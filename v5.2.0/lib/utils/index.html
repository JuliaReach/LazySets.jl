<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Utilities · LazySets.jl</title><meta name="title" content="Utilities · LazySets.jl"/><meta property="og:title" content="Utilities · LazySets.jl"/><meta property="twitter:title" content="Utilities · LazySets.jl"/><meta name="description" content="Documentation for LazySets.jl."/><meta property="og:description" content="Documentation for LazySets.jl."/><meta property="twitter:description" content="Documentation for LazySets.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/aligned.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LazySets.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../man/optional_dependencies/">Optional Features</a></li><li><a class="tocitem" href="../../man/tour/">A Tour of LazySets</a></li><li><a class="tocitem" href="../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../man/unary_set_operations/">Unary Operations on Sets</a></li><li><a class="tocitem" href="../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../API/">API</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Set Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../interfaces/overview/">Overview</a></li><li><a class="tocitem" href="../interfaces/LazySet/">General sets (LazySet)</a></li><li><a class="tocitem" href="../interfaces/ConvexSet/">Convex sets (ConvexSet)</a></li><li><a class="tocitem" href="../interfaces/AbstractCentrallySymmetric/">Centrally symmetric sets (AbstractCentrallySymmetric)</a></li><li><a class="tocitem" href="../interfaces/AbstractPolyhedron/">Polyhedra (AbstractPolyhedron)</a></li><li><a class="tocitem" href="../interfaces/AbstractPolytope/">Polytopes (AbstractPolytope)</a></li><li><a class="tocitem" href="../interfaces/AbstractPolygon/">Polygons (AbstractPolygon)</a></li><li><a class="tocitem" href="../interfaces/AbstractHPolygon/">Polygons in constraint representation (AbstractHPolygon)</a></li><li><a class="tocitem" href="../interfaces/AbstractCentrallySymmetricPolytope/">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a></li><li><a class="tocitem" href="../interfaces/AbstractZonotope/">Zonotopes (AbstractZonotope)</a></li><li><a class="tocitem" href="../interfaces/AbstractHyperrectangle/">Hyperrectangles (AbstractHyperrectangle)</a></li><li><a class="tocitem" href="../interfaces/AbstractSingleton/">Singletons (AbstractSingleton)</a></li><li><a class="tocitem" href="../interfaces/AbstractAffineMap/">Affine maps (AbstractAffineMap)</a></li><li><a class="tocitem" href="../interfaces/AbstractPolynomialZonotope/">Polynomial zonotope sets (AbstractPolynomialZonotope)</a></li><li><a class="tocitem" href="../interfaces/AbstractSparsePolynomialZonotope/">Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)</a></li><li><a class="tocitem" href="../interfaces/AbstractBallp/">Balls in the p-norm (AbstractBallp)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../sets/DensePolynomialZonotope/">DensePolynomialZonotope</a></li><li><a class="tocitem" href="../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../sets/HParallelotope/">HParallelotope</a></li><li><a class="tocitem" href="../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../sets/Line/">Line</a></li><li><a class="tocitem" href="../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../sets/Polygon/">Polygon</a></li><li><a class="tocitem" href="../sets/SimpleSparsePolynomialZonotope/">SimpleSparsePolynomialZonotope</a></li><li><a class="tocitem" href="../sets/SparsePolynomialZonotope/">SparsePolynomialZonotope</a></li><li><a class="tocitem" href="../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../sets/Star/">Star</a></li><li><a class="tocitem" href="../sets/Tetrahedron/">Tetrahedron</a></li><li><a class="tocitem" href="../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../sets/Zonotope/">Zonotope</a></li><li><a class="tocitem" href="../sets/ZonotopeMD/">ZonotopeMD</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lazy_operations/AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../lazy_operations/Bloating/">Bloating</a></li><li><a class="tocitem" href="../lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../lazy_operations/Complement/">Complement</a></li><li><a class="tocitem" href="../lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../lazy_operations/Intersection/">Intersection</a></li><li><a class="tocitem" href="../lazy_operations/LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../lazy_operations/InverseLinearMap/">InverseLinearMap</a></li><li><a class="tocitem" href="../lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../lazy_operations/QuadraticMap/">QuadraticMap</a></li><li><a class="tocitem" href="../lazy_operations/Rectification/">Rectification</a></li><li><a class="tocitem" href="../lazy_operations/ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../lazy_operations/Translation/">Translation</a></li><li><a class="tocitem" href="../lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Concrete Binary Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../concrete_binary_operations/overview/">Binary set operations</a></li><li><a class="tocitem" href="../concrete_binary_operations/cartesian_product/">Cartesian Product</a></li><li><a class="tocitem" href="../concrete_binary_operations/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../concrete_binary_operations/difference/">Set difference</a></li><li><a class="tocitem" href="../concrete_binary_operations/distance/">Distance</a></li><li><a class="tocitem" href="../concrete_binary_operations/intersection/">Intersection of two sets</a></li><li><a class="tocitem" href="../concrete_binary_operations/minkowski_sum/">Minkowski Sum</a></li><li><a class="tocitem" href="../concrete_binary_operations/minkowski_difference/">Minkowski Difference</a></li><li><a class="tocitem" href="../concrete_binary_operations/isdisjoint/">Check for Disjointness of Sets</a></li><li><a class="tocitem" href="../concrete_binary_operations/issubset/">Subset Check</a></li></ul></li><li><a class="tocitem" href="../conversion/">Conversions between set representations</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Approximations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../approximations/overview/">Overview</a></li><li><a class="tocitem" href="../approximations/overapproximate/">Overapproximation</a></li><li><a class="tocitem" href="../approximations/box_approximation/">Box Approximation</a></li><li><a class="tocitem" href="../approximations/iterative_refinement/">Iterative refinement</a></li><li><a class="tocitem" href="../approximations/template_directions/">Template directions</a></li><li><a class="tocitem" href="../approximations/underapproximate/">Underapproximation</a></li><li><a class="tocitem" href="../approximations/approximate/">Approximation</a></li><li><a class="tocitem" href="../approximations/decompose/">Cartesian Decomposition</a></li><li><a class="tocitem" href="../approximations/hausdorff_distance/">Hausdorff Distance</a></li><li><a class="tocitem" href="../approximations/overapproximate_norm/">Norm Overapproximation</a></li><li><a class="tocitem" href="../approximations/overapproximate_expmap/">Overapproximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">MatrixSets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../matrixsets/MatrixZonotope/">MatrixZonotope</a></li></ul></li><li class="is-active"><a class="tocitem" href>Utilities</a><ul class="internal"><li><a class="tocitem" href="#Array-set-types"><span>Array set types</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Inspection-of-set-interfaces"><span>Inspection of set interfaces</span></a></li><li><a class="tocitem" href="#Polyhedra"><span>Polyhedra</span></a></li><li><a class="tocitem" href="#File-formats"><span>File formats</span></a></li><li><a class="tocitem" href="#Sampling"><span>Sampling</span></a></li><li><a class="tocitem" href="#Symbolics"><span>Symbolics</span></a></li><li><a class="tocitem" href="#SymEngine"><span>SymEngine</span></a></li><li><a class="tocitem" href="#Functions-for-numbers"><span>Functions for numbers</span></a></li><li><a class="tocitem" href="#Other-functions"><span>Other functions</span></a></li></ul></li><li><a class="tocitem" href="../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Utilities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Utilities</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/utils.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h1><h2 id="Array-set-types"><a class="docs-heading-anchor" href="#Array-set-types">Array set types</a><a id="Array-set-types-1"></a><a class="docs-heading-anchor-permalink" href="#Array-set-types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="LazySets.flatten"><a class="docstring-binding" href="#LazySets.flatten"><code>LazySets.flatten</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">flatten(X::LazySets.AbstractArraySet)</code></pre><p>Flatten an array set, i.e., resolve potential nestings.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; E1 = EmptySet(1); E2 = EmptySet(2); E3 = EmptySet(3);

julia&gt; X = MinkowskiSumArray([E1, MinkowskiSumArray([E2, E2])])
MinkowskiSumArray{Float64, LazySet{Float64}}(LazySet{Float64}[∅(1), MinkowskiSumArray{Float64, ∅}(∅[∅(2), ∅(2)])])

julia&gt; flatten(X)
MinkowskiSumArray{Float64, ∅}(∅[∅(1), ∅(2), ∅(2)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Interfaces/AbstractArraySet.jl#L27-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.neutral"><a class="docstring-binding" href="#LazySets.neutral"><code>LazySets.neutral</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">neutral(T::Type{&lt;:LazySet})</code></pre><p>Get the neutral set type for a lazy binary operation, if any.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/macros.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.absorbing"><a class="docstring-binding" href="#LazySets.absorbing"><code>LazySets.absorbing</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">absorbing(T::Type{&lt;:LazySet})</code></pre><p>Get the absorbing set type for a lazy binary operation, if any.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/macros.jl#L78-L82">source</a></section></details></article><h3 id="Internal-helper-macros"><a class="docs-heading-anchor" href="#Internal-helper-macros">Internal helper macros</a><a id="Internal-helper-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-helper-macros" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="LazySets.@neutral"><a class="docstring-binding" href="#LazySets.@neutral"><code>LazySets.@neutral</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@neutral(SET, NEUT)</code></pre><p>Create methods to make a lazy set operation commutative with a given neutral-element set type.</p><p><strong>Input</strong></p><ul><li><code>SET</code>  – set type of lazy operation</li><li><code>NEUT</code> – set type of neutral element</li></ul><p><strong>Output</strong></p><p>Nothing.</p><p><strong>Notes</strong></p><p>This macro generates four functions (possibly two more if <code>@absorbing</code> has been used in advance, and possibly two or four more if <code>@declare_array_version</code> has been used in advance).</p><p><strong>Examples</strong></p><p><code>@neutral(MinkowskiSum, N)</code> creates at least the following methods:</p><ul><li><code>neutral(::MinkowskiSum) = N</code></li><li><code>MinkowskiSum(X, N) = X</code></li><li><code>MinkowskiSum(N, X) = X</code></li><li><code>MinkowskiSum(N, N) = N</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/macros.jl#L8-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.@absorbing"><a class="docstring-binding" href="#LazySets.@absorbing"><code>LazySets.@absorbing</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@absorbing(SET, ABS)</code></pre><p>Create methods to make a lazy set operation commutative with a given absorbing-element set type.</p><p><strong>Input</strong></p><ul><li><code>SET</code> – set type of lazy operation</li><li><code>ABS</code> – set type of absorbing element</li></ul><p><strong>Output</strong></p><p>Nothing.</p><p><strong>Notes</strong></p><p>This macro generates four functions (possibly two more if <code>@neutral</code> has been used in advance, and possibly two or four more if <code>@declare_array_version</code> has been used in advance).</p><p><strong>Examples</strong></p><p><code>@absorbing(MinkowskiSum, A)</code> creates at least the following methods:</p><ul><li><code>absorbing(::MinkowskiSum) = A</code></li><li><code>MinkowskiSum(X, A) = A</code></li><li><code>MinkowskiSum(A, X) = A</code></li><li><code>MinkowskiSum(A, A) = A</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/macros.jl#L85-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.@neutral_absorbing"><a class="docstring-binding" href="#LazySets.@neutral_absorbing"><code>LazySets.@neutral_absorbing</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@neutral_absorbing(SET, NEUT, ABS)</code></pre><p>Create two methods to avoid method ambiguities for a lazy set operation with respect to neutral-element and absorbing-element set types.</p><p><strong>Input</strong></p><ul><li><code>SET</code>  – set type of lazy operation</li><li><code>NEUT</code> – set type of neutral element</li><li><code>ABS</code>  – set type of absorbing element</li></ul><p><strong>Output</strong></p><p>A quoted expression containing the function definitions.</p><p><strong>Notes</strong></p><p>This macro is used internally in other macros.</p><p><strong>Examples</strong></p><p><code>@neutral_absorbing(MinkowskiSum, N, A)</code> creates the following methods as quoted expressions:</p><ul><li><code>MinkowskiSum(N, A) = A</code></li><li><code>MinkowskiSum(A, N) = A</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/macros.jl#L348-L374">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.@declare_binary_operation"><a class="docstring-binding" href="#LazySets.@declare_binary_operation"><code>LazySets.@declare_binary_operation</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@declare_binary_operation(SET)</code></pre><p>Create common methods for binary set operations.</p><p><strong>Input</strong></p><ul><li><code>SET</code> – set type of the lazy operation</li></ul><p><strong>Output</strong></p><p>Nothing.</p><p><strong>Notes</strong></p><p>This macro generates seven methods. See the example below.</p><p><strong>Examples</strong></p><p><code>@declare_binary_operation(MinkowskiSum)</code> creates the following methods:</p><ul><li><code>iterate(::MinkowskiSum)</code></li><li><code>length(::MinkowskiSum)</code></li><li><code>getindex(::MinkowskiSum, ::Int)</code></li><li><code>getindex(::MinkowskiSum, ::AbstractVector{Int})</code></li><li><code>lastindex(::MinkowskiSum)</code></li><li><code>array(::MinkowskiSum)</code></li><li><code>is_array_constructor(::Type{MinkowskiSum})</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/macros.jl#L155-L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.@declare_array_version"><a class="docstring-binding" href="#LazySets.@declare_array_version"><code>LazySets.@declare_array_version</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@declare_array_version(SET, SETARR)</code></pre><p>Create methods to connect a lazy set operation with its array set type.</p><p><strong>Input</strong></p><ul><li><code>SET</code>    – set type of lazy operation</li><li><code>SETARR</code> – set type of array version</li></ul><p><strong>Output</strong></p><p>Nothing.</p><p><strong>Notes</strong></p><p>This macro generates six methods (and possibly up to eight more if <code>@neutral</code>/<code>@absorbing</code> has been used in advance for the base and/or array set type). See the example below.</p><p><strong>Examples</strong></p><p><code>@declare_array_version(MinkowskiSum, MinkowskiSumArray)</code> creates at least the following methods:</p><ul><li><code>array_constructor(::Type{MinkowskiSum}) = MinkowskiSumArray</code></li><li><code>binary_constructor(::Type{MinkowskiSumArray}) = MinkowskiSum</code></li><li><code>is_array_constructor(::Type{MinkowskiSumArray}) = true</code></li><li><code>MinkowskiSum!(X, Y)</code></li><li><code>MinkowskiSum!(X, arr)</code></li><li><code>MinkowskiSum!(arr, X)</code></li><li><code>MinkowskiSum!(arr1, arr2)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/macros.jl#L238-L269">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.@array_neutral"><a class="docstring-binding" href="#LazySets.@array_neutral"><code>LazySets.@array_neutral</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@array_neutral(FUN, NEUT, SETARR)</code></pre><p>Create two methods to avoid method ambiguities for a lazy set operation with respect to the neutral-element set type and the array set type.</p><p><strong>Input</strong></p><ul><li><code>FUN</code>     – function name</li><li><code>NEUT</code>    – set type of neutral element</li><li><code>SETARR</code>  – set type of array version</li></ul><p><strong>Output</strong></p><p>A quoted expression containing the function definitions.</p><p><strong>Examples</strong></p><p><code>@array_neutral(MinkowskiSum, N, ARR)</code> creates the following methods as quoted expressions:</p><ul><li><code>MinkowskiSum(N, ARR) = ARR</code></li><li><code>MinkowskiSum(ARR, N) = ARR</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/macros.jl#L386-L408">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.@array_absorbing"><a class="docstring-binding" href="#LazySets.@array_absorbing"><code>LazySets.@array_absorbing</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@array_absorbing(FUN, ABS, SETARR)</code></pre><p>Create two methods to avoid method ambiguities for a lazy set operation with respect to the absorbing-element set type and the array set type.</p><p><strong>Input</strong></p><ul><li><code>FUN</code>     – function name</li><li><code>ABS</code>     – set type of absorbing element</li><li><code>SETARR</code>  – set type of array version</li></ul><p><strong>Output</strong></p><p>A quoted expression containing the function definitions.</p><p><strong>Examples</strong></p><p><code>@array_absorbing(MinkowskiSum, ABS, ARR)</code> creates the following methods as quoted expressions:</p><ul><li><code>MinkowskiSum(ABS, ARR) = ABS</code></li><li><code>MinkowskiSum(ARR, ABS) = ABS</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/macros.jl#L420-L442">source</a></section></details></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="LazySets.CachedPair"><a class="docstring-binding" href="#LazySets.CachedPair"><code>LazySets.CachedPair</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CachedPair{N}</code></pre><p>A mutable pair of an index and a vector.</p><p><strong>Fields</strong></p><ul><li><code>idx</code> – index</li><li><code>vec</code> – vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/LazyOperations/CachedMinkowskiSumArray.jl#L4-L13">source</a></section></details></article><h2 id="Inspection-of-set-interfaces"><a class="docs-heading-anchor" href="#Inspection-of-set-interfaces">Inspection of set interfaces</a><a id="Inspection-of-set-interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Inspection-of-set-interfaces" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="LazySets.implementing_sets"><a class="docstring-binding" href="#LazySets.implementing_sets"><code>LazySets.implementing_sets</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">implementing_sets(op::Function;
                  signature::Tuple{Vector{Type}, Int}=(Type[], 1),
                  type_args=Float64, binary::Bool=false)</code></pre><p>Compute a dictionary containing information about availability of (unary or binary) concrete set operations.</p><p><strong>Input</strong></p><ul><li><code>op</code>        – set operation (respectively its <code>Function</code> object)</li><li><code>signature</code> – (optional, default: <code>Type[]</code>) the type signature of the                function without the <code>LazySet</code> type(s) (see also the <code>index</code>                option and the <code>Examples</code> section below)</li><li><code>index</code>     – (optional, default: <code>1</code>) index of the set type in the signature                in the unary case (see the <code>binary</code> option)</li><li><code>type_args</code> – (optional, default: <code>Float64</code>) type arguments added to the                <code>LazySet</code>(s) when searching for available methods; valid                inputs are a type or <code>nothing</code>, and in the unary case (see the                <code>binary</code> option) it can also be a list of types</li><li><code>binary</code>    – (optional, default: <code>false</code>) flag indicating whether <code>op</code> is a                binary function (<code>true</code>) or a unary function (<code>false</code>)</li></ul><p><strong>Output</strong></p><p>A dictionary with three keys each mapping to a list:</p><ul><li><code>&quot;available&quot;</code> – This list contains all set types such that there exists an                  implementation of <code>op</code>.</li><li><code>&quot;missing&quot;</code>   – This list contains all set types such that there does not                  exist an implementation of <code>op</code>. Note that this is the                  complement of the <code>&quot;available&quot;</code> list.</li><li><code>&quot;specific&quot;</code>  – This list contains all set types such that there exists a                  type-specific implementation. Note that those set types also                  occur in the <code>&quot;available&quot;</code> list.</li></ul><p>In the unary case, the lists contain set types. In the binary case, the lists contain pairs of set types.</p><p><strong>Examples</strong></p><p><code>shape_matrix</code> is only available for ellipsoids.</p><pre><code class="language-julia-repl hljs">julia&gt; using LazySets: implementing_sets

julia&gt; dict = implementing_sets(shape_matrix);

julia&gt; dict[&quot;available&quot;]
1-element Vector{Type}:
 Ellipsoid</code></pre><p>Every convex set type implements the function <code>σ</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; dict = implementing_sets(σ; signature=Type[AbstractVector], index=2);

julia&gt; dict[&quot;missing&quot;]
5-element Vector{Type}:
 Complement
 DensePolynomialZonotope
 QuadraticMap
 SimpleSparsePolynomialZonotope
 SparsePolynomialZonotope</code></pre><p>Some operations are not available for sets with rational numbers.</p><pre><code class="language-julia-repl hljs">julia&gt; N = Rational{Int};

julia&gt; dict = implementing_sets(σ; signature=Type[AbstractVector{N}], index=2, type_args=N);

julia&gt; Ball2 ∈ dict[&quot;missing&quot;]
true</code></pre><p>For binary functions, the dictionary contains pairs of set types. This check takes several seconds because it considers all possible set-type combinations.</p><pre><code class="language-julia-repl hljs">julia&gt; dict = LazySets.implementing_sets(convex_hull; binary=true);

julia&gt; (HPolytope, HPolytope) ∈ dict[&quot;available&quot;]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/helper_functions.jl#L1-L88">source</a></section></details></article><h2 id="Polyhedra"><a class="docs-heading-anchor" href="#Polyhedra">Polyhedra</a><a id="Polyhedra-1"></a><a class="docs-heading-anchor-permalink" href="#Polyhedra" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="LazySets.isfeasible"><a class="docstring-binding" href="#LazySets.isfeasible"><code>LazySets.isfeasible</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isfeasible(A::AbstractMatrix, b::AbstractVector, [witness]::Bool=false;
           [solver]=nothing)</code></pre><p>Check for feasibility of linear constraints given in matrix-vector form.</p><p><strong>Input</strong></p><ul><li><code>A</code>       – constraints matrix</li><li><code>b</code>       – constraints vector</li><li><code>witness</code> – (optional; default: <code>false</code>) flag for witness production</li><li><code>solver</code>  – (optional; default: <code>nothing</code>) LP solver</li></ul><p><strong>Output</strong></p><p>If <code>witness</code> is <code>false</code>, the result is a <code>Bool</code>.</p><p>If <code>witness</code> is <code>true</code>, the result is a pair <code>(res, w)</code> where <code>res</code> is a <code>Bool</code> and <code>w</code> is a witness point/vector.</p><p><strong>Algorithm</strong></p><p>This implementation solves the corresponding feasibility linear program.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/lp_solvers.jl#L40-L63">source</a></section></details></article><h2 id="File-formats"><a class="docs-heading-anchor" href="#File-formats">File formats</a><a id="File-formats-1"></a><a class="docs-heading-anchor-permalink" href="#File-formats" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="LazySets.read_gen-Tuple{String}"><a class="docstring-binding" href="#LazySets.read_gen-Tuple{String}"><code>LazySets.read_gen</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_gen(filename::String)</code></pre><p>Read a sequence of polygons stored in vertex representation (gen format).</p><p><strong>Input</strong></p><ul><li><code>filename</code> – path of the file containing the polygons</li></ul><p><strong>Output</strong></p><p>A list of polygons in vertex representation.</p><p><strong>Notes</strong></p><p>The <code>x</code> and <code>y</code> coordinates of each vertex should be separated by an empty space and polygons are separated by empty lines (even the last polygon). For example:</p><pre><code class="language-julia hljs">1.01 1.01
0.99 1.01
0.99 0.99
1.01 0.99

0.908463 1.31047
0.873089 1.31047
0.873089 1.28452
0.908463 1.28452

</code></pre><p>This is parsed as</p><pre><code class="language-julia hljs">2-element Array{VPolygon{Float64, Vector{Float64}},1}:
 VPolygon{Float64, Vector{Float64}}([[1.01, 1.01], [0.99, 1.01], [0.99, 0.99], [1.01, 0.99]])
 VPolygon{Float64, Vector{Float64}}([[0.908463, 1.31047], [0.873089, 1.31047], [0.873089, 1.28452], [0.908463, 1.28452]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/file_formats.jl#L1-L39">source</a></section></details></article><h2 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="LazySets._sample_unit_nsphere_muller!"><a class="docstring-binding" href="#LazySets._sample_unit_nsphere_muller!"><code>LazySets._sample_unit_nsphere_muller!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_sample_unit_nsphere_muller!(D::Vector{Vector{N}}, n::Int, p::Int;
                             [rng]::AbstractRNG=GLOBAL_RNG,
                             [seed]::Union{Int, Nothing}=nothing) where {N}</code></pre><p>Draw samples from a uniform distribution on an <span>$n$</span>-dimensional unit sphere using Muller&#39;s method.</p><p><strong>Input</strong></p><ul><li><code>D</code>    – output, vector of points</li><li><code>n</code>    – dimension of the sphere</li><li><code>p</code>    – number of random samples</li><li><code>rng</code>  – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code> – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>The modified vector <code>D</code>.</p><p><strong>Algorithm</strong></p><p>This function implements Muller&#39;s method of normalized Gaussians <a href="../../bibliography/#Muller59">Muller [Mul59]</a> to uniformly sample over the <span>$n$</span>-dimensional sphere <span>$S^n$</span> (which is the bounding surface of the <span>$n$</span>-dimensional unit ball).</p><p>Given <span>$n$</span> canonical Gaussian random variables <span>$Z₁, Z₂, …, Z_n$</span>, the distribution of the vectors</p><p class="math-container">\[\dfrac{1}{α}\left(z₁, z₂, …, z_n\right)^T,\]</p><p>where <span>$α := \sqrt{z₁² + z₂² + … + z_n²}$</span>, is uniform over <span>$S^n$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/samples.jl#L661-L694">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.API.sample"><a class="docstring-binding" href="#LazySets.API.sample"><code>LazySets.API.sample</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sample(X::LazySet, [m]::Int=1;
       [rng]::AbstractRNG=GLOBAL_RNG,
       [seed]::Union{Int,Nothing}=nothing)</code></pre><p>Compute random samples from a set.</p><p><strong>Input</strong></p><ul><li><code>X</code>    – set</li><li><code>m</code>    – (optional; default: 1) number of random samples</li><li><code>rng</code>  – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code> – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A vector of <code>m</code> elements in <code>X</code> if <code>X</code> is nonempty, and an error otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/API/Mixed/sample.jl#L1-L18">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="language-julia hljs">sample(B::Ball2, [nsamples]::Int;
       [rng]::AbstractRNG=GLOBAL_RNG,
       [seed]::Union{Int, Nothing}=nothing)</code></pre><p><strong>Algorithm</strong></p><p>Random sampling with uniform distribution in <code>B</code> is computed using Muller&#39;s method of normalized Gaussians. This method requires the package <code>Distributions</code>. See <a href="../sets/Ball2/#LazySets.Ball2Module._sample_unit_nball_muller!"><code>_sample_unit_nball_muller!</code></a> for implementation details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Sets/Ball2/sample.jl#L1-L13">source</a></section><section><div><pre><code class="language-julia hljs">sample(X::LazySet{N}, num_samples::Int;
       [sampler]=_default_sampler(X),
       [rng]::AbstractRNG=GLOBAL_RNG,
       [seed]::Union{Int, Nothing}=nothing,
       [include_vertices]=false,
       [VN]=Vector{N}) where {N}</code></pre><p>Random sampling of an arbitrary set <code>X</code>.</p><p><strong>Input</strong></p><ul><li><code>X</code>           – set to be sampled</li><li><code>num_samples</code> – number of random samples</li><li><code>sampler</code>     – (optional, default: <code>_default_sampler(X)</code>) the sampler used;                  falls back to <a href="#LazySets.CombinedSampler"><code>CombinedSampler</code></a></li><li><code>rng</code>         – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>        – (optional, default: <code>nothing</code>) seed for reseeding</li><li><code>include_vertices</code> – (optional, default: <code>false</code>) option to include the                  vertices of <code>X</code></li><li><code>VN</code>          – (optional, default: <code>Vector{N}</code>) vector type of the sampled                  points</li></ul><p><strong>Output</strong></p><p>A vector of <code>num_samples</code> vectors. If <code>num_samples</code> is not passed, the result is just one sample (not wrapped in a vector).</p><p><strong>Algorithm</strong></p><p>See the documentation of the respective <code>Sampler</code>.</p><p><strong>Notes</strong></p><p>If <code>include_vertices == true</code>, we include all vertices computed with <code>vertices</code>. Alternatively if a number <span>$k$</span> is passed, we plot the first <span>$k$</span> vertices returned by <code>vertices(X)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/samples.jl#L18-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.AbstractSampler"><a class="docstring-binding" href="#LazySets.AbstractSampler"><code>LazySets.AbstractSampler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractSampler</code></pre><p>Abstract type for defining new sampling methods.</p><p><strong>Notes</strong></p><p>All subtypes should implement a <code>sample!(D, X, ::Method)</code> method where the first argument is the output (vector of vectors), the second argument is the set to be sampled, and the third argument is the sampler instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/samples.jl#L5-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.CombinedSampler"><a class="docstring-binding" href="#LazySets.CombinedSampler"><code>LazySets.CombinedSampler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CombinedSampler &lt;: AbstractSampler</code></pre><p>Type used for sampling arbitrary sets by trying different sampling strategies.</p><p><strong>Algorithm</strong></p><p>The algorithm is to first try a <a href="#LazySets.RejectionSampler"><code>RejectionSampler</code></a> 10 times. If that fails, it tries a <a href="#LazySets.RandomWalkSampler"><code>RandomWalkSampler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/samples.jl#L299-L308">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.FaceSampler"><a class="docstring-binding" href="#LazySets.FaceSampler"><code>LazySets.FaceSampler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FaceSampler &lt;: AbstractSampler</code></pre><p>Type used for sampling from the <code>k</code>-faces of a set.</p><p><strong>Fields</strong></p><ul><li><code>dim</code> – dimension of the faces to be sampled; a negative number is          interpreted as <code>n - dim</code> where <code>n</code> is the dimension of the set</li></ul><p><strong>Notes</strong></p><p>For a three-dimensional polytope, the following face dimensions exist:</p><ul><li>3-face – the polytope itself</li><li>2-faces – 2-dimensional polygonal faces</li><li>1-faces – 1-dimensional edges</li><li>0-faces – 0-dimensional vertices</li></ul><p>For more information see <a href="https://en.wikipedia.org/wiki/Face_(geometry)#k-face">Wikipedia</a>.</p><p><strong>Algorithm</strong></p><p>Currently only hyperrectangles are supported. For each point to be sampled, we randomly split the integers <code>1 .. n</code> into two subgroups of size <code>k</code> and <code>n-k</code> respectively. For the i-th coordinate in the first group, we sample in the interval <code>low(H, i) .. high(H, i)</code>. For the i-th coordinate in the second group, we randomly pick either <code>low(H, i)</code> or <code>high(H, i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/samples.jl#L337-L366">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.HalfSpaceSampler"><a class="docstring-binding" href="#LazySets.HalfSpaceSampler"><code>LazySets.HalfSpaceSampler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HalfSpaceSampler{D} &lt;: AbstractSampler</code></pre><p>Type used for sampling from a half-space.</p><p><strong>Fields</strong></p><ul><li><code>distribution</code> – (optional, default: <code>nothing</code>) distribution from which                   samples are drawn</li></ul><p><strong>Notes</strong></p><p>If <code>distribution</code> is <code>nothing</code> (default), the sampling algorithm uses a <code>DefaultUniform</code> over <span>$[0, 1]^n$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/samples.jl#L425-L439">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.HyperplaneSampler"><a class="docstring-binding" href="#LazySets.HyperplaneSampler"><code>LazySets.HyperplaneSampler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HyperplaneSampler{D} &lt;: AbstractSampler</code></pre><p>Type used for sampling from a hyperplane.</p><p><strong>Fields</strong></p><ul><li><code>distribution</code> – (optional, default: <code>nothing</code>) distribution from which                   samples are drawn</li></ul><p><strong>Notes</strong></p><p>If <code>distribution</code> is <code>nothing</code> (default), the sampling algorithm uses a <code>DefaultUniform</code> over <span>$[0, 1]^n$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/samples.jl#L469-L483">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.SingletonSampler"><a class="docstring-binding" href="#LazySets.SingletonSampler"><code>LazySets.SingletonSampler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SingletonSampler &lt;: AbstractSampler</code></pre><p>Type used for sampling from a singleton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/samples.jl#L511-L515">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.RejectionSampler"><a class="docstring-binding" href="#LazySets.RejectionSampler"><code>LazySets.RejectionSampler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RejectionSampler{D} &lt;: AbstractSampler</code></pre><p>Type used for rejection sampling of a bounded set <code>X</code>.</p><p><strong>Fields</strong></p><ul><li><code>distribution</code> – (optional, default: <code>DefaultUniform</code>) distribution from                   which the sample is drawn</li><li><code>tight</code>        – (optional, default: <code>false</code>) set to <code>true</code> if the support of                   the distribution is known to coincide with the set <code>X</code></li><li><code>maxiter</code>      – (optional, default: <code>Inf</code>) maximum number of iterations                   before giving up</li></ul><p><strong>Algorithm</strong></p><p>Draw a sample <span>$x$</span> from a given distribution of a box-overapproximation of the original set <span>$X$</span> in all <span>$n$</span> dimensions. The function rejects a drawn sample <span>$x$</span> and redraws as long as the sample is not contained in the original set <span>$X$</span>, i.e., while <span>$x ∉ X$</span>.</p><p><strong>Notes</strong></p><p>The <code>maxiter</code> parameter is useful when sampling from sets that are small compared to their box approximation, e.g., flat sets, for which the probability of sampling from within the set is close to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/samples.jl#L110-L136">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.RandomWalkSampler"><a class="docstring-binding" href="#LazySets.RandomWalkSampler"><code>LazySets.RandomWalkSampler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RandomWalkSampler &lt;: AbstractSampler</code></pre><p>Type used for sampling from a convex polytope using its vertex representation. This is especially useful if rejection sampling does not work because the polytope is flat.</p><p><strong>Fields</strong></p><ul><li><code>variant</code> – (optional, default: <code>true</code>) choice of a variant (see below)</li></ul><p><strong>Notes</strong></p><p>The sampling is not uniform - points in the center of the polytope are more likely to be sampled.</p><p>The set to be sampled from must provide its vertices via <code>vertices_list</code>.</p><p><strong>Algorithm</strong></p><p>Choose a random convex combination of the vertices of a convex polytope <code>X</code>.</p><p>If <code>variant == false</code>, we proceed as follows. Let <span>$V = \{v_i\}_i$</span> denote the set of vertices of <code>X</code>. Then any point <span>$p ∈ ℝ^n$</span> of the convex polytope <span>$X$</span> is a convex combination of its vertices, i.e., <span>$p = ∑_{i} v_i α_i$</span> for some (non-negative) coefficients <span>$\{α_i\}_i$</span> that add up to 1. The algorithm chooses a random convex combination (the <span>$α_i$</span>). To produce this combination, we apply the finite-difference operator on a sorted uniform sample over <span>$[0, 1]$</span>; the method can be found in <a href="../../bibliography/#Rubin81">Rubin [Rub81]</a> and <a href="https://cs.stackexchange.com/a/3229">this StackExchange post</a>.</p><p>If <code>variant == true</code>, we start from a random vertex and then repeatedly walk toward a random vertex inside the polytope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/samples.jl#L222-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.PolynomialZonotopeSampler"><a class="docstring-binding" href="#LazySets.PolynomialZonotopeSampler"><code>LazySets.PolynomialZonotopeSampler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PolynomialZonotopeSampler{D} &lt;: AbstractSampler</code></pre><p>Type used for sampling from polynomial zonotopes.</p><p><strong>Fields</strong></p><ul><li><code>distribution</code> – (optional, default: <code>nothing</code>) distribution from which                   samples are drawn</li></ul><p><strong>Notes</strong></p><p>If <code>distribution</code> is <code>nothing</code> (default), the sampling algorithm uses a <code>DefaultUniform</code> over <span>$[-1, 1]^n$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/samples.jl#L528-L542">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.UniverseSampler"><a class="docstring-binding" href="#LazySets.UniverseSampler"><code>LazySets.UniverseSampler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UniverseSampler{D} &lt;: AbstractSampler</code></pre><p>Type used for sampling from universal sets.</p><p><strong>Fields</strong></p><ul><li><code>distribution</code> – (optional, default: <code>nothing</code>) distribution from which                   samples are drawn</li></ul><p><strong>Notes</strong></p><p>If <code>distribution</code> is <code>nothing</code> (default), the sampling algorithm uses a <code>DefaultUniform</code> over <span>$[-100, 100]^n$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/samples.jl#L619-L633">source</a></section></details></article><h2 id="Symbolics"><a class="docs-heading-anchor" href="#Symbolics">Symbolics</a><a id="Symbolics-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolics" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="LazySets._vec"><a class="docstring-binding" href="#LazySets._vec"><code>LazySets._vec</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_vec(vars)</code></pre><p>Transform a tuple of operations into one vector of operations.</p><p><strong>Input</strong></p><ul><li><code>vars</code> – tuple where each element is either variable-like (<code>Num</code>) or a           vector of variables (<code>Vector{Num}</code>)</li></ul><p><strong>Output</strong></p><p>A vector of <code>Operation</code> obtained by concatenating each tuple component.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Symbolics

julia&gt; vars = @variables x[1:2] y
2-element Vector{Any}:
  x[1:2]
 y

julia&gt; LazySets._vec(vars)
3-element Vector{Num}:
 x[1]
 x[2]
    y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/helper_functions.jl#L227-L257">source</a></section></details></article><h2 id="SymEngine"><a class="docs-heading-anchor" href="#SymEngine">SymEngine</a><a id="SymEngine-1"></a><a class="docs-heading-anchor-permalink" href="#SymEngine" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SymEngine.free_symbols"><a class="docstring-binding" href="#SymEngine.free_symbols"><code>SymEngine.free_symbols</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">free_symbols(expr::Expr, set_type::Type{LazySet})</code></pre><p>Return the free symbols in an expression that represents a given set type.</p><p><strong>Input</strong></p><ul><li><code>expr</code> – symbolic expression</li></ul><p><strong>Output</strong></p><p>A list of symbols, in the form of SymEngine <code>Basic</code> objects.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LazySets: free_symbols

julia&gt; free_symbols(:(x1 &lt;= -0.03), HalfSpace)
1-element Vector{SymEngine.Basic}:
 x1

julia&gt; free_symbols(:(x1 + x2 &lt;= 2*x4 + 6), HalfSpace)
3-element Vector{SymEngine.Basic}:
 x2
 x1
 x4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Initialization/init_SymEngine.jl#L41-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets._is_linear_combination"><a class="docstring-binding" href="#LazySets._is_linear_combination"><code>LazySets._is_linear_combination</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><em>is</em>linear_combination(L::Basic)</p><p>Determine whether the expression <code>L</code> is a linear combination of its symbols.</p><p><strong>Input</strong></p><ul><li><code>L</code> – expression</li></ul><p><strong>Output</strong></p><p><code>true</code> if <code>L</code> is a linear combination or false otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LazySets: _is_linear_combination

julia&gt; _is_linear_combination(:(2*x1 - 4))
true

julia&gt; _is_linear_combination(:(6.1 - 5.3*f - 0.1*g))
true

julia&gt; _is_linear_combination(:(2*x1^2))
false

julia&gt; _is_linear_combination(:(x1^2 - 4*x2 + x3 + 2))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Initialization/init_SymEngine.jl#L4-L34">source</a></section></details></article><h2 id="Functions-for-numbers"><a class="docs-heading-anchor" href="#Functions-for-numbers">Functions for numbers</a><a id="Functions-for-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-for-numbers" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="LazySets.sign_cadlag"><a class="docstring-binding" href="#LazySets.sign_cadlag"><code>LazySets.sign_cadlag</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sign_cadlag(x::Real)</code></pre><p>This function works like the sign function but is <span>$1$</span> for input <span>$0$</span>.</p><p><strong>Input</strong></p><ul><li><code>x</code> – real scalar</li></ul><p><strong>Output</strong></p><p><span>$1$</span> if <span>$x ≥ 0$</span>, <span>$-1$</span> otherwise.</p><p><strong>Notes</strong></p><p>This is the sign function right-continuous at zero (see <a href="https://en.wikipedia.org/wiki/C%C3%A0dl%C3%A0g">càdlàg function</a>). It can be used with vector-valued arguments via the dot operator.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LazySets.sign_cadlag.([-0.6, 1.3, 0.0])
3-element Vector{Float64}:
 -1.0
  1.0
  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Utils/numbers.jl#L1-L29">source</a></section></details></article><h2 id="Other-functions"><a class="docs-heading-anchor" href="#Other-functions">Other functions</a><a id="Other-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="LazySets.binary_search_constraints"><a class="docstring-binding" href="#LazySets.binary_search_constraints"><code>LazySets.binary_search_constraints</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">binary_search_constraints(d::AbstractVector{N},
                          constraints::Vector{&lt;:HalfSpace{N}};
                          [start_index]::Int=div(length(constraints)+1, 2),
                          [choose_lower]::Bool=false) where {N}</code></pre><p>Perform a binary search in the constraints.</p><p><strong>Input</strong></p><ul><li><code>d</code>            – direction</li><li><code>constraints</code>  – constraints</li><li><code>start_index</code>  – (optional, default: <code>div(length(constraints)+1, 2)</code>) start                   index</li><li><code>choose_lower</code> – (optional, default: <code>false</code>) flag for choosing the lower                   index (see the &#39;Output&#39; section)</li></ul><p><strong>Output</strong></p><p>In the default setting, the result is the smallest index <code>k</code> such that <code>d ⪯ constraints[k].a</code>, or <code>length(constraints)+1</code> if no such <code>k</code> exists. If the <code>choose_lower</code> flag is set, the result is the largest index <code>k</code> such that <code>constraints[k].a &lt; d</code>, which is equivalent to being <code>k-1</code> in the normal setting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Interfaces/AbstractHPolygon.jl#L522-L546">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.get_constrained_lowdimset"><a class="docstring-binding" href="#LazySets.get_constrained_lowdimset"><code>LazySets.get_constrained_lowdimset</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_constrained_lowdimset(cpa::CartesianProductArray{N, S},
                          P::AbstractPolyhedron{N}) where {N, S}</code></pre><p>Preprocessing step for the intersection between a Cartesian product of a finite number of sets and a polyhedron.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product of a finite number of sets</li><li><code>P</code>   – polyhedron</li></ul><p><strong>Output</strong></p><p>A four-tuple of:</p><ol><li>a low-dimensional <code>CartesianProductArray</code> in the constrained dimensions of the original set <code>cpa</code></li><li>the variables in the constrained blocks,</li><li>the original block structure of the low-dimensional sets,</li><li>the list of the constrained blocks.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/LazyOperations/Intersection.jl#L933-L953">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.get_radius!"><a class="docstring-binding" href="#LazySets.get_radius!"><code>LazySets.get_radius!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_radius!(sih::SymmetricIntervalHull, i::Int)</code></pre><p>Compute the radius of the symmetric interval hull of a set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>sih</code> – symmetric interval hull of a set</li><li><code>i</code>   – dimension in which the radius should be computed</li></ul><p><strong>Output</strong></p><p>The radius of the symmetric interval hull of a set in a given dimension.</p><p><strong>Algorithm</strong></p><p>We ask for the <code>extrema</code> of the underlying set in dimension <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/LazyOperations/SymmetricIntervalHull.jl#L227-L244">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.HalfSpaceModule.is_tighter_same_dir_2D"><a class="docstring-binding" href="#LazySets.HalfSpaceModule.is_tighter_same_dir_2D"><code>LazySets.HalfSpaceModule.is_tighter_same_dir_2D</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_tighter_same_dir_2D(c1::HalfSpace,
                       c2::HalfSpace;
                       [strict]::Bool=false)</code></pre><p>Check if the first of two two-dimensional constraints with equivalent normal direction is tighter.</p><p><strong>Input</strong></p><ul><li><code>c1</code>     – first linear constraint</li><li><code>c2</code>     – second linear constraint</li><li><code>strict</code> – (optional; default: <code>false</code>) check for strictly tighter             constraints?</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the first constraint is tighter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Sets/HalfSpace/HalfSpaceModule.jl#L67-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets._leq_trig"><a class="docstring-binding" href="#LazySets._leq_trig"><code>LazySets._leq_trig</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_leq_trig(u::AbstractVector{N}, v::AbstractVector{N}) where {N&lt;:AbstractFloat}</code></pre><p>Compare two 2D vectors by their direction.</p><p><strong>Input</strong></p><ul><li><code>u</code> –  first 2D direction</li><li><code>v</code> –  second 2D direction</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$\arg(u) [2π] ≤ \arg(v) [2π]$</span>.</p><p><strong>Notes</strong></p><p>The argument is measured in counter-clockwise fashion, with the 0 being the direction (1, 0).</p><p><strong>Algorithm</strong></p><p>The implementation uses the arctangent function with sign, <code>atan</code>, which for two arguments implements the <a href="https://en.wikipedia.org/wiki/Atan2"><code>atan2</code> function</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/Interfaces/AbstractPolygon.jl#L139-L162">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.same_block_structure"><a class="docstring-binding" href="#LazySets.same_block_structure"><code>LazySets.same_block_structure</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">same_block_structure(x::AbstractVector{S1}, y::AbstractVector{S2}
                    ) where {S1&lt;:LazySet, S2&lt;:LazySet}</code></pre><p>Check whether two vectors of sets have the same block structure, i.e., the <span>$i$</span>-th entry in the vectors have the same dimension.</p><p><strong>Input</strong></p><ul><li><code>x</code> – first vector</li><li><code>y</code> – second vector</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the vectors have the same block structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/57213c3bae590a4bc7b01c7f3bbb59814d14a774/src/LazyOperations/CartesianProductArray.jl#L472-L487">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../matrixsets/MatrixZonotope/">« MatrixZonotope</a><a class="docs-footer-nextpage" href="../parallel/">Parallel »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 3 February 2026 07:30">Tuesday 3 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
