<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conversions between set representations · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/getting_started/">Getting Started</a></li><li><a class="toctext" href="../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="toctext" href="../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="toctext" href="../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="toctext" href="../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="toctext" href="../../man/interval_hulls/">Interval Hulls</a></li><li><a class="toctext" href="../../man/convex_hulls/">Convex Hulls</a></li><li><a class="toctext" href="../../man/set_operations/">Operations on Sets</a></li><li><a class="toctext" href="../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="toctext" href="../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="toctext" href="../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="toctext" href="../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../interfaces/">Set Interfaces</a></li><li><a class="toctext" href="../representations/">Common Set Representations</a></li><li><a class="toctext" href="../operations/">Common Set Operations</a></li><li><a class="toctext" href="../comparisons/">Comparisons</a></li><li class="current"><a class="toctext" href>Conversions between set representations</a><ul class="internal"></ul></li><li><a class="toctext" href="../binary_functions/">Binary Functions on Sets</a></li><li><a class="toctext" href="../approximations/">Approximations</a></li><li><a class="toctext" href="../utils/">Utility Functions</a></li><li><a class="toctext" href="../parallel/">Parallel</a></li></ul></li><li><a class="toctext" href="../../about/">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Conversions between set representations</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/conversion.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Conversions between set representations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Conversion-between-set-representations-1" href="#Conversion-between-set-representations-1">Conversion between set representations</a></h1><p>This section of the manual lists the conversion functions between set representations.</p><ul><li><a href="#Conversion-between-set-representations-1">Conversion between set representations</a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON2}, Tuple{HPOLYGON1}, Tuple{Type{HPOLYGON1},HPOLYGON2}} where HPOLYGON2&lt;:AbstractHPolygon where HPOLYGON1&lt;:AbstractHPolygon" href="#Base.convert-Union{Tuple{HPOLYGON2}, Tuple{HPOLYGON1}, Tuple{Type{HPOLYGON1},HPOLYGON2}} where HPOLYGON2&lt;:AbstractHPolygon where HPOLYGON1&lt;:AbstractHPolygon"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPOLYGON1},
        P::HPOLYGON2) where {HPOLYGON1&lt;:AbstractHPolygon,
                             HPOLYGON2&lt;:AbstractHPolygon}</code></pre><p>Convert between polygon types in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polygon</li></ul><p><strong>Output</strong></p><p>The polygon represented as the target type.</p><p><strong>Notes</strong></p><p>We need the <code>Union</code> type for <code>HPOLYGON1</code> because the target type must be concrete.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L5-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON},VPolygon}} where HPOLYGON&lt;:AbstractHPolygon" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON},VPolygon}} where HPOLYGON&lt;:AbstractHPolygon"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(T::Type{HPOLYGON}, P::VPolygon) where {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Converts a polygon in vertex representation to a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPOLYGON</code> – type used for dispatch</li><li><code>P</code>        – polygon in vertex representation</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L35-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{Hyperrectangle},AbstractHyperrectangle}" href="#Base.convert-Tuple{Type{Hyperrectangle},AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Hyperrectangle}, H::AbstractHyperrectangle)</code></pre><p>Convert a hyperrectangular set to a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – hyperrectangle type, used for dispatch</li><li><code>H</code>              – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; convert(Hyperrectangle, Interval(0.0, 1.0))
Hyperrectangle{Float64}([0.5], [0.5])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L445-L465">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{Interval},AbstractHyperrectangle}" href="#Base.convert-Tuple{Type{Interval},AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Interval}, H::AbstractHyperrectangle)</code></pre><p>Converts a hyperrectangular set to an interval.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – interval type, used for dispatch</li><li><code>H</code>        – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>An interval.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; convert(Interval, Hyperrectangle{Float64}([0.5], [0.5]))
Interval{Float64,IntervalArithmetic.Interval{Float64}}([0, 1])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L470-L490">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{Interval},LazySet{N}}} where N&lt;:Real" href="#Base.convert-Union{Tuple{N}, Tuple{Type{Interval},LazySet{N}}} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Interval}, S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Converts a convex set to an interval.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – interval type, used for dispatch</li><li><code>S</code>        – convex set</li></ul><p><strong>Output</strong></p><p>An interval.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L496-L509">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProductArray{N,HN}}} where HN&lt;:AbstractHyperrectangle{N} where N&lt;:Real" href="#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProductArray{N,HN}}} where HN&lt;:AbstractHyperrectangle{N} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Hyperrectangle},
        cpa::CartesianProductArray{N, HN}) where {N&lt;:Real, HN&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the cartesian product of a finite number of hyperrectangular sets to a single hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>S</code>              – cartesian product array of hyperrectangular set </li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>This implementation uses the <code>center</code> and <code>radius_hyperrectangle</code> methods of <code>AbstractHyperrectangle</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L515-L535">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProductArray{N,Interval{N,IN} where IN&lt;:AbstractInterval{N}}}} where N&lt;:Real" href="#Base.convert-Union{Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProductArray{N,Interval{N,IN} where IN&lt;:AbstractInterval{N}}}} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Hyperrectangle},
        cpa::CartesianProductArray{N, Interval{N}}) where {N&lt;:Real}</code></pre><p>Converts the cartesian product of a finite number of intervals to a single hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>S</code>              – cartesian product array of intervals </li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>This implementation uses the <code>min</code> and <code>max</code> methods of <code>Interval</code> to reduce the allocatons and improve performance (see LazySets#1143).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L580-L600">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON},AbstractHyperrectangle}} where HPOLYGON&lt;:AbstractHPolygon" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON},AbstractHyperrectangle}} where HPOLYGON&lt;:AbstractHPolygon"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPOLYGON}, H::AbstractHyperrectangle) where
    {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Converts a hyperrectangular set to a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPOLYGON</code>  – type used for dispatch</li><li><code>H</code>         – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L710-L724">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON},HPolytope{N}}} where HPOLYGON&lt;:AbstractHPolygon where N&lt;:Real" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON},HPolytope{N}}} where HPOLYGON&lt;:AbstractHPolygon where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPOLYGON}, P::HPolytope{N}) where
    {N&lt;:Real, HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Convert from 2D polytope in H-representation to polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code>  – target type</li><li><code>P</code>     – source polytope (must be 2D)</li><li><code>prune</code> – (optional, default: <code>true</code>) flag for removing redundant            constraints in the end</li></ul><p><strong>Output</strong></p><p>The 2D polytope represented as polygon.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L215-L230">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON},AbstractSingleton{N}}} where HPOLYGON&lt;:AbstractHPolygon where N&lt;:Real" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON},AbstractSingleton{N}}} where HPOLYGON&lt;:AbstractHPolygon where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPOLYGON}, S::AbstractSingleton{N}
       ) where {N&lt;:Real, HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Convert from singleton to polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>S</code>    – singleton</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation with the minimal number of constraints (three).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L387-L402">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON},LineSegment{N}}} where HPOLYGON&lt;:AbstractHPolygon where N&lt;:Real" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON},LineSegment{N}}} where HPOLYGON&lt;:AbstractHPolygon where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPOLYGON}, L::LineSegment{N}
      ) where {N&lt;:Real, HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Convert from line segment to polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code>  – target type</li><li><code>L</code>     – line segment</li><li><code>prune</code> – (optional, default: <code>false</code>) flag for removing redundant            constraints in the end</li></ul><p><strong>Output</strong></p><p>A flat polygon in constraint representation with the minimal number of constraints (four).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L415-L431">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolyhedron},AbstractPolytope}" href="#Base.convert-Tuple{Type{HPolyhedron},AbstractPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPolyhedron}, P::AbstractPolytope)</code></pre><p>Convert a polytopic set to a polyhedron in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The given polytope represented as a polyhedron in constraint representation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L149-L162">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolytope},AbstractHPolygon}" href="#Base.convert-Tuple{Type{HPolytope},AbstractHPolygon}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPolytope}, P::AbstractHPolygon)</code></pre><p>Convert from polygon in H-representation to polytope in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polygon</li></ul><p><strong>Output</strong></p><p>The polygon represented as 2D polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L71-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolytope},AbstractHyperrectangle}" href="#Base.convert-Tuple{Type{HPolytope},AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPolytope}, H::AbstractHyperrectangle)</code></pre><p>Converts a hyperrectangular set to a polytope in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPolytope</code> – type used for dispatch</li><li><code>H</code>         – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A polytope in constraint representation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L691-L704">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolytope},AbstractPolytope}" href="#Base.convert-Tuple{Type{HPolytope},AbstractPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPolytope}, P::AbstractPolytope)</code></pre><p>Convert a polytopic set to a polytope in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The given polytope represented as a polytope in constraint representation.</p><p><strong>Algorithm</strong></p><p>First the list of constraints of <code>P</code> is computed, then the corresponding <code>HPolytope</code> is created.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L126-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolytope},VPolytope}" href="#Base.convert-Tuple{Type{HPolytope},VPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPolytope}, P::VPolytope)</code></pre><p>Convert from polytope in V-representation to polytope in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The polytope in the dual representation.</p><p><strong>Algorithm</strong></p><p>The <code>tohrep</code> function is invoked. It requires the <code>Polyhedra</code> package.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L167-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolygon},AbstractHPolygon}" href="#Base.convert-Tuple{Type{VPolygon},AbstractHPolygon}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{VPolygon}, P::AbstractHPolygon)</code></pre><p>Converts a polygon in constraint representation to a polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>VPolygon</code> – type used for dispatch</li><li><code>P</code>        – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>A polygon in vertex representation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L53-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolygon},AbstractPolytope}" href="#Base.convert-Tuple{Type{VPolygon},AbstractPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{VPolygon}, P::AbstractPolytope)</code></pre><p>Convert polytopic set to polygon in V-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The 2D polytope represented as a polygon.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L107-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolytope},AbstractPolytope}" href="#Base.convert-Tuple{Type{VPolytope},AbstractPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{VPolytope}, P::AbstractPolytope)</code></pre><p>Convert polytopic type to polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The set <code>P</code> represented as a <code>VPolytope</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L89-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolytope},HPolytope}" href="#Base.convert-Tuple{Type{VPolytope},HPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{VPolytope}, P::HPolytope)</code></pre><p>Convert from polytope in H-representation to polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The polytope in the dual representation.</p><p><strong>Algorithm</strong></p><p>The <code>tovrep</code> function is invoked. It requires the <code>Polyhedra</code> package.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L189-L206">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{Zonotope},AbstractHyperrectangle}" href="#Base.convert-Tuple{Type{Zonotope},AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Zonotope}, H::AbstractHyperrectangle)</code></pre><p>Converts a hyperrectangular set to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code></li><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A zonotope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L241-L254">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{IntervalArithmetic.IntervalBox},AbstractHyperrectangle}" href="#Base.convert-Tuple{Type{IntervalArithmetic.IntervalBox},AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{IntervalArithmetic.IntervalBox}, H::AbstractHyperrectangle)</code></pre><p>Converts a hyperrectangular set to an <code>IntervalBox</code> from <code>IntervalArithmetic</code>.</p><p><strong>Input</strong></p><ul><li><code>IntervalBox</code> – type used for dispatch</li><li><code>H</code>           – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>An <code>IntervalBox</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L732-L745">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{Hyperrectangle},IntervalArithmetic.IntervalBox}" href="#Base.convert-Tuple{Type{Hyperrectangle},IntervalArithmetic.IntervalBox}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Hyperrectangle}, IB::IntervalArithmetic.IntervalBox)</code></pre><p>Converts an <code>IntervalBox</code> from <code>IntervalArithmetic</code> to a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>IB</code>             – interval box</li></ul><p><strong>Output</strong></p><p>A <code>Hyperrectangle</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L750-L763">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{Zonotope},CartesianProduct{N,Zonotope{N},Zonotope{N}}}} where N&lt;:Real" href="#Base.convert-Union{Tuple{N}, Tuple{Type{Zonotope},CartesianProduct{N,Zonotope{N},Zonotope{N}}}} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Zonotope}, cp::CartesianProduct{N, Zonotope{N}, Zonotope{N}}) where {N&lt;:Real}</code></pre><p>Converts the cartesian product of two zonotopes to a new zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type used for dispatch</li><li><code>S</code>        – cartesian product of two zonotopes</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>The cartesian product is obtained by:</p><ul><li>Concatenating the centers of each input zonotope.</li><li>Arranging the generators in block-diagional fashion, and filled with zeros in the off-diagonal; for this reason, the generator matrix of the returned zonotope is built as a sparse matrix.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L661-L683">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProduct{N,HN1,HN2}}} where HN2&lt;:AbstractHyperrectangle{N} where HN1&lt;:AbstractHyperrectangle{N} where N&lt;:Real" href="#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProduct{N,HN1,HN2}}} where HN2&lt;:AbstractHyperrectangle{N} where HN1&lt;:AbstractHyperrectangle{N} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Hyperrectangle},
        cp::CartesianProduct{N, HN1, HN2}) where {N&lt;:Real, HN1&lt;:AbstractHyperrectangle{N}, HN2&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the cartesian product of two hyperrectangular sets to a single hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>S</code>              – cartesian product of two hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>The result is obtained by concatenating the center and radius of each hyperrectangle. This implementation uses the <code>center</code> and <code>radius_hyperrectangle</code> methods of <code>AbstractHyperrectangle</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L551-L571">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope},CartesianProduct{N,HN1,HN2}}} where HN2&lt;:AbstractHyperrectangle{N} where HN1&lt;:AbstractHyperrectangle{N} where N&lt;:Real" href="#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope},CartesianProduct{N,HN1,HN2}}} where HN2&lt;:AbstractHyperrectangle{N} where HN1&lt;:AbstractHyperrectangle{N} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Zonotope}, cp::CartesianProduct{N, HN1, HN2}) where {N&lt;:Real,
    HN1&lt;:AbstractHyperrectangle{N}, HN2&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the cartesian product of two hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>cp</code>       – cartesian product of two hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>This method falls back to the conversion of the cartesian product to a single hyperrectangle, and then from a hyperrectangle to a zonotope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L259-L274">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope},CartesianProductArray{N,HN}}} where HN&lt;:AbstractHyperrectangle{N} where N&lt;:Real" href="#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope},CartesianProductArray{N,HN}}} where HN&lt;:AbstractHyperrectangle{N} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Zonotope}, cpa::CartesianProductArray{N, HN})
    where {N&lt;:Real, HN&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the cartesian product array of hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>cpa</code>      – cartesian product array of hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method falls back to the conversion of the cartesian product to a single hyperrectangle, and then from a hyperrectangle to a zonotope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L281-L300">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{SN}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,SN,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM}} where SN&lt;:AbstractHyperrectangle{N} where N" href="#Base.convert-Union{Tuple{SN}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,SN,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM}} where SN&lt;:AbstractHyperrectangle{N} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Zonotope},
        S::LinearMap{N, SN}
        ) where {N, SN&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the lazy linear map of a hyperrectangular set to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>S</code>        – linear map of a hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method first converts the hyperrectangular set to a zonotope, and then applies the (concrete) linear map to the zonotope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L306-L326">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,CartesianProduct{N,HN1,HN2},NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM}} where HN2&lt;:AbstractHyperrectangle{N} where HN1&lt;:AbstractHyperrectangle{N} where N" href="#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,CartesianProduct{N,HN1,HN2},NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM}} where HN2&lt;:AbstractHyperrectangle{N} where HN1&lt;:AbstractHyperrectangle{N} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Zonotope}, S::LinearMap{N, CartesianProduct{N, HN1, HN2}}
       ) where {N, HN1&lt;:AbstractHyperrectangle{N},
                HN2&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the lazy linear map of the cartesian product of two hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>S</code>        – linear map of the cartesian product of hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method first converts the cartesian product to a zonotope, and then applies the (concrete) linear map to the zonotope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L332-L353">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,CartesianProductArray{N,HN},NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM}} where HN&lt;:AbstractHyperrectangle{N} where N" href="#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,CartesianProductArray{N,HN},NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM}} where HN&lt;:AbstractHyperrectangle{N} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Zonotope},S::LinearMap{N, CartesianProductArray{N, HN}}
       ) where {N, HN&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the lazy linear map of the cartesian product of a finite number of hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>S</code>        – linear map of a <code>CartesianProductArray</code> of hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method first converts the cartesian product array to a zonotope, and then applies the (concrete) linear map to the zonotope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L361-L381">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProduct{N,Interval{N,IN} where IN&lt;:AbstractInterval{N},Interval{N,IN} where IN&lt;:AbstractInterval{N}}},AbstractHyperrectangle{N}}} where N&lt;:Real" href="#Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProduct{N,Interval{N,IN} where IN&lt;:AbstractInterval{N},Interval{N,IN} where IN&lt;:AbstractInterval{N}}},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{CartesianProduct{N, Interval{N}, Interval{N}}},
        H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Converts a two-dimensional hyperrectangle to the cartesian product of two intervals.</p><p><strong>Input</strong></p><ul><li><code>CartesianProduct</code> – type used for dispatch</li><li><code>H</code>                – hyperrectangle</li></ul><p><strong>Output</strong></p><p>The cartesian product of two intervals.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L614-L629">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProductArray{N,Interval{N,IN} where IN&lt;:AbstractInterval{N}}},AbstractHyperrectangle{N}}} where N&lt;:Real" href="#Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProductArray{N,Interval{N,IN} where IN&lt;:AbstractInterval{N}}},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{CartesianProductArray{N, Interval{N}}},
        H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Converts a hyperrectangle to the cartesian product array of intervals.</p><p><strong>Input</strong></p><ul><li><code>CartesianProductArray</code> – type used for dispatch</li><li><code>H</code>                     – hyperrectangle</li></ul><p><strong>Output</strong></p><p>The cartesian product of a finite number of intervals.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L640-L654">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{AH}, Tuple{N}, Tuple{Type{Hyperrectangle},Rectification{N,AH}}} where AH&lt;:AbstractHyperrectangle{N} where N&lt;:Real" href="#Base.convert-Union{Tuple{AH}, Tuple{N}, Tuple{Type{Hyperrectangle},Rectification{N,AH}}} where AH&lt;:AbstractHyperrectangle{N} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Hyperrectangle}, r::Rectification{N, AH})
    where {N&lt;:Real, AH&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts a rectification of a hyperrectangle to a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>r</code>              – rectification of a hyperrectangle</li></ul><p><strong>Output</strong></p><p>A <code>Hyperrectangle</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L770-L784">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{IN}, Tuple{N}, Tuple{Type{Interval},Rectification{N,IN}}} where IN&lt;:(Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}) where N&lt;:Real" href="#Base.convert-Union{Tuple{IN}, Tuple{N}, Tuple{Type{Interval},Rectification{N,IN}}} where IN&lt;:(Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}) where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Interval},
        r::Rectification{N, IN}) where {N&lt;:Real, IN&lt;:Interval{N}}</code></pre><p>Converts a rectification of an interval to an interval.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – type used for dispatch</li><li><code>r</code>        – rectification of an interval</li></ul><p><strong>Output</strong></p><p>An <code>Interval</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/convert.jl#L791-L805">source</a></section><footer><hr/><a class="previous" href="../comparisons/"><span class="direction">Previous</span><span class="title">Comparisons</span></a><a class="next" href="../binary_functions/"><span class="direction">Next</span><span class="title">Binary Functions on Sets</span></a></footer></article></body></html>
