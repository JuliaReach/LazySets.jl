<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Set Interfaces · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/getting_started/">Getting Started</a></li><li><a class="toctext" href="../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="toctext" href="../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="toctext" href="../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="toctext" href="../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="toctext" href="../../man/interval_hulls/">Interval Hulls</a></li><li><a class="toctext" href="../../man/convex_hulls/">Convex Hulls</a></li><li><a class="toctext" href="../../man/set_operations/">Operations on Sets</a></li><li><a class="toctext" href="../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="toctext" href="../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="toctext" href="../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="toctext" href="../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href>Set Interfaces</a><ul class="internal"><li><a class="toctext" href="#LazySet-1">LazySet</a></li><li><a class="toctext" href="#Centrally-symmetric-set-1">Centrally symmetric set</a></li><li><a class="toctext" href="#Polyhedron-1">Polyhedron</a></li></ul></li><li><a class="toctext" href="../representations/">Common Set Representations</a></li><li><a class="toctext" href="../operations/">Common Set Operations</a></li><li><a class="toctext" href="../comparisons/">Comparisons</a></li><li><a class="toctext" href="../conversion/">Conversions between set representations</a></li><li><a class="toctext" href="../binary_functions/">Binary Functions on Sets</a></li><li><a class="toctext" href="../approximations/">Approximations</a></li><li><a class="toctext" href="../utils/">Utility Functions</a></li><li><a class="toctext" href="../parallel/">Parallel</a></li></ul></li><li><a class="toctext" href="../../about/">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Set Interfaces</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/interfaces.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Set Interfaces</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Set-Interfaces-1" href="#Set-Interfaces-1">Set Interfaces</a></h1><p>This section of the manual describes the interfaces for different set types. Every set that fits the description of an interface should also implement it. This helps in several ways:</p><ul><li>avoid code duplicates,</li><li>provide functions for many sets at once,</li><li>allow changes in the source code without changing the API.</li></ul><p>The interface functions are outlined in the interface documentation. See <a href="../representations/#Common-Set-Representations-1">Common Set Representations</a> for implementations of the interfaces.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The naming convention is such that all interface names (with the exception of the main abstract type <code>LazySet</code>) should be preceded by <code>Abstract</code>.</p></div></div><p>The following diagram shows the interface hierarchy.</p><p><img src="../../assets/interfaces.png" alt="../assets/interfaces.png"/></p><ul><li><a href="#Set-Interfaces-1">Set Interfaces</a></li><ul><li><a href="#LazySet-1">LazySet</a></li><ul><li><a href="#Support-function-and-support-vector-1">Support function and support vector</a></li><li><a href="#Other-globally-defined-set-functions-1">Other globally defined set functions</a></li><li><a href="#Set-functions-that-override-Base-functions-1">Set functions that override Base functions</a></li><li><a href="#Aliases-for-set-types-1">Aliases for set types</a></li></ul><li><a href="#Centrally-symmetric-set-1">Centrally symmetric set</a></li><li><a href="#Polyhedron-1">Polyhedron</a></li><ul><li><a href="#Polytope-1">Polytope</a></li><ul><li><a href="#Polygon-1">Polygon</a></li><li><a href="#Centrally-symmetric-polytope-1">Centrally symmetric polytope</a></li></ul></ul></ul></ul><h2><a class="nav-anchor" id="LazySet-1" href="#LazySet-1">LazySet</a></h2><p>Every convex set in this library implements this interface.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.LazySet" href="#LazySets.LazySet"><code>LazySets.LazySet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">LazySet{N}</code></pre><p>Abstract type for convex sets, i.e., sets characterized by a (possibly infinite) intersection of halfspaces, or equivalently, sets <span>$S$</span> such that for any two elements <span>$x, y ∈ S$</span> and <span>$0 ≤ λ ≤ 1$</span> it holds that <span>$λ·x + (1-λ)·y ∈ S$</span>.</p><p><strong>Notes</strong></p><p><code>LazySet</code> types should be parameterized with a type <code>N</code>, typically <code>N&lt;:Real</code>, for using different numeric types.</p><p>Every concrete <code>LazySet</code> must define the following functions:</p><ul><li><code>σ(d::AbstractVector{N}, S::LazySet{N}) where {N&lt;:Real}</code> – the support vector   of <code>S</code> in a given direction <code>d</code>; note that the numeric type <code>N</code> of <code>d</code> and   <code>S</code> must be identical; for some set types <code>N</code> may be more restrictive than   <code>Real</code></li><li><code>dim(S::LazySet)::Int</code> – the ambient dimension of <code>S</code></li></ul><p>The subtypes of <code>LazySet</code> (including abstract interfaces):</p><pre><code class="language-julia-repl">julia&gt; subtypes(LazySet, false)
18-element Array{Any,1}:
 AbstractCentrallySymmetric
 AbstractPolyhedron
 AffineMap
 CacheMinkowskiSum
 CartesianProduct
 CartesianProductArray
 ConvexHull
 ConvexHullArray
 EmptySet
 ExponentialMap
 ExponentialProjectionMap
 Intersection
 IntersectionArray
 LinearMap
 MinkowskiSum
 MinkowskiSumArray
 ResetMap
 Translation</code></pre><p>If we only consider <em>concrete</em> subtypes, then:</p><p><code>jldoctest; setup = :(using LazySets: subtypes) julia&gt; subtypes(LazySet, true) 37-element Array{Type,1}:  Ball1  Ball2  BallInf  Ballp  CacheMinkowskiSum  CartesianProduct  CartesianProductArray  ConvexHull  ConvexHullArray  Ellipsoid  EmptySet  ExponentialMap  ExponentialProjectionMap  HPolygon  HPolygonOpt  HPolyhedron  HPolytope  HalfSpace  Hyperplane  Hyperrectangle  Intersection  IntersectionArray  Interval  Line  LineSegment  LinearMap  MinkowskiSum  MinkowskiSumArray  ResetMap  Singleton  SymmetricIntervalHull  Translation  Universe  VPolygon  VPolytope  ZeroSet  Zonotope</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/LazySet.jl#L19-L106">source</a></section><h3><a class="nav-anchor" id="Support-function-and-support-vector-1" href="#Support-function-and-support-vector-1">Support function and support vector</a></h3><p>Every <code>LazySet</code> type must define a function <code>σ</code> to compute the support vector.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.support_vector" href="#LazySets.support_vector"><code>LazySets.support_vector</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">support_vector</code></pre><p>Alias for the support vector σ.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/LazySet.jl#L149-L153">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, S::LazySet{N})::N where {N&lt;:Real}</code></pre><p>Evaluate the support function of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>The support function of the set <code>S</code> for the direction <code>d</code>.</p><p><strong>Notes</strong></p><p>The numeric type of the direction and the set must be identical.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/LazySet.jl#L113-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.support_function" href="#LazySets.support_function"><code>LazySets.support_function</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">support_function</code></pre><p>Alias for the support function ρ.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/LazySet.jl#L135-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ" href="#LazySets.σ"><code>LazySets.σ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">σ</code></pre><p>Function to compute the support vector σ.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/LazySet.jl#L142-L146">source</a></section><h3><a class="nav-anchor" id="Other-globally-defined-set-functions-1" href="#Other-globally-defined-set-functions-1">Other globally defined set functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">norm(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the norm of a convex set. It is the norm of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/LazySet.jl#L208-L223">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius" href="#LazySets.radius"><code>LazySets.radius</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">radius(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the radius of a convex set. It is the radius of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/LazySet.jl#L232-L247">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.diameter" href="#LazySets.diameter"><code>LazySets.diameter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">diameter(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the diameter of a convex set. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/LazySet.jl#L256-L272">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{LazySet}" href="#LazySets.isbounded-Tuple{LazySet}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(S::LazySet)::Bool</code></pre><p>Determine whether a set is bounded.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set is bounded.</p><p><strong>Algorithm</strong></p><p>We check boundedness via <a href="#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>isbounded_unit_dimensions</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/LazySet.jl#L156-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.isbounded_unit_dimensions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded_unit_dimensions(S::LazySet{N})::Bool where {N&lt;:Real}</code></pre><p>Determine whether a set is bounded in each unit dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set is bounded in each unit dimension.</p><p><strong>Algorithm</strong></p><p>This function performs <span>$2n$</span> support function checks, where <span>$n$</span> is the ambient dimension of <code>S</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/LazySet.jl#L177-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>An element of a convex set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/LazySet.jl#L278-L290">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tosimplehrep-Tuple{LazySet}" href="#LazySets.tosimplehrep-Tuple{LazySet}"><code>LazySets.tosimplehrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tosimplehrep(S::LazySet)</code></pre><p>Return the simple H-representation <span>$Ax ≤ b$</span> of a set from its list of linear constraints.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p>The tuple <code>(A, b)</code> where <code>A</code> is the matrix of normal directions and <code>b</code> is the vector of offsets.</p><p><strong>Notes</strong></p><p>This function only works for sets that can be represented exactly by a finite list of linear constraints. This fallback implementation relies on <code>constraints_list(S)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/LazySet.jl#L429-L449">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isuniversal-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},Bool}} where N&lt;:Real" href="#LazySets.isuniversal-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},Bool}} where N&lt;:Real"><code>LazySets.isuniversal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isuniversal(X::LazySet{N}, [witness]::Bool=false
           )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a given convex set is universal, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – convex set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X$</span> is universal</li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X$</span> is universal</li><li><code>(false, v)</code> iff <span>$X$</span> is not universal and <span>$v ∉ X$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>This is a naive fallback implementation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/LazySet.jl#L452-L474">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.minkowski_sum-Union{Tuple{N}, Tuple{LazySet{N},LazySet{N}}} where N&lt;:Real" href="#LazySets.minkowski_sum-Union{Tuple{N}, Tuple{LazySet{N},LazySet{N}}} where N&lt;:Real"><code>LazySets.minkowski_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">minkowski_sum(P::LazySet{N}, Q::LazySet{N};
              [backend]=nothing,
              [algorithm]=nothing,
              [prune]=true) where {N&lt;:Real}</code></pre><p>Concrete Minkowski sum for a pair of lazy sets using their constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>         – lazy set</li><li><code>Q</code>         – another lazy set</li><li><code>backend</code>   – (optional, default: <code>nothing</code>) polyhedral computations backend</li><li><code>algorithm</code> – (optional, default: <code>nothing</code>) algorithm to compute the elimination                of variables; available options are <code>Polyhedra.FourierMotzkin</code>,                <code>Polyhedra.BlockElimination</code>, and <code>Polyhedra.ProjectGenerators</code></li><li><code>prune</code>     – (optional, default: <code>true</code>) if <code>true</code>, apply a post-processing algorithm                to remove redundant constraints</li></ul><p><strong>Output</strong></p><p>An <code>HPolytope</code> that corresponds to the Minkowski sum of <code>P</code> and <code>Q</code> if both <code>P</code> and <code>Q</code> are bounded; otherwise an <code>HPolyhedron</code>.</p><p><strong>Notes</strong></p><p>This function requires that the list of constraints of both lazy sets <code>P</code> and <code>Q</code> can be obtained. After obtaining the respective lists of constraints, the <code>minkowski_sum</code> fucntion for polyhedral sets is used. For details see <a href="../binary_functions/#LazySets.minkowski_sum-Union{Tuple{N}, Tuple{VPolytope{N},VPolytope{N}}} where N&lt;:Real"><code>minkowski_sum(::VPolytope, ::VPolytope)</code></a>.</p><p>This method requires <code>Polyhedra</code> and <code>CDDLib</code>, so you have to do:</p><pre><code class="language-julia">julia&gt; using LazySets, Polyhedra, CDDLib

julia&gt; ...

julia&gt; minkowski_sum(P, Q)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/concrete_minkowski_sum.jl#L3-L43">source</a></section><p>Plotting is available for general one- or two-dimensional <code>LazySet</code>s, provided that the overapproximation using iterative refinement is available:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.plot_recipe-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},N}} where N&lt;:Real" href="#LazySets.plot_recipe-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},N}} where N&lt;:Real"><code>LazySets.plot_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_recipe(X::LazySet{N}, [ε]::N=N(PLOT_PRECISION)) where {N&lt;:Real}</code></pre><p>Convert a convex set to a pair <code>(x, y)</code> of points for plotting.</p><p><strong>Input</strong></p><ul><li><code>X</code> – convex set</li><li><code>ε</code> – (optional, default: <code>PLOT_PRECISION</code>) approximation error bound</li></ul><p><strong>Output</strong></p><p>A pair <code>(x, y)</code> of points that can be plotted.</p><p><strong>Notes</strong></p><p>Plotting of unbounded sets is not implemented yet (see <a href="https://github.com/JuliaReach/LazySets.jl/issues/576">#576</a>).</p><p><strong>Algorithm</strong></p><p>We first assert that <code>X</code> is bounded.</p><p>One-dimensional sets are converted to an <code>Interval</code>. We do not support three-dimensional or higher-dimensional sets at the moment.</p><p>For two-dimensional sets, we first compute a polygonal overapproximation. The second argument, <code>ε</code>, corresponds to the error in Hausdorff distance between the overapproximating set and <code>X</code>. The default value <code>PLOT_PRECISION</code> is chosen such that the unit ball in the 2-norm is approximated with reasonable accuracy. On the other hand, if you only want to produce a fast box-overapproximation of <code>X</code>, pass <code>ε=Inf</code>. Finally, we use the plot recipe for polygons.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/LazySet.jl#L492-L526">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{Dict{Symbol,Any},LazySet{N}}, Tuple{Dict{Symbol,Any},LazySet{N},N}} where N&lt;:Real" href="#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{Dict{Symbol,Any},LazySet{N}}, Tuple{Dict{Symbol,Any},LazySet{N},N}} where N&lt;:Real"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_lazyset(X::LazySet{N}, [ε]::N=N(PLOT_PRECISION); ...) where {N&lt;:Real}</code></pre><p>Plot a convex set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – convex set</li><li><code>ε</code> – (optional, default: <code>PLOT_PRECISION</code>) approximation error bound</li></ul><p><strong>Notes</strong></p><p>See <a href="#LazySets.plot_recipe-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},N}} where N&lt;:Real"><code>plot_recipe(::LazySet{&lt;:Real})</code></a>.</p><p>For polyhedral set types (subtypes of <code>AbstractPolyhedron</code>), the argument <code>ε</code> is ignored.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; B = Ball2(ones(2), 0.1);

julia&gt; plot(B, 1e-3)  # default accuracy value (explicitly given for clarity)

julia&gt; plot(B, 1e-2)  # faster but less accurate than the previous call</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/plot_recipes.jl#L124-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{VN}, Tuple{N}, Tuple{Dict{Symbol,Any},AbstractArray{VN,1}}, Tuple{Dict{Symbol,Any},AbstractArray{VN,1},N}, Tuple{Dict{Symbol,Any},AbstractArray{VN,1},N,Int64}, Tuple{Dict{Symbol,Any},AbstractArray{VN,1},N,Int64,Bool}} where VN&lt;:LazySet{N} where N&lt;:Real" href="#RecipesBase.apply_recipe-Union{Tuple{VN}, Tuple{N}, Tuple{Dict{Symbol,Any},AbstractArray{VN,1}}, Tuple{Dict{Symbol,Any},AbstractArray{VN,1},N}, Tuple{Dict{Symbol,Any},AbstractArray{VN,1},N,Int64}, Tuple{Dict{Symbol,Any},AbstractArray{VN,1},N,Int64,Bool}} where VN&lt;:LazySet{N} where N&lt;:Real"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_list(list::AbstractVector{VN}, [ε]::N=N(PLOT_PRECISION),
          [Nφ]::Int=PLOT_POLAR_DIRECTIONS, [fast]::Bool=false; ...)
    where {N&lt;:Real, VN&lt;:LazySet{N}}</code></pre><p>Plot a list of convex sets.</p><p><strong>Input</strong></p><ul><li><code>list</code> – list of convex sets (1D or 2D)</li><li><code>ε</code>    – (optional, default: <code>PLOT_PRECISION</code>) approximation error bound</li><li><code>Nφ</code>   – (optional, default: <code>PLOT_POLAR_DIRECTIONS</code>) number of polar           directions (used to plot lazy intersections)</li><li><code>fast</code> – (optional, default: <code>false</code>) switch for faster plotting but without           individual plot recipes (see notes below)</li></ul><p><strong>Notes</strong></p><p>For each set in the list we apply an individual plot recipe.</p><p>The option <code>fast</code> provides access to a faster plotting scheme where all sets in the list are first converted to polytopes and then plotted in one single run. This, however, is not suitable when plotting flat sets (line segments, singletons) because then the polytope plot recipe does not deliver good results. Hence by default we do not use this option. For plotting a large number of (non-flat) polytopes, we highly advise activating this option.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; B1 = BallInf(zeros(2), 0.4);

julia&gt; B2 = BallInf(ones(2), 0.4);

julia&gt; plot([B1, B2])</code></pre><p>Some of the sets in the list may not be plotted precisely but rather overapproximated first. The second argument <code>ε</code> controls the accuracy of this overapproximation.</p><pre><code class="language-julia">julia&gt; Bs = [BallInf(zeros(2), 0.4), Ball2(ones(2), 0.4)];

julia&gt; plot(Bs, 1e-3)  # default accuracy value (explicitly given for clarity)

julia&gt; plot(Bs, 1e-2)  # faster but less accurate than the previous call</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/plot_recipes.jl#L15-L64">source</a></section><h3><a class="nav-anchor" id="Set-functions-that-override-Base-functions-1" href="#Set-functions-that-override-Base-functions-1">Set functions that override Base functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Tuple{LazySet,LazySet}" href="#Base.:==-Tuple{LazySet,LazySet}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">==(X::LazySet, Y::LazySet)</code></pre><p>Return whether two LazySets of the same type are exactly equal.</p><p><strong>Input</strong></p><ul><li><code>X</code> – any <code>LazySet</code></li><li><code>Y</code> – another <code>LazySet</code> of the same type as <code>X</code></li></ul><p><strong>Output</strong></p><ul><li><code>true</code> iff <code>X</code> is equal to <code>Y</code>.</li></ul><p><strong>Notes</strong></p><p>The check is purely syntactic and the sets need to have the same base type. For instance, <code>X::VPolytope == Y::HPolytope</code> returns <code>false</code> even if <code>X</code> and <code>Y</code> represent the same polytope. However <code>X::HPolytope{Int64} == Y::HPolytope{Float64}</code> is a valid comparison.</p><p><strong>Algorithm</strong></p><p>We recursively compare the fields of <code>X</code> and <code>Y</code> until a mismatch is found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; HalfSpace([1], 1) == HalfSpace([1], 1)
true

julia&gt; HalfSpace([1], 1) == HalfSpace([1.0], 1.0)
true

julia&gt; Ball1([0.], 1.) == Ball2([0.], 1.)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/LazySet.jl#L295-L332">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:≈-Tuple{LazySet,LazySet}" href="#Base.:≈-Tuple{LazySet,LazySet}"><code>Base.:≈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">≈(X::LazySet, Y::LazySet)</code></pre><p>Return whether two LazySets of the same type are approximately equal.</p><p><strong>Input</strong></p><ul><li><code>X</code> – any <code>LazySet</code></li><li><code>Y</code> – another <code>LazySet</code> of the same type as <code>X</code></li></ul><p><strong>Output</strong></p><ul><li><code>true</code> iff <code>X</code> is equal to <code>Y</code>.</li></ul><p><strong>Notes</strong></p><p>The check is purely syntactic and the sets need to have the same base type. For instance, <code>X::VPolytope ≈ Y::HPolytope</code> returns <code>false</code> even if <code>X</code> and <code>Y</code> represent the same polytope. However <code>X::HPolytope{Int64} ≈ Y::HPolytope{Float64}</code> is a valid comparison.</p><p><strong>Algorithm</strong></p><p>We recursively compare the fields of <code>X</code> and <code>Y</code> until a mismatch is found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; HalfSpace([1], 1) ≈ HalfSpace([1], 1)
true

julia&gt; HalfSpace([1], 1) ≈ HalfSpace([1.00000001], 0.99999999)
true

julia&gt; HalfSpace([1], 1) ≈ HalfSpace([1.0], 1.0)
true

julia&gt; Ball1([0.], 1.) ≈ Ball2([0.], 1.)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/LazySet.jl#L347-L387">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy-Tuple{LazySet}" href="#Base.copy-Tuple{LazySet}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">copy(S::LazySet)</code></pre><p>Return a deep copy of the given set by copying its values recursively.</p><p><strong>Input</strong></p><ul><li><code>S</code> – any <code>LazySet</code></li></ul><p><strong>Output</strong></p><p>A copy of <code>S</code>.</p><p><strong>Notes</strong></p><p>This function performs a <code>deepcopy</code> of each field in <code>S</code>, resulting in a completely independent object. See the documentation of <code>?deepcopy</code> for further details.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/LazySet.jl#L408-L426">source</a></section><h3><a class="nav-anchor" id="Aliases-for-set-types-1" href="#Aliases-for-set-types-1">Aliases for set types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CompactSet" href="#LazySets.CompactSet"><code>LazySets.CompactSet</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">CompactSet</code></pre><p>An alias for compact set types.</p><p><strong>Notes</strong></p><p>Most lazy operations are not captured by this alias because whether their result is compact or not depends on the argument(s).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/aliases.jl#L4-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.NonCompactSet" href="#LazySets.NonCompactSet"><code>LazySets.NonCompactSet</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">NonCompactSet</code></pre><p>An alias for non-compact set types.</p><p><strong>Notes</strong></p><p>Most lazy operations are not captured by this alias because whether their result is non-compact or not depends on the argument(s).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/aliases.jl#L20-L29">source</a></section><h2><a class="nav-anchor" id="Centrally-symmetric-set-1" href="#Centrally-symmetric-set-1">Centrally symmetric set</a></h2><p>Centrally symmetric sets such as balls of different norms are characterized by a center. Note that there is a special interface combination <a href="#Centrally-symmetric-polytope-1">Centrally symmetric polytope</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractCentrallySymmetric" href="#LazySets.AbstractCentrallySymmetric"><code>LazySets.AbstractCentrallySymmetric</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractCentrallySymmetric{N&lt;:Real} &lt;: LazySet{N}</code></pre><p>Abstract type for centrally symmetric sets.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractCentrallySymmetric</code> must define the following functions:</p><ul><li><code>center(::AbstractCentrallySymmetric{N})::Vector{N}</code> – return the center   point</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractCentrallySymmetric)
3-element Array{Any,1}:
 Ball2
 Ballp
 Ellipsoid</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractCentrallySymmetric.jl#L7-L26">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractCentrallySymmetric}" href="#LazySets.dim-Tuple{AbstractCentrallySymmetric}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(S::AbstractCentrallySymmetric)::Int</code></pre><p>Return the ambient dimension of a centrally symmetric set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractCentrallySymmetric.jl#L30-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{AbstractCentrallySymmetric}" href="#LazySets.isbounded-Tuple{AbstractCentrallySymmetric}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(S::AbstractCentrallySymmetric)::Bool</code></pre><p>Determine whether a centrally symmetric set is bounded.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p><code>true</code> (since a set with a unique center must be bounded).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractCentrallySymmetric.jl#L47-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(S::AbstractCentrallySymmetric{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a centrally symmetric set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p>The center of the centrally symmetric set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractCentrallySymmetric.jl#L64-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{AbstractCentrallySymmetric}" href="#Base.isempty-Tuple{AbstractCentrallySymmetric}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(S::AbstractCentrallySymmetric)::Bool</code></pre><p>Return if a centrally symmetric set is empty or not.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractCentrallySymmetric.jl#L81-L93">source</a></section><h2><a class="nav-anchor" id="Polyhedron-1" href="#Polyhedron-1">Polyhedron</a></h2><p>A polyhedron has finitely many facets (<em>H-representation</em>) and is not necessarily bounded.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractPolyhedron" href="#LazySets.AbstractPolyhedron"><code>LazySets.AbstractPolyhedron</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractPolyhedron{N&lt;:Real} &lt;: LazySet{N}</code></pre><p>Abstract type for compact convex polyhedral sets.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolyhedron</code> must define the following functions:</p><ul><li><code>constraints_list(::AbstractPolyhedron{N})</code> – return a list of all facet   constraints</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolyhedron)
6-element Array{Any,1}:
 AbstractPolytope
 HPolyhedron
 HalfSpace
 Hyperplane
 Line
 Universe</code></pre><p>Polyhedra are defined as the intersection of a finite number of closed half-spaces. As such, polyhedra are closed and convex but not necessarily bounded. Bounded polyhedra are called <em>polytopes</em> (see <a href="#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractPolyhedron.jl#L3-L29">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractPolyhedron{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractPolyhedron{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, P::AbstractPolyhedron{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a polyhedron.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>P</code> – polyhedron</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation checks if the point lies inside each defining half-space.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractPolyhedron_functions.jl#L9-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constrained_dimensions-Tuple{AbstractPolyhedron}" href="#LazySets.constrained_dimensions-Tuple{AbstractPolyhedron}"><code>LazySets.constrained_dimensions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constrained_dimensions(P::AbstractPolyhedron)::Vector{Int} where {N&lt;:Real}</code></pre><p>Return the indices in which a polyhedron is constrained.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polyhedron</li></ul><p><strong>Output</strong></p><p>A vector of ascending indices <code>i</code> such that the polyhedron is constrained in dimension <code>i</code>.</p><p><strong>Examples</strong></p><p>A 2D polyhedron with constraint <span>$x1 ≥ 0$</span> is constrained in dimension 1 only.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractPolyhedron_functions.jl#L39-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolyhedron{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolyhedron{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N},
           P::AbstractPolyhedron{N};
           check_invertibility::Bool=true,
           cond_tol::Number=DEFAULT_COND_TOL,
           use_inv::Bool=!issparse(M)
           ) where {N&lt;:Real}</code></pre><p>Concrete linear map of a polyhedron in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>P</code> – abstract polyhedron</li><li><code>check_invertibility</code> – (optional, deault: <code>true</code>) check if the linear map is                          invertible, in which case this function uses the matrix                          inverse; if the invertibility check fails, or if                          this flag is set to <code>false</code>, use the vertex representation                          to compute the linear map (see below for details)</li><li><code>cond_tol</code> – (optional) tolerance of matrix condition (used to check whether               the matrix is invertible)</li><li><code>use_inv</code>  – (optional, default: <code>false</code> if <code>M</code> is sparse and <code>true</code>               otherwise) whether to compute the full left division through               <code>inv(M)</code>, or to use the left division for each vector; see below </li></ul><p><strong>Output</strong></p><p>The type of the result is &quot;as close as possible&quot; to the the type of <code>P</code>. Let <code>(m, n)</code> be the size of <code>M</code>, where <code>m ≠ n</code> is allowed for rectangular maps.</p><p>To fix the type of the output to something different than the default value, consider post-processing the result of this function with a call to a suitable <code>convert</code> method.</p><p>In particular, the output depends on the type of <code>P</code>, on <code>m</code>, and the algorithm that was used:</p><ul><li><p>If the vertex-based approach was used:</p><ul><li>If <code>P</code> is a <code>VPolygon</code> and <code>m = 2</code> then the output is a <code>VPolygon</code>.</li><li>If <code>P</code> is a <code>VPolytope</code> then the output is a <code>VPolytope</code>.</li><li>Otherwise, the output is an <code>Interval</code> if <code>m = 1</code>, a <code>VPolygon</code> if <code>m = 2</code> and a <code>VPolytope</code> in other cases.</li></ul></li><li><p>If the invertibility criterion was used:</p><ul><li>The types of <code>HalfSpace</code>, <code>Hyperplane</code>, <code>Line</code> and <code>AbstractHPolygon</code> are preserved.</li><li>If <code>P</code> is an <code>AbstractPolytope</code>, then the output is an <code>Interval</code> if <code>m = 1</code>, an <code>HPolygon</code> if <code>m = 2</code> and an <code>HPolytope</code> in other cases.</li><li>Otherwise, the output is an <code>HPolyhedron</code>.</li></ul></li></ul><p><strong>Algorithm</strong></p><p>This function implements two algorithms for the linear map:</p><ul><li>If the matrix <span>$M$</span> is invertible (which we check with a sufficient condition), then <span>$y = M x$</span> implies <span>$x = \text{inv}(M) y$</span> and we transform the constraint system <span>$A x ≤ b$</span> to <span>$A \text{inv}(M) y ≤ b$</span>.</li><li>Otherwise, we transform the polyhedron to vertex representation and apply the map to each vertex, returning a polyhedron in vertex representation. </li></ul><p>Note that the vertex representation (second approach) is only available if the polyhedron is bounded. Hence we check boundedness first.</p><p>To switch off the check for invertibility, set the option <code>check_invertibility=false</code>. If <code>M</code> is not invertible and the polyhedron is unbounded, this function returns an exception.</p><p>The option <code>use_inv</code> lets the user control - in case <code>M</code> is invertible - if the full matrix inverse is computed, or only the left division on the normal vectors. Note that this helps as a workaround when <code>M</code> is a sparse matrix, since the <code>inv</code> function is not available for sparse matrices. In this case, either use the option <code>use_inv=false</code> or convert the type of <code>M</code> as in <code>linear_map(Matrix(M), P)</code>.</p><p>Internally, this function operates at the level of the <code>AbstractPolyhedron</code> interface, but the actual algorithm uses dispatch on the concrete type of <code>P</code>, depending on the algorithm that is used:</p><ul><li><code>_linear_map_vrep(M, P)</code> if the vertex approach is used</li><li><code>_linear_map_hrep(M, P, use_inv)</code> if the invertibility criterion is used</li></ul><p>New subtypes of the interface should write their own <code>_linear_map_vrep</code> (resp. <code>_linear_map_hrep</code>) for special handling of the linear map; otherwise the fallback implementation for <code>AbstractPolyhedron</code> is used (see below).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractPolyhedron_functions.jl#L213-L299">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.minkowski_sum-Union{Tuple{N}, Tuple{AbstractPolyhedron{N},AbstractPolyhedron{N}}} where N&lt;:Real" href="#LazySets.minkowski_sum-Union{Tuple{N}, Tuple{AbstractPolyhedron{N},AbstractPolyhedron{N}}} where N&lt;:Real"><code>LazySets.minkowski_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">minkowski_sum(P::AbstractPolyhedron{N}, Q::AbstractPolyhedron{N};
              [backend]=nothing,
              [algorithm]=nothing,
              [prune]=true) where {N&lt;:Real}</code></pre><p>Compute the Minkowski sum between two polyhedra in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>         – polyhedron in constraint representation</li><li><code>Q</code>         – another polyhedron in constraint representation</li><li><code>backend</code>   – (optional, default: <code>nothing</code>) polyhedral computations backend</li><li><code>algorithm</code> – (optional, default: <code>nothing</code>) algorithm to compute the elimination                of variables; available options are <code>Polyhedra.FourierMotzkin</code>,                <code>Polyhedra.BlockElimination</code>, and <code>Polyhedra.ProjectGenerators</code></li><li><code>prune</code>     – (optional, default: <code>true</code>) if <code>true</code>, apply a post-processing algorithm                to remove redundant constraints</li></ul><p><strong>Output</strong></p><p>A polyhedron in H-representation that corresponds to the Minkowski sum of <code>P</code> and <code>Q</code>.</p><p><strong>Notes</strong></p><p>This method requires <code>Polyhedra</code> and <code>CDDLib</code>, so you have to do:</p><pre><code class="language-julia">julia&gt; using LazySets, Polyhedra, CDDLib

julia&gt; ...

julia&gt; minkowski_sum(P, Q)</code></pre><p><strong>Algorithm</strong></p><p>This function implements the concrete Minkowski sum by projection and variable elimination as detailed in [1]. The idea is that if we write <span>$P$</span> and <span>$Q$</span> in <em>simple H-representation</em>, that is, <span>$P = \{x ∈ \mathbb{R}^n : Ax ≤ b \}$</span> and <span>$Q = \{x ∈ \mathbb{R}^n : Cx ≤ d \}$</span>, then their Minkowski sum can be seen as the projection onto the first <span>$n$</span>-dimensional coordinates of the polyhedron</p><div>\[    \begin{pmatrix} 0 &amp; A \ C &amp; -C \end{pmatrix} \binom{x}{y} ≤ inom{b}{d}\]</div><p>This is seen by noting that <span>$P ⊕ Q$</span> corresponds to the set of points <span>$x ∈ \mathbb{R}^n$</span> such that <span>$x = y + z$</span> with <span>$Ay ≤ b$</span> and <span>$Cz ≤ d$</span>; hence it follows that <span>$Ay ≤ b$</span> and <span>$C(x-y) ≤ d$</span>, and the inequality displayed above follows by considering the <span>$2n$</span>-dimensional space <span>$\binom{x}{y}$</span>. The reduction from <span>$2n$</span> to <span>$n$</span> variables is performed using an elimination algorithm as described next.</p><p>The elimination of variables depends on the concrete polyhedra library <code>Polyhedra</code>, which itself uses <code>CDDLib</code> for variable elimination. The available algorithms are:</p><ul><li><p><code>Polyhedra.FourierMotzkin</code>   – computation of the projection by computing the                                 H-representation and applying the Fourier-Motzkin                                 elimination algorithm to it</p></li><li><p><code>Polyhedra.BlockElimination</code> – computation of the projection by computing the                                 H-representation and applying the block elimination                                 algorithm to it</p></li><li><p><code>Polyhedra.ProjectGenerators</code> – computation of the projection by computing the                                  V-representation</p></li></ul><p>[1] Kvasnica, Michal. &quot;Minkowski addition of convex polytopes.&quot; (2005): 1-10.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/concrete_minkowski_sum.jl#L64-L132">source</a></section><p>Plotting (bounded) polyhedra is available, too:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.plot_recipe-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}, Tuple{AbstractPolyhedron{N},N}} where N&lt;:Real" href="#LazySets.plot_recipe-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}, Tuple{AbstractPolyhedron{N},N}} where N&lt;:Real"><code>LazySets.plot_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_recipe(P::AbstractPolyhedron{N}, [ε]::N=zero(N)) where {N&lt;:Real}</code></pre><p>Convert a (bounded) polyhedron to a pair <code>(x, y)</code> of points for plotting.</p><p><strong>Input</strong></p><ul><li><code>P</code> – bounded polyhedron</li><li><code>ε</code> – (optional, default: <code>0</code>) ignored, used for dispatch</li></ul><p><strong>Output</strong></p><p>A pair <code>(x, y)</code> of points that can be plotted.</p><p><strong>Algorithm</strong></p><p>We first assert that <code>P</code> is bounded (i.e., that <code>P</code> is a polytope).</p><p>One-dimensional polytopes are converted to an <code>Interval</code>. Three-dimensional or higher-dimensional polytopes are not supported.</p><p>For two-dimensional polytopes (i.e., polygons) we compute their set of vertices using <code>vertices_list</code> and then plot the convex hull of these vertices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractPolyhedron_functions.jl#L368-L391">source</a></section><h3><a class="nav-anchor" id="Polytope-1" href="#Polytope-1">Polytope</a></h3><p>A polytope is a bounded set with finitely many vertices (<em>V-representation</em>) resp. facets (<em>H-representation</em>). Note that there is a special interface combination <a href="#Centrally-symmetric-polytope-1">Centrally symmetric polytope</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractPolytope" href="#LazySets.AbstractPolytope"><code>LazySets.AbstractPolytope</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractPolytope{N&lt;:Real} &lt;: AbstractPolyhedron{N}</code></pre><p>Abstract type for compact convex polytopic sets.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolytope</code> must define the following functions:</p><ul><li><code>vertices_list(::AbstractPolytope{N})::Vector{Vector{N}}</code> – return a list of   all vertices</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolytope)
4-element Array{Any,1}:
 AbstractCentrallySymmetricPolytope
 AbstractPolygon
 HPolytope
 VPolytope</code></pre><p>A polytope is a bounded polyhedron (see <a href="#LazySets.AbstractPolyhedron"><code>AbstractPolyhedron</code></a>). Polytopes are compact convex sets with either of the following equivalent properties:</p><ol><li>They are the intersection of a finite number of closed half-spaces.</li><li>They are the convex hull of finitely many vertices.</li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractPolytope.jl#L9-L34">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{AbstractPolytope}" href="#LazySets.isbounded-Tuple{AbstractPolytope}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(P::AbstractPolytope)::Bool</code></pre><p>Determine whether a polytopic set is bounded.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polytopic set</li></ul><p><strong>Output</strong></p><p><code>true</code> (since a polytope must be bounded).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractPolytope.jl#L42-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">singleton_list(P::AbstractPolytope{N})::Vector{Singleton{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a polytopic set as a list of singletons.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polytopic set</li></ul><p><strong>Output</strong></p><p>List containing a singleton for each vertex.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractPolytope.jl#L59-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{AbstractPolytope}" href="#Base.isempty-Tuple{AbstractPolytope}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(P::AbstractPolytope)::Bool</code></pre><p>Determine whether a polytope is empty.</p><p><strong>Input</strong></p><ul><li><code>P</code> – abstract polytope</li></ul><p><strong>Output</strong></p><p><code>true</code> if the given polytope contains no vertices, and <code>false</code> otherwise.</p><p><strong>Algorithm</strong></p><p>This algorithm checks whether the <code>vertices_list</code> of the given polytope is empty or not.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractPolytope.jl#L77-L94">source</a></section><h4><a class="nav-anchor" id="Polygon-1" href="#Polygon-1">Polygon</a></h4><p>A polygon is a two-dimensional polytope.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractPolygon" href="#LazySets.AbstractPolygon"><code>LazySets.AbstractPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractPolygon{N&lt;:Real} &lt;: AbstractPolytope{N}</code></pre><p>Abstract type for polygons (i.e., 2D polytopes).</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolygon</code> must define the following functions:</p><ul><li><code>tovrep(::AbstractPolygon{N})::VPolygon{N}</code>         – transform into   V-representation</li><li><code>tohrep(::AbstractPolygon{N})::S where {S&lt;:AbstractHPolygon{N}}</code> – transform   into H-representation</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolygon)
2-element Array{Any,1}:
 AbstractHPolygon
 VPolygon</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractPolygon.jl#L7-L26">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractPolygon}" href="#LazySets.dim-Tuple{AbstractPolygon}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(P::AbstractPolygon)::Int</code></pre><p>Return the ambient dimension of a polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polygon, which is 2.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractPolygon.jl#L33-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolygon{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolygon{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N},
           P::AbstractPolyhedron{N};
           check_invertibility::Bool=true,
           cond_tol::Number=DEFAULT_COND_TOL,
           use_inv::Bool=!issparse(M)
           ) where {N&lt;:Real}</code></pre><p>Concrete linear map of a polyhedron in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>P</code> – abstract polyhedron</li><li><code>check_invertibility</code> – (optional, deault: <code>true</code>) check if the linear map is                          invertible, in which case this function uses the matrix                          inverse; if the invertibility check fails, or if                          this flag is set to <code>false</code>, use the vertex representation                          to compute the linear map (see below for details)</li><li><code>cond_tol</code> – (optional) tolerance of matrix condition (used to check whether               the matrix is invertible)</li><li><code>use_inv</code>  – (optional, default: <code>false</code> if <code>M</code> is sparse and <code>true</code>               otherwise) whether to compute the full left division through               <code>inv(M)</code>, or to use the left division for each vector; see below </li></ul><p><strong>Output</strong></p><p>The type of the result is &quot;as close as possible&quot; to the the type of <code>P</code>. Let <code>(m, n)</code> be the size of <code>M</code>, where <code>m ≠ n</code> is allowed for rectangular maps.</p><p>To fix the type of the output to something different than the default value, consider post-processing the result of this function with a call to a suitable <code>convert</code> method.</p><p>In particular, the output depends on the type of <code>P</code>, on <code>m</code>, and the algorithm that was used:</p><ul><li><p>If the vertex-based approach was used:</p><ul><li>If <code>P</code> is a <code>VPolygon</code> and <code>m = 2</code> then the output is a <code>VPolygon</code>.</li><li>If <code>P</code> is a <code>VPolytope</code> then the output is a <code>VPolytope</code>.</li><li>Otherwise, the output is an <code>Interval</code> if <code>m = 1</code>, a <code>VPolygon</code> if <code>m = 2</code> and a <code>VPolytope</code> in other cases.</li></ul></li><li><p>If the invertibility criterion was used:</p><ul><li>The types of <code>HalfSpace</code>, <code>Hyperplane</code>, <code>Line</code> and <code>AbstractHPolygon</code> are preserved.</li><li>If <code>P</code> is an <code>AbstractPolytope</code>, then the output is an <code>Interval</code> if <code>m = 1</code>, an <code>HPolygon</code> if <code>m = 2</code> and an <code>HPolytope</code> in other cases.</li><li>Otherwise, the output is an <code>HPolyhedron</code>.</li></ul></li></ul><p><strong>Algorithm</strong></p><p>This function implements two algorithms for the linear map:</p><ul><li>If the matrix <span>$M$</span> is invertible (which we check with a sufficient condition), then <span>$y = M x$</span> implies <span>$x = \text{inv}(M) y$</span> and we transform the constraint system <span>$A x ≤ b$</span> to <span>$A \text{inv}(M) y ≤ b$</span>.</li><li>Otherwise, we transform the polyhedron to vertex representation and apply the map to each vertex, returning a polyhedron in vertex representation. </li></ul><p>Note that the vertex representation (second approach) is only available if the polyhedron is bounded. Hence we check boundedness first.</p><p>To switch off the check for invertibility, set the option <code>check_invertibility=false</code>. If <code>M</code> is not invertible and the polyhedron is unbounded, this function returns an exception.</p><p>The option <code>use_inv</code> lets the user control - in case <code>M</code> is invertible - if the full matrix inverse is computed, or only the left division on the normal vectors. Note that this helps as a workaround when <code>M</code> is a sparse matrix, since the <code>inv</code> function is not available for sparse matrices. In this case, either use the option <code>use_inv=false</code> or convert the type of <code>M</code> as in <code>linear_map(Matrix(M), P)</code>.</p><p>Internally, this function operates at the level of the <code>AbstractPolyhedron</code> interface, but the actual algorithm uses dispatch on the concrete type of <code>P</code>, depending on the algorithm that is used:</p><ul><li><code>_linear_map_vrep(M, P)</code> if the vertex approach is used</li><li><code>_linear_map_hrep(M, P, use_inv)</code> if the invertibility criterion is used</li></ul><p>New subtypes of the interface should write their own <code>_linear_map_vrep</code> (resp. <code>_linear_map_hrep</code>) for special handling of the linear map; otherwise the fallback implementation for <code>AbstractPolyhedron</code> is used (see below).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractPolyhedron_functions.jl#L213-L299">source</a></section><h5><a class="nav-anchor" id="HPolygon-1" href="#HPolygon-1">HPolygon</a></h5><p>An HPolygon is a polygon in H-representation (or constraint representation).</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractHPolygon" href="#LazySets.AbstractHPolygon"><code>LazySets.AbstractHPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractHPolygon{N&lt;:Real} &lt;: AbstractPolygon{N}</code></pre><p>Abstract type for polygons in H-representation (i.e., constraints).</p><p><strong>Notes</strong></p><p>All subtypes must satisfy the invariant that constraints are sorted counter-clockwise.</p><p>Every concrete <code>AbstractHPolygon</code> must have the following fields:</p><ul><li><code>constraints::Vector{LinearConstraint{N}}</code> – the constraints</li></ul><p>New subtypes should be added to the <code>convert</code> method in order to be convertible.</p><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractHPolygon)
2-element Array{Any,1}:
 HPolygon
 HPolygonOpt</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHPolygon.jl#L20-L41">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(P::AbstractHPolygon{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>A vertex of the polygon in constraint representation (the first one in the order of the constraints).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHPolygon.jl#L166-L179">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHPolygon{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHPolygon{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, P::AbstractHPolygon{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given 2D point is contained in a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>x</code> – two-dimensional point/vector</li><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation checks if the point lies on the outside of each edge.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHPolygon.jl#L186-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Union{Tuple{Type{HPOLYGON}}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon" href="#Base.rand-Union{Tuple{Type{HPOLYGON}}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{HPOLYGON}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing,
     [num_constraints]::Int=-1
    )::HPOLYGON{N} where {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Create a random polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPOLYGON</code>        – type for dispatch</li><li><code>N</code>               – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>             – (optional, default: 2) dimension</li><li><code>rng</code>             – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>            – (optional, default: <code>nothing</code>) seed for reseeding</li><li><code>num_constraints</code> – (optional, default: <code>-1</code>) number of constraints of the                      polygon (must be 3 or bigger; see comment below)</li></ul><p><strong>Output</strong></p><p>A random polygon in constraint representation.</p><p><strong>Algorithm</strong></p><p>We create a random polygon in vertex representation and convert it to constraint representation. See <a href="../representations/#Base.rand-Tuple{Type{VPolygon}}"><code>rand(::Type{VPolygon})</code></a>. For non-flat polygons the number of vertices and the number of constraints are identical.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHPolygon.jl#L216-L245">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tohrep-Union{Tuple{HPOLYGON}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon" href="#LazySets.tohrep-Union{Tuple{HPOLYGON}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon"><code>LazySets.tohrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tohrep(P::HPOLYGON)::HPOLYGON where {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Build a contraint representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>The identity, i.e., the same polygon instance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHPolygon.jl#L66-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tovrep-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.tovrep-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.tovrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tovrep(P::AbstractHPolygon{N})::VPolygon{N} where {N&lt;:Real}</code></pre><p>Build a vertex representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>The same polygon but in vertex representation, a <code>VPolygon</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHPolygon.jl#L48-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.addconstraint!-Union{Tuple{N}, Tuple{AbstractHPolygon{N},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.addconstraint!-Union{Tuple{N}, Tuple{AbstractHPolygon{N},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">addconstraint!(P::AbstractHPolygon{N},
               constraint::LinearConstraint{N};
               [linear_search]::Bool=(length(P.constraints) &lt;
                                      BINARY_SEARCH_THRESHOLD),
               [prune]::Bool=true
              )::Nothing where {N&lt;:Real}</code></pre><p>Add a linear constraint to a polygon in constraint representation, keeping the constraints sorted by their normal directions.</p><p><strong>Input</strong></p><ul><li><code>P</code>             – polygon in constraint representation</li><li><code>constraint</code>    – linear constraint to add</li><li><code>linear_search</code> – (optional, default: <code>length(constraints) &lt;                    BINARY_SEARCH_THRESHOLD</code>) flag to choose between linear                    and binary search</li><li><code>prune</code>         – (optional, default: <code>true</code>) flag for removing redundant                    constraints in the end</li></ul><p><strong>Output</strong></p><p>Nothing.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHPolygon.jl#L376-L400">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.addconstraint!-Union{Tuple{LC}, Tuple{N}, Tuple{Array{LC,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where LC&lt;:(HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}) where N&lt;:Real" href="#LazySets.addconstraint!-Union{Tuple{LC}, Tuple{N}, Tuple{Array{LC,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where LC&lt;:(HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}) where N&lt;:Real"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">addconstraint!(constraints::Vector{LC},
               new_constraint::LinearConstraint{N};
               [linear_search]::Bool=(length(P.constraints) &lt;
                                      BINARY_SEARCH_THRESHOLD),
               [prune]::Bool=true
              )::Nothing where {N&lt;:Real, LC&lt;:LinearConstraint{N}}</code></pre><p>Add a linear constraint to a sorted vector of constrains, keeping the constraints sorted by their normal directions.</p><p><strong>Input</strong></p><ul><li><code>constraints</code>    – vector of linear constraintspolygon in constraint                     representation</li><li><code>new_constraint</code> – linear constraint to add</li><li><code>linear_search</code>  – (optional, default: <code>length(constraints) &lt;                     BINARY_SEARCH_THRESHOLD</code>) flag to choose between linear                     and binary search</li><li><code>prune</code>          – (optional, default: <code>true</code>) flag for removing redundant                     constraints in the end</li></ul><p><strong>Output</strong></p><p>Nothing.</p><p><strong>Algorithm</strong></p><p>If <code>prune</code> is active, we check if the new constraint is redundant. If the constraint is not redundant, we perform the same check to the left and to the right until we find the first constraint that is not redundant.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHPolygon.jl#L411-L442">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isredundant-Union{Tuple{N}, Tuple{HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.isredundant-Union{Tuple{N}, Tuple{HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.isredundant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isredundant(cmid::LinearConstraint{N}, cright::LinearConstraint{N},
            cleft::LinearConstraint{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a linear constraint is redundant wrt. two surrounding constraints.</p><p><strong>Input</strong></p><ul><li><code>cmid</code>   – linear constraint of concern</li><li><code>cright</code> – linear constraint to the right (clockwise turn)</li><li><code>cleft</code>  – linear constraint to the left (counter-clockwise turn)</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the constraint is redundant.</p><p><strong>Algorithm</strong></p><p>We first check whether the angle between the surrounding constraints is &lt; 180°, which is a necessary condition (unless the direction is identical to one of the other two constraints). If so, we next check if the angle is 0°, in which case the constraint <code>cmid</code> is redundant unless it is strictly tighter than the other two constraints. If the angle is strictly between 0° and 180°, the constraint <code>cmid</code> is redundant if and only if the vertex defined by the other two constraints lies inside the set defined by <code>cmid</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHPolygon.jl#L265-L291">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.remove_redundant_constraints!-Tuple{AbstractHPolygon}" href="#LazySets.remove_redundant_constraints!-Tuple{AbstractHPolygon}"><code>LazySets.remove_redundant_constraints!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">remove_redundant_constraints!(P::AbstractHPolygon)</code></pre><p>Remove all redundant constraints of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>The same polygon with all redundant constraints removed.</p><p><strong>Notes</strong></p><p>Since we only consider bounded polygons and a polygon needs at least three constraints to be bounded, we stop removing redundant constraints if there are three or less constraints left. This means that for non-bounded polygons the result may be unexpected.</p><p><strong>Algorithm</strong></p><p>We go through all consecutive triples of constraints and check if the one in the middle is redundant. For this we assume that the constraints are sorted.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHPolygon.jl#L327-L352">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(P::AbstractHPolygon{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints defining a polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in H-representation</li></ul><p><strong>Output</strong></p><p>The list of constraints of the polygon. The implementation guarantees that the constraints are sorted counter-clockwise.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHPolygon.jl#L144-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}, Tuple{AbstractHPolygon{N},Bool}, Tuple{AbstractHPolygon{N},Bool,Bool}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}, Tuple{AbstractHPolygon{N},Bool}, Tuple{AbstractHPolygon{N},Bool,Bool}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(P::AbstractHPolygon{N},
              apply_convex_hull::Bool=false,
              check_feasibility::Bool=true
             )::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>                 – polygon in constraint representation</li><li><code>apply_convex_hull</code> – (optional, default: <code>false</code>) flag to post-process the                        intersection of constraints with a convex hull</li><li><code>check_feasibility</code> – (optional, default: <code>true</code>) flag to check whether the                        polygon was empty (required for correctness in case of                        empty polygons)</li></ul><p><strong>Output</strong></p><p>List of vertices.</p><p><strong>Algorithm</strong></p><p>We compute each vertex as the intersection of consecutive lines defined by the half-spaces. If <code>check_feasibility</code> is active, we then check if the constraints of the polygon were actually feasible (i.e., they pointed in the <em>right</em> direction). For this we compute the <em>average</em> of all vertices and check membership in each constraint.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHPolygon.jl#L87-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded" href="#LazySets.isbounded"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isbounded(P::AbstractHPolygon, [use_type_assumption]::Bool=true)::Bool</code></pre><p>Determine whether a polygon in constraint representation is bounded.</p><p><strong>Input</strong></p><ul><li><code>P</code>                   – polygon in constraint representation</li><li><code>use_type_assumption</code> – (optional, default: <code>true</code>) flag for ignoring the                          type assumption that polygons are bounded</li></ul><p><strong>Output</strong></p><p><code>true</code> if <code>use_type_assumption</code> is activated. Otherwise, <code>true</code> iff <code>P</code> is bounded.</p><p><strong>Algorithm</strong></p><p>If <code>!use_type_assumption</code>, we convert <code>P</code> to an <code>HPolyhedron</code> <code>P2</code> and then use <code>isbounded(P2)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHPolygon.jl#L569-L589">source</a></section><h4><a class="nav-anchor" id="Centrally-symmetric-polytope-1" href="#Centrally-symmetric-polytope-1">Centrally symmetric polytope</a></h4><p>A centrally symmetric polytope is a combination of two other interfaces: <a href="#Centrally-symmetric-set-1">Centrally symmetric set</a> and <a href="#Polytope-1">Polytope</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractCentrallySymmetricPolytope" href="#LazySets.AbstractCentrallySymmetricPolytope"><code>LazySets.AbstractCentrallySymmetricPolytope</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractCentrallySymmetricPolytope{N&lt;:Real} &lt;: AbstractPolytope{N}</code></pre><p>Abstract type for centrally symmetric, polytopic sets. It combines the <code>AbstractCentrallySymmetric</code> and <code>AbstractPolytope</code> interfaces. Such a type combination is necessary as long as Julia does not support <a href="https://github.com/JuliaLang/julia/issues/5">multiple inheritance</a>.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractCentrallySymmetricPolytope</code> must define the following functions:</p><ul><li>from <code>AbstractCentrallySymmetric</code>:<ul><li><code>center(::AbstractCentrallySymmetricPolytope{N})::Vector{N}</code> – return the  center point</li></ul></li><li>from <code>AbstractPolytope</code>:<ul><li><code>vertices_list(::AbstractCentrallySymmetricPolytope{N})::Vector{Vector{N}}</code>  – return a list of all vertices</li></ul></li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractCentrallySymmetricPolytope)
2-element Array{Any,1}:
 AbstractZonotope
 Ball1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractCentrallySymmetricPolytope.jl#L9-L34">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}" href="#LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(P::AbstractCentrallySymmetricPolytope)::Int</code></pre><p>Return the ambient dimension of a centrally symmetric, polytopic set.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric, polytopic set</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polytopic set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractCentrallySymmetricPolytope.jl#L42-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(P::AbstractCentrallySymmetricPolytope{N})::Vector{N}
    where {N&lt;:Real}</code></pre><p>Return some element of a centrally symmetric polytope.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric polytope</li></ul><p><strong>Output</strong></p><p>The center of the centrally symmetric polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractCentrallySymmetricPolytope.jl#L60-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}" href="#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(P::AbstractCentrallySymmetricPolytope)::Bool</code></pre><p>Return if a centrally symmetric, polytopic set is empty or not.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric, polytopic set</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractCentrallySymmetricPolytope.jl#L79-L91">source</a></section><h5><a class="nav-anchor" id="AbstractZonotope-1" href="#AbstractZonotope-1">AbstractZonotope</a></h5><p>A zonotope is a specific centrally symmetric polytope characterized by a center and a collection of generators.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractZonotope" href="#LazySets.AbstractZonotope"><code>LazySets.AbstractZonotope</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractZonotope{N&lt;:Real} &lt;: AbstractCentrallySymmetricPolytope{N}</code></pre><p>Abstract type for zonotopic sets.</p><p><strong>Notes</strong></p><p>Mathematically, a zonotope is defined as the set</p><div>\[Z = \left\{ c + ∑_{i=1}^p ξ_i g_i,~~ ξ_i \in [-1, 1]~~ ∀ i = 1,…, p \right\},\]</div><p>where <span>$c \in \mathbb{R}^n$</span> is its center and <span>$\{g_i\}_{i=1}^p$</span>, <span>$g_i \in \mathbb{R}^n$</span>, is the set of generators. This characterization defines a zonotope as the finite Minkowski sum of line segments. Zonotopes can be equivalently described as the image of a unit infinity-norm ball in <span>$\mathbb{R}^n$</span> by an affine transformation.</p><p>See <a href="../representations/#LazySets.Zonotope"><code>Zonotope</code></a> for a standard implementation of this interface.</p><p>Every concrete <code>AbstractZonotope</code> must define the following functions:</p><ul><li><code>genmat(::AbstractZonotope{N})::AbstractMatrix{N}</code> – return the generator   matrix</li><li><code>generators(::AbstractZonotope{N})</code> – return an iterator over the generators</li></ul><p>Since the functions <code>genmat</code> and <code>generators</code> can be defined in terms of each other, it is sufficient to only genuinely implement one of them and let the implementation of the other function call the fallback implementation <code>genmat_fallback</code> resp. <code>generators_fallback</code>.</p><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractZonotope)
3-element Array{Any,1}:
 AbstractHyperrectangle
 LineSegment
 Zonotope</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractZonotope.jl#L6-L44">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ngens-Tuple{AbstractZonotope}" href="#LazySets.ngens-Tuple{AbstractZonotope}"><code>LazySets.ngens</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ngens(Z::AbstractZonotope)::Int</code></pre><p>Return the number of generators of a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>An integer representing the number of generators.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractZonotope.jl#L123-L135">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.genmat_fallback-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.genmat_fallback-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.genmat_fallback</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">genmat_fallback(Z::AbstractZonotope{N}) where {N&lt;:Real}</code></pre><p>Fallback definition of <code>genmat</code> for zonotopic sets.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>A matrix where each column represents one generator of <code>Z</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractZonotope.jl#L52-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.generators_fallback-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.generators_fallback-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.generators_fallback</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">generators_fallback(Z::AbstractZonotope{N}) where {N&lt;:Real}</code></pre><p>Fallback definition of <code>generators</code> for zonotopic sets.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>An iterator over the generators of <code>Z</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractZonotope.jl#L102-L114">source</a></section><h5><a class="nav-anchor" id="Hyperrectangle-1" href="#Hyperrectangle-1">Hyperrectangle</a></h5><p>A hyperrectangle is a special centrally symmetric polytope with axis-aligned facets.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractHyperrectangle" href="#LazySets.AbstractHyperrectangle"><code>LazySets.AbstractHyperrectangle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractHyperrectangle{N&lt;:Real} &lt;: AbstractZonotope{N}</code></pre><p>Abstract type for hyperrectangular sets.</p><p><strong>Notes</strong></p><p>See <a href="../representations/#LazySets.Hyperrectangle"><code>Hyperrectangle</code></a> for a standard implementation of this interface.</p><p>Every concrete <code>AbstractHyperrectangle</code> must define the following functions:</p><ul><li><code>radius_hyperrectangle(::AbstractHyperrectangle{N})::Vector{N}</code> – return the   hyperrectangle&#39;s radius, which is a full-dimensional vector</li><li><code>radius_hyperrectangle(::AbstractHyperrectangle{N}, i::Int)::N</code> – return the   hyperrectangle&#39;s radius in the <code>i</code>-th dimension</li><li><code>isflat(::AbstractHyperrectangle{N})::Bool</code> – determine whether the   hyperrectangle&#39;s radius is zero in some dimension</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractHyperrectangle)
5-element Array{Any,1}:
 AbstractSingleton
 BallInf
 Hyperrectangle
 Interval
 SymmetricIntervalHull</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHyperrectangle.jl#L11-L37">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">norm(H::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the norm of a hyperrectangular set.</p><p>The norm of a hyperrectangular set is defined as the norm of the enclosing ball, of the given <span>$p$</span>-norm, of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p><p><strong>Algorithm</strong></p><p>Recall that the norm is defined as</p><div>\[‖ X ‖ = \max_{x ∈ X} ‖ x ‖_p = max_{x ∈ \text{vertices}(X)} ‖ x ‖_p.\]</div><p>The last equality holds because the optimum of a convex function over a polytope is attained at one of its vertices.</p><p>This implementation uses the fact that the maximum is achieved in the vertex <span>$c + \text{diag}(\text{sign}(c)) r$</span>, for any <span>$p$</span>-norm, hence it suffices to take the <span>$p$</span>-norm of this particular vertex. This statement is proved below. Note that, in particular, there is no need to compute the <span>$p$</span>-norm for <em>each</em> vertex, which can be very expensive. </p><p>If <span>$X$</span> is an axis-aligned hyperrectangle and the <span>$n$</span>-dimensional vectors center and radius of the hyperrectangle are denoted <span>$c$</span> and <span>$r$</span> respectively, then reasoning on the <span>$2^n$</span> vertices we have that:</p><div>\[\max_{x ∈ \text{vertices}(X)} ‖ x ‖_p = \max_{α_1, …, α_n ∈ \{-1, 1\}} (|c_1 + α_1 r_1|^p + ... + |c_n + α_n r_n|^p)^{1/p}.\]</div><p>The function <span>$x ↦ x^p$</span>, <span>$p &gt; 0$</span>, is monotonically increasing and thus the maximum of each term <span>$|c_i + α_i r_i|^p$</span> is given by <span>$|c_i + \text{sign}(c_i) r_i|^p$</span> for each <span>$i$</span>. Hence, <span>$x^* := \text{argmax}_{x ∈ X} ‖ x ‖_p$</span> is the vertex <span>$c + \text{diag}(\text{sign}(c)) r$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHyperrectangle.jl#L283-L328">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius" href="#LazySets.radius"><code>LazySets.radius</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">radius(H::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the radius of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p><p><strong>Notes</strong></p><p>The radius is defined as the radius of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center. It is the same for all corners of a hyperrectangular set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHyperrectangle.jl#L334-L353">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a hyperrectangular set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the vertex with biggest values is returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHyperrectangle.jl#L233-L247">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Evaluate the support function of a hyperrectangular set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>Evaluation of the support function in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHyperrectangle.jl#L254-L267">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, H::AbstractHyperrectangle{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ H$</span>.</p><p><strong>Algorithm</strong></p><p>Let <span>$H$</span> be an <span>$n$</span>-dimensional hyperrectangular set, <span>$c_i$</span> and <span>$r_i$</span> be the box&#39;s center and radius and <span>$x_i$</span> be the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ H$</span> iff <span>$|c_i - x_i| ≤ r_i$</span> for all <span>$i=1,…,n$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHyperrectangle.jl#L358-L378">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(H::AbstractHyperrectangle{N}
             )::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A list of vertices. Zeros in the radius are correctly handled, i.e., the result does not contain any duplicate vertices.</p><p><strong>Notes</strong></p><p>For high dimensions, it is preferable to develop a <code>vertex_iterator</code> approach.</p><p><strong>Algorithm</strong></p><p>First we identify the dimensions where <code>H</code> is flat, i.e., its radius is zero. We also compute the number of vertices that we have to create.</p><p>Next we create the vertices. We do this by enumerating all vectors <code>v</code> of length <code>n</code> (the dimension of <code>H</code>) with entries <code>-1</code>/<code>0</code>/<code>1</code> and construct the corresponding vertex as follows:</p><div>\[    \text{vertex}(v)(i) = \begin{cases} c(i) + r(i) &amp; v(i) = 1 \\
                                          c(i) &amp; v(i) = 0 \\
                                          c(i) - r(i) &amp; v(i) = -1. \end{cases}\]</div><p>For enumerating the vectors <code>v</code>, we modify the current <code>v</code> from left to right by changing entries <code>-1</code> to <code>1</code>, skipping entries <code>0</code>, and stopping at the first entry <code>1</code> (but changing it to <code>-1</code>). This way we only need to change the vertex in those dimensions where <code>v</code> has changed, which usually is a smaller number than <code>n</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHyperrectangle.jl#L120-L160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of an axis-aligned hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A list of linear constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHyperrectangle.jl#L204-L216">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.high-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">high(H::AbstractHyperrectangle{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the higher coordinates of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A vector with the higher coordinates of the hyperrectangular set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHyperrectangle.jl#L394-L406">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},Int64}} where N&lt;:Real" href="#LazySets.high-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},Int64}} where N&lt;:Real"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">high(H::AbstractHyperrectangle{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the higher coordinate of a hyperrectangular set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The higher coordinate of the hyperrectangular set in the given dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHyperrectangle.jl#L411-L424">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.low-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">low(H::AbstractHyperrectangle{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the lower coordinates of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A vector with the lower coordinates of the hyperrectangular set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHyperrectangle.jl#L429-L441">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},Int64}} where N&lt;:Real" href="#LazySets.low-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},Int64}} where N&lt;:Real"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">low(H::AbstractHyperrectangle{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the lower coordinate of a hyperrectangular set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The lower coordinate of the hyperrectangular set in the given dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHyperrectangle.jl#L446-L459">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isflat-Tuple{AbstractHyperrectangle}" href="#LazySets.isflat-Tuple{AbstractHyperrectangle}"><code>LazySets.isflat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isflat(H::AbstractHyperrectangle)::Bool</code></pre><p>Determine whether a hyperrectangular set is flat, i.e. whether its radius is zero in some dimension.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the hyperrectangular set is flat.</p><p><strong>Notes</strong></p><p>For robustness with respect to floating-point inputs, this function relies on the result of <code>isapproxzero</code> when applied to the radius in some dimension. Hence, this function depends on the absolute zero tolerance <code>ABSZTOL</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHyperrectangle.jl#L464-L483">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.split-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractArray{Int64,1}}} where N&lt;:Real" href="#Base.split-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractArray{Int64,1}}} where N&lt;:Real"><code>Base.split</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">split(H::AbstractHyperrectangle{N}, num_blocks::AbstractVector{Int}
     ) where {N&lt;:Real}</code></pre><p>Partition a hyperrectangular set into uniform sub-hyperrectangles.</p><p><strong>Input</strong></p><ul><li><code>H</code>          – hyperrectangular set</li><li><code>num_blocks</code> – number of blocks in the partition for each dimension</li></ul><p><strong>Output</strong></p><p>A list of <code>Hyperrectangle</code>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHyperrectangle.jl#L488-L502">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.generators-Tuple{AbstractHyperrectangle}" href="#LazySets.generators-Tuple{AbstractHyperrectangle}"><code>LazySets.generators</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">generators(H::AbstractHyperrectangle)</code></pre><p>Return an iterator over the generators of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>An iterator over the generators of <code>H</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHyperrectangle.jl#L99-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.genmat-Tuple{AbstractHyperrectangle}" href="#LazySets.genmat-Tuple{AbstractHyperrectangle}"><code>LazySets.genmat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>genmat(H::AbstractHyperrectangle)</p><p>Return the generator matrix of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A matrix where each column represents one generator of <code>H</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHyperrectangle.jl#L45-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Arrays.rectify-Tuple{AbstractHyperrectangle}" href="#LazySets.Arrays.rectify-Tuple{AbstractHyperrectangle}"><code>LazySets.Arrays.rectify</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rectify(H::AbstractHyperrectangle)</code></pre><p>Concrete rectification of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The <code>Hyperrectangle</code> that corresponds to the rectification of <code>H</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractHyperrectangle.jl#L536-L548">source</a></section><h5><a class="nav-anchor" id="Singleton-1" href="#Singleton-1">Singleton</a></h5><p>A singleton is a special hyperrectangle consisting of only one point.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractSingleton" href="#LazySets.AbstractSingleton"><code>LazySets.AbstractSingleton</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractSingleton{N&lt;:Real} &lt;: AbstractHyperrectangle{N}</code></pre><p>Abstract type for sets with a single value.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractSingleton</code> must define the following functions:</p><ul><li><code>element(::AbstractSingleton{N})::Vector{N}</code> – return the single element</li><li><code>element(::AbstractSingleton{N}, i::Int)::N</code> – return the single element&#39;s   entry in the <code>i</code>-th dimension</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractSingleton)
2-element Array{Any,1}:
 Singleton
 ZeroSet</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractSingleton.jl#L8-L26">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The support vector, which is the set&#39;s vector itself, irrespective of the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractSingleton.jl#L264-L278">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Evaluate the support function of a set with a single value in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>Evaluation of the support function in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractSingleton.jl#L283-L296">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, S::AbstractSingleton{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ S$</span>.</p><p><strong>Notes</strong></p><p>This implementation performs an exact comparison, which may be insufficient with floating point computations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractSingleton.jl#L301-L319">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>An element of a convex set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/LazySet.jl#L278-L290">source</a><div><div><pre><code class="language-julia">an_element(P::AbstractCentrallySymmetricPolytope{N})::Vector{N}
    where {N&lt;:Real}</code></pre><p>Return some element of a centrally symmetric polytope.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric polytope</li></ul><p><strong>Output</strong></p><p>The center of the centrally symmetric polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractCentrallySymmetricPolytope.jl#L60-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.center-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">center(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The only element of the set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractSingleton.jl#L198-L210">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(S::AbstractSingleton{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A list containing only a single vertex.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractSingleton.jl#L219-L231">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">radius_hyperrectangle(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the box radius of a set with a single value in every dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The zero vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractSingleton.jl#L53-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">radius_hyperrectangle(S::AbstractSingleton{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the box radius of a set with a single value in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>Zero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractSingleton.jl#L33-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.high-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">high(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the higher coordinates of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A vector with the higher coordinates of the set with a single value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractSingleton.jl#L72-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real" href="#LazySets.high-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">high(S::AbstractSingleton{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the higher coordinate of a set with a single value in the given dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The higher coordinate of the set with a single value in the given dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractSingleton.jl#L89-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.low-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">low(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the lower coordinates of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A vector with the lower coordinates of the set with a single value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractSingleton.jl#L108-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real" href="#LazySets.low-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">low(S::AbstractSingleton{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the lower coordinate of a set with a single value in the given dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The lower coordinate of the set with a single value in the given dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractSingleton.jl#L125-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractSingleton{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractSingleton{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Concrete linear map of an abstract singleton.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>S</code> – abstract singleton</li></ul><p><strong>Output</strong></p><p>The abstract singleton of the same type of <span>$S$</span> obtained by applying the linear map to the element in <span>$S$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractSingleton.jl#L237-L251">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.generators-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.generators-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.generators</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">generators(S::AbstractSingleton)</code></pre><p>Return an (empty) iterator over the generators of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>An empty iterator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractSingleton.jl#L177-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.genmat-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.genmat-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.genmat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>genmat(S::AbstractSingleton)</p><p>Return the (empty) generator matrix of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A matrix with no columns representing the generators of <code>S</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractSingleton.jl#L148-L160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.plot_recipe-Union{Tuple{AbstractSingleton{N}}, Tuple{N}, Tuple{AbstractSingleton{N},N}} where N&lt;:Real" href="#LazySets.plot_recipe-Union{Tuple{AbstractSingleton{N}}, Tuple{N}, Tuple{AbstractSingleton{N},N}} where N&lt;:Real"><code>LazySets.plot_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_recipe(S::AbstractSingleton{N}, [ε]::N=zero(N)) where {N&lt;:Real}</code></pre><p>Convert a singleton to a pair <code>(x, y)</code> of points for plotting.</p><p><strong>Input</strong></p><ul><li><code>S</code> – singleton</li><li><code>ε</code> – (optional, default: <code>0</code>) ignored, used for dispatch</li></ul><p><strong>Output</strong></p><p>A pair <code>(x, y)</code> of one point that can be plotted.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/AbstractSingleton.jl#L332-L345">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{Dict{Symbol,Any},AbstractSingleton{N}}, Tuple{Dict{Symbol,Any},AbstractSingleton{N},N}} where N&lt;:Real" href="#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{Dict{Symbol,Any},AbstractSingleton{N}}, Tuple{Dict{Symbol,Any},AbstractSingleton{N},N}} where N&lt;:Real"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_singleton(S::AbstractSingleton{N}, [ε]::N=zero(N); ...) where {N&lt;:Real}</code></pre><p>Plot a singleton.</p><p><strong>Input</strong></p><ul><li><code>S</code> – singleton</li><li><code>ε</code> – (optional, default: <code>0</code>) ignored, used for dispatch</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; plot(Singleton([0.5, 1.0]))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8644313baca99c38f1a04ebca8e3a7aac37c47e4/src/plot_recipes.jl#L179-L194">source</a></section><footer><hr/><a class="previous" href="../../man/lazy_intersections/"><span class="direction">Previous</span><span class="title">Lazy Intersections</span></a><a class="next" href="../representations/"><span class="direction">Next</span><span class="title">Common Set Representations</span></a></footer></article></body></html>
