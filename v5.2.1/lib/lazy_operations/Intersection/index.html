<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Intersection · LazySets.jl</title><meta name="title" content="Intersection · LazySets.jl"/><meta property="og:title" content="Intersection · LazySets.jl"/><meta property="twitter:title" content="Intersection · LazySets.jl"/><meta name="description" content="Documentation for LazySets.jl."/><meta property="og:description" content="Documentation for LazySets.jl."/><meta property="twitter:description" content="Documentation for LazySets.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/aligned.css" rel="stylesheet" type="text/css"/><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">LazySets.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../../man/optional_dependencies/">Optional Features</a></li><li><a class="tocitem" href="../../../man/tour/">A Tour of LazySets</a></li><li><a class="tocitem" href="../../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../../man/unary_set_operations/">Unary Operations on Sets</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../API/">API</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Set Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../interfaces/overview/">Overview</a></li><li><a class="tocitem" href="../../interfaces/LazySet/">General sets (LazySet)</a></li><li><a class="tocitem" href="../../interfaces/ConvexSet/">Convex sets (ConvexSet)</a></li><li><a class="tocitem" href="../../interfaces/AbstractCentrallySymmetric/">Centrally symmetric sets (AbstractCentrallySymmetric)</a></li><li><a class="tocitem" href="../../interfaces/AbstractPolyhedron/">Polyhedra (AbstractPolyhedron)</a></li><li><a class="tocitem" href="../../interfaces/AbstractPolytope/">Polytopes (AbstractPolytope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractPolygon/">Polygons (AbstractPolygon)</a></li><li><a class="tocitem" href="../../interfaces/AbstractHPolygon/">Polygons in constraint representation (AbstractHPolygon)</a></li><li><a class="tocitem" href="../../interfaces/AbstractCentrallySymmetricPolytope/">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractZonotope/">Zonotopes (AbstractZonotope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractHyperrectangle/">Hyperrectangles (AbstractHyperrectangle)</a></li><li><a class="tocitem" href="../../interfaces/AbstractSingleton/">Singletons (AbstractSingleton)</a></li><li><a class="tocitem" href="../../interfaces/AbstractAffineMap/">Affine maps (AbstractAffineMap)</a></li><li><a class="tocitem" href="../../interfaces/AbstractPolynomialZonotope/">Polynomial zonotope sets (AbstractPolynomialZonotope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractSparsePolynomialZonotope/">Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractBallp/">Balls in the p-norm (AbstractBallp)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../../sets/DensePolynomialZonotope/">DensePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../../sets/HParallelotope/">HParallelotope</a></li><li><a class="tocitem" href="../../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../../sets/Line/">Line</a></li><li><a class="tocitem" href="../../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../../sets/Polygon/">Polygon</a></li><li><a class="tocitem" href="../../sets/SimpleSparsePolynomialZonotope/">SimpleSparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/SparsePolynomialZonotope/">SparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../../sets/Star/">Star</a></li><li><a class="tocitem" href="../../sets/Tetrahedron/">Tetrahedron</a></li><li><a class="tocitem" href="../../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../../sets/Zonotope/">Zonotope</a></li><li><a class="tocitem" href="../../sets/ZonotopeMD/">ZonotopeMD</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox" checked/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../Bloating/">Bloating</a></li><li><a class="tocitem" href="../CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../Complement/">Complement</a></li><li><a class="tocitem" href="../ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../ExponentialMap/">ExponentialMap</a></li><li class="is-active"><a class="tocitem" href>Intersection</a><ul class="internal"><li><a class="tocitem" href="#def_Intersection"><span>Binary intersection (Intersection)</span></a></li><li><a class="tocitem" href="#def_IntersectionArray"><span><span>$n$</span>-ary intersection (IntersectionArray)</span></a></li></ul></li><li><a class="tocitem" href="../LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../InverseLinearMap/">InverseLinearMap</a></li><li><a class="tocitem" href="../MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../QuadraticMap/">QuadraticMap</a></li><li><a class="tocitem" href="../Rectification/">Rectification</a></li><li><a class="tocitem" href="../ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../Translation/">Translation</a></li><li><a class="tocitem" href="../UnionSet/">UnionSet</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Concrete Binary Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../concrete_binary_operations/overview/">Binary set operations</a></li><li><a class="tocitem" href="../../concrete_binary_operations/cartesian_product/">Cartesian Product</a></li><li><a class="tocitem" href="../../concrete_binary_operations/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../concrete_binary_operations/difference/">Set difference</a></li><li><a class="tocitem" href="../../concrete_binary_operations/distance/">Distance</a></li><li><a class="tocitem" href="../../concrete_binary_operations/intersection/">Intersection of two sets</a></li><li><a class="tocitem" href="../../concrete_binary_operations/minkowski_sum/">Minkowski Sum</a></li><li><a class="tocitem" href="../../concrete_binary_operations/minkowski_difference/">Minkowski Difference</a></li><li><a class="tocitem" href="../../concrete_binary_operations/isdisjoint/">Check for Disjointness of Sets</a></li><li><a class="tocitem" href="../../concrete_binary_operations/issubset/">Subset Check</a></li></ul></li><li><a class="tocitem" href="../../conversion/">Conversions between set representations</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Approximations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../approximations/overview/">Overview</a></li><li><a class="tocitem" href="../../approximations/overapproximate/">Overapproximation</a></li><li><a class="tocitem" href="../../approximations/box_approximation/">Box Approximation</a></li><li><a class="tocitem" href="../../approximations/iterative_refinement/">Iterative refinement</a></li><li><a class="tocitem" href="../../approximations/template_directions/">Template directions</a></li><li><a class="tocitem" href="../../approximations/underapproximate/">Underapproximation</a></li><li><a class="tocitem" href="../../approximations/approximate/">Approximation</a></li><li><a class="tocitem" href="../../approximations/decompose/">Cartesian Decomposition</a></li><li><a class="tocitem" href="../../approximations/hausdorff_distance/">Hausdorff Distance</a></li><li><a class="tocitem" href="../../approximations/overapproximate_norm/">Norm Overapproximation</a></li><li><a class="tocitem" href="../../approximations/overapproximate_expmap/">Overapproximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">MatrixSets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../matrixsets/MatrixZonotope/">MatrixZonotope</a></li></ul></li><li><a class="tocitem" href="../../utils/">Utilities</a></li><li><a class="tocitem" href="../../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li><a class="is-disabled">Lazy Operations</a></li><li class="is-active"><a href>Intersection</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Intersection</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/lazy_operations/Intersection.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Intersection"><a class="docs-heading-anchor" href="#Intersection">Intersection</a><a id="Intersection-1"></a><a class="docs-heading-anchor-permalink" href="#Intersection" title="Permalink"></a></h1><h2 id="def_Intersection"><a class="docs-heading-anchor" href="#def_Intersection">Binary intersection (Intersection)</a><a id="def_Intersection-1"></a><a class="docs-heading-anchor-permalink" href="#def_Intersection" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="LazySets.Intersection"><a class="docstring-binding" href="#LazySets.Intersection"><code>LazySets.Intersection</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Intersection{N, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the intersection of two sets.</p><p><strong>Fields</strong></p><ul><li><code>X</code>     – set</li><li><code>Y</code>     – set</li><li><code>cache</code> – internal cache for avoiding recomputation; see            <a href="#LazySets.IntersectionCache"><code>IntersectionCache</code></a></li></ul><p><strong>Notes</strong></p><p>If the arguments of the lazy intersection are half-spaces, the set is simplified to a polyhedron in constraint representation (<code>HPolyhedron</code>).</p><p>The intersection preserves convexity: if the set arguments are convex, then their intersection is convex as well.</p><p>The convenience alias <code>∩</code> can be typed by <code>\cap&lt;tab&gt;</code>.</p><p><strong>Examples</strong></p><p>Create an expression <span>$Z$</span> that lazily represents the intersection of two squares <span>$X$</span> and <span>$Y$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; X, Y = BallInf([0.0, 0.0], 0.5), BallInf([1.0, 0.0], 0.75);

julia&gt; Z = X ∩ Y;

julia&gt; typeof(Z)
Intersection{Float64, BallInf{Float64, Vector{Float64}}, BallInf{Float64, Vector{Float64}}}

julia&gt; dim(Z)
2</code></pre><p>We can check if the intersection is empty with <code>isempty</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; isempty(Z)
false</code></pre><p>Do not confuse <code>Intersection</code> with the concrete operation, which is computed with the lowercase <code>intersection</code> function:</p><pre><code class="language-julia-repl hljs">julia&gt; W = intersection(X, Y)
Hyperrectangle{Float64, Vector{Float64}, Vector{Float64}}([0.375, 0.0], [0.125, 0.5])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L44-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.API.dim-Tuple{Intersection}"><a class="docstring-binding" href="#LazySets.API.dim-Tuple{Intersection}"><code>LazySets.API.dim</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dim(cap::Intersection)</code></pre><p>Return the dimension of an intersection of two sets.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two sets</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the intersection of two sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L211-L223">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.API.ρ-Tuple{AbstractVector, Intersection}"><a class="docstring-binding" href="#LazySets.API.ρ-Tuple{AbstractVector, Intersection}"><code>LazySets.API.ρ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, cap::Intersection)</code></pre><p>Return an upper bound on the support function of the intersection of two sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cap</code> – intersection of two sets</li></ul><p><strong>Output</strong></p><p>An upper bound on the support function in the given direction.</p><p><strong>Algorithm</strong></p><p>The support function of an intersection of <span>$X$</span> and <span>$Y$</span> is upper-bounded by the minimum of the support-function evaluations for <span>$X$</span> and <span>$Y$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L252-L271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.API.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractVector, Intersection{N, S1, S2}}} where {N, S1&lt;:LazySet, S2&lt;:Union{HalfSpace, Hyperplane, Line2D}}"><a class="docstring-binding" href="#LazySets.API.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractVector, Intersection{N, S1, S2}}} where {N, S1&lt;:LazySet, S2&lt;:Union{HalfSpace, Hyperplane, Line2D}}"><code>LazySets.API.ρ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, cap::Intersection{N, S1, S2};
  algorithm::String=&quot;line_search&quot;, kwargs...
 ) where {N, S1&lt;:LazySet,
             S2&lt;:Union{HalfSpace, Hyperplane, Line2D}}</code></pre><p>Evaluate the support function of the intersection of a compact set and a half-space/hyperplane/line in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>         – direction</p></li><li><p><code>cap</code>       – lazy intersection of a compact set and a half-space/hyperplane/                line</p></li><li><p><code>algorithm</code> – (optional, default: <code>&quot;line_search&quot;</code>): the algorithm to                calculate the support function; valid options are:</p><ul><li><code>&quot;line_search&quot;</code> – solve the associated univariate optimization problem                    using a line-search method (either Brent or the                    Golden Section method)</li><li><code>&quot;projection&quot;</code>  – only valid for intersection with a hyperplane/line;                    evaluate the support function by reducing the problem                    to the 2D intersection of a rank-2 linear                    transformation of the given compact set in the plane                    generated by the given direction <code>d</code> and the                    hyperplane&#39;s normal vector <code>n</code></li><li><code>&quot;simple&quot;</code>      – take the <span>$\min$</span> of the support-function evaluation                    of each operand</li></ul></li></ul><p><strong>Output</strong></p><p>The scalar value of the support function of the set <code>cap</code> in the given direction.</p><p><strong>Notes</strong></p><p>It is assumed that the first set of the intersection (<code>cap.X</code>) is compact.</p><p>Any additional number of arguments to the algorithm backend can be passed as keyword arguments.</p><p><strong>Algorithm</strong></p><p>The algorithms are based on solving the associated optimization problem</p><p class="math-container">\[\min_{λ ∈ D_h} ρ(ℓ - λa, X) + λb.\]</p><p>where <span>$D_h = \{ λ : λ ≥ 0 \}$</span> if <span>$H$</span> is a half-space or <span>$D_h = \{ λ : λ ∈ ℝ \}$</span> if <span>$H$</span> is a hyperplane.</p><p>For additional information we refer to <a href="../../../bibliography/#FrehseR12">Frehse and Ray [FR12]</a>, <a href="../../../bibliography/#LeGuernic09">Guernic [Gue09]</a> and <a href="../../../bibliography/#RockafellarW98">Rockafellar and Wets [RW98]</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L336-L388">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.API.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractVector, Intersection{N, S1, S2}}} where {N, S1&lt;:LazySet, S2&lt;:AbstractPolyhedron}"><a class="docstring-binding" href="#LazySets.API.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractVector, Intersection{N, S1, S2}}} where {N, S1&lt;:LazySet, S2&lt;:AbstractPolyhedron}"><code>LazySets.API.ρ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, cap::Intersection{N, S1, S2};
  kwargs...) where {N, S1&lt;:LazySet, S2&lt;:AbstractPolyhedron}</code></pre><p>Return an upper bound on the support function of the intersection between a compact set and a polyhedron along a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>      – direction</li><li><code>cap</code>    – intersection of a compact set and a polyhedron</li><li><code>kwargs</code> – additional arguments that are passed to the support-function             algorithm</li></ul><p><strong>Output</strong></p><p>An upper bound of the support function of the given intersection.</p><p><strong>Algorithm</strong></p><p>The idea is to solve the univariate optimization problem <code>ρ(di, X ∩ Hi)</code> for each half-space in the polyhedron and then take the minimum. This gives an overapproximation of the exact support value.</p><p>This algorithm is inspired from <a href="../../../bibliography/#FrehseR12">Frehse and Ray [FR12]</a>.</p><p><strong>Notes</strong></p><p>This method relies on the <code>constraints_list</code> of the polyhedron.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L404-L433">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.API.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractVector, Intersection{N, S1, S2}}} where {N, S1&lt;:AbstractPolyhedron, S2&lt;:AbstractPolyhedron}"><a class="docstring-binding" href="#LazySets.API.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractVector, Intersection{N, S1, S2}}} where {N, S1&lt;:AbstractPolyhedron, S2&lt;:AbstractPolyhedron}"><code>LazySets.API.ρ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, cap::Intersection{N, S1, S2}; kwargs...
 ) where {N, S1&lt;:AbstractPolyhedron, S2&lt;:AbstractPolyhedron}</code></pre><p>Evaluate the support function of the intersection between two polyhedral sets.</p><p><strong>Input</strong></p><ul><li><code>d</code>      – direction</li><li><code>cap</code>    – intersection of two polyhedral sets</li><li><code>kwargs</code> – additional arguments that are passed to the support-function             algorithm</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function in the given direction.</p><p><strong>Algorithm</strong></p><p>We combine the constraints of the two polyhedra to a new <code>HPolyhedron</code>, for which we then evaluate the support function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L472-L493">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.API.σ-Tuple{AbstractVector, Intersection}"><a class="docstring-binding" href="#LazySets.API.σ-Tuple{AbstractVector, Intersection}"><code>LazySets.API.σ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, cap::Intersection)</code></pre><p>Return a support vector of an intersection of two sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cap</code> – intersection of two sets</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>We compute the concrete intersection, which may be expensive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L228-L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.API.isbounded-Tuple{Intersection}"><a class="docstring-binding" href="#LazySets.API.isbounded-Tuple{Intersection}"><code>LazySets.API.isbounded</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isbounded(cap::Intersection)</code></pre><p>Check whether an intersection of two sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the intersection is bounded.</p><p><strong>Algorithm</strong></p><p>We first check if any of the wrapped sets is bounded. Otherwise we check boundedness via <a href="../../interfaces/LazySet/#LazySets._isbounded_unit_dimensions-Tuple{LazySet}"><code>LazySets._isbounded_unit_dimensions</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L539-L557">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isempty-Tuple{Intersection}"><a class="docstring-binding" href="#Base.isempty-Tuple{Intersection}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isempty(cap::Intersection)</code></pre><p>Check whether the intersection of two sets is empty.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the intersection is empty.</p><p><strong>Notes</strong></p><p>The result will be cached, so a second query will be fast.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L652-L668">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.in-Tuple{AbstractVector, Intersection}"><a class="docstring-binding" href="#Base.in-Tuple{AbstractVector, Intersection}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">in(x::AbstractVector, cap::Intersection)</code></pre><p>Check whether a given point is contained in the intersection of two sets.</p><p><strong>Input</strong></p><ul><li><code>x</code>   – point/vector</li><li><code>cap</code> – intersection of two sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ cap$</span>.</p><p><strong>Algorithm</strong></p><p>A point <span>$x$</span> is in the intersection iff it is in each set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L569-L586">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.API.constraints_list-Tuple{Intersection}"><a class="docstring-binding" href="#LazySets.API.constraints_list-Tuple{Intersection}"><code>LazySets.API.constraints_list</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">constraints_list(cap::Intersection)</code></pre><p>Return a list of constraints of an intersection of two (polyhedral) sets.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two (polyhedral) sets</li></ul><p><strong>Output</strong></p><p>A list of constraints of the intersection.</p><p><strong>Notes</strong></p><p>We assume that the underlying sets are polyhedral, i.e., offer a method <code>constraints_list</code>.</p><p><strong>Algorithm</strong></p><p>We create the polyhedron by taking the intersection of the <code>constraints_list</code>s of the sets and remove redundant constraints.</p><p>This function ignores the boolean output from the in-place <code>remove_redundant_constraints!</code>, which may inform the user that the constraints are infeasible. In that case, the list of constraints at the moment when the infeasibility was detected is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L591-L618">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.API.vertices_list-Tuple{Intersection}"><a class="docstring-binding" href="#LazySets.API.vertices_list-Tuple{Intersection}"><code>LazySets.API.vertices_list</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vertices_list(cap::Intersection)</code></pre><p>Return a list of vertices of a lazy intersection of two (polyhedral) sets.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two (polyhedral) sets</li></ul><p><strong>Output</strong></p><p>A list containing the vertices of the lazy intersection of two sets.</p><p><strong>Notes</strong></p><p>We assume that the underlying sets are polyhedral and that the intersection is bounded.</p><p><strong>Algorithm</strong></p><p>We compute the concrete intersection using <code>intersection</code> and then take the vertices of that representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L625-L647">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.isempty_known-Tuple{Intersection}"><a class="docstring-binding" href="#LazySets.isempty_known-Tuple{Intersection}"><code>LazySets.isempty_known</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isempty_known(cap::Intersection)</code></pre><p>Ask whether the status of emptiness is known.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the emptiness status is known. In this case, <code>isempty(cap)</code> can be used to obtain the status in constant time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L145-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.set_isempty!-Tuple{Intersection, Bool}"><a class="docstring-binding" href="#LazySets.set_isempty!-Tuple{Intersection, Bool}"><code>LazySets.set_isempty!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_isempty!(cap::Intersection, isempty::Bool)</code></pre><p>Set the status of emptiness in the cache.</p><p><strong>Input</strong></p><ul><li><code>cap</code>     – intersection of two sets</li><li><code>isempty</code> – new status of emptiness</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L163-L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.swap-Tuple{Intersection}"><a class="docstring-binding" href="#LazySets.swap-Tuple{Intersection}"><code>LazySets.swap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">swap(cap::Intersection)</code></pre><p>Return a new <code>Intersection</code> object with the arguments swapped.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two sets</li></ul><p><strong>Output</strong></p><p>A new <code>Intersection</code> object with the arguments swapped. The old cache is shared between the old and new objects.</p><p><strong>Notes</strong></p><p>The advantage of using this function instead of manually swapping the arguments is that the cache is shared.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L188-L206">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.use_precise_ρ"><a class="docstring-binding" href="#LazySets.use_precise_ρ"><code>LazySets.use_precise_ρ</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">use_precise_ρ(cap::Intersection)</code></pre><p>Check whether a precise algorithm for computing <span>$ρ$</span> shall be applied.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two sets</li></ul><p><strong>Output</strong></p><p><code>true</code> if a precise algorithm shall be applied.</p><p><strong>Notes</strong></p><p>The default implementation always returns <code>true</code>.</p><p>If the result is <code>false</code>, a coarse approximation of the support function is returned.</p><p>This function can be overwritten by the user to control the policy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L310-L331">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets._line_search"><a class="docstring-binding" href="#LazySets._line_search"><code>LazySets._line_search</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_line_search(ℓ, X, H::Union{&lt;:HalfSpace, &lt;:Hyperplane, &lt;:Line2D}; [kwargs...])</code></pre><p>Given a convex set <span>$X$</span> and a half-space <span>$H = \{x: a^T x ≤ b \}$</span> or a hyperplane/line <span>$H = \{x: a^T x = b \}$</span>, calculate:</p><p class="math-container">\[\min_{λ ∈ D_h} ρ(ℓ - λa, X) + λb.\]</p><p>where <span>$D_h = \{ λ : λ ≥ 0 \}$</span> if <span>$H$</span> is a half-space or <span>$D_h = \{ λ : λ ∈ ℝ \}$</span> if <span>$H$</span> is a hyperplane.</p><p><strong>Input</strong></p><ul><li><code>ℓ</code> – direction</li><li><code>X</code> – convex set</li><li><code>H</code> – half-space or hyperplane or line</li></ul><p><strong>Output</strong></p><p>The tuple <code>(fmin, λmin)</code>, where <code>fmin</code> is the minimum value of the function <span>$f(λ) = ρ(ℓ - λa) + λb$</span> over the feasible set <span>$λ ≥ 0$</span>, and <span>$λmin$</span> is the minimizer.</p><p><strong>Notes</strong></p><p>This function requires the <code>Optim</code> package, and relies on the univariate optimization interface <code>Optim.optimize(...)</code>.</p><p>Additional arguments to the <code>optimize</code> backend can be passed as keyword arguments. The default method is <code>Optim.Brent()</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = Ball1(zeros(2), 1.0);

julia&gt; H = HalfSpace([-1.0, 0.0], -1.0);  # x &gt;= 1

julia&gt; using Optim

julia&gt; using LazySets: _line_search

julia&gt; v = _line_search([1.0, 0.0], X, H);  # uses Brent&#39;s method by default

julia&gt; v[1]
1.0</code></pre><p>We can specify the upper bound in Brent&#39;s method:</p><pre><code class="language-julia-repl hljs">julia&gt; v = _line_search([1.0, 0.0], X, H, upper=1e3);

julia&gt; v[1]
1.0</code></pre><p>Instead of Brent&#39;s method we can use the Golden Section method:</p><pre><code class="language-julia-repl hljs">julia&gt; v = _line_search([1.0, 0.0], X, H, upper=1e3, method=GoldenSection());

julia&gt; v[1]
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L737-L803">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets._projection"><a class="docstring-binding" href="#LazySets._projection"><code>LazySets._projection</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_projection(ℓ, X::LazySet, H::Union{Hyperplane, Line2D};
            [lazy_linear_map]=false,
            [lazy_2d_intersection]=true,
            [algorithm_2d_intersection]=nothing,
            [kwargs...])</code></pre><p>Given a convex set <span>$X$</span> and a hyperplane <span>$H = \{x: n ⋅ x = γ \}$</span>, calculate the support function of the intersection between the rank-2 projection <span>$Π_{nℓ} X$</span> and the line <span>$Lγ = \{(x, y): x = γ \}$</span>.</p><p><strong>Input</strong></p><ul><li><code>ℓ</code>                    – direction</li><li><code>X</code>                    – convex set</li><li><code>H</code>                    – hyperplane</li><li><code>lazy_linear_map</code>      – (optional, default: <code>false</code>) flag to perform the                           projection lazily or concretely</li><li><code>lazy_2d_intersection</code> – (optional, default: <code>true</code>) flag to perform the 2D                           intersection between the projected set and the line                           lazily or concretely</li><li><code>algorithm_2d_intersection</code> – (optional, default: <code>nothing</code>) if given, fixes                                the support-function algorithm used for the                                intersection in 2D; otherwise the default is                                used</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function of <span>$X ∩ H$</span> along direction <span>$ℓ$</span>.</p><p><strong>Algorithm</strong></p><p>This projection method is based on Prop. 8.2, [1, page 103].</p><p>In the original algorithm, <a href="../../../bibliography/#LeGuernic09">Guernic [Gue09]</a>, Section 8.2, the linear map is performed concretely and the intersection is performed lazily (these are the default options in this algorithm, but here the four combinations are available). If the set <span>$X$</span> is a zonotope, its concrete projection is again a zonotope (sometimes called &quot;zonogon&quot;). The intersection between this zonogon and the line can be taken efficiently in a lazy way (see [<a href="../../../bibliography/#LeGuernic09">Gue09</a>, Section 8.2.2]), if one uses dispatch on <code>ρ(y_dir, Sℓ⋂Lγ; kwargs...)</code> given that <code>Sℓ</code> is itself a zonotope.</p><p><strong>Notes</strong></p><p>This function depends on the calculation of the support function of another set in two dimensions. Obviously one does not want to use <code>algorithm=&quot;projection&quot;</code> again for this second calculation. The option <code>algorithm_2d_intersection</code> is used for that: if not given, the default support-function algorithm is used (e.g., <code>&quot;line_search&quot;</code>). You can still pass additional arguments to the <code>&quot;line_search&quot;</code> backend through the <code>kwargs</code> arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L854-L905">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.API.linear_map-Tuple{AbstractMatrix, Intersection}"><a class="docstring-binding" href="#LazySets.API.linear_map-Tuple{AbstractMatrix, Intersection}"><code>LazySets.API.linear_map</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">linear_map(M::AbstractMatrix, cap::Intersection)</code></pre><p>Return the concrete linear map of an intersection of two sets.</p><p><strong>Input</strong></p><ul><li><code>M</code>   – matrix</li><li><code>cap</code> – intersection of two sets</li></ul><p><strong>Output</strong></p><p>The set obtained by applying the given linear map to the intersection.</p><p><strong>Algorithm</strong></p><p>This method computes the concrete intersection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L715-L732">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.plot_recipe-Union{Tuple{Intersection{N, S1, S2} where {S1&lt;:LazySet{N}, S2&lt;:LazySet{N}}}, Tuple{N}, Tuple{Intersection{N, S1, S2} where {S1&lt;:LazySet{N}, S2&lt;:LazySet{N}}, N}, Tuple{Intersection{N, S1, S2} where {S1&lt;:LazySet{N}, S2&lt;:LazySet{N}}, N, Int64}} where N"><a class="docstring-binding" href="#LazySets.plot_recipe-Union{Tuple{Intersection{N, S1, S2} where {S1&lt;:LazySet{N}, S2&lt;:LazySet{N}}}, Tuple{N}, Tuple{Intersection{N, S1, S2} where {S1&lt;:LazySet{N}, S2&lt;:LazySet{N}}, N}, Tuple{Intersection{N, S1, S2} where {S1&lt;:LazySet{N}, S2&lt;:LazySet{N}}, N, Int64}} where N"><code>LazySets.plot_recipe</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_recipe(cap::Intersection{N}, [ε]::N=-one(N),
            [Nφ]::Int=PLOT_POLAR_DIRECTIONS) where {N}</code></pre><p>Convert an intersection of two sets to a pair <code>(x, y)</code> of points for plotting.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two sets</li><li><code>ε</code>   – (optional, default <code>0</code>) ignored, used for dispatch</li><li><code>Nφ</code>  – (optional, default: <code>PLOT_POLAR_DIRECTIONS</code>) number of polar          directions used in the template overapproximation</li></ul><p><strong>Output</strong></p><p>A pair <code>(x, y)</code> of points that can be plotted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L682-L698">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol, Any}, Intersection{N, S1, S2} where {S1&lt;:LazySet{N}, S2&lt;:LazySet{N}}}, Tuple{AbstractDict{Symbol, Any}, Intersection{N, S1, S2} where {S1&lt;:LazySet{N}, S2&lt;:LazySet{N}}, Real}, Tuple{AbstractDict{Symbol, Any}, Intersection{N, S1, S2} where {S1&lt;:LazySet{N}, S2&lt;:LazySet{N}}, Real, Int64}} where N"><a class="docstring-binding" href="#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol, Any}, Intersection{N, S1, S2} where {S1&lt;:LazySet{N}, S2&lt;:LazySet{N}}}, Tuple{AbstractDict{Symbol, Any}, Intersection{N, S1, S2} where {S1&lt;:LazySet{N}, S2&lt;:LazySet{N}}, Real}, Tuple{AbstractDict{Symbol, Any}, Intersection{N, S1, S2} where {S1&lt;:LazySet{N}, S2&lt;:LazySet{N}}, Real, Int64}} where N"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_intersection(cap::Intersection{N}, [ε]::Real=zero(N),
                  [Nφ]::Int=PLOT_POLAR_DIRECTIONS) where {N}</code></pre><p>Plot a lazy intersection.</p><p><strong>Input</strong></p><ul><li><code>cap</code>  – lazy intersection</li><li><code>ε</code>    – (optional, default <code>0</code>) ignored, used for dispatch</li><li><code>Nφ</code>   – (optional, default: <code>PLOT_POLAR_DIRECTIONS</code>) number of polar           directions used in the template overapproximation</li></ul><p><strong>Notes</strong></p><p>This function is separated from the main <code>LazySet</code> plot recipe because iterative refinement is not available for lazy intersections (since it uses the support vector (but see <a href="https://github.com/JuliaReach/LazySets.jl/issues/1187">#1187</a>)).</p><p>Also note that if the set is a <em>nested</em> intersection, you may have to manually overapproximate this set before plotting (see <code>overapproximate</code> for details).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; X = Ball2(zeros(2), 1.) ∩ Ball2(ones(2), 1.5);  # lazy intersection

julia&gt; plot(X)</code></pre><p>You can specify the accuracy of the overapproximation of the lazy intersection by passing an explicit value for <code>Nφ</code>, which stands for the number of polar directions used in the overapproximation. This number can also be passed to the <code>plot</code> function directly.</p><pre><code class="language-julia hljs">julia&gt; plot(overapproximate(X, PolarDirections(100)))

julia&gt; plot(X, 0.0, 100)  # equivalent to the above line</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/Plotting/plot_recipes.jl#L450-L491">source</a></section></details></article><p>Inherited from <a href="../../interfaces/LazySet/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../../API/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../../API/#LazySets.API.radius"><code>radius</code></a></li><li><a href="../../API/#LazySets.API.diameter"><code>diameter</code></a></li><li>[<code>an_element</code>](@ref an_element(::LazySet)</li><li><a href="../../interfaces/LazySet/#LazySets.singleton_list-Tuple{LazySet}"><code>singleton_list</code></a></li><li><a href="../../interfaces/LazySet/#LazySets.API.reflect-Tuple{LazySet}"><code>reflect</code></a></li></ul><h3 id="Intersection-cache"><a class="docs-heading-anchor" href="#Intersection-cache">Intersection cache</a><a id="Intersection-cache-1"></a><a class="docs-heading-anchor-permalink" href="#Intersection-cache" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="LazySets.IntersectionCache"><a class="docstring-binding" href="#LazySets.IntersectionCache"><code>LazySets.IntersectionCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IntersectionCache</code></pre><p>Container for information cached by a lazy <code>Intersection</code> object.</p><p><strong>Fields</strong></p><ul><li><p><code>isempty</code> – is the intersection empty? There are three possible states,              encoded as <code>Int8</code> values -1, 0, 1:</p><ul><li><span>$-1$</span> - it is currently unknown whether the intersection is empty</li><li><span>$0$</span> - intersection is not empty</li><li><span>$1$</span> - intersection is empty</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/Intersection.jl#L9-L22">source</a></section></details></article><h2 id="def_IntersectionArray"><a class="docs-heading-anchor" href="#def_IntersectionArray"><span>$n$</span>-ary intersection (IntersectionArray)</a><a id="def_IntersectionArray-1"></a><a class="docs-heading-anchor-permalink" href="#def_IntersectionArray" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="LazySets.IntersectionArray"><a class="docstring-binding" href="#LazySets.IntersectionArray"><code>LazySets.IntersectionArray</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IntersectionArray{N, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the intersection of a finite number of sets.</p><p><strong>Fields</strong></p><ul><li><code>array</code> – array of sets</li></ul><p><strong>Notes</strong></p><p>This type assumes that the dimensions of all elements match.</p><p>The <code>EmptySet</code> is the absorbing element for <code>IntersectionArray</code>.</p><p>The intersection preserves convexity: if the set arguments are convex, then their intersection is convex as well.</p><p>The convenience alias <code>∩</code> can be typed by <code>\cap&lt;tab&gt;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/IntersectionArray.jl#L4-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.Intersection!"><a class="docstring-binding" href="#LazySets.Intersection!"><code>LazySets.Intersection!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Intersection!(X, Y)</code></pre><p>Convenience function to compute the lazy intersection and modify <code>IntersectionArray</code>s in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/IntersectionArray.jl#L28-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.API.dim-Tuple{IntersectionArray}"><a class="docstring-binding" href="#LazySets.API.dim-Tuple{IntersectionArray}"><code>LazySets.API.dim</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dim(ia::IntersectionArray)</code></pre><p>Return the dimension of an intersection of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of sets</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the intersection of a finite number of sets, or <code>0</code> if there is no set in the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/IntersectionArray.jl#L76-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.API.σ-Tuple{AbstractVector, IntersectionArray}"><a class="docstring-binding" href="#LazySets.API.σ-Tuple{AbstractVector, IntersectionArray}"><code>LazySets.API.σ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, ia::IntersectionArray)</code></pre><p>Return a support vector of an intersection of a finite number of sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>ia</code> – intersection of a finite number of sets</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction. If the direction has norm zero, the result depends on the individual sets.</p><p><strong>Algorithm</strong></p><p>This implementation computes the concrete intersection, which can be expensive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/IntersectionArray.jl#L94-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.API.isbounded-Tuple{IntersectionArray}"><a class="docstring-binding" href="#LazySets.API.isbounded-Tuple{IntersectionArray}"><code>LazySets.API.isbounded</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isbounded(ia::IntersectionArray)</code></pre><p>Check whether an intersection of a finite number of sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the intersection is bounded.</p><p><strong>Algorithm</strong></p><p>We first check if any of the wrapped sets is bounded. Otherwise we check boundedness via <a href="../../interfaces/LazySet/#LazySets._isbounded_unit_dimensions-Tuple{LazySet}"><code>LazySets._isbounded_unit_dimensions</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/IntersectionArray.jl#L119-L137">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.in-Tuple{AbstractVector, IntersectionArray}"><a class="docstring-binding" href="#Base.in-Tuple{AbstractVector, IntersectionArray}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">in(x::AbstractVector, ia::IntersectionArray)</code></pre><p>Check whether a given point is contained in an intersection of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>x</code>  – point/vector</li><li><code>ia</code> – intersection of a finite number of sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ ia$</span>.</p><p><strong>Algorithm</strong></p><p>A point <span>$x$</span> is in the intersection iff it is in each set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/IntersectionArray.jl#L159-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.array-Tuple{IntersectionArray}"><a class="docstring-binding" href="#LazySets.array-Tuple{IntersectionArray}"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array(ia::IntersectionArray)</code></pre><p>Return the array of an intersection of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of sets</li></ul><p><strong>Output</strong></p><p>The array of an intersection of a finite number of sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/IntersectionArray.jl#L59-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.API.constraints_list-Tuple{IntersectionArray}"><a class="docstring-binding" href="#LazySets.API.constraints_list-Tuple{IntersectionArray}"><code>LazySets.API.constraints_list</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">constraints_list(ia::IntersectionArray)</code></pre><p>Return the list of constraints of an intersection of a finite number of (polyhedral) sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of (polyhedral) sets</li></ul><p><strong>Output</strong></p><p>The list of constraints of the intersection.</p><p><strong>Notes</strong></p><p>We assume that the underlying sets are polyhedral, i.e., offer a method <code>constraints_list</code>.</p><p><strong>Algorithm</strong></p><p>We create the polyhedron from the <code>constraints_list</code>s of the sets and remove redundant constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a067e8e91a9826ae4387b4970878f294d42e884d/src/LazyOperations/IntersectionArray.jl#L187-L210">source</a></section></details></article><p>Inherited from <a href="../../interfaces/LazySet/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../../API/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../../API/#LazySets.API.radius"><code>radius</code></a></li><li><a href="../../API/#LazySets.API.diameter"><code>diameter</code></a></li><li>[<code>an_element</code>](@ref an_element(::LazySet)</li><li><a href="../../interfaces/LazySet/#LazySets.singleton_list-Tuple{LazySet}"><code>singleton_list</code></a></li><li><a href="../../interfaces/LazySet/#LazySets.API.reflect-Tuple{LazySet}"><code>reflect</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ExponentialMap/">« ExponentialMap</a><a class="docs-footer-nextpage" href="../LinearMap/">LinearMap »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 3 February 2026 19:21">Tuesday 3 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
