<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interfaces · LazySets.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">LazySets.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../man/set_operations/">Operations on Sets</a></li><li><a class="tocitem" href="../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li class="is-active"><a class="tocitem" href>Interfaces</a><ul class="internal"><li><a class="tocitem" href="#def_LazySet"><span>General sets (LazySet)</span></a></li><li><a class="tocitem" href="#def_AbstractCentrallySymmetric"><span>Centrally symmetric sets (AbstractCentrallySymmetric)</span></a></li><li><a class="tocitem" href="#def_AbstractPolyhedron"><span>Polyhedra (AbstractPolyhedron)</span></a></li><li><a class="tocitem" href="#def_AbstractPolytope"><span>Polytopes (AbstractPolytope)</span></a></li><li><a class="tocitem" href="#def_AbstractPolygon"><span>Polygons (AbstractPolygon)</span></a></li><li><a class="tocitem" href="#def_AbstractHPolygon"><span>Polygons in constraint representation (AbstractHPolygon)</span></a></li><li><a class="tocitem" href="#def_AbstractCentrallySymmetricPolytope"><span>Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</span></a></li><li><a class="tocitem" href="#def_AbstractZonotope"><span>Zonotopes (AbstractZonotope)</span></a></li><li><a class="tocitem" href="#def_AbstractHyperrectangle"><span>Hyperrectangles (AbstractHyperrectangle)</span></a></li><li><a class="tocitem" href="#def_AbstractSingleton"><span>Singletons (AbstractSingleton)</span></a></li><li><a class="tocitem" href="#def_AbstractAffineMap"><span>Affine maps (AbstractAffineMap)</span></a></li><li><a class="tocitem" href="#def_AbstractStar"><span>Star sets (AbstractStar)</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../sets/Line/">Line</a></li><li><a class="tocitem" href="../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../sets/PolynomialZonotope/">PolynomialZonotope</a></li><li><a class="tocitem" href="../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../sets/Star/">Star</a></li><li><a class="tocitem" href="../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../sets/Zonotope/">Zonotope</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lazy_operations/AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../lazy_operations/Bloating/">Bloating</a></li><li><a class="tocitem" href="../lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../lazy_operations/Complement/">Complement</a></li><li><a class="tocitem" href="../lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../lazy_operations/Intersection/">Intersection</a></li><li><a class="tocitem" href="../lazy_operations/LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../lazy_operations/Rectification/">Rectification</a></li><li><a class="tocitem" href="../lazy_operations/ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../lazy_operations/Translation/">Translation</a></li><li><a class="tocitem" href="../lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><a class="tocitem" href="../binary_functions/">Concrete Operations</a></li><li><a class="tocitem" href="../conversion/">Conversions between set representations</a></li><li><a class="tocitem" href="../comparisons/">Comparisons</a></li><li><a class="tocitem" href="../approximations/">Approximations</a></li><li><a class="tocitem" href="../utils/">Utility Functions</a></li><li><a class="tocitem" href="../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Interfaces</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interfaces</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/interfaces.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Set-Interfaces"><a class="docs-heading-anchor" href="#Set-Interfaces">Set Interfaces</a><a id="Set-Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Set-Interfaces" title="Permalink"></a></h1><p>This section of the manual describes the interfaces for different set types. Every set that fits the description of an interface should also implement it. This helps in several ways:</p><ul><li>avoid code duplicates,</li><li>provide functions for many sets at once,</li><li>allow changes in the source code without changing the API.</li></ul><p>The interface functions are outlined in the interface documentation. For implementations of the interfaces see the corresponding sub-pages linked in the respective sections.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The naming convention is such that all interface names (with the exception of the main abstract type <code>LazySet</code>) should be preceded by <code>Abstract</code>.</p></div></div><p>The following diagram shows the interface hierarchy.</p><p><img src="../../assets/interfaces.png" alt="../assets/interfaces.png"/></p><ul><li><a href="#Set-Interfaces">Set Interfaces</a></li><ul><li><a href="#def_LazySet">General sets (LazySet)</a></li><ul><li><a href="#Support-function-and-support-vector">Support function and support vector</a></li><li><a href="#Other-globally-defined-set-functions">Other globally defined set functions</a></li><li><a href="#Set-functions-that-override-Base-functions">Set functions that override Base functions</a></li><li><a href="#Aliases-for-set-types">Aliases for set types</a></li><li><a href="#Implementations">Implementations</a></li></ul><li><a href="#def_AbstractCentrallySymmetric">Centrally symmetric sets (AbstractCentrallySymmetric)</a></li><ul><li><a href="#Implementations-2">Implementations</a></li></ul><li><a href="#def_AbstractPolyhedron">Polyhedra (AbstractPolyhedron)</a></li><ul><li><a href="#Implementations-3">Implementations</a></li></ul><li><a href="#def_AbstractPolytope">Polytopes (AbstractPolytope)</a></li><ul><li><a href="#Implementations-4">Implementations</a></li></ul><li><a href="#def_AbstractPolygon">Polygons (AbstractPolygon)</a></li><ul><li><a href="#Implementations-5">Implementations</a></li></ul><li><a href="#def_AbstractHPolygon">Polygons in constraint representation (AbstractHPolygon)</a></li><ul><li><a href="#Implementations-6">Implementations</a></li></ul><li><a href="#def_AbstractCentrallySymmetricPolytope">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a></li><ul><li><a href="#Implementations-7">Implementations</a></li></ul><li><a href="#def_AbstractZonotope">Zonotopes (AbstractZonotope)</a></li><ul><li><a href="#Implementations-8">Implementations</a></li></ul><li><a href="#def_AbstractHyperrectangle">Hyperrectangles (AbstractHyperrectangle)</a></li><ul><li><a href="#Implementations-9">Implementations</a></li></ul><li><a href="#def_AbstractSingleton">Singletons (AbstractSingleton)</a></li><ul><li><a href="#Implementations-10">Implementations</a></li></ul><li><a href="#def_AbstractAffineMap">Affine maps (AbstractAffineMap)</a></li><ul><li><a href="#Implementations-11">Implementations</a></li></ul><li><a href="#def_AbstractStar">Star sets (AbstractStar)</a></li><ul><li><a href="#Implementations-12">Implementations</a></li></ul></ul></ul><h2 id="def_LazySet"><a class="docs-heading-anchor" href="#def_LazySet">General sets (LazySet)</a><a id="def_LazySet-1"></a><a class="docs-heading-anchor-permalink" href="#def_LazySet" title="Permalink"></a></h2><p>Every convex set in this library implements this interface.</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.LazySet" href="#LazySets.LazySet"><code>LazySets.LazySet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LazySet{N}</code></pre><p>Abstract type for convex sets, i.e., sets characterized by a (possibly infinite) intersection of halfspaces, or equivalently, sets <span>$S$</span> such that for any two elements <span>$x, y ∈ S$</span> and <span>$0 ≤ λ ≤ 1$</span> it holds that <span>$λ·x + (1-λ)·y ∈ S$</span>.</p><p><strong>Notes</strong></p><p><code>LazySet</code> types should be parameterized with a type <code>N</code>, typically <code>N&lt;:Real</code>, for using different numeric types.</p><p>Every concrete <code>LazySet</code> must define the following functions:</p><ul><li><code>σ(d::AbstractVector, S::LazySet)</code> – the support vector of <code>S</code> in a given   direction <code>d</code></li><li><code>dim(S::LazySet)</code> – the ambient dimension of <code>S</code></li></ul><p>The function</p><ul><li><code>ρ(d::AbstractVector, S::LazySet)</code> – the support function of <code>S</code> in a given   direction <code>d</code></li></ul><p>is optional because there is a fallback implementation relying on <code>σ</code>. However, for unbounded sets (which includes most lazy set types) this fallback cannot be used and an explicit method must be implemented.</p><p>The subtypes of <code>LazySet</code> (including abstract interfaces):</p><pre><code class="language-julia-repl">julia&gt; subtypes(LazySet, false)
14-element Array{Any,1}:
 AbstractAffineMap
 AbstractCentrallySymmetric
 AbstractPolyhedron
 Bloating
 CachedMinkowskiSumArray
 CartesianProduct
 CartesianProductArray
 ConvexHull
 ConvexHullArray
 EmptySet
 Intersection
 IntersectionArray
 MinkowskiSum
 MinkowskiSumArray</code></pre><p>If we only consider <em>concrete</em> subtypes, then:</p><pre><code class="language-julia-repl">julia&gt; concrete_subtypes = subtypes(LazySet, true);

julia&gt; length(concrete_subtypes)
41

julia&gt; println.(concrete_subtypes);
AffineMap
Ball1
Ball2
BallInf
Ballp
Bloating
CachedMinkowskiSumArray
CartesianProduct
CartesianProductArray
ConvexHull
ConvexHullArray
Ellipsoid
EmptySet
ExponentialMap
ExponentialProjectionMap
HParallelotope
HPolygon
HPolygonOpt
HPolyhedron
HPolytope
HalfSpace
Hyperplane
Hyperrectangle
Intersection
IntersectionArray
Interval
Line
Line2D
LineSegment
LinearMap
MinkowskiSum
MinkowskiSumArray
ResetMap
Singleton
SymmetricIntervalHull
Translation
Universe
VPolygon
VPolytope
ZeroSet
Zonotope</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L35-L131">source</a></section></article><h3 id="Support-function-and-support-vector"><a class="docs-heading-anchor" href="#Support-function-and-support-vector">Support function and support vector</a><a id="Support-function-and-support-vector-1"></a><a class="docs-heading-anchor-permalink" href="#Support-function-and-support-vector" title="Permalink"></a></h3><p>Every <code>LazySet</code> type must define a function <code>σ</code> to compute the support vector.</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.support_vector" href="#LazySets.support_vector"><code>LazySets.support_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">support_vector</code></pre><p>Alias for the support vector σ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L244-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.ρ-Tuple{AbstractArray{T,1} where T,LazySet}" href="#LazySets.ρ-Tuple{AbstractArray{T,1} where T,LazySet}"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ρ(d::AbstractVector, S::LazySet)</code></pre><p>Evaluate the support function of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>The support function of the set <code>S</code> for the direction <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L212-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.support_function" href="#LazySets.support_function"><code>LazySets.support_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">support_function</code></pre><p>Alias for the support function ρ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L230-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.σ" href="#LazySets.σ"><code>LazySets.σ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">σ</code></pre><p>Function to compute the support vector σ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L237-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.singleton_list-Tuple{LazySet}" href="#LazySets.singleton_list-Tuple{LazySet}"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">singleton_list(P::LazySet)</code></pre><p>Return the vertices of a polytopic set as a list of singletons.</p><p><strong>Input</strong></p><ul><li><code>P</code>                 – polytopic set</li></ul><p><strong>Output</strong></p><p>The list of vertices of <code>P</code>, as <code>Singleton</code>.</p><p><strong>Notes</strong></p><p>This function relies on <code>vertices_list</code>, which raises an error if the set is not polytopic (e.g., unbounded).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L998-L1015">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.constraints-Tuple{LazySet}" href="#LazySets.constraints-Tuple{LazySet}"><code>LazySets.constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraints(X::LazySet)</code></pre><p>Construct an iterator over the constraints of a polyhedral set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – polyhedral set</li></ul><p><strong>Output</strong></p><p>An iterator over the constraints of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L1042-L1054">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.vertices-Tuple{LazySet}" href="#LazySets.vertices-Tuple{LazySet}"><code>LazySets.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertices(X::LazySet)</code></pre><p>Construct an iterator over the vertices of a polyhedral set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – polyhedral set</li></ul><p><strong>Output</strong></p><p>An iterator over the vertices of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L1059-L1071">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MiniQhull.delaunay" href="#MiniQhull.delaunay"><code>MiniQhull.delaunay</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delaunay(X::LazySet)</code></pre><p>Compute the Delaunay triangulation of the given convex set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A union of polytopes in vertex representation.</p><p><strong>Notes</strong></p><p>This function requires that you have properly installed the package <a href="https://github.com/gridap/MiniQhull.jl">MiniQhull.jl</a>, including the library <a href="http://www.qhull.org/">Qhull</a>.</p><p>The method works in arbitrary dimension and the requirement is that the list of vertices of <code>X</code> can be obtained.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L1094-L1115">source</a></section></article><h3 id="Other-globally-defined-set-functions"><a class="docs-heading-anchor" href="#Other-globally-defined-set-functions">Other globally defined set functions</a><a id="Other-globally-defined-set-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-globally-defined-set-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="LazySets.basetype" href="#LazySets.basetype"><code>LazySets.basetype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">basetype(T::Type{&lt;:LazySet})</code></pre><p>Return the base type of the given set type (i.e., without type parameters).</p><p><strong>Input</strong></p><ul><li><code>T</code> – set type, used for dispatch</li></ul><p><strong>Output</strong></p><p>The base type of <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L167-L179">source</a></section><section><div><pre><code class="language-none">basetype(S::LazySet)</code></pre><p>Return the base type of the given set (i.e., without type parameters).</p><p><strong>Input</strong></p><ul><li><code>S</code> – set instance, used for dispatch</li></ul><p><strong>Output</strong></p><p>The base type of <code>S</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; z = rand(Zonotope);

julia&gt; basetype(z)
Zonotope

julia&gt; basetype(z + z)
MinkowskiSum

julia&gt; basetype(LinearMap(rand(2, 2), z + z))
LinearMap</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L182-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">norm(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the norm of a convex set. It is the norm of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L312-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.radius" href="#LazySets.radius"><code>LazySets.radius</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">radius(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the radius of a convex set. It is the radius of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L336-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.diameter" href="#LazySets.diameter"><code>LazySets.diameter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">diameter(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the diameter of a convex set. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L360-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isbounded-Tuple{LazySet}" href="#LazySets.isbounded-Tuple{LazySet}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isbounded(S::LazySet)</code></pre><p>Determine whether a set is bounded.</p><p><strong>Input</strong></p><ul><li><code>S</code>         – set</li><li><code>algorithm</code> – (optional, default: <code>&quot;support_function&quot;</code>) algorithm choice,                possible options are <code>&quot;support_function&quot;</code> and <code>&quot;stiemke&quot;</code></li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set is bounded.</p><p><strong>Algorithm</strong></p><p>See the documentation of <code>_isbounded_unit_dimensions</code> or <code>_isbounded_stiemke</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L251-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets._isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N" href="#LazySets._isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N"><code>LazySets._isbounded_unit_dimensions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_isbounded_unit_dimensions(S::LazySet{N}) where {N}</code></pre><p>Determine whether a set is bounded in each unit dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set is bounded in each unit dimension.</p><p><strong>Algorithm</strong></p><p>This function performs <span>$2n$</span> support function checks, where <span>$n$</span> is the ambient dimension of <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L281-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N" href="#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">an_element(S::LazySet{N}) where {N}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>An element of a convex set.</p><p><strong>Algorithm</strong></p><p>An element of the set is obtained by evaluating its support vector along direction <span>$[1, 0, …, 0]$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L404-L421">source</a></section><section><div><pre><code class="language-none">an_element(P::AbstractPolyhedron{N};
           [solver]=default_lp_solver(N)) where {N}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polyhedron</li><li><code>solver</code>  – (optional, default: <code>default_lp_solver(N)</code>) LP solver</li></ul><p><strong>Output</strong></p><p>An element of the polyhedron, or an error if the polyhedron is empty.</p><p><strong>Algorithm</strong></p><p>An element of the polyhedron is obtained by solving a feasibility linear program.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolyhedron_functions.jl#L880-L898">source</a></section><section><div><pre><code class="language-none">an_element(L::Line2D{N}) where {N}</code></pre><p>Return some element of a line.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line</li></ul><p><strong>Output</strong></p><p>An element on the line.</p><p><strong>Algorithm</strong></p><p>If the <span>$b$</span> value of the line is zero, the result is the origin. Otherwise the result is some <span>$x = [x1, x2]$</span> such that <span>$a·[x1, x2] = b$</span>. We first find out in which dimension <span>$a$</span> is nonzero, say, dimension 1, and then choose <span>$x1 = 1$</span> and accordingly <span>$x2 = \frac{b - a1}{a2}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Sets/Line2D.jl#L193-L212">source</a></section><section><div><pre><code class="language-none">an_element(U::Universe{N}) where {N}</code></pre><p>Return some element of a universe.</p><p><strong>Input</strong></p><ul><li><code>U</code> – universe</li></ul><p><strong>Output</strong></p><p>The origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Sets/Universe.jl#L166-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.tosimplehrep-Tuple{LazySet}" href="#LazySets.tosimplehrep-Tuple{LazySet}"><code>LazySets.tosimplehrep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tosimplehrep(S::LazySet)</code></pre><p>Return the simple H-representation <span>$Ax ≤ b$</span> of a set from its list of linear constraints.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p>The tuple <code>(A, b)</code> where <code>A</code> is the matrix of normal directions and <code>b</code> is the vector of offsets.</p><p><strong>Notes</strong></p><p>This function only works for sets that can be represented exactly by a finite list of linear constraints. This fallback implementation relies on <code>constraints_list(S)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L561-L581">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isuniversal-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},Bool}} where N" href="#LazySets.isuniversal-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},Bool}} where N"><code>LazySets.isuniversal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isuniversal(X::LazySet{N}, [witness]::Bool=false) where {N}</code></pre><p>Check whether a given convex set is universal, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – convex set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X$</span> is universal</li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X$</span> is universal</li><li><code>(false, v)</code> iff <span>$X$</span> is not universal and <span>$v ∉ X$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>This is a naive fallback implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L612-L633">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.affine_map-Tuple{AbstractArray{T,2} where T,LazySet,AbstractArray{T,1} where T}" href="#LazySets.affine_map-Tuple{AbstractArray{T,2} where T,LazySet,AbstractArray{T,1} where T}"><code>LazySets.affine_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">affine_map(M::AbstractMatrix, X::LazySet, v::AbstractVector; kwargs...)</code></pre><p>Compute a concrete affine map.</p><p><strong>Input</strong></p><ul><li><code>M</code> – linear map</li><li><code>X</code> – convex set</li><li><code>v</code> – translation vector</li></ul><p><strong>Output</strong></p><p>A set representing the affine map of <code>X</code>.</p><p><strong>Algorithm</strong></p><p>The implementation applies the functions <code>linear_map</code> and <code>translate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L381-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.reflect-Tuple{LazySet}" href="#LazySets.reflect-Tuple{LazySet}"><code>LazySets.reflect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reflect(P::LazySet)</code></pre><p>Concrete reflection of a convex set <code>P</code>, resulting in the reflected set <code>-P</code>.</p><p><strong>Note</strong></p><p>This function requires that the list of constraints of the set <code>P</code> is available, i.e. such that it can be written as <span>$P = \{z ∈ ℝⁿ: ⋂ sᵢᵀz ≤ rᵢ, i = 1, ..., N\}.$</span></p><p>This function can be used to implement the alternative definition of the Minkowski Difference, which writes as</p><p class="math-container">\[A ⊖ B = \{a − b | a ∈ A, b ∈ B\} = A ⊕ (-B)\]</p><p>by calling <code>minkowski_sum(A, reflect(B))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L584-L601">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_interior_point-Union{Tuple{N}, Tuple{AbstractArray{N,1},LazySet{N}}} where N&lt;:Real" href="#LazySets.is_interior_point-Union{Tuple{N}, Tuple{AbstractArray{N,1},LazySet{N}}} where N&lt;:Real"><code>LazySets.is_interior_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_interior_point(d::AbstractVector{N}, P::LazySet{N};
                  p=N(Inf), ε=_rtol(N)) where {N&lt;:Real}</code></pre><p>Check if the point <code>d</code> is contained in the interior of the convex set <code>P</code>.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – point</li><li><code>P</code>  – set</li><li><code>p</code>  – (optional; default: <code>N(Inf)</code>) norm of the ball used to apply the error         tolerance</li><li><code>ε</code>  – (optional; default: <code>_rtol(N)</code>) error tolerance of check</li></ul><p><strong>Output</strong></p><p>Boolean which indicates if the point <code>d</code> is contained in <code>P</code>.</p><p><strong>Algorithm</strong></p><p>The implementation checks if a <code>Ballp</code> of norm <code>p</code> with center <code>d</code> and radius <code>ε</code> is contained in the set <code>P</code>. This is a numerical check for <code>d ∈ interior(P)</code> with error tolerance <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L650-L673">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isoperationtype-Tuple{Type{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:LazySet}" href="#LazySets.isoperationtype-Tuple{Type{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:LazySet}"><code>LazySets.isoperationtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isoperationtype(X::Type{&lt;:LazySet})</code></pre><p>Check whether the given <code>LazySet</code> type is an operation or not.</p><p><strong>Input</strong></p><ul><li><code>X</code> – subtype of <code>LazySet</code></li></ul><p><strong>Output</strong></p><p><code>true</code> if the given set type is a set-based operation and <code>false</code> otherwise.</p><p><strong>Notes</strong></p><p>The fallback for this function returns an error that <code>isoperationtype</code> is not implemented. Subtypes of <code>LazySet</code> should dispatch on this function as required.</p><p>See also <a href="#LazySets.isoperation-Tuple{LazySet}"><code>isoperation(X&lt;:LazySet)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isoperationtype(BallInf)
false

julia&gt; isoperationtype(LinearMap)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L760-L789">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isoperation-Tuple{LazySet}" href="#LazySets.isoperation-Tuple{LazySet}"><code>LazySets.isoperation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isoperation(X::LazySet)</code></pre><p>Check whether the given <code>LazySet</code> is an instance of a set operation or not.</p><p><strong>Input</strong></p><ul><li><code>X</code> – a <code>LazySet</code></li></ul><p><strong>Output</strong></p><p><code>true</code> if <code>X</code> is an instance of a set-based operation and <code>false</code> otherwise.</p><p><strong>Notes</strong></p><p>The fallback implementation returns whether the set type of the input is an operation or not using <code>isoperationtype</code>.</p><p>See also <a href="#LazySets.isoperationtype-Tuple{Type{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:LazySet}"><code>isoperationtype(X::Type{&lt;:LazySet})</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = BallInf([0.0, 0.0], 1.0);

julia&gt; isoperation(B)
false

julia&gt; isoperation(B ⊕ B)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L721-L752">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isequivalent-Tuple{LazySet,LazySet}" href="#LazySets.isequivalent-Tuple{LazySet,LazySet}"><code>LazySets.isequivalent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isequivalent(X::LazySet, Y::LazySet)</code></pre><p>Return whether two LazySets are equal in the mathematical sense, i.e. equivalent.</p><p><strong>Input</strong></p><ul><li><code>X</code> – any <code>LazySet</code></li><li><code>Y</code> – another <code>LazySet</code></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>X</code> is equivalent to <code>Y</code>.</p><p><strong>Algorithm</strong></p><p>First we check <code>X ≈ Y</code>, which returns <code>true</code> if and only if <code>X</code> and <code>Y</code> have the same type and approximately the same values (checked with <code>LazySets._isapprox</code>). If that fails, we check the double inclusion <code>X ⊆ Y &amp;&amp; Y ⊆ X</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X = BallInf([0.1, 0.2], 0.3);

julia&gt; Y = convert(HPolytope, X);

julia&gt; X == Y
false

julia&gt; isequivalent(X, Y)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L797-L830">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isconvextype-Tuple{Type{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:LazySet}" href="#LazySets.isconvextype-Tuple{Type{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:LazySet}"><code>LazySets.isconvextype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isconvextype(X::Type{&lt;:LazySet})</code></pre><p>Check whether the given <code>LazySet</code> type is convex.</p><p><strong>Input</strong></p><ul><li><code>X</code> – subtype of <code>LazySet</code></li></ul><p><strong>Output</strong></p><p><code>true</code> if the given set type is guaranteed to be convex by using only type information, and <code>false</code> otherwise.</p><p><strong>Notes</strong></p><p>Since this operation only acts on types (not on values), it can return false negatives, i.e. there may be instances where the set is convex, even though the answer of this function is <code>false</code>. The examples below illustrate this point.</p><p><strong>Examples</strong></p><p>A ball in the infinity norm is always convex, hence we get:</p><pre><code class="language-julia-repl">julia&gt; isconvextype(BallInf)
true</code></pre><p>For instance, the union (<code>UnionSet</code>) of two sets may in general be either convex or not, since convexity cannot be decided by just using type information. Hence, <code>isconvextype</code> returns <code>false</code> if <code>X</code> is <code>Type{&lt;:UnionSet}</code>.</p><pre><code class="language-julia-repl">julia&gt; isconvextype(UnionSet)
false</code></pre><p>However, the type parameters from the set operations allow to decide convexity in some cases, by falling back to the convexity of the type of its arguments. Consider for instance the lazy intersection. The intersection of two convex sets is always convex, hence we can get:</p><pre><code class="language-julia-repl">julia&gt; isconvextype(Intersection{Float64, BallInf{Float64}, BallInf{Float64}})
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L845-L892">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.surface-Union{Tuple{LazySet{N}}, Tuple{N}} where N" href="#LazySets.surface-Union{Tuple{LazySet{N}}, Tuple{N}} where N"><code>LazySets.surface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">surface(X::LazySet{N}) where {N}</code></pre><p>Compute the surface area of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A number representing the surface area of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L895-L907">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.area-Union{Tuple{LazySet{N}}, Tuple{N}} where N" href="#LazySets.area-Union{Tuple{LazySet{N}}, Tuple{N}} where N"><code>LazySets.area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">area(X::LazySet{N}) where {N}</code></pre><p>Compute the area of a two-dimensional polytopic set using the Shoelace formula.</p><p><strong>Input</strong></p><ul><li><code>X</code> – two-dimensional set</li></ul><p><strong>Output</strong></p><p>A number representing the area of <code>X</code>.</p><p><strong>Notes</strong></p><p>This algorithm is applicable to any lazy set <code>X</code> such that its list of vertices, <code>vertices_list</code>, can be computed.</p><p><strong>Algorithm</strong></p><p>Let <code>m</code> be the number of vertices of <code>X</code>. The following instances are considered:</p><ul><li><code>m = 0, 1, 2</code>: the output is zero.</li><li><code>m = 3</code>: the triangle case is computed using the Shoelace formula with 3 points.</li><li><code>m = 4</code>: the quadrilateral case is obtained by the factored version of the Shoelace          formula with 4 points.</li></ul><p>Otherwise, the general Shoelace formula is used; for detals see the wikipedia article <a href="https://en.wikipedia.org/wiki/Shoelace_formula">Shoelace formula</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L917-L946">source</a></section><section><div><pre><code class="language-none">area(∅::EmptySet{N}) where {N}</code></pre><p>Return the area of an empty set.</p><p><strong>Input</strong></p><ul><li><code>∅</code> – empty set</li></ul><p><strong>Output</strong></p><p>The zero element of type <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Sets/EmptySet.jl#L363-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.concretize-Tuple{LazySet}" href="#LazySets.concretize-Tuple{LazySet}"><code>LazySets.concretize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">concretize(X::LazySet)</code></pre><p>Construct a concrete representation of a (possibly lazy) set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A concrete representation of <code>X</code> (as far as possible).</p><p><strong>Notes</strong></p><p>Since not every lazy set has a concrete set representation in this library, the result may be partially lazy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L1020-L1037">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.complement-Tuple{LazySet}" href="#LazySets.complement-Tuple{LazySet}"><code>LazySets.complement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">complement(X::LazySet)</code></pre><p>Return the complement of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A <code>UnionSetArray</code> of half-spaces, i.e. the output is the union of the linear constraints which are obtained by complementing each constraint of <code>X</code>.</p><p><strong>Algorithm</strong></p><p>The principle used in this function is that if <span>$X$</span> and <span>$Y$</span> are any pair of sets, then <span>$(X ∩ Y)^C = X^C ∪ Y^C$</span>. In particular, we can apply this rule for each constraint that defines a polyhedral set, hence the concrete complement can be represented as the set union of the complement of each constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L1129-L1149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.project-Union{Tuple{N}, Tuple{LazySet{N},AbstractArray{Int64,1}}, Tuple{LazySet{N},AbstractArray{Int64,1},Nothing}, Tuple{LazySet{N},AbstractArray{Int64,1},Nothing,Int64}} where N" href="#LazySets.project-Union{Tuple{N}, Tuple{LazySet{N},AbstractArray{Int64,1}}, Tuple{LazySet{N},AbstractArray{Int64,1},Nothing}, Tuple{LazySet{N},AbstractArray{Int64,1},Nothing,Int64}} where N"><code>LazySets.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project(S::LazySet{N},
        block::AbstractVector{Int},
        [::Nothing=nothing],
        [n]::Int=dim(S)
       ) where {N}</code></pre><p>Project a high-dimensional set to a given block by using a concrete linear map.</p><p><strong>Input</strong></p><ul><li><code>S</code>       – set</li><li><code>block</code>   – block structure - a vector with the dimensions of interest</li><li><code>nothing</code> – (default: <code>nothing</code>) used for dispatch</li><li><code>n</code>       – (optional, default: <code>dim(S)</code>) ambient dimension of the set <code>S</code></li></ul><p><strong>Output</strong></p><p>A set representing the projection of the set <code>S</code> to block <code>block</code>.</p><p><strong>Algorithm</strong></p><p>We apply the function <code>linear_map</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L1156-L1179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.project-Union{Tuple{TS}, Tuple{LazySet,AbstractArray{Int64,1},Type{TS}}, Tuple{LazySet,AbstractArray{Int64,1},Type{TS},Int64}} where TS&lt;:LazySet" href="#LazySets.project-Union{Tuple{TS}, Tuple{LazySet,AbstractArray{Int64,1},Type{TS}}, Tuple{LazySet,AbstractArray{Int64,1},Type{TS},Int64}} where TS&lt;:LazySet"><code>LazySets.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project(S::LazySet,
        block::AbstractVector{Int},
        set_type::Type{TS},
        [n]::Int=dim(S)
       ) where {TS&lt;:LazySet}</code></pre><p>Project a high-dimensional set to a given block and set type, possibly involving an overapproximation.</p><p><strong>Input</strong></p><ul><li><code>S</code>        – set</li><li><code>block</code>    – block structure - a vector with the dimensions of interest</li><li><code>set_type</code> – target set type</li><li><code>n</code>        – (optional, default: <code>dim(S)</code>) ambient dimension of the set <code>S</code></li></ul><p><strong>Output</strong></p><p>A set of type <code>set_type</code> representing an overapproximation of the projection of <code>S</code>.</p><p><strong>Algorithm</strong></p><ol><li>Project the set <code>S</code> with <code>M⋅S</code>, where <code>M</code> is the identity matrix in the block</li></ol><p>coordinates and zero otherwise.</p><ol><li>Overapproximate the projected lazy set using <code>overapproximate</code> and</li></ol><p><code>set_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L1189-L1217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.project-Union{Tuple{N}, Tuple{T}, Tuple{LazySet,AbstractArray{Int64,1},Pair{T,N}}, Tuple{LazySet,AbstractArray{Int64,1},Pair{T,N},Int64}} where N&lt;:Real where T&lt;:UnionAll" href="#LazySets.project-Union{Tuple{N}, Tuple{T}, Tuple{LazySet,AbstractArray{Int64,1},Pair{T,N}}, Tuple{LazySet,AbstractArray{Int64,1},Pair{T,N},Int64}} where N&lt;:Real where T&lt;:UnionAll"><code>LazySets.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project(S::LazySet,
        block::AbstractVector{Int},
        set_type_and_precision::Pair{T, N},
        [n]::Int=dim(S)
       ) where {T&lt;:UnionAll, N&lt;:Real}</code></pre><p>Project a high-dimensional set to a given block and set type with a certified error bound.</p><p><strong>Input</strong></p><ul><li><code>S</code>     – set</li><li><code>block</code> – block structure - a vector with the dimensions of interest</li><li><code>set_type_and_precision</code> – pair <code>(T, ε)</code> of a target set type <code>T</code> and an                             error bound <code>ε</code> for approximation</li><li><code>n</code>     – (optional, default: <code>dim(S)</code>) ambient dimension of the set <code>S</code></li></ul><p><strong>Output</strong></p><p>A set representing the epsilon-close approximation of the projection of <code>S</code>.</p><p><strong>Notes</strong></p><p>Currently we only support <code>HPolygon</code> as set type, which implies that the set must be two-dimensional.</p><p><strong>Algorithm</strong></p><ol><li>Project the set <code>S</code> with <code>M⋅S</code>, where <code>M</code> is the identity matrix in the block</li></ol><p>coordinates and zero otherwise.</p><ol><li>Overapproximate the projected lazy set with the given error bound <code>ε</code>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L1227-L1259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.project" href="#LazySets.project"><code>LazySets.project</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">project(S::LazySet,
        block::AbstractVector{Int},
        ε::Real,
        [n]::Int=dim(S)
       )</code></pre><p>Project a high-dimensional set to a given block and set type with a certified error bound.</p><p><strong>Input</strong></p><ul><li><code>S</code>     – set</li><li><code>block</code> – block structure - a vector with the dimensions of interest</li><li><code>ε</code>     – error bound for approximation</li><li><code>n</code>     – (optional, default: <code>dim(S)</code>) ambient dimension of the set <code>S</code></li></ul><p><strong>Output</strong></p><p>A set representing the epsilon-close approximation of the projection of <code>S</code>.</p><p><strong>Algorithm</strong></p><ol><li>Project the set <code>S</code> with <code>M⋅S</code>, where <code>M</code> is the identity matrix in the block</li></ol><p>coordinates and zero otherwise.</p><ol><li>Overapproximate the projected lazy set with the given error bound <code>ε</code>.</li></ol><p>The target set type is chosen automatically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L1274-L1301">source</a></section></article><p>Plotting is available for general one- or two-dimensional <code>LazySet</code>s, provided that the overapproximation using iterative refinement is available:</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.plot_recipe-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},Any}} where N" href="#LazySets.plot_recipe-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},Any}} where N"><code>LazySets.plot_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_recipe(X::LazySet{N}, [ε]=N(PLOT_PRECISION)) where {N}</code></pre><p>Convert a convex set to a pair <code>(x, y)</code> of points for plotting.</p><p><strong>Input</strong></p><ul><li><code>X</code> – convex set</li><li><code>ε</code> – (optional, default: <code>PLOT_PRECISION</code>) approximation error bound</li></ul><p><strong>Output</strong></p><p>A pair <code>(x, y)</code> of points that can be plotted.</p><p><strong>Algorithm</strong></p><p>We first assert that <code>X</code> is bounded.</p><p>One-dimensional sets are converted to an <code>Interval</code>. We do not support three-dimensional or higher-dimensional sets at the moment.</p><p>For two-dimensional sets, we first compute a polygonal overapproximation. The second argument, <code>ε</code>, corresponds to the error in Hausdorff distance between the overapproximating set and <code>X</code>. The default value <code>PLOT_PRECISION</code> is chosen such that the unit ball in the 2-norm is approximated with reasonable accuracy. On the other hand, if you only want to produce a fast box-overapproximation of <code>X</code>, pass <code>ε=Inf</code>. Finally, we use the plot recipe for polygons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L679-L708">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol,Any},LazySet{N}}, Tuple{AbstractDict{Symbol,Any},LazySet{N},N}} where N" href="#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol,Any},LazySet{N}}, Tuple{AbstractDict{Symbol,Any},LazySet{N},N}} where N"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_lazyset(X::LazySet{N}, [ε]::N=N(PLOT_PRECISION); ...) where {N}</code></pre><p>Plot a convex set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – convex set</li><li><code>ε</code> – (optional, default: <code>PLOT_PRECISION</code>) approximation error bound</li></ul><p><strong>Notes</strong></p><p>See <a href="#LazySets.plot_recipe-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},Any}} where N"><code>plot_recipe(::LazySet)</code></a>.</p><p>For polyhedral set types (subtypes of <code>AbstractPolyhedron</code>), the argument <code>ε</code> is ignored.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; B = Ball2(ones(2), 0.1);

julia&gt; plot(B, 1e-3)  # default accuracy value (explicitly given for clarity)

julia&gt; plot(B, 1e-2)  # faster but less accurate than the previous call</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Plotting/plot_recipes.jl#L270-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{VN}, Tuple{N}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1}}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1},N}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1},N,Int64}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1},N,Int64,Bool}} where VN&lt;:LazySet{N} where N" href="#RecipesBase.apply_recipe-Union{Tuple{VN}, Tuple{N}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1}}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1},N}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1},N,Int64}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1},N,Int64,Bool}} where VN&lt;:LazySet{N} where N"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_list(list::AbstractVector{VN}, [ε]::N=N(PLOT_PRECISION),
          [Nφ]::Int=PLOT_POLAR_DIRECTIONS, [fast]::Bool=false; ...)
    where {N, VN&lt;:LazySet{N}}</code></pre><p>Plot a list of convex sets.</p><p><strong>Input</strong></p><ul><li><code>list</code> – list of convex sets (1D or 2D)</li><li><code>ε</code>    – (optional, default: <code>PLOT_PRECISION</code>) approximation error bound</li><li><code>Nφ</code>   – (optional, default: <code>PLOT_POLAR_DIRECTIONS</code>) number of polar           directions (used to plot lazy intersections)</li><li><code>fast</code> – (optional, default: <code>false</code>) switch for faster plotting but without           individual plot recipes (see notes below)</li></ul><p><strong>Notes</strong></p><p>For each set in the list we apply an individual plot recipe.</p><p>The option <code>fast</code> provides access to a faster plotting scheme where all sets in the list are first converted to polytopes and then plotted in one single run. This, however, is not suitable when plotting flat sets (line segments, singletons) because then the polytope plot recipe does not deliver good results. Hence by default we do not use this option. For plotting a large number of (non-flat) polytopes, we highly advise activating this option.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; B1 = BallInf(zeros(2), 0.4);

julia&gt; B2 = BallInf(ones(2), 0.4);

julia&gt; plot([B1, B2])</code></pre><p>Some of the sets in the list may not be plotted precisely but rather overapproximated first. The second argument <code>ε</code> controls the accuracy of this overapproximation.</p><pre><code class="language-julia">julia&gt; Bs = [BallInf(zeros(2), 0.4), Ball2(ones(2), 0.4)];

julia&gt; plot(Bs, 1e-3)  # default accuracy value (explicitly given for clarity)

julia&gt; plot(Bs, 1e-2)  # faster but less accurate than the previous call</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Plotting/plot_recipes.jl#L90-L139">source</a></section></article><p>For three-dimensional sets, we support <code>Makie</code>:</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.plot3d" href="#LazySets.plot3d"><code>LazySets.plot3d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plot3d(S::LazySet; backend=default_polyhedra_backend(S),
       alpha=1.0, color=:blue, colormap=:viridis, colorrange=nothing,
       interpolate=false, linewidth=1, overdraw=false, shading=true,
       transparency=true, visible=true)</code></pre><p>Plot a three-dimensional convex set using <code>Makie</code>.</p><p><strong>Input</strong></p><ul><li><code>S</code>            – convex set</li><li><code>backend</code>      – (optional, default: <code>default_polyhedra_backend(S)</code>) polyhedral                   computations backend </li><li><code>alpha</code>        – (optional, default: <code>1.0</code>) float in <code>[0,1]</code>; the alpha or                   transparency value</li><li><code>color</code>        – (optional, default: <code>:blue</code>) <code>Symbol</code> or <code>Colorant</code>; the color                   of the main plot element (markers, lines, etc.) and it can be                   a color symbol/string like <code>:red</code></li><li><code>colormap</code>     – (optional, default: <code>:viridis</code>) the color map of the main plot;                   call <code>available_gradients()</code> to see what gradients are available,                   and it can also be used as <code>[:red, :black]</code></li><li><code>colorrange</code>   – (optional, default: <code>nothing</code>, which falls back to                   <code>Makie.AbstractPlotting.Automatic()</code>) a tuple <code>(min, max)</code>                   where <code>min</code> and <code>max</code> specify the data range to be used for                   indexing the colormap</li><li><code>interpolate</code>  – (optional, default: <code>false</code>) a bool for heatmap and images,                   it toggles color interpolation between nearby pixels</li><li><code>linewidth</code>    – (optional, default: <code>1</code>) a number that specifies the width of                   the line in <code>line</code> and <code>linesegments</code> plots</li><li><code>overdraw</code>     – (optional, default: <code>false</code>)</li><li><code>shading</code>      – (optional, default: <code>true</code>) a boolean that specifies if shading                   should be on or not (for meshes)</li><li><code>transparency</code> – (optional, default: <code>true</code>) if <code>true</code>, the set is transparent                   otherwise it is displayed as a solid object</li><li><code>visible</code>      – (optional, default: <code>true</code>) a bool that toggles visibility                   of the plot</li></ul><p>For a complete list of attributes and usage see <a href="http://makie.juliaplots.org/stable/plot-attributes">Makie&#39;s documentation</a>.</p><p><strong>Notes</strong></p><p>This plot recipe works by computing the list of constraints of <code>S</code> and converting to a polytope in H-representation. Then, this polytope is transformed with <code>Polyhedra.Mesh</code> and it is plotted using the <code>mesh</code> function.</p><p>If the function <code>constraints_list</code> is not applicable to your set <code>S</code>, try overapproximation first; e.g. via</p><pre><code class="language-julia">julia&gt; using LazySets.Approximations

julia&gt; Sapprox = overapproximate(S, SphericalDirections(10))

julia&gt; plot3d(Sapprox)</code></pre><p>The number <code>10</code> above corresponds to the number of directions considered; for  better resolution use higher values (but it will take longer).</p><p>For efficiency consider using the <code>CDDLib</code> backend, as in</p><pre><code class="language-julia">julia&gt; using CDDLib

julia&gt; plot3d(Sapprox, backend=CDDLib.Library())</code></pre><p><strong>Examples</strong></p><p>The functionality requires <em>both</em> <code>Polyhedra</code> and <code>Makie</code>; so after loading <code>LazySets</code>, do <code>using Makie, Polyhedra</code> (or <code>using Polyhedra, Makie</code>, the order doesn&#39;t matter).</p><pre><code class="language-julia">julia&gt; using LazySets, Makie, Polyhedra

julia&gt; plot3d(10. * rand(Hyperrectangle, dim=3))

julia&gt; plot3d!(10. * rand(Hyperrectangle, dim=3), color=:red)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Plotting/mesh.jl#L38-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.plot3d!" href="#LazySets.plot3d!"><code>LazySets.plot3d!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plot3d!(S::LazySet; backend=default_polyhedra_backend(S),
        alpha=1.0, color=:blue, colormap=:viridis, colorrange=nothing, interpolate=false,
        linewidth=1, overdraw=false, shading=true, transparency=true, visible=true)</code></pre><p>Plot a three-dimensional convex set using Makie.</p><p><strong>Input</strong></p><p>See <code>plot3d</code> for the description of the inputs. For a complete list of attributes and usage see <a href="http://makie.juliaplots.org/stable/plot-attributes">Makie&#39;s documentation</a>.</p><p><strong>Notes</strong></p><p>See the documentation of <code>plot3d</code> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Plotting/mesh.jl#L133-L149">source</a></section></article><h3 id="Set-functions-that-override-Base-functions"><a class="docs-heading-anchor" href="#Set-functions-that-override-Base-functions">Set functions that override Base functions</a><a id="Set-functions-that-override-Base-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Set-functions-that-override-Base-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{LazySet,LazySet}" href="#Base.:==-Tuple{LazySet,LazySet}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">==(X::LazySet, Y::LazySet)</code></pre><p>Return whether two LazySets of the same type are exactly equal.</p><p><strong>Input</strong></p><ul><li><code>X</code> – any <code>LazySet</code></li><li><code>Y</code> – another <code>LazySet</code> of the same type as <code>X</code></li></ul><p><strong>Output</strong></p><ul><li><code>true</code> iff <code>X</code> is equal to <code>Y</code>.</li></ul><p><strong>Notes</strong></p><p>The check is purely syntactic and the sets need to have the same base type. For instance, <code>X::VPolytope == Y::HPolytope</code> returns <code>false</code> even if <code>X</code> and <code>Y</code> represent the same polytope. However <code>X::HPolytope{Int64} == Y::HPolytope{Float64}</code> is a valid comparison.</p><p><strong>Algorithm</strong></p><p>We recursively compare the fields of <code>X</code> and <code>Y</code> until a mismatch is found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; HalfSpace([1], 1) == HalfSpace([1], 1)
true

julia&gt; HalfSpace([1], 1) == HalfSpace([1.0], 1.0)
true

julia&gt; Ball1([0.], 1.) == Ball2([0.], 1.)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L427-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:≈-Tuple{LazySet,LazySet}" href="#Base.:≈-Tuple{LazySet,LazySet}"><code>Base.:≈</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">≈(X::LazySet, Y::LazySet)</code></pre><p>Return whether two LazySets of the same type are approximately equal.</p><p><strong>Input</strong></p><ul><li><code>X</code> – any <code>LazySet</code></li><li><code>Y</code> – another <code>LazySet</code> of the same type as <code>X</code></li></ul><p><strong>Output</strong></p><ul><li><code>true</code> iff <code>X</code> is equal to <code>Y</code>.</li></ul><p><strong>Notes</strong></p><p>The check is purely syntactic and the sets need to have the same base type. For instance, <code>X::VPolytope ≈ Y::HPolytope</code> returns <code>false</code> even if <code>X</code> and <code>Y</code> represent the same polytope. However <code>X::HPolytope{Int64} ≈ Y::HPolytope{Float64}</code> is a valid comparison.</p><p><strong>Algorithm</strong></p><p>We recursively compare the fields of <code>X</code> and <code>Y</code> until a mismatch is found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; HalfSpace([1], 1) ≈ HalfSpace([1], 1)
true

julia&gt; HalfSpace([1], 1) ≈ HalfSpace([1.00000001], 0.99999999)
true

julia&gt; HalfSpace([1], 1) ≈ HalfSpace([1.0], 1.0)
true

julia&gt; Ball1([0.], 1.) ≈ Ball2([0.], 1.)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L479-L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{LazySet}" href="#Base.copy-Tuple{LazySet}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">copy(S::LazySet)</code></pre><p>Return a deep copy of the given set by copying its values recursively.</p><p><strong>Input</strong></p><ul><li><code>S</code> – any <code>LazySet</code></li></ul><p><strong>Output</strong></p><p>A copy of <code>S</code>.</p><p><strong>Notes</strong></p><p>This function performs a <code>deepcopy</code> of each field in <code>S</code>, resulting in a completely independent object. See the documentation of <code>?deepcopy</code> for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L540-L558">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype" href="#Base.eltype"><code>Base.eltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eltype(::Type{&lt;:LazySet{N}}) where {N}</code></pre><p>Return the numeric type (<code>N</code>) of the given set type.</p><p><strong>Input</strong></p><ul><li><code>T</code> – set type, used for dispatch</li></ul><p><strong>Output</strong></p><p>The numeric type of <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L137-L149">source</a></section><section><div><pre><code class="language-none">eltype(::LazySet{N}) where {N}</code></pre><p>Return the numeric type (<code>N</code>) of the given set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set instance, used for dispatch</li></ul><p><strong>Output</strong></p><p>The numeric type of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L152-L164">source</a></section></article><h3 id="Aliases-for-set-types"><a class="docs-heading-anchor" href="#Aliases-for-set-types">Aliases for set types</a><a id="Aliases-for-set-types-1"></a><a class="docs-heading-anchor-permalink" href="#Aliases-for-set-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="LazySets.CompactSet" href="#LazySets.CompactSet"><code>LazySets.CompactSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CompactSet</code></pre><p>An alias for compact set types.</p><p><strong>Notes</strong></p><p>Most lazy operations are not captured by this alias because whether their result is compact or not depends on the argument(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/aliases.jl#L4-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.NonCompactSet" href="#LazySets.NonCompactSet"><code>LazySets.NonCompactSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonCompactSet</code></pre><p>An alias for non-compact set types.</p><p><strong>Notes</strong></p><p>Most lazy operations are not captured by this alias because whether their result is non-compact or not depends on the argument(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/aliases.jl#L20-L29">source</a></section></article><h3 id="Implementations"><a class="docs-heading-anchor" href="#Implementations">Implementations</a><a id="Implementations-1"></a><a class="docs-heading-anchor-permalink" href="#Implementations" title="Permalink"></a></h3><p>Concrete set representations:</p><ul><li><a href="../sets/EmptySet/#def_EmptySet">Empty set (EmptySet)</a></li><li><a href="../sets/PolynomialZonotope/#def_PolynomialZonotope">Polynomial zonotope (PolynomialZonotope)</a></li></ul><p>Lazy set operations:</p><ul><li><a href="../lazy_operations/AffineMap/#def_AffineMap">Affine map (AffineMap)</a></li><li><a href="../lazy_operations/LinearMap/#def_LinearMap">Linear map (LinearMap)</a></li><li><a href="../lazy_operations/ExponentialMap/#def_ExponentialMap">Exponential map (ExponentialMap)</a></li><li><a href="../lazy_operations/ExponentialMap/#def_ExponentialProjectionMap">Exponential projection map (ExponentialProjectionMap)</a></li><li><a href="../lazy_operations/ResetMap/#def_ResetMap">Reset map (ResetMap)</a></li><li><a href="../lazy_operations/Translation/#def_Translation">Translation</a></li><li><a href="../lazy_operations/Bloating/#def_Bloating">Bloating</a></li><li><a href="../lazy_operations/CartesianProduct/#def_CartesianProduct">Binary Cartesian product (CartesianProduct)</a></li><li><a href="../lazy_operations/CartesianProduct/#def_CartesianProductArray"><span>$n$</span>-ary Cartesian product (CartesianProductArray)</a></li><li><a href="../lazy_operations/ConvexHull/#def_ConvexHull">Binary convex hull (ConvexHull)</a></li><li><a href="../lazy_operations/ConvexHull/#def_ConvexHullArray"><span>$n$</span>-ary convex hull (ConvexHullArray)</a></li><li><a href="../lazy_operations/Intersection/#def_Intersection">Binary intersection</a></li><li><a href="../lazy_operations/Intersection/#def_IntersectionArray"><span>$n$</span>-ary intersection (IntersectionArray)</a></li><li><a href="../lazy_operations/MinkowskiSum/#def_MinkowskiSum">Binary Minkowski sum (MinkowskiSum)</a></li><li><a href="../lazy_operations/MinkowskiSum/#def_MinkowskiSumArray"><span>$n$</span>-ary Minkowski sum (MinkowskiSumArray)</a></li><li><a href="../lazy_operations/MinkowskiSum/#def_CachedMinkowskiSumArray"><span>$n$</span>-ary Minkowski sum with cache (CachedMinkowskiSumArray)</a></li><li><a href="../lazy_operations/UnionSet/#def_UnionSet">Binary set union (UnionSet)</a></li><li><a href="../lazy_operations/UnionSet/#def_UnionSetArray"><span>$n$</span>-ary set union (UnionSetArray)</a></li><li><a href="../lazy_operations/Complement/#def_Complement">Complement</a></li><li><a href="../lazy_operations/Rectification/#def_Rectification">Rectification</a></li></ul><h2 id="def_AbstractCentrallySymmetric"><a class="docs-heading-anchor" href="#def_AbstractCentrallySymmetric">Centrally symmetric sets (AbstractCentrallySymmetric)</a><a id="def_AbstractCentrallySymmetric-1"></a><a class="docs-heading-anchor-permalink" href="#def_AbstractCentrallySymmetric" title="Permalink"></a></h2><p>Centrally symmetric sets such as balls of different norms are characterized by a center. Note that there is a special interface combination <a href="#def_AbstractCentrallySymmetricPolytope">Centrally symmetric polytope</a>.</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.AbstractCentrallySymmetric" href="#LazySets.AbstractCentrallySymmetric"><code>LazySets.AbstractCentrallySymmetric</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractCentrallySymmetric{N} &lt;: LazySet{N}</code></pre><p>Abstract type for centrally symmetric sets.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractCentrallySymmetric</code> must define the following functions:</p><ul><li><code>center(::AbstractCentrallySymmetric)</code> – return the center point</li><li><code>center(::AbstractCentrallySymmetric, i::Int)</code> – return the center point at index <code>i</code></li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractCentrallySymmetric)
3-element Array{Any,1}:
 Ball2
 Ballp
 Ellipsoid</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractCentrallySymmetric.jl#L7-L26">source</a></section></article><p>This interface defines the following functions:</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractCentrallySymmetric}" href="#LazySets.dim-Tuple{AbstractCentrallySymmetric}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dim(S::AbstractCentrallySymmetric)</code></pre><p>Return the ambient dimension of a centrally symmetric set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractCentrallySymmetric.jl#L31-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isbounded-Tuple{AbstractCentrallySymmetric}" href="#LazySets.isbounded-Tuple{AbstractCentrallySymmetric}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isbounded(S::AbstractCentrallySymmetric)</code></pre><p>Determine whether a centrally symmetric set is bounded.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p><code>true</code> (since a set with a unique center must be bounded).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractCentrallySymmetric.jl#L48-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isuniversal-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}, Tuple{AbstractCentrallySymmetric{N},Bool}} where N" href="#LazySets.isuniversal-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}, Tuple{AbstractCentrallySymmetric{N},Bool}} where N"><code>LazySets.isuniversal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isuniversal(S::AbstractCentrallySymmetric{N}, [witness]::Bool=false
           ) where {N}</code></pre><p>Check whether a centrally symmetric set is universal.</p><p><strong>Input</strong></p><ul><li><code>S</code>       – centrally symmetric set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>false</code></li><li>If <code>witness</code> option is activated: <code>(false, v)</code> where <span>$v ∉ S$</span></li></ul><p><strong>Algorithm</strong></p><p>A witness is obtained by computing the support vector in direction <code>d = [1, 0, …, 0]</code> and adding <code>d</code> on top.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractCentrallySymmetric.jl#L99-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.an_element-Tuple{AbstractCentrallySymmetric}" href="#LazySets.an_element-Tuple{AbstractCentrallySymmetric}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">an_element(S::AbstractCentrallySymmetric)</code></pre><p>Return some element of a centrally symmetric set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p>The center of the centrally symmetric set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractCentrallySymmetric.jl#L65-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{AbstractCentrallySymmetric}" href="#Base.isempty-Tuple{AbstractCentrallySymmetric}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isempty(S::AbstractCentrallySymmetric)</code></pre><p>Return if a centrally symmetric set is empty or not.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractCentrallySymmetric.jl#L82-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.center-Tuple{AbstractCentrallySymmetric,Int64}" href="#LazySets.center-Tuple{AbstractCentrallySymmetric,Int64}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">center(H::AbstractCentrallySymmetric, i::Int)</code></pre><p>Return the center along a given dimension of a centrally symmetric set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The center along a given dimension of the centrally symmetric set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractCentrallySymmetric.jl#L131-L144">source</a></section></article><h3 id="Implementations-2"><a class="docs-heading-anchor" href="#Implementations-2">Implementations</a><a class="docs-heading-anchor-permalink" href="#Implementations-2" title="Permalink"></a></h3><ul><li><a href="../sets/Ball2/#def_Ball2">Euclidean-norm ball (Ball2)</a></li><li><a href="../sets/Ellipsoid/#def_Ellipsoid">Ellipsoid</a></li><li><a href="../sets/Ballp/#def_Ballp">p-norm ball (Ballp)</a></li></ul><h2 id="def_AbstractPolyhedron"><a class="docs-heading-anchor" href="#def_AbstractPolyhedron">Polyhedra (AbstractPolyhedron)</a><a id="def_AbstractPolyhedron-1"></a><a class="docs-heading-anchor-permalink" href="#def_AbstractPolyhedron" title="Permalink"></a></h2><p>A polyhedron has finitely many facets (<em>H-representation</em>) and is not necessarily bounded.</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.AbstractPolyhedron" href="#LazySets.AbstractPolyhedron"><code>LazySets.AbstractPolyhedron</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractPolyhedron{N} &lt;: LazySet{N}</code></pre><p>Abstract type for compact convex polyhedral sets.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolyhedron</code> must define the following functions:</p><ul><li><code>constraints_list(::AbstractPolyhedron{N})</code> – return a list of all facet   constraints</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolyhedron)
7-element Array{Any,1}:
 AbstractPolytope
 HPolyhedron
 HalfSpace
 Hyperplane
 Line
 Line2D
 Universe</code></pre><p>Polyhedra are defined as the intersection of a finite number of closed half-spaces. As such, polyhedra are closed and convex but not necessarily bounded. Bounded polyhedra are called <em>polytopes</em> (see <a href="#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolyhedron.jl#L3-L30">source</a></section></article><p>This interface defines the following functions:</p><article class="docstring"><header><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{T,1} where T,AbstractPolyhedron}" href="#Base.:∈-Tuple{AbstractArray{T,1} where T,AbstractPolyhedron}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∈(x::AbstractVector, P::AbstractPolyhedron)</code></pre><p>Check whether a given point is contained in a polyhedron.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>P</code> – polyhedron</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation checks if the point lies inside each defining half-space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolyhedron_functions.jl#L41-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isuniversal-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}, Tuple{AbstractPolyhedron{N},Bool}} where N" href="#LazySets.isuniversal-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}, Tuple{AbstractPolyhedron{N},Bool}} where N"><code>LazySets.isuniversal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isuniversal(P::AbstractPolyhedron{N}, [witness]::Bool=false) where {N}</code></pre><p>Check whether a polyhedron is universal.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polyhedron</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P$</span> is universal</li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$P$</span> is universal</li><li><code>(false, v)</code> iff <span>$P$</span> is not universal and <span>$v ∉ P$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><code>P</code> is universal iff it has no constraints.</p><p>A witness is produced using <code>isuniversal(H)</code> where <code>H</code> is the first linear constraint of <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolyhedron_functions.jl#L71-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.constrained_dimensions-Tuple{AbstractPolyhedron}" href="#LazySets.constrained_dimensions-Tuple{AbstractPolyhedron}"><code>LazySets.constrained_dimensions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constrained_dimensions(P::AbstractPolyhedron)</code></pre><p>Return the indices in which a polyhedron is constrained.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polyhedron</li></ul><p><strong>Output</strong></p><p>A vector of ascending indices <code>i</code> such that the polyhedron is constrained in dimension <code>i</code>.</p><p><strong>Examples</strong></p><p>A 2D polyhedron with constraint <span>$x1 ≥ 0$</span> is constrained in dimension 1 only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolyhedron_functions.jl#L104-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{NP}, Tuple{NM}, Tuple{AbstractArray{NM,2},AbstractPolyhedron{NP}}} where NP where NM" href="#LazySets.linear_map-Union{Tuple{NP}, Tuple{NM}, Tuple{AbstractArray{NM,2},AbstractPolyhedron{NP}}} where NP where NM"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{NM},
           P::AbstractPolyhedron{NP};
           [algorithm]::Union{String, Nothing}=nothing,
           [check_invertibility]::Bool=true,
           [cond_tol]::Number=DEFAULT_COND_TOL,
           [inverse]::Union{AbstractMatrix{N}, Nothing}=nothing,
           [backend]=nothing,
           [elimination_method]=nothing) where {NM, NP}</code></pre><p>Concrete linear map of a polyhedral set.</p><p><strong>Input</strong></p><ul><li><p><code>M</code>         – matrix</p></li><li><p><code>P</code>         – polyhedral set</p></li><li><p><code>algorithm</code> – (optional; default: <code>nothing</code>) algorithm to be used; for the                description see the Algorithm section below; possible choices are:</p><ul><li><code>&quot;inverse&quot;</code>, alias: <code>&quot;inv&quot;</code></li><li><code>&quot;inverse_right&quot;</code>, alias: <code>&quot;inv_right&quot;</code></li><li><code>&quot;elimination&quot;</code>, alias: <code>&quot;elim&quot;</code></li><li><code>&quot;lift&quot;</code></li><li><code>&quot;vrep&quot;</code></li><li><code>&quot;vrep_chull&quot;</code></li></ul></li><li><p><code>check_invertibility</code> – (optional, default: <code>true</code>) if <code>true</code> check whether                          given matrix <code>M</code> is invertible; set to <code>false</code> only                          if you know that <code>M</code> is invertible</p></li><li><p><code>cond_tol</code>  – (optional; default: <code>DEFAULT_COND_TOL</code>) tolerance of matrix                condition (used to check whether the matrix is invertible)</p></li><li><p><code>inverse</code>   – (optional; default: <code>nothing</code>) matrix inverse <code>M⁻¹</code>; use this                option if you have already computed the inverse matrix of <code>M</code></p></li><li><p><code>backend</code>   – (optional: default: <code>nothing</code>) polyhedra backend</p></li><li><p><code>elimination_method</code>  – (optional: default: <code>nothing</code>) elimination method for                          the <code>&quot;elimination&quot;</code> algorithm</p></li></ul><p><strong>Output</strong></p><p>The type of the result is &quot;as close as possible&quot; to the the type of <code>P</code>. Let <code>(m, n)</code> be the size of <code>M</code>, where <code>m ≠ n</code> is allowed for rectangular maps.</p><p>To fix the type of the output to something different than the default value, consider post-processing the result of this function with a call to a suitable <code>convert</code> method.</p><p>In particular, the output depends on the type of <code>P</code>, on <code>m</code>, and the algorithm that was used:</p><ul><li><p>If the vertex-based approach was used:</p><ul><li>If <code>P</code> is a <code>VPolygon</code> and <code>m = 2</code> then the output is a <code>VPolygon</code>.</li><li>If <code>P</code> is a <code>VPolytope</code> then the output is a <code>VPolytope</code>.</li><li>Otherwise, the output is an <code>Interval</code> if <code>m = 1</code>, a <code>VPolygon</code> if <code>m = 2</code> and a <code>VPolytope</code> in other cases.</li></ul></li><li><p>If the invertibility criterion was used:</p><ul><li>The types of <code>HalfSpace</code>, <code>Hyperplane</code>, <code>Line2D</code> and <code>AbstractHPolygon</code> are preserved.</li><li>If <code>P</code> is an <code>AbstractPolytope</code>, then the output is an <code>Interval</code> if <code>m = 1</code>, an <code>HPolygon</code> if <code>m = 2</code> and an <code>HPolytope</code> in other cases.</li><li>Otherwise, the output is an <code>HPolyhedron</code>.</li></ul></li></ul><p><strong>Notes</strong></p><p>Since the different linear map algorithms work at the level of constraints (not sets representations), this function uses dispatch on two stages: once the algorithm has been defined, first the helper functions <code>_linear_map_hrep_helper</code> (resp. <code>_linear_map_vrep</code>) are invoked, which dispatch on the set type. Then, each helper function calls the concrete implementation of <code>_linear_map_hrep</code>, which dispatches on the algorithm, and returns a list of constraints.</p><p>To simplify working with different algorithms and options, the types <code>&lt;: AbstractLinearMapAlgorithm</code> are used. These types are singleton type or types that carry only the key data for the given algorithm, such as the matrix inverse or the polyhedra backend.</p><p>New subtypes of the <code>AbstractPolyhedron</code> interface may define their own helper functions <code>_linear_map_vrep</code>, respectively <code>_linear_map_hrep_helper</code> for special handling of the constraints returned by the implementations of <code>_linear_map_hrep</code>; otherwise the fallback implementation for <code>AbstractPolyhedron</code> is used, which instantiates an <code>HPolyhedron</code>.</p><p><strong>Algorithm</strong></p><p>This function mainly implements several approaches for the linear map: inverse, right inverse, transformation to the vertex representation, variable elimination, and variable lifting. Depending on the properties of <code>M</code> and <code>P</code>, one algorithm may be preferable over the other. Details on the algorithms are given in the following subsections.</p><p>Otherwise, if the algorithm argument is not specified, a default option is chosen based on heuristics on the types and values of <code>M</code> and <code>P</code>:</p><ul><li>If the <code>&quot;inverse&quot;</code> algorithm applies, it is used.</li><li>If the <code>&quot;inverse_right&quot;</code> algorithm applies, it is used.</li><li>Otherwise, if the <code>&quot;lift&quot;</code> algorithm applies, it is used.</li><li>Otherwise, the <code>&quot;elimination&quot;</code> algorithm is used.</li></ul><p>Note that <code>&quot;inverse&quot;</code> does not require the external library <code>Polyhedra</code>, and neither does <code>&quot;inverse_right&quot;</code>. However, the fallback method <code>&quot;elimination&quot;</code> requires <code>Polyhedra</code> as well as the library <code>CDDLib</code>.</p><p>The optional keyword arguments <code>inverse</code> and <code>check_invertibility</code> modify the default behavior:</p><ul><li>If an inverse matrix is passed in <code>inverse</code>, the given algorithm is applied, and if none is given, either <code>&quot;inverse&quot;</code> or <code>&quot;inverse_right&quot;</code> is applied (in that order of preference).</li><li>If <code>check_invertibility</code> is set to <code>false</code>, the given algorithm is applied, and if none is given, either <code>&quot;inverse&quot;</code> or <code>&quot;inverse_right&quot;</code> is applied (in that order of preference).</li></ul><p><strong>Inverse</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm=&quot;inverse&quot;</code> (or <code>algorithm=&quot;inv&quot;</code>). The algorithm requires that <code>M</code> is invertible, square, and dense. If you know a priori that <code>M</code> is invertible, set the flag <code>check_invertibility=false</code>, such that no extra checks are done within <code>linear_map</code>. Otherwise, we check the sufficient condition that the condition number of <code>M</code> is not too high. The threshold for the condition number can be modified from its default value, <code>DEFAULT_COND_TOL</code>, by passing a custom <code>cond_tol</code>.</p><p>The algorithm is described next. Assuming that the matrix <span>$M$</span> is invertible (which we check via a sufficient condition,), <span>$y = M x$</span> implies <span>$x = \text{inv}(M) y$</span> and we can transform the polyhedron <span>$A x ≤ b$</span> to the polyhedron <span>$A \text{inv}(M) y ≤ b$</span>.</p><p>If the dense condition on <code>M</code> is not fullfilled, there are two suggested workarounds: either transform to dense matrix, i.e. calling <code>linear_map</code> with <code>Matrix(M)</code>, or use the <code>&quot;inverse_right&quot;</code> algorithm, which does not compute the inverse matrix explicitly, but uses a polyalgorithm; see the documentation of <code>?</code> for details.</p><p><strong>Inverse-right</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm=&quot;inverse_right&quot;</code> (or <code>algorithm=&quot;inv_right&quot;</code>). This algorithm applies to square and invertible matrices <code>M</code>. The idea is essentially the same as for the <code>&quot;inverse&quot;</code> algorithm; the difference is that in <code>&quot;inverse&quot;</code> the full matrix inverse is computed, and in <code>&quot;inverse_right&quot;</code> only the left division on the normal vectors is used. In particular, <code>&quot;inverse_right&quot;</code> is good as a workaround when <code>M</code> is sparse (since the <code>inv</code> function is not available for sparse matrices).</p><p><strong>Elimination</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm = &quot;elimination&quot;</code> or <code>algorithm = &quot;elim&quot;</code>. The algorithm applies to any matrix <code>M</code> (invertible or not), and any polyhedron <code>P</code> (bounded or not).</p><p>The idea is described next. If <code>P : Ax &lt;= b</code> and <code>y = Mx</code> denote the polyhedron and the linear map respectively, we consider the vector <code>z = [y, x]</code>, write the given equalities and the inequalities, and then eliminate the last x variables (there are <code>length(x)</code> in total) using a call to <code>Polyhedra.eliminate</code> to a backend library that can do variable elimination, typically <code>CDDLib</code> with the <code>BlockElimination()</code> algorithm. In this way we have eliminated the &quot;old&quot; variables <code>x</code> and kept the &quot;new&quot; or transformed variables &quot;y&quot;.</p><p>The default elimination method is block elimination. For possible options we refer to the documentation of Polyhedra, <a href="https://juliapolyhedra.github.io/Polyhedra.jl/latest/projection/">projection/elimination</a>.</p><p><strong>Lift</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm=&quot;lift&quot;</code>. The algorithm applies if <code>M</code> is rectangular of size <code>m × n</code> with <code>m &gt; n</code> and full rank (i.e. of rank <code>n</code>).</p><p>The idea is to embed the polyhedron into the <code>m</code>-dimensional space by appending zeros, i.e. extending all constraints of <code>P</code> to <code>m</code> dimensions, and constraining the last <code>m - n</code> dimensions to <code>0</code>. The matrix resulting matrix is extended to an invertible <code>m × m</code> matrix and the algorithm using the inverse of the linear map is applied. For the technical details of the extension of <code>M</code> to a higher-dimensional invertible matrix, see <code>LazySets.Arrays.extend</code>.</p><p><strong>Vertex representation</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm</code> either <code>&quot;vrep&quot;</code> or <code>&quot;vrep_chull&quot;</code>. The idea is to convert the polyhedron to its vertex representation and apply the linear map to each vertex of <code>P</code>.</p><p>The returned set is a polytope in vertex representation. Note that conversion of the result back to half-space representation is not computed by default, since this may be costly. If you used this algorithm and still want to convert back to half-space representation, apply <code>tohrep</code> to the result of this function. Note that this method only works for bounded polyhedra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolyhedron_functions.jl#L394-L582">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.chebyshev_center-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}} where N" href="#LazySets.chebyshev_center-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}} where N"><code>LazySets.chebyshev_center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chebyshev_center(P::AbstractPolyhedron{N};
                 [get_radius]::Bool=false,
                 [backend]=default_polyhedra_backend(P),
                 [solver]=default_lp_solver_polyhedra(N; presolve=true)
                 ) where {N}</code></pre><p>Compute the <a href="https://en.wikipedia.org/wiki/Chebyshev_center">Chebyshev center</a> of a polytope.</p><p><strong>Input</strong></p><ul><li><code>P</code>          – polytope</li><li><code>get_radius</code> – (optional; default: <code>false</code>) option to additionally return the                 radius of the largest ball enclosed by <code>P</code> around the                 Chebyshev center</li><li><code>backend</code>    – (optional; default: <code>default_polyhedra_backend(P)</code>) the                 backend for polyhedral computations</li><li><code>solver</code>     – (optional; default:                 <code>default_lp_solver_polyhedra(N; presolve=true)</code>) the LP                 solver passed to <code>Polyhedra</code></li></ul><p><strong>Output</strong></p><p>If <code>get_radius</code> is <code>false</code>, the result is the Chebyshev center of <code>P</code>. If <code>get_radius</code> is <code>true</code>, the result is the pair <code>(c, r)</code> where <code>c</code> is the Chebyshev center of <code>P</code> and <code>r</code> is the radius of the largest ball with center <code>c</code> enclosed by <code>P</code>.</p><p><strong>Notes</strong></p><p>The Chebyshev center is the center of a largest Euclidean ball enclosed by <code>P</code>. In general, the center of such a ball is not unique (but the radius is).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolyhedron_functions.jl#L830-L863">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}} where N" href="#LazySets.an_element-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}} where N"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">an_element(S::LazySet{N}) where {N}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>An element of a convex set.</p><p><strong>Algorithm</strong></p><p>An element of the set is obtained by evaluating its support vector along direction <span>$[1, 0, …, 0]$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/LazySet.jl#L404-L421">source</a></section><section><div><pre><code class="language-none">an_element(P::AbstractPolyhedron{N};
           [solver]=default_lp_solver(N)) where {N}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polyhedron</li><li><code>solver</code>  – (optional, default: <code>default_lp_solver(N)</code>) LP solver</li></ul><p><strong>Output</strong></p><p>An element of the polyhedron, or an error if the polyhedron is empty.</p><p><strong>Algorithm</strong></p><p>An element of the polyhedron is obtained by solving a feasibility linear program.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolyhedron_functions.jl#L880-L898">source</a></section><section><div><pre><code class="language-none">an_element(L::Line2D{N}) where {N}</code></pre><p>Return some element of a line.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line</li></ul><p><strong>Output</strong></p><p>An element on the line.</p><p><strong>Algorithm</strong></p><p>If the <span>$b$</span> value of the line is zero, the result is the origin. Otherwise the result is some <span>$x = [x1, x2]$</span> such that <span>$a·[x1, x2] = b$</span>. We first find out in which dimension <span>$a$</span> is nonzero, say, dimension 1, and then choose <span>$x1 = 1$</span> and accordingly <span>$x2 = \frac{b - a1}{a2}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Sets/Line2D.jl#L193-L212">source</a></section><section><div><pre><code class="language-none">an_element(U::Universe{N}) where {N}</code></pre><p>Return some element of a universe.</p><p><strong>Input</strong></p><ul><li><code>U</code> – universe</li></ul><p><strong>Output</strong></p><p>The origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Sets/Universe.jl#L166-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isbounded-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}} where N" href="#LazySets.isbounded-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}} where N"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isbounded(P::AbstractPolyhedron{N}; [solver]=default_lp_solver(N)) where {N}</code></pre><p>Determine whether a polyhedron is bounded.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polyhedron</li><li><code>solver</code>  – (optional, default: <code>default_lp_solver(N)</code>) the backend used              to solve the linear program</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the polyhedron is bounded</p><p><strong>Algorithm</strong></p><p>We first check if the polyhedron has more than <code>max(dim(P), 1)</code> constraints, which is a necessary condition for boundedness.</p><p>If so, we check boundedness via <code>_isbounded_stiemke</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolyhedron_functions.jl#L918-L939">source</a></section><section><div><pre><code class="language-none">isbounded(r::Rectification{N}) where {N}</code></pre><p>Determine whether a rectification is bounded.</p><p><strong>Input</strong></p><ul><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the rectification is bounded.</p><p><strong>Algorithm</strong></p><p>Let <span>$X$</span> be the set wrapped by rectification <span>$r$</span>. We first check whether <span>$X$</span> is bounded (because then <span>$r$</span> is bounded). Otherwise, we check unboundedness of <span>$X$</span> in direction <span>$(1, 1, …, 1)$</span>, which is sufficient for unboundedness of <span>$r$</span>; this step is not necessary but rather a heuristics. Otherwise, we check boundedness of <span>$X$</span> in every positive unit direction, which is sufficient and necessary for boundedness of <span>$r$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/LazyOperations/Rectification.jl#L386-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.vertices_list-Tuple{AbstractPolyhedron}" href="#LazySets.vertices_list-Tuple{AbstractPolyhedron}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertices_list(P::AbstractPolyhedron; check_boundedness::Bool=true)</code></pre><p>Return the list of vertices of a polyhedron in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>                 – polyhedron in constraint representation</li><li><code>check_boundedness</code> – (optional, default: <code>true</code>) if <code>true</code>, check whether the                        polyhedron is bounded</li></ul><p><strong>Output</strong></p><p>The list of vertices of <code>P</code>, or an error if <code>P</code> is unbounded.</p><p><strong>Notes</strong></p><p>This function returns an error if the polyhedron is unbounded. Otherwise, the polyhedron is converted to an <code>HPolytope</code> and its list of vertices is computed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; P = HPolyhedron([HalfSpace([1.0, 0.0], 1.0),
                        HalfSpace([0.0, 1.0], 1.0),
                        HalfSpace([-1.0, 0.0], 1.0),
                        HalfSpace([0.0, -1.0], 1.0)]);

julia&gt; length(vertices_list(P))
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolyhedron_functions.jl#L948-L979">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.project-Union{Tuple{N}, Tuple{AbstractPolyhedron{N},AbstractArray{Int64,1}}} where N" href="#LazySets.project-Union{Tuple{N}, Tuple{AbstractPolyhedron{N},AbstractArray{Int64,1}}} where N"><code>LazySets.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project(P::AbstractPolyhedron{N}, block::AbstractVector{Int}) where {N}</code></pre><p>Concrete projection of a polyhedral set.</p><p><strong>Input</strong></p><ul><li><code>P</code>        – set</li><li><code>block</code>    – block structure, a vector with the dimensions of interest</li></ul><p><strong>Output</strong></p><p>A polyhedron representing the projection of <code>P</code> on the dimensions specified by <code>block</code>. If <code>P</code> was bounded, the result is an <code>HPolytope</code>; otherwise the result is an <code>HPolyhedron</code>. Note that there are more specific methods for specific input types, which give a different output type; e.g., projecting a <code>Ball1</code> results in a <code>Ball1</code>.</p><p><strong>Algorithm</strong></p><ul><li>We first try to exploit the special case where each of the constraints of <code>P</code> and <code>block</code> are <em>compatible</em>, which is one of the two cases described below. Let <code>c</code> be a constraint of <code>P</code> and let <span>$D_c$</span> and <span>$D_b$</span> be the set of dimensions in which <code>c</code> resp. <code>block</code> are constrained.<ul><li>If <span>$D_c ⊆ D_b$</span>, then one can project the normal vector of <code>c</code>.</li><li>If <span>$D_c ∩ D_b = ∅$</span>, then the constraint becomes redundant.</li></ul></li><li>In the general case, we compute the concrete linear map of the projection matrix associated to the given block structure.</li></ul><p><strong>Examples</strong></p><p>Consider the four-dimensional cross-polytope (unit ball in the 1-norm):</p><pre><code class="language-julia-repl">julia&gt; P = convert(HPolytope, Ball1(zeros(4), 1.0));</code></pre><p>All dimensions are constrained, and computing the (trivial) projection on the whole space behaves as expected:</p><pre><code class="language-julia-repl">julia&gt; constrained_dimensions(P)
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; project(P, [1, 2, 3, 4]) == P
true</code></pre><p>Each constraint of the cross polytope is constrained in all dimensions.</p><p>Now let&#39;s take a ball in the infinity norm and remove some constraints:</p><pre><code class="language-julia-repl">julia&gt; B = BallInf(zeros(4), 1.0);

julia&gt; c = constraints_list(B)[1:2]
2-element Array{HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}},1}:
 HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([1.0, 0.0, 0.0, 0.0], 1.0)
 HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([0.0, 1.0, 0.0, 0.0], 1.0)

julia&gt; P = HPolyhedron(c);

julia&gt; constrained_dimensions(P)
2-element Array{Int64,1}:
 1
 2</code></pre><p>Finally we take the concrete projection onto variables <code>1</code> and <code>2</code>:</p><pre><code class="language-julia-repl">julia&gt; project(P, [1, 2]) |&gt; constraints_list
2-element Array{HalfSpace{Float64,Array{Float64,1}},1}:
 HalfSpace{Float64,Array{Float64,1}}([1.0, 0.0], 1.0)
 HalfSpace{Float64,Array{Float64,1}}([0.0, 1.0], 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolyhedron_functions.jl#L988-L1068">source</a></section></article><p>Plotting (bounded) polyhedra is available, too:</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.plot_recipe-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}, Tuple{AbstractPolyhedron{N},Any}} where N" href="#LazySets.plot_recipe-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}, Tuple{AbstractPolyhedron{N},Any}} where N"><code>LazySets.plot_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_recipe(P::AbstractPolyhedron{N}, [ε]=zero(N)) where {N}</code></pre><p>Convert a (bounded) polyhedron to a pair <code>(x, y)</code> of points for plotting.</p><p><strong>Input</strong></p><ul><li><code>P</code> – bounded polyhedron</li><li><code>ε</code> – (optional, default: <code>0</code>) ignored, used for dispatch</li></ul><p><strong>Output</strong></p><p>A pair <code>(x, y)</code> of points that can be plotted, where <code>x</code> is the vector of x-coordinates and <code>y</code> is the vector of y-coordinates.</p><p><strong>Algorithm</strong></p><p>We first assert that <code>P</code> is bounded (i.e., that <code>P</code> is a polytope).</p><p>One-dimensional polytopes are converted to an <code>Interval</code>. Three-dimensional or higher-dimensional polytopes are not supported.</p><p>For two-dimensional polytopes (i.e., polygons) we compute their set of vertices using <code>vertices_list</code> and then plot the convex hull of these vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolyhedron_functions.jl#L775-L799">source</a></section></article><h3 id="Implementations-3"><a class="docs-heading-anchor" href="#Implementations-3">Implementations</a><a class="docs-heading-anchor-permalink" href="#Implementations-3" title="Permalink"></a></h3><ul><li><a href="../sets/HalfSpace/#def_HalfSpace">Half-space (HalfSpace)</a></li><li><a href="../sets/HPolyhedron/#def_HPolyhedron">Polyhedron in constraint representation (HPolyhedron)</a></li><li><a href="../sets/Hyperplane/#def_Hyperplane">Hyperplane</a></li><li><a href="../sets/Line2D/#def_Line2D">Line2D</a></li><li><a href="../sets/Line/#def_Line">Line</a></li><li><a href="../sets/Universe/#def_Universe">Universe</a></li></ul><h2 id="def_AbstractPolytope"><a class="docs-heading-anchor" href="#def_AbstractPolytope">Polytopes (AbstractPolytope)</a><a id="def_AbstractPolytope-1"></a><a class="docs-heading-anchor-permalink" href="#def_AbstractPolytope" title="Permalink"></a></h2><p>A polytope is a bounded set with finitely many vertices (<em>V-representation</em>) resp. facets (<em>H-representation</em>). Note that there is a special interface combination <a href="#def_AbstractCentrallySymmetricPolytope">Centrally symmetric polytope</a>.</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.AbstractPolytope" href="#LazySets.AbstractPolytope"><code>LazySets.AbstractPolytope</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractPolytope{N} &lt;: AbstractPolyhedron{N}</code></pre><p>Abstract type for compact convex polytopic sets.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolytope</code> must define the following functions:</p><ul><li><code>vertices_list(::AbstractPolytope{N})</code> – return a list of all vertices</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolytope)
4-element Array{Any,1}:
 AbstractCentrallySymmetricPolytope
 AbstractPolygon
 HPolytope
 VPolytope</code></pre><p>A polytope is a bounded polyhedron (see <a href="#LazySets.AbstractPolyhedron"><code>AbstractPolyhedron</code></a>). Polytopes are compact convex sets with either of the following equivalent properties:</p><ol><li>They are the intersection of a finite number of closed half-spaces.</li><li>They are the convex hull of finitely many vertices.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolytope.jl#L8-L32">source</a></section></article><p>This interface defines the following functions:</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.isbounded-Tuple{AbstractPolytope}" href="#LazySets.isbounded-Tuple{AbstractPolytope}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isbounded(P::AbstractPolytope)</code></pre><p>Determine whether a polytopic set is bounded.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polytopic set</li></ul><p><strong>Output</strong></p><p><code>true</code> (since a polytope must be bounded).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolytope.jl#L41-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isuniversal-Union{Tuple{AbstractPolytope{N}}, Tuple{N}, Tuple{AbstractPolytope{N},Bool}} where N" href="#LazySets.isuniversal-Union{Tuple{AbstractPolytope{N}}, Tuple{N}, Tuple{AbstractPolytope{N},Bool}} where N"><code>LazySets.isuniversal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isuniversal(P::AbstractPolytope{N}, [witness]::Bool=false) where {N}</code></pre><p>Check whether a polyhedron is universal.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polyhedron</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>false</code></li><li>If <code>witness</code> option is activated: <code>(false, v)</code> where <span>$v ∉ P$</span></li></ul><p><strong>Algorithm</strong></p><p>A witness is produced using <code>isuniversal(H)</code> where <code>H</code> is the first linear constraint of <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolytope.jl#L80-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{AbstractPolytope}" href="#Base.isempty-Tuple{AbstractPolytope}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isempty(P::AbstractPolytope)</code></pre><p>Determine whether a polytope is empty.</p><p><strong>Input</strong></p><ul><li><code>P</code> – abstract polytope</li></ul><p><strong>Output</strong></p><p><code>true</code> if the given polytope contains no vertices, and <code>false</code> otherwise.</p><p><strong>Algorithm</strong></p><p>This algorithm checks whether the <code>vertices_list</code> of the given polytope is empty or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolytope.jl#L58-L75">source</a></section></article><h3 id="Implementations-4"><a class="docs-heading-anchor" href="#Implementations-4">Implementations</a><a class="docs-heading-anchor-permalink" href="#Implementations-4" title="Permalink"></a></h3><ul><li><a href="../sets/HPolytope/#def_HPolytope">Polytope in constraint representation (HPolytope)</a></li><li><a href="../sets/VPolytope/#def_VPolytope">Polytope in vertex representation (VPolytope)</a></li></ul><h2 id="def_AbstractPolygon"><a class="docs-heading-anchor" href="#def_AbstractPolygon">Polygons (AbstractPolygon)</a><a id="def_AbstractPolygon-1"></a><a class="docs-heading-anchor-permalink" href="#def_AbstractPolygon" title="Permalink"></a></h2><p>A polygon is a two-dimensional polytope.</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.AbstractPolygon" href="#LazySets.AbstractPolygon"><code>LazySets.AbstractPolygon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractPolygon{N} &lt;: AbstractPolytope{N}</code></pre><p>Abstract type for polygons (i.e., 2D polytopes).</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolygon</code> must define the following functions:</p><ul><li><code>tovrep(::AbstractPolygon{N})</code>         – transform into   V-representation</li><li><code>tohrep(::AbstractPolygon{N}) where {S&lt;:AbstractHPolygon{N}}</code> – transform   into H-representation</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolygon)
2-element Array{Any,1}:
 AbstractHPolygon
 VPolygon</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolygon.jl#L7-L26">source</a></section></article><p>This interface defines the following functions:</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractPolygon}" href="#LazySets.dim-Tuple{AbstractPolygon}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dim(P::AbstractPolygon)</code></pre><p>Return the ambient dimension of a polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polygon, which is 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolygon.jl#L34-L46">source</a></section></article><p>The following helper functions are used for sorting directions:</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.jump2pi" href="#LazySets.jump2pi"><code>LazySets.jump2pi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">jump2pi(x::N) where {N&lt;:AbstractFloat}</code></pre><p>Return <span>$x + 2π$</span> if <span>$x$</span> is negative, otherwise return <span>$x$</span>.</p><p><strong>Input</strong></p><ul><li><code>x</code> – real scalar</li></ul><p><strong>Output</strong></p><p><span>$x + 2π$</span> if <span>$x$</span> is negative, <span>$x$</span> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LazySets: jump2pi

julia&gt; jump2pi(0.0)
0.0

julia&gt; jump2pi(-0.5)
5.783185307179586

julia&gt; jump2pi(0.5)
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolygon.jl#L51-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&lt;=-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#Base.:&lt;=-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>Base.:&lt;=</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">&lt;=(u::AbstractVector, v::AbstractVector)</code></pre><p>Compare two 2D vectors by their direction.</p><p><strong>Input</strong></p><ul><li><code>u</code> – first 2D direction</li><li><code>v</code> – second 2D direction</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$\arg(u) [2π] ≤ \arg(v) [2π]$</span>.</p><p><strong>Notes</strong></p><p>The argument is measured in counter-clockwise fashion, with the 0 being the direction (1, 0).</p><p><strong>Algorithm</strong></p><p>The implementation checks the quadrant of each direction, and compares directions using the right-hand rule (see <a href="../utils/#LazySets.Arrays.is_right_turn"><code>is_right_turn</code></a>). In particular, this method does not use the arctangent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolygon.jl#L117-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets._leq_trig-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:AbstractFloat" href="#LazySets._leq_trig-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:AbstractFloat"><code>LazySets._leq_trig</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_leq_trig(u::AbstractVector{N}, v::AbstractVector{N}) where {N&lt;:AbstractFloat}</code></pre><p>Compares two 2D vectors by their direction.</p><p><strong>Input</strong></p><ul><li><code>u</code> –  first 2D direction</li><li><code>v</code> –  second 2D direction</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$\arg(u) [2π] ≤ \arg(v) [2π]$</span>.</p><p><strong>Notes</strong></p><p>The argument is measured in counter-clockwise fashion, with the 0 being the direction (1, 0).</p><p><strong>Algorithm</strong></p><p>The implementation uses the arctangent function with sign, <code>atan</code>, which for two arguments implements the <a href="https://en.wikipedia.org/wiki/Atan2"><code>atan2</code> function</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolygon.jl#L160-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.quadrant-Union{Tuple{AbstractArray{N,1}}, Tuple{N}} where N" href="#LazySets.quadrant-Union{Tuple{AbstractArray{N,1}}, Tuple{N}} where N"><code>LazySets.quadrant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">quadrant(w::AbstractVector{N}) where {N}</code></pre><p>Compute the quadrant where the direction <code>w</code> belongs.</p><p><strong>Input</strong></p><ul><li><code>w</code> –  direction</li></ul><p><strong>Output</strong></p><p>An integer from 0 to 3, with the following convention:</p><pre><code class="language-none">     ^
   1 | 0
  ---+--&gt;
   2 | 3</code></pre><p><strong>Algorithm</strong></p><p>The idea is to encode the following logic function: <span>$11 ↦ 0, 01 ↦ 1, 00 ↦ 2, 10 ↦ 3$</span>, according to the convention of above.</p><p>This function is inspired from AGPX&#39;s answer in: <a href="https://stackoverflow.com/a/46635372">Sort points in clockwise order?</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractPolygon.jl#L83-L110">source</a></section></article><h3 id="Implementations-5"><a class="docs-heading-anchor" href="#Implementations-5">Implementations</a><a class="docs-heading-anchor-permalink" href="#Implementations-5" title="Permalink"></a></h3><ul><li><a href="../sets/VPolygon/#def_VPolygon">Polygon in vertex representation (VPolygon)</a></li></ul><h2 id="def_AbstractHPolygon"><a class="docs-heading-anchor" href="#def_AbstractHPolygon">Polygons in constraint representation (AbstractHPolygon)</a><a id="def_AbstractHPolygon-1"></a><a class="docs-heading-anchor-permalink" href="#def_AbstractHPolygon" title="Permalink"></a></h2><p>An HPolygon is a polygon in H-representation (or constraint representation).</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.AbstractHPolygon" href="#LazySets.AbstractHPolygon"><code>LazySets.AbstractHPolygon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractHPolygon{N} &lt;: AbstractPolygon{N}</code></pre><p>Abstract type for polygons in H-representation (i.e., constraints).</p><p><strong>Notes</strong></p><p>All subtypes must satisfy the invariant that constraints are sorted counter-clockwise.</p><p>Every concrete <code>AbstractHPolygon</code> must have the following fields:</p><ul><li><code>constraints::Vector{LinearConstraint{N, AbstractVector{N}}}</code> – the constraints</li></ul><p>New subtypes should be added to the <code>convert</code> method in order to be convertible.</p><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractHPolygon)
2-element Array{Any,1}:
 HPolygon
 HPolygonOpt</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHPolygon.jl#L20-L41">source</a></section></article><p>This interface defines the following functions:</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.an_element-Tuple{AbstractHPolygon}" href="#LazySets.an_element-Tuple{AbstractHPolygon}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">an_element(P::AbstractHPolygon)</code></pre><p>Return some element of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>A vertex of the polygon in constraint representation (the first one in the order of the constraints).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHPolygon.jl#L193-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{T,1} where T,AbstractHPolygon}" href="#Base.:∈-Tuple{AbstractArray{T,1} where T,AbstractHPolygon}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∈(x::AbstractVector, P::AbstractHPolygon)</code></pre><p>Check whether a given 2D point is contained in a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>x</code> – two-dimensional point/vector</li><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation checks if the point lies on the outside of each edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHPolygon.jl#L213-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Union{Tuple{Type{HPOLYGON}}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon" href="#Base.rand-Union{Tuple{Type{HPOLYGON}}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rand(::Type{HPOLYGON}; [N]::Type=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing,
     [num_constraints]::Int=-1) where {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Create a random polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPOLYGON</code>        – type for dispatch</li><li><code>N</code>               – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>             – (optional, default: 2) dimension</li><li><code>rng</code>             – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>            – (optional, default: <code>nothing</code>) seed for reseeding</li><li><code>num_constraints</code> – (optional, default: <code>-1</code>) number of constraints of the                      polygon (must be 3 or bigger; see comment below)</li></ul><p><strong>Output</strong></p><p>A random polygon in constraint representation.</p><p><strong>Algorithm</strong></p><p>We create a random polygon in vertex representation and convert it to constraint representation. See <a href="../sets/VPolygon/#Base.rand-Tuple{Type{VPolygon}}"><code>rand(::Type{VPolygon})</code></a>. For non-flat polygons the number of vertices and the number of constraints are identical.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHPolygon.jl#L243-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.tohrep-Tuple{HPOLYGON} where HPOLYGON&lt;:AbstractHPolygon" href="#LazySets.tohrep-Tuple{HPOLYGON} where HPOLYGON&lt;:AbstractHPolygon"><code>LazySets.tohrep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tohrep(P::HPOLYGON) where {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Build a contraint representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>The identity, i.e., the same polygon instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHPolygon.jl#L66-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.tovrep-Tuple{AbstractHPolygon}" href="#LazySets.tovrep-Tuple{AbstractHPolygon}"><code>LazySets.tovrep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tovrep(P::AbstractHPolygon)</code></pre><p>Build a vertex representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>The same polygon but in vertex representation, a <code>VPolygon</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHPolygon.jl#L49-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.addconstraint!-Tuple{AbstractHPolygon,HalfSpace}" href="#LazySets.addconstraint!-Tuple{AbstractHPolygon,HalfSpace}"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addconstraint!(P::AbstractHPolygon,
               constraint::LinearConstraint;
               [linear_search]::Bool=(length(P.constraints) &lt;
                                      BINARY_SEARCH_THRESHOLD),
               [prune]::Bool=true)</code></pre><p>Add a linear constraint to a polygon in constraint representation, keeping the constraints sorted by their normal directions.</p><p><strong>Input</strong></p><ul><li><code>P</code>             – polygon in constraint representation</li><li><code>constraint</code>    – linear constraint to add</li><li><code>linear_search</code> – (optional, default: <code>length(constraints) &lt;                    BINARY_SEARCH_THRESHOLD</code>) flag to choose between linear                    and binary search</li><li><code>prune</code>         – (optional, default: <code>true</code>) flag for removing redundant                    constraints in the end</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHPolygon.jl#L409-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.addconstraint!-Union{Tuple{LC}, Tuple{Array{LC,1},HalfSpace}} where LC&lt;:HalfSpace" href="#LazySets.addconstraint!-Union{Tuple{LC}, Tuple{Array{LC,1},HalfSpace}} where LC&lt;:HalfSpace"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addconstraint!(constraints::Vector{LC},
               new_constraint::LinearConstraint;
               [linear_search]::Bool=(length(P.constraints) &lt;
                                      BINARY_SEARCH_THRESHOLD),
               [prune]::Bool=true
              ) where {LC&lt;:LinearConstraint}</code></pre><p>Add a linear constraint to a sorted vector of constrains, keeping the constraints sorted by their normal directions.</p><p><strong>Input</strong></p><ul><li><code>constraints</code>    – vector of linear constraintspolygon in constraint                     representation</li><li><code>new_constraint</code> – linear constraint to add</li><li><code>linear_search</code>  – (optional, default: <code>length(constraints) &lt;                     BINARY_SEARCH_THRESHOLD</code>) flag to choose between linear                     and binary search</li><li><code>prune</code>          – (optional, default: <code>true</code>) flag for removing redundant                     constraints in the end</li></ul><p><strong>Algorithm</strong></p><p>If <code>prune</code> is active, we check if the new constraint is redundant. If the constraint is not redundant, we perform the same check to the left and to the right until we find the first constraint that is not redundant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHPolygon.jl#L438-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}, Tuple{AbstractHPolygon{N},Any}} where N" href="#LinearAlgebra.normalize-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}, Tuple{AbstractHPolygon{N},Any}} where N"><code>LinearAlgebra.normalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalize(P::AbstractHPolygon{N}, p=N(2)) where {N}</code></pre><p>Normalize a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li><li><code>p</code> – (optional, default: <code>2</code>) norm</li></ul><p><strong>Output</strong></p><p>A new polygon in constraint representation whose normal directions <span>$a_i$</span> are normalized, i.e., such that <span>$‖a_i‖_p = 1$</span> holds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHPolygon.jl#L83-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isredundant-Tuple{HalfSpace,HalfSpace,HalfSpace}" href="#LazySets.isredundant-Tuple{HalfSpace,HalfSpace,HalfSpace}"><code>LazySets.isredundant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isredundant(cmid::LinearConstraint, cright::LinearConstraint,
            cleft::LinearConstraint)</code></pre><p>Check whether a linear constraint is redundant wrt. two surrounding constraints.</p><p><strong>Input</strong></p><ul><li><code>cmid</code>   – linear constraint of concern</li><li><code>cright</code> – linear constraint to the right (clockwise turn)</li><li><code>cleft</code>  – linear constraint to the left (counter-clockwise turn)</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the constraint is redundant.</p><p><strong>Algorithm</strong></p><p>We first check whether the angle between the surrounding constraints is &lt; 180°, which is a necessary condition (unless the direction is identical to one of the other two constraints). If so, we next check if the angle is 0°, in which case the constraint <code>cmid</code> is redundant unless it is strictly tighter than the other two constraints. If the angle is strictly between 0° and 180°, the constraint <code>cmid</code> is redundant if and only if the vertex defined by the other two constraints lies inside the set defined by <code>cmid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHPolygon.jl#L290-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.remove_redundant_constraints!-Tuple{AbstractHPolygon}" href="#LazySets.remove_redundant_constraints!-Tuple{AbstractHPolygon}"><code>LazySets.remove_redundant_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">remove_redundant_constraints!(P::AbstractHPolygon)</code></pre><p>Remove all redundant constraints of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>The same polygon with all redundant constraints removed.</p><p><strong>Notes</strong></p><p>Since we only consider bounded polygons and a polygon needs at least three constraints to be bounded, we stop removing redundant constraints if there are three or less constraints left. This means that for non-bounded polygons the result may be unexpected.</p><p><strong>Algorithm</strong></p><p>We go through all consecutive triples of constraints and check if the one in the middle is redundant. For this we assume that the constraints are sorted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHPolygon.jl#L360-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.constraints_list-Tuple{AbstractHPolygon}" href="#LazySets.constraints_list-Tuple{AbstractHPolygon}"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraints_list(P::AbstractHPolygon)</code></pre><p>Return the list of constraints defining a polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in H-representation</li></ul><p><strong>Output</strong></p><p>The list of constraints of the polygon. The implementation guarantees that the constraints are sorted counter-clockwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHPolygon.jl#L171-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N" href="#LazySets.vertices_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertices_list(P::AbstractHPolygon{N};
              apply_convex_hull::Bool=true,
              check_feasibility::Bool=true) where {N}</code></pre><p>Return the list of vertices of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>                 – polygon in constraint representation</li><li><code>apply_convex_hull</code> – (optional, default: <code>true</code>) flag to post-process the                        intersection of constraints with a convex hull</li><li><code>check_feasibility</code> – (optional, default: <code>true</code>) flag to check whether the                        polygon was empty (required for correctness in case of                        empty polygons)</li></ul><p><strong>Output</strong></p><p>List of vertices.</p><p><strong>Algorithm</strong></p><p>We compute each vertex as the intersection of consecutive lines defined by the half-spaces. If <code>check_feasibility</code> is active, we then check if the constraints of the polygon were actually feasible (i.e., they pointed in the <em>right</em> direction). For this we compute the <em>average</em> of all vertices and check membership in each constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHPolygon.jl#L108-L136">source</a></section><section><div><pre><code class="language-none">vertices_list(B::Ball1{N, VN}) where {N, VN&lt;:AbstractVector}</code></pre><p>Return the list of vertices of a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the 1-norm</li></ul><p><strong>Output</strong></p><p>A list containing the vertices of the ball in the 1-norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Sets/Ball1.jl#L84-L96">source</a></section><section><div><pre><code class="language-none">vertices_list(∅::EmptySet{N}) where {N}</code></pre><p>Return the list of vertices of an empty set.</p><p><strong>Input</strong></p><ul><li><code>∅</code> – empty set</li></ul><p><strong>Output</strong></p><p>The empty list of vertices, as the empty set does not contain any vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Sets/EmptySet.jl#L293-L305">source</a></section><section><div><pre><code class="language-none">vertices_list(P::HPolytope{N};
              [backend]=nothing, [prune]::Bool=true) where {N}</code></pre><p>Return the list of vertices of a polytope in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polytope in constraint representation</li><li><code>backend</code> – (optional, default: <code>nothing</code>) the polyhedral computations backend</li><li><code>prune</code>   – (optional, default: <code>true</code>) flag to remove redundant vertices</li></ul><p><strong>Output</strong></p><p>List of vertices.</p><p><strong>Algorithm</strong></p><p>If the polytope is two-dimensional, the polytope is converted to a polygon in H-representation and then its <code>vertices_list</code> function is used. This ensures that, by default, the optimized two-dimensional methods are used.</p><p>It is possible to use the <code>Polyhedra</code> backend in two-dimensions as well by passing, e.g. <code>backend=CDDLib.Library()</code>.</p><p>If the polytope is not two-dimensional, the concrete polyhedra manipulation library <code>Polyhedra</code> is used. The actual computation is performed by a given backend; for the default backend used in <code>LazySets</code> see <code>default_polyhedra_backend(P)</code>. For further information on the supported backends see <a href="https://juliapolyhedra.github.io/Polyhedra.jl/">Polyhedra&#39;s documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Sets/HPolytope.jl#L180-L210">source</a></section><section><div><pre><code class="language-none">vertices_list(cp::CartesianProduct{N}) where {N}</code></pre><p>Return the list of vertices of a (polytopic) Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/LazyOperations/CartesianProduct.jl#L225-L243">source</a></section><section><div><p>vertices_list(cpa::CartesianProductArray{N}) where {N}</p><p>Return the list of vertices of a (polytopic) Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/LazyOperations/CartesianProductArray.jl#L309-L328">source</a></section><section><div><pre><code class="language-none">vertices_list(em::ExponentialMap{N}) where {N}</code></pre><p>Return the list of vertices of a (polytopic) exponential map.</p><p><strong>Input</strong></p><ul><li><code>em</code> – exponential map</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying set <code>X</code> is polytopic. Then the result is just the exponential map applied to the vertices of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/LazyOperations/ExponentialMap.jl#L398-L415">source</a></section><section><div><pre><code class="language-none">vertices_list(ms::MinkowskiSum{N, Z1, Z2}) where {N, Z1&lt;:AbstractZonotope{N}, Z2&lt;:AbstractZonotope{N}}</code></pre><p>Return the list of vertices for the Minkowski sum of two zonotopic sets.</p><p><strong>Input</strong></p><ul><li><code>ms</code> – Minkowski sum of two zonotopic sets</li></ul><p><strong>Output</strong></p><p>The list of vertices of the Minkowski sum of two zonotopic sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/LazyOperations/MinkowskiSum.jl#L258-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isbounded" href="#LazySets.isbounded"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isbounded(P::AbstractHPolygon, [use_type_assumption]::Bool=true)</code></pre><p>Determine whether a polygon in constraint representation is bounded.</p><p><strong>Input</strong></p><ul><li><code>P</code>                   – polygon in constraint representation</li><li><code>use_type_assumption</code> – (optional, default: <code>true</code>) flag for ignoring the                          type assumption that polygons are bounded</li></ul><p><strong>Output</strong></p><p><code>true</code> if <code>use_type_assumption</code> is activated. Otherwise, <code>true</code> iff <code>P</code> is bounded.</p><p><strong>Algorithm</strong></p><p>If <code>!use_type_assumption</code>, we convert <code>P</code> to an <code>HPolyhedron</code> <code>P2</code> and then use <code>isbounded(P2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHPolygon.jl#L590-L610">source</a></section></article><h3 id="Implementations-6"><a class="docs-heading-anchor" href="#Implementations-6">Implementations</a><a class="docs-heading-anchor-permalink" href="#Implementations-6" title="Permalink"></a></h3><ul><li><a href="../sets/HPolygon/#def_HPolygon">Polygon in constraint representation (HPolygon)</a></li><li><a href="../sets/HPolygonOpt/#def_HPolygonOpt">Polygon in optimized constraint representation (HPolygonOpt)</a></li></ul><h2 id="def_AbstractCentrallySymmetricPolytope"><a class="docs-heading-anchor" href="#def_AbstractCentrallySymmetricPolytope">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a><a id="def_AbstractCentrallySymmetricPolytope-1"></a><a class="docs-heading-anchor-permalink" href="#def_AbstractCentrallySymmetricPolytope" title="Permalink"></a></h2><p>A centrally symmetric polytope is a combination of two other interfaces: <a href="#def_AbstractCentrallySymmetric">Centrally symmetric sets</a> and <a href="#def_AbstractPolytope">Polytope</a>.</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.AbstractCentrallySymmetricPolytope" href="#LazySets.AbstractCentrallySymmetricPolytope"><code>LazySets.AbstractCentrallySymmetricPolytope</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractCentrallySymmetricPolytope{N} &lt;: AbstractPolytope{N}</code></pre><p>Abstract type for centrally symmetric, polytopic sets. It combines the <code>AbstractCentrallySymmetric</code> and <code>AbstractPolytope</code> interfaces. Such a type combination is necessary as long as Julia does not support <a href="https://github.com/JuliaLang/julia/issues/5">multiple inheritance</a>.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractCentrallySymmetricPolytope</code> must define the following functions:</p><ul><li>from <code>AbstractCentrallySymmetric</code>:<ul><li><code>center(::AbstractCentrallySymmetricPolytope)</code> – return the center point</li></ul></li><li>from <code>AbstractPolytope</code>:<ul><li><code>vertices_list(::AbstractCentrallySymmetricPolytope)</code>  – return a list of all vertices</li></ul></li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractCentrallySymmetricPolytope)
2-element Array{Any,1}:
 AbstractZonotope
 Ball1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractCentrallySymmetricPolytope.jl#L8-L32">source</a></section></article><p>This interface defines the following functions:</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}" href="#LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dim(P::AbstractCentrallySymmetricPolytope)</code></pre><p>Return the ambient dimension of a centrally symmetric, polytopic set.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric, polytopic set</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polytopic set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractCentrallySymmetricPolytope.jl#L41-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.an_element-Tuple{AbstractCentrallySymmetricPolytope}" href="#LazySets.an_element-Tuple{AbstractCentrallySymmetricPolytope}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">an_element(P::AbstractCentrallySymmetricPolytope)</code></pre><p>Return some element of a centrally symmetric polytope.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric polytope</li></ul><p><strong>Output</strong></p><p>The center of the centrally symmetric polytope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractCentrallySymmetricPolytope.jl#L59-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}" href="#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isempty(P::AbstractCentrallySymmetricPolytope)</code></pre><p>Return if a centrally symmetric, polytopic set is empty or not.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric, polytopic set</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractCentrallySymmetricPolytope.jl#L76-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isuniversal-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}, Tuple{AbstractCentrallySymmetricPolytope{N},Bool}} where N" href="#LazySets.isuniversal-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}, Tuple{AbstractCentrallySymmetricPolytope{N},Bool}} where N"><code>LazySets.isuniversal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isuniversal(S::AbstractCentrallySymmetricPolytope{N},
            [witness]::Bool=false) where {N}</code></pre><p>Check whether a centrally symmetric polytope is universal.</p><p><strong>Input</strong></p><ul><li><code>S</code>       – centrally symmetric polytope</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>false</code></li><li>If <code>witness</code> option is activated: <code>(false, v)</code> where <span>$v ∉ S$</span></li></ul><p><strong>Algorithm</strong></p><p>A witness is obtained by computing the support vector in direction <code>d = [1, 0, …, 0]</code> and adding <code>d</code> on top.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractCentrallySymmetricPolytope.jl#L93-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.center-Tuple{AbstractCentrallySymmetricPolytope,Int64}" href="#LazySets.center-Tuple{AbstractCentrallySymmetricPolytope,Int64}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">center(S::AbstractCentrallySymmetricPolytope, i::Int)</code></pre><p>Return the center along a given dimension of a centrally symmetric polytope.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric polytope</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The center along a given dimension of the centrally symmetric polytope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractCentrallySymmetricPolytope.jl#L125-L138">source</a></section></article><h3 id="Implementations-7"><a class="docs-heading-anchor" href="#Implementations-7">Implementations</a><a class="docs-heading-anchor-permalink" href="#Implementations-7" title="Permalink"></a></h3><ul><li><a href="../sets/Ball1/#def_Ball1">Manhattan-norm ball (Ball1)</a></li></ul><h2 id="def_AbstractZonotope"><a class="docs-heading-anchor" href="#def_AbstractZonotope">Zonotopes (AbstractZonotope)</a><a id="def_AbstractZonotope-1"></a><a class="docs-heading-anchor-permalink" href="#def_AbstractZonotope" title="Permalink"></a></h2><p>A zonotope is a specific centrally symmetric polytope characterized by a center and a collection of generators.</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.AbstractZonotope" href="#LazySets.AbstractZonotope"><code>LazySets.AbstractZonotope</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractZonotope{N} &lt;: AbstractCentrallySymmetricPolytope{N}</code></pre><p>Abstract type for zonotopic sets.</p><p><strong>Notes</strong></p><p>Mathematically, a zonotope is defined as the set</p><p class="math-container">\[Z = \left\{ c + ∑_{i=1}^p ξ_i g_i,~~ ξ_i \in [-1, 1]~~ ∀ i = 1,…, p \right\},\]</p><p>where <span>$c \in \mathbb{R}^n$</span> is its center and <span>$\{g_i\}_{i=1}^p$</span>, <span>$g_i \in \mathbb{R}^n$</span>, is the set of generators. This characterization defines a zonotope as the finite Minkowski sum of line segments. Zonotopes can be equivalently described as the image of a unit infinity-norm ball in <span>$\mathbb{R}^n$</span> by an affine transformation.</p><p>See <a href="../sets/Zonotope/#LazySets.Zonotope"><code>Zonotope</code></a> for a standard implementation of this interface.</p><p>Every concrete <code>AbstractZonotope</code> must define the following functions:</p><ul><li><code>genmat(::AbstractZonotope{N})</code> – return the generator matrix</li><li><code>generators(::AbstractZonotope{N})</code> – return an iterator over the generators</li></ul><p>Since the functions <code>genmat</code> and <code>generators</code> can be defined in terms of each other, it is sufficient to only genuinely implement one of them and let the implementation of the other function call the fallback implementation <code>genmat_fallback</code> resp. <code>generators_fallback</code>.</p><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractZonotope)
4-element Array{Any,1}:
 AbstractHyperrectangle
 HParallelotope
 LineSegment
 Zonotope</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractZonotope.jl#L13-L51">source</a></section></article><p>This interface defines the following functions:</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.ngens-Tuple{AbstractZonotope}" href="#LazySets.ngens-Tuple{AbstractZonotope}"><code>LazySets.ngens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ngens(Z::AbstractZonotope)</code></pre><p>Return the number of generators of a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>An integer representing the number of generators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractZonotope.jl#L184-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.genmat_fallback-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N" href="#LazySets.genmat_fallback-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N"><code>LazySets.genmat_fallback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">genmat_fallback(Z::AbstractZonotope{N};
                [gens]=generators(Z),
                [ngens]=nothing) where {N}</code></pre><p>Fallback definition of <code>genmat</code> for zonotopic sets.</p><p><strong>Input</strong></p><ul><li><code>Z</code>     – zonotopic set</li><li><code>gens</code>  – (optional; default: <code>generators(Z)</code>) iterator over generators</li><li><code>ngens</code> – (optional; default: <code>nothing</code>) number of generators or <code>nothing</code> if            unknown</li></ul><p><strong>Output</strong></p><p>A matrix where each column represents one generator of <code>Z</code>.</p><p><strong>Notes</strong></p><p>Passing the number of generators is much more efficient as otherwise the generators have to be obtained from the iterator (<code>gens</code>) and stored in an intermediate vector until the final result matrix can be allocated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractZonotope.jl#L59-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.generators_fallback-Tuple{AbstractZonotope}" href="#LazySets.generators_fallback-Tuple{AbstractZonotope}"><code>LazySets.generators_fallback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generators_fallback(Z::AbstractZonotope)</code></pre><p>Fallback definition of <code>generators</code> for zonotopic sets.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>An iterator over the generators of <code>Z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractZonotope.jl#L144-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.ρ-Tuple{AbstractArray{T,1} where T,AbstractZonotope}" href="#LazySets.ρ-Tuple{AbstractArray{T,1} where T,AbstractZonotope}"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ρ(d::AbstractVector, Z::AbstractZonotope)</code></pre><p>Return the support function of a zonotopic set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>The support function of the zonotopic set in the given direction.</p><p><strong>Algorithm</strong></p><p>The support value is <span>$cᵀ d + ‖Gᵀ d‖₁$</span> where <span>$c$</span> is the center and <span>$G$</span> is the generator matrix of <code>Z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractZonotope.jl#L227-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{T,1} where T,AbstractZonotope}" href="#LazySets.σ-Tuple{AbstractArray{T,1} where T,AbstractZonotope}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">σ(d::AbstractVector, Z::AbstractZonotope)</code></pre><p>Return the support vector of a zonotopic set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction. If the direction has norm zero, the vertex with <span>$ξ_i = 1 \ \ ∀ i = 1,…, p$</span> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractZonotope.jl#L252-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{T,1} where T,AbstractZonotope}" href="#Base.:∈-Tuple{AbstractArray{T,1} where T,AbstractZonotope}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∈(x::AbstractVector, Z::AbstractZonotope; solver=nothing)</code></pre><p>Check whether a given point is contained in a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>x</code>      – point/vector</li><li><code>Z</code>      – zonotopic set</li><li><code>solver</code> – (optional, default: <code>nothing</code>) the backend used to solve the             linear program</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ Z$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Z = Zonotope([1.0, 0.0], [0.1 0.0; 0.0 0.1]);

julia&gt; [1.0, 0.2] ∈ Z
false
julia&gt; [1.0, 0.1] ∈ Z
true</code></pre><p><strong>Notes</strong></p><p>If <code>solver == nothing</code>, we fall back to <code>default_lp_solver(N)</code>.</p><p><strong>Algorithm</strong></p><p>The membership problem is computed by stating and solving the following linear program. Let <span>$p$</span> and <span>$n$</span> be the number of generators and ambient dimension, respectively. We consider the minimization of <span>$x_0$</span> in the <span>$p+1$</span>-dimensional space of elements <span>$(x_0, ξ_1, …, ξ_p)$</span> constrained to <span>$0 ≤ x_0 ≤ ∞$</span>, <span>$ξ_i ∈ [-1, 1]$</span> for all <span>$i = 1, …, p$</span>, and such that <span>$x-c = Gξ$</span> holds. If a feasible solution exists, the optimal value <span>$x_0 = 0$</span> is achieved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractZonotope.jl#L273-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.linear_map-Tuple{AbstractArray{T,2} where T,AbstractZonotope}" href="#LazySets.linear_map-Tuple{AbstractArray{T,2} where T,AbstractZonotope}"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">linear_map(M::AbstractMatrix, Z::AbstractZonotope)</code></pre><p>Concrete linear map of a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>The zonotope obtained by applying the linear map to the center and generators of <span>$Z$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractZonotope.jl#L335-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.translate-Tuple{AbstractZonotope,AbstractArray{T,1} where T}" href="#LazySets.translate-Tuple{AbstractZonotope,AbstractArray{T,1} where T}"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">translate(Z::AbstractZonotope, v::AbstractVector)</code></pre><p>Translate (i.e., shift) a zonotope by a given vector.</p><p><strong>Input</strong></p><ul><li><code>Z</code>     – zonotope</li><li><code>v</code>     – translation vector</li></ul><p><strong>Output</strong></p><p>A translated zonotope.</p><p><strong>Notes</strong></p><p>See also <a href="#LazySets.translate!-Tuple{AbstractZonotope,AbstractArray{T,1} where T}"><code>translate!(Z::AbstractZonotope, v::AbstractVector)</code></a> for the in-place version.</p><p><strong>Algorithm</strong></p><p>We add the translation vector to the center of the zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractZonotope.jl#L359-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.translate!-Tuple{AbstractZonotope,AbstractArray{T,1} where T}" href="#LazySets.translate!-Tuple{AbstractZonotope,AbstractArray{T,1} where T}"><code>LazySets.translate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">translate!(Z::AbstractZonotope, v::AbstractVector)</code></pre><p>Translate (i.e., shift) a zonotope by a given vector in-place.</p><p><strong>Input</strong></p><ul><li><code>Z</code>     – zonotope</li><li><code>v</code>     – translation vector</li></ul><p><strong>Output</strong></p><p>A translated zonotope.</p><p><strong>Notes</strong></p><p>See also <a href="#LazySets.translate-Tuple{AbstractZonotope,AbstractArray{T,1} where T}"><code>translate(Z::AbstractZonotope, v::AbstractVector)</code></a> for the out-of-place version.</p><p><strong>Algorithm</strong></p><p>We add the translation vector to the center of the zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractZonotope.jl#L386-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.constraints_list-Tuple{AbstractZonotope}" href="#LazySets.constraints_list-Tuple{AbstractZonotope}"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraints_list(P::AbstractZonotope)</code></pre><p>Return the list of constraints defining a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>The list of constraints of the zonotopic set.</p><p><strong>Algorithm</strong></p><p>This is the (inefficient) fallback implementation for rational numbers. It first computes the vertices and then converts the corresponding polytope to constraint representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractZonotope.jl#L487-L505">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N&lt;:AbstractFloat" href="#LazySets.constraints_list-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N&lt;:AbstractFloat"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraints_list(Z::AbstractZonotope{N}; check_full_rank::Bool=true) where {N&lt;:AbstractFloat}</code></pre><p>Return the list of constraints defining a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code>               – zonotopic set</li><li><code>check_full_rank</code> – (optional; default: <code>true</code>) flag for checking whether the                      generator matrix has full rank</li></ul><p><strong>Output</strong></p><p>The list of constraints of the zonotopic set.</p><p><strong>Notes</strong></p><p>The algorithm assumes that no generator is redundant. The result has <span>$2 \binom{p}{n-1}$</span> (with <span>$p$</span> being the number of generators and <span>$n$</span> being the ambient dimension) constraints, which is optimal under this assumption.</p><p>If <span>$p &lt; n$</span> or the generator matrix is not full rank, we fall back to the (slower) computation based on the vertex representation.</p><p><strong>Algorithm</strong></p><p>We follow the algorithm presented in <em>Althoff, Stursberg, Buss: Computing Reachable Sets of Hybrid Systems Using a Combination of Zonotopes and Polytopes. 2009.</em></p><p>The one-dimensional case is not covered by that algorithm; we manually handle this case, assuming that there is only one generator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractZonotope.jl#L512-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.vertices_list-Tuple{AbstractZonotope}" href="#LazySets.vertices_list-Tuple{AbstractZonotope}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertices_list(Z::AbstractZonotope; [apply_convex_hull]::Bool=true)</code></pre><p>Return the vertices of a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code>                 – zonotopic set</li><li><code>apply_convex_hull</code> – (optional, default: <code>true</code>) if <code>true</code>, post-process the                        computation with the convex hull of the points</li></ul><p><strong>Output</strong></p><p>List of vertices as a vector of vectors.</p><p><strong>Algorithm</strong></p><p><strong>Two-dimensional case</strong></p><p>We use a trick to speed up enumerating vertices of 2-dimensional zonotopic sets with all generators in the first quadrant or third quadrant (same sign). Namely, sort the generators in angle and add them clockwise in increasing order and anticlockwise in decreasing order, the algorithm detail: https://math.stackexchange.com/q/3356460</p><p>To avoid cumulative sum from both directions separately, we build a 2d index matrix to sum generators for both directions in one matrix-vector product.</p><p><strong>General case</strong></p><p>If the zonotopic set has <span>$p$</span> generators, each vertex is the result of summing the center with some linear combination of generators, where the combination factors are <span>$ξ_i ∈ \{-1, 1\}$</span>.</p><p>There are at most <span>$2^p$</span> distinct vertices. Use the flag <code>apply_convex_hull</code> to control whether a convex hull algorithm is applied to the vertices computed by this method; otherwise, redundant vertices may be present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractZonotope.jl#L421-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.order-Tuple{AbstractZonotope}" href="#LazySets.order-Tuple{AbstractZonotope}"><code>LazySets.order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">order(Z::AbstractZonotope)</code></pre><p>Return the order of a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotope</li></ul><p><strong>Output</strong></p><p>A rational number representing the order of the zonotope.</p><p><strong>Notes</strong></p><p>The order of a zonotope is defined as the quotient of its number of generators and its dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractZonotope.jl#L201-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.togrep-Tuple{AbstractZonotope}" href="#LazySets.togrep-Tuple{AbstractZonotope}"><code>LazySets.togrep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">togrep(Z::AbstractZonotope)</code></pre><p>Return a generator representation of a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>The same set in generator representation. This fallback implementation returns a <code>Zonotope</code>; however, more specific implementations may return other generator representations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractZonotope.jl#L161-L175">source</a></section></article><h3 id="Implementations-8"><a class="docs-heading-anchor" href="#Implementations-8">Implementations</a><a class="docs-heading-anchor-permalink" href="#Implementations-8" title="Permalink"></a></h3><ul><li><a href="../sets/Zonotope/#def_Zonotope">Zonotope</a></li><li><a href="../sets/LineSegment/#def_LineSegment">Line segment (LineSegment)</a></li></ul><h2 id="def_AbstractHyperrectangle"><a class="docs-heading-anchor" href="#def_AbstractHyperrectangle">Hyperrectangles (AbstractHyperrectangle)</a><a id="def_AbstractHyperrectangle-1"></a><a class="docs-heading-anchor-permalink" href="#def_AbstractHyperrectangle" title="Permalink"></a></h2><p>A hyperrectangle is a special centrally symmetric polytope with axis-aligned facets.</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.AbstractHyperrectangle" href="#LazySets.AbstractHyperrectangle"><code>LazySets.AbstractHyperrectangle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractHyperrectangle{N} &lt;: AbstractZonotope{N}</code></pre><p>Abstract type for hyperrectangular sets.</p><p><strong>Notes</strong></p><p>See <a href="../sets/Hyperrectangle/#LazySets.Hyperrectangle"><code>Hyperrectangle</code></a> for a standard implementation of this interface.</p><p>Every concrete <code>AbstractHyperrectangle</code> must define the following functions:</p><ul><li><p><code>radius_hyperrectangle(::AbstractHyperrectangle)</code> – return the   hyperrectangle&#39;s radius, which is a full-dimensional vector</p></li><li><p><code>radius_hyperrectangle(::AbstractHyperrectangle, i::Int)</code> – return the   hyperrectangle&#39;s radius in the <code>i</code>-th dimension</p></li><li><p><code>isflat(::AbstractHyperrectangle)</code> – determine whether the   hyperrectangle&#39;s radius is zero in some dimension</p></li></ul><p>Every hyperrectangular set is also a zonotopic set; see <a href="#LazySets.AbstractZonotope"><code>AbstractZonotope</code></a>.</p><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractHyperrectangle)
5-element Array{Any,1}:
 AbstractSingleton
 BallInf
 Hyperrectangle
 Interval
 SymmetricIntervalHull</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L12-L43">source</a></section></article><p>This interface defines the following functions:</p><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">norm(H::AbstractHyperrectangle, [p]::Real=Inf)</code></pre><p>Return the norm of a hyperrectangular set.</p><p>The norm of a hyperrectangular set is defined as the norm of the enclosing ball, of the given <span>$p$</span>-norm, of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p><p><strong>Algorithm</strong></p><p>Recall that the norm is defined as</p><p class="math-container">\[‖ X ‖ = \max_{x ∈ X} ‖ x ‖_p = max_{x ∈ \text{vertices}(X)} ‖ x ‖_p.\]</p><p>The last equality holds because the optimum of a convex function over a polytope is attained at one of its vertices.</p><p>This implementation uses the fact that the maximum is achieved in the vertex <span>$c + \text{diag}(\text{sign}(c)) r$</span>, for any <span>$p$</span>-norm, hence it suffices to take the <span>$p$</span>-norm of this particular vertex. This statement is proved below. Note that, in particular, there is no need to compute the <span>$p$</span>-norm for <em>each</em> vertex, which can be very expensive.</p><p>If <span>$X$</span> is an axis-aligned hyperrectangle and the <span>$n$</span>-dimensional vectors center and radius of the hyperrectangle are denoted <span>$c$</span> and <span>$r$</span> respectively, then reasoning on the <span>$2^n$</span> vertices we have that:</p><p class="math-container">\[\max_{x ∈ \text{vertices}(X)} ‖ x ‖_p = \max_{α_1, …, α_n ∈ \{-1, 1\}} (|c_1 + α_1 r_1|^p + ... + |c_n + α_n r_n|^p)^{1/p}.\]</p><p>The function <span>$x ↦ x^p$</span>, <span>$p &gt; 0$</span>, is monotonically increasing and thus the maximum of each term <span>$|c_i + α_i r_i|^p$</span> is given by <span>$|c_i + \text{sign}(c_i) r_i|^p$</span> for each <span>$i$</span>. Hence, <span>$x^* := \text{argmax}_{x ∈ X} ‖ x ‖_p$</span> is the vertex <span>$c + \text{diag}(\text{sign}(c)) r$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L337-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.radius" href="#LazySets.radius"><code>LazySets.radius</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">radius(H::AbstractHyperrectangle, [p]::Real=Inf)</code></pre><p>Return the radius of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p><p><strong>Notes</strong></p><p>The radius is defined as the radius of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center. It is the same for all corners of a hyperrectangular set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L388-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{T,1} where T,AbstractHyperrectangle}" href="#LazySets.σ-Tuple{AbstractArray{T,1} where T,AbstractHyperrectangle}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">σ(d::AbstractVector, H::AbstractHyperrectangle)</code></pre><p>Return the support vector of a hyperrectangular set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the vertex with biggest values is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L260-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.ρ-Tuple{AbstractArray{T,1} where T,AbstractHyperrectangle}" href="#LazySets.ρ-Tuple{AbstractArray{T,1} where T,AbstractHyperrectangle}"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ρ(d::AbstractVector, H::AbstractHyperrectangle)</code></pre><p>Evaluate the support function of a hyperrectangular set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>Evaluation of the support function in the given direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L297-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{T,1} where T,AbstractHyperrectangle}" href="#Base.:∈-Tuple{AbstractArray{T,1} where T,AbstractHyperrectangle}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∈(x::AbstractVector, H::AbstractHyperrectangle)</code></pre><p>Check whether a given point is contained in a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ H$</span>.</p><p><strong>Algorithm</strong></p><p>Let <span>$H$</span> be an <span>$n$</span>-dimensional hyperrectangular set, <span>$c_i$</span> and <span>$r_i$</span> be the box&#39;s center and radius and <span>$x_i$</span> be the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ H$</span> iff <span>$|c_i - x_i| ≤ r_i$</span> for all <span>$i=1,…,n$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L412-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.vertices_list-Tuple{AbstractHyperrectangle}" href="#LazySets.vertices_list-Tuple{AbstractHyperrectangle}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertices_list(H::AbstractHyperrectangle)</code></pre><p>Return the list of vertices of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A list of vertices. Zeros in the radius are correctly handled, i.e., the result does not contain any duplicate vertices.</p><p><strong>Notes</strong></p><p>For high dimensions, it is preferable to develop a <code>vertex_iterator</code> approach.</p><p><strong>Algorithm</strong></p><p>First we identify the dimensions where <code>H</code> is flat, i.e., its radius is zero. We also compute the number of vertices that we have to create.</p><p>Next we create the vertices. We do this by enumerating all vectors <code>v</code> of length <code>n</code> (the dimension of <code>H</code>) with entries <code>-1</code>/<code>0</code>/<code>1</code> and construct the corresponding vertex as follows:</p><p class="math-container">\[    \text{vertex}(v)(i) = \begin{cases} c(i) + r(i) &amp; v(i) = 1 \\
                                          c(i) &amp; v(i) = 0 \\
                                          c(i) - r(i) &amp; v(i) = -1. \end{cases}\]</p><p>For enumerating the vectors <code>v</code>, we modify the current <code>v</code> from left to right by changing entries <code>-1</code> to <code>1</code>, skipping entries <code>0</code>, and stopping at the first entry <code>1</code> (but changing it to <code>-1</code>). This way we only need to change the vertex in those dimensions where <code>v</code> has changed, which usually is a smaller number than <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L148-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N" href="#LazySets.constraints_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraints_list(H::AbstractHyperrectangle{N}) where {N}</code></pre><p>Return the list of constraints of an axis-aligned hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A list of linear constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L231-L243">source</a></section><section><div><pre><code class="language-none">constraints_list(P::Ball1{N}) where {N}</code></pre><p>Return the list of constraints defining a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the 1-norm</li></ul><p><strong>Output</strong></p><p>The list of constraints of the ball.</p><p><strong>Algorithm</strong></p><p>The constraints can be defined as <span>$d_i^T (x-c) ≤ r$</span> for all <span>$d_i$</span>, where <span>$d_i$</span> is a vector with elements <span>$1$</span> or <span>$-1$</span> in <span>$n$</span> dimensions. To span all possible <span>$d_i$</span>, the function <code>Iterators.product</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Sets/Ball1.jl#L234-L252">source</a></section><section><div><pre><code class="language-none">constraints_list(x::Interval{N}) where {N}</code></pre><p>Return the list of constraints of the given interval.</p><p><strong>Input</strong></p><ul><li><code>x</code> – interval</li></ul><p><strong>Output</strong></p><p>The list of constraints of the interval represented as two one-dimensional half-spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Sets/Interval.jl#L393-L406">source</a></section><section><div><pre><code class="language-none">constraints_list(L::Line{N, VN}) where {N, VN}</code></pre><p>Return the list of constraints of a line.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line</li></ul><p><strong>Output</strong></p><p>A list containing <code>2n-2</code> half-spaces whose intersection is <code>L</code>, where <code>n</code> is the ambient dimension of <code>L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Sets/Line.jl#L191-L204">source</a></section><section><div><pre><code class="language-none">constraints_list(U::Universe{N}) where {N}</code></pre><p>Return the list of constraints defining a universe.</p><p><strong>Input</strong></p><ul><li><code>U</code> – universe</li></ul><p><strong>Output</strong></p><p>The empty list of constraints, as the universe is unconstrained.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Sets/Universe.jl#L42-L54">source</a></section><section><div><pre><code class="language-none">constraints_list(P::HParallelotope{N, VN}) where {N, VN}</code></pre><p>Return the list of constraints of the given parallelotope.</p><p><strong>Input</strong></p><ul><li><code>P</code> – parallelotope in constraint representation</li></ul><p><strong>Output</strong></p><p>The list of constraints of <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Sets/HParallelotope.jl#L289-L301">source</a></section><section><div><p>constraints_list(cpa::CartesianProductArray{N}) where {N}</p><p>Return the list of constraints of a (polyhedral) Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A list of constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/LazyOperations/CartesianProductArray.jl#L274-L287">source</a></section><section><div><pre><code class="language-none">constraints_list(ia::IntersectionArray{N}) where {N}</code></pre><p>Return the list of constraints of an intersection of a finite number of (polyhedral) sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of (polyhedral) sets</li></ul><p><strong>Output</strong></p><p>The list of constraints of the intersection.</p><p><strong>Notes</strong></p><p>We assume that the underlying sets are polyhedral, i.e., offer a method <code>constraints_list</code>.</p><p><strong>Algorithm</strong></p><p>We create the polyhedron from the <code>constraints_list</code>s of the sets and remove redundant constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/LazyOperations/IntersectionArray.jl#L161-L184">source</a></section><section><div><pre><code class="language-none">constraints_list(rm::ResetMap{N}) where {N}</code></pre><p>Return the list of constraints of a polytopic reset map.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map of a polytope</li></ul><p><strong>Output</strong></p><p>The list of constraints of the reset map.</p><p><strong>Notes</strong></p><p>We assume that the underlying set <code>X</code> is a polytope, i.e., is bounded and offers a method <code>constraints_list(X)</code>.</p><p><strong>Algorithm</strong></p><p>We fall back to <code>constraints_list</code> of a <code>LinearMap</code> of the <code>A</code>-matrix in the affine-map view of a reset map. Each reset dimension <span>$i$</span> is projected to zero, expressed by two constraints for each reset dimension. Then it remains to shift these constraints to the new value.</p><p>For instance, if the dimension <span>$5$</span> was reset to <span>$4$</span>, then there will be constraints <span>$x₅ ≤ 0$</span> and <span>$-x₅ ≤ 0$</span>. We then modify the right-hand side of these constraints to <span>$x₅ ≤ 4$</span> and <span>$-x₅ ≤ -4$</span>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/LazyOperations/ResetMap.jl#L257-L287">source</a></section><section><div><pre><code class="language-none">constraints_list(rm::ResetMap{N, S}) where {N, S&lt;:AbstractHyperrectangle}</code></pre><p>Return the list of constraints of a hyperrectangular reset map.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map of a hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The list of constraints of the reset map.</p><p><strong>Algorithm</strong></p><p>We iterate through all dimensions. If there is a reset, we construct the corresponding (flat) constraints. Otherwise, we construct the corresponding constraints of the underlying set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/LazyOperations/ResetMap.jl#L329-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.high-Tuple{AbstractHyperrectangle}" href="#LazySets.high-Tuple{AbstractHyperrectangle}"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">high(H::AbstractHyperrectangle)</code></pre><p>Return the higher coordinates of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A vector with the higher coordinates of the hyperrectangular set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L446-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.high-Tuple{AbstractHyperrectangle,Int64}" href="#LazySets.high-Tuple{AbstractHyperrectangle,Int64}"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">high(H::AbstractHyperrectangle, i::Int)</code></pre><p>Return the higher coordinate of a hyperrectangular set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The higher coordinate of the hyperrectangular set in the given dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L463-L476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.low-Tuple{AbstractHyperrectangle}" href="#LazySets.low-Tuple{AbstractHyperrectangle}"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">low(H::AbstractHyperrectangle)</code></pre><p>Return the lower coordinates of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A vector with the lower coordinates of the hyperrectangular set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L481-L493">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.low-Tuple{AbstractHyperrectangle,Int64}" href="#LazySets.low-Tuple{AbstractHyperrectangle,Int64}"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">low(H::AbstractHyperrectangle, i::Int)</code></pre><p>Return the lower coordinate of a hyperrectangular set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The lower coordinate of the hyperrectangular set in the given dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L498-L511">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isflat-Tuple{AbstractHyperrectangle}" href="#LazySets.isflat-Tuple{AbstractHyperrectangle}"><code>LazySets.isflat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isflat(H::AbstractHyperrectangle)</code></pre><p>Determine whether a hyperrectangular set is flat, i.e. whether its radius is zero in some dimension.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the hyperrectangular set is flat.</p><p><strong>Notes</strong></p><p>For robustness with respect to floating-point inputs, this function relies on the result of <code>isapproxzero</code> when applied to the radius in some dimension. Hence, this function depends on the absolute zero tolerance <code>ABSZTOL</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L516-L535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.split-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractArray{Int64,1}}} where N" href="#Base.split-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractArray{Int64,1}}} where N"><code>Base.split</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">split(H::AbstractHyperrectangle{N}, num_blocks::AbstractVector{Int}
     ) where {N}</code></pre><p>Partition a hyperrectangular set into uniform sub-hyperrectangles.</p><p><strong>Input</strong></p><ul><li><code>H</code>          – hyperrectangular set</li><li><code>num_blocks</code> – number of blocks in the partition for each dimension</li></ul><p><strong>Output</strong></p><p>A list of <code>Hyperrectangle</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L540-L554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.generators-Tuple{AbstractHyperrectangle}" href="#LazySets.generators-Tuple{AbstractHyperrectangle}"><code>LazySets.generators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generators(H::AbstractHyperrectangle)</code></pre><p>Return an iterator over the generators of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>An iterator over the generators of <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L106-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.genmat-Tuple{AbstractHyperrectangle}" href="#LazySets.genmat-Tuple{AbstractHyperrectangle}"><code>LazySets.genmat</code></a> — <span class="docstring-category">Method</span></header><section><div><p>genmat(H::AbstractHyperrectangle)</p><p>Return the generator matrix of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A matrix where each column represents one generator of <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L51-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.ngens-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N" href="#LazySets.ngens-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N"><code>LazySets.ngens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ngens(H::AbstractHyperrectangle{N}) where {N}</code></pre><p>Return the number of generators of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The number of generators.</p><p><strong>Algorithm</strong></p><p>A hyperrectangular set has one generator for each non-flat dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L123-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Arrays.rectify-Tuple{AbstractHyperrectangle}" href="#LazySets.Arrays.rectify-Tuple{AbstractHyperrectangle}"><code>LazySets.Arrays.rectify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rectify(H::AbstractHyperrectangle)</code></pre><p>Concrete rectification of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The <code>Hyperrectangle</code> that corresponds to the rectification of <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L588-L600">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.volume-Tuple{AbstractHyperrectangle}" href="#LazySets.volume-Tuple{AbstractHyperrectangle}"><code>LazySets.volume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">volume(H::AbstractHyperrectangle)</code></pre><p>Return the volume of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The volume of <span>$H$</span>.</p><p><strong>Algorithm</strong></p><p>The volume of the <span>$n$</span>-dimensional hyperrectangle <span>$H$</span> with vector radius <span>$r$</span> is <span>$2ⁿ ∏ᵢ rᵢ$</span> where <span>$rᵢ$</span> denotes the <span>$i$</span>-th component of <span>$r$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractHyperrectangle.jl#L605-L622">source</a></section></article><h3 id="Implementations-9"><a class="docs-heading-anchor" href="#Implementations-9">Implementations</a><a class="docs-heading-anchor-permalink" href="#Implementations-9" title="Permalink"></a></h3><p>Concrete set representations:</p><ul><li><a href="../sets/Hyperrectangle/#def_Hyperrectangle">Hyperrectangle</a></li><li><a href="../sets/BallInf/#def_BallInf">Infinity-norm ball (BallInf)</a></li><li><a href="../sets/Interval/#def_Interval">Interval</a></li></ul><p>Lazy set operations:</p><ul><li><a href="../lazy_operations/SymmetricIntervalHull/#def_SymmetricIntervalHull">Symmetric interval hull (SymmetricIntervalHull)</a></li></ul><h2 id="def_AbstractSingleton"><a class="docs-heading-anchor" href="#def_AbstractSingleton">Singletons (AbstractSingleton)</a><a id="def_AbstractSingleton-1"></a><a class="docs-heading-anchor-permalink" href="#def_AbstractSingleton" title="Permalink"></a></h2><p>A singleton is a special hyperrectangle consisting of only one point.</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.AbstractSingleton" href="#LazySets.AbstractSingleton"><code>LazySets.AbstractSingleton</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractSingleton{N} &lt;: AbstractHyperrectangle{N}</code></pre><p>Abstract type for sets with a single value.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractSingleton</code> must define the following functions:</p><ul><li><code>element(::AbstractSingleton{N})</code> – return the single element</li><li><code>element(::AbstractSingleton{N}, i::Int)</code> – return the single element&#39;s   entry in the <code>i</code>-th dimension</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractSingleton)
2-element Array{Any,1}:
 Singleton
 ZeroSet</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractSingleton.jl#L8-L26">source</a></section></article><p>This interface defines the following functions:</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{T,1} where T,AbstractSingleton}" href="#LazySets.σ-Tuple{AbstractArray{T,1} where T,AbstractSingleton}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">σ(d::AbstractVector, S::AbstractSingleton)</code></pre><p>Return the support vector of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The support vector, which is the set&#39;s vector itself, irrespective of the given direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractSingleton.jl#L287-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.ρ-Tuple{AbstractArray{T,1} where T,AbstractSingleton}" href="#LazySets.ρ-Tuple{AbstractArray{T,1} where T,AbstractSingleton}"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ρ(d::AbstractVector, S::AbstractSingleton)</code></pre><p>Evaluate the support function of a set with a single value in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>Evaluation of the support function in the given direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractSingleton.jl#L306-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{T,1} where T,AbstractSingleton}" href="#Base.:∈-Tuple{AbstractArray{T,1} where T,AbstractSingleton}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∈(x::AbstractVector, S::AbstractSingleton)</code></pre><p>Check whether a given point is contained in a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ S$</span>.</p><p><strong>Notes</strong></p><p>This implementation performs an exact comparison, which may be insufficient with floating point computations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractSingleton.jl#L324-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.center-Tuple{AbstractSingleton}" href="#LazySets.center-Tuple{AbstractSingleton}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">center(S::AbstractSingleton)</code></pre><p>Return the center of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The only element of the set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractSingleton.jl#L206-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.vertices-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N" href="#LazySets.vertices-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N"><code>LazySets.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertices(S::AbstractSingleton{N}) where {N}</code></pre><p>Construct an iterator over the vertices of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>An iterator with a single value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractSingleton.jl#L227-L239">source</a></section><section><div><pre><code class="language-none">vertices(∅::EmptySet{N}) where {N}</code></pre><p>Construct an iterator over the vertices of an empty set.</p><p><strong>Input</strong></p><ul><li><code>∅</code> – empty set</li></ul><p><strong>Output</strong></p><p>The empty iterator, as the empty set does not contain any vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Sets/EmptySet.jl#L276-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.vertices_list-Tuple{AbstractSingleton}" href="#LazySets.vertices_list-Tuple{AbstractSingleton}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertices_list(S::AbstractSingleton)</code></pre><p>Return the list of vertices of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A list containing only a single vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractSingleton.jl#L244-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N" href="#LazySets.radius_hyperrectangle-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">radius_hyperrectangle(S::AbstractSingleton{N}) where {N}</code></pre><p>Return the box radius of a set with a single value in every dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The zero vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractSingleton.jl#L53-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N" href="#LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">radius_hyperrectangle(S::AbstractSingleton{N}, i::Int) where {N}</code></pre><p>Return the box radius of a set with a single value in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>Zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractSingleton.jl#L34-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.high-Tuple{AbstractSingleton}" href="#LazySets.high-Tuple{AbstractSingleton}"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">high(S::AbstractSingleton)</code></pre><p>Return the higher coordinates of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A vector with the higher coordinates of the set with a single value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractSingleton.jl#L71-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.high-Tuple{AbstractSingleton,Int64}" href="#LazySets.high-Tuple{AbstractSingleton,Int64}"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">high(S::AbstractSingleton, i::Int)</code></pre><p>Return the higher coordinate of a set with a single value in the given dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The higher coordinate of the set with a single value in the given dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractSingleton.jl#L88-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.low-Tuple{AbstractSingleton}" href="#LazySets.low-Tuple{AbstractSingleton}"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">low(S::AbstractSingleton)</code></pre><p>Return the lower coordinates of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A vector with the lower coordinates of the set with a single value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractSingleton.jl#L107-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.low-Tuple{AbstractSingleton,Int64}" href="#LazySets.low-Tuple{AbstractSingleton,Int64}"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">low(S::AbstractSingleton, i::Int)</code></pre><p>Return the lower coordinate of a set with a single value in the given dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The lower coordinate of the set with a single value in the given dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractSingleton.jl#L124-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.linear_map-Tuple{AbstractArray{T,2} where T,AbstractSingleton}" href="#LazySets.linear_map-Tuple{AbstractArray{T,2} where T,AbstractSingleton}"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">linear_map(M::AbstractMatrix, S::AbstractSingleton)</code></pre><p>Concrete linear map of an abstract singleton.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>S</code> – abstract singleton</li></ul><p><strong>Output</strong></p><p>The abstract singleton of the same type of <span>$S$</span> obtained by applying the linear map to the element in <span>$S$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractSingleton.jl#L261-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.generators-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N" href="#LazySets.generators-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N"><code>LazySets.generators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generators(S::AbstractSingleton{N}) where {N}</code></pre><p>Return an (empty) iterator over the generators of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>An empty iterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractSingleton.jl#L164-L176">source</a></section><section><div><pre><code class="language-none">generators(L::LineSegment{N}) where {N}</code></pre><p>Return an iterator over the (single) generator of a line segment.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line segment</li></ul><p><strong>Output</strong></p><p>A one-element iterator over the generator of <code>L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Sets/LineSegment.jl#L218-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.genmat-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N" href="#LazySets.genmat-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N"><code>LazySets.genmat</code></a> — <span class="docstring-category">Method</span></header><section><div><p>genmat(S::AbstractSingleton{N}) where {N}</p><p>Return the (empty) generator matrix of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A matrix with no columns representing the generators of <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractSingleton.jl#L147-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.ngens-Tuple{AbstractSingleton}" href="#LazySets.ngens-Tuple{AbstractSingleton}"><code>LazySets.ngens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ngens(S::AbstractSingleton)</code></pre><p>Return the number of generators of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>H</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The number of generators.</p><p><strong>Algorithm</strong></p><p>A set with a single value has no generators, so the result is <span>$0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractSingleton.jl#L181-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.plot_recipe-Union{Tuple{AbstractSingleton{N}}, Tuple{N}, Tuple{AbstractSingleton{N},Any}} where N" href="#LazySets.plot_recipe-Union{Tuple{AbstractSingleton{N}}, Tuple{N}, Tuple{AbstractSingleton{N},Any}} where N"><code>LazySets.plot_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_recipe(S::AbstractSingleton{N}, [ε]=zero(N)) where {N}</code></pre><p>Convert a singleton to a pair <code>(x, y)</code> of points for plotting.</p><p><strong>Input</strong></p><ul><li><code>S</code> – singleton</li><li><code>ε</code> – (optional, default: <code>0</code>) ignored, used for dispatch</li></ul><p><strong>Output</strong></p><p>A pair <code>(x, y)</code> of one point that can be plotted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractSingleton.jl#L355-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol,Any},AbstractSingleton{N}}, Tuple{AbstractDict{Symbol,Any},AbstractSingleton{N},N}} where N" href="#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol,Any},AbstractSingleton{N}}, Tuple{AbstractDict{Symbol,Any},AbstractSingleton{N},N}} where N"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_singleton(S::AbstractSingleton{N}, [ε]::N=zero(N); ...) where {N}</code></pre><p>Plot a singleton.</p><p><strong>Input</strong></p><ul><li><code>S</code> – singleton</li><li><code>ε</code> – (optional, default: <code>0</code>) ignored, used for dispatch</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; plot(Singleton([0.5, 1.0]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Plotting/plot_recipes.jl#L350-L365">source</a></section></article><h3 id="Implementations-10"><a class="docs-heading-anchor" href="#Implementations-10">Implementations</a><a class="docs-heading-anchor-permalink" href="#Implementations-10" title="Permalink"></a></h3><ul><li><a href="../sets/Singleton/#def_Singleton">Singleton</a></li><li><a href="../sets/ZeroSet/#def_ZeroSet">Origin (ZeroSet)</a></li></ul><h2 id="def_AbstractAffineMap"><a class="docs-heading-anchor" href="#def_AbstractAffineMap">Affine maps (AbstractAffineMap)</a><a id="def_AbstractAffineMap-1"></a><a class="docs-heading-anchor-permalink" href="#def_AbstractAffineMap" title="Permalink"></a></h2><p>An affine map consists of a linear map and a translation.</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.AbstractAffineMap" href="#LazySets.AbstractAffineMap"><code>LazySets.AbstractAffineMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractAffineMap{N, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Abstract type for affine maps.</p><p><strong>Notes</strong></p><p>See <a href="../lazy_operations/AffineMap/#LazySets.AffineMap"><code>AffineMap</code></a> for a standard implementation of this interface.</p><p>Every concrete <code>AbstractAffineMap</code> must define the following functions:</p><ul><li><code>matrix(::AbstractAffineMap)</code> – return the linear map</li><li><code>vector(::AbstractAffineMap)</code> – return the affine translation vector</li><li><code>set(::AbstractAffineMap)</code> – return the set that the map is applied to</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractAffineMap)
6-element Array{Any,1}:
 AffineMap
 ExponentialMap
 ExponentialProjectionMap
 LinearMap
 ResetMap
 Translation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractAffineMap.jl#L6-L30">source</a></section></article><p>This interface defines the following functions:</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractAffineMap}" href="#LazySets.dim-Tuple{AbstractAffineMap}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dim(am::AbstractAffineMap)</code></pre><p>Return the dimension of an affine map.</p><p><strong>Input</strong></p><ul><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>The dimension of an affine map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractAffineMap.jl#L40-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{T,1} where T,AbstractAffineMap}" href="#LazySets.σ-Tuple{AbstractArray{T,1} where T,AbstractAffineMap}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">σ(d::AbstractVector, am::AbstractAffineMap)</code></pre><p>Return the support vector of an affine map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractAffineMap.jl#L57-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.ρ-Tuple{AbstractArray{T,1} where T,AbstractAffineMap}" href="#LazySets.ρ-Tuple{AbstractArray{T,1} where T,AbstractAffineMap}"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ρ(d::AbstractVector, am::AbstractAffineMap)</code></pre><p>Return the support function of an affine map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractAffineMap.jl#L76-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.an_element-Tuple{AbstractAffineMap}" href="#LazySets.an_element-Tuple{AbstractAffineMap}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">an_element(am::AbstractAffineMap)</code></pre><p>Return some element of an affine map.</p><p><strong>Input</strong></p><ul><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>An element of the affine map. It relies on the <code>an_element</code> function of the wrapped set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractAffineMap.jl#L94-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{AbstractAffineMap}" href="#Base.isempty-Tuple{AbstractAffineMap}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isempty(am::AbstractAffineMap)</code></pre><p>Return whether an affine map is empty or not.</p><p><strong>Input</strong></p><ul><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractAffineMap.jl#L112-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isbounded-Tuple{AbstractAffineMap}" href="#LazySets.isbounded-Tuple{AbstractAffineMap}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isbounded(am::AbstractAffineMap; cond_tol::Number=DEFAULT_COND_TOL)</code></pre><p>Determine whether an affine map is bounded.</p><p><strong>Input</strong></p><ul><li><code>am</code>       – affine map</li><li><code>cond_tol</code> – (optional) tolerance of matrix condition (used to check whether               the matrix is invertible)</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the affine map is bounded.</p><p><strong>Algorithm</strong></p><p>We first check if the matrix is zero or the wrapped set is bounded. If not, we perform a sufficient check whether the matrix is invertible. If the matrix is invertible, then the map being bounded is equivalent to the wrapped set being bounded, and hence the map is unbounded. Otherwise, we check boundedness via <a href="#LazySets._isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N"><code>_isbounded_unit_dimensions</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractAffineMap.jl#L129-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{T,1} where T,AbstractAffineMap}" href="#Base.:∈-Tuple{AbstractArray{T,1} where T,AbstractAffineMap}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∈(x::AbstractVector, am::AbstractAffineMap)</code></pre><p>Check whether a given point is contained in the affine map of a convex set.</p><p><strong>Input</strong></p><ul><li><code>x</code>  – point/vector</li><li><code>am</code> – affine map of a convex set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ am$</span>.</p><p><strong>Algorithm</strong></p><p>Note that <span>$x ∈ M⋅S ⊕ v$</span> iff <span>$M^{-1}⋅(x - v) ∈ S$</span>. This implementation does not explicitly invert the matrix, which is why it also works for non-square matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; am = AffineMap([2.0 0.0; 0.0 1.0], BallInf([1., 1.], 1.), [-1.0, -1.0]);

julia&gt; [5.0, 1.0] ∈ am
false

julia&gt; [3.0, 1.0] ∈ am
true</code></pre><p>An example with a non-square matrix:</p><pre><code class="language-julia-repl">julia&gt; B = BallInf(zeros(4), 1.);

julia&gt; M = [1. 0 0 0; 0 1 0 0]/2;

julia&gt; [0.5, 0.5] ∈ M*B
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractAffineMap.jl#L163-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.vertices_list-Tuple{AbstractAffineMap}" href="#LazySets.vertices_list-Tuple{AbstractAffineMap}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertices_list(am::AbstractAffineMap; [apply_convex_hull]::Bool)</code></pre><p>Return the list of vertices of a (polyhedral) affine map.</p><p><strong>Input</strong></p><ul><li><code>am</code>                – affine map</li><li><code>apply_convex_hull</code> – (optional, default: <code>true</code>) if <code>true</code>, apply the convex                        hull operation to the list of vertices transformed by                        the affine map</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>This implementation computes all vertices of <code>X</code>, then transforms them through the affine map, i.e. <code>x ↦ M*x + v</code> for each vertex <code>x</code> of <code>X</code>. By default, the convex hull operation is taken before returning this list. For dimensions three or higher, this operation relies on the functionality through the concrete polyhedra library <code>Polyhedra.jl</code>.</p><p>If you are not interested in taking the convex hull of the resulting vertices under the affine map, pass <code>apply_convex_hull=false</code> as a keyword argument.</p><p>Note that we assume that the underlying set <code>X</code> is polyhedral, either concretely or lazily, i.e. there the function <code>vertices_list</code> should be applicable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractAffineMap.jl#L210-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.constraints_list-Tuple{AbstractAffineMap}" href="#LazySets.constraints_list-Tuple{AbstractAffineMap}"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraints_list(am::AbstractAffineMap)</code></pre><p>Return the list of constraints of a (polyhedral) affine map.</p><p><strong>Input</strong></p><ul><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>The list of constraints of the affine map.</p><p><strong>Notes</strong></p><p>We assume that the underlying set <code>X</code> is polyhedral, i.e., offers a method <code>constraints_list(X)</code>.</p><p><strong>Algorithm</strong></p><p>Falls back to the list of constraints of the translation of a lazy linear map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractAffineMap.jl#L260-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.linear_map-Tuple{AbstractArray{T,2} where T,AbstractAffineMap}" href="#LazySets.linear_map-Tuple{AbstractArray{T,2} where T,AbstractAffineMap}"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">linear_map(M::AbstractMatrix, am::AbstractAffineMap)</code></pre><p>Return the linear map of a lazy affine map.</p><p><strong>Input</strong></p><ul><li><code>M</code>  – matrix</li><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>A set corresponding to the linear map of the lazy affine map of a set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractAffineMap.jl#L287-L300">source</a></section></article><h3 id="Implementations-11"><a class="docs-heading-anchor" href="#Implementations-11">Implementations</a><a class="docs-heading-anchor-permalink" href="#Implementations-11" title="Permalink"></a></h3><ul><li><a href="../lazy_operations/AffineMap/#def_AffineMap">Affine map (AffineMap)</a></li><li><a href="../lazy_operations/ExponentialMap/#def_ExponentialMap">Exponential map (ExponentialMap)</a></li><li><a href="../lazy_operations/LinearMap/#def_LinearMap">Linear map (LinearMap)</a></li><li><a href="../lazy_operations/ResetMap/#def_ResetMap">Reset map (ResetMap)</a></li><li><a href="../lazy_operations/Translation/#def_Translation">Translation</a></li></ul><h2 id="def_AbstractStar"><a class="docs-heading-anchor" href="#def_AbstractStar">Star sets (AbstractStar)</a><a id="def_AbstractStar-1"></a><a class="docs-heading-anchor-permalink" href="#def_AbstractStar" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.AbstractStar" href="#LazySets.AbstractStar"><code>LazySets.AbstractStar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractStar{N}</code></pre><p>Abstract supertype for all star set types.</p><p><strong>Notes</strong></p><p>A set <span>$X$</span> is star-like (also known as generalized star) if it can be represented by a center <span>$x₀ ∈ \mathbb{R}^n$</span> and <span>$m$</span> vectors <span>$v₁, …, vₘ$</span> forming the basis, and a predicate <span>$P : \mathbb{R}^n → \{⊤, ⊥\}$</span> such that</p><p class="math-container">\[    X = \{x ∈ \mathbb{R}^n : x = x₀ + \sum_{i=1}^m α_i v_i,,~~\textrm{s.t. } P(α) = ⊤ \}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/1b108dfce9bb55c81da0b4a5608fae4f2bb7cd51/src/Interfaces/AbstractStar.jl#L1-L15">source</a></section></article><h3 id="Implementations-12"><a class="docs-heading-anchor" href="#Implementations-12">Implementations</a><a class="docs-heading-anchor-permalink" href="#Implementations-12" title="Permalink"></a></h3><ul><li><a href="../sets/Star/#def_Star">Star</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/lazy_intersections/">« Lazy Intersections</a><a class="docs-footer-nextpage" href="../sets/Ball1/">Ball1 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 25 February 2021 09:55">Thursday 25 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
