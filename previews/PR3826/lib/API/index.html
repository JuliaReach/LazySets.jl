<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · LazySets.jl</title><meta name="title" content="API · LazySets.jl"/><meta property="og:title" content="API · LazySets.jl"/><meta property="twitter:title" content="API · LazySets.jl"/><meta name="description" content="Documentation for LazySets.jl."/><meta property="og:description" content="Documentation for LazySets.jl."/><meta property="twitter:description" content="Documentation for LazySets.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/aligned.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LazySets.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../man/optional_dependencies/">Optional Features</a></li><li><a class="tocitem" href="../../man/tour/">A Tour of LazySets</a></li><li><a class="tocitem" href="../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../man/unary_set_operations/">Unary Operations on Sets</a></li><li><a class="tocitem" href="../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Unary-set-functions"><span>Unary set functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Mixed-set-functions"><span>Mixed set functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Binary-set-functions"><span>Binary set functions</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Set Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../interfaces/overview/">Overview</a></li><li><a class="tocitem" href="../interfaces/LazySet/">General sets (LazySet)</a></li><li><a class="tocitem" href="../interfaces/ConvexSet/">Convex sets (ConvexSet)</a></li><li><a class="tocitem" href="../interfaces/AbstractCentrallySymmetric/">Centrally symmetric sets (AbstractCentrallySymmetric)</a></li><li><a class="tocitem" href="../interfaces/AbstractPolyhedron/">Polyhedra (AbstractPolyhedron)</a></li><li><a class="tocitem" href="../interfaces/AbstractPolytope/">Polytopes (AbstractPolytope)</a></li><li><a class="tocitem" href="../interfaces/AbstractPolygon/">Polygons (AbstractPolygon)</a></li><li><a class="tocitem" href="../interfaces/AbstractHPolygon/">Polygons in constraint representation (AbstractHPolygon)</a></li><li><a class="tocitem" href="../interfaces/AbstractCentrallySymmetricPolytope/">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a></li><li><a class="tocitem" href="../interfaces/AbstractZonotope/">Zonotopes (AbstractZonotope)</a></li><li><a class="tocitem" href="../interfaces/AbstractHyperrectangle/">Hyperrectangles (AbstractHyperrectangle)</a></li><li><a class="tocitem" href="../interfaces/AbstractSingleton/">Singletons (AbstractSingleton)</a></li><li><a class="tocitem" href="../interfaces/AbstractAffineMap/">Affine maps (AbstractAffineMap)</a></li><li><a class="tocitem" href="../interfaces/AbstractPolynomialZonotope/">Polynomial zonotope sets (AbstractPolynomialZonotope)</a></li><li><a class="tocitem" href="../interfaces/AbstractSparsePolynomialZonotope/">Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)</a></li><li><a class="tocitem" href="../interfaces/AbstractBallp/">Balls in the p-norm (AbstractBallp)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../sets/DensePolynomialZonotope/">DensePolynomialZonotope</a></li><li><a class="tocitem" href="../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../sets/HParallelotope/">HParallelotope</a></li><li><a class="tocitem" href="../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../sets/Line/">Line</a></li><li><a class="tocitem" href="../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../sets/Polygon/">Polygon</a></li><li><a class="tocitem" href="../sets/SimpleSparsePolynomialZonotope/">SimpleSparsePolynomialZonotope</a></li><li><a class="tocitem" href="../sets/SparsePolynomialZonotope/">SparsePolynomialZonotope</a></li><li><a class="tocitem" href="../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../sets/Star/">Star</a></li><li><a class="tocitem" href="../sets/Tetrahedron/">Tetrahedron</a></li><li><a class="tocitem" href="../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../sets/Zonotope/">Zonotope</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lazy_operations/AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../lazy_operations/Bloating/">Bloating</a></li><li><a class="tocitem" href="../lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../lazy_operations/Complement/">Complement</a></li><li><a class="tocitem" href="../lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../lazy_operations/Intersection/">Intersection</a></li><li><a class="tocitem" href="../lazy_operations/LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../lazy_operations/InverseLinearMap/">InverseLinearMap</a></li><li><a class="tocitem" href="../lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../lazy_operations/QuadraticMap/">QuadraticMap</a></li><li><a class="tocitem" href="../lazy_operations/Rectification/">Rectification</a></li><li><a class="tocitem" href="../lazy_operations/ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../lazy_operations/Translation/">Translation</a></li><li><a class="tocitem" href="../lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Concrete Binary Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../concrete_binary_operations/overview/">Binary set operations</a></li><li><a class="tocitem" href="../concrete_binary_operations/cartesian_product/">Cartesian Product</a></li><li><a class="tocitem" href="../concrete_binary_operations/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../concrete_binary_operations/difference/">Set difference</a></li><li><a class="tocitem" href="../concrete_binary_operations/distance/">Distance</a></li><li><a class="tocitem" href="../concrete_binary_operations/intersection/">Intersection of two sets</a></li><li><a class="tocitem" href="../concrete_binary_operations/minkowski_sum/">Minkowski Sum</a></li><li><a class="tocitem" href="../concrete_binary_operations/minkowski_difference/">Minkowski Difference</a></li><li><a class="tocitem" href="../concrete_binary_operations/isdisjoint/">Check for Disjointness of Sets</a></li><li><a class="tocitem" href="../concrete_binary_operations/issubset/">Subset Check</a></li></ul></li><li><a class="tocitem" href="../conversion/">Conversions between set representations</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Approximations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../approximations/overview/">Overview</a></li><li><a class="tocitem" href="../approximations/overapproximate/">Overapproximation</a></li><li><a class="tocitem" href="../approximations/box_approximation/">Box Approximation</a></li><li><a class="tocitem" href="../approximations/iterative_refinement/">Iterative refinement</a></li><li><a class="tocitem" href="../approximations/template_directions/">Template directions</a></li><li><a class="tocitem" href="../approximations/underapproximate/">Underapproximation</a></li><li><a class="tocitem" href="../approximations/approximate/">Approximation</a></li><li><a class="tocitem" href="../approximations/decompose/">Cartesian Decomposition</a></li><li><a class="tocitem" href="../approximations/hausdorff_distance/">Hausdorff Distance</a></li></ul></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li><a class="tocitem" href="../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/API.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#Set-interface">Set interface</a></li><li><a href="#Unary-set-functions">Unary set functions</a></li><li><a href="#Mixed-set-functions">Mixed set functions</a></li><li><a href="#Binary-set-functions">Binary set functions</a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API" href="#LazySets.API"><code>LazySets.API</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">API</code></pre><p>This module contains an API (application programming interface) for set libraries. The module only defines and documents the general functions and does not provide implementations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/API.jl#L1-L7">source</a></section></article><h1 id="Set-interface"><a class="docs-heading-anchor" href="#Set-interface">Set interface</a><a id="Set-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Set-interface" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.LazySet" href="#LazySets.API.LazySet"><code>LazySets.API.LazySet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LazySet</code></pre><p>Abstract type for a set of points.</p><p>This type is not exported and is only used to define interface methods without type piracy.</p><p>The <code>LazySets</code> library defines its own set interface, which is also called <code>LazySet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/LazySet.jl#L2-L12">source</a></section></article><h1 id="Unary-set-functions"><a class="docs-heading-anchor" href="#Unary-set-functions">Unary set functions</a><a id="Unary-set-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Unary-set-functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.an_element-Tuple{LazySets.API.LazySet}" href="#LazySets.API.an_element-Tuple{LazySets.API.LazySet}"><code>LazySets.API.an_element</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">an_element(X::LazySet)</code></pre><p>Return some element of a nonempty set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>An element of <code>X</code> unless <code>X</code> is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/an_element.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.area-Tuple{LazySets.API.LazySet}" href="#LazySets.API.area-Tuple{LazySets.API.LazySet}"><code>LazySets.API.area</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">area(X::LazySet)</code></pre><p>Compute the area of a two-dimensional set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – two-dimensional set</li></ul><p><strong>Output</strong></p><p>A number representing the area of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/area.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.center-Tuple{LazySets.API.LazySet, Int64}" href="#LazySets.API.center-Tuple{LazySets.API.LazySet, Int64}"><code>LazySets.API.center</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">center(X::LazySet, i::Int)</code></pre><p>Compute the center of a centrally symmetric set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – centrally symmetric set</li><li><code>i</code> – dimension</li></ul><p><strong>Output</strong></p><p>A real number representing the center of the set in the given dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/center.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.center-Tuple{LazySets.API.LazySet}" href="#LazySets.API.center-Tuple{LazySets.API.LazySet}"><code>LazySets.API.center</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">center(X::LazySet)</code></pre><p>Compute the center of a centrally symmetric set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p>A vector with the center, or midpoint, of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/center.jl#L17-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.complement-Tuple{LazySets.API.LazySet}" href="#LazySets.API.complement-Tuple{LazySets.API.LazySet}"><code>LazySets.API.complement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">complement(X::LazySet)</code></pre><p>Compute the complement of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the complement of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/complement.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.concretize-Tuple{LazySets.API.LazySet}" href="#LazySets.API.concretize-Tuple{LazySets.API.LazySet}"><code>LazySets.API.concretize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">concretize(X::LazySet)</code></pre><p>Construct a concrete representation of a (possibly lazy) set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A concrete representation of <code>X</code> (as far as possible).</p><p><strong>Notes</strong></p><p>Since not every lazy set has a concrete set representation in this library, the result may still be partially lazy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/concretize.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}" href="#LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}"><code>LazySets.API.constraints_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">constraints_list(X::LazySet)</code></pre><p>Compute a list of linear constraints of a polyhedral set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – polyhedral set</li></ul><p><strong>Output</strong></p><p>A list of the linear constraints of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/constraints_list.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.constraints-Tuple{LazySets.API.LazySet}" href="#LazySets.API.constraints-Tuple{LazySets.API.LazySet}"><code>LazySets.API.constraints</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">constraints(X::LazySet)</code></pre><p>Construct an iterator over the constraints of a polyhedral set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – polyhedral set</li></ul><p><strong>Output</strong></p><p>An iterator over the constraints of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/constraints.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.convex_hull-Tuple{LazySets.API.LazySet}" href="#LazySets.API.convex_hull-Tuple{LazySets.API.LazySet}"><code>LazySets.API.convex_hull</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convex_hull(X::LazySet)</code></pre><p>Compute the convex hull of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the convex hull of <code>X</code>.</p><p><strong>Notes</strong></p><p>The convex hull of a set <span>$X$</span> is defined as</p><p class="math-container">\[    \{λx + (1-λ)y \mid x, y ∈ X, λ ∈ [0, 1]\}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/convex_hull.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.diameter" href="#LazySets.API.diameter"><code>LazySets.API.diameter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diameter(X::LazySet, [p]::Real=Inf)</code></pre><p>Return the diameter of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p><p><strong>Notes</strong></p><p>The diameter of a set is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/diameter.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.dim-Tuple{LazySets.API.LazySet}" href="#LazySets.API.dim-Tuple{LazySets.API.LazySet}"><code>LazySets.API.dim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dim(X::LazySet)</code></pre><p>Compute the ambient dimension of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/dim.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eltype-Tuple{Type{&lt;:LazySets.API.LazySet}}" href="#Base.eltype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eltype(T::Type{&lt;:LazySet})</code></pre><p>Determine the numeric type of a set type.</p><p><strong>Input</strong></p><ul><li><code>T</code> – set type</li></ul><p><strong>Output</strong></p><p>The numeric type of <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/eltype.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eltype-Tuple{LazySets.API.LazySet}" href="#Base.eltype-Tuple{LazySets.API.LazySet}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eltype(X::LazySet)</code></pre><p>Determine the numeric type of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>The numeric type of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/eltype.jl#L16-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.extrema-Tuple{LazySets.API.LazySet, Int64}" href="#Base.extrema-Tuple{LazySets.API.LazySet, Int64}"><code>Base.extrema</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extrema(X::LazySet, i::Int)</code></pre><p>Compute the lowest and highest coordinate of a set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>i</code> – dimension</li></ul><p><strong>Output</strong></p><p>Two real numbers representing the lowest and highest coordinate of the set in the given dimension.</p><p><strong>Notes</strong></p><p>The result is equivalent to <code>(low(X, i), high(X, i))</code>, but sometimes it can be computed more efficiently.</p><p>The resulting values are the lower and upper ends of the projection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/extrema.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.extrema-Tuple{LazySets.API.LazySet}" href="#Base.extrema-Tuple{LazySets.API.LazySet}"><code>Base.extrema</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extrema(X::LazySet)</code></pre><p>Compute the lowest and highest coordinate of a set in each dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>Two vectors with the lowest and highest coordinates of <code>X</code> in each dimension.</p><p><strong>Notes</strong></p><p>See also <a href="#Base.extrema-Tuple{LazySets.API.LazySet, Int64}"><code>extrema(X::LazySet, i::Int)</code></a>.</p><p>The result is equivalent to <code>(low(X), high(X))</code>, but sometimes it can be computed more efficiently.</p><p>The resulting points are the lowest and highest corners of the box approximation, so they are not necessarily contained in <code>X</code>.</p><p><strong>Algorithm</strong></p><p>The default implementation computes the extrema via <code>low</code> and <code>high</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/extrema.jl#L25-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.high-Tuple{LazySets.API.LazySet, Int64}" href="#LazySets.API.high-Tuple{LazySets.API.LazySet, Int64}"><code>LazySets.API.high</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">high(X::LazySet, i::Int)</code></pre><p>Compute the highest coordinate of a set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>i</code> – dimension</li></ul><p><strong>Output</strong></p><p>A real number representing the highest coordinate of the set in the given dimension.</p><p><strong>Notes</strong></p><p>The resulting value is the upper end of the projection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/high.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.high-Tuple{LazySets.API.LazySet}" href="#LazySets.API.high-Tuple{LazySets.API.LazySet}"><code>LazySets.API.high</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">high(X::LazySet)</code></pre><p>Compute the highest coordinate of a set in each dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A vector with the highest coordinate of the set in each dimension.</p><p><strong>Notes</strong></p><p>See also <code>high(X::LazySet, i::Int)</code>.</p><p>The result is the uppermost corner of the box approximation, so it is not necessarily contained in <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/high.jl#L22-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isbounded-Tuple{LazySets.API.LazySet}" href="#LazySets.API.isbounded-Tuple{LazySets.API.LazySet}"><code>LazySets.API.isbounded</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isbounded(X::LazySet)</code></pre><p>Check whether a set is bounded.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set is bounded.</p><p><strong>Notes</strong></p><p>See also <a href="#LazySets.API.isboundedtype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>isboundedtype(::Type{&lt;:LazySet})</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/isbounded.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isboundedtype-Tuple{Type{&lt;:LazySets.API.LazySet}}" href="#LazySets.API.isboundedtype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>LazySets.API.isboundedtype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isboundedtype(T::Type{&lt;:LazySet})</code></pre><p>Check whether a set type only represents bounded sets.</p><p><strong>Input</strong></p><ul><li><code>T</code> – set type</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set type only represents bounded sets.</p><p><strong>Notes</strong></p><p>See also <a href="#LazySets.API.isbounded-Tuple{LazySets.API.LazySet}"><code>isbounded(::LazySet)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/isboundedtype.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isconvextype-Tuple{Type{&lt;:LazySets.API.LazySet}}" href="#LazySets.API.isconvextype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>LazySets.API.isconvextype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isconvextype(T::Type{&lt;:LazySet})</code></pre><p>Check whether <code>T</code> is convex just by using type information.</p><p><strong>Input</strong></p><ul><li><code>T</code> – subtype of <code>LazySet</code></li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set type only represents convex sets.</p><p><strong>Notes</strong></p><p>Since this operation only acts on types (not on values), it can return false negatives, i.e., there may be instances where the set is convex, even though the answer of this function is <code>false</code>. The examples below illustrate this point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/isconvextype.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isempty" href="#Base.isempty"><code>Base.isempty</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isempty(X::LazySet, witness::Bool=false)</code></pre><p>Check whether a set is empty.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If the <code>witness</code> option is deactivated: <code>true</code> iff <span>$X = ∅$</span></li><li>If the <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X = ∅$</span></li><li><code>(false, v)</code> iff <span>$X ≠ ∅$</span> for some <span>$v ∈ X$</span></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/isempty.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isoperation-Tuple{LazySets.API.LazySet}" href="#LazySets.API.isoperation-Tuple{LazySets.API.LazySet}"><code>LazySets.API.isoperation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isoperation(X::LazySet)</code></pre><p>Check whether a set is an instance of a (lazy) set operation.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>X</code> is an instance of a set-based operation.</p><p><strong>Notes</strong></p><p>See also <a href="#LazySets.API.isoperationtype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>isoperationtype(::Type{&lt;:LazySet})</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/isoperation.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isoperationtype-Tuple{Type{&lt;:LazySets.API.LazySet}}" href="#LazySets.API.isoperationtype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>LazySets.API.isoperationtype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isoperationtype(T::Type{&lt;:LazySet})</code></pre><p>Check whether a set type is a (lazy) set operation.</p><p><strong>Input</strong></p><ul><li><code>T</code> – set type</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set type represents a set operation.</p><p><strong>Notes</strong></p><p>See also <a href="#LazySets.API.isoperation-Tuple{LazySets.API.LazySet}"><code>isoperation(::LazySet)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/isoperationtype.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.ispolyhedral-Tuple{LazySets.API.LazySet}" href="#LazySets.API.ispolyhedral-Tuple{LazySets.API.LazySet}"><code>LazySets.API.ispolyhedral</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ispolyhedral(X::LazySet)</code></pre><p>Check whether a set is polyhedral.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> only if the set is polyhedral.</p><p><strong>Notes</strong></p><p>The answer is conservative, i.e., may sometimes be <code>false</code> even if the set is polyhedral.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/ispolyhedral.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isuniversal" href="#LazySets.API.isuniversal"><code>LazySets.API.isuniversal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isuniversal(X::LazySet, witness::Bool=false)</code></pre><p>Check whether a set is universal.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If the <code>witness</code> option is deactivated: <code>true</code> iff <span>$X = ℝ^n$</span></li><li>If the <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X = ℝ^n$</span></li><li><code>(false, v)</code> iff <span>$X ≠ ℝ^n$</span> for some <span>$v ∉ X$</span></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/isuniversal.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.low-Tuple{LazySets.API.LazySet, Int64}" href="#LazySets.API.low-Tuple{LazySets.API.LazySet, Int64}"><code>LazySets.API.low</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">low(X::LazySet, i::Int)</code></pre><p>Compute the lowest coordinate of a set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>i</code> – dimension</li></ul><p><strong>Output</strong></p><p>A real number representing the lowest coordinate of the set in the given dimension.</p><p><strong>Notes</strong></p><p>The resulting value is the lower end of the projection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/low.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.low-Tuple{LazySets.API.LazySet}" href="#LazySets.API.low-Tuple{LazySets.API.LazySet}"><code>LazySets.API.low</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">low(X::LazySet)</code></pre><p>Compute the lowest coordinates of a set in each dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A vector with the lowest coordinate of the set in each dimension.</p><p><strong>Notes</strong></p><p>See also <code>low(X::LazySet, i::Int)</code>.</p><p>The result is the lowermost corner of the box approximation, so it is not necessarily contained in <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/low.jl#L22-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">norm(X::LazySet, [p]::Real=Inf)</code></pre><p>Return the norm of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p><p><strong>Notes</strong></p><p>The norm of a set is the norm of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume that is centered in the origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/norm.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.radius" href="#LazySets.API.radius"><code>LazySets.API.radius</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">radius(X::LazySet, [p]::Real=Inf)</code></pre><p>Return the radius of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p><p><strong>Notes</strong></p><p>The radius of a set is the radius of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/radius.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{Type{&lt;:LazySets.API.LazySet}}" href="#Base.rand-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand(T::Type{&lt;:LazySet}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )</code></pre><p>Create a random set of the given set type.</p><p><strong>Input</strong></p><ul><li><code>T</code>    – set type</li><li><code>N</code>    – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>  – (optional, default: 2) dimension</li><li><code>rng</code>  – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code> – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A random set of the given set type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/rand.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityBase.Arrays.rectify-Tuple{LazySets.API.LazySet}" href="#ReachabilityBase.Arrays.rectify-Tuple{LazySets.API.LazySet}"><code>ReachabilityBase.Arrays.rectify</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rectify(X::LazySet)</code></pre><p>Compute the rectification of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the rectification of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/rectify.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.reflect-Tuple{LazySets.API.LazySet}" href="#LazySets.API.reflect-Tuple{LazySets.API.LazySet}"><code>LazySets.API.reflect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reflect(X::LazySet)</code></pre><p>Compute the reflection of a set in the origin.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the reflection <span>$-X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/reflect.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.vertices_list-Tuple{LazySets.API.LazySet}" href="#LazySets.API.vertices_list-Tuple{LazySets.API.LazySet}"><code>LazySets.API.vertices_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertices_list(X::LazySet)</code></pre><p>Compute a list of vertices of a polytopic set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – polytopic set</li></ul><p><strong>Output</strong></p><p>A list of the vertices of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/vertices_list.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.vertices-Tuple{LazySets.API.LazySet}" href="#LazySets.API.vertices-Tuple{LazySets.API.LazySet}"><code>LazySets.API.vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertices(X::LazySet)</code></pre><p>Construct an iterator over the vertices of a polytopic set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – polytopic set</li></ul><p><strong>Output</strong></p><p>An iterator over the vertices of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/vertices.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.volume-Tuple{LazySets.API.LazySet}" href="#LazySets.API.volume-Tuple{LazySets.API.LazySet}"><code>LazySets.API.volume</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">volume(X::LazySet)</code></pre><p>Compute the volume, or Lebesgue measure, of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A real number representing the Lebesgue measure of <code>X</code>.</p><p><strong>Notes</strong></p><p>The <a href="https://en.wikipedia.org/wiki/Lebesgue_measure">Lebesgue measure</a> has the following common special cases:</p><ul><li>In 1D, it coincides with the <em>length</em>.</li><li>In 2D, it coincides with the <em>area</em> (see also <a href="#LazySets.API.area-Tuple{LazySets.API.LazySet}"><code>area</code></a>).</li><li>In 3D, it coincides with the <em>volume</em>.</li></ul><p>In higher dimensions, it is also known as the <em>hypervolume</em> or simply <em>volume</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Unary/volume.jl#L1-L24">source</a></section></article><h1 id="Mixed-set-functions"><a class="docs-heading-anchor" href="#Mixed-set-functions">Mixed set functions</a><a id="Mixed-set-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Mixed-set-functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.affine_map-Tuple{AbstractMatrix, LazySets.API.LazySet, AbstractVector}" href="#LazySets.API.affine_map-Tuple{AbstractMatrix, LazySets.API.LazySet, AbstractVector}"><code>LazySets.API.affine_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">affine_map(M::AbstractMatrix, X::LazySet, v::AbstractVector)</code></pre><p>Compute the affine map <span>$M · X + v$</span>.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>X</code> – set</li><li><code>v</code> – translation vector</li></ul><p><strong>Output</strong></p><p>A set representing the affine map <span>$M · X + v$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Mixed/affine_map.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityBase.Arrays.distance-Tuple{AbstractVector, LazySets.API.LazySet}" href="#ReachabilityBase.Arrays.distance-Tuple{AbstractVector, LazySets.API.LazySet}"><code>ReachabilityBase.Arrays.distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance(x::AbstractVector, X::LazySet; [p]::Real=2)
distance(X::LazySet, x::AbstractVector; [p]::Real=2)</code></pre><p>Compute the standard distance (induced by the <span>$p$</span>-norm) between a point and a set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>X</code> – set</li><li><code>p</code> – (optional; default: <code>2</code>) value of the <span>$p$</span>-norm</li></ul><p><strong>Output</strong></p><p>A real number representing the distance between <code>x</code> and <code>X</code>.</p><p><strong>Notes</strong></p><p>The standard distance is zero if the point lies inside the set, and infinite if the set is empty. Otherwise, it is the <span>$p$</span>-norm of the shortest line segment between the point and any other point in the set. Formally,</p><p class="math-container">\[    \inf_{y ∈ X} \{ d(x, y) \}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Mixed/distance.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.exponential_map-Tuple{AbstractMatrix, LazySets.API.LazySet}" href="#LazySets.API.exponential_map-Tuple{AbstractMatrix, LazySets.API.LazySet}"><code>LazySets.API.exponential_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exponential_map(M::AbstractMatrix, X::LazySet)</code></pre><p>Compute the exponential map of <code>M</code> and <code>X</code>, i.e., <span>$eᴹ ⋅ X$</span>.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the exponential map <span>$eᴹ ⋅ X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Mixed/exponential_map.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}" href="#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∈(x::AbstractVector, X::LazySet)</code></pre><p>Check whether a point lies in a set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Mixed/in.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.is_interior_point-Tuple{AbstractVector, LazySets.API.LazySet}" href="#LazySets.API.is_interior_point-Tuple{AbstractVector, LazySets.API.LazySet}"><code>LazySets.API.is_interior_point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_interior_point(v::AbstractVector{&lt;:Real}, X::LazySet; kwargs...) end</code></pre><p>Check whether a point is contained in the interior of a set.</p><p><strong>Input</strong></p><ul><li><code>v</code>  – point/vector</li><li><code>X</code>  – set</li><li><code>p</code>  – (optional; default: <code>Inf</code>) norm of the ball used to apply the error         tolerance</li><li><code>ε</code>  – (optional; default: <code>_rtol(eltype(X))</code>) error tolerance of the check</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the point <code>v</code> is strictly contained in <code>X</code> with tolerance <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Mixed/is_interior_point.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.linear_map-Tuple{AbstractMatrix, LazySets.API.LazySet}" href="#LazySets.API.linear_map-Tuple{AbstractMatrix, LazySets.API.LazySet}"><code>LazySets.API.linear_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_map(M::AbstractMatrix, X::LazySet)</code></pre><p>Compute the linear map <span>$M · X$</span>.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the linear map <span>$M · X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Mixed/linear_map.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.permute-Tuple{LazySets.API.LazySet, AbstractVector{Int64}}" href="#SparseArrays.permute-Tuple{LazySets.API.LazySet, AbstractVector{Int64}}"><code>SparseArrays.permute</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">permute(X::LazySet, p::AbstractVector{Int})</code></pre><p>Permute the dimensions of a set according to a given permutation vector.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>p</code> – permutation vector</li></ul><p><strong>Output</strong></p><p>A new set corresponding to <code>X</code> where the dimensions have been permuted according to <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Mixed/permute.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.project-Tuple{LazySets.API.LazySet, AbstractVector{Int64}}" href="#LazySets.API.project-Tuple{LazySets.API.LazySet, AbstractVector{Int64}}"><code>LazySets.API.project</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">project(X::LazySet, block::AbstractVector{Int})</code></pre><p>Project a set to a given block by using a concrete linear map.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>block</code>   – block structure - a vector with the dimensions of interest</li></ul><p><strong>Output</strong></p><p>A set representing the projection of <code>X</code> to block <code>block</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Mixed/project.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.sample" href="#LazySets.API.sample"><code>LazySets.API.sample</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample(X::LazySet, [m]::Int=1;
       [rng]::AbstractRNG=GLOBAL_RNG,
       [seed]::Union{Int,Nothing}=nothing)</code></pre><p>Compute random samples from a set.</p><p><strong>Input</strong></p><ul><li><code>X</code>    – set</li><li><code>m</code>    – (optional; default: 1) number of random samples</li><li><code>rng</code>  – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code> – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A vector of <code>m</code> elements in <code>X</code> if <code>X</code> is nonempty, and an error otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Mixed/sample.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.scale-Tuple{Real, LazySets.API.LazySet}" href="#LazySets.API.scale-Tuple{Real, LazySets.API.LazySet}"><code>LazySets.API.scale</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scale(α::Real, X::LazySet)</code></pre><p>Compute the scaling of a set.</p><p><strong>Input</strong></p><ul><li><code>α</code> – scalar</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing <span>$α ⋅ X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Mixed/scale.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.scale!-Tuple{Real, LazySets.API.LazySet}" href="#LazySets.API.scale!-Tuple{Real, LazySets.API.LazySet}"><code>LazySets.API.scale!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scale!(α::Real, X::LazySet)</code></pre><p>Scale a set by modifying it.</p><p><strong>Input</strong></p><ul><li><code>α</code> – scalar</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>The scaled set representing <span>$α ⋅ X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Mixed/scale!.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}" href="#LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}"><code>LazySets.API.ρ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, X::LazySet)</code></pre><p>Evaluate the support function of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function of <code>X</code> in direction <code>d</code>.</p><p><strong>Notes</strong></p><p>A convenience alias <code>support_function</code> is also available.</p><p>We have the following identity based on the support vector <span>$σ$</span>:</p><p class="math-container">\[    ρ(d, X) = d ⋅ σ(d, X)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Mixed/support_function.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.support_function" href="#LazySets.API.support_function"><code>LazySets.API.support_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">ρ(d::AbstractVector, B::Ball1)</code></pre><p><strong>Algorithm</strong></p><p>Let <span>$c$</span> and <span>$r$</span> be the center and radius of the ball <span>$B$</span> in the 1-norm, respectively. Then:</p><p class="math-container">\[ρ(d, B) = ⟨d, c⟩ + r ‖d‖_∞.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/Ball1/support_function.jl#L1-L14">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, X::LazySet)</code></pre><p>Evaluate the support function of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function of <code>X</code> in direction <code>d</code>.</p><p><strong>Notes</strong></p><p>A convenience alias <code>support_function</code> is also available.</p><p>We have the following identity based on the support vector <span>$σ$</span>:</p><p class="math-container">\[    ρ(d, X) = d ⋅ σ(d, X)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Mixed/support_function.jl#L1-L24">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">ρ(d::AbstractVector, B::Ball2)</code></pre><p><strong>Algorithm</strong></p><p>Let <span>$c$</span> and <span>$r$</span> be the center and radius of the ball <span>$B$</span> in the 2-norm, respectively. Then:</p><p class="math-container">\[ρ(d, B) = ⟨d, c⟩ + r ‖d‖_2.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/Ball2/support_function.jl#L1-L14">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">ρ(d::AbstractVector, B::BallInf)</code></pre><p><strong>Algorithm</strong></p><p>Let <span>$B$</span> be a ball in the infinity norm with center <span>$c$</span> and radius <span>$r$</span> and let <span>$d$</span> be the direction of interest. For balls with dimensions less than <span>$30$</span>, we use the implementation for <code>AbstractHyperrectangle</code>, tailored to a <code>BallInf</code>, which computes</p><p class="math-container">\[    ∑_{i=1}^n d_i (c_i + \textrm{sgn}(d_i) · r)\]</p><p>where <span>$\textrm{sgn}(α) = 1$</span> if <span>$α ≥ 0$</span> and <span>$\textrm{sgn}(α) = -1$</span> if <span>$α &lt; 0$</span>.</p><p>For balls of higher dimension, we instead exploit that for a support vector <span>$v = σ(d, B) = c + \textrm{sgn}(d) · (r, …, r)ᵀ$</span> we have</p><p class="math-container">\[    ρ(d, B) = ⟨d, v⟩ = ⟨d, c⟩ + ⟨d, \textrm{sgn}(d) · (r, …, r)ᵀ⟩ = ⟨d, c⟩ + r · ∑_{i=1}^n |d_i|\]</p><p>where <span>$⟨·, ·⟩$</span> denotes the dot product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/BallInf/support_function.jl#L3-L30">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">ρ(d::AbstractVector, U::Universe)</code></pre><p><strong>Algorithm</strong></p><p>If the direction is all zero, the result is zero. Otherwise, the result is <code>Inf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/Universe/support_function.jl#L1-L10">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, P::SparsePolynomialZonotope; [enclosure_method]=nothing)</code></pre><p>Bound the support function of <span>$P$</span> in the direction <span>$d$</span>.</p><p><strong>Input</strong></p><ul><li><code>d</code>                – direction</li><li><code>P</code>                – sparse polynomial zonotope</li><li><code>enclosure_method</code> – (optional; default: <code>nothing</code>) method to use for                       enclosure; an <code>AbstractEnclosureAlgorithm</code> from the                       <a href="https://github.com/JuliaReach/RangeEnclosures.jl"><code>Rangeenclosures.jl</code></a>                       package</li></ul><p><strong>Output</strong></p><p>An overapproximation of the support function in the given direction.</p><p><strong>Algorithm</strong></p><p>This method implements <a href="../../bibliography/#Kochdumper21a">Kochdumper [Koc22]</a>, Proposition 3.1.16.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/SparsePolynomialZonotope/support_function.jl#L1-L22">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">ρ(d::AbstractVector, hs::HalfSpace)</code></pre><p><strong>Output</strong></p><p>Unless the direction is (a multiple of) the normal direction of the half-space, the result is <code>Inf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/HalfSpace/support_function.jl#L1-L10">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">ρ(d::AbstractVector, E::Ellipsoid)</code></pre><p><strong>Algorithm</strong></p><p>The support value is <span>$cᵀ d + ‖Bᵀ d‖₂$</span>, where <span>$c$</span> is the center and <span>$Q = B Bᵀ$</span> is the shape matrix of <code>E</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/Ellipsoid/support_function.jl#L1-L10">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">ρ(d::AbstractVector, H::Hyperplane)</code></pre><p><strong>Output</strong></p><p>If the set is unbounded in the given direction, the result is <code>Inf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/Hyperplane/support_function.jl#L1-L9">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">ρ(d::AbstractVector, X::LazySet)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation computes a support vector via <code>σ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Interfaces/LazySet.jl#L427-L435">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">ρ(d::AbstractVector, Z::AbstractZonotope)</code></pre><p><strong>Algorithm</strong></p><p>The support value is <span>$cᵀ d + ‖Gᵀ d‖₁$</span>, where <span>$c$</span> is the center and <span>$G$</span> is the generator matrix of <code>Z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Interfaces/AbstractZonotope.jl#L205-L214">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">ρ(d::AbstractVector, B::AbstractBallp)</code></pre><p><strong>Algorithm</strong></p><p>Let <span>$c$</span> and <span>$r$</span> be the center and radius of the ball <span>$B$</span> in the p-norm, respectively, and let <span>$q = \frac{p}{p-1}$</span>. Then:</p><p class="math-container">\[ρ(d, B) = ⟨d, c⟩ + r ‖d‖_q.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Interfaces/AbstractBallp.jl#L137-L150">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, cup::UnionSet)</code></pre><p>Evaluate the support function of the union of two sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cup</code> – union of two sets</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function in the given direction.</p><p><strong>Algorithm</strong></p><p>The support function of the union of two sets <span>$X$</span> and <span>$Y$</span> evaluates to the maximum of the support-function evaluations of <span>$X$</span> and <span>$Y$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/UnionSet.jl#L143-L161">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, B::Bloating)</code></pre><p>Return the support function of a bloated set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>B</code> – bloated set</li></ul><p><strong>Output</strong></p><p>The support function of the bloated set in the given direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/Bloating.jl#L96-L109">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, cp::CartesianProduct)</code></pre><p>Evaluate the support function of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function in the given direction. If the direction has norm zero, the result depends on the wrapped sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/CartesianProduct.jl#L182-L196">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, cpa::CartesianProductArray)</code></pre><p>Evaluate the support function of a Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cpa</code> – Cartesian product of a finite number of sets</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function in the given direction. If the direction has norm zero, the result depends on the wrapped sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/CartesianProductArray.jl#L181-L195">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, ch::ConvexHull)</code></pre><p>Evaluate the support function of the convex hull of two sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>ch</code> – convex hull of two sets</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function of the convex hull in the given direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/ConvexHull.jl#L133-L148">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, cha::ConvexHullArray)</code></pre><p>Evaluate the support function of a convex hull of a finite number of sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cha</code> – convex hull of a finite number of sets</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function of the convex hull of a finite number of sets in the given direction.</p><p><strong>Algorithm</strong></p><p>This algorithm calculates the maximum over all <span>$ρ(d, X_i)$</span>, where the <span>$X_1, …, X_k$</span> are the sets in the array of <code>cha</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/ConvexHullArray.jl#L113-L133">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, em::ExponentialMap;
  [backend]=get_exponential_backend())</code></pre><p>Evaluate the support function of the exponential map.</p><p><strong>Input</strong></p><ul><li><code>d</code>       – direction</li><li><code>em</code>      – exponential map</li><li><code>backend</code> – (optional; default: <code>get_exponential_backend()</code>) exponentiation              backend</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function in the given direction.</p><p><strong>Notes</strong></p><p>If <span>$E = \exp(M)⋅X$</span>, where <span>$M$</span> is a matrix and <span>$X$</span> is a set, it follows that <span>$ρ(d, E) = ρ(\exp(M)^T d, X)$</span> for any direction <span>$d$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/ExponentialMap.jl#L313-L334">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, eprojmap::ExponentialProjectionMap;
  [backend]=get_exponential_backend())</code></pre><p>Evaluate the support function of a projection of an exponential map.</p><p><strong>Input</strong></p><ul><li><code>d</code>        – direction</li><li><code>eprojmap</code> – projection of an exponential map</li><li><code>backend</code>  – (optional; default: <code>get_exponential_backend()</code>) exponentiation               backend</li></ul><p><strong>Output</strong></p><p>Evaluation of the support function in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$S = (L⋅M⋅R)⋅X$</span>, where <span>$L$</span> and <span>$R$</span> are matrices, <span>$M$</span> is a matrix exponential, and <span>$X$</span> is a set, it follows that <span>$ρ(d, S) = ρ(R^T⋅M^T⋅L^T⋅d, X)$</span> for any direction <span>$d$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/ExponentialProjectionMap.jl#L171-L194">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, cap::Intersection)</code></pre><p>Return an upper bound on the support function of the intersection of two sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cap</code> – intersection of two sets</li></ul><p><strong>Output</strong></p><p>An upper bound on the support function in the given direction.</p><p><strong>Algorithm</strong></p><p>The support function of an intersection of <span>$X$</span> and <span>$Y$</span> is upper-bounded by the minimum of the support-function evaluations for <span>$X$</span> and <span>$Y$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/Intersection.jl#L251-L270">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, cap::Intersection{N, S1, S2};
  algorithm::String=&quot;line_search&quot;, kwargs...
 ) where {N, S1&lt;:LazySet,
             S2&lt;:Union{HalfSpace, Hyperplane, Line2D}}</code></pre><p>Evaluate the support function of the intersection of a compact set and a half-space/hyperplane/line in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>         – direction</p></li><li><p><code>cap</code>       – lazy intersection of a compact set and a half-space/hyperplane/                line</p></li><li><p><code>algorithm</code> – (optional, default: <code>&quot;line_search&quot;</code>): the algorithm to                calculate the support function; valid options are:</p><ul><li><code>&quot;line_search&quot;</code> – solve the associated univariate optimization problem                    using a line-search method (either Brent or the                    Golden Section method)</li><li><code>&quot;projection&quot;</code>  – only valid for intersection with a hyperplane/line;                    evaluate the support function by reducing the problem                    to the 2D intersection of a rank-2 linear                    transformation of the given compact set in the plane                    generated by the given direction <code>d</code> and the                    hyperplane&#39;s normal vector <code>n</code></li><li><code>&quot;simple&quot;</code>      – take the <span>$\min$</span> of the support-function evaluation                    of each operand</li></ul></li></ul><p><strong>Output</strong></p><p>The scalar value of the support function of the set <code>cap</code> in the given direction.</p><p><strong>Notes</strong></p><p>It is assumed that the first set of the intersection (<code>cap.X</code>) is compact.</p><p>Any additional number of arguments to the algorithm backend can be passed as keyword arguments.</p><p><strong>Algorithm</strong></p><p>The algorithms are based on solving the associated optimization problem</p><p class="math-container">\[\min_{λ ∈ D_h} ρ(ℓ - λa, X) + λb.\]</p><p>where <span>$D_h = \{ λ : λ ≥ 0 \}$</span> if <span>$H$</span> is a half-space or <span>$D_h = \{ λ : λ ∈ ℝ \}$</span> if <span>$H$</span> is a hyperplane.</p><p>For additional information we refer to <a href="../../bibliography/#Frehse012">Frehse and Ray [FR12]</a>, <a href="../../bibliography/#LeGuernic09">Guernic [Gue09]</a> and <a href="../../bibliography/#RockafellarW98">Rockafellar and Wets [RW98]</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/Intersection.jl#L335-L387">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, cap::Intersection{N, S1, S2};
  kwargs...) where {N, S1&lt;:LazySet, S2&lt;:AbstractPolyhedron}</code></pre><p>Return an upper bound on the support function of the intersection between a compact set and a polyhedron along a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>      – direction</li><li><code>cap</code>    – intersection of a compact set and a polyhedron</li><li><code>kwargs</code> – additional arguments that are passed to the support-function             algorithm</li></ul><p><strong>Output</strong></p><p>An upper bound of the support function of the given intersection.</p><p><strong>Algorithm</strong></p><p>The idea is to solve the univariate optimization problem <code>ρ(di, X ∩ Hi)</code> for each half-space in the polyhedron and then take the minimum. This gives an overapproximation of the exact support value.</p><p>This algorithm is inspired from <a href="../../bibliography/#Frehse012">Frehse and Ray [FR12]</a>.</p><p><strong>Notes</strong></p><p>This method relies on the <code>constraints_list</code> of the polyhedron.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/Intersection.jl#L403-L432">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, cap::Intersection{N, S1, S2}; kwargs...
 ) where {N, S1&lt;:AbstractPolyhedron, S2&lt;:AbstractPolyhedron}</code></pre><p>Evaluate the support function of the intersection between two polyhedral sets.</p><p><strong>Input</strong></p><ul><li><code>d</code>      – direction</li><li><code>cap</code>    – intersection of two polyhedral sets</li><li><code>kwargs</code> – additional arguments that are passed to the support-function             algorithm</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function in the given direction.</p><p><strong>Algorithm</strong></p><p>We combine the constraints of the two polyhedra to a new <code>HPolyhedron</code>, for which we then evaluate the support function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/Intersection.jl#L471-L492">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, lm::LinearMap; kwargs...)</code></pre><p>Evaluate the support function of the linear map.</p><p><strong>Input</strong></p><ul><li><code>d</code>      – direction</li><li><code>lm</code>     – linear map</li><li><code>kwargs</code> – additional arguments that are passed to the support function             algorithm</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$L = M⋅S$</span>, where <span>$M$</span> is a matrix and <span>$S$</span> is a set, it follows that <span>$ρ(d, L) = ρ(M^T d, S)$</span> for any direction <span>$d$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/LinearMap.jl#L268-L289">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, ilm::InverseLinearMap)</code></pre><p>Evaluate the support function of the inverse linear map.</p><p><strong>Input</strong></p><ul><li><code>d</code>      – direction</li><li><code>ilm</code>    – inverse linear map</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$L = M^{-1}⋅X$</span>, where <span>$M$</span> is a matrix and <span>$X$</span> is a set, it follows that <span>$ρ(d, L) = ρ((M^T)^{-1} d, X)$</span> for any direction <span>$d$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/InverseLinearMap.jl#L172-L191">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, ms::MinkowskiSum)</code></pre><p>Evaluate the support function of a Minkowski sum of two sets.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>ms</code> – Minkowski sum of two sets</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function in the given direction.</p><p><strong>Algorithm</strong></p><p>The support function in direction <span>$d$</span> of the Minkowski sum of two sets <span>$X$</span> and <span>$Y$</span> is the sum of the support functions of <span>$X$</span> and <span>$Y$</span> in direction <span>$d$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/MinkowskiSum.jl#L136-L155">source</a></section><section><div><p>ρ(d::AbstractVector, msa::MinkowskiSumArray)</p><p>Evaluate the support function of a Minkowski sum of a finite number of sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>msa</code> – Minkowski sum of a finite number of sets</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function in the given direction.</p><p><strong>Algorithm</strong></p><p>The support function of the Minkowski sum of multiple sets evaluations to the sum of the support-function evaluations of each set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/MinkowskiSumArray.jl#L129-L148">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, rm::ResetMap)</code></pre><p>Evaluate the support function of a reset map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>rm</code> – reset map</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function in the given direction.</p><p><strong>Notes</strong></p><p>We use the usual dot-product definition, but for unbounded sets we redefine the product between <span>$0$</span> and <span>$±∞$</span> as <span>$0$</span>; Julia returns <code>NaN</code> here.</p><pre><code class="language-julia-repl hljs">julia&gt; Inf * 0.0
NaN</code></pre><p>See the discussion <a href="https://math.stackexchange.com/q/28940">here</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/ResetMap.jl#L220-L245">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, tr::Translation)</code></pre><p>Evaluate the support function of a translation.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>tr</code> – translation of a set</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function in the given direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/Translation.jl#L233-L246">source</a></section><section><div><p>ρ(d::AbstractVector, cup::UnionSetArray)</p><p>Evaluate the support function of the union of a finite number of sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cup</code> – union of a finite number of sets</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function in the given direction.</p><p><strong>Algorithm</strong></p><p>The support function of the union of a finite number of sets <span>$X₁, X₂, ...$</span> can be obtained as the maximum of <span>$ρ(d, X₂), ρ(d, X₂), ...$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/UnionSetArray.jl#L144-L163">source</a></section><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, R::Rectification)</code></pre><p>Evaluate the support function of a rectification in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>R</code> – rectification</li></ul><p><strong>Output</strong></p><p>The support value of the rectification in the given direction.</p><p><strong>Algorithm</strong></p><p>We use different procedures for different types of input sets. If the wrapped set has a suitable structure for which we can efficiently compute the support vector, we fall back to the evaluation of the support function by means of the support vector. Otherwise we compute the union of projections to obtain a precise result (see <a href="../lazy_operations/Rectification/#LazySets.to_union_of_projections"><code>to_union_of_projections</code></a>), and then compute the support function for this union. (The union is cached internally, so subsequent queries are more efficient.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/Rectification.jl#L280-L304">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">ρ(d::AbstractVector{M}, P::HPoly{N};
  solver=default_lp_solver(M, N)) where {M, N}</code></pre><p><strong>Input</strong></p><ul><li><code>solver</code> – (optional, default: <code>default_lp_solver(M, N)</code>) the backend used to             solve the linear program</li></ul><p><strong>Output</strong></p><p>If <code>P</code> is unbounded in the given direction, there are two cases:</p><ul><li>If <code>P</code> is an <code>HPolytope</code>, we throw an error.</li><li>If <code>P</code> is an <code>HPolyedron</code>, the result is <code>Inf</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/HPolyhedron/support_function.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}" href="#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}"><code>LazySets.API.σ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, X::LazySet)</code></pre><p>Compute a support vector of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A support vector of <code>X</code> in direction <code>d</code>.</p><p><strong>Notes</strong></p><p>A convenience alias <code>support_vector</code> is also available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Mixed/support_vector.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.support_vector" href="#LazySets.API.support_vector"><code>LazySets.API.support_vector</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">σ(d::AbstractVector, P::VPolygon)</code></pre><p><strong>Output</strong></p><p>If the direction has norm zero, the first vertex is returned.</p><p><strong>Algorithm</strong></p><p>This implementation uses a binary search algorithm when the polygon has more than 10 vertices and a brute-force search when it has 10 or fewer vertices. The brute-force search compares the projection of each vector along the given direction and runs in <span>$O(n)$</span> where <span>$n$</span> is the number of vertices. The binary search runs in <span>$O(log n)$</span> and we follow <a href="http://geomalgorithms.com/a14-_extreme_pts.html#polyMax_2D()">this implementation</a> based on an algorithm described in <a href="../../bibliography/#ORourke98">O’Rourke [O’R98]</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/VPolygon/support_vector.jl#L6-L25">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, X::LazySet)</code></pre><p>Compute a support vector of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A support vector of <code>X</code> in direction <code>d</code>.</p><p><strong>Notes</strong></p><p>A convenience alias <code>support_vector</code> is also available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Mixed/support_vector.jl#L1-L18">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">σ(d::AbstractVector, B::Ball2)</code></pre><p><strong>Notes</strong></p><p>Let <span>$c$</span> and <span>$r$</span> be the center and radius of a ball <span>$B$</span> in the 2-norm, respectively. For nonzero direction <span>$d$</span> we have</p><p class="math-container">\[σ(d, B) = c + r \frac{d}{‖d‖_2}.\]</p><p>This function requires computing the 2-norm of the input direction, which is performed in the given precision of the numeric datatype of both the direction and the set. Exact inputs are not supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/Ball2/support_vector.jl#L1-L20">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">σ(d::AbstractVector, L::LineSegment)</code></pre><p><strong>Algorithm</strong></p><p>If the angle between the vector <span>$q - p$</span> and <span>$d$</span> is bigger than 90° and less than 270° (measured in counter-clockwise order), the result is <span>$p$</span>, otherwise it is <span>$q$</span>. If the angle is exactly 90° or 270°, or if the direction has norm zero, this implementation returns <span>$q$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/LineSegment/support_vector.jl#L1-L13">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">σ(d::AbstractVector, U::Universe)</code></pre><p><strong>Output</strong></p><p>A vector with infinity values, except in dimensions where the direction is zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/Universe/support_vector.jl#L1-L9">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">σ(d::AbstractVector, hs::HalfSpace)</code></pre><p><strong>Output</strong></p><p>The support vector in the given direction, which is only defined in the following two cases:</p><ol><li>The direction has norm zero.</li><li>The direction is (a multiple of) the normal direction of the half-space.</li></ol><p>In both cases the result is any point on the boundary (the defining hyperplane). Otherwise this function throws an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/HalfSpace/support_vector.jl#L1-L14">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">σ(d::AbstractVector, E::Ellipsoid)</code></pre><p><strong>Algorithm</strong></p><p>Let <span>$E$</span> be an ellipsoid of center <span>$c$</span> and shape matrix <span>$Q = BB^\mathrm{T}$</span>. Its support vector along direction <span>$d$</span> can be deduced from that of the unit Euclidean ball <span>$\mathcal{B}_2$</span> using the algebraic relations for the support vector,</p><p class="math-container">\[σ_{B\mathcal{B}_2 ⊕ c}(d) = c + Bσ_{\mathcal{B}_2} (B^\mathrm{T} d)
= c + \dfrac{Qd}{\sqrt{d^\mathrm{T}Q d}}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/Ellipsoid/support_vector.jl#L1-L17">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">σ(d::AbstractVector, P::VPolytope)</code></pre><p><strong>Algorithm</strong></p><p>A support vector maximizes the support function. For a polytope, the support function is always maximized in some vertex. Hence it is sufficient to check all vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/VPolytope/support_vector.jl#L1-L11">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">σ(d::AbstractVector, H::Hyperplane)</code></pre><p><strong>Output</strong></p><p>A support vector in the given direction, which is only defined in the following two cases:</p><ol><li>The direction has norm zero.</li><li>The direction is the hyperplane&#39;s normal direction or its opposite direction.</li></ol><p>In all cases, any point on the hyperplane is a solution. Otherwise this function throws an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/Hyperplane/support_vector.jl#L1-L14">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">σ(d::AbstractVector, T::Tetrahedron)</code></pre><p><strong>Algorithm</strong></p><p>This method falls back to the <code>VPolytope</code> implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/Tetrahedron/support_vector.jl#L1-L9">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">σ(d::AbstractVector, Z::AbstractZonotope)</code></pre><p><strong>Notes</strong></p><p>If the direction has norm zero, the vertex with <span>$ξ_i = 1 \ \ ∀ i = 1,…, p$</span> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Interfaces/AbstractZonotope.jl#L221-L230">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">σ(d::AbstractVector, H::AbstractHyperrectangle)</code></pre><p><strong>Notes</strong></p><p>If the direction vector is zero in dimension <span>$i$</span>, the result will have the center&#39;s coordinate in that dimension. For instance, for the two-dimensional infinity-norm ball, if the direction points to the right, the result is the vector <code>[1, 0]</code> in the middle of the right-hand facet.</p><p>If the direction has norm zero, the result can be any point in <code>H</code>. The default implementation returns the center of <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Interfaces/AbstractHyperrectangle.jl#L268-L282">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">σ(d::AbstractVector, S::AbstractSingleton)</code></pre><p><strong>Algorithm</strong></p><p>The support vector is the set&#39;s vector itself, irrespective of the given direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Interfaces/AbstractSingleton.jl#L125-L134">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">σ(d::AbstractVector, B::AbstractBallp)</code></pre><p><strong>Algorithm</strong></p><p>The support vector of the unit ball in the <span>$p$</span>-norm along direction <span>$d$</span> is:</p><p class="math-container">\[σ(d, \mathcal{B}_p^n(0, 1)) = \dfrac{\tilde{v}}{‖\tilde{v}‖_q},\]</p><p>where <span>$\tilde{v}_i = \frac{|d_i|^q}{d_i}$</span> if <span>$d_i ≠ 0$</span> and <span>$\tilde{v}_i = 0$</span> otherwise, for all <span>$i=1,…,n$</span>, and <span>$q$</span> is the conjugate number of <span>$p$</span>. By the affine transformation <span>$x = r\tilde{x} + c$</span>, one obtains that the support vector of <span>$\mathcal{B}_p^n(c, r)$</span> is</p><p class="math-container">\[σ(d, \mathcal{B}_p^n(c, r)) = \dfrac{v}{‖v‖_q},\]</p><p>where <span>$v_i = c_i + r\frac{|d_i|^q}{d_i}$</span> if <span>$d_i ≠ 0$</span> and <span>$v_i = 0$</span> otherwise, for all <span>$i = 1, …, n$</span>.</p><p>If the direction has norm zero, the center of the ball is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Interfaces/AbstractBallp.jl#L94-L119">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, P::HPolygonOpt;
  [linear_search]::Bool=(length(P.constraints) &lt; 10))</code></pre><p>Return a support vector of an optimized polygon in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>             – direction</li><li><code>P</code>             – optimized polygon in constraint representation</li><li><code>linear_search</code> – (optional, default: see below) flag for controlling whether                    to perform a linear search or a binary search</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. The result is always one of the vertices; in particular, if the direction has norm zero, any vertex is returned.</p><p><strong>Algorithm</strong></p><p>Comparison of directions is performed using polar angles; see the definition of <code>⪯</code> for two-dimensional vectors.</p><p>For polygons with 10 or more constraints we use a binary search by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/HPolygonOpt.jl#L107-L133">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, cup::UnionSet; [algorithm]=&quot;support_vector&quot;)</code></pre><p>Return a support vector of the union of two sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>         – direction</li><li><code>cup</code>       – union of two sets</li><li><code>algorithm</code> – (optional, default: &quot;support<em>vector&quot;): the algorithm to compute                the support vector; if &quot;support</em>vector&quot;, use the support                vector of each argument; if &quot;support_function&quot; use the support                function of each argument and evaluate the support vector of                only one of them</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>The support vector of the union of two sets <span>$X$</span> and <span>$Y$</span> can be obtained as the vector that maximizes the support function of either <span>$X$</span> or <span>$Y$</span>, i.e., it is sufficient to find the <span>$\argmax(ρ(d, X), ρ(d, Y)])$</span> and evaluate its support vector.</p><p>The default implementation, with option <code>algorithm=&quot;support_vector&quot;</code>, computes the support vector of <span>$X$</span> and <span>$Y$</span> and then compares the support function using a dot product.</p><p>If the support function can be computed more efficiently, the alternative implementation <code>algorithm=&quot;support_function&quot;</code> can be used, which evaluates the support function of each set directly and then calls only the support vector of either <span>$X$</span> <em>or</em> <span>$Y$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/UnionSet.jl#L91-L125">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, B::Bloating)</code></pre><p>Return the support vector of a bloated set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>B</code> – bloated set</li></ul><p><strong>Output</strong></p><p>The support vector of the bloated set in the given direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/Bloating.jl#L73-L86">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, cp::CartesianProduct)</code></pre><p>Return a support vector of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction. If the direction has norm zero, the result depends on the wrapped sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/CartesianProduct.jl#L150-L164">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, cpa::CartesianProductArray)</code></pre><p>Compute a support vector of a Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cpa</code> – Cartesian product of a finite number of sets</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction. If the direction has norm zero, the result depends on the product sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/CartesianProductArray.jl#L98-L112">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, ch::ConvexHull)</code></pre><p>Return a support vector of the convex hull of two sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>ch</code> – convex hull of two sets</li></ul><p><strong>Output</strong></p><p>A support vector of the convex hull in the given direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/ConvexHull.jl#L111-L124">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, cha::ConvexHullArray)</code></pre><p>Return a support vector of a convex hull of a finite number of sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cha</code> – convex hull of a finite number of sets</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/ConvexHullArray.jl#L93-L107">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, em::ExponentialMap;
  [backend]=get_exponential_backend())</code></pre><p>Return a support vector of an exponential map.</p><p><strong>Input</strong></p><ul><li><code>d</code>       – direction</li><li><code>em</code>      – exponential map</li><li><code>backend</code> – (optional; default: <code>get_exponential_backend()</code>) exponentiation              backend</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$E = \exp(M)⋅X$</span>, where <span>$M$</span> is a matrix and <span>$X$</span> is a set, it follows that <span>$σ(d, E) = \exp(M)⋅σ(\exp(M)^T d, X)$</span> for any direction <span>$d$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/ExponentialMap.jl#L283-L305">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, eprojmap::ExponentialProjectionMap;
  [backend]=get_exponential_backend())</code></pre><p>Return a support vector of a projection of an exponential map.</p><p><strong>Input</strong></p><ul><li><code>d</code>        – direction</li><li><code>eprojmap</code> – projection of an exponential map</li><li><code>backend</code>  – (optional; default: <code>get_exponential_backend()</code>) exponentiation               backend</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$S = (L⋅M⋅R)⋅X$</span>, where <span>$L$</span> and <span>$R$</span> are matrices, <span>$M$</span> is a matrix exponential, and <span>$X$</span> is a set, it follows that <span>$σ(d, S) = L⋅M⋅R⋅σ(R^T⋅M^T⋅L^T⋅d, X)$</span> for any direction <span>$d$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/ExponentialProjectionMap.jl#L135-L158">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, cap::Intersection)</code></pre><p>Return a support vector of an intersection of two sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cap</code> – intersection of two sets</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>We compute the concrete intersection, which may be expensive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/Intersection.jl#L227-L245">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, ia::IntersectionArray)</code></pre><p>Return a support vector of an intersection of a finite number of sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>ia</code> – intersection of a finite number of sets</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction. If the direction has norm zero, the result depends on the individual sets.</p><p><strong>Algorithm</strong></p><p>This implementation computes the concrete intersection, which can be expensive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/IntersectionArray.jl#L90-L109">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, lm::LinearMap)</code></pre><p>Return a support vector of the linear map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>lm</code> – linear map</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$L = M⋅S$</span>, where <span>$M$</span> is a matrix and <span>$S$</span> is a set, it follows that <span>$σ(d, L) = M⋅σ(M^T d, S)$</span> for any direction <span>$d$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/LinearMap.jl#L240-L259">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, ilm::InverseLinearMap)</code></pre><p>Return a support vector of a inverse linear map.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>ilm</code> – inverse linear map</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$L = M^{-1}⋅X$</span>, where <span>$M$</span> is a matrix and <span>$X$</span> is a set, since (M^T)^{-1}=(M^{-1})^T, it follows that <span>$σ(d, L) = M^{-1}⋅σ((M^T)^{-1} d, X)$</span> for any direction <span>$d$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/InverseLinearMap.jl#L146-L166">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, ms::MinkowskiSum)</code></pre><p>Return a support vector of a Minkowski sum of two sets.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>ms</code> – Minkowski sum of two sets</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.</p><p><strong>Algorithm</strong></p><p>A valid support vector in direction <span>$d$</span> of the Minkowski sum of two sets <span>$X$</span> and <span>$Y$</span> is the sum of the support vectors of <span>$X$</span> and <span>$Y$</span> in direction <span>$d$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/MinkowskiSum.jl#L111-L131">source</a></section><section><div><p>σ(d::AbstractVector, msa::MinkowskiSumArray)</p><p>Return a support vector of a Minkowski sum of a finite number of sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>msa</code> – Minkowski sum of a finite number of sets</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/MinkowskiSumArray.jl#L105-L120">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, cms::CachedMinkowskiSumArray)</code></pre><p>Return a support vector of a cached Minkowski sum in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cms</code> – cached Minkowski sum</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.</p><p><strong>Notes</strong></p><p>The result is cached, i.e., any further query with the same direction runs in constant time. When sets are added to the cached Minkowski sum, the query is only performed for the new sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/CachedMinkowskiSumArray.jl#L117-L138">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, rm::ResetMap)</code></pre><p>Return a support vector of a reset map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>rm</code> – reset map</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/ResetMap.jl#L196-L210">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, sih::SymmetricIntervalHull)</code></pre><p>Return a support vector of the symmetric interval hull of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>sih</code> – symmetric interval hull of a set</li></ul><p><strong>Output</strong></p><p>A support vector of the symmetric interval hull of a set in the given direction. If the direction has norm zero, the origin is returned.</p><p><strong>Algorithm</strong></p><p>For each non-zero entry in <code>d</code> we need to either look up the bound (if it has been computed before) or compute it, in which case we store it for future queries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/SymmetricIntervalHull.jl#L184-L205">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, tr::Translation)</code></pre><p>Return a support vector of a translation.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>tr</code> – translation of a set</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/Translation.jl#L214-L228">source</a></section><section><div><p>σ(d::AbstractVector, cup::UnionSetArray; [algorithm]=&quot;support_vector&quot;)</p><p>Return a support vector of the union of a finite number of sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>         – direction</li><li><code>cup</code>       – union of a finite number of sets</li><li><code>algorithm</code> – (optional, default: &quot;support<em>vector&quot;): the algorithm to compute                the support vector; if &quot;support</em>vector&quot;, use the support                vector of each argument; if &quot;support_function&quot;, use the support                function of each argument and evaluate the support vector of                only one of them</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>The support vector of the union of a finite number of sets <span>$X₁, X₂, ...$</span> can be obtained as the vector that maximizes the support function, i.e., it is sufficient to find the <span>$\argmax([ρ(d, X₂), ρ(d, X₂), ...])$</span> and evaluate its support vector.</p><p>The default implementation, with option <code>algorithm=&quot;support_vector&quot;</code>, computes the support vector of all <span>$X₁, X₂, ...$</span> and then compares the support function using the dot product.</p><p>If the support function can be computed more efficiently, the alternative implementation <code>algorithm=&quot;support_function&quot;</code> can be used, which evaluates the support function of each set directly and then calls only the support vector of one of the <span>$Xᵢ$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/UnionSetArray.jl#L77-L112">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, R::Rectification)</code></pre><p>Return a support vector of a rectification.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>R</code> – rectification</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/Rectification.jl#L157-L171">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, R::Rectification{N, &lt;:AbstractHyperrectangle}) where {N}</code></pre><p>Return a support vector of the rectification of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>R</code> – rectification of a hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>Let <span>$R(·)$</span> be the rectification of a vector respectively a set, and let <span>$H$</span> be a hyperrectangle. Then <span>$σ_{R(H)}(d) = R(σ_{H}(d))$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/Rectification.jl#L177-L195">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, R::Rectification{N, &lt;:CartesianProduct}) where {N}</code></pre><p>Return a support vector of the rectification of a Cartesian product of two sets.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>R</code> – rectification of a Cartesian product of two sets</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction.</p><p><strong>Notes</strong></p><p>Note that this implementation creates new <code>Rectification</code> objects that do not get preserved. Hence a second support-vector query does not benefit from the computations in the first query. For this use case another implementation should be added.</p><p><strong>Algorithm</strong></p><p>Rectification distributes with the Cartesian product. Let <span>$R(·)$</span> be the rectification of a set. We can just query a support vector for <span>$R(X)$</span> and <span>$R(Y)$</span> recursively: <span>$σ_{R(X × Y)}(d) = σ_{R(X)}(d_X) × σ_{R(Y)}(d_Y)$</span>, where <span>$x × y$</span> concatenates vectors <span>$x$</span> and <span>$y$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/Rectification.jl#L200-L228">source</a></section><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector,
  R::Rectification{N, &lt;:CartesianProductArray}) where {N}</code></pre><p>Return a support vector of the rectification of a Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>R</code> – rectification of a Cartesian product of a finite number of sets</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction.</p><p><strong>Notes</strong></p><p>Note that this implementation creates new <code>Rectification</code> objects that do not get preserved. Hence a second support-vector query does not benefit from the computations in the first query. For this use case another implementation should be added.</p><p><strong>Algorithm</strong></p><p>Rectification distributes with the Cartesian product. Let <span>$R(·)$</span> be the rectification of a set. We can just query a support vector for each subspace recursively: <span>$σ_{R(X_1 × ⋯ × X_m)}(d) = σ_{R(X_1)}(d_{X_1}) × ⋯ × σ_{R(X_m)}(d_{X_m})$</span>, where <span>$x × y$</span> concatenates vectors <span>$x$</span> and <span>$y$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/LazyOperations/Rectification.jl#L236-L266">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">σ(d::AbstractVector{M}, P::HPoly{N};
  solver=default_lp_solver(M, N) where {M, N}</code></pre><p><strong>Input</strong></p><ul><li><code>solver</code> – (optional, default: <code>default_lp_solver(M, N)</code>) the backend used to             solve the linear program</li></ul><p><strong>Output</strong></p><p>If <code>P</code> is unbounded in the given direction, there are two cases:</p><ul><li>If <code>P</code> is an <code>HPolytope</code>, we throw an error.</li><li>If <code>P</code> is an <code>HPolyedron</code>, the result contains <code>±Inf</code> entries.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/HPolyhedron/support_vector.jl#L1-L17">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">σ(d::AbstractVector, P::HPolygon;
  [linear_search]::Bool=(length(P.constraints) &lt; 10))</code></pre><p><strong>Input</strong></p><ul><li><code>linear_search</code> – (optional, default: see below) flag for controlling whether                    to perform a linear search or a binary search</li></ul><p><strong>Output</strong></p><p>The result is always one of the vertices; in particular, if the direction has norm zero, any vertex is returned.</p><p><strong>Algorithm</strong></p><p>Comparison of directions is performed using polar angles; see the definition of <code>⪯</code> for two-dimensional vectors.</p><p>For polygons with 10 or more constraints we use a binary search by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/Sets/HPolygon/support_vector.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.translate-Tuple{LazySets.API.LazySet, AbstractVector}" href="#LazySets.API.translate-Tuple{LazySets.API.LazySet, AbstractVector}"><code>LazySets.API.translate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translate(X::LazySet, v::AbstractVector)</code></pre><p>Compute the translation of a set with a vector.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>v</code> – vector</li></ul><p><strong>Output</strong></p><p>A set representing <span>$X + \{v\}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Mixed/translate.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.translate!-Tuple{LazySets.API.LazySet, AbstractVector}" href="#LazySets.API.translate!-Tuple{LazySets.API.LazySet, AbstractVector}"><code>LazySets.API.translate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translate!(X::LazySet, v::AbstractVector)</code></pre><p>Translate a set with a vector by modifying it.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>v</code> – vector</li></ul><p><strong>Output</strong></p><p>The translated set representing <span>$X + \{v\}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Mixed/translate!.jl#L1-L14">source</a></section></article><h1 id="Binary-set-functions"><a class="docs-heading-anchor" href="#Binary-set-functions">Binary set functions</a><a id="Binary-set-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-set-functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.cartesian_product-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.cartesian_product-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.cartesian_product</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cartesian_product(X::LazySet, Y::LazySet)</code></pre><p>Compute the Cartesian product of two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the Cartesian product <span>$X × Y$</span>.</p><p><strong>Notes</strong></p><p>The Cartesian product of two sets <span>$X$</span> and <span>$Y$</span> is defined as</p><p class="math-container">\[    X × Y = \{[x, y] \mid x ∈ X, y ∈ Y\}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Binary/cartesian_product.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.convex_hull-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.convex_hull-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.convex_hull</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convex_hull(X::LazySet, Y::LazySet)</code></pre><p>Compute the convex hull of (the union of) two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the convex hull of <span>$X ∪ Y$</span>.</p><p><strong>Notes</strong></p><p>See <a href="#LazySets.API.convex_hull-Tuple{LazySets.API.LazySet}"><code>convex_hull(::LazySet)</code></a> for the convex hull of a single set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Binary/convex_hull.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.difference</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">difference(X::LazySet, Y::LazySet)</code></pre><p>Compute the set difference of two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the difference <span>$X ∖ Y$</span>.</p><p><strong>Notes</strong></p><p>The set difference is defined as:</p><p class="math-container">\[    X ∖ Y = \{x \mid x ∈ X \text{ and } x ∉ Y \}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Binary/difference.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityBase.Arrays.distance-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#ReachabilityBase.Arrays.distance-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>ReachabilityBase.Arrays.distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance(X::LazySet, Y::LazySet; [p]::Real=2)</code></pre><p>Compute the standard distance (induced by the <span>$p$</span>-norm) between two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li><li><code>p</code> – (optional; default: <code>2</code>) value of the <span>$p$</span>-norm</li></ul><p><strong>Output</strong></p><p>A real number representing the distance between <code>X</code> and <code>Y</code>.</p><p><strong>Notes</strong></p><p>The standard distance is zero if the sets intersect, and infinite if one of the sets is empty. Otherwise, it is the <span>$p$</span>-norm of the shortest line segment between any pair of points. Formally,</p><p class="math-container">\[    \inf_{x ∈ X, y ∈ Y} \{ d(x, y) \}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Binary/distance.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.exact_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.exact_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.exact_sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exact_sum(X::LazySet, Y::LazySet)</code></pre><p>Compute the exact sum of two parametric sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – parametric set</li><li><code>Y</code> – parametric set</li></ul><p><strong>Output</strong></p><p>A set representing the exact sum, sometimes written <span>$X ⊞ Y$</span>.</p><p><strong>Notes</strong></p><p>For parametric sets, the exact sum behaves like the Minkowski sum, except that the parameters are shared. Thus, for nonparametric sets, it coincides with the Minkowski sum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Binary/exact_sum.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.intersection-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.intersection-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.intersection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intersection(X::LazySet, Y::LazySet)</code></pre><p>Compute the intersection of two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the intersection <span>$X ∩ Y$</span>.</p><p><strong>Notes</strong></p><p>The intersection of two sets <span>$X$</span> and <span>$Y$</span> is defined as</p><p class="math-container">\[    X ∩ Y = \{x \mid x ∈ X \text{ and } x ∈ Y\}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Binary/intersection.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:≈-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#Base.:≈-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>Base.:≈</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">≈(X::LazySet, Y::LazySet)</code></pre><p>Check whether two sets of the same type are approximately equal.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set of the same base type as <code>X</code></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>X</code> is approximately equal to <code>Y</code>.</p><p><strong>Notes</strong></p><p>The check is purely syntactic and the sets need to have the same base type, i.e., <code>X::T1 ≈ Y::T2</code> always returns <code>false</code> even if <code>X</code> and <code>Y</code> represent the same set. But <code>X::T{Int64} ≈ Y::T{Float64}</code> is a valid comparison.</p><p>The convenience alias <code>isapprox</code> is also available.</p><p>&quot;<code>≈</code>&quot; can be typed by <code>\approx&lt;tab&gt;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Binary/isapprox.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isdisjoint-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#Base.isdisjoint-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>Base.isdisjoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isdisjoint(X::LazySet, Y::LazySet, [witness]::Bool=false)</code></pre><p>Check whether two sets are disjoint (i.e., do not intersect), and optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>Y</code>       – set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If the <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ∩ Y = ∅$</span></li><li>If the <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ∩ Y = ∅$</span></li><li><code>(false, v)</code> iff <span>$X ∩ Y ≠ ∅$</span> for some <span>$v ∈ X ∩ Y$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>The convenience alias <code>is_intersection_empty</code> is also available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Binary/isdisjoint.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.is_intersection_empty" href="#LazySets.API.is_intersection_empty"><code>LazySets.API.is_intersection_empty</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_intersection_empty(X::LazySet, Y::LazySet, [witness]::Bool=false)</code></pre><p>Convenience alias for the <code>isdisjoint</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Binary/isdisjoint.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:==-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#Base.:==-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">==(X::LazySet, Y::LazySet)</code></pre><p>Check whether two sets use exactly the same set representation.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>X</code> is equal to <code>Y</code>.</p><p><strong>Notes</strong></p><p>The check is purely syntactic and the sets need to have the same base type, i.e., <code>X::T1 == Y::T2</code> always returns <code>false</code> even if <code>X</code> and <code>Y</code> represent the same set. But <code>X::T{Int64} == Y::T{Float64}</code> is a valid comparison.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Binary/isequal.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isequivalent-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.isequivalent-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.isequivalent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isequivalent(X::LazySet, Y::LazySet)</code></pre><p>Check whether two sets are equivalent, i.e., represent the same set of points.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>X</code> is equivalent to <code>Y</code> (up to numerical precision).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Binary/isequivalent.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.:⊂-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.:⊂-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.:⊂</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">⊂(X::LazySet, Y::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a set is a strict subset of another set, and optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>Y</code>       – set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If the <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊂ Y$</span></li><li>If the <code>witness</code> option is activated:<ul><li><code>(true, v)</code> iff <span>$X ⊂ Y$</span> for some <span>$v ∈ Y ∖ X$</span></li><li><code>(false, [])</code> iff <span>$X ⊂ Y$</span> does not hold</li></ul></li></ul><p><strong>Notes</strong></p><p>Strict inclusion is sometimes written as <code>⊊</code>. The following identity holds:</p><p class="math-container">\[    X ⊂ Y ⇔ X ⊆ Y ∧ Y ⊈ X\]</p><p><strong>Algorithm</strong></p><p>The default implementation first checks inclusion of <code>X</code> in <code>Y</code> and then checks noninclusion of <code>Y</code> in <code>X</code>:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Binary/isstrictsubset.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#Base.:⊆-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">⊆(X::LazySet, Y::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a set is a subset of another set, and optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>Y</code>       – set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If the <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊆ Y$</span></li><li>If the <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ⊆ Y$</span></li><li><code>(false, v)</code> iff <span>$X ⊈ Y$</span> for some <span>$v ∈ X ∖ Y$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>The convenience alias <code>issubset</code> is also available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Binary/issubset.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.linear_combination-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.linear_combination-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.linear_combination</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_combination(X::LazySet, Y::LazySet)</code></pre><p>Compute the linear combination of two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the linear combination of <code>X</code> and <code>Y</code>.</p><p><strong>Notes</strong></p><p>The linear combination of two sets <span>$X$</span> and <span>$Y$</span> is defined as</p><p class="math-container">\[    \left\{\frac{1}{2}(1+λ)x + \frac{1}{2}(1-λ)y \mid x ∈ X, y ∈ Y, λ ∈ [-1, 1]\right\}.\]</p><p>If <span>$X$</span> and <span>$Y$</span> are convex, their linear combination is identical with the convex hull of their union <span>$X ∪ Y$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Binary/linear_combination.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.minkowski_difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.minkowski_difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.minkowski_difference</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minkowski_difference(X::LazySet, Y::LazySet)</code></pre><p>Compute the Minkowski difference of two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the Minkowski difference <span>$X ⊖ Y$</span>.</p><p><strong>Notes</strong></p><p>The Minkowski difference of two sets <span>$X$</span> and <span>$Y$</span> is defined as</p><p class="math-container">\[    X ⊖ Y = \{z \mid \{z\} ⊕ Y ⊆ X\}\]</p><p>The convenience alias <code>pontryagin_difference</code> is also available.</p><p>There is some inconsistency in the literature regarding the naming conventions. In this library, both <em>Minkowski difference</em> and <em>Pontryagin difference</em> refer to the geometric difference of two sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Binary/minkowski_difference.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.pontryagin_difference" href="#LazySets.API.pontryagin_difference"><code>LazySets.API.pontryagin_difference</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pontryagin_difference(X::LazySet, Y::LazySet)</code></pre><p>Convenience alias for the <code>minkowski_difference</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Binary/minkowski_difference.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.minkowski_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.minkowski_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.minkowski_sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minkowski_sum(X::LazySet, Y::LazySet)</code></pre><p>Compute the Minkowski sum of two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the Minkowski sum <span>$X ⊕ Y$</span>.</p><p><strong>Notes</strong></p><p>The Minkowski sum of two sets <span>$X$</span> and <span>$Y$</span> is defined as</p><p class="math-container">\[    X ⊕ Y = \{x + y \mid x ∈ X, y ∈ Y\}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e68cbb5d6db3dd36b8706c42ef8b2cf4ff3ddc0a/src/API/Binary/minkowski_sum.jl#L1-L22">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/lazy_intersections/">« Lazy Intersections</a><a class="docs-footer-nextpage" href="../interfaces/overview/">Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Wednesday 2 April 2025 05:22">Wednesday 2 April 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
