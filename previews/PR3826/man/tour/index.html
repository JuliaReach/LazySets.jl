<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A Tour of LazySets · LazySets.jl</title><meta name="title" content="A Tour of LazySets · LazySets.jl"/><meta property="og:title" content="A Tour of LazySets · LazySets.jl"/><meta property="twitter:title" content="A Tour of LazySets · LazySets.jl"/><meta name="description" content="Documentation for LazySets.jl."/><meta property="og:description" content="Documentation for LazySets.jl."/><meta property="twitter:description" content="Documentation for LazySets.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/aligned.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LazySets.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../optional_dependencies/">Optional Features</a></li><li class="is-active"><a class="tocitem" href>A Tour of LazySets</a><ul class="internal"><li><a class="tocitem" href="#Creating-sets"><span>Creating sets</span></a></li><li><a class="tocitem" href="#Operating-with-sets"><span>Operating with sets</span></a></li><li><a class="tocitem" href="#Exploring-the-type-hierarchy"><span>Exploring the type hierarchy</span></a></li><li><a class="tocitem" href="#Random-sampling-and-splitting"><span>Random sampling and splitting</span></a></li><li><a class="tocitem" href="#Polyhedral-approximations"><span>Polyhedral approximations</span></a></li><li><a class="tocitem" href="#Specialization"><span>Specialization</span></a></li><li><a class="tocitem" href="#The-Lazy-paradigm"><span>The Lazy paradigm</span></a></li><li><a class="tocitem" href="#How-to-contribute"><span>How to contribute</span></a></li><li><a class="tocitem" href="#How-to-cite"><span>How to cite</span></a></li></ul></li><li><a class="tocitem" href="../convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../unary_set_operations/">Unary Operations on Sets</a></li><li><a class="tocitem" href="../reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/API/">API</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Set Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lib/interfaces/overview/">Overview</a></li><li><a class="tocitem" href="../../lib/interfaces/LazySet/">General sets (LazySet)</a></li><li><a class="tocitem" href="../../lib/interfaces/ConvexSet/">Convex sets (ConvexSet)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractCentrallySymmetric/">Centrally symmetric sets (AbstractCentrallySymmetric)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractPolyhedron/">Polyhedra (AbstractPolyhedron)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractPolytope/">Polytopes (AbstractPolytope)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractPolygon/">Polygons (AbstractPolygon)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractHPolygon/">Polygons in constraint representation (AbstractHPolygon)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractCentrallySymmetricPolytope/">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractZonotope/">Zonotopes (AbstractZonotope)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractHyperrectangle/">Hyperrectangles (AbstractHyperrectangle)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractSingleton/">Singletons (AbstractSingleton)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractAffineMap/">Affine maps (AbstractAffineMap)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractPolynomialZonotope/">Polynomial zonotope sets (AbstractPolynomialZonotope)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractSparsePolynomialZonotope/">Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractBallp/">Balls in the p-norm (AbstractBallp)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lib/sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../../lib/sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../../lib/sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../../lib/sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../../lib/sets/DensePolynomialZonotope/">DensePolynomialZonotope</a></li><li><a class="tocitem" href="../../lib/sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../../lib/sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../../lib/sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../../lib/sets/HParallelotope/">HParallelotope</a></li><li><a class="tocitem" href="../../lib/sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../../lib/sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../../lib/sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../../lib/sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../../lib/sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../../lib/sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../../lib/sets/Interval/">Interval</a></li><li><a class="tocitem" href="../../lib/sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../../lib/sets/Line/">Line</a></li><li><a class="tocitem" href="../../lib/sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../../lib/sets/Polygon/">Polygon</a></li><li><a class="tocitem" href="../../lib/sets/SimpleSparsePolynomialZonotope/">SimpleSparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../lib/sets/SparsePolynomialZonotope/">SparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../lib/sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../../lib/sets/Star/">Star</a></li><li><a class="tocitem" href="../../lib/sets/Tetrahedron/">Tetrahedron</a></li><li><a class="tocitem" href="../../lib/sets/Universe/">Universe</a></li><li><a class="tocitem" href="../../lib/sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../../lib/sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../../lib/sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../../lib/sets/Zonotope/">Zonotope</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lib/lazy_operations/AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../../lib/lazy_operations/Bloating/">Bloating</a></li><li><a class="tocitem" href="../../lib/lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../../lib/lazy_operations/Complement/">Complement</a></li><li><a class="tocitem" href="../../lib/lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../../lib/lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../../lib/lazy_operations/Intersection/">Intersection</a></li><li><a class="tocitem" href="../../lib/lazy_operations/LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../../lib/lazy_operations/InverseLinearMap/">InverseLinearMap</a></li><li><a class="tocitem" href="../../lib/lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../../lib/lazy_operations/QuadraticMap/">QuadraticMap</a></li><li><a class="tocitem" href="../../lib/lazy_operations/Rectification/">Rectification</a></li><li><a class="tocitem" href="../../lib/lazy_operations/ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../../lib/lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../../lib/lazy_operations/Translation/">Translation</a></li><li><a class="tocitem" href="../../lib/lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Concrete Binary Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lib/concrete_binary_operations/overview/">Binary set operations</a></li><li><a class="tocitem" href="../../lib/concrete_binary_operations/cartesian_product/">Cartesian Product</a></li><li><a class="tocitem" href="../../lib/concrete_binary_operations/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../lib/concrete_binary_operations/difference/">Set difference</a></li><li><a class="tocitem" href="../../lib/concrete_binary_operations/distance/">Distance</a></li><li><a class="tocitem" href="../../lib/concrete_binary_operations/intersection/">Intersection of two sets</a></li><li><a class="tocitem" href="../../lib/concrete_binary_operations/minkowski_sum/">Minkowski Sum</a></li><li><a class="tocitem" href="../../lib/concrete_binary_operations/minkowski_difference/">Minkowski Difference</a></li><li><a class="tocitem" href="../../lib/concrete_binary_operations/isdisjoint/">Check for Disjointness of Sets</a></li><li><a class="tocitem" href="../../lib/concrete_binary_operations/issubset/">Subset Check</a></li></ul></li><li><a class="tocitem" href="../../lib/conversion/">Conversions between set representations</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Approximations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lib/approximations/overview/">Overview</a></li><li><a class="tocitem" href="../../lib/approximations/overapproximate/">Overapproximation</a></li><li><a class="tocitem" href="../../lib/approximations/box_approximation/">Box Approximation</a></li><li><a class="tocitem" href="../../lib/approximations/iterative_refinement/">Iterative refinement</a></li><li><a class="tocitem" href="../../lib/approximations/template_directions/">Template directions</a></li><li><a class="tocitem" href="../../lib/approximations/underapproximate/">Underapproximation</a></li><li><a class="tocitem" href="../../lib/approximations/approximate/">Approximation</a></li><li><a class="tocitem" href="../../lib/approximations/decompose/">Cartesian Decomposition</a></li><li><a class="tocitem" href="../../lib/approximations/hausdorff_distance/">Hausdorff Distance</a></li></ul></li><li><a class="tocitem" href="../../lib/utils/">Utilities</a></li><li><a class="tocitem" href="../../lib/parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>A Tour of LazySets</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>A Tour of LazySets</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/man/tour.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="A-Tour-of-LazySets"><a class="docs-heading-anchor" href="#A-Tour-of-LazySets">A Tour of LazySets</a><a id="A-Tour-of-LazySets-1"></a><a class="docs-heading-anchor-permalink" href="#A-Tour-of-LazySets" title="Permalink"></a></h1><p>LazySets is a library for set-based computations in Euclidean space. The library offers both concrete and lazy set representations, where the latter stands for the ability to delay set computations until they are needed. The choice of the programming language <a href="https://julialang.org/">Julia</a> and the accompanying documentation allow researchers to easily translate set-based algorithms from mathematics to software in a platform-independent way, while achieving runtime performance that is comparable to statically compiled languages. Combining lazy operations in high dimensions and explicit computations in low dimensions, LazySets can be applied to solve complex, large-scale problems. The library can handle the most common operations between sets, including <a href="https://juliareach.github.io/LazySets.jl/dev/lib/lazy_operations/MinkowskiSum/">Minkowski sum</a>, <a href="https://juliareach.github.io/LazySets.jl/dev/lib/lazy_operations/CartesianProduct/">Cartesian product</a>, <a href="https://juliareach.github.io/LazySets.jl/dev/lib/lazy_operations/ConvexHull/">convex hull</a>, <a href="https://juliareach.github.io/LazySets.jl/dev/lib/lazy_operations/Intersection/">intersection</a> and <a href="https://juliareach.github.io/LazySets.jl/dev/lib/lazy_operations/UnionSet/">union</a>.</p><p>The purpose of this section is to give a high-level overview of the library and several examples to illustrate basic functionality. Further sections delve into more advanced uses.</p><h2 id="Creating-sets"><a class="docs-heading-anchor" href="#Creating-sets">Creating sets</a><a id="Creating-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-sets" title="Permalink"></a></h2><p>Sets can be created using the constructor for each set type. Here we define the two-dimensional half-space</p><p class="math-container">\[H = \{ (x, y) ∈ ℝ^2 : x ≤ y\} = \{ (x, y) ∈ ℝ^2 : x - y ≤ 0\}.\]</p><pre><code class="language-julia hljs">using LazySets

H = HalfSpace([1.0, -1.0], 0.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HalfSpace{Float64, Vector{Float64}}([1.0, -1.0], 0.0)</code></pre><p>The first argument is the normal vector to the half-space and the second argument the displacement, written in the standard form <span>$a⋅x ≤ b$</span>. We can define the same set using <em>symbolic variables</em> with the help of the Julia package <a href="https://symbolics.juliasymbolics.org/dev/">Symbolics.jl</a>:</p><pre><code class="language-julia hljs">using Symbolics

var = @variables x y

H′ = HalfSpace(x ≤ y, var)  # for `′`, type H\prime&lt;tab&gt;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HalfSpace{Float64, Vector{Float64}}([1.0, -1.0], -0.0)</code></pre><p>We can use LazySets to check that <code>H</code> and <code>H′</code> represent the same sets (mathematically the set equivalence <span>$H = H&#39;$</span> corresponds to a double inclusion check <span>$H ⊆ H&#39; ∧ H&#39; ⊆ H$</span>):</p><pre><code class="language-julia hljs">isequivalent(H, H′)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>High-dimensional sets can be conveniently defined using array notation. Here we create the nine-dimensional half-space</p><p class="math-container">\[H9 = \left\{ x ∈ ℝ^{9} : ∑_{i=1}^{9} i x_i ≤ 10 \right\}.\]</p><pre><code class="language-julia hljs">var = @variables x[1:9]

expr = sum(i*x[i] for i in 1:9) ≤ 10.0
H9 = HalfSpace(expr, var)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HalfSpace{Float64, Vector{Float64}}([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], 10.0)</code></pre><p>Next we ask LazySets to create two intervals <span>$[0, 1]$</span> and <span>$[2, 3]$</span> and then take their Cartesian product.</p><pre><code class="language-julia hljs">A = Interval(0, 1)
B = Interval(2, 3)

C = A × B</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CartesianProduct{Float64, Interval{Float64}, Interval{Float64}}(Interval{Float64}([0, 1]), Interval{Float64}([2, 3]))</code></pre><p>In LazySets, intervals are implemented as thin wrappers around those available in <a href="https://juliaintervals.github.io/pages/packages/intervalarithmetic/">IntervalArithmetic.jl</a>. Use the <code>convert</code> function to represent the set as a <code>Hyperrectangle</code>, which is a dedicated set type that represents a hyperrectangle with a center and a radius vector:</p><pre><code class="language-julia hljs">H = convert(Hyperrectangle, C)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Hyperrectangle{Float64, Vector{Float64}, Vector{Float64}}([0.5, 2.5], [0.5, 0.5])</code></pre><p>IntervalArithmetic.jl represents multi-dimensional intervals with the type <code>IntervalBox</code>, to which we can also <code>convert</code>:</p><pre><code class="language-julia hljs">using IntervalArithmetic

Hbox = convert(IntervalBox, H)

typeof(Hbox)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">IntervalArithmetic.IntervalBox{2, Float64}</code></pre><p>Hyperrectangles are a special subclass of <a href="https://juliareach.github.io/LazySets.jl/dev/lib/sets/Zonotope/">zonotopes</a>.</p><pre><code class="language-julia hljs">Z = convert(Zonotope, C)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.5, 2.5], [0.5 0.0; 0.0 0.5])</code></pre><p>There are many other set representations available in this library. They are introduced in further sections below.</p><h2 id="Operating-with-sets"><a class="docs-heading-anchor" href="#Operating-with-sets">Operating with sets</a><a id="Operating-with-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Operating-with-sets" title="Permalink"></a></h2><p>The result of <strong>intersecting</strong> two or more half-spaces is a polyhedron:</p><pre><code class="language-julia hljs">var = @variables x y

H1 = HalfSpace(y ≥ x, var)
H2 = HalfSpace(y ≥ -x, var)

P = H1 ∩ H2  # for `∩`, type `\cap&lt;tab&gt;`</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HPolyhedron{Float64, Vector{Float64}}(HalfSpace{Float64, Vector{Float64}}[HalfSpace{Float64, Vector{Float64}}([1.0, -1.0], -0.0), HalfSpace{Float64, Vector{Float64}}([-1.0, -1.0], 0.0)])</code></pre><p>Naturally, LazySets can plot the resulting set using the <a href="http://docs.juliaplots.org/latest/">Plots.jl</a> library:</p><pre><code class="language-julia hljs">using Plots

plot(H1, lab=&quot;H1&quot;)
plot!(H2, lab=&quot;H2&quot;)
plot!(P, lab=&quot;P = H1 ∩ H2&quot;, linewidth=2.0, linestyle=:dash)</code></pre><img src="03592b92.svg" alt="Example block output"/><p>A polyhedron consists of a finite intersection of half-spaces, which are also called linear constraints:</p><pre><code class="language-julia hljs">constraints_list(P)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{HalfSpace{Float64, Vector{Float64}}}:
 HalfSpace{Float64, Vector{Float64}}([1.0, -1.0], -0.0)
 HalfSpace{Float64, Vector{Float64}}([-1.0, -1.0], 0.0)</code></pre><p>The intersection of <span>$P$</span> with the triangle <span>$R$</span> with vertices</p><p><span>$\{(-1.0, -1.0), (1.0, -1.0), (0.0, 1.0)\}$</span> can be constructed with:</p><pre><code class="language-julia hljs">R = VPolygon([[-1.0, -1.0], [1.0, -1.0], [0.0, 1.0]])

Q = P ∩ R</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Intersection{Float64, HPolyhedron{Float64, Vector{Float64}}, VPolygon{Float64, Vector{Float64}}}(HPolyhedron{Float64, Vector{Float64}}(HalfSpace{Float64, Vector{Float64}}[HalfSpace{Float64, Vector{Float64}}([1.0, -1.0], -0.0), HalfSpace{Float64, Vector{Float64}}([-1.0, -1.0], 0.0)]), VPolygon{Float64, Vector{Float64}}([[-1.0, -1.0], [1.0, -1.0], [0.0, 1.0]]), LazySets.IntersectionCache(-1))</code></pre><pre><code class="language-julia hljs">plot!(Q, lab=&quot;Q = P ∩ R&quot;)
plot!(R, lab=&quot;R&quot;, linestyle=:dashdot, alpha=.2)</code></pre><img src="69376535.svg" alt="Example block output"/><p>The resulting set <code>Q</code> is a <strong>lazy (binary) intersection</strong>: by design, all operations in LazySets are lazy by default. Concrete operations can be performed by calling corresponding lower-case functions:</p><pre><code class="language-julia hljs">Q = intersection(P, R)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HPolytope{Float64, Vector{Float64}}(HalfSpace{Float64, Vector{Float64}}[HalfSpace{Float64, Vector{Float64}}([1.0, -1.0], -0.0), HalfSpace{Float64, Vector{Float64}}([-1.0, -1.0], 0.0), HalfSpace{Float64, Vector{Float64}}([2.0, 1.0], 1.0), HalfSpace{Float64, Vector{Float64}}([-2.0, 1.0], 1.0)])</code></pre><p>Alternatively, we can use the <code>concretize</code> function to transform a lazy set representation into a suitable concrete set representation.</p><pre><code class="language-julia hljs">concretize(P ∩ R)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HPolytope{Float64, Vector{Float64}}(HalfSpace{Float64, Vector{Float64}}[HalfSpace{Float64, Vector{Float64}}([1.0, -1.0], -0.0), HalfSpace{Float64, Vector{Float64}}([-1.0, -1.0], 0.0), HalfSpace{Float64, Vector{Float64}}([2.0, 1.0], 1.0), HalfSpace{Float64, Vector{Float64}}([-2.0, 1.0], 1.0)])</code></pre><p>The result is an <code>HPolytope</code> (instead of an <code>HPolyhedron</code>), since polytopes are special cases of <em>bounded</em> polyhedra.</p><pre><code class="language-julia hljs">isbounded(P)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><pre><code class="language-julia hljs">isbounded(Q)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>LazySets can compute various useful operations. For example, it can compute the area of a two-dimensional bounded set:</p><pre><code class="language-julia hljs">area(Q)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.3333333333333333</code></pre><p>When using rational numbers instead of floating-point numbers, we get an exact value for the area:</p><pre><code class="language-julia hljs">area(rationalize(Q))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1//3</code></pre><p>The vertices can be retrieved using <code>vertices_list</code>,</p><pre><code class="language-julia hljs">vertices_list(Q)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Vector{Float64}}:
 [0.0, 1.0]
 [-0.3333333333333333, 0.3333333333333333]
 [-0.0, 0.0]
 [0.3333333333333333, 0.3333333333333333]</code></pre><p>or in iterator-fashion with <code>vertices</code>:</p><pre><code class="language-julia hljs">vertices(Q)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Vector{Float64}}:
 [0.0, 1.0]
 [-0.3333333333333333, 0.3333333333333333]
 [-0.0, 0.0]
 [0.3333333333333333, 0.3333333333333333]</code></pre><p>The constraint representation of <span>$Q$</span> is obtained similarly.</p><pre><code class="language-julia hljs">constraints_list(Q)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{HalfSpace{Float64, Vector{Float64}}}:
 HalfSpace{Float64, Vector{Float64}}([1.0, -1.0], -0.0)
 HalfSpace{Float64, Vector{Float64}}([-1.0, -1.0], 0.0)
 HalfSpace{Float64, Vector{Float64}}([2.0, 1.0], 1.0)
 HalfSpace{Float64, Vector{Float64}}([-2.0, 1.0], 1.0)</code></pre><p>The constraint iterator is called with <code>constraints</code>.</p><pre><code class="language-julia hljs">constraints(Q)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{HalfSpace{Float64, Vector{Float64}}}:
 HalfSpace{Float64, Vector{Float64}}([1.0, -1.0], -0.0)
 HalfSpace{Float64, Vector{Float64}}([-1.0, -1.0], 0.0)
 HalfSpace{Float64, Vector{Float64}}([2.0, 1.0], 1.0)
 HalfSpace{Float64, Vector{Float64}}([-2.0, 1.0], 1.0)</code></pre><p>The <strong>Minkowski sum</strong> of two sets can be computed using <code>⊕</code> (type <code>\oplus&lt;tab&gt;</code>) (or alternatively just <code>+</code> for convenience):</p><pre><code class="language-julia hljs"># ball in the 2-norm of given center and radius
B = Ball2([0.8, 1.0], 0.3)

E = Q ⊕ B</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MinkowskiSum{Float64, HPolytope{Float64, Vector{Float64}}, Ball2{Float64, Vector{Float64}}}(HPolytope{Float64, Vector{Float64}}(HalfSpace{Float64, Vector{Float64}}[HalfSpace{Float64, Vector{Float64}}([1.0, -1.0], -0.0), HalfSpace{Float64, Vector{Float64}}([-1.0, -1.0], 0.0), HalfSpace{Float64, Vector{Float64}}([2.0, 1.0], 1.0), HalfSpace{Float64, Vector{Float64}}([-2.0, 1.0], 1.0)]), Ball2{Float64, Vector{Float64}}([0.8, 1.0], 0.3))</code></pre><p>Approximating and plotting such sets relies on techniques based on the <em>support function</em>, discussed at length in other sections of this manual.</p><pre><code class="language-julia hljs">plot(E, lab=&quot;E = Q ⊕ B&quot;, legend=:bottomright)
plot!(Q, lab=&quot;Q&quot;)
plot!(B, lab=&quot;B&quot;, ratio=1., xlims=(-0.5, 1.5))</code></pre><img src="feb1e6b1.svg" alt="Example block output"/><p><strong>Linear</strong> and <strong>affine</strong> maps are defined combining the <code>*</code> and <code>+</code> operators.</p><pre><code class="language-julia hljs">M = [0 1; 1 0.]
b = [0.5, -0.5]

X = M * E + b</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AffineMap{Float64, MinkowskiSum{Float64, HPolytope{Float64, Vector{Float64}}, Ball2{Float64, Vector{Float64}}}, Float64, Matrix{Float64}, Vector{Float64}}([0.0 1.0; 1.0 0.0], MinkowskiSum{Float64, HPolytope{Float64, Vector{Float64}}, Ball2{Float64, Vector{Float64}}}(HPolytope{Float64, Vector{Float64}}(HalfSpace{Float64, Vector{Float64}}[HalfSpace{Float64, Vector{Float64}}([1.0, -1.0], -0.0), HalfSpace{Float64, Vector{Float64}}([-1.0, -1.0], 0.0), HalfSpace{Float64, Vector{Float64}}([2.0, 1.0], 1.0), HalfSpace{Float64, Vector{Float64}}([-2.0, 1.0], 1.0)]), Ball2{Float64, Vector{Float64}}([0.8, 1.0], 0.3)), [0.5, -0.5])</code></pre><p>The set <span>$X$</span>, and in general, the composition of sets and operations, is again a set (in this case an operation).</p><pre><code class="language-julia hljs">isoperation(X)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Therefore, all set operations (and plotting) still work in the same way.</p><pre><code class="language-julia hljs">plot!(X, lab=&quot;X = M*E + b&quot;, legend=:topright)</code></pre><img src="7cc50fd4.svg" alt="Example block output"/><p><strong>Convex hulls</strong> can be computed with <code>convex_hull</code> (concrete), <code>ConvexHull</code> (lazy, binary), or <code>ConvexHullArray</code> (lazy, n-ary).</p><pre><code class="language-julia hljs">C = ConvexHullArray([E, Q, X])

plot!(C, c=:grey, lab=&quot;C = CH(E, Q, X)&quot;)</code></pre><img src="3a51ed8c.svg" alt="Example block output"/><p>The <strong>Cartesian product</strong> of sets is defined with <code>×</code> (type <code>\times&lt;tab&gt;</code>) (or alternatively just <code>*</code> for convenience).</p><pre><code class="language-julia hljs">X = Interval(0, 1) × Ball1([1.0, 2.0, 3.0], 1.0) × Interval(2, 4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CartesianProduct{Float64, CartesianProduct{Float64, Interval{Float64}, Ball1{Float64, Vector{Float64}}}, Interval{Float64}}(CartesianProduct{Float64, Interval{Float64}, Ball1{Float64, Vector{Float64}}}(Interval{Float64}([0, 1]), Ball1{Float64, Vector{Float64}}([1.0, 2.0, 3.0], 1.0)), Interval{Float64}([2, 4]))</code></pre><p><strong>Set unions</strong> are defined with <code>∪</code> (type <code>\cup&lt;tab&gt;</code>).</p><pre><code class="language-julia hljs">Y = Ball2([1.0, 2.0, 3.0], 1.0) × LineSegment([0.0, 0.0], [1.0, 1.0])

U = X ∪ Y</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">UnionSet{Float64, CartesianProduct{Float64, CartesianProduct{Float64, Interval{Float64}, Ball1{Float64, Vector{Float64}}}, Interval{Float64}}, CartesianProduct{Float64, Ball2{Float64, Vector{Float64}}, LineSegment{Float64, Vector{Float64}}}}(CartesianProduct{Float64, CartesianProduct{Float64, Interval{Float64}, Ball1{Float64, Vector{Float64}}}, Interval{Float64}}(CartesianProduct{Float64, Interval{Float64}, Ball1{Float64, Vector{Float64}}}(Interval{Float64}([0, 1]), Ball1{Float64, Vector{Float64}}([1.0, 2.0, 3.0], 1.0)), Interval{Float64}([2, 4])), CartesianProduct{Float64, Ball2{Float64, Vector{Float64}}, LineSegment{Float64, Vector{Float64}}}(Ball2{Float64, Vector{Float64}}([1.0, 2.0, 3.0], 1.0), LineSegment{Float64, Vector{Float64}}([0.0, 0.0], [1.0, 1.0])))</code></pre><p>There are other set operations not mentioned in this section. See the remaining sections of this manual for further examples.</p><h2 id="Exploring-the-type-hierarchy"><a class="docs-heading-anchor" href="#Exploring-the-type-hierarchy">Exploring the type hierarchy</a><a id="Exploring-the-type-hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Exploring-the-type-hierarchy" title="Permalink"></a></h2><p>Every set type in the library inherits from the parametric abstract type <code>LazySet{N}</code>, where <code>N</code> is a parameter for the numeric type (typically, double-precision floating point numbers, <code>Float64</code>). This way one can easily choose between, e.g., floating point (<code>Float64</code>) and exact (<code>Rational</code>) precision with no additional performance penalty: At runtime, Julia uses multiple dispatch on <code>N</code> and JIT-compiles into type-specific code.</p><p>Since the <code>LazySets</code> type hierarchy is rather involved, a way to visualize it is to use <a href="https://juliacollections.github.io/AbstractTrees.jl/stable/">AbstractTrees.jl</a>. The package provides several utilities for working with tree-like data structures. The function <a href="https://juliacollections.github.io/AbstractTrees.jl/stable/api/#AbstractTrees.print_tree"><code>print_tree</code></a> provides a very detailed answer.</p><pre><code class="language-julia hljs">using AbstractTrees

AbstractTrees.children(x::Type) = LazySets.subtypes(x, false)

print_tree(LazySet)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LazySet
├─ AbstractAffineMap
│  ├─ AffineMap
│  ├─ ExponentialMap
│  ├─ ExponentialProjectionMap
│  ├─ InverseLinearMap
│  ├─ LinearMap
│  ├─ ResetMap
│  └─ Translation
├─ AbstractPolynomialZonotope
│  ├─ AbstractSparsePolynomialZonotope
│  │  ├─ SimpleSparsePolynomialZonotope
│  │  └─ SparsePolynomialZonotope
│  └─ DensePolynomialZonotope
├─ Bloating
├─ CachedMinkowskiSumArray
├─ CartesianProduct
├─ CartesianProductArray
├─ Complement
├─ ConvexSet
│  ├─ AbstractCentrallySymmetric
│  │  ├─ AbstractBallp
│  │  │  ├─ Ball2
│  │  │  └─ Ballp
│  │  └─ Ellipsoid
│  ├─ AbstractPolyhedron
│  │  ├─ AbstractPolytope
│  │  │  ├─ AbstractCentrallySymmetricPolytope
│  │  │  │  ├─ AbstractZonotope
│  │  │  │  │  ⋮
│  │  │  │  │
│  │  │  │  └─ Ball1
│  │  │  ├─ AbstractPolygon
│  │  │  │  ├─ AbstractHPolygon
│  │  │  │  │  ⋮
│  │  │  │  │
│  │  │  │  └─ VPolygon
│  │  │  ├─ HPolytope
│  │  │  ├─ Tetrahedron
│  │  │  └─ VPolytope
│  │  ├─ HPolyhedron
│  │  ├─ HalfSpace
│  │  ├─ Hyperplane
│  │  ├─ Line
│  │  ├─ Line2D
│  │  ├─ Star
│  │  └─ Universe
│  ├─ ConvexHull
│  ├─ ConvexHullArray
│  └─ EmptySet
├─ Intersection
├─ IntersectionArray
├─ MinkowskiSum
├─ MinkowskiSumArray
├─ Polygon
├─ QuadraticMap
├─ Rectification
├─ UnionSet
└─ UnionSetArray</code></pre><p>Since the list does not fit into the default size, some types are hidden. LazySets has several set interfaces whose names start with <code>Abstract</code>. Visualizing the subtypes of a specific set interface can be done similarly. Consider the class of zonotopic sets, <code>AbstractZonotope</code>, which are those that can be represented as</p><p class="math-container">\[Z = \left\{ x ∈ ℝ^n : x = c + ∑_{i=1}^p ξ_i g_i,~~ ξ_i ∈ [-1, 1]~~ ∀ i = 1,…, p \right\},\]</p><p>where <span>$c ∈ ℝ^n$</span> is called the center and the vectors <span>$\{g_i\}_{i=1}^p$</span>, <span>$g_i ∈ ℝ^n$</span>, are called the generators.</p><pre><code class="language-julia hljs">print_tree(AbstractZonotope)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AbstractZonotope
├─ AbstractHyperrectangle
│  ├─ AbstractSingleton
│  │  ├─ Singleton
│  │  └─ ZeroSet
│  ├─ BallInf
│  ├─ Hyperrectangle
│  ├─ Interval
│  └─ SymmetricIntervalHull
├─ HParallelotope
├─ LineSegment
└─ Zonotope</code></pre><p>All the sets belonging to the abstract zonotope interface have in common that they can be characterized by a center and a generator matrix (equivalently, as the finite Minkowski sum of line segments, or as the image of a unit infinity-norm ball in <span>$ℝ^n$</span> by an affine transformation). Hence, new set types implementing a few interface functions can make use of all the available functionality that are implemented by generic algorithms working at the interface level.</p><p>Last but not least, we remark that one of the key design choices of LazySets (which, admittedly, may be confusing at first) is that <strong>both set representations and set operations subtype <code>LazySet</code></strong>. In other words, an &quot;operation between sets&quot; and &quot;a set&quot; are on the same footing in terms of belonging to the same type hierarchy. One of the advantages of these two mathematical concepts to be &quot;just types&quot; is to conveniently compose representations and operations (existing and user-created ones).</p><p>An overview of only the set operations can be obtained like so:</p><pre><code class="language-julia hljs">filter(isoperationtype, LazySets.subtypes(LazySet, true))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">23-element Vector{Type}:
 AffineMap
 Bloating
 CachedMinkowskiSumArray
 CartesianProduct
 CartesianProductArray
 Complement
 ConvexHull
 ConvexHullArray
 ExponentialMap
 ExponentialProjectionMap
 ⋮
 MinkowskiSum
 MinkowskiSumArray
 QuadraticMap
 Rectification
 ResetMap
 SymmetricIntervalHull
 Translation
 UnionSet
 UnionSetArray</code></pre><p>The total amount of available representations is larger (if we had used <code>subtypes(LazySet)</code>, that would only show the direct subtypes of <code>LazySet</code>).</p><pre><code class="language-julia hljs">length(LazySets.subtypes(LazySet, true))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">53</code></pre><h2 id="Random-sampling-and-splitting"><a class="docs-heading-anchor" href="#Random-sampling-and-splitting">Random sampling and splitting</a><a id="Random-sampling-and-splitting-1"></a><a class="docs-heading-anchor-permalink" href="#Random-sampling-and-splitting" title="Permalink"></a></h2><p>Another useful operation is to perform <strong>random sampling</strong> from a given set.</p><pre><code class="language-julia hljs"># returns a vector of samples (vectors)
S = sample(Q, 300, include_vertices=true)

plot(Q, lab=&quot;Q&quot;)

# transform into a vector of singletons (for plotting)
plot!(Singleton.(S), lab=&quot;S&quot;, c=:magenta)</code></pre><img src="575d6a8b.svg" alt="Example block output"/><p>Set membership is computed with the <code>∈</code> operator (type <code>\in&lt;tab&gt;</code>):</p><pre><code class="language-julia hljs">all(s -&gt; s ∈ Q, S)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Below we show a straightforward way to enclose <code>Q</code> with smaller, simpler sets (hyperrectangles in this case).</p><pre><code class="language-julia hljs"># compute an enclosing hyperrectangle
Qbox = overapproximate(Q, Hyperrectangle)

# split it into 6 pieces horizontally and 10 pieces vertically
Bs = split(Qbox, [6, 10])

# find all the boxes that intersect Q
idx = findall(Bi -&gt; !isdisjoint(Bi, Q), Bs)

plot(Bs[idx])
plot!(Q, lab=&quot;Q&quot;)
plot!(Singleton.(S), lab=&quot;S&quot;, c=:magenta)</code></pre><img src="ffe26919.svg" alt="Example block output"/><p>With a bit of extra work we can also split the set into non axis-aligned parallelotopes:</p><pre><code class="language-julia hljs"># compute an enclosing zonotope
Z = overapproximate(Q, Zonotope, OctDirections)

# reduce to order 1
P = overapproximate(Z, HParallelotope)

# split along the first (resp. second) generator three (resp. four) times
Zs = split(convert(Zonotope, P), [1, 2], [3, 4])

# find all the zonotopes that intersect Q
idx = findall(Zi -&gt; !isdisjoint(Zi, Q), Zs)

plot(Zs[idx])
plot!(Q, lab=&quot;Q&quot;)
plot!(Singleton.(S), lab=&quot;S&quot;, c=:magenta)</code></pre><img src="24a47bd9.svg" alt="Example block output"/><h2 id="Polyhedral-approximations"><a class="docs-heading-anchor" href="#Polyhedral-approximations">Polyhedral approximations</a><a id="Polyhedral-approximations-1"></a><a class="docs-heading-anchor-permalink" href="#Polyhedral-approximations" title="Permalink"></a></h2><p>In this library we mainly consider representations of closed convex sets in the usual sense from convex geometry: A set is closed if it contains all its limit points. A set <span>$S$</span> is convex if for any <span>$m$</span> points <span>$v_j ∈ S$</span> and <span>$m$</span> non-negative numbers <span>$λ_j$</span> that sum up to <span>$1$</span> we have that <span>$∑_{j=1}^m λ_j v_j ∈ S$</span> as well. Alternatively, a closed convex set is an intersection of (possibly infinitely many) closed half-spaces.</p><p>One of the central functions are <code>support_function(d, X)</code> (with the alias <code>ρ(d, X)</code> (type <code>\rho&lt;tab&gt;</code>)) and <code>support_vector</code> (with the alias <code>σ</code> (type <code>\sigma&lt;tab&gt;</code>)). The support function of a set <span>$X$</span> along direction <span>$d ∈ ℝ^n$</span> corresponds to the (signed) distance of the maximum element in <span>$X$</span> along direction <span>$d$</span>. The support vector is a (among possibly infinitely many) maximizer of the support function.</p><p>The support function also characterizes the half-space that tightly covers a set in a given direction. Hence it can be used to obtain a polyhedral (over-)approximation of any set. This topic is further covered in other sections of the manual.</p><h2 id="Specialization"><a class="docs-heading-anchor" href="#Specialization">Specialization</a><a id="Specialization-1"></a><a class="docs-heading-anchor-permalink" href="#Specialization" title="Permalink"></a></h2><p>One of the key features of LazySets is specialization. On a more technical level, the library aims at a high level of optimization to get the best possible performance given the following two restrictions: the set type and the set dimension.</p><p>The submodule <code>LazySets.Arrays</code> exports the &quot;one-hot vector&quot; <code>SingleEntryVector</code> that can be used, e.g., to represent polyhedra with axis-aligned half-spaces as information on the <em>type</em>. If <code>H</code> is a (non-flat) 100-dimensional hyperrectangle, it has <span>$2^{100}$</span> vertices. Computing the support function of <code>M*X</code> for any square matrix <code>M</code> along the canonical direction <code>e_{50} = [0, …, 0, 1, 0, …, 0]</code> takes around <code>10us</code> on a modern computer.</p><pre><code class="language-julia hljs">using LazySets.Arrays: SingleEntryVector

using BenchmarkTools

d = SingleEntryVector(50, 100, 1.0)
M = rand(100, 100)  # a random 100×100 matrix
H = rand(Hyperrectangle, dim=100)  # a random 100-dimensional hyperrectangle

out = @benchmark ρ($d, $M * $H)
out</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 4 evaluations per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">7.156 μs</span></span> … <span class="sgr35">62.938 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">7.579 μs              </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">7.783 μs</span></span> ± <span class="sgr32"> 1.306 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

  ▇▄▁   ▃<span class="sgr34">█</span>▆▂▁<span class="sgr32"> </span>  ▃▂                              ▁▃▃▂         ▂
  ████▆▄█<span class="sgr34">█</span>███<span class="sgr32">█</span>▆▅██▇▅▆▄▄▃▄▄▃▅▁▁▁▁▁▅▆▆▆▇▆▇██▅▇███▇█████▇▅▄▄▅▆▆ █
  7.16 μs<span class="sgr90">      Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>     10.4 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">928 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">2</span>.</code></pre><h2 id="The-Lazy-paradigm"><a class="docs-heading-anchor" href="#The-Lazy-paradigm">The Lazy paradigm</a><a id="The-Lazy-paradigm-1"></a><a class="docs-heading-anchor-permalink" href="#The-Lazy-paradigm" title="Permalink"></a></h2><p>For the several set representations, such as polyhedra in constraint and in vertex representation, ellipsoids, balls in different norms, and specific classes of polyhedra (such as intervals, zonotopes, or hyperrectangles), LazySets implements specialized methods for many set operations. Applications that use LazySets can explore different approaches with minimal changes in their code. Conversion between set representations as well as overapproximation and underapproximation functionality are available.</p><p>Set operations can be performed in two possible (complementary) ways: concretely or lazily. A <em>concrete</em> operation returns a set of a dedicated type (such as <code>Hyperrectangle</code>). A <em>lazy</em> operation simply returns a wrapper object representing the result of the operation between the given sets. For instance, consider the transformation with a linear map, i.e., the set <span>$Y = \{y : y = Ax \textrm{ for some } x ∈ X\}$</span>. In LazySets, <code>linear_map(A, X)</code> returns a <em>concrete</em> set representation of <span>$Y$</span>. The algorithm that is actually used, as well as the type of <span>$Y$</span>, depend on the types of its arguments (this is the <em>multiple dispatch</em> paradigm) and the dimension of <code>X</code>.</p><p>For example, if <code>X</code> is a polygon in vertex representation (<code>VPolygon</code>), then <code>linear_map(M, X)</code> applies <code>M</code> to each vertex of <code>X</code>. However, if <code>X</code> is a 30-dimensional polyhedron in half-space representation (<code>HPolyhedron</code>), then the half-space representation is used if <code>M</code> is invertible – if not, and if <code>MX</code> does not fall into any special case, the vertex representation has to be computed. For polyhedra manipulation we use the library <a href="https://juliapolyhedra.github.io/Polyhedra.jl/dev/">Polyhedra.jl</a> (the cost of converting between representations increases exponentially with the dimension, so computing with concrete polyhedra is usually avoided in high dimensions). Observe that if we are interested in <code>P(MX)</code> for some projection matrix <code>P</code>, that operation <em>can</em> be performed efficiently using the support function, i.e., without actually computing <code>MX</code>. On the other hand, there are special cases of polyhedra for which concrete operations can be performed efficiently. For instance, if <code>X</code> is a hyperrectangle (or a zonotope), the resulting set is a zonotope and the computation is efficient.</p><p>To give an example of lazy operations, <code>LinearMap(A, X)</code>, or simply <code>A * X</code>, computes the lazy linear map, which is just a new object that wraps the computation of the linear map until it is actually needed. In other words, <code>LinearMap(A, X)</code> can be used to reason about the linear map even if computing the result is expensive (e.g., if <code>X</code> is high-dimensional), since this command just builds an object representing the linear map of <code>A</code> and <code>X</code>. In LazySets, Unicode symbols such as <code>A * X</code>, <code>X ⊕ Y</code>, <code>X ⊖ Y</code>, <code>X × Y</code>, all default to lazy operations by design. Unicode is written using the LaTeX macro of the symbol followed by the TAB key, such as <code>\oplus&lt;tab&gt;</code> for the (lazy) Minkowski sum ⊕.</p><p>Finally, one can combine lazy set operations to build lazy expressions that represent several operations between sets, such as <code>Q = (Z ⊕ A*X) × T</code>. By means of the basic tools of (convex) geometry, useful information about <code>Q</code> can be obtained without actually computing the linear map, Minkowski sum and Cartesian product in the above computation. For example, if the computation only involves querying information about <code>Q</code> in a restricted number of directions, as it is often the case in applications, the lazy approach can be realized very efficiently!</p><h2 id="How-to-contribute"><a class="docs-heading-anchor" href="#How-to-contribute">How to contribute</a><a id="How-to-contribute-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-contribute" title="Permalink"></a></h2><p>Development happens on <a href="https://github.com/JuliaReach/LazySets.jl/">github</a>. New contributors should follow the links provided in the <a href="https://juliareach.github.io/LazySets.jl/dev/about/">About</a> section of this documentation.</p><h2 id="How-to-cite"><a class="docs-heading-anchor" href="#How-to-cite">How to cite</a><a id="How-to-cite-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-cite" title="Permalink"></a></h2><p>When citing <code>LazySets.jl</code>, please use the entry in <a href="https://github.com/JuliaReach/LazySets.jl/blob/master/CITATION.bib">CITATION.bib</a>.</p><p>Further publications using LazySets can be found in the <a href="https://github.com/JuliaReach/LazySets.jl#-publications">Publications</a> section of the README. If you would like to list your work, feel free to create a <a href="https://github.com/JuliaReach/LazySets.jl/pulls">pull request</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optional_dependencies/">« Optional Features</a><a class="docs-footer-nextpage" href="../convex_sets/">Introduction to Convex Sets »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Wednesday 2 April 2025 05:23">Wednesday 2 April 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
