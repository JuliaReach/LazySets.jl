<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Zonotopes (AbstractZonotope) · LazySets.jl</title><meta name="title" content="Zonotopes (AbstractZonotope) · LazySets.jl"/><meta property="og:title" content="Zonotopes (AbstractZonotope) · LazySets.jl"/><meta property="twitter:title" content="Zonotopes (AbstractZonotope) · LazySets.jl"/><meta name="description" content="Documentation for LazySets.jl."/><meta property="og:description" content="Documentation for LazySets.jl."/><meta property="twitter:description" content="Documentation for LazySets.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/aligned.css" rel="stylesheet" type="text/css"/><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">LazySets.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../../man/optional_dependencies/">Optional Features</a></li><li><a class="tocitem" href="../../../man/tour/">A Tour of LazySets</a></li><li><a class="tocitem" href="../../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../../man/unary_set_operations/">Unary Operations on Sets</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../API/">API</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox" checked/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Set Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../LazySet/">General sets (LazySet)</a></li><li><a class="tocitem" href="../ConvexSet/">Convex sets (ConvexSet)</a></li><li><a class="tocitem" href="../AbstractCentrallySymmetric/">Centrally symmetric sets (AbstractCentrallySymmetric)</a></li><li><a class="tocitem" href="../AbstractPolyhedron/">Polyhedra (AbstractPolyhedron)</a></li><li><a class="tocitem" href="../AbstractPolytope/">Polytopes (AbstractPolytope)</a></li><li><a class="tocitem" href="../AbstractPolygon/">Polygons (AbstractPolygon)</a></li><li><a class="tocitem" href="../AbstractHPolygon/">Polygons in constraint representation (AbstractHPolygon)</a></li><li><a class="tocitem" href="../AbstractCentrallySymmetricPolytope/">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a></li><li class="is-active"><a class="tocitem" href>Zonotopes (AbstractZonotope)</a><ul class="internal"><li><a class="tocitem" href="#Internal-methods"><span>Internal methods</span></a></li><li><a class="tocitem" href="#Order-reduction-methods"><span>Order-reduction methods</span></a></li><li><a class="tocitem" href="#Implementations"><span>Implementations</span></a></li></ul></li><li><a class="tocitem" href="../AbstractHyperrectangle/">Hyperrectangles (AbstractHyperrectangle)</a></li><li><a class="tocitem" href="../AbstractSingleton/">Singletons (AbstractSingleton)</a></li><li><a class="tocitem" href="../AbstractAffineMap/">Affine maps (AbstractAffineMap)</a></li><li><a class="tocitem" href="../AbstractPolynomialZonotope/">Polynomial zonotope sets (AbstractPolynomialZonotope)</a></li><li><a class="tocitem" href="../AbstractSparsePolynomialZonotope/">Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)</a></li><li><a class="tocitem" href="../AbstractBallp/">Balls in the p-norm (AbstractBallp)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../../sets/DensePolynomialZonotope/">DensePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../../sets/HParallelotope/">HParallelotope</a></li><li><a class="tocitem" href="../../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../../sets/Line/">Line</a></li><li><a class="tocitem" href="../../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../../sets/Polygon/">Polygon</a></li><li><a class="tocitem" href="../../sets/SimpleSparsePolynomialZonotope/">SimpleSparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/SparsePolynomialZonotope/">SparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../../sets/Star/">Star</a></li><li><a class="tocitem" href="../../sets/Tetrahedron/">Tetrahedron</a></li><li><a class="tocitem" href="../../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../../sets/Zonotope/">Zonotope</a></li><li><a class="tocitem" href="../../sets/ZonotopeMD/">ZonotopeMD</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lazy_operations/AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../../lazy_operations/Bloating/">Bloating</a></li><li><a class="tocitem" href="../../lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../../lazy_operations/Complement/">Complement</a></li><li><a class="tocitem" href="../../lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../../lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../../lazy_operations/Intersection/">Intersection</a></li><li><a class="tocitem" href="../../lazy_operations/LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../../lazy_operations/InverseLinearMap/">InverseLinearMap</a></li><li><a class="tocitem" href="../../lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../../lazy_operations/QuadraticMap/">QuadraticMap</a></li><li><a class="tocitem" href="../../lazy_operations/Rectification/">Rectification</a></li><li><a class="tocitem" href="../../lazy_operations/ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../../lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../../lazy_operations/Translation/">Translation</a></li><li><a class="tocitem" href="../../lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Concrete Binary Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../concrete_binary_operations/overview/">Binary set operations</a></li><li><a class="tocitem" href="../../concrete_binary_operations/cartesian_product/">Cartesian Product</a></li><li><a class="tocitem" href="../../concrete_binary_operations/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../concrete_binary_operations/difference/">Set difference</a></li><li><a class="tocitem" href="../../concrete_binary_operations/distance/">Distance</a></li><li><a class="tocitem" href="../../concrete_binary_operations/intersection/">Intersection of two sets</a></li><li><a class="tocitem" href="../../concrete_binary_operations/minkowski_sum/">Minkowski Sum</a></li><li><a class="tocitem" href="../../concrete_binary_operations/minkowski_difference/">Minkowski Difference</a></li><li><a class="tocitem" href="../../concrete_binary_operations/isdisjoint/">Check for Disjointness of Sets</a></li><li><a class="tocitem" href="../../concrete_binary_operations/issubset/">Subset Check</a></li></ul></li><li><a class="tocitem" href="../../conversion/">Conversions between set representations</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Approximations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../approximations/overview/">Overview</a></li><li><a class="tocitem" href="../../approximations/overapproximate/">Overapproximation</a></li><li><a class="tocitem" href="../../approximations/box_approximation/">Box Approximation</a></li><li><a class="tocitem" href="../../approximations/iterative_refinement/">Iterative refinement</a></li><li><a class="tocitem" href="../../approximations/template_directions/">Template directions</a></li><li><a class="tocitem" href="../../approximations/underapproximate/">Underapproximation</a></li><li><a class="tocitem" href="../../approximations/approximate/">Approximation</a></li><li><a class="tocitem" href="../../approximations/decompose/">Cartesian Decomposition</a></li><li><a class="tocitem" href="../../approximations/hausdorff_distance/">Hausdorff Distance</a></li></ul></li><li><a class="tocitem" href="../../utils/">Utilities</a></li><li><a class="tocitem" href="../../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li><a class="is-disabled">Set Interfaces</a></li><li class="is-active"><a href>Zonotopes (AbstractZonotope)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Zonotopes (AbstractZonotope)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/interfaces/AbstractZonotope.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#def_AbstractZonotope">Zonotopes (AbstractZonotope)</a></li><li class="no-marker"><ul><li><a href="#Internal-methods">Internal methods</a></li><li><a href="#Order-reduction-methods">Order-reduction methods</a></li><li><a href="#Implementations">Implementations</a></li></ul></li></ul><h1 id="def_AbstractZonotope"><a class="docs-heading-anchor" href="#def_AbstractZonotope">Zonotopes (AbstractZonotope)</a><a id="def_AbstractZonotope-1"></a><a class="docs-heading-anchor-permalink" href="#def_AbstractZonotope" title="Permalink"></a></h1><p>A zonotope is a specific centrally symmetric polytope characterized by a center and a collection of generators.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.AbstractZonotope" href="#LazySets.AbstractZonotope"><code>LazySets.AbstractZonotope</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractZonotope{N} &lt;: AbstractCentrallySymmetricPolytope{N}</code></pre><p>Abstract type for zonotopic sets.</p><p><strong>Notes</strong></p><p>Mathematically, a zonotope is defined as the set</p><p class="math-container">\[Z = \left\{ c + ∑_{i=1}^p ξ_i g_i,~~ ξ_i ∈ [-1, 1]~~ ∀ i = 1,…, p \right\},\]</p><p>where <span>$c ∈ ℝ^n$</span> is its center and <span>$\{g_i\}_{i=1}^p$</span>, <span>$g_i ∈ ℝ^n$</span>, is the set of generators. This characterization defines a zonotope as the finite Minkowski sum of line segments. Zonotopes can be equivalently described as the image of a unit infinity-norm ball in <span>$ℝ^n$</span> by an affine transformation.</p><p>See <a href="../../sets/Zonotope/#LazySets.ZonotopeModule.Zonotope"><code>Zonotope</code></a> for a standard implementation of this interface.</p><p>Every concrete <code>AbstractZonotope</code> must define the following functions:</p><ul><li><code>generators(::AbstractZonotope)</code> – return an iterator over the generators</li><li><code>genmat(::AbstractZonotope)</code> – return a generator matrix</li></ul><p>Since the functions <code>genmat</code> and <code>generators</code> can be defined in terms of each other, it is sufficient to only genuinely implement one of them and let the implementation of the other function call the fallback implementation <code>genmat_fallback</code> resp. <code>generators_fallback</code>.</p><p>The subtypes of <code>AbstractZonotope</code> (including abstract interfaces):</p><pre><code class="language-julia-repl hljs">julia&gt; subtypes(AbstractZonotope)
5-element Vector{Any}:
 AbstractHyperrectangle
 HParallelotope
 LineSegment
 Zonotope
 ZonotopeMD</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L10-L52">source</a></section></article><p>This interface requires to implement the following functions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.generators-Tuple{AbstractZonotope}" href="#LazySets.generators-Tuple{AbstractZonotope}"><code>LazySets.generators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generators(Z::AbstractZonotope)</code></pre><p>Return an iterator over the generators of a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>An iterator over the generators of <code>Z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L55-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.genmat-Tuple{AbstractZonotope}" href="#LazySets.genmat-Tuple{AbstractZonotope}"><code>LazySets.genmat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">genmat(Z::AbstractZonotope)</code></pre><p>Return a generator matrix of a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>A generator matrix of <code>Z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L70-L82">source</a></section></article><p>This interface defines the following functions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractZonotope" href="#LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractZonotope"><code>LazySets.API.constraints_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">constraints_list(X::LazySet)</code></pre><p>Compute a list of linear constraints of a polyhedral set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – polyhedral set</li></ul><p><strong>Output</strong></p><p>A list of the linear constraints of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/API/Unary/constraints_list.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.constraints_list-Tuple{AbstractZonotope}" href="#LazySets.API.constraints_list-Tuple{AbstractZonotope}"><code>LazySets.API.constraints_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">constraints_list(P::AbstractZonotope)</code></pre><p><strong>Algorithm</strong></p><p>This is the (inefficient) fallback implementation for rational numbers. It first computes the vertices and then converts the corresponding polytope to constraint representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L510-L520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.constraints_list-Tuple{AbstractZonotope{&lt;:AbstractFloat}}" href="#LazySets.API.constraints_list-Tuple{AbstractZonotope{&lt;:AbstractFloat}}"><code>LazySets.API.constraints_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">constraints_list(Z::AbstractZonotope{&lt;:AbstractFloat})</code></pre><p><strong>Notes</strong></p><p>The main algorithm assumes that the generator matrix is full rank. The result has <span>$2 \binom{p}{n-1}$</span> (with <span>$p$</span> being the number of generators and <span>$n$</span> being the ambient dimension) constraints, which is optimal under this assumption. If this assumption is not given, the implementation tries to work around.</p><p><strong>Algorithm</strong></p><p>We follow the algorithm presented in <a href="../../../bibliography/#AlthoffSB10">Althoff <em>et al.</em> [ASB10]</a>. Three cases are not covered by that algorithm, so we handle them separately. The first case is zonotopes in one dimension. The second case is that there are fewer generators than dimensions, <span>$p &lt; n$</span>, or the generator matrix is not full rank, in which case we fall back to the (slower) computation based on the vertex representation. The third case is that the zonotope is flat in some dimensions, in which case we project the zonotope to the non-flat dimensions and extend the result later.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L529-L551">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.ngens-Tuple{AbstractZonotope}" href="#LazySets.ngens-Tuple{AbstractZonotope}"><code>LazySets.ngens</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ngens(Z::AbstractZonotope)</code></pre><p>Return the number of generators of a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>An integer representing the number of generators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L167-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.order-Tuple{AbstractZonotope}" href="#LazySets.order-Tuple{AbstractZonotope}"><code>LazySets.order</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">order(Z::AbstractZonotope)</code></pre><p>Return the order of a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>A rational number representing the order of the zonotopic set.</p><p><strong>Notes</strong></p><p>The order of a zonotopic set is defined as the quotient of its number of generators and its dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L184-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.reflect-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractZonotope" href="#LazySets.API.reflect-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractZonotope"><code>LazySets.API.reflect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reflect(X::LazySet)</code></pre><p>Compute the reflection of a set in the origin.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the reflection <span>$-X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/API/Unary/reflect.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.reflect-Tuple{AbstractZonotope}" href="#LazySets.API.reflect-Tuple{AbstractZonotope}"><code>LazySets.API.reflect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">reflect(Z::AbstractZonotope)</code></pre><p><strong>Algorithm</strong></p><p>If <span>$Z$</span> has center <span>$c$</span> and generator matrix <span>$G$</span>, then <span>$-Z$</span> has center <span>$-c$</span> and generator matrix <span>$G$</span>. For the latter, observe that <span>$G$</span> and <span>$-G$</span> behave the same way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L1132-L1142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.remove_redundant_generators-Tuple{AbstractZonotope}" href="#LazySets.remove_redundant_generators-Tuple{AbstractZonotope}"><code>LazySets.remove_redundant_generators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_redundant_generators(Z::AbstractZonotope)</code></pre><p>Remove all redundant (pairwise linearly dependent) generators of a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>A new zonotope with fewer generators, or the same zonotopic set if no generator could be removed.</p><p><strong>Algorithm</strong></p><p>By default this implementation returns the input zonotopic set. Subtypes of <code>AbstractZonotope</code> whose generators can be removed have to define a new method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L760-L779">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.togrep-Tuple{AbstractZonotope}" href="#LazySets.togrep-Tuple{AbstractZonotope}"><code>LazySets.togrep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">togrep(Z::AbstractZonotope)</code></pre><p>Return a generator representation of a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>The same set in generator representation. This fallback implementation returns a <code>Zonotope</code>; however, more specific implementations may return other generator representations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L148-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.vertices_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractZonotope" href="#LazySets.API.vertices_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractZonotope"><code>LazySets.API.vertices_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertices_list(X::LazySet)</code></pre><p>Compute a list of vertices of a polytopic set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – polytopic set</li></ul><p><strong>Output</strong></p><p>A list of the vertices of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/API/Unary/vertices_list.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.vertices_list-Tuple{AbstractZonotope}" href="#LazySets.API.vertices_list-Tuple{AbstractZonotope}"><code>LazySets.API.vertices_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">vertices_list(Z::AbstractZonotope; [apply_convex_hull]::Bool=true)</code></pre><p><strong>Input</strong></p><ul><li><code>apply_convex_hull</code> – (optional, default: <code>true</code>) if <code>true</code>, post-process the                        computation with the convex hull of the points</li></ul><p><strong>Algorithm</strong></p><p><strong>Two-dimensional case</strong></p><p>We use a trick to speed up enumerating vertices of 2-dimensional zonotopic sets with all generators in the first quadrant or third quadrant (same sign). Namely, sort the generators by angle and add them clockwise in increasing order and counterclockwise in decreasing order. A more detailed explanation can be found <a href="https://math.stackexchange.com/q/3356460">here</a>.</p><p>To avoid the cumulative sum from both directions separately, we build a 2D index matrix to sum generators for both directions in one matrix-vector product.</p><p><strong>General case</strong></p><p>If the zonotopic set has <span>$p$</span> generators, each vertex is the result of summing the center with some linear combination of generators, where the combination factors are <span>$ξ_i ∈ \{-1, 1\}$</span>.</p><p>There are at most <span>$2^p$</span> distinct vertices. Use the flag <code>apply_convex_hull</code> to control whether a convex-hull algorithm is applied to the vertices computed by this method; otherwise, redundant vertices may be present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L339-L371">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope" href="#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∈(x::AbstractVector, X::LazySet)</code></pre><p>Check whether a point lies in a set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/API/Mixed/in.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:∈-Tuple{AbstractVector, AbstractZonotope}" href="#Base.:∈-Tuple{AbstractVector, AbstractZonotope}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">∈(x::AbstractVector, Z::AbstractZonotope; solver=nothing)</code></pre><p><strong>Input</strong></p><ul><li><code>solver</code> – (optional, default: <code>nothing</code>) the backend used to solve the             linear program</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Z = Zonotope([1.0, 0.0], [0.1 0.0; 0.0 0.1]);

julia&gt; [1.0, 0.2] ∈ Z
false
julia&gt; [1.0, 0.1] ∈ Z
true</code></pre><p><strong>Notes</strong></p><p>If <code>solver == nothing</code>, we fall back to <code>default_lp_solver(N)</code>.</p><p><strong>Algorithm</strong></p><p>The membership problem is reduced to the following linear program. Let <span>$p$</span> and <span>$n$</span> be the number of generators and ambient dimension, respectively. We consider the <span>$p$</span>-dimensional space of elements <span>$(ξ_1, …, ξ_p)$</span> constrained to <span>$ξ_i ∈ [-1, 1]$</span> for all <span>$i = 1, …, p$</span> such that <span>$x-c = Gξ$</span> holds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L237-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.linear_map-Tuple{AbstractMatrix, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope" href="#LazySets.API.linear_map-Tuple{AbstractMatrix, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope"><code>LazySets.API.linear_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_map(M::AbstractMatrix, X::LazySet)</code></pre><p>Compute the linear map <span>$M · X$</span>.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the linear map <span>$M · X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/API/Mixed/linear_map.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.linear_map-Tuple{AbstractMatrix, AbstractZonotope}" href="#LazySets.API.linear_map-Tuple{AbstractMatrix, AbstractZonotope}"><code>LazySets.API.linear_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">linear_map(M::AbstractMatrix, Z::AbstractZonotope)</code></pre><p><strong>Output</strong></p><p>A <code>Zonotope</code>.</p><p><strong>Algorithm</strong></p><p>We apply the linear map to the center and the generators.</p><p>If the map has outpu dimension 1, a specialized algorithm ensures that the resulting zonotope only has a single generator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L295-L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.reduce_order" href="#LazySets.reduce_order"><code>LazySets.reduce_order</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reduce_order(Z::AbstractZonotope, r::Real,
             [method]::AbstractReductionMethod=GIR05())</code></pre><p>Reduce the order of a zonotopic set by overapproximating with a zonotope with fewer generators.</p><p><strong>Input</strong></p><ul><li><code>Z</code>      – zonotopic set</li><li><code>r</code>      – desired order</li><li><code>method</code> – (optional, default: <code>GIR05()</code>) the reduction method used</li></ul><p><strong>Output</strong></p><p>A new zonotope with fewer generators, if possible.</p><p><strong>Algorithm</strong></p><p>The available algorithms are:</p><pre><code class="language-julia-repl hljs">julia&gt; subtypes(AbstractReductionMethod)
4-element Vector{Any}:
 LazySets.ASB10
 LazySets.COMB03
 LazySets.GIR05
 LazySets.SRMB16</code></pre><p>See the documentation of each algorithm for references. Most methods split the given zonotopic set <code>Z</code> into two zonotopes, <code>K</code> and <code>L</code>, where <code>K</code> contains the most &quot;representative&quot; generators and <code>L</code> contains the generators that are reduced, <code>Lred</code>, using a box overapproximation. This methodology varies slightly for <a href="#LazySets.SRMB16"><code>SRMB16</code></a>. We follow the notation from <a href="../../../bibliography/#YangS18">Yang and Scott [YS18]</a>. See also <a href="../../../bibliography/#KopetzkiSA17">Kopetzki <em>et al.</em> [KSA17]</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L834-L870">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.split-Tuple{AbstractZonotope, Int64}" href="#Base.split-Tuple{AbstractZonotope, Int64}"><code>Base.split</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split(Z::AbstractZonotope, j::Int)</code></pre><p>Return two zonotopes obtained by splitting the given zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li><li><code>j</code> – index of the generator to be split</li></ul><p><strong>Output</strong></p><p>The zonotope obtained by splitting <code>Z</code> into two zonotopes such that their union is <code>Z</code> and their intersection is possibly non-empty.</p><p><strong>Algorithm</strong></p><p>This function implements <a href="../../../bibliography/#AlthoffSB08">Althoff <em>et al.</em> [ASB08]</a>, Prop. 3, which we state next. The zonotopic set <span>$Z = ⟨c, g^{(1, …, p)}⟩$</span> is split into:</p><p class="math-container">\[Z₁ = ⟨c - \frac{1}{2}g^{(j)}, (g^{(1, …,j-1)}, \frac{1}{2}g^{(j)}, g^{(j+1, …, p)})⟩ \\
Z₂ = ⟨c + \frac{1}{2}g^{(j)}, (g^{(1, …,j-1)}, \frac{1}{2}g^{(j)}, g^{(j+1, …, p)})⟩,\]</p><p>such that <span>$Z₁ ∪ Z₂ = Z$</span> and <span>$Z₁ ∩ Z₂ = Z^*$</span>, where</p><p class="math-container">\[Z^* = ⟨c, (g^{(1,…,j-1)}, g^{(j+1,…, p)})⟩.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L645-L674">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.split-Tuple{AbstractZonotope, AbstractVector{Int64}, AbstractVector{Int64}}" href="#Base.split-Tuple{AbstractZonotope, AbstractVector{Int64}, AbstractVector{Int64}}"><code>Base.split</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split(Z::AbstractZonotope, gens::AbstractVector{Int},
      nparts::AbstractVector{Int})</code></pre><p>Split a zonotopic set along the given generators into a vector of zonotopes.</p><p><strong>Input</strong></p><ul><li><code>Z</code>    – zonotopic set</li><li><code>gens</code> – vector of indices of the generators to be split</li><li><code>n</code>    – vector of integers describing the number of partitions in the           corresponding generator</li></ul><p><strong>Output</strong></p><p>The zonotopes obtained by splitting <code>Z</code> into <code>2^{n_i}</code> zonotopes for each generator <code>i</code> such that their union is <code>Z</code> and their intersection is possibly non-empty.</p><p><strong>Examples</strong></p><p>Splitting of a two-dimensional zonotopic set along its first generator:</p><pre><code class="language-julia-repl hljs">julia&gt; Z = Zonotope([1.0, 0.0], [0.1 0.0; 0.0 0.1])
Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.0, 0.0], [0.1 0.0; 0.0 0.1])

julia&gt; split(Z, [1], [1])
2-element Vector{Zonotope{Float64, Vector{Float64}, Matrix{Float64}}}:
 Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.95, 0.0], [0.05 0.0; 0.0 0.1])
 Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.05, 0.0], [0.05 0.0; 0.0 0.1])</code></pre><p>Here, the first vector in the arguments corresponds to the zonotopic set&#39;s generator to be split, and the second vector corresponds to the exponent of <code>2^n</code> parts that the set will be split into along the corresponding generator.</p><p>As an example, below we split a two-dimensional zonotope along both of its generators, each time into four parts.</p><pre><code class="nohighlight hljs">julia&gt; Z = Zonotope([1.0, 0.0], [0.1 0.0; 0.0 0.1])
Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.0, 0.0], [0.1 0.0; 0.0 0.1])

julia&gt; split(Z, [1, 2], [2, 2])
16-element Vector{Zonotope{Float64, Vector{Float64}, Matrix{Float64}}}:
Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.925, -0.075], [0.025 0.0; 0.0 0.025])
Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.925, -0.025], [0.025 0.0; 0.0 0.025])
Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.925, 0.025], [0.025 0.0; 0.0 0.025])
Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.925, 0.075], [0.025 0.0; 0.0 0.025])
Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.975, -0.075], [0.025 0.0; 0.0 0.025])
Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.975, -0.025], [0.025 0.0; 0.0 0.025])
Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.975, 0.025], [0.025 0.0; 0.0 0.025])
Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.975, 0.075], [0.025 0.0; 0.0 0.025])
Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.025, -0.075], [0.025 0.0; 0.0 0.025])
Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.025, -0.025], [0.025 0.0; 0.0 0.025])
Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.025, 0.025], [0.025 0.0; 0.0 0.025])
Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.025, 0.075], [0.025 0.0; 0.0 0.025])
Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.075, -0.075], [0.025 0.0; 0.0 0.025])
Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.075, -0.025], [0.025 0.0; 0.0 0.025])
Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.075, 0.025], [0.025 0.0; 0.0 0.025])
Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.075, 0.075], [0.025 0.0; 0.0 0.025])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L679-L741">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope" href="#LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope"><code>LazySets.API.ρ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, X::LazySet)</code></pre><p>Evaluate the support function of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function of <code>X</code> in direction <code>d</code>.</p><p><strong>Notes</strong></p><p>A convenience alias <code>support_function</code> is also available.</p><p>We have the following identity based on the support vector <span>$σ$</span>:</p><p class="math-container">\[    ρ(d, X) = d ⋅ σ(d, X)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/API/Mixed/support_function.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.ρ-Tuple{AbstractVector, AbstractZonotope}" href="#LazySets.API.ρ-Tuple{AbstractVector, AbstractZonotope}"><code>LazySets.API.ρ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">ρ(d::AbstractVector, Z::AbstractZonotope)</code></pre><p><strong>Algorithm</strong></p><p>The support value is <span>$cᵀ d + ‖Gᵀ d‖₁$</span>, where <span>$c$</span> is the center and <span>$G$</span> is the generator matrix of <code>Z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L206-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope" href="#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope"><code>LazySets.API.σ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, X::LazySet)</code></pre><p>Compute a support vector of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A support vector of <code>X</code> in direction <code>d</code>.</p><p><strong>Notes</strong></p><p>A convenience alias <code>support_vector</code> is also available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/API/Mixed/support_vector.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.σ-Tuple{AbstractVector, AbstractZonotope}" href="#LazySets.API.σ-Tuple{AbstractVector, AbstractZonotope}"><code>LazySets.API.σ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">σ(d::AbstractVector, Z::AbstractZonotope)</code></pre><p><strong>Notes</strong></p><p>If the direction has norm zero, the vertex with <span>$ξ_i = 1 \ \ ∀ i = 1,…, p$</span> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L222-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isdisjoint-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope" href="#Base.isdisjoint-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope"><code>Base.isdisjoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isdisjoint(X::LazySet, Y::LazySet, [witness]::Bool=false)</code></pre><p>Check whether two sets are disjoint (i.e., do not intersect), and optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>Y</code>       – set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If the <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ∩ Y = ∅$</span></li><li>If the <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ∩ Y = ∅$</span></li><li><code>(false, v)</code> iff <span>$X ∩ Y ≠ ∅$</span> for some <span>$v ∈ X ∩ Y$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>The convenience alias <code>is_intersection_empty</code> is also available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/API/Binary/isdisjoint.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isdisjoint" href="#Base.isdisjoint"><code>Base.isdisjoint</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">isdisjoint(Z1::AbstractZonotope, Z2::AbstractZonotope,
           [witness]::Bool=false; [solver]=nothing)</code></pre><p><strong>Input</strong></p><ul><li><code>solver</code>  – (optional, default: <code>nothing</code>) the backend used to solve the              linear program</li></ul><p><strong>Algorithm</strong></p><p>The algorithm is taken from <a href="../../../bibliography/#GuibasNZ03">Guibas <em>et al.</em> [GNZ03]</a>.</p><p><span>$Z1 ∩ Z2 = ∅$</span> iff <span>$c_1 - c_2 ∉ Z(0, (g_1, g_2))$</span> where <span>$c_i$</span> and <span>$g_i$</span> are the center and generators of zonotope <code>Zi</code> and <span>$Z(c, g)$</span> represents the zonotope with center <span>$c$</span> and generators <span>$g$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/ConcreteOperations/isdisjoint.jl#L177-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.minkowski_difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope" href="#LazySets.API.minkowski_difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope"><code>LazySets.API.minkowski_difference</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minkowski_difference(X::LazySet, Y::LazySet)</code></pre><p>Compute the Minkowski difference of two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the Minkowski difference <span>$X ⊖ Y$</span>.</p><p><strong>Notes</strong></p><p>The Minkowski difference of two sets <span>$X$</span> and <span>$Y$</span> is defined as</p><p class="math-container">\[    X ⊖ Y = \{z \mid \{z\} ⊕ Y ⊆ X\}\]</p><p>The convenience alias <code>pontryagin_difference</code> is also available.</p><p>There is some inconsistency in the literature regarding the naming conventions. In this library, both <em>Minkowski difference</em> and <em>Pontryagin difference</em> refer to the geometric difference of two sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/API/Binary/minkowski_difference.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.minkowski_difference-Tuple{AbstractZonotope, AbstractZonotope}" href="#LazySets.API.minkowski_difference-Tuple{AbstractZonotope, AbstractZonotope}"><code>LazySets.API.minkowski_difference</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">minkowski_difference(Z1::AbstractZonotope, Z2::AbstractZonotope)</code></pre><p><strong>Output</strong></p><p>An <code>HPolytope</code>.</p><p><strong>Algorithm</strong></p><p>For one-dimensional sets, this method implements a simple algorithm for intervals. For two-dimensional sets, this method implements <a href="../../../bibliography/#Althoff15">Althoff [Alt15]</a>, Proposition 6. For higher-dimensional sets, this method implements <a href="../../../bibliography/#Althoff15">Althoff [Alt15]</a>, Theorem 3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/ConcreteOperations/minkowski_difference.jl#L97-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.minkowski_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope" href="#LazySets.API.minkowski_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope"><code>LazySets.API.minkowski_sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minkowski_sum(X::LazySet, Y::LazySet)</code></pre><p>Compute the Minkowski sum of two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the Minkowski sum <span>$X ⊕ Y$</span>.</p><p><strong>Notes</strong></p><p>The Minkowski sum of two sets <span>$X$</span> and <span>$Y$</span> is defined as</p><p class="math-container">\[    X ⊕ Y = \{x + y \mid x ∈ X, y ∈ Y\}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/API/Binary/minkowski_sum.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.minkowski_sum-Tuple{AbstractZonotope, AbstractZonotope}" href="#LazySets.API.minkowski_sum-Tuple{AbstractZonotope, AbstractZonotope}"><code>LazySets.API.minkowski_sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">minkowski_sum(Z1::AbstractZonotope, Z2::AbstractZonotope)</code></pre><p><strong>Algorithm</strong></p><p>The resulting zonotope is obtained by summing up the centers and concatenating the generators of <code>Z1</code> and <code>Z2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/ConcreteOperations/minkowski_sum.jl#L191-L200">source</a></section></article><p>Undocumented implementations:</p><ul><li><a href="../../API/#LazySets.API.project-Tuple{LazySets.API.LazySet, AbstractVector{Int64}}"><code>project</code></a></li><li><a href="../../API/#LazySets.API.cartesian_product-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>cartesian_product</code></a></li></ul><p>Inherited from <a href="../LazySet/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../LazySet/#LazySets.API.area-Tuple{LazySet}"><code>area</code></a></li><li><a href="../LazySet/#LazySets.chebyshev_center_radius-Tuple{LazySet}"><code>chebyshev_center_radius</code></a></li><li><a href="../LazySet/#LazySets.API.complement-Tuple{LazySet}"><code>complement</code></a></li><li><a href="../LazySet/#LazySets.API.concretize-Tuple{LazySet}"><code>concretize</code></a></li><li><a href="../LazySet/#LazySets.API.constraints-Tuple{LazySet}"><code>constraints</code></a></li><li><a href="../LazySet/#LazySets.API.convex_hull-Tuple{LazySet}"><code>convex_hull</code></a></li><li><code>copy(::Type{LazySet})</code></li><li><a href="../LazySet/#LazySets.API.diameter"><code>diameter</code></a></li><li><a href="../LazySet/#Base.eltype-Tuple{Type{&lt;:LazySet}}"><code>eltype</code></a></li><li><a href="../LazySet/#Base.eltype-Tuple{LazySet}"><code>eltype</code></a></li><li><a href="../LazySet/#LazySets.API.isoperation-Tuple{LazySet}"><code>isoperation</code></a></li><li><a href="../LazySet/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../LazySet/#Polyhedra.polyhedron-Tuple{LazySet}"><code>polyhedron</code></a></li><li><a href="../LazySet/#LazySets.API.radius"><code>radius</code></a></li><li><a href="../LazySet/#Base.rationalize-Union{Tuple{T}, Tuple{Type{T}, LazySet{&lt;:AbstractFloat}, Real}} where T&lt;:Integer"><code>rationalize</code></a></li><li><a href="../../API/#ReachabilityBase.Arrays.rectify-Tuple{LazySets.API.LazySet}"><code>rectify</code></a></li><li><a href="../LazySet/#LazySets.singleton_list-Tuple{LazySet}"><code>singleton_list</code></a></li><li><a href="../LazySet/#LazySets.tosimplehrep-Tuple{LazySet}"><code>tosimplehrep</code></a></li><li><a href="../LazySet/#LazySets.triangulate-Tuple{LazySet}"><code>triangulate</code></a></li><li><a href="../LazySet/#LazySets.triangulate_faces-Tuple{LazySet}"><code>triangulate_faces</code></a></li><li><a href="../LazySet/#LazySets.API.vertices-Tuple{LazySet}"><code>vertices</code></a></li><li><a href="../LazySet/#LazySets.API.affine_map-Tuple{Any, LazySet, AbstractVector}"><code>affine_map</code></a></li><li><a href="../LazySet/#LazySets.API.exponential_map-Tuple{AbstractMatrix, LazySet}"><code>exponential_map</code></a></li><li><a href="../../API/#LazySets.API.is_interior_point-Tuple{AbstractVector, LazySets.API.LazySet}"><code>is_interior_point</code></a></li><li><a href="../../utils/#LazySets.API.sample"><code>sample</code></a></li><li><a href="../LazySet/#LazySets.API.scale-Tuple{Real, LazySet}"><code>scale</code></a></li><li><a href="../LazySet/#LazySets.API.translate-Tuple{LazySet, AbstractVector}"><code>translate</code></a></li><li><a href="../LazySet/#LazySets.API.convex_hull-Tuple{LazySet, LazySet}"><code>convex_hull</code></a></li><li><a href="../../API/#LazySets.API.exact_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>exact_sum</code></a></li><li><a href="../LazySet/#Base.:≈-Tuple{LazySet, LazySet}"><code>≈</code></a></li><li><a href="../LazySet/#Base.:==-Tuple{LazySet, LazySet}"><code>==</code></a></li><li><a href="../LazySet/#LazySets.API.isequivalent-Tuple{LazySet, LazySet}"><code>isequivalent</code></a></li><li><a href="../../concrete_binary_operations/issubset/#LazySets.API.:⊂-Tuple{LazySet, LazySet}"><code>⊂</code></a></li></ul><p>Inherited from <a href="../ConvexSet/#LazySets.ConvexSet"><code>ConvexSet</code></a>:</p><ul><li><a href="../../API/#LazySets.API.isconvextype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>isconvextype</code></a></li><li><a href="../../API/#LazySets.API.linear_combination-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>linear_combination</code></a></li></ul><p>Inherited from <a href="../AbstractPolyhedron/#LazySets.AbstractPolyhedron"><code>AbstractPolyhedron</code></a>:</p><ul><li><a href="../../API/#LazySets.API.high-Tuple{LazySets.API.LazySet, Int64}"><code>high</code></a></li><li><a href="../../API/#LazySets.API.high-Tuple{LazySets.API.LazySet, Int64}"><code>high</code></a></li><li><a href="../../API/#LazySets.API.ispolyhedral-Tuple{LazySets.API.LazySet}"><code>ispolyhedral</code></a></li><li><a href="../../API/#LazySets.API.low-Tuple{LazySets.API.LazySet, Int64}"><code>low</code></a></li><li><a href="../../API/#LazySets.API.low-Tuple{LazySets.API.LazySet, Int64}"><code>low</code></a></li><li><a href="../AbstractPolyhedron/#LazySets.API.intersection-Union{Tuple{N}, Tuple{AbstractPolyhedron{N}, AbstractPolyhedron{N}}} where N"><code>intersection</code></a></li></ul><p>Inherited from <a href="../AbstractPolytope/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><a href="../../API/#LazySets.API.isbounded-Tuple{LazySets.API.LazySet}"><code>isbounded</code></a></li><li><a href="../../API/#LazySets.API.isboundedtype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>isboundedtype</code></a></li><li><a href="../AbstractPolytope/#LazySets.API.volume-Tuple{AbstractPolytope}"><code>volume</code></a></li><li><a href="../AbstractPolytope/#Base.:⊆"><code>⊆</code></a></li></ul><p>Inherited from <a href="../AbstractCentrallySymmetricPolytope/#LazySets.AbstractCentrallySymmetricPolytope"><code>AbstractCentrallySymmetricPolytope</code></a>:</p><ul><li><a href="../AbstractCentrallySymmetricPolytope/#LazySets.API.an_element-Tuple{AbstractCentrallySymmetricPolytope}"><code>an_element</code></a></li><li><a href="../../API/#LazySets.API.center-Tuple{LazySets.API.LazySet, Int64}"><code>center</code></a></li><li><a href="../../API/#LazySets.API.dim-Tuple{LazySets.API.LazySet}"><code>dim</code></a></li><li><a href="../AbstractCentrallySymmetricPolytope/#Base.extrema-Tuple{AbstractCentrallySymmetricPolytope}"><code>extrema</code></a></li><li><a href="../AbstractCentrallySymmetricPolytope/#Base.extrema-Tuple{AbstractCentrallySymmetricPolytope, Int64}"><code>extrema</code></a></li><li><a href="../../API/#Base.isempty"><code>isempty</code></a></li><li><a href="../AbstractCentrallySymmetricPolytope/#LazySets.API.isuniversal"><code>isuniversal</code></a></li></ul><h2 id="Internal-methods"><a class="docs-heading-anchor" href="#Internal-methods">Internal methods</a><a id="Internal-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.generators_fallback-Tuple{AbstractZonotope}" href="#LazySets.generators_fallback-Tuple{AbstractZonotope}"><code>LazySets.generators_fallback</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generators_fallback(Z::AbstractZonotope)</code></pre><p>Fallback definition of <code>generators</code> for zonotopic sets.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>An iterator over the generators of <code>Z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L131-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.genmat_fallback-Tuple{AbstractZonotope}" href="#LazySets.genmat_fallback-Tuple{AbstractZonotope}"><code>LazySets.genmat_fallback</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">genmat_fallback(Z::AbstractZonotope; [gens]=generators(Z), [ngens]=nothing)</code></pre><p>Fallback definition of <code>genmat</code> for zonotopic sets.</p><p><strong>Input</strong></p><ul><li><code>Z</code>     – zonotopic set</li><li><code>gens</code>  – (optional; default: <code>generators(Z)</code>) iterator over generators</li><li><code>ngens</code> – (optional; default: <code>nothing</code>) number of generators or <code>nothing</code> if            unknown</li></ul><p><strong>Output</strong></p><p>A matrix where each column represents one generator of <code>Z</code>.</p><p><strong>Notes</strong></p><p>Passing the number of generators (<code>ngens</code>) is more efficient, since otherwise the generators have to be obtained from the iterator (<code>gens</code>) and stored in an intermediate vector until the final result matrix can be allocated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L85-L106">source</a></section></article><h2 id="Order-reduction-methods"><a class="docs-heading-anchor" href="#Order-reduction-methods">Order-reduction methods</a><a id="Order-reduction-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Order-reduction-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.AbstractReductionMethod" href="#LazySets.AbstractReductionMethod"><code>LazySets.AbstractReductionMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractReductionMethod</code></pre><p>Abstract supertype for order-reduction methods of a zonotopic set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L784-L788">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.ASB10" href="#LazySets.ASB10"><code>LazySets.ASB10</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ASB10 &lt;: AbstractReductionMethod</code></pre><p>Zonotope order-reduction method from <a href="../../../bibliography/#AlthoffSB10">Althoff <em>et al.</em> [ASB10]</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L805-L809">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.COMB03" href="#LazySets.COMB03"><code>LazySets.COMB03</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">COMB03 &lt;: AbstractReductionMethod</code></pre><p>Zonotope order-reduction method from <a href="../../../bibliography/#Combastel03">Combastel [Com03]</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L798-L802">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.GIR05" href="#LazySets.GIR05"><code>LazySets.GIR05</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GIR05 &lt;: AbstractReductionMethod</code></pre><p>Zonotope order-reduction method from <a href="../../../bibliography/#Girard05">Girard [Gir05]</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L791-L795">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.SRMB16" href="#LazySets.SRMB16"><code>LazySets.SRMB16</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SRMB16 &lt;: AbstractReductionMethod</code></pre><p>Zonotope order-reduction method from <a href="../../../bibliography/#ScottRMB16">Scott <em>et al.</em> [SRMB16]</a>.</p><p><strong>Fields</strong></p><ul><li><code>ϵ</code> – (optional; default: <code>1e-6</code>) pivot threshold</li><li><code>δ</code> – (optional; default: <code>1e-3</code>) volume threshold</li></ul><p><strong>Notes</strong></p><p>The method reorders the generator matrix using reduced row echelon form (rref) to the form <span>$[T ~ V]$</span>, then iteratively removes one generator from <span>$V$</span> while updating <span>$T$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/f973fd702681158aad7a84dd48acb5ad1e956bbc/src/Interfaces/AbstractZonotope.jl#L812-L826">source</a></section></article><h2 id="Implementations"><a class="docs-heading-anchor" href="#Implementations">Implementations</a><a id="Implementations-1"></a><a class="docs-heading-anchor-permalink" href="#Implementations" title="Permalink"></a></h2><ul><li><a href="../../sets/Zonotope/#def_Zonotope">Zonotope</a></li><li><a href="../../sets/LineSegment/#def_LineSegment">Line segment (LineSegment)</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../AbstractCentrallySymmetricPolytope/">« Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a><a class="docs-footer-nextpage" href="../AbstractHyperrectangle/">Hyperrectangles (AbstractHyperrectangle) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Sunday 15 June 2025 16:50">Sunday 15 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
