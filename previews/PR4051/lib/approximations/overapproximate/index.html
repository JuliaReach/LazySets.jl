<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overapproximation · LazySets.jl</title><meta name="title" content="Overapproximation · LazySets.jl"/><meta property="og:title" content="Overapproximation · LazySets.jl"/><meta property="twitter:title" content="Overapproximation · LazySets.jl"/><meta name="description" content="Documentation for LazySets.jl."/><meta property="og:description" content="Documentation for LazySets.jl."/><meta property="twitter:description" content="Documentation for LazySets.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/aligned.css" rel="stylesheet" type="text/css"/><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">LazySets.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../../man/optional_dependencies/">Optional Features</a></li><li><a class="tocitem" href="../../../man/tour/">A Tour of LazySets</a></li><li><a class="tocitem" href="../../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../../man/unary_set_operations/">Unary Operations on Sets</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../API/">API</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Set Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../interfaces/overview/">Overview</a></li><li><a class="tocitem" href="../../interfaces/LazySet/">General sets (LazySet)</a></li><li><a class="tocitem" href="../../interfaces/ConvexSet/">Convex sets (ConvexSet)</a></li><li><a class="tocitem" href="../../interfaces/AbstractCentrallySymmetric/">Centrally symmetric sets (AbstractCentrallySymmetric)</a></li><li><a class="tocitem" href="../../interfaces/AbstractPolyhedron/">Polyhedra (AbstractPolyhedron)</a></li><li><a class="tocitem" href="../../interfaces/AbstractPolytope/">Polytopes (AbstractPolytope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractPolygon/">Polygons (AbstractPolygon)</a></li><li><a class="tocitem" href="../../interfaces/AbstractHPolygon/">Polygons in constraint representation (AbstractHPolygon)</a></li><li><a class="tocitem" href="../../interfaces/AbstractCentrallySymmetricPolytope/">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractZonotope/">Zonotopes (AbstractZonotope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractHyperrectangle/">Hyperrectangles (AbstractHyperrectangle)</a></li><li><a class="tocitem" href="../../interfaces/AbstractSingleton/">Singletons (AbstractSingleton)</a></li><li><a class="tocitem" href="../../interfaces/AbstractAffineMap/">Affine maps (AbstractAffineMap)</a></li><li><a class="tocitem" href="../../interfaces/AbstractPolynomialZonotope/">Polynomial zonotope sets (AbstractPolynomialZonotope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractSparsePolynomialZonotope/">Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractBallp/">Balls in the p-norm (AbstractBallp)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../../sets/DensePolynomialZonotope/">DensePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../../sets/HParallelotope/">HParallelotope</a></li><li><a class="tocitem" href="../../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../../sets/Line/">Line</a></li><li><a class="tocitem" href="../../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../../sets/Polygon/">Polygon</a></li><li><a class="tocitem" href="../../sets/SimpleSparsePolynomialZonotope/">SimpleSparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/SparsePolynomialZonotope/">SparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../../sets/Star/">Star</a></li><li><a class="tocitem" href="../../sets/Tetrahedron/">Tetrahedron</a></li><li><a class="tocitem" href="../../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../../sets/Zonotope/">Zonotope</a></li><li><a class="tocitem" href="../../sets/ZonotopeMD/">ZonotopeMD</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lazy_operations/AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../../lazy_operations/Bloating/">Bloating</a></li><li><a class="tocitem" href="../../lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../../lazy_operations/Complement/">Complement</a></li><li><a class="tocitem" href="../../lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../../lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../../lazy_operations/Intersection/">Intersection</a></li><li><a class="tocitem" href="../../lazy_operations/LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../../lazy_operations/InverseLinearMap/">InverseLinearMap</a></li><li><a class="tocitem" href="../../lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../../lazy_operations/QuadraticMap/">QuadraticMap</a></li><li><a class="tocitem" href="../../lazy_operations/Rectification/">Rectification</a></li><li><a class="tocitem" href="../../lazy_operations/ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../../lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../../lazy_operations/Translation/">Translation</a></li><li><a class="tocitem" href="../../lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Concrete Binary Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../concrete_binary_operations/overview/">Binary set operations</a></li><li><a class="tocitem" href="../../concrete_binary_operations/cartesian_product/">Cartesian Product</a></li><li><a class="tocitem" href="../../concrete_binary_operations/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../concrete_binary_operations/difference/">Set difference</a></li><li><a class="tocitem" href="../../concrete_binary_operations/distance/">Distance</a></li><li><a class="tocitem" href="../../concrete_binary_operations/intersection/">Intersection of two sets</a></li><li><a class="tocitem" href="../../concrete_binary_operations/minkowski_sum/">Minkowski Sum</a></li><li><a class="tocitem" href="../../concrete_binary_operations/minkowski_difference/">Minkowski Difference</a></li><li><a class="tocitem" href="../../concrete_binary_operations/isdisjoint/">Check for Disjointness of Sets</a></li><li><a class="tocitem" href="../../concrete_binary_operations/issubset/">Subset Check</a></li></ul></li><li><a class="tocitem" href="../../conversion/">Conversions between set representations</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox" checked/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Approximations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li class="is-active"><a class="tocitem" href>Overapproximation</a></li><li><a class="tocitem" href="../box_approximation/">Box Approximation</a></li><li><a class="tocitem" href="../iterative_refinement/">Iterative refinement</a></li><li><a class="tocitem" href="../template_directions/">Template directions</a></li><li><a class="tocitem" href="../underapproximate/">Underapproximation</a></li><li><a class="tocitem" href="../approximate/">Approximation</a></li><li><a class="tocitem" href="../decompose/">Cartesian Decomposition</a></li><li><a class="tocitem" href="../hausdorff_distance/">Hausdorff Distance</a></li><li><a class="tocitem" href="../overapproximate_norm/">Norm Overapproximation</a></li><li><a class="tocitem" href="../overapproximate_expmap/">Overapproximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">MatrixSets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../matrixsets/MatrixZonotope/">MatrixZonotope</a></li></ul></li><li><a class="tocitem" href="../../utils/">Utilities</a></li><li><a class="tocitem" href="../../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li><a class="is-disabled">Approximations</a></li><li class="is-active"><a href>Overapproximation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Overapproximation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/approximations/overapproximate.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#Overapproximation">Overapproximation</a></li></ul><h1 id="Overapproximation"><a class="docs-heading-anchor" href="#Overapproximation">Overapproximation</a><a id="Overapproximation-1"></a><a class="docs-heading-anchor-permalink" href="#Overapproximation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.Approximations.overapproximate" href="#LazySets.Approximations.overapproximate"><code>LazySets.Approximations.overapproximate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">overapproximate(X::S, ::Type{S}, args...) where {S&lt;:LazySet}</code></pre><p>Overapproximating a set of type <code>S</code> with type <code>S</code> is a no-op.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>Type{S}</code> – target set type</li><li><code>args</code>    – further arguments (ignored)</li><li><code>kwargs</code>  – further keyword arguments (ignored)</li></ul><p><strong>Output</strong></p><p>The input set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L6-L21">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(S::LazySet, T::Type{&lt;:LazySet}, [args]...; [kwargs]...)</code></pre><p>Default overapproximation method that falls back to <code>convert</code>.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>Type{S}</code> – target set type</li><li><code>args</code>    – further arguments</li><li><code>kwargs</code>  – further keyword arguments</li></ul><p><strong>Output</strong></p><p>The result of <code>convert</code>, or a <code>MethodError</code> if no such method exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L26-L41">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(S::LazySet)</code></pre><p>Alias for <code>overapproximate(S, Hyperrectangle)</code> resp. <code>box_approximation(S)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L46-L50">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(S::LazySet, ::Type{&lt;:Hyperrectangle})</code></pre><p>Alias for <code>box_approximation(S)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L53-L57">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(S::LazySet, ::Type{&lt;:BallInf})</code></pre><p>Alias for <code>ballinf_approximation(S)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L62-L66">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(S::LazySet{N},
                ::Type{&lt;:HPolygon},
                [ε]::Real=Inf) where {N}</code></pre><p>Overapproximate a given 2D set using iterative refinement.</p><p><strong>Input</strong></p><ul><li><code>S</code>        – two-dimensional bounded set</li><li><code>HPolygon</code> – target set type</li><li><code>ε</code>        – (optional, default: <code>Inf</code>) error tolerance</li><li><code>prune</code>    – (optional, default: <code>true</code>) flag for removing redundant               constraints in the end</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p><p><strong>Notes</strong></p><p>The result is always a convex overapproximation of the input set.</p><p>If no error tolerance ε is given, or is <code>Inf</code>, the result is a box-shaped polygon. For convex input sets, the result is an ε-close polygonal overapproximation with respect to the Hausdorff distance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L71-L97">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(S::LazySet, ε::Real)</code></pre><p>Alias for <code>overapproximate(S, HPolygon, ε)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L134-L138">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(X::LazySet{N}, dirs::AbstractDirections;
                [prune]::Bool=true) where {N}</code></pre><p>Overapproximate a (possibly unbounded) set with template directions.</p><p><strong>Input</strong></p><ul><li><code>X</code>     – set</li><li><code>dirs</code>  – directions</li><li><code>prune</code> – (optional, default: <code>true</code>) flag for removing redundant constraints</li></ul><p><strong>Output</strong></p><p>A polyhedron overapproximating the set <code>X</code> with the directions from <code>dirs</code>. The overapproximation is computed using the support function. The result is an <code>HPolytope</code> if it is bounded and otherwise an <code>HPolyhedron</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L150-L167">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(X::LazySet{N}, dirs::Type{&lt;:AbstractDirections}) where {N}</code></pre><p>Overapproximate a set with template directions.</p><p><strong>Input</strong></p><ul><li><code>X</code>    – set</li><li><code>dirs</code> – type of direction representation</li></ul><p><strong>Output</strong></p><p>A polyhedron overapproximating the set <code>X</code> with the directions from <code>dirs</code>. The result is an <code>HPolytope</code> if it is bounded and otherwise an <code>HPolyhedron</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L215-L229">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(cap::Intersection{N, &lt;:LazySet, &lt;:AbstractPolyhedron},
                dirs::AbstractDirections;
                kwargs...
               ) where {N}</code></pre><p>Overapproximate the intersection between a set and a polyhedron given a set of template directions.</p><p><strong>Input</strong></p><ul><li><code>cap</code>    – intersection of a set and a polyhedron</li><li><code>dirs</code>   – template directions</li><li><code>kwargs</code> – additional arguments that are passed to the support function             algorithm</li></ul><p><strong>Output</strong></p><p>A polytope or polyhedron in H-representation such that the normal direction of each half-space is given by an element of <code>dirs</code>.</p><p><strong>Algorithm</strong></p><p>Let <code>di</code> be a direction drawn from the set of template directions <code>dirs</code>. Let <code>X</code> be the set and let <code>P</code> be the polyhedron. We overapproximate the set <code>X ∩ H</code> with a polytope or polyhedron in constraint representation using a given set of template directions <code>dirs</code>.</p><p>The idea is to solve the univariate optimization problem <code>ρ(di, X ∩ Hi)</code> for each half-space of the set <code>P</code> and then take the minimum. This gives an overapproximation of the exact support function.</p><p>This algorithm is inspired from <a href="../../../bibliography/#FrehseR12">Frehse and Ray [FR12]</a>.</p><p><strong>Notes</strong></p><p>This method relies on having available the <code>constraints_list</code> of the polyhedron <code>P</code>.</p><p>This method may return a non-empty set even if the original set is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L264-L304">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(cap::Intersection{N, &lt;:HalfSpace, &lt;:AbstractPolytope},
                dirs::AbstractDirections;
                [kwargs]...
               ) where {N}</code></pre><p>Overapproximate the intersection between a half-space and a polytope given a set of template directions.</p><p><strong>Input</strong></p><ul><li><code>cap</code>    – intersection of a half-space and a polytope</li><li><code>dirs</code>   – template directions</li><li><code>kwargs</code> – additional arguments that are passed to the support function             algorithm</li></ul><p><strong>Output</strong></p><p>A polytope in H-representation such that the normal direction of each half-space is given by an element of <code>dirs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L322-L342">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(Z::AbstractZonotope, ::Type{&lt;:HParallelotope},
                [indices]=1:dim(Z))</code></pre><p>Overapproximate a zonotopic set with a parallelotope in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>Z</code>              – zonotopic set</li><li><code>HParallelotope</code> – target set type</li><li><code>indices</code>        – (optional; default: <code>1:dim(Z)</code>) generator indices selected                      when constructing the parallelotope</li></ul><p><strong>Output</strong></p><p>An overapproximation of the given zonotopic set using a parallelotope.</p><p><strong>Algorithm</strong></p><p>The algorithm is based on Proposition 8 discussed in <a href="../../../bibliography/#AlthoffSB10">Althoff <em>et al.</em> [ASB10]</a>, Section 5.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L377-L398">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(X::Intersection{N, &lt;:AbstractZonotope, &lt;:Hyperplane},
                dirs::AbstractDirections) where {N}</code></pre><p>Overapproximate the intersection between a zonotopic set and a hyperplane with a polyhedron or polytope using the given directions.</p><p><strong>Input</strong></p><ul><li><code>X</code>    – intersection between a zonotopic set and a hyperplane</li><li><code>dirs</code> – type of direction representation</li></ul><p><strong>Output</strong></p><p>An overapproximation of the intersection between a zonotopic set and a hyperplane. If the directions are bounding, the result is an <code>HPolytope</code>, otherwise the result is an <code>HPolyhedron</code>.</p><p><strong>Algorithm</strong></p><p>This function implements <a href="../../../bibliography/#LeGuernic09">Guernic [Gue09]</a>, Algorithm 8.1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L423-L444">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(QM::QuadraticMap{N, &lt;:SparsePolynomialZonotope},
                ::Type{&lt;:SparsePolynomialZonotope}) where {N}</code></pre><p>Overapproximate a quadratic map of a sparse polynomial zonotope with a sparse polynomial zonotope.</p><p><strong>Input</strong></p><ul><li><code>QM</code>                       – quadratic map of a sparse polynomial zonotope</li><li><code>SparsePolynomialZonotope</code> – target type</li></ul><p><strong>Output</strong></p><p>A sparse polynomial zonotope overapproximating the quadratic map of a sparse polynomial zonotope.</p><p><strong>Algorithm</strong></p><p>This method implements <a href="../../../bibliography/#KochdumperA21">Kochdumper and Althoff [KA21]</a>, Proposition 13.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L490-L510">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(P::VPolygon, ::Type{&lt;:LinearMap{N,&lt;:Hyperrectangle}}) where {N}</code></pre><p>Overapproximate a convex polygon with a minimal-area rotated rectangle.</p><p><strong>Input</strong></p><ul><li><code>P</code> – convex polygon</li><li><code>LinearMap{N,&lt;:Hyperrectangle}</code> – target type</li></ul><p><strong>Output</strong></p><p>A <code>LinearMap</code> of a <code>Hyperrectangle</code>.</p><p><strong>Algorithm</strong></p><p>This method follows an approach described in <a href="https://gis.stackexchange.com/a/22934">this post</a>, which itself is based on <a href="https://gis.stackexchange.com/a/22904">this post</a>.</p><p>Generally, the idea is that the rotated rectangle must share at least one edge with the polygon. Thus, it suffices to try out finitely many rectangles. Some tricks from linear algebra allow to construct the corresponding rotations and rectangles elegantly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L540-L564">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(P::AbstractSparsePolynomialZonotope{N}, ::Type{&lt;:VPolytope}) where {N}</code></pre><p>Overapproximate a sparse polynomial zonotope with a polytope in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>         – sparse polynomial zonotope</li><li><code>VPolytope</code> – target type</li></ul><p><strong>Output</strong></p><p>A <code>VPolytope</code>.</p><p><strong>Algorithm</strong></p><p>This method implements <a href="../../../bibliography/#Kochdumper21a">Kochdumper [Koc22]</a>, Proposition 3.1.15. The idea is to split <code>P</code> into a linear and nonlinear part (such that <code>P = P₁ ⊕ P₂</code>). The nonlinear part is enclosed by a zonotope. Then we combine the vertices of both sets and finally apply a convex-hull algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L603-L624">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">overapproximate(CH::ConvexHull{N,&lt;:AbstractSparsePolynomialZonotope,
                                 &lt;:AbstractSparsePolynomialZonotope},
                ::Type{&lt;:SparsePolynomialZonotope}) where {N}</code></pre><p><strong>Algorithm</strong></p><p>This method implements <a href="../../../bibliography/#Kochdumper21a">Kochdumper [Koc22]</a>, 3.1.28.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L725-L735">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(lm::LinearMap{N,S,NM,MAT},
                     ::Type{&lt;:SparsePolynomialZonotope}) where {N,
                                                                S&lt;:SparsePolynomialZonotope{N},
                                                                NM,MAT&lt;:MatrixZonotope{NM}}</code></pre><p>Overapproximate the linear map of a sparse polynomial zonotope through a matrix zonotope, following Proposition 2 in <a href="../../../bibliography/#HuangLBS2025">Huang <em>et al.</em> [HLBS25]</a>.</p><p><strong>Input</strong></p><ul><li><code>lm</code> – a linear map of a sparse polynomial zonotope through a matrix zonotope</li></ul><p><strong>Output</strong></p><p>A sparse polynomial zonotope overapproximating the linear map</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L814-L831">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(lm::LinearMap{N,S,NM,MAT},
                     ::Type{&lt;:SparsePolynomialZonotope}) where {N,S&lt;:SparsePolynomialZonotope{N},NM,
                                                MAT&lt;:MatrixZonotopeProduct{NM}}</code></pre><p>Overapproximate the linear map of a sparse polynomial zonotope through a product of matrix zonotopes, by recursively applying the overapproximation rule from the inside out.</p><p><strong>Input</strong></p><ul><li><code>lm</code> – a linear map of a sparse polynomial zonotope through a <code>MatrixZonotopeProduct</code></li><li><code>SparsePolynomialZonotope</code> – target type</li></ul><p><strong>Output</strong></p><p>An overapproximation of the linear map as a sparse polynomial zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L856-L872">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(MZP::MatrixZonotopeProduct{N,S},
                     ::Type{&lt;:MatrixZonotope}) where {N,S&lt;:AbstractMatrix{N}}</code></pre><p>Overapproximate the product of matrix zonotopes, following <a href="../../../bibliography/#AlthoffKS11">Althoff <em>et al.</em> [AKS11]</a>, Equation 4.10.</p><p><strong>Input</strong></p><ul><li><code>MZP</code> – a <code>MatrixZonotopeProduct</code></li><li><code>MatrixZonotope</code> – target type</li></ul><p><strong>Output</strong></p><p>A matrix zonotope overapproximating the matrix zonotope product</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L884-L898">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(S::LazySet, ::Type{&lt;:Interval})</code></pre><p>Return the overapproximation of a set with an interval.</p><p><strong>Input</strong></p><ul><li><code>S</code>        – one-dimensional set</li><li><code>Interval</code> – target type</li></ul><p><strong>Output</strong></p><p>An interval.</p><p><strong>Algorithm</strong></p><p>We use the <code>extrema</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_interval.jl#L1-L18">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(cap::Intersection, ::Type{&lt;:Interval})</code></pre><p>Return the overapproximation of a lazy intersection with an interval.</p><p><strong>Input</strong></p><ul><li><code>cap</code>      – one-dimensional intersection</li><li><code>Interval</code> – target type</li></ul><p><strong>Output</strong></p><p>An interval.</p><p><strong>Algorithm</strong></p><p>The algorithm recursively overapproximates the two intersected sets with intervals and then intersects these. (Note that this fails if the sets are unbounded.)</p><p>For convex sets this algorithm is precise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_interval.jl#L26-L47">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(cap::IntersectionArray, ::Type{&lt;:Interval})</code></pre><p>Return the overapproximation of an intersection array with an interval.</p><p><strong>Input</strong></p><ul><li><code>cap</code>      – one-dimensional intersection array</li><li><code>Interval</code> – target type</li></ul><p><strong>Output</strong></p><p>An interval.</p><p><strong>Algorithm</strong></p><p>The algorithm recursively overapproximates the intersected sets with intervals and then intersects these. (Note that this fails if the sets are unbounded.)</p><p>For convex sets this algorithm is precise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_interval.jl#L58-L79">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(Z::AbstractZonotope, ::Type{&lt;:Zonotope}, r::Real)</code></pre><p>Reduce the order of a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code>        – zonotopic set</li><li><code>Zonotope</code> – target set type</li><li><code>r</code>        – desired order</li></ul><p><strong>Output</strong></p><p>A new zonotope with <code>r</code> generators, if possible.</p><p><strong>Algorithm</strong></p><p>This method falls back to <code>reduce_order</code> with the default algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_zonotope.jl#L1-L19">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(X::ConvexHull{N, &lt;:AbstractZonotope, &lt;:AbstractZonotope},
                ::Type{&lt;:Zonotope}) where {N}</code></pre><p>Overapproximate the convex hull of two zonotopic sets.</p><p><strong>Input</strong></p><ul><li><code>X</code>         – convex hull of two zonotopic sets</li><li><code>Zonotope</code>  – target set type</li><li><code>algorithm</code> – (optional; default: <code>&quot;mean&quot;</code>) choice of algorithm; possible                values are <code>&quot;mean&quot;</code> and <code>&quot;join&quot;</code></li></ul><p><strong>Output</strong></p><p>A zonotope <span>$Z$</span> such that <span>$X ⊆ Z$</span>.</p><p><strong>Algorithm</strong></p><p>The algorithm can be controlled by the parameter <code>algorithm</code>. Note that the results of the two implemented algorithms are generally incomparable.</p><p><strong>&#39;mean&#39; method</strong></p><p>If <code>algorithm == &quot;mean&quot;</code>, we choose the method proposed in <a href="../../../bibliography/#Girard05">Girard [Gir05]</a>. The convex hull of two zonotopic sets <span>$Z₁$</span> and <span>$Z₂$</span> of the same order, which we write</p><p class="math-container">\[Z_j = ⟨c^{(j)}, g^{(j)}_1, …, g^{(j)}_p⟩\]</p><p>for <span>$j = 1, 2$</span>, can be overapproximated as follows:</p><p class="math-container">\[CH(Z_1, Z_2) ⊆ \frac{1}{2}⟨c^{(1)}+c^{(2)}, g^{(1)}_1+g^{(2)}_1, …,
g^{(1)}_p+g^{(2)}_p, c^{(1)}-c^{(2)}, g^{(1)}_1-g^{(2)}_1, …, g^{(1)}_p-g^{(2)}_p⟩.\]</p><p>If the zonotope order is not the same, this algorithm calls <code>reduce_order</code> to reduce the order to the minimum of the arguments.</p><p>It should be noted that the output zonotope is not necessarily the minimal enclosing zonotope, which is in general expensive to obtain in high dimensions. This is further investigated in <a href="../../../bibliography/#GuibasNZ03">Guibas <em>et al.</em> [GNZ03]</a>.</p><p><strong>&#39;join&#39; method</strong></p><p>If <code>algorithm == &quot;join&quot;</code>, we choose the method proposed in <a href="../../../bibliography/#GhorbalGP09">Ghorbal <em>et al.</em> [GGP09]</a>, Definition 1. The convex hull <span>$X$</span> of two zonotopic sets <span>$Z₁$</span> and <span>$Z₂$</span> is overapproximated by a zonotope <span>$Z₃$</span> such that the box approximation of <span>$X$</span> is identical with the box approximation of <span>$Z₃$</span>. Let <span>$□(X)$</span> denote the box approximation of <span>$X$</span>. The center of <span>$Z₃$</span> is the center of <span>$□(X)$</span>.</p><p>The generator construction consists of two phases. In the first phase, we construct generators <span>$g$</span> as a combination of one generator from <span>$Z₁$</span>, say, <span>$g₁$</span>, with another generator from <span>$Z₂$</span>, say, <span>$g₂$</span>. The entry of <span>$g$</span> in the <span>$i$</span>-th dimension is given as</p><p class="math-container">\[    g[i] = \argmin_{\min(g₁[i], g₂[i]) ≤ x ≤ \max(g₁[i], g₂[i])} |x|.\]</p><p>If <span>$g$</span> is the zero vector, it can be omitted.</p><p>In the second phase, we construct another generator for each dimension. These generators are scaled unit vectors. The following formula defines the sum of all those generators.</p><p class="math-container">\[    \sup(□(X)) - c - ∑_g |g|\]</p><p>where <span>$c$</span> is the center of the new zonotope and the <span>$g$</span>s are the generators constructed in the first phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_zonotope.jl#L24-L101">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(P::AbstractSparsePolynomialZonotope, ::Type{&lt;:Zonotope})</code></pre><p>Overapproximate a sparse polynomial zonotope with a zonotope.</p><p><strong>Input</strong></p><ul><li><code>P</code>        – sparse polynomial zonotope</li><li><code>Zonotope</code> – target set type</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method implements <a href="../../../bibliography/#Kochdumper21a">Kochdumper [Koc22]</a>, Proposition 3.1.14.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_zonotope.jl#L222-L239">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(P::AbstractSparsePolynomialZonotope, ::Type{&lt;:Zonotope},
                dom::IntervalBox)</code></pre><p>Overapproximate a sparse polynomial zonotope over the parameter domain <code>dom</code> with a zonotope.</p><p><strong>Input</strong></p><ul><li><code>P</code>         – sparse polynomial zonotope</li><li><code>Zonotope</code>  – target set type</li><li><code>dom</code>       – parameter domain, which should be a subset of <code>[-1, 1]^q</code>,                where <code>q = nparams(P)</code></li></ul><p><strong>Output</strong></p><p>A zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_zonotope.jl#L248-L265">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(P::DensePolynomialZonotope, ::Type{&lt;:Zonotope})</code></pre><p>Overapproximate a polynomial zonotope with a zonotope.</p><p><strong>Input</strong></p><ul><li><code>P</code>        – polynomial zonotope</li><li><code>Zonotope</code> – target set type</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method implements <a href="../../../bibliography/#Althoff13">Althoff [Alt13]</a>, Proposition 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_zonotope.jl#L296-L313">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(X::LazySet, ZT::Type{&lt;:Zonotope},
                dir::Union{AbstractDirections, Type{&lt;:AbstractDirections}};
                [algorithm]=&quot;vrep&quot;, kwargs...)</code></pre><p>Overapproximate a set with a zonotope.</p><p><strong>Input</strong></p><ul><li><code>X</code>         – set</li><li><code>Zonotope</code>  – target set type</li><li><code>dir</code>       – directions used for the generators</li><li><code>algorithm</code> – (optional, default: <code>&quot;vrep&quot;</code>) algorithm used to compute the                overapproximation</li><li><code>kwargs</code>    – further algorithm-specific options</li></ul><p><strong>Output</strong></p><p>A zonotope that overapproximates <code>X</code> and uses at most the generator directions provided in <code>dir</code> (redundant directions will be ignored).</p><p><strong>Notes</strong></p><p>Two algorithms are available:</p><ul><li><p><code>&quot;vrep&quot;</code> – Overapproximate a polytopic set with a zonotope of minimal total generator sum using only generators in the given directions. Under this constraint, the zonotope has the minimal sum of generator vectors. See the docstring of <a href="#LazySets.Approximations._overapproximate_zonotope_vrep"><code>_overapproximate_zonotope_vrep</code></a> for further details.</p></li><li><p><code>&quot;cpa&quot;</code> – Overapproximate a polytopic set with a zonotope using a Cartesian decomposition into two-dimensional blocks. See the docstring of <a href="#LazySets.Approximations._overapproximate_zonotope_cpa"><code>_overapproximate_zonotope_cpa</code></a> for further details.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_zonotope.jl#L713-L746">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(r::Rectification{N, &lt;:AbstractZonotope},
                ::Type{&lt;:Zonotope}) where {N}</code></pre><p>Overapproximate the rectification of a zonotopic set with a zonotope.</p><p><strong>Input</strong></p><ul><li><code>r</code>        – lazy rectification of a zonotopic set</li><li><code>Zonotope</code> – target set type</li></ul><p><strong>Output</strong></p><p>A zonotope overapproximation of the set obtained by rectifying <code>Z</code>.</p><p><strong>Algorithm</strong></p><p>This method implements <a href="../../../bibliography/#SinghGMPV18">Singh <em>et al.</em> [SGM+18]</a>, Theorem 3.1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_zonotope.jl#L959-L977">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(CHA::ConvexHullArray{N, &lt;:AbstractZonotope},
                ::Type{&lt;:Zonotope}) where {N}</code></pre><p>Overapproximate the convex hull of a list of zonotopic sets with a zonotope.</p><p><strong>Input</strong></p><ul><li><code>CHA</code>      – convex hull array of zonotopic sets</li><li><code>Zonotope</code> – target set type</li></ul><p><strong>Output</strong></p><p>A zonotope overapproximation of the convex hull array of zonotopic sets.</p><p><strong>Algorithm</strong></p><p>This method iteratively applies the overapproximation algorithm to the convex hull of two zonotopic sets from the given array of zonotopic sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_zonotope.jl#L1024-L1043">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(QM::QuadraticMap{N, &lt;:AbstractZonotope},
                ::Type{&lt;:Zonotope}) where {N}</code></pre><p>Overapproximate a quadratic map of a zonotopic set with a zonotope.</p><p><strong>Input</strong></p><ul><li><code>QM</code>       – quadratic map of a zonotopic set</li><li><code>Zonotope</code> – target set type</li></ul><p><strong>Output</strong></p><p>A zonotope overapproximating the quadratic map of a zonotopic set.</p><p><strong>Notes</strong></p><p>Mathematically, a quadratic map of a zonotope with matrices <span>$Q$</span> is defined as:</p><p class="math-container">\[    Z_Q = \right\{ λ \mid λ_i = x^T Q\^{(i)} x,~i = 1, …, n,~x ∈ Z \left\}\]</p><p><strong>Algorithm</strong></p><p>This method implements <a href="../../../bibliography/#AlthoffK12">Althoff and Krogh [AK12]</a>, Lemma 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_zonotope.jl#L1066-L1092">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(X::Intersection{N, &lt;:AbstractZonotope, &lt;:Hyperplane},
                ::Type{&lt;:Zonotope})</code></pre><p>Overapproximate the intersection of a zonotopic set and a hyperplane with a zonotope.</p><p><strong>Input</strong></p><ul><li><code>X</code>        – intersection of a zonotopic set and a hyperplane</li><li><code>Zonotope</code> – target set type</li></ul><p><strong>Output</strong></p><p>A zonotope overapproximating the intersection.</p><p><strong>Algorithm</strong></p><p>This method implements <a href="../../../bibliography/#MaigaRTC14">Maı̈ga <em>et al.</em> [MRTC14]</a>, Algorithm 3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_zonotope.jl#L1126-L1145">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(lm::LinearMap{N,S,NM,MAT},
                     ::Type{Zonotope}) where {N,S&lt;:AbstractZonotope{N},NM,
                                              MAT&lt;:MatrixZonotope{NM}}</code></pre><p>Overapproximate the linear map of a zonotope through a matrix zonotope, following <a href="../../../bibliography/#AlthoffGK11">Althoff <em>et al.</em> [AGK11]</a>, Proposition 4.</p><p><strong>Input</strong></p><ul><li><code>lm</code> – a linear map of a zonotope through a matrix zonotope</li></ul><p><strong>Output</strong></p><p>A zonotope overapproximating the linear map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_zonotope.jl#L1248-L1264">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(lm::LinearMap{N,S,NM,MAT},
                     ::Type{&lt;:Zonotope}) where {N,S&lt;:AbstractZonotope{N},NM,
                                                MAT&lt;:MatrixZonotopeProduct{NM}}</code></pre><p>Overapproximate the linear map of a zonotope through a product of matrix zonotopes, by recursively applying the overapproximation rule from the inside out.</p><p><strong>Input</strong></p><ul><li><code>lm</code> – a linear map of a zonotope through a <code>MatrixZonotopeProduct</code></li><li><code>Zonotope</code> – target type</li></ul><p><strong>Output</strong></p><p>An overapproximation of the linear map as a zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_zonotope.jl#L1291-L1307">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(lm::LinearMap{N, &lt;:CartesianProductArray},
                ::Type{&lt;:CartesianProductArray{N, S}}
               ) where {N, S&lt;:LazySet}</code></pre><p>Decompose a lazy linear map of a Cartesian product array while keeping the original block structure.</p><p><strong>Input</strong></p><ul><li><code>lm</code>                    – lazy linear map of Cartesian product array</li><li><code>CartesianProductArray</code> – target set type</li></ul><p><strong>Output</strong></p><p>A <code>CartesianProductArray</code> representing the decomposed linear map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_cartesianproductarray.jl#L1-L17">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(lm::LinearMap{N, &lt;:CartesianProductArray},
                ::Type{&lt;:CartesianProductArray},
                dir::Type{&lt;:AbstractDirections}) where {N}</code></pre><p>Decompose a lazy linear map of a Cartesian product array with template directions while keeping the original block structure.</p><p><strong>Input</strong></p><ul><li><code>lm</code>                    – lazy linear map of a Cartesian product array</li><li><code>CartesianProductArray</code> – target set type</li><li><code>dir</code>                   – template directions for overapproximation</li></ul><p><strong>Output</strong></p><p>A <code>CartesianProductArray</code> representing the decomposed linear map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_cartesianproductarray.jl#L25-L42">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(lm::LinearMap{N, &lt;:CartesianProductArray},
                ::Type{&lt;:CartesianProductArray},
                set_type::Type{&lt;:LazySet}) where {N}</code></pre><p>Decompose a lazy linear map of a Cartesian product array with a given set type while keeping the original block structure.</p><p><strong>Input</strong></p><ul><li><code>lm</code>                    – lazy linear map of a Cartesian product array</li><li><code>CartesianProductArray</code> – target set type</li><li><code>set_type</code>              – set type for overapproximation</li></ul><p><strong>Output</strong></p><p>A <code>CartesianProductArray</code> representing the decomposed linear map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_cartesianproductarray.jl#L51-L68">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(rm::ResetMap{N, &lt;:CartesianProductArray},
                ::Type{&lt;:CartesianProductArray}, oa) where {N}</code></pre><p>Overapproximate a reset map (that only resets to zero) of a Cartesian product with a new Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>rm</code>                    – reset map</li><li><code>CartesianProductArray</code> – target set type</li><li><code>oa</code>                    – overapproximation option</li></ul><p><strong>Output</strong></p><p>A Cartesian product with the same block structure.</p><p><strong>Notes</strong></p><p>This implementation currently only supports resets to zero.</p><p><strong>Algorithm</strong></p><p>We convert the <code>ResetMap</code> into a <code>LinearMap</code> and then call the corresponding <code>overapproximate</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_cartesianproductarray.jl#L102-L127">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(cap::Intersection{N,
                                  &lt;:CartesianProductArray,
                                  &lt;:AbstractPolyhedron},
                ::Type{&lt;:CartesianProductArray}, oa) where {N}</code></pre><p>Overapproximate the intersection of a Cartesian product of a finite number of sets and a polyhedron with a new Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cap</code>                   – lazy intersection of a Cartesian product array and                            a polyhedron</li><li><code>CartesianProductArray</code> – target set type</li><li><code>oa</code>                    – overapproximation option</li></ul><p><strong>Output</strong></p><p>A <code>CartesianProductArray</code> that overapproximates the intersection of <code>cpa</code> and <code>P</code>.</p><p><strong>Algorithm</strong></p><p>The intersection only needs to be computed in the blocks of <code>cpa</code> that are constrained in <code>P</code>. Hence we first collect those constrained blocks in a lower-dimensional Cartesian product array and then convert to an <code>HPolytope</code> <code>X</code>. Then we take the intersection of <code>X</code> and the projection of <code>Y</code> onto the corresponding dimensions. (This projection is purely syntactic and exact.) Finally we decompose the result again and plug together the unaffected old blocks and the newly computed blocks. The result is a <code>CartesianProductArray</code> with the same block structure as in <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_cartesianproductarray.jl#L138-L171">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(em::ExponentialMap{N,S,MAT},
                     ::Type{&lt;:SparsePolynomialZonotope},
                     k::Int=2;
                     [matnorm]::Union{Real,Nothing}=nothing) where {N,
                                                                  S&lt;:SparsePolynomialZonotope,
                                                                  MAT&lt;:AbstractMatrixZonotope{N}}</code></pre><p>Overapproximate the exponential map of a sparse polynomial zonotope through a composition of matrix zonotopes, following Proposition 3 of <a href="../../../bibliography/#HuangLBS2025">Huang <em>et al.</em> [HLBS25]</a>.</p><p><strong>Input</strong></p><ul><li><code>em</code>      – an expontial map of a sparse polynomial zonotope through a product of matrix zonotopes</li><li><code>SparsePolynomialZonotope</code> – target type</li><li><code>k</code>       – (default: <code>2</code>) the order of the taylor expansion</li><li><code>matnorm</code> – (Optional, default: <code>nothing</code>) Pre-computed induced <span>$\infty$</span>-norm of the matrix zonotope</li></ul><p><strong>Output</strong></p><p>A sparse polynomial zonotope overapproximating the exponential map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_expmap.jl#L242-L263">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(em::ExponentialMap{N,S,MAT}, ::Type{&lt;:Zonotope},
                     k::Int=2;
                     [matnorm]::Union{Real,Nothing}=nothing) where {N,S&lt;:AbstractZonotope,
                                                                  MAT&lt;:AbstractMatrixZonotope{N}}</code></pre><p>Overapproximate the exponential map of a zonotope through a composition of matrix zonotopes, following Proposition 3 of <a href="../../../bibliography/#HuangLBS2025">Huang <em>et al.</em> [HLBS25]</a>.</p><p><strong>Input</strong></p><ul><li><code>em</code>       – an expontial map of a zonotope through a product of matrix zonotopes</li><li><code>Zonotope</code> – target type</li><li><code>k</code>        – (default: <code>2</code>) the order of the taylor expansion</li><li><code>matnorm</code>  – (Optional, default: <code>nothing</code>) Pre-computed induced <span>$\infty$</span>-norm of the matrix zonotope</li></ul><p><strong>Output</strong></p><p>A zonotope overapproximating the exponential map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_expmap.jl#L274-L293">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(vTM::Vector{TaylorModel1{T, S}}, ::Type{&lt;:Zonotope};
                [remove_redundant_generators]::Bool=true
                [normalize]::Bool=true) where {T, S}</code></pre><p>Overapproximate a Taylor model in one variable with a zonotope.</p><p><strong>Input</strong></p><ul><li><code>vTM</code>       – vector of <code>TaylorModel1</code></li><li><code>Zonotope</code>  –  target set type</li><li><code>remove_redundant_generators</code> – (optional; default: <code>true</code>) flag to remove                                  redundant generators of the resulting zonotope</li><li><code>normalize</code> – (optional; default: <code>true</code>) flag to skip the normalization of                the Taylor models</li></ul><p><strong>Output</strong></p><p>A zonotope that overapproximates the range of the given Taylor model.</p><p><strong>Examples</strong></p><p>If the polynomials are linear, this method exactly transforms to a zonotope. The nonlinear case necessarily introduces overapproximation error. Consider the linear case first:</p><pre><code class="language-julia-repl hljs">julia&gt; using LazySets, TaylorModels

julia&gt; const IA = IntervalArithmetic;

julia&gt; I = IA.interval(-0.5, 0.5) # interval remainder
[-0.5, 0.5]

julia&gt; x₀ = IA.interval(0.0) # expansion point
[0, 0]

julia&gt; D = IA.interval(-3.0, 1.0)
[-3, 1]

julia&gt; p1 = Taylor1([2.0, 1.0], 2) # define a linear polynomial
 2.0 + 1.0 t + 𝒪(t³)

julia&gt; p2 = Taylor1([0.9, 3.0], 2) # define another linear polynomial
 0.9 + 3.0 t + 𝒪(t³)

julia&gt; vTM = [TaylorModel1(pi, I, x₀, D) for pi in [p1, p2]]
2-element Vector{TaylorModel1{Float64, Float64}}:
  2.0 + 1.0 t + [-0.5, 0.5]
  0.9 + 3.0 t + [-0.5, 0.5]</code></pre><p>Here, <code>vTM</code> is a Taylor model vector, since each component is a Taylor model in one variable (<code>TaylorModel1</code>). Using <code>overapproximate(vTM, Zonotope)</code> we can compute its associated zonotope in generator representation:</p><pre><code class="language-julia-repl hljs">julia&gt; Z = overapproximate(vTM, Zonotope);

julia&gt; center(Z)
2-element Vector{Float64}:
  1.0
 -2.1

julia&gt; Matrix(genmat(Z))
2×3 Matrix{Float64}:
 0.0  2.0  0.5
 0.5  6.0  0.0</code></pre><p>Note how the generators of this zonotope mainly consist of two pieces: one comes from the linear part of the polynomials, and another one corresponds to the interval remainder. This conversion gives the same upper and lower bounds as the range evaluation using interval arithmetic:</p><pre><code class="language-julia-repl hljs">julia&gt; X = box_approximation(Z)
Hyperrectangle{Float64, Vector{Float64}, Vector{Float64}}([1.0, -2.1], [2.5, 6.5])

julia&gt; Y = evaluate(vTM[1], vTM[1].dom) × evaluate(vTM[2], vTM[2].dom)
[-1.5, 3.5] × [-8.60001, 4.40001]

julia&gt; H = convert(Hyperrectangle, Y) # this IntervalBox is the same as X
Hyperrectangle{Float64, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}([1.0, -2.1000000000000005], [2.5, 6.500000000000001])</code></pre><p>However, the zonotope returns better results if we want to approximate the Taylor model because it is not axis-aligned:</p><pre><code class="language-julia-repl hljs">julia&gt; d = [-0.35, 0.93];

julia&gt; ρ(d, Z) &lt; ρ(d, X)
true</code></pre><p>This method also works if the polynomials are non-linear; for example suppose that we add a third polynomial with a quadratic term:</p><pre><code class="language-julia-repl hljs">julia&gt; p3 = Taylor1([0.9, 3.0, 1.0], 3)
 0.9 + 3.0 t + 1.0 t² + 𝒪(t⁴)

julia&gt; vTM = [TaylorModel1(pi, I, x₀, D) for pi in [p1, p2, p3]]
3-element Vector{TaylorModel1{Float64, Float64}}:
           2.0 + 1.0 t + [-0.5, 0.5]
           0.9 + 3.0 t + [-0.5, 0.5]
  0.9 + 3.0 t + 1.0 t² + [-0.5, 0.5]

julia&gt; Z = overapproximate(vTM, Zonotope);

julia&gt; center(Z)
3-element Vector{Float64}:
  1.0
 -2.1
  2.4

julia&gt; Matrix(genmat(Z))
3×4 Matrix{Float64}:
 0.0  0.0  2.0  0.5
 0.0  0.5  6.0  0.0
 5.0  0.0  6.0  0.0</code></pre><p>The last generator corresponds to the addition of the interval remainder and the box overapproximation of the nonlinear part of <code>p3</code> over the domain.</p><p><strong>Algorithm</strong></p><p>Let <span>$\text{vTM} = (p, I)$</span> be a vector of <span>$m$</span> Taylor models, where <span>$I$</span> is the interval remainder in <span>$ℝ^m$</span>. Let <span>$p_{lin}$</span> (resp. <span>$p_{nonlin}$</span>) correspond to the linear (resp. nonlinear) part of each scalar polynomial.</p><p>The range of <span>$\text{vTM}$</span> can be enclosed by a zonotope with center <span>$c$</span> and matrix of generators <span>$G$</span>, <span>$Z = ⟨c, G⟩$</span>, by performing a conservative linearization of <span>$\text{vTM}$</span>:</p><p class="math-container">\[    vTM&#39; = (p&#39;, I&#39;) := (p_{lin} − p_{nonlin} , I + \text{Int}(p_{nonlin})).\]</p><p>This algorithm proceeds in two steps:</p><p>1- Conservatively linearize <span>$\text{vTM}$</span> as above and compute a box    overapproximation of the nonlinear part. 2- Transform the linear Taylor model to a zonotope exactly through variable    normalization onto the symmetric intervals <span>$[-1, 1]$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_zonotope.jl#L364-L511">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(vTM::Vector{TaylorModelN{N, T, S}}, ::Type{&lt;:Zonotope};
                [remove_redundant_generators]::Bool=true
                [normalize]::Bool=true) where {N, T, S}</code></pre><p>Overapproximate a multivariate Taylor model with a zonotope.</p><p><strong>Input</strong></p><ul><li><code>vTM</code>       – vector of <code>TaylorModelN</code></li><li><code>Zonotope</code>  – target set type</li><li><code>remove_redundant_generators</code> – (optional; default: <code>true</code>) flag to remove                                  redundant generators of the resulting zonotope</li><li><code>normalize</code> – (optional; default: <code>true</code>) flag to skip the normalization of                the Taylor models</li></ul><p><strong>Output</strong></p><p>A zonotope that overapproximates the range of the given Taylor model.</p><p><strong>Examples</strong></p><p>Consider a vector of two 2-dimensional Taylor models of order 2 and 4, respectively.</p><pre><code class="language-julia-repl hljs">julia&gt; using LazySets, TaylorModels

julia&gt; const IA = IntervalArithmetic;

julia&gt; x₁, x₂ = set_variables(Float64, [&quot;x₁&quot;, &quot;x₂&quot;], order=8)
2-element Vector{TaylorN{Float64}}:
  1.0 x₁ + 𝒪(‖x‖⁹)
  1.0 x₂ + 𝒪(‖x‖⁹)

julia&gt; x₀ = IA.IntervalBox(0..0, 2) # expansion point
[0, 0]²

julia&gt; Dx₁ = IA.interval(0.0, 3.0) # domain for x₁
[0, 3]

julia&gt; Dx₂ = IA.interval(-1.0, 1.0) # domain for x₂
[-1, 1]

julia&gt; D = Dx₁ × Dx₂ # take the Cartesian product of the domain on each variable
[0, 3] × [-1, 1]

julia&gt; r = IA.interval(-0.5, 0.5) # interval remainder
[-0.5, 0.5]

julia&gt; p1 = 1 + x₁^2 - x₂
 1.0 - 1.0 x₂ + 1.0 x₁² + 𝒪(‖x‖⁹)

julia&gt; p2 = x₂^3 + 3x₁^4 + x₁ + 1
 1.0 + 1.0 x₁ + 1.0 x₂³ + 3.0 x₁⁴ + 𝒪(‖x‖⁹)

julia&gt; vTM = [TaylorModelN(pi, r, x₀, D) for pi in [p1, p2]]
2-element Vector{TaylorModelN{2, Float64, Float64}}:
            1.0 - 1.0 x₂ + 1.0 x₁² + [-0.5, 0.5]
  1.0 + 1.0 x₁ + 1.0 x₂³ + 3.0 x₁⁴ + [-0.5, 0.5]

julia&gt; Z = overapproximate(vTM, Zonotope);

julia&gt; center(Z)
2-element Vector{Float64}:
   5.5
 124.0

julia&gt; Matrix(genmat(Z))
2×2 Matrix{Float64}:
   0.0   6.0
 124.5  -0.0</code></pre><p><strong>Algorithm</strong></p><p>We refer to the algorithm description for the univariate case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_zonotope.jl#L520-L598">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(lm::LinearMap{N, &lt;:AbstractZonotope, NM,
                              &lt;:AbstractIntervalMatrix{NM}},
                ::Type{&lt;:Zonotope}) where {N, NM}</code></pre><p>Overapproximate an interval-matrix linear map of a zonotopic set by a zonotope.</p><p><strong>Input</strong></p><ul><li><code>lm</code>       – interval-matrix linear map of a zonotopic set</li><li><code>Zonotope</code> – target set type</li></ul><p><strong>Output</strong></p><p>A zonotope overapproximating the linear map.</p><p><strong>Algorithm</strong></p><p>This implementation uses the method proposed in <a href="../../../bibliography/#AlthoffSB07">Althoff <em>et al.</em> [ASB07]</a>.</p><p>Given an interval matrix <span>$M = \tilde{M} + ⟨-\hat{M},\hat{M}⟩$</span> (split into a conventional matrix and a symmetric interval matrix) and a zonotope <span>$⟨c, g_1, …, g_m⟩$</span>, we compute the resulting zonotope <span>$⟨\tilde{M}c, \tilde{M}g_1, …, \tilde{M}g_m, v_1, …, v_n⟩$</span> where the <span>$v_j$</span>, <span>$j = 1, …, n$</span>, are defined as</p><p class="math-container">\[    v_j = \begin{cases} 0 &amp; i ≠ j \\
          \hat{M}_j (|c| + ∑_{k=1}^m |g_k|) &amp; i = j. \end{cases}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_zonotope.jl#L659-L689">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(expA::MatrixZonotopeExp{N,T}, ::Type{&lt;:MatrixZonotope},
                     k::Int=2) where {N,T&lt;:AbstractMatrixZonotope{N}}</code></pre><p>Overapproximate the matrix zonotope exponential <span>$exp(\mathcal{A})$</span></p><p><strong>Input</strong></p><ul><li><code>expA</code> – <code>MatrixZonotopeExp</code></li><li><code>MatrixZonotope</code> – target type</li><li><code>k</code> – (default: <code>2</code>) the order of the Taylor expansion</li></ul><p><strong>Output</strong></p><p>A matrix zonotope overapproximating the matrix zonotope exponential</p><p><strong>Algorithm</strong></p><p>The expansion</p><p class="math-container">\[exp(\mathcal{A}) ⊆ \sum_i^k \frac{\mathcal{A}^i}{i!} + E_k\]</p><p>is computed by overapproximating the matrix zonotope powers <span>$A^i$</span> for <span>$i=0, …, k$</span>. The remainder term <span>$E_k$</span> is computed through interval arithmetic following <a href="../../../bibliography/#AlthoffKS11">Althoff <em>et al.</em> [AKS11]</a>, Proposition 4.1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_expmap.jl#L160-L188">source</a></section><section><div><pre><code class="language-julia hljs">overapproximate(A::MatrixZonotope, ::Type{&lt;:IntervalMatrix})</code></pre><p>Overapproximate a matrix zonotope by an interval matrix</p><p><strong>Input</strong></p><ul><li><code>A</code> – a matrix zonotope</li><li><code>IntervalMatrix</code> – target type</li></ul><p><strong>Output</strong></p><p>An interval matrix overapproximating the matrix zonotope</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate.jl#L938-L951">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.Approximations._overapproximate_zonotope_vrep" href="#LazySets.Approximations._overapproximate_zonotope_vrep"><code>LazySets.Approximations._overapproximate_zonotope_vrep</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_overapproximate_zonotope_vrep(X::LazySet{N},
                               dir::AbstractDirections;
                               solver=default_lp_solver(N)) where {N}</code></pre><p>Overapproximate a polytopic set with a zonotope of minimal total generator sum using only generators in the given directions.</p><p><strong>Input</strong></p><ul><li><code>X</code>      – polytopic set</li><li><code>dir</code>    – directions used for the generators</li><li><code>solver</code> – (optional, default: <code>default_lp_solver(N)</code>) the backend used to             solve the linear program</li></ul><p><strong>Output</strong></p><p>A zonotope that overapproximates <code>X</code> and uses at most the directions provided in <code>dir</code> (redundant directions will be ignored). Under this constraint, the zonotope has the minimal sum of generator vectors.</p><p><strong>Notes</strong></p><p>The algorithm only requires one representative of each generator direction and their additive inverse (e.g., only one of <code>[1, 0]</code> and <code>[-1, 0]</code>) and assumes that the directions are normalized. We preprocess the directions in that respect.</p><p><strong>Algorithm</strong></p><p>We solve a linear program parametric in the vertices <span>$v_j$</span> of <code>X</code> and the directions <span>$d_k$</span> in <code>dir</code> presented in Section 4.2 in <a href="../../../bibliography/#GuibasNZ03">Guibas <em>et al.</em> [GNZ03]</a>, adapting the notation to the one used in this library.</p><p class="math-container">\[    \min ∑_{k=1}^l α_k \
    s.t. \
    c + ∑_{k=1}^l b_{kj} * d_k = v_j \quad ∀ j \
    -α_k ≤ b_{kj} ≤ α_k \quad ∀ k, j \
    α_k ≥ 0 \quad ∀ k\]</p><p>The resulting zonotope has center <code>c</code> and generators <code>α_k · d_k</code>.</p><p>Note that the first type of side constraints is vector-based and that the nonnegativity constraints (last type) are not stated explicitly in [<a href="../../../bibliography/#GuibasNZ03">GNZ03</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_zonotope.jl#L772-L818">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.Approximations._overapproximate_zonotope_cpa" href="#LazySets.Approximations._overapproximate_zonotope_cpa"><code>LazySets.Approximations._overapproximate_zonotope_cpa</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_overapproximate_zonotope_cpa(X::LazySet, dir::Type{&lt;:AbstractDirections})</code></pre><p>Overapproximate a polytopic set with a zonotope using Cartesian decomposition.</p><p><strong>Input</strong></p><ul><li><code>X</code>   – polytopic set</li><li><code>dir</code> – directions used for the generators</li></ul><p><strong>Output</strong></p><p>A zonotope that overapproximates <code>X</code>.</p><p><strong>Notes</strong></p><p>The algorithm decomposes <code>X</code> into 2D sets and overapproximates those sets with zonotopes, and finally converts the Cartesian product of the sets to a zonotope.</p><p><strong>Algorithm</strong></p><p>The implementation is based on <a href="../../../bibliography/#LeGuernic09">Guernic [Gue09]</a>, Section 8.2.4.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6f75e939341352d41c52152b29b82a5827a2e8f7/src/Approximations/overapproximate_zonotope.jl#L902-L924">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview/">« Overview</a><a class="docs-footer-nextpage" href="../box_approximation/">Box Approximation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Sunday 26 October 2025 12:13">Sunday 26 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
