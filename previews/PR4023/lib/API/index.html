<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · LazySets.jl</title><meta name="title" content="API · LazySets.jl"/><meta property="og:title" content="API · LazySets.jl"/><meta property="twitter:title" content="API · LazySets.jl"/><meta name="description" content="Documentation for LazySets.jl."/><meta property="og:description" content="Documentation for LazySets.jl."/><meta property="twitter:description" content="Documentation for LazySets.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/aligned.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LazySets.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../man/optional_dependencies/">Optional Features</a></li><li><a class="tocitem" href="../../man/tour/">A Tour of LazySets</a></li><li><a class="tocitem" href="../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../man/unary_set_operations/">Unary Operations on Sets</a></li><li><a class="tocitem" href="../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Unary-set-functions"><span>Unary set functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Mixed-set-functions"><span>Mixed set functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Binary-set-functions"><span>Binary set functions</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Set Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../interfaces/overview/">Overview</a></li><li><a class="tocitem" href="../interfaces/LazySet/">General sets (LazySet)</a></li><li><a class="tocitem" href="../interfaces/ConvexSet/">Convex sets (ConvexSet)</a></li><li><a class="tocitem" href="../interfaces/AbstractCentrallySymmetric/">Centrally symmetric sets (AbstractCentrallySymmetric)</a></li><li><a class="tocitem" href="../interfaces/AbstractPolyhedron/">Polyhedra (AbstractPolyhedron)</a></li><li><a class="tocitem" href="../interfaces/AbstractPolytope/">Polytopes (AbstractPolytope)</a></li><li><a class="tocitem" href="../interfaces/AbstractPolygon/">Polygons (AbstractPolygon)</a></li><li><a class="tocitem" href="../interfaces/AbstractHPolygon/">Polygons in constraint representation (AbstractHPolygon)</a></li><li><a class="tocitem" href="../interfaces/AbstractCentrallySymmetricPolytope/">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a></li><li><a class="tocitem" href="../interfaces/AbstractZonotope/">Zonotopes (AbstractZonotope)</a></li><li><a class="tocitem" href="../interfaces/AbstractHyperrectangle/">Hyperrectangles (AbstractHyperrectangle)</a></li><li><a class="tocitem" href="../interfaces/AbstractSingleton/">Singletons (AbstractSingleton)</a></li><li><a class="tocitem" href="../interfaces/AbstractAffineMap/">Affine maps (AbstractAffineMap)</a></li><li><a class="tocitem" href="../interfaces/AbstractPolynomialZonotope/">Polynomial zonotope sets (AbstractPolynomialZonotope)</a></li><li><a class="tocitem" href="../interfaces/AbstractSparsePolynomialZonotope/">Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)</a></li><li><a class="tocitem" href="../interfaces/AbstractBallp/">Balls in the p-norm (AbstractBallp)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../sets/DensePolynomialZonotope/">DensePolynomialZonotope</a></li><li><a class="tocitem" href="../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../sets/HParallelotope/">HParallelotope</a></li><li><a class="tocitem" href="../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../sets/Line/">Line</a></li><li><a class="tocitem" href="../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../sets/Polygon/">Polygon</a></li><li><a class="tocitem" href="../sets/SimpleSparsePolynomialZonotope/">SimpleSparsePolynomialZonotope</a></li><li><a class="tocitem" href="../sets/SparsePolynomialZonotope/">SparsePolynomialZonotope</a></li><li><a class="tocitem" href="../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../sets/Star/">Star</a></li><li><a class="tocitem" href="../sets/Tetrahedron/">Tetrahedron</a></li><li><a class="tocitem" href="../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../sets/Zonotope/">Zonotope</a></li><li><a class="tocitem" href="../sets/ZonotopeMD/">ZonotopeMD</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lazy_operations/AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../lazy_operations/Bloating/">Bloating</a></li><li><a class="tocitem" href="../lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../lazy_operations/Complement/">Complement</a></li><li><a class="tocitem" href="../lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../lazy_operations/Intersection/">Intersection</a></li><li><a class="tocitem" href="../lazy_operations/LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../lazy_operations/InverseLinearMap/">InverseLinearMap</a></li><li><a class="tocitem" href="../lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../lazy_operations/QuadraticMap/">QuadraticMap</a></li><li><a class="tocitem" href="../lazy_operations/Rectification/">Rectification</a></li><li><a class="tocitem" href="../lazy_operations/ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../lazy_operations/Translation/">Translation</a></li><li><a class="tocitem" href="../lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Concrete Binary Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../concrete_binary_operations/overview/">Binary set operations</a></li><li><a class="tocitem" href="../concrete_binary_operations/cartesian_product/">Cartesian Product</a></li><li><a class="tocitem" href="../concrete_binary_operations/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../concrete_binary_operations/difference/">Set difference</a></li><li><a class="tocitem" href="../concrete_binary_operations/distance/">Distance</a></li><li><a class="tocitem" href="../concrete_binary_operations/intersection/">Intersection of two sets</a></li><li><a class="tocitem" href="../concrete_binary_operations/minkowski_sum/">Minkowski Sum</a></li><li><a class="tocitem" href="../concrete_binary_operations/minkowski_difference/">Minkowski Difference</a></li><li><a class="tocitem" href="../concrete_binary_operations/isdisjoint/">Check for Disjointness of Sets</a></li><li><a class="tocitem" href="../concrete_binary_operations/issubset/">Subset Check</a></li></ul></li><li><a class="tocitem" href="../conversion/">Conversions between set representations</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Approximations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../approximations/overview/">Overview</a></li><li><a class="tocitem" href="../approximations/overapproximate/">Overapproximation</a></li><li><a class="tocitem" href="../approximations/box_approximation/">Box Approximation</a></li><li><a class="tocitem" href="../approximations/iterative_refinement/">Iterative refinement</a></li><li><a class="tocitem" href="../approximations/template_directions/">Template directions</a></li><li><a class="tocitem" href="../approximations/underapproximate/">Underapproximation</a></li><li><a class="tocitem" href="../approximations/approximate/">Approximation</a></li><li><a class="tocitem" href="../approximations/decompose/">Cartesian Decomposition</a></li><li><a class="tocitem" href="../approximations/hausdorff_distance/">Hausdorff Distance</a></li><li><a class="tocitem" href="../approximations/overapproximate_norm/">Norm Overapproximation</a></li><li><a class="tocitem" href="../approximations/overapproximate_expmap/">Overapproximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">MatrixSets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../matrixsets/MatrixZonotope/">MatrixZonotope</a></li></ul></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li><a class="tocitem" href="../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/API.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#Set-interface">Set interface</a></li><li><a href="#Unary-set-functions">Unary set functions</a></li><li><a href="#Mixed-set-functions">Mixed set functions</a></li><li><a href="#Binary-set-functions">Binary set functions</a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API" href="#LazySets.API"><code>LazySets.API</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">API</code></pre><p>This module contains an API (application programming interface) for set libraries. The module only defines and documents the general functions and does not provide implementations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/API.jl#L1-L7">source</a></section></article><h1 id="Set-interface"><a class="docs-heading-anchor" href="#Set-interface">Set interface</a><a id="Set-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Set-interface" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.LazySet" href="#LazySets.API.LazySet"><code>LazySets.API.LazySet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LazySet</code></pre><p>Abstract type for a set of points.</p><p>This type is not exported and is only used to define interface methods without type piracy.</p><p>The <code>LazySets</code> library defines its own set interface, which is also called <code>LazySet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/LazySet.jl#L2-L12">source</a></section></article><h1 id="Unary-set-functions"><a class="docs-heading-anchor" href="#Unary-set-functions">Unary set functions</a><a id="Unary-set-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Unary-set-functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.an_element-Tuple{LazySets.API.LazySet}" href="#LazySets.API.an_element-Tuple{LazySets.API.LazySet}"><code>LazySets.API.an_element</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">an_element(X::LazySet)</code></pre><p>Return some element of a nonempty set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>An element of <code>X</code> unless <code>X</code> is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/an_element.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.area-Tuple{LazySets.API.LazySet}" href="#LazySets.API.area-Tuple{LazySets.API.LazySet}"><code>LazySets.API.area</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">area(X::LazySet)</code></pre><p>Compute the area of a two-dimensional set, respectively the surface area of a three-dimensional set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – two- or three-dimensional set</li></ul><p><strong>Output</strong></p><p>A number representing the (surface) area of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/area.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.center-Tuple{LazySets.API.LazySet, Int64}" href="#LazySets.API.center-Tuple{LazySets.API.LazySet, Int64}"><code>LazySets.API.center</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">center(X::LazySet, i::Int)</code></pre><p>Compute the center of a centrally symmetric set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – centrally symmetric set</li><li><code>i</code> – dimension</li></ul><p><strong>Output</strong></p><p>A real number representing the center of the set in the given dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/center.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.center-Tuple{LazySets.API.LazySet}" href="#LazySets.API.center-Tuple{LazySets.API.LazySet}"><code>LazySets.API.center</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">center(X::LazySet)</code></pre><p>Compute the center of a centrally symmetric set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p>A vector with the center, or midpoint, of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/center.jl#L17-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.complement-Tuple{LazySets.API.LazySet}" href="#LazySets.API.complement-Tuple{LazySets.API.LazySet}"><code>LazySets.API.complement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">complement(X::LazySet)</code></pre><p>Compute the complement of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the complement of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/complement.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.concretize-Tuple{LazySets.API.LazySet}" href="#LazySets.API.concretize-Tuple{LazySets.API.LazySet}"><code>LazySets.API.concretize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">concretize(X::LazySet)</code></pre><p>Construct a concrete representation of a (possibly lazy) set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A concrete representation of <code>X</code> (as far as possible).</p><p><strong>Notes</strong></p><p>Since not every lazy set has a concrete set representation in this library, the result may still be partially lazy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/concretize.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}" href="#LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}"><code>LazySets.API.constraints_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">constraints_list(X::LazySet)</code></pre><p>Compute a list of linear constraints of a polyhedral set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – polyhedral set</li></ul><p><strong>Output</strong></p><p>A list of the linear constraints of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/constraints_list.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.constraints-Tuple{LazySets.API.LazySet}" href="#LazySets.API.constraints-Tuple{LazySets.API.LazySet}"><code>LazySets.API.constraints</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">constraints(X::LazySet)</code></pre><p>Construct an iterator over the constraints of a polyhedral set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – polyhedral set</li></ul><p><strong>Output</strong></p><p>An iterator over the constraints of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/constraints.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.convex_hull-Tuple{LazySets.API.LazySet}" href="#LazySets.API.convex_hull-Tuple{LazySets.API.LazySet}"><code>LazySets.API.convex_hull</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convex_hull(X::LazySet)</code></pre><p>Compute the convex hull of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the convex hull of <code>X</code>.</p><p><strong>Notes</strong></p><p>The convex hull of a set <span>$X$</span> is defined as</p><p class="math-container">\[    \{λx + (1-λ)y \mid x, y ∈ X, λ ∈ [0, 1]\}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/convex_hull.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.diameter" href="#LazySets.API.diameter"><code>LazySets.API.diameter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diameter(X::LazySet, [p]::Real=Inf)</code></pre><p>Return the diameter of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p><p><strong>Notes</strong></p><p>The diameter of a set is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/diameter.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.dim-Tuple{LazySets.API.LazySet}" href="#LazySets.API.dim-Tuple{LazySets.API.LazySet}"><code>LazySets.API.dim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dim(X::LazySet)</code></pre><p>Compute the ambient dimension of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/dim.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eltype-Tuple{Type{&lt;:LazySets.API.LazySet}}" href="#Base.eltype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eltype(T::Type{&lt;:LazySet})</code></pre><p>Determine the numeric type of a set type.</p><p><strong>Input</strong></p><ul><li><code>T</code> – set type</li></ul><p><strong>Output</strong></p><p>The numeric type of <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/eltype.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eltype-Tuple{LazySets.API.LazySet}" href="#Base.eltype-Tuple{LazySets.API.LazySet}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eltype(X::LazySet)</code></pre><p>Determine the numeric type of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>The numeric type of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/eltype.jl#L16-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.extrema-Tuple{LazySets.API.LazySet, Int64}" href="#Base.extrema-Tuple{LazySets.API.LazySet, Int64}"><code>Base.extrema</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extrema(X::LazySet, i::Int)</code></pre><p>Compute the lowest and highest coordinate of a set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>i</code> – dimension</li></ul><p><strong>Output</strong></p><p>Two real numbers representing the lowest and highest coordinate of the set in the given dimension.</p><p><strong>Notes</strong></p><p>The result is equivalent to <code>(low(X, i), high(X, i))</code>, but sometimes it can be computed more efficiently.</p><p>The resulting values are the lower and upper ends of the projection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/extrema.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.extrema-Tuple{LazySets.API.LazySet}" href="#Base.extrema-Tuple{LazySets.API.LazySet}"><code>Base.extrema</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extrema(X::LazySet)</code></pre><p>Compute the lowest and highest coordinate of a set in each dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>Two vectors with the lowest and highest coordinates of <code>X</code> in each dimension.</p><p><strong>Notes</strong></p><p>See also <a href="#Base.extrema-Tuple{LazySets.API.LazySet, Int64}"><code>extrema(X::LazySet, i::Int)</code></a>.</p><p>The result is equivalent to <code>(low(X), high(X))</code>, but sometimes it can be computed more efficiently.</p><p>The resulting points are the lowest and highest corners of the box approximation, so they are not necessarily contained in <code>X</code>.</p><p><strong>Algorithm</strong></p><p>The default implementation computes the extrema via <code>low</code> and <code>high</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/extrema.jl#L25-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.high-Tuple{LazySets.API.LazySet, Int64}" href="#LazySets.API.high-Tuple{LazySets.API.LazySet, Int64}"><code>LazySets.API.high</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">high(X::LazySet, i::Int)</code></pre><p>Compute the highest coordinate of a set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>i</code> – dimension</li></ul><p><strong>Output</strong></p><p>A real number representing the highest coordinate of the set in the given dimension.</p><p><strong>Notes</strong></p><p>The resulting value is the upper end of the projection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/high.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.high-Tuple{LazySets.API.LazySet}" href="#LazySets.API.high-Tuple{LazySets.API.LazySet}"><code>LazySets.API.high</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">high(X::LazySet)</code></pre><p>Compute the highest coordinate of a set in each dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A vector with the highest coordinate of the set in each dimension.</p><p><strong>Notes</strong></p><p>See also <code>high(X::LazySet, i::Int)</code>.</p><p>The result is the uppermost corner of the box approximation, so it is not necessarily contained in <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/high.jl#L22-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isbounded-Tuple{LazySets.API.LazySet}" href="#LazySets.API.isbounded-Tuple{LazySets.API.LazySet}"><code>LazySets.API.isbounded</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isbounded(X::LazySet)</code></pre><p>Check whether a set is bounded.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set is bounded.</p><p><strong>Notes</strong></p><p>See also <a href="#LazySets.API.isboundedtype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>isboundedtype(::Type{&lt;:LazySet})</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/isbounded.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isboundedtype-Tuple{Type{&lt;:LazySets.API.LazySet}}" href="#LazySets.API.isboundedtype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>LazySets.API.isboundedtype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isboundedtype(T::Type{&lt;:LazySet})</code></pre><p>Check whether a set type only represents bounded sets.</p><p><strong>Input</strong></p><ul><li><code>T</code> – set type</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set type only represents bounded sets.</p><p><strong>Notes</strong></p><p>See also <a href="#LazySets.API.isbounded-Tuple{LazySets.API.LazySet}"><code>isbounded(::LazySet)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/isboundedtype.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isconvextype-Tuple{Type{&lt;:LazySets.API.LazySet}}" href="#LazySets.API.isconvextype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>LazySets.API.isconvextype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isconvextype(T::Type{&lt;:LazySet})</code></pre><p>Check whether <code>T</code> is convex just by using type information.</p><p><strong>Input</strong></p><ul><li><code>T</code> – subtype of <code>LazySet</code></li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set type only represents convex sets.</p><p><strong>Notes</strong></p><p>Since this operation only acts on types (not on values), it can return false negatives, i.e., there may be instances where the set is convex, even though the answer of this function is <code>false</code>. The examples below illustrate this point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/isconvextype.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isempty" href="#Base.isempty"><code>Base.isempty</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isempty(X::LazySet, witness::Bool=false)</code></pre><p>Check whether a set is empty.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If the <code>witness</code> option is deactivated: <code>true</code> iff <span>$X = ∅$</span></li><li>If the <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X = ∅$</span></li><li><code>(false, v)</code> iff <span>$X ≠ ∅$</span> for some <span>$v ∈ X$</span></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/isempty.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isoperation-Tuple{LazySets.API.LazySet}" href="#LazySets.API.isoperation-Tuple{LazySets.API.LazySet}"><code>LazySets.API.isoperation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isoperation(X::LazySet)</code></pre><p>Check whether a set is an instance of a (lazy) set operation.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>X</code> is an instance of a set-based operation.</p><p><strong>Notes</strong></p><p>See also <a href="#LazySets.API.isoperationtype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>isoperationtype(::Type{&lt;:LazySet})</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/isoperation.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isoperationtype-Tuple{Type{&lt;:LazySets.API.LazySet}}" href="#LazySets.API.isoperationtype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>LazySets.API.isoperationtype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isoperationtype(T::Type{&lt;:LazySet})</code></pre><p>Check whether a set type is a (lazy) set operation.</p><p><strong>Input</strong></p><ul><li><code>T</code> – set type</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set type represents a set operation.</p><p><strong>Notes</strong></p><p>See also <a href="#LazySets.API.isoperation-Tuple{LazySets.API.LazySet}"><code>isoperation(::LazySet)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/isoperationtype.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.ispolyhedral-Tuple{LazySets.API.LazySet}" href="#LazySets.API.ispolyhedral-Tuple{LazySets.API.LazySet}"><code>LazySets.API.ispolyhedral</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ispolyhedral(X::LazySet)</code></pre><p>Check whether a set is polyhedral.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> only if the set is polyhedral.</p><p><strong>Notes</strong></p><p>The answer is conservative, i.e., may sometimes be <code>false</code> even if the set is polyhedral.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/ispolyhedral.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isuniversal" href="#LazySets.API.isuniversal"><code>LazySets.API.isuniversal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isuniversal(X::LazySet, witness::Bool=false)</code></pre><p>Check whether a set is universal.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If the <code>witness</code> option is deactivated: <code>true</code> iff <span>$X = ℝ^n$</span></li><li>If the <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X = ℝ^n$</span></li><li><code>(false, v)</code> iff <span>$X ≠ ℝ^n$</span> for some <span>$v ∉ X$</span></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/isuniversal.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.low-Tuple{LazySets.API.LazySet, Int64}" href="#LazySets.API.low-Tuple{LazySets.API.LazySet, Int64}"><code>LazySets.API.low</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">low(X::LazySet, i::Int)</code></pre><p>Compute the lowest coordinate of a set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>i</code> – dimension</li></ul><p><strong>Output</strong></p><p>A real number representing the lowest coordinate of the set in the given dimension.</p><p><strong>Notes</strong></p><p>The resulting value is the lower end of the projection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/low.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.low-Tuple{LazySets.API.LazySet}" href="#LazySets.API.low-Tuple{LazySets.API.LazySet}"><code>LazySets.API.low</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">low(X::LazySet)</code></pre><p>Compute the lowest coordinates of a set in each dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A vector with the lowest coordinate of the set in each dimension.</p><p><strong>Notes</strong></p><p>See also <code>low(X::LazySet, i::Int)</code>.</p><p>The result is the lowermost corner of the box approximation, so it is not necessarily contained in <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/low.jl#L22-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">norm(X::LazySet, [p]::Real=Inf)</code></pre><p>Return the norm of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p><p><strong>Notes</strong></p><p>The norm of a set is the norm of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume that is centered in the origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/norm.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.radius" href="#LazySets.API.radius"><code>LazySets.API.radius</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">radius(X::LazySet, [p]::Real=Inf)</code></pre><p>Return the radius of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p><p><strong>Notes</strong></p><p>The radius of a set is the radius of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/radius.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{Type{&lt;:LazySets.API.LazySet}}" href="#Base.rand-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand(T::Type{&lt;:LazySet}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )</code></pre><p>Create a random set of the given set type.</p><p><strong>Input</strong></p><ul><li><code>T</code>    – set type</li><li><code>N</code>    – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>  – (optional, default: 2) dimension</li><li><code>rng</code>  – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code> – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A random set of the given set type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/rand.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityBase.Arrays.rectify-Tuple{LazySets.API.LazySet}" href="#ReachabilityBase.Arrays.rectify-Tuple{LazySets.API.LazySet}"><code>ReachabilityBase.Arrays.rectify</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rectify(X::LazySet)</code></pre><p>Compute the rectification of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the rectification of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/rectify.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.reflect-Tuple{LazySets.API.LazySet}" href="#LazySets.API.reflect-Tuple{LazySets.API.LazySet}"><code>LazySets.API.reflect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reflect(X::LazySet)</code></pre><p>Compute the reflection of a set in the origin.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the reflection <span>$-X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/reflect.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.vertices_list-Tuple{LazySets.API.LazySet}" href="#LazySets.API.vertices_list-Tuple{LazySets.API.LazySet}"><code>LazySets.API.vertices_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertices_list(X::LazySet)</code></pre><p>Compute a list of vertices of a polytopic set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – polytopic set</li></ul><p><strong>Output</strong></p><p>A list of the vertices of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/vertices_list.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.vertices-Tuple{LazySets.API.LazySet}" href="#LazySets.API.vertices-Tuple{LazySets.API.LazySet}"><code>LazySets.API.vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertices(X::LazySet)</code></pre><p>Construct an iterator over the vertices of a polytopic set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – polytopic set</li></ul><p><strong>Output</strong></p><p>An iterator over the vertices of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/vertices.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.volume-Tuple{LazySets.API.LazySet}" href="#LazySets.API.volume-Tuple{LazySets.API.LazySet}"><code>LazySets.API.volume</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">volume(X::LazySet)</code></pre><p>Compute the volume, or Lebesgue measure, of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A real number representing the Lebesgue measure of <code>X</code>.</p><p><strong>Notes</strong></p><p>The <a href="https://en.wikipedia.org/wiki/Lebesgue_measure">Lebesgue measure</a> has the following common special cases:</p><ul><li>In 1D, it coincides with the <em>length</em>.</li><li>In 2D, it coincides with the <em>area</em> (see also <a href="#LazySets.API.area-Tuple{LazySets.API.LazySet}"><code>area</code></a>).</li><li>In 3D, it coincides with the <em>volume</em>.</li></ul><p>In higher dimensions, it is also known as the <em>hypervolume</em> or simply <em>volume</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Unary/volume.jl#L1-L24">source</a></section></article><h1 id="Mixed-set-functions"><a class="docs-heading-anchor" href="#Mixed-set-functions">Mixed set functions</a><a id="Mixed-set-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Mixed-set-functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.affine_map-Tuple{AbstractMatrix, LazySets.API.LazySet, AbstractVector}" href="#LazySets.API.affine_map-Tuple{AbstractMatrix, LazySets.API.LazySet, AbstractVector}"><code>LazySets.API.affine_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">affine_map(M::AbstractMatrix, X::LazySet, v::AbstractVector)</code></pre><p>Compute the affine map <span>$M · X + v$</span>.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>X</code> – set</li><li><code>v</code> – translation vector</li></ul><p><strong>Output</strong></p><p>A set representing the affine map <span>$M · X + v$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Mixed/affine_map.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityBase.Arrays.distance-Tuple{AbstractVector, LazySets.API.LazySet}" href="#ReachabilityBase.Arrays.distance-Tuple{AbstractVector, LazySets.API.LazySet}"><code>ReachabilityBase.Arrays.distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance(x::AbstractVector, X::LazySet; [p]::Real=2)
distance(X::LazySet, x::AbstractVector; [p]::Real=2)</code></pre><p>Compute the standard distance (induced by the <span>$p$</span>-norm) between a point and a set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>X</code> – set</li><li><code>p</code> – (optional; default: <code>2</code>) value of the <span>$p$</span>-norm</li></ul><p><strong>Output</strong></p><p>A real number representing the distance between <code>x</code> and <code>X</code>.</p><p><strong>Notes</strong></p><p>The standard distance is zero if the point lies inside the set, and infinite if the set is empty. Otherwise, it is the <span>$p$</span>-norm of the shortest line segment between the point and any other point in the set. Formally,</p><p class="math-container">\[    \inf_{y ∈ X} \{ d(x, y) \}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Mixed/distance.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.exponential_map-Tuple{AbstractMatrix, LazySets.API.LazySet}" href="#LazySets.API.exponential_map-Tuple{AbstractMatrix, LazySets.API.LazySet}"><code>LazySets.API.exponential_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exponential_map(M::AbstractMatrix, X::LazySet)</code></pre><p>Compute the exponential map of <code>M</code> and <code>X</code>, i.e., <span>$eᴹ ⋅ X$</span>.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the exponential map <span>$eᴹ ⋅ X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Mixed/exponential_map.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}" href="#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∈(x::AbstractVector, X::LazySet)</code></pre><p>Check whether a point lies in a set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Mixed/in.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.is_interior_point-Tuple{AbstractVector, LazySets.API.LazySet}" href="#LazySets.API.is_interior_point-Tuple{AbstractVector, LazySets.API.LazySet}"><code>LazySets.API.is_interior_point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_interior_point(v::AbstractVector, X::LazySet; [p]::Real=Inf, [ε]::Real=_rtol(eltype(X)))</code></pre><p>Check whether a point is contained in the interior of a set.</p><p><strong>Input</strong></p><ul><li><code>v</code>  – point/vector</li><li><code>X</code>  – set</li><li><code>p</code>  – (optional; default: <code>Inf</code>) norm of the ball used to apply the error         tolerance</li><li><code>ε</code>  – (optional; default: <code>_rtol(eltype(X))</code>) error tolerance of the check</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the point <code>v</code> is strictly contained in <code>X</code> with tolerance <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Mixed/is_interior_point.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.linear_map-Tuple{AbstractMatrix, LazySets.API.LazySet}" href="#LazySets.API.linear_map-Tuple{AbstractMatrix, LazySets.API.LazySet}"><code>LazySets.API.linear_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_map(M::AbstractMatrix, X::LazySet)</code></pre><p>Compute the linear map <span>$M · X$</span>.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the linear map <span>$M · X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Mixed/linear_map.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.permute-Tuple{LazySets.API.LazySet, AbstractVector{Int64}}" href="#SparseArrays.permute-Tuple{LazySets.API.LazySet, AbstractVector{Int64}}"><code>SparseArrays.permute</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">permute(X::LazySet, p::AbstractVector{Int})</code></pre><p>Permute the dimensions of a set according to a given permutation vector.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>p</code> – permutation vector</li></ul><p><strong>Output</strong></p><p>A new set corresponding to <code>X</code> where the dimensions have been permuted according to <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Mixed/permute.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.project-Tuple{LazySets.API.LazySet, AbstractVector{Int64}}" href="#LazySets.API.project-Tuple{LazySets.API.LazySet, AbstractVector{Int64}}"><code>LazySets.API.project</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">project(X::LazySet, block::AbstractVector{Int})</code></pre><p>Project a set to a given block by using a concrete linear map.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>block</code>   – block structure - a vector with the dimensions of interest</li></ul><p><strong>Output</strong></p><p>A set representing the projection of <code>X</code> to block <code>block</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Mixed/project.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.sample" href="#LazySets.API.sample"><code>LazySets.API.sample</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample(X::LazySet, [m]::Int=1;
       [rng]::AbstractRNG=GLOBAL_RNG,
       [seed]::Union{Int,Nothing}=nothing)</code></pre><p>Compute random samples from a set.</p><p><strong>Input</strong></p><ul><li><code>X</code>    – set</li><li><code>m</code>    – (optional; default: 1) number of random samples</li><li><code>rng</code>  – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code> – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A vector of <code>m</code> elements in <code>X</code> if <code>X</code> is nonempty, and an error otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Mixed/sample.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.scale-Tuple{Real, LazySets.API.LazySet}" href="#LazySets.API.scale-Tuple{Real, LazySets.API.LazySet}"><code>LazySets.API.scale</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scale(α::Real, X::LazySet)</code></pre><p>Compute the scaling of a set.</p><p><strong>Input</strong></p><ul><li><code>α</code> – scalar</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing <span>$α ⋅ X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Mixed/scale.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.scale!-Tuple{Real, LazySets.API.LazySet}" href="#LazySets.API.scale!-Tuple{Real, LazySets.API.LazySet}"><code>LazySets.API.scale!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scale!(α::Real, X::LazySet)</code></pre><p>Scale a set by modifying it.</p><p><strong>Input</strong></p><ul><li><code>α</code> – scalar</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>The scaled set representing <span>$α ⋅ X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Mixed/scale!.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}" href="#LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}"><code>LazySets.API.ρ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, X::LazySet)</code></pre><p>Evaluate the support function of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function of <code>X</code> in direction <code>d</code>.</p><p><strong>Notes</strong></p><p>The convenience alias <code>support_function</code> is also available.</p><p>We have the following identity based on the support vector <span>$σ$</span>:</p><p class="math-container">\[    ρ(d, X) = d ⋅ σ(d, X)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Mixed/support_function.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}" href="#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}"><code>LazySets.API.σ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, X::LazySet)</code></pre><p>Compute a support vector of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A support vector of <code>X</code> in direction <code>d</code>.</p><p><strong>Notes</strong></p><p>The convenience alias <code>support_vector</code> is also available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Mixed/support_vector.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.translate-Tuple{LazySets.API.LazySet, AbstractVector}" href="#LazySets.API.translate-Tuple{LazySets.API.LazySet, AbstractVector}"><code>LazySets.API.translate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translate(X::LazySet, v::AbstractVector)</code></pre><p>Compute the translation of a set with a vector.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>v</code> – vector</li></ul><p><strong>Output</strong></p><p>A set representing <span>$X + \{v\}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Mixed/translate.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.translate!-Tuple{LazySets.API.LazySet, AbstractVector}" href="#LazySets.API.translate!-Tuple{LazySets.API.LazySet, AbstractVector}"><code>LazySets.API.translate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translate!(X::LazySet, v::AbstractVector)</code></pre><p>Translate a set with a vector by modifying it.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>v</code> – vector</li></ul><p><strong>Output</strong></p><p>The translated set representing <span>$X + \{v\}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Mixed/translate!.jl#L1-L14">source</a></section></article><h1 id="Binary-set-functions"><a class="docs-heading-anchor" href="#Binary-set-functions">Binary set functions</a><a id="Binary-set-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-set-functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.cartesian_product-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.cartesian_product-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.cartesian_product</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cartesian_product(X::LazySet, Y::LazySet)</code></pre><p>Compute the Cartesian product of two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the Cartesian product <span>$X × Y$</span>.</p><p><strong>Notes</strong></p><p>The Cartesian product of two sets <span>$X$</span> and <span>$Y$</span> is defined as</p><p class="math-container">\[    X × Y = \{[x, y] \mid x ∈ X, y ∈ Y\}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Binary/cartesian_product.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.convex_hull-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.convex_hull-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.convex_hull</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convex_hull(X::LazySet, Y::LazySet)</code></pre><p>Compute the convex hull of (the union of) two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the convex hull of <span>$X ∪ Y$</span>.</p><p><strong>Notes</strong></p><p>See <a href="#LazySets.API.convex_hull-Tuple{LazySets.API.LazySet}"><code>convex_hull(::LazySet)</code></a> for the convex hull of a single set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Binary/convex_hull.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.difference</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">difference(X::LazySet, Y::LazySet)</code></pre><p>Compute the set difference of two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the difference <span>$X ∖ Y$</span>.</p><p><strong>Notes</strong></p><p>The set difference is defined as:</p><p class="math-container">\[    X ∖ Y = \{x \mid x ∈ X \text{ and } x ∉ Y \}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Binary/difference.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityBase.Arrays.distance-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#ReachabilityBase.Arrays.distance-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>ReachabilityBase.Arrays.distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance(X::LazySet, Y::LazySet; [p]::Real=2)</code></pre><p>Compute the standard distance (induced by the <span>$p$</span>-norm) between two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li><li><code>p</code> – (optional; default: <code>2</code>) value of the <span>$p$</span>-norm</li></ul><p><strong>Output</strong></p><p>A real number representing the distance between <code>X</code> and <code>Y</code>.</p><p><strong>Notes</strong></p><p>The standard distance is zero if the sets intersect, and infinite if one of the sets is empty. Otherwise, it is the <span>$p$</span>-norm of the shortest line segment between any pair of points. Formally,</p><p class="math-container">\[    \inf_{x ∈ X, y ∈ Y} \{ d(x, y) \}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Binary/distance.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.exact_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.exact_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.exact_sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exact_sum(X::LazySet, Y::LazySet)</code></pre><p>Compute the exact sum of two parametric sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – parametric set</li><li><code>Y</code> – parametric set</li></ul><p><strong>Output</strong></p><p>A set representing the exact sum, sometimes written <span>$X ⊞ Y$</span>.</p><p><strong>Notes</strong></p><p>For parametric sets, the exact sum behaves like the Minkowski sum, except that the parameters are shared. Thus, for nonparametric sets, it coincides with the Minkowski sum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Binary/exact_sum.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.intersection-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.intersection-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.intersection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intersection(X::LazySet, Y::LazySet)</code></pre><p>Compute the intersection of two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the intersection <span>$X ∩ Y$</span>.</p><p><strong>Notes</strong></p><p>The intersection of two sets <span>$X$</span> and <span>$Y$</span> is defined as</p><p class="math-container">\[    X ∩ Y = \{x \mid x ∈ X \text{ and } x ∈ Y\}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Binary/intersection.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isapprox-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#Base.isapprox-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isapprox(X::LazySet, Y::LazySet)</code></pre><p>Check whether two sets of the same type are approximately equal.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>X</code> is approximately equal to <code>Y</code>.</p><p><strong>Notes</strong></p><p>The check is purely syntactic and the sets need to have the same base type, i.e., <code>X::T1 ≈ Y::T2</code> always returns <code>false</code> even if <code>X</code> and <code>Y</code> represent the same set. But <code>X::T{Int64} ≈ Y::T{Float64}</code> is a valid comparison. Note that, unlike most other binary operations, a query with <code>X</code> and <code>Y</code> of different dimension is allowed (and results in the answer <code>false</code>).</p><p>The convenience alias <code>≈</code> can be typed by <code>\approx&lt;tab&gt;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Binary/isapprox.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isdisjoint-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#Base.isdisjoint-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>Base.isdisjoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isdisjoint(X::LazySet, Y::LazySet, [witness]::Bool=false)</code></pre><p>Check whether two sets are disjoint (i.e., do not intersect), and optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>Y</code>       – set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If the <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ∩ Y = ∅$</span></li><li>If the <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ∩ Y = ∅$</span></li><li><code>(false, v)</code> iff <span>$X ∩ Y ≠ ∅$</span> for some <span>$v ∈ X ∩ Y$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>The convenience alias <code>is_intersection_empty</code> is also available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Binary/isdisjoint.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:==-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#Base.:==-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">==(X::LazySet, Y::LazySet)</code></pre><p>Check whether two sets use exactly the same set representation.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>X</code> is equal to <code>Y</code>.</p><p><strong>Notes</strong></p><p>The check is purely syntactic and the sets need to have the same base type, i.e., <code>X::T1 == Y::T2</code> always returns <code>false</code> even if <code>X</code> and <code>Y</code> represent the same set. But <code>X::T{Int64} == Y::T{Float64}</code> is a valid comparison. Note that, unlike most other binary operations, a query with <code>X</code> and <code>Y</code> of different dimension is allowed (and results in the answer <code>false</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Binary/isequal.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isequivalent-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.isequivalent-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.isequivalent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isequivalent(X::LazySet, Y::LazySet)</code></pre><p>Check whether two sets are equivalent, i.e., represent the same set of points.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>X</code> is equivalent to <code>Y</code> (up to numerical precision).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Binary/isequivalent.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.:⊂-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.:⊂-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.:⊂</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">⊂(X::LazySet, Y::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a set is a strict subset of another set, and optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>Y</code>       – set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If the <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊂ Y$</span></li><li>If the <code>witness</code> option is activated:<ul><li><code>(true, v)</code> iff <span>$X ⊂ Y$</span> for some <span>$v ∈ Y ∖ X$</span></li><li><code>(false, [])</code> iff <span>$X ⊂ Y$</span> does not hold</li></ul></li></ul><p><strong>Notes</strong></p><p>Strict inclusion is sometimes written as <code>⊊</code>. The following identity holds:</p><p class="math-container">\[    X ⊂ Y ⇔ X ⊆ Y ∧ Y ⊈ X\]</p><p><strong>Algorithm</strong></p><p>The default implementation first checks inclusion of <code>X</code> in <code>Y</code> and then checks noninclusion of <code>Y</code> in <code>X</code>:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Binary/isstrictsubset.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#Base.:⊆-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">⊆(X::LazySet, Y::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a set is a subset of another set, and optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>Y</code>       – set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If the <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊆ Y$</span></li><li>If the <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ⊆ Y$</span></li><li><code>(false, v)</code> iff <span>$X ⊈ Y$</span> for some <span>$v ∈ X ∖ Y$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>The convenience alias <code>issubset</code> is also available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Binary/issubset.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.linear_combination-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.linear_combination-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.linear_combination</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_combination(X::LazySet, Y::LazySet)</code></pre><p>Compute the linear combination of two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the linear combination of <code>X</code> and <code>Y</code>.</p><p><strong>Notes</strong></p><p>The linear combination of two sets <span>$X$</span> and <span>$Y$</span> is defined as</p><p class="math-container">\[    \left\{\frac{1}{2}(1+λ)x + \frac{1}{2}(1-λ)y \mid x ∈ X, y ∈ Y, λ ∈ [-1, 1]\right\}.\]</p><p>If <span>$X$</span> and <span>$Y$</span> are convex, their linear combination is identical with the convex hull of their union <span>$X ∪ Y$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Binary/linear_combination.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.minkowski_difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.minkowski_difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.minkowski_difference</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minkowski_difference(X::LazySet, Y::LazySet)</code></pre><p>Compute the Minkowski difference of two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the Minkowski difference <span>$X ⊖ Y$</span>.</p><p><strong>Notes</strong></p><p>The Minkowski difference of two sets <span>$X$</span> and <span>$Y$</span> is defined as</p><p class="math-container">\[    X ⊖ Y = \{z \mid \{z\} ⊕ Y ⊆ X\}\]</p><p>The convenience alias <code>pontryagin_difference</code> is also available.</p><p>There is some inconsistency in the literature regarding the naming conventions. In this library, both <em>Minkowski difference</em> and <em>Pontryagin difference</em> refer to the geometric difference of two sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Binary/minkowski_difference.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.minkowski_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}" href="#LazySets.API.minkowski_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>LazySets.API.minkowski_sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minkowski_sum(X::LazySet, Y::LazySet)</code></pre><p>Compute the Minkowski sum of two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the Minkowski sum <span>$X ⊕ Y$</span>.</p><p><strong>Notes</strong></p><p>The Minkowski sum of two sets <span>$X$</span> and <span>$Y$</span> is defined as</p><p class="math-container">\[    X ⊕ Y = \{x + y \mid x ∈ X, y ∈ Y\}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/aa2e42ed6d52930f660ca7da8b331d5a31576468/src/API/Binary/minkowski_sum.jl#L1-L22">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/lazy_intersections/">« Lazy Intersections</a><a class="docs-footer-nextpage" href="../interfaces/overview/">Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 23 September 2025 01:03">Tuesday 23 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
