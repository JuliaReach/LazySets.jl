var documenterSearchIndex = {"docs":
[{"location":"lib/API/","page":"API","title":"API","text":"Pages = [\"API.md\"]\nDepth = 3","category":"page"},{"location":"lib/API/#LazySets.API","page":"API","title":"LazySets.API","text":"API\n\nThis module contains an API (application programming interface) for set libraries. The module only defines and documents the general functions and does not provide implementations.\n\n\n\n\n\n","category":"module"},{"location":"lib/API/#Set-interface","page":"API","title":"Set interface","text":"","category":"section"},{"location":"lib/API/#LazySets.API.LazySet","page":"API","title":"LazySets.API.LazySet","text":"LazySet\n\nAbstract type for a set of points.\n\nThis type is not exported and is only used to define interface methods without type piracy.\n\nThe LazySets library defines its own set interface, which is also called LazySet.\n\n\n\n\n\n","category":"type"},{"location":"lib/API/#Unary-set-functions","page":"API","title":"Unary set functions","text":"","category":"section"},{"location":"lib/API/#LazySets.API.an_element-Tuple{LazySets.API.LazySet}","page":"API","title":"LazySets.API.an_element","text":"an_element(X::LazySet)\n\nReturn some element of a nonempty set.\n\nInput\n\nX – set\n\nOutput\n\nAn element of X unless X is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.area-Tuple{LazySets.API.LazySet}","page":"API","title":"LazySets.API.area","text":"area(X::LazySet)\n\nCompute the area of a two-dimensional set, respectively the surface area of a three-dimensional set.\n\nInput\n\nX – two- or three-dimensional set\n\nOutput\n\nA number representing the (surface) area of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.center-Tuple{LazySets.API.LazySet, Int64}","page":"API","title":"LazySets.API.center","text":"center(X::LazySet, i::Int)\n\nCompute the center of a centrally symmetric set in a given dimension.\n\nInput\n\nX – centrally symmetric set\ni – dimension\n\nOutput\n\nA real number representing the center of the set in the given dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.center-Tuple{LazySets.API.LazySet}","page":"API","title":"LazySets.API.center","text":"center(X::LazySet)\n\nCompute the center of a centrally symmetric set.\n\nInput\n\nX – centrally symmetric set\n\nOutput\n\nA vector with the center, or midpoint, of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.complement-Tuple{LazySets.API.LazySet}","page":"API","title":"LazySets.API.complement","text":"complement(X::LazySet)\n\nCompute the complement of a set.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the complement of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.concretize-Tuple{LazySets.API.LazySet}","page":"API","title":"LazySets.API.concretize","text":"concretize(X::LazySet)\n\nConstruct a concrete representation of a (possibly lazy) set.\n\nInput\n\nX – set\n\nOutput\n\nA concrete representation of X (as far as possible).\n\nNotes\n\nSince not every lazy set has a concrete set representation in this library, the result may still be partially lazy.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}","page":"API","title":"LazySets.API.constraints_list","text":"constraints_list(X::LazySet)\n\nCompute a list of linear constraints of a polyhedral set.\n\nInput\n\nX – polyhedral set\n\nOutput\n\nA list of the linear constraints of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.constraints-Tuple{LazySets.API.LazySet}","page":"API","title":"LazySets.API.constraints","text":"constraints(X::LazySet)\n\nConstruct an iterator over the constraints of a polyhedral set.\n\nInput\n\nX – polyhedral set\n\nOutput\n\nAn iterator over the constraints of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.convex_hull-Tuple{LazySets.API.LazySet}","page":"API","title":"LazySets.API.convex_hull","text":"convex_hull(X::LazySet)\n\nCompute the convex hull of a set.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the convex hull of X.\n\nNotes\n\nThe convex hull of a set X is defined as\n\n    λx + (1-λ)y mid x y  X λ  0 1\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.diameter","page":"API","title":"LazySets.API.diameter","text":"diameter(X::LazySet, [p]::Real=Inf)\n\nReturn the diameter of a set.\n\nInput\n\nX – set\np – (optional, default: Inf) norm\n\nOutput\n\nA real number representing the diameter.\n\nNotes\n\nThe diameter of a set is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given p-norm) of minimal volume.\n\n\n\n\n\n","category":"function"},{"location":"lib/API/#LazySets.API.dim-Tuple{LazySets.API.LazySet}","page":"API","title":"LazySets.API.dim","text":"dim(X::LazySet)\n\nCompute the ambient dimension of a set.\n\nInput\n\nX – set\n\nOutput\n\nThe ambient dimension of the set.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#Base.eltype-Tuple{Type{<:LazySets.API.LazySet}}","page":"API","title":"Base.eltype","text":"eltype(T::Type{<:LazySet})\n\nDetermine the numeric type of a set type.\n\nInput\n\nT – set type\n\nOutput\n\nThe numeric type of T.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#Base.eltype-Tuple{LazySets.API.LazySet}","page":"API","title":"Base.eltype","text":"eltype(X::LazySet)\n\nDetermine the numeric type of a set.\n\nInput\n\nX – set\n\nOutput\n\nThe numeric type of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#Base.extrema-Tuple{LazySets.API.LazySet, Int64}","page":"API","title":"Base.extrema","text":"extrema(X::LazySet, i::Int)\n\nCompute the lowest and highest coordinate of a set in a given dimension.\n\nInput\n\nX – set\ni – dimension\n\nOutput\n\nTwo real numbers representing the lowest and highest coordinate of the set in the given dimension.\n\nNotes\n\nThe result is equivalent to (low(X, i), high(X, i)), but sometimes it can be computed more efficiently.\n\nThe resulting values are the lower and upper ends of the projection.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#Base.extrema-Tuple{LazySets.API.LazySet}","page":"API","title":"Base.extrema","text":"extrema(X::LazySet)\n\nCompute the lowest and highest coordinate of a set in each dimension.\n\nInput\n\nX – set\n\nOutput\n\nTwo vectors with the lowest and highest coordinates of X in each dimension.\n\nNotes\n\nSee also extrema(X::LazySet, i::Int).\n\nThe result is equivalent to (low(X), high(X)), but sometimes it can be computed more efficiently.\n\nThe resulting points are the lowest and highest corners of the box approximation, so they are not necessarily contained in X.\n\nAlgorithm\n\nThe default implementation computes the extrema via low and high.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.high-Tuple{LazySets.API.LazySet, Int64}","page":"API","title":"LazySets.API.high","text":"high(X::LazySet, i::Int)\n\nCompute the highest coordinate of a set in a given dimension.\n\nInput\n\nX – set\ni – dimension\n\nOutput\n\nA real number representing the highest coordinate of the set in the given dimension.\n\nNotes\n\nThe resulting value is the upper end of the projection.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.high-Tuple{LazySets.API.LazySet}","page":"API","title":"LazySets.API.high","text":"high(X::LazySet)\n\nCompute the highest coordinate of a set in each dimension.\n\nInput\n\nX – set\n\nOutput\n\nA vector with the highest coordinate of the set in each dimension.\n\nNotes\n\nSee also high(X::LazySet, i::Int).\n\nThe result is the uppermost corner of the box approximation, so it is not necessarily contained in X.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.isbounded-Tuple{LazySets.API.LazySet}","page":"API","title":"LazySets.API.isbounded","text":"isbounded(X::LazySet)\n\nCheck whether a set is bounded.\n\nInput\n\nX – set\n\nOutput\n\ntrue iff the set is bounded.\n\nNotes\n\nSee also isboundedtype(::Type{<:LazySet}).\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.isboundedtype-Tuple{Type{<:LazySets.API.LazySet}}","page":"API","title":"LazySets.API.isboundedtype","text":"isboundedtype(T::Type{<:LazySet})\n\nCheck whether a set type only represents bounded sets.\n\nInput\n\nT – set type\n\nOutput\n\ntrue iff the set type only represents bounded sets.\n\nNotes\n\nSee also isbounded(::LazySet).\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.isconvextype-Tuple{Type{<:LazySets.API.LazySet}}","page":"API","title":"LazySets.API.isconvextype","text":"isconvextype(T::Type{<:LazySet})\n\nCheck whether T is convex just by using type information.\n\nInput\n\nT – subtype of LazySet\n\nOutput\n\ntrue iff the set type only represents convex sets.\n\nNotes\n\nSince this operation only acts on types (not on values), it can return false negatives, i.e., there may be instances where the set is convex, even though the answer of this function is false. The examples below illustrate this point.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#Base.isempty","page":"API","title":"Base.isempty","text":"isempty(X::LazySet, witness::Bool=false)\n\nCheck whether a set is empty.\n\nInput\n\nX       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X = \nIf the witness option is activated:\n(true, []) iff X = \n(false, v) iff X   for some v  X\n\n\n\n\n\n","category":"function"},{"location":"lib/API/#LazySets.API.isoperation-Tuple{LazySets.API.LazySet}","page":"API","title":"LazySets.API.isoperation","text":"isoperation(X::LazySet)\n\nCheck whether a set is an instance of a (lazy) set operation.\n\nInput\n\nX – set\n\nOutput\n\ntrue iff X is an instance of a set-based operation.\n\nNotes\n\nSee also isoperationtype(::Type{<:LazySet}).\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.isoperationtype-Tuple{Type{<:LazySets.API.LazySet}}","page":"API","title":"LazySets.API.isoperationtype","text":"isoperationtype(T::Type{<:LazySet})\n\nCheck whether a set type is a (lazy) set operation.\n\nInput\n\nT – set type\n\nOutput\n\ntrue iff the set type represents a set operation.\n\nNotes\n\nSee also isoperation(::LazySet).\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.ispolyhedral-Tuple{LazySets.API.LazySet}","page":"API","title":"LazySets.API.ispolyhedral","text":"ispolyhedral(X::LazySet)\n\nCheck whether a set is polyhedral.\n\nInput\n\nX – set\n\nOutput\n\ntrue only if the set is polyhedral.\n\nNotes\n\nThe answer is conservative, i.e., may sometimes be false even if the set is polyhedral.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.isuniversal","page":"API","title":"LazySets.API.isuniversal","text":"isuniversal(X::LazySet, witness::Bool=false)\n\nCheck whether a set is universal.\n\nInput\n\nX       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X = ℝ^n\nIf the witness option is activated:\n(true, []) iff X = ℝ^n\n(false, v) iff X  ℝ^n for some v  X\n\n\n\n\n\n","category":"function"},{"location":"lib/API/#LazySets.API.low-Tuple{LazySets.API.LazySet, Int64}","page":"API","title":"LazySets.API.low","text":"low(X::LazySet, i::Int)\n\nCompute the lowest coordinate of a set in a given dimension.\n\nInput\n\nX – set\ni – dimension\n\nOutput\n\nA real number representing the lowest coordinate of the set in the given dimension.\n\nNotes\n\nThe resulting value is the lower end of the projection.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.low-Tuple{LazySets.API.LazySet}","page":"API","title":"LazySets.API.low","text":"low(X::LazySet)\n\nCompute the lowest coordinates of a set in each dimension.\n\nInput\n\nX – set\n\nOutput\n\nA vector with the lowest coordinate of the set in each dimension.\n\nNotes\n\nSee also low(X::LazySet, i::Int).\n\nThe result is the lowermost corner of the box approximation, so it is not necessarily contained in X.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LinearAlgebra.norm","page":"API","title":"LinearAlgebra.norm","text":"norm(X::LazySet, [p]::Real=Inf)\n\nReturn the norm of a set.\n\nInput\n\nX – set\np – (optional, default: Inf) norm\n\nOutput\n\nA real number representing the norm.\n\nNotes\n\nThe norm of a set is the norm of the enclosing ball (of the given p-norm) of minimal volume that is centered in the origin.\n\n\n\n\n\n","category":"function"},{"location":"lib/API/#LazySets.API.radius","page":"API","title":"LazySets.API.radius","text":"radius(X::LazySet, [p]::Real=Inf)\n\nReturn the radius of a set.\n\nInput\n\nX – set\np – (optional, default: Inf) norm\n\nOutput\n\nA real number representing the radius.\n\nNotes\n\nThe radius of a set is the radius of the enclosing ball (of the given p-norm) of minimal volume.\n\n\n\n\n\n","category":"function"},{"location":"lib/API/#Base.rand-Tuple{Type{<:LazySets.API.LazySet}}","page":"API","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#ReachabilityBase.Arrays.rectify-Tuple{LazySets.API.LazySet}","page":"API","title":"ReachabilityBase.Arrays.rectify","text":"rectify(X::LazySet)\n\nCompute the rectification of a set.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the rectification of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.reflect-Tuple{LazySets.API.LazySet}","page":"API","title":"LazySets.API.reflect","text":"reflect(X::LazySet)\n\nCompute the reflection of a set in the origin.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the reflection -X.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.vertices_list-Tuple{LazySets.API.LazySet}","page":"API","title":"LazySets.API.vertices_list","text":"vertices_list(X::LazySet)\n\nCompute a list of vertices of a polytopic set.\n\nInput\n\nX – polytopic set\n\nOutput\n\nA list of the vertices of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.vertices-Tuple{LazySets.API.LazySet}","page":"API","title":"LazySets.API.vertices","text":"vertices(X::LazySet)\n\nConstruct an iterator over the vertices of a polytopic set.\n\nInput\n\nX – polytopic set\n\nOutput\n\nAn iterator over the vertices of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.volume-Tuple{LazySets.API.LazySet}","page":"API","title":"LazySets.API.volume","text":"volume(X::LazySet)\n\nCompute the volume, or Lebesgue measure, of a set.\n\nInput\n\nX – set\n\nOutput\n\nA real number representing the Lebesgue measure of X.\n\nNotes\n\nThe Lebesgue measure has the following common special cases:\n\nIn 1D, it coincides with the length.\nIn 2D, it coincides with the area (see also area).\nIn 3D, it coincides with the volume.\n\nIn higher dimensions, it is also known as the hypervolume or simply volume.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#Mixed-set-functions","page":"API","title":"Mixed set functions","text":"","category":"section"},{"location":"lib/API/#LazySets.API.affine_map-Tuple{AbstractMatrix, LazySets.API.LazySet, AbstractVector}","page":"API","title":"LazySets.API.affine_map","text":"affine_map(M::AbstractMatrix, X::LazySet, v::AbstractVector)\n\nCompute the affine map M  X + v.\n\nInput\n\nM – matrix\nX – set\nv – translation vector\n\nOutput\n\nA set representing the affine map M  X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#ReachabilityBase.Arrays.distance-Tuple{AbstractVector, LazySets.API.LazySet}","page":"API","title":"ReachabilityBase.Arrays.distance","text":"distance(x::AbstractVector, X::LazySet; [p]::Real=2)\ndistance(X::LazySet, x::AbstractVector; [p]::Real=2)\n\nCompute the standard distance (induced by the p-norm) between a point and a set.\n\nInput\n\nx – point/vector\nX – set\np – (optional; default: 2) value of the p-norm\n\nOutput\n\nA real number representing the distance between x and X.\n\nNotes\n\nThe standard distance is zero if the point lies inside the set, and infinite if the set is empty. Otherwise, it is the p-norm of the shortest line segment between the point and any other point in the set. Formally,\n\n    inf_y  X  d(x y) \n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.exponential_map-Tuple{AbstractMatrix, LazySets.API.LazySet}","page":"API","title":"LazySets.API.exponential_map","text":"exponential_map(M::AbstractMatrix, X::LazySet)\n\nCompute the exponential map of M and X, i.e., eᴹ  X.\n\nInput\n\nM – matrix\nX – set\n\nOutput\n\nA set representing the exponential map eᴹ  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}","page":"API","title":"Base.:∈","text":"∈(x::AbstractVector, X::LazySet)\n\nCheck whether a point lies in a set.\n\nInput\n\nx – point/vector\nX – set\n\nOutput\n\ntrue iff x  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.is_interior_point-Tuple{AbstractVector, LazySets.API.LazySet}","page":"API","title":"LazySets.API.is_interior_point","text":"is_interior_point(v::AbstractVector{<:Real}, X::LazySet; kwargs...) end\n\nCheck whether a point is contained in the interior of a set.\n\nInput\n\nv  – point/vector\nX  – set\np  – (optional; default: Inf) norm of the ball used to apply the error         tolerance\nε  – (optional; default: _rtol(eltype(X))) error tolerance of the check\n\nOutput\n\ntrue iff the point v is strictly contained in X with tolerance ε.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.linear_map-Tuple{AbstractMatrix, LazySets.API.LazySet}","page":"API","title":"LazySets.API.linear_map","text":"linear_map(M::AbstractMatrix, X::LazySet)\n\nCompute the linear map M  X.\n\nInput\n\nM – matrix\nX – set\n\nOutput\n\nA set representing the linear map M  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#SparseArrays.permute-Tuple{LazySets.API.LazySet, AbstractVector{Int64}}","page":"API","title":"SparseArrays.permute","text":"permute(X::LazySet, p::AbstractVector{Int})\n\nPermute the dimensions of a set according to a given permutation vector.\n\nInput\n\nX – set\np – permutation vector\n\nOutput\n\nA new set corresponding to X where the dimensions have been permuted according to p.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.project-Tuple{LazySets.API.LazySet, AbstractVector{Int64}}","page":"API","title":"LazySets.API.project","text":"project(X::LazySet, block::AbstractVector{Int})\n\nProject a set to a given block by using a concrete linear map.\n\nInput\n\nX       – set\nblock   – block structure - a vector with the dimensions of interest\n\nOutput\n\nA set representing the projection of X to block block.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.sample","page":"API","title":"LazySets.API.sample","text":"sample(X::LazySet, [m]::Int=1;\n       [rng]::AbstractRNG=GLOBAL_RNG,\n       [seed]::Union{Int,Nothing}=nothing)\n\nCompute random samples from a set.\n\nInput\n\nX    – set\nm    – (optional; default: 1) number of random samples\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA vector of m elements in X if X is nonempty, and an error otherwise.\n\n\n\n\n\n","category":"function"},{"location":"lib/API/#LazySets.API.scale-Tuple{Real, LazySets.API.LazySet}","page":"API","title":"LazySets.API.scale","text":"scale(α::Real, X::LazySet)\n\nCompute the scaling of a set.\n\nInput\n\nα – scalar\nX – set\n\nOutput\n\nA set representing α  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.scale!-Tuple{Real, LazySets.API.LazySet}","page":"API","title":"LazySets.API.scale!","text":"scale!(α::Real, X::LazySet)\n\nScale a set by modifying it.\n\nInput\n\nα – scalar\nX – set\n\nOutput\n\nThe scaled set representing α  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}","page":"API","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, X::LazySet)\n\nEvaluate the support function of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nThe evaluation of the support function of X in direction d.\n\nNotes\n\nA convenience alias support_function is also available.\n\nWe have the following identity based on the support vector σ:\n\n    ρ(d X) = d  σ(d X)\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.support_function","page":"API","title":"LazySets.API.support_function","text":"Extended help\n\nρ(d::AbstractVector, B::Ball1)\n\nAlgorithm\n\nLet c and r be the center and radius of the ball B in the 1-norm, respectively. Then:\n\nρ(d B) = d c + r d_\n\n\n\n\n\nρ(d::AbstractVector, X::LazySet)\n\nEvaluate the support function of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nThe evaluation of the support function of X in direction d.\n\nNotes\n\nA convenience alias support_function is also available.\n\nWe have the following identity based on the support vector σ:\n\n    ρ(d X) = d  σ(d X)\n\n\n\n\n\nExtended help\n\nρ(d::AbstractVector, B::Ball2)\n\nAlgorithm\n\nLet c and r be the center and radius of the ball B in the 2-norm, respectively. Then:\n\nρ(d B) = d c + r d_2\n\n\n\n\n\nExtended help\n\nρ(d::AbstractVector, B::BallInf)\n\nAlgorithm\n\nLet B be a ball in the infinity norm with center c and radius r and let d be the direction of interest. For balls with dimensions less than 30, we use the implementation for AbstractHyperrectangle, tailored to a BallInf, which computes\n\n    _i=1^n d_i (c_i + textrmsgn(d_i)  r)\n\nwhere textrmsgn(α) = 1 if α  0 and textrmsgn(α) = -1 if α  0.\n\nFor balls of higher dimension, we instead exploit that for a support vector v = σ(d B) = c + textrmsgn(d)  (r  r)ᵀ we have\n\n    ρ(d B) = d v = d c + d textrmsgn(d)  (r  r)ᵀ = d c + r  _i=1^n d_i\n\nwhere   denotes the dot product.\n\n\n\n\n\nExtended help\n\nρ(d::AbstractVector, U::Universe)\n\nAlgorithm\n\nIf the direction is all zero, the result is zero. Otherwise, the result is Inf.\n\n\n\n\n\nExtended help\n\nρ(d::AbstractVector, hs::HalfSpace)\n\nOutput\n\nUnless the direction is (a multiple of) the normal direction of the half-space, the result is Inf.\n\n\n\n\n\nExtended help\n\nρ(d::AbstractVector, E::Ellipsoid)\n\nAlgorithm\n\nThe support value is cᵀ d + Bᵀ d₂, where c is the center and Q = B Bᵀ is the shape matrix of E.\n\n\n\n\n\nExtended help\n\nρ(d::AbstractVector, H::Hyperplane)\n\nOutput\n\nIf the set is unbounded in the given direction, the result is Inf.\n\n\n\n\n\nExtended help\n\nρ(d::AbstractVector, X::LazySet)\n\nAlgorithm\n\nThe default implementation computes a support vector via σ.\n\n\n\n\n\nρ(d::AbstractVector, P::AbstractSparsePolynomialZonotope; [enclosure_method]=nothing)\n\nBound the support function of P in the direction d.\n\nInput\n\nd                – direction\nP                – sparse polynomial zonotope\nenclosure_method – (optional; default: nothing) method to use for                       enclosure; an AbstractEnclosureAlgorithm from the                       Rangeenclosures.jl                       package\n\nOutput\n\nAn overapproximation of the support function in the given direction.\n\nAlgorithm\n\nThis method implements Kochdumper [Koc22], Proposition 3.1.16.\n\n\n\n\n\nExtended help\n\nρ(d::AbstractVector, Z::AbstractZonotope)\n\nAlgorithm\n\nThe support value is cᵀ d + Gᵀ d₁, where c is the center and G is the generator matrix of Z.\n\n\n\n\n\nExtended help\n\nρ(d::AbstractVector, B::AbstractBallp)\n\nAlgorithm\n\nLet c and r be the center and radius of the ball B in the p-norm, respectively, and let q = fracpp-1. Then:\n\nρ(d B) = d c + r d_q\n\n\n\n\n\nρ(d::AbstractVector, cup::UnionSet)\n\nEvaluate the support function of the union of two sets in a given direction.\n\nInput\n\nd   – direction\ncup – union of two sets\n\nOutput\n\nThe evaluation of the support function in the given direction.\n\nAlgorithm\n\nThe support function of the union of two sets X and Y evaluates to the maximum of the support-function evaluations of X and Y.\n\n\n\n\n\nρ(d::AbstractVector, B::Bloating)\n\nReturn the support function of a bloated set in a given direction.\n\nInput\n\nd – direction\nB – bloated set\n\nOutput\n\nThe support function of the bloated set in the given direction.\n\n\n\n\n\nρ(d::AbstractVector, cp::CartesianProduct)\n\nEvaluate the support function of a Cartesian product.\n\nInput\n\nd  – direction\ncp – Cartesian product\n\nOutput\n\nThe evaluation of the support function in the given direction. If the direction has norm zero, the result depends on the wrapped sets.\n\n\n\n\n\nρ(d::AbstractVector, cpa::CartesianProductArray)\n\nEvaluate the support function of a Cartesian product of a finite number of sets.\n\nInput\n\nd   – direction\ncpa – Cartesian product of a finite number of sets\n\nOutput\n\nThe evaluation of the support function in the given direction. If the direction has norm zero, the result depends on the wrapped sets.\n\n\n\n\n\nρ(d::AbstractVector, ch::ConvexHull)\n\nEvaluate the support function of the convex hull of two sets in a given direction.\n\nInput\n\nd  – direction\nch – convex hull of two sets\n\nOutput\n\nThe evaluation of the support function of the convex hull in the given direction.\n\n\n\n\n\nρ(d::AbstractVector, cha::ConvexHullArray)\n\nEvaluate the support function of a convex hull of a finite number of sets in a given direction.\n\nInput\n\nd   – direction\ncha – convex hull of a finite number of sets\n\nOutput\n\nThe evaluation of the support function of the convex hull of a finite number of sets in the given direction.\n\nAlgorithm\n\nThis algorithm calculates the maximum over all ρ(d X_i), where the X_1  X_k are the sets in the array of cha.\n\n\n\n\n\nρ(d::AbstractVector, em::ExponentialMap;\n  [backend]=get_exponential_backend())\n\nEvaluate the support function of the exponential map.\n\nInput\n\nd       – direction\nem      – exponential map\nbackend – (optional; default: get_exponential_backend()) exponentiation              backend\n\nOutput\n\nThe evaluation of the support function in the given direction.\n\nNotes\n\nIf E = exp(M)X, where M is a matrix and X is a set, it follows that ρ(d E) = ρ(exp(M)^T d X) for any direction d.\n\n\n\n\n\nρ(d::AbstractVector, eprojmap::ExponentialProjectionMap;\n  [backend]=get_exponential_backend())\n\nEvaluate the support function of a projection of an exponential map.\n\nInput\n\nd        – direction\neprojmap – projection of an exponential map\nbackend  – (optional; default: get_exponential_backend()) exponentiation               backend\n\nOutput\n\nEvaluation of the support function in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\nNotes\n\nIf S = (LMR)X, where L and R are matrices, M is a matrix exponential, and X is a set, it follows that ρ(d S) = ρ(R^TM^TL^Td X) for any direction d.\n\n\n\n\n\nρ(d::AbstractVector, cap::Intersection)\n\nReturn an upper bound on the support function of the intersection of two sets in a given direction.\n\nInput\n\nd   – direction\ncap – intersection of two sets\n\nOutput\n\nAn upper bound on the support function in the given direction.\n\nAlgorithm\n\nThe support function of an intersection of X and Y is upper-bounded by the minimum of the support-function evaluations for X and Y.\n\n\n\n\n\nρ(d::AbstractVector, cap::Intersection{N, S1, S2};\n  algorithm::String=\"line_search\", kwargs...\n ) where {N, S1<:LazySet,\n             S2<:Union{HalfSpace, Hyperplane, Line2D}}\n\nEvaluate the support function of the intersection of a compact set and a half-space/hyperplane/line in a given direction.\n\nInput\n\nd         – direction\ncap       – lazy intersection of a compact set and a half-space/hyperplane/                line\nalgorithm – (optional, default: \"line_search\"): the algorithm to                calculate the support function; valid options are:\n\"line_search\" – solve the associated univariate optimization problem                    using a line-search method (either Brent or the                    Golden Section method)\n\"projection\"  – only valid for intersection with a hyperplane/line;                    evaluate the support function by reducing the problem                    to the 2D intersection of a rank-2 linear                    transformation of the given compact set in the plane                    generated by the given direction d and the                    hyperplane's normal vector n\n\"simple\"      – take the min of the support-function evaluation                    of each operand\n\nOutput\n\nThe scalar value of the support function of the set cap in the given direction.\n\nNotes\n\nIt is assumed that the first set of the intersection (cap.X) is compact.\n\nAny additional number of arguments to the algorithm backend can be passed as keyword arguments.\n\nAlgorithm\n\nThe algorithms are based on solving the associated optimization problem\n\nmin_λ  D_h ρ(ℓ - λa X) + λb\n\nwhere D_h =  λ  λ  0  if H is a half-space or D_h =  λ  λ  ℝ  if H is a hyperplane.\n\nFor additional information we refer to Frehse and Ray [FR12], Guernic [Gue09] and Rockafellar and Wets [RW98]\n\n\n\n\n\nρ(d::AbstractVector, cap::Intersection{N, S1, S2};\n  kwargs...) where {N, S1<:LazySet, S2<:AbstractPolyhedron}\n\nReturn an upper bound on the support function of the intersection between a compact set and a polyhedron along a given direction.\n\nInput\n\nd      – direction\ncap    – intersection of a compact set and a polyhedron\nkwargs – additional arguments that are passed to the support-function             algorithm\n\nOutput\n\nAn upper bound of the support function of the given intersection.\n\nAlgorithm\n\nThe idea is to solve the univariate optimization problem ρ(di, X ∩ Hi) for each half-space in the polyhedron and then take the minimum. This gives an overapproximation of the exact support value.\n\nThis algorithm is inspired from Frehse and Ray [FR12].\n\nNotes\n\nThis method relies on the constraints_list of the polyhedron.\n\n\n\n\n\nρ(d::AbstractVector, cap::Intersection{N, S1, S2}; kwargs...\n ) where {N, S1<:AbstractPolyhedron, S2<:AbstractPolyhedron}\n\nEvaluate the support function of the intersection between two polyhedral sets.\n\nInput\n\nd      – direction\ncap    – intersection of two polyhedral sets\nkwargs – additional arguments that are passed to the support-function             algorithm\n\nOutput\n\nThe evaluation of the support function in the given direction.\n\nAlgorithm\n\nWe combine the constraints of the two polyhedra to a new HPolyhedron, for which we then evaluate the support function.\n\n\n\n\n\nρ(d::AbstractVector, lm::LinearMap; kwargs...)\n\nEvaluate the support function of the linear map.\n\nInput\n\nd      – direction\nlm     – linear map\nkwargs – additional arguments that are passed to the support function             algorithm\n\nOutput\n\nThe evaluation of the support function in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\nNotes\n\nIf L = MS, where M is a matrix and S is a set, it follows that ρ(d L) = ρ(M^T d S) for any direction d.\n\n\n\n\n\nρ(d::AbstractVector, ilm::InverseLinearMap)\n\nEvaluate the support function of the inverse linear map.\n\nInput\n\nd      – direction\nilm    – inverse linear map\n\nOutput\n\nThe evaluation of the support function in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\nNotes\n\nIf L = M^-1X, where M is a matrix and X is a set, it follows that ρ(d L) = ρ((M^T)^-1 d X) for any direction d.\n\n\n\n\n\nρ(d::AbstractVector, ms::MinkowskiSum)\n\nEvaluate the support function of a Minkowski sum of two sets.\n\nInput\n\nd  – direction\nms – Minkowski sum of two sets\n\nOutput\n\nThe evaluation of the support function in the given direction.\n\nAlgorithm\n\nThe support function in direction d of the Minkowski sum of two sets X and Y is the sum of the support functions of X and Y in direction d.\n\n\n\n\n\nρ(d::AbstractVector, msa::MinkowskiSumArray)\n\nEvaluate the support function of a Minkowski sum of a finite number of sets in a given direction.\n\nInput\n\nd   – direction\nmsa – Minkowski sum of a finite number of sets\n\nOutput\n\nThe evaluation of the support function in the given direction.\n\nAlgorithm\n\nThe support function of the Minkowski sum of multiple sets evaluations to the sum of the support-function evaluations of each set.\n\n\n\n\n\nρ(d::AbstractVector, rm::ResetMap)\n\nEvaluate the support function of a reset map.\n\nInput\n\nd  – direction\nrm – reset map\n\nOutput\n\nThe evaluation of the support function in the given direction.\n\nNotes\n\nWe use the usual dot-product definition, but for unbounded sets we redefine the product between 0 and  as 0; Julia returns NaN here.\n\njulia> Inf * 0.0\nNaN\n\nSee the discussion here.\n\n\n\n\n\nρ(d::AbstractVector, tr::Translation)\n\nEvaluate the support function of a translation.\n\nInput\n\nd  – direction\ntr – translation of a set\n\nOutput\n\nThe evaluation of the support function in the given direction.\n\n\n\n\n\nρ(d::AbstractVector, cup::UnionSetArray)\n\nEvaluate the support function of the union of a finite number of sets in a given direction.\n\nInput\n\nd   – direction\ncup – union of a finite number of sets\n\nOutput\n\nThe evaluation of the support function in the given direction.\n\nAlgorithm\n\nThe support function of the union of a finite number of sets X₁ X₂  can be obtained as the maximum of ρ(d X₂) ρ(d X₂) .\n\n\n\n\n\nρ(d::AbstractVector, R::Rectification)\n\nEvaluate the support function of a rectification in a given direction.\n\nInput\n\nd – direction\nR – rectification\n\nOutput\n\nThe support value of the rectification in the given direction.\n\nAlgorithm\n\nWe use different procedures for different types of input sets. If the wrapped set has a suitable structure for which we can efficiently compute the support vector, we fall back to the evaluation of the support function by means of the support vector. Otherwise we compute the union of projections to obtain a precise result (see to_union_of_projections), and then compute the support function for this union. (The union is cached internally, so subsequent queries are more efficient.)\n\n\n\n\n\nExtended help\n\nρ(d::AbstractVector{M}, P::HPoly{N};\n  solver=default_lp_solver(M, N)) where {M, N}\n\nInput\n\nsolver – (optional, default: default_lp_solver(M, N)) the backend used to             solve the linear program\n\nOutput\n\nIf P is unbounded in the given direction, there are two cases:\n\nIf P is an HPolytope, we throw an error.\nIf P is an HPolyedron, the result is Inf.\n\n\n\n\n\n","category":"function"},{"location":"lib/API/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}","page":"API","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.support_vector","page":"API","title":"LazySets.API.support_vector","text":"Extended help\n\nσ(d::AbstractVector, P::VPolygon)\n\nOutput\n\nIf the direction has norm zero, the first vertex is returned.\n\nAlgorithm\n\nThis implementation uses a binary search algorithm when the polygon has more than 10 vertices and a brute-force search when it has 10 or fewer vertices. The brute-force search compares the projection of each vector along the given direction and runs in O(n) where n is the number of vertices. The binary search runs in O(log n) and we follow this implementation based on an algorithm described in O’Rourke [O’R98].\n\n\n\n\n\nσ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\nExtended help\n\nσ(d::AbstractVector, B::Ball2)\n\nNotes\n\nLet c and r be the center and radius of a ball B in the 2-norm, respectively. For nonzero direction d we have\n\nσ(d B) = c + r fracdd_2\n\nThis function requires computing the 2-norm of the input direction, which is performed in the given precision of the numeric datatype of both the direction and the set. Exact inputs are not supported.\n\n\n\n\n\nExtended help\n\nσ(d::AbstractVector, L::LineSegment)\n\nAlgorithm\n\nIf the angle between the vector q - p and d is bigger than 90° and less than 270° (measured in counter-clockwise order), the result is p, otherwise it is q. If the angle is exactly 90° or 270°, or if the direction has norm zero, this implementation returns q.\n\n\n\n\n\nExtended help\n\nσ(d::AbstractVector, U::Universe)\n\nOutput\n\nA vector with infinity values, except in dimensions where the direction is zero.\n\n\n\n\n\nExtended help\n\nσ(d::AbstractVector, hs::HalfSpace)\n\nOutput\n\nThe support vector in the given direction, which is only defined in the following two cases:\n\nThe direction has norm zero.\nThe direction is (a multiple of) the normal direction of the half-space.\n\nIn both cases the result is any point on the boundary (the defining hyperplane). Otherwise this function throws an error.\n\n\n\n\n\nExtended help\n\nσ(d::AbstractVector, E::Ellipsoid)\n\nAlgorithm\n\nLet E be an ellipsoid of center c and shape matrix Q = BB^mathrmT. Its support vector along direction d can be deduced from that of the unit Euclidean ball mathcalB_2 using the algebraic relations for the support vector,\n\nσ_BmathcalB_2  c(d) = c + Bσ_mathcalB_2 (B^mathrmT d)\n= c + dfracQdsqrtd^mathrmTQ d\n\n\n\n\n\nExtended help\n\nσ(d::AbstractVector, P::VPolytope)\n\nAlgorithm\n\nA support vector maximizes the support function. For a polytope, the support function is always maximized in some vertex. Hence it is sufficient to check all vertices.\n\n\n\n\n\nExtended help\n\nσ(d::AbstractVector, H::Hyperplane)\n\nOutput\n\nA support vector in the given direction, which is only defined in the following two cases:\n\nThe direction has norm zero.\nThe direction is the hyperplane's normal direction or its opposite direction.\n\nIn all cases, any point on the hyperplane is a solution. Otherwise this function throws an error.\n\n\n\n\n\nExtended help\n\nσ(d::AbstractVector, T::Tetrahedron)\n\nAlgorithm\n\nThis method falls back to the VPolytope implementation.\n\n\n\n\n\nExtended help\n\nσ(d::AbstractVector, Z::AbstractZonotope)\n\nNotes\n\nIf the direction has norm zero, the vertex with ξ_i = 1    i = 1 p is returned.\n\n\n\n\n\nExtended help\n\nσ(d::AbstractVector, H::AbstractHyperrectangle)\n\nNotes\n\nIf the direction vector is zero in dimension i, the result will have the center's coordinate in that dimension. For instance, for the two-dimensional infinity-norm ball, if the direction points to the right, the result is the vector [1, 0] in the middle of the right-hand facet.\n\nIf the direction has norm zero, the result can be any point in H. The default implementation returns the center of H.\n\n\n\n\n\nExtended help\n\nσ(d::AbstractVector, S::AbstractSingleton)\n\nAlgorithm\n\nThe support vector is the set's vector itself, irrespective of the given direction.\n\n\n\n\n\nExtended help\n\nσ(d::AbstractVector, B::AbstractBallp)\n\nAlgorithm\n\nThe support vector of the unit ball in the p-norm along direction d is:\n\nσ(d mathcalB_p^n(0 1)) = dfractildevtildev_q\n\nwhere tildev_i = fracd_i^qd_i if d_i  0 and tildev_i = 0 otherwise, for all i=1n, and q is the conjugate number of p. By the affine transformation x = rtildex + c, one obtains that the support vector of mathcalB_p^n(c r) is\n\nσ(d mathcalB_p^n(c r)) = dfracvv_q\n\nwhere v_i = c_i + rfracd_i^qd_i if d_i  0 and v_i = 0 otherwise, for all i = 1  n.\n\nIf the direction has norm zero, the center of the ball is returned.\n\n\n\n\n\nσ(d::AbstractVector, P::HPolygonOpt;\n  [linear_search]::Bool=(length(P.constraints) < 10))\n\nReturn a support vector of an optimized polygon in a given direction.\n\nInput\n\nd             – direction\nP             – optimized polygon in constraint representation\nlinear_search – (optional, default: see below) flag for controlling whether                    to perform a linear search or a binary search\n\nOutput\n\nThe support vector in the given direction. The result is always one of the vertices; in particular, if the direction has norm zero, any vertex is returned.\n\nAlgorithm\n\nComparison of directions is performed using polar angles; see the definition of ⪯ for two-dimensional vectors.\n\nFor polygons with 10 or more constraints we use a binary search by default.\n\n\n\n\n\nσ(d::AbstractVector, cup::UnionSet; [algorithm]=\"support_vector\")\n\nReturn a support vector of the union of two sets in a given direction.\n\nInput\n\nd         – direction\ncup       – union of two sets\nalgorithm – (optional, default: \"supportvector\"): the algorithm to compute                the support vector; if \"supportvector\", use the support                vector of each argument; if \"support_function\" use the support                function of each argument and evaluate the support vector of                only one of them\n\nOutput\n\nA support vector in the given direction.\n\nAlgorithm\n\nThe support vector of the union of two sets X and Y can be obtained as the vector that maximizes the support function of either X or Y, i.e., it is sufficient to find the argmax(ρ(d X) ρ(d Y)) and evaluate its support vector.\n\nThe default implementation, with option algorithm=\"support_vector\", computes the support vector of X and Y and then compares the support function using a dot product.\n\nIf the support function can be computed more efficiently, the alternative implementation algorithm=\"support_function\" can be used, which evaluates the support function of each set directly and then calls only the support vector of either X or Y.\n\n\n\n\n\nσ(d::AbstractVector, B::Bloating)\n\nReturn the support vector of a bloated set in a given direction.\n\nInput\n\nd – direction\nB – bloated set\n\nOutput\n\nThe support vector of the bloated set in the given direction.\n\n\n\n\n\nσ(d::AbstractVector, cp::CartesianProduct)\n\nReturn a support vector of a Cartesian product.\n\nInput\n\nd  – direction\ncp – Cartesian product\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the wrapped sets.\n\n\n\n\n\nσ(d::AbstractVector, cpa::CartesianProductArray)\n\nCompute a support vector of a Cartesian product of a finite number of sets.\n\nInput\n\nd   – direction\ncpa – Cartesian product of a finite number of sets\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the product sets.\n\n\n\n\n\nσ(d::AbstractVector, ch::ConvexHull)\n\nReturn a support vector of the convex hull of two sets in a given direction.\n\nInput\n\nd  – direction\nch – convex hull of two sets\n\nOutput\n\nA support vector of the convex hull in the given direction.\n\n\n\n\n\nσ(d::AbstractVector, cha::ConvexHullArray)\n\nReturn a support vector of a convex hull of a finite number of sets in a given direction.\n\nInput\n\nd   – direction\ncha – convex hull of a finite number of sets\n\nOutput\n\nA support vector in the given direction.\n\n\n\n\n\nσ(d::AbstractVector, em::ExponentialMap;\n  [backend]=get_exponential_backend())\n\nReturn a support vector of an exponential map.\n\nInput\n\nd       – direction\nem      – exponential map\nbackend – (optional; default: get_exponential_backend()) exponentiation              backend\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\nNotes\n\nIf E = exp(M)X, where M is a matrix and X is a set, it follows that σ(d E) = exp(M)σ(exp(M)^T d X) for any direction d.\n\n\n\n\n\nσ(d::AbstractVector, eprojmap::ExponentialProjectionMap;\n  [backend]=get_exponential_backend())\n\nReturn a support vector of a projection of an exponential map.\n\nInput\n\nd        – direction\neprojmap – projection of an exponential map\nbackend  – (optional; default: get_exponential_backend()) exponentiation               backend\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\nNotes\n\nIf S = (LMR)X, where L and R are matrices, M is a matrix exponential, and X is a set, it follows that σ(d S) = LMRσ(R^TM^TL^Td X) for any direction d.\n\n\n\n\n\nσ(d::AbstractVector, cap::Intersection)\n\nReturn a support vector of an intersection of two sets in a given direction.\n\nInput\n\nd   – direction\ncap – intersection of two sets\n\nOutput\n\nA support vector in the given direction.\n\nAlgorithm\n\nWe compute the concrete intersection, which may be expensive.\n\n\n\n\n\nσ(d::AbstractVector, ia::IntersectionArray)\n\nReturn a support vector of an intersection of a finite number of sets in a given direction.\n\nInput\n\nd  – direction\nia – intersection of a finite number of sets\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the individual sets.\n\nAlgorithm\n\nThis implementation computes the concrete intersection, which can be expensive.\n\n\n\n\n\nσ(d::AbstractVector, lm::LinearMap)\n\nReturn a support vector of the linear map.\n\nInput\n\nd  – direction\nlm – linear map\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\nNotes\n\nIf L = MS, where M is a matrix and S is a set, it follows that σ(d L) = Mσ(M^T d S) for any direction d.\n\n\n\n\n\nσ(d::AbstractVector, ilm::InverseLinearMap)\n\nReturn a support vector of a inverse linear map.\n\nInput\n\nd   – direction\nilm – inverse linear map\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\nNotes\n\nIf L = M^-1X, where M is a matrix and X is a set, since (M^T)^{-1}=(M^{-1})^T, it follows that σ(d L) = M^-1σ((M^T)^-1 d X) for any direction d.\n\n\n\n\n\nσ(d::AbstractVector, ms::MinkowskiSum)\n\nReturn a support vector of a Minkowski sum of two sets.\n\nInput\n\nd  – direction\nms – Minkowski sum of two sets\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.\n\nAlgorithm\n\nA valid support vector in direction d of the Minkowski sum of two sets X and Y is the sum of the support vectors of X and Y in direction d.\n\n\n\n\n\nσ(d::AbstractVector, msa::MinkowskiSumArray)\n\nReturn a support vector of a Minkowski sum of a finite number of sets in a given direction.\n\nInput\n\nd   – direction\nmsa – Minkowski sum of a finite number of sets\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.\n\n\n\n\n\nσ(d::AbstractVector, cms::CachedMinkowskiSumArray)\n\nReturn a support vector of a cached Minkowski sum in a given direction.\n\nInput\n\nd   – direction\ncms – cached Minkowski sum\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.\n\nNotes\n\nThe result is cached, i.e., any further query with the same direction runs in constant time. When sets are added to the cached Minkowski sum, the query is only performed for the new sets.\n\n\n\n\n\nσ(d::AbstractVector, rm::ResetMap)\n\nReturn a support vector of a reset map.\n\nInput\n\nd  – direction\nrm – reset map\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\n\n\n\n\nσ(d::AbstractVector, sih::SymmetricIntervalHull)\n\nReturn a support vector of the symmetric interval hull of a set in a given direction.\n\nInput\n\nd   – direction\nsih – symmetric interval hull of a set\n\nOutput\n\nA support vector of the symmetric interval hull of a set in the given direction. If the direction has norm zero, the origin is returned.\n\nAlgorithm\n\nFor each non-zero entry in d we need to either look up the bound (if it has been computed before) or compute it, in which case we store it for future queries.\n\n\n\n\n\nσ(d::AbstractVector, tr::Translation)\n\nReturn a support vector of a translation.\n\nInput\n\nd  – direction\ntr – translation of a set\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\n\n\n\n\nσ(d::AbstractVector, cup::UnionSetArray; [algorithm]=\"support_vector\")\n\nReturn a support vector of the union of a finite number of sets in a given direction.\n\nInput\n\nd         – direction\ncup       – union of a finite number of sets\nalgorithm – (optional, default: \"supportvector\"): the algorithm to compute                the support vector; if \"supportvector\", use the support                vector of each argument; if \"support_function\", use the support                function of each argument and evaluate the support vector of                only one of them\n\nOutput\n\nA support vector in the given direction.\n\nAlgorithm\n\nThe support vector of the union of a finite number of sets X₁ X₂  can be obtained as the vector that maximizes the support function, i.e., it is sufficient to find the argmax(ρ(d X₂) ρ(d X₂) ) and evaluate its support vector.\n\nThe default implementation, with option algorithm=\"support_vector\", computes the support vector of all X₁ X₂  and then compares the support function using the dot product.\n\nIf the support function can be computed more efficiently, the alternative implementation algorithm=\"support_function\" can be used, which evaluates the support function of each set directly and then calls only the support vector of one of the Xᵢ.\n\n\n\n\n\nσ(d::AbstractVector, R::Rectification)\n\nReturn a support vector of a rectification.\n\nInput\n\nd – direction\nR – rectification\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\n\n\n\n\nσ(d::AbstractVector, R::Rectification{N, <:AbstractHyperrectangle}) where {N}\n\nReturn a support vector of the rectification of a hyperrectangular set.\n\nInput\n\nd – direction\nR – rectification of a hyperrectangular set\n\nOutput\n\nA support vector in the given direction.\n\nAlgorithm\n\nLet R() be the rectification of a vector respectively a set, and let H be a hyperrectangle. Then σ_R(H)(d) = R(σ_H(d)).\n\n\n\n\n\nσ(d::AbstractVector, R::Rectification{N, <:CartesianProduct}) where {N}\n\nReturn a support vector of the rectification of a Cartesian product of two sets.\n\nInput\n\nd – direction\nR – rectification of a Cartesian product of two sets\n\nOutput\n\nA support vector in the given direction.\n\nNotes\n\nNote that this implementation creates new Rectification objects that do not get preserved. Hence a second support-vector query does not benefit from the computations in the first query. For this use case another implementation should be added.\n\nAlgorithm\n\nRectification distributes with the Cartesian product. Let R() be the rectification of a set. We can just query a support vector for R(X) and R(Y) recursively: σ_R(X  Y)(d) = σ_R(X)(d_X)  σ_R(Y)(d_Y), where x  y concatenates vectors x and y.\n\n\n\n\n\nσ(d::AbstractVector,\n  R::Rectification{N, <:CartesianProductArray}) where {N}\n\nReturn a support vector of the rectification of a Cartesian product of a finite number of sets.\n\nInput\n\nd – direction\nR – rectification of a Cartesian product of a finite number of sets\n\nOutput\n\nA support vector in the given direction.\n\nNotes\n\nNote that this implementation creates new Rectification objects that do not get preserved. Hence a second support-vector query does not benefit from the computations in the first query. For this use case another implementation should be added.\n\nAlgorithm\n\nRectification distributes with the Cartesian product. Let R() be the rectification of a set. We can just query a support vector for each subspace recursively: σ_R(X_1    X_m)(d) = σ_R(X_1)(d_X_1)    σ_R(X_m)(d_X_m), where x  y concatenates vectors x and y.\n\n\n\n\n\nExtended help\n\nσ(d::AbstractVector{M}, P::HPoly{N};\n  solver=default_lp_solver(M, N) where {M, N}\n\nInput\n\nsolver – (optional, default: default_lp_solver(M, N)) the backend used to             solve the linear program\n\nOutput\n\nIf P is unbounded in the given direction, there are two cases:\n\nIf P is an HPolytope, we throw an error.\nIf P is an HPolyedron, the result contains ±Inf entries.\n\n\n\n\n\nExtended help\n\nσ(d::AbstractVector, P::HPolygon;\n  [linear_search]::Bool=(length(P.constraints) < 10))\n\nInput\n\nlinear_search – (optional, default: see below) flag for controlling whether                    to perform a linear search or a binary search\n\nOutput\n\nThe result is always one of the vertices; in particular, if the direction has norm zero, any vertex is returned.\n\nAlgorithm\n\nComparison of directions is performed using polar angles; see the definition of ⪯ for two-dimensional vectors.\n\nFor polygons with 10 or more constraints we use a binary search by default.\n\n\n\n\n\n","category":"function"},{"location":"lib/API/#LazySets.API.translate-Tuple{LazySets.API.LazySet, AbstractVector}","page":"API","title":"LazySets.API.translate","text":"translate(X::LazySet, v::AbstractVector)\n\nCompute the translation of a set with a vector.\n\nInput\n\nX – set\nv – vector\n\nOutput\n\nA set representing X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.translate!-Tuple{LazySets.API.LazySet, AbstractVector}","page":"API","title":"LazySets.API.translate!","text":"translate!(X::LazySet, v::AbstractVector)\n\nTranslate a set with a vector by modifying it.\n\nInput\n\nX – set\nv – vector\n\nOutput\n\nThe translated set representing X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#Binary-set-functions","page":"API","title":"Binary set functions","text":"","category":"section"},{"location":"lib/API/#LazySets.API.cartesian_product-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}","page":"API","title":"LazySets.API.cartesian_product","text":"cartesian_product(X::LazySet, Y::LazySet)\n\nCompute the Cartesian product of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the Cartesian product X  Y.\n\nNotes\n\nThe Cartesian product of two sets X and Y is defined as\n\n    X  Y = x y mid x  X y  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.convex_hull-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}","page":"API","title":"LazySets.API.convex_hull","text":"convex_hull(X::LazySet, Y::LazySet)\n\nCompute the convex hull of (the union of) two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the convex hull of X  Y.\n\nNotes\n\nSee convex_hull(::LazySet) for the convex hull of a single set.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}","page":"API","title":"LazySets.API.difference","text":"difference(X::LazySet, Y::LazySet)\n\nCompute the set difference of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the difference X  Y.\n\nNotes\n\nThe set difference is defined as:\n\n    X  Y = x mid x  X text and  x  Y \n\n\n\n\n\n","category":"method"},{"location":"lib/API/#ReachabilityBase.Arrays.distance-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}","page":"API","title":"ReachabilityBase.Arrays.distance","text":"distance(X::LazySet, Y::LazySet; [p]::Real=2)\n\nCompute the standard distance (induced by the p-norm) between two sets.\n\nInput\n\nX – set\nY – set\np – (optional; default: 2) value of the p-norm\n\nOutput\n\nA real number representing the distance between X and Y.\n\nNotes\n\nThe standard distance is zero if the sets intersect, and infinite if one of the sets is empty. Otherwise, it is the p-norm of the shortest line segment between any pair of points. Formally,\n\n    inf_x  X y  Y  d(x y) \n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.exact_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}","page":"API","title":"LazySets.API.exact_sum","text":"exact_sum(X::LazySet, Y::LazySet)\n\nCompute the exact sum of two parametric sets.\n\nInput\n\nX – parametric set\nY – parametric set\n\nOutput\n\nA set representing the exact sum, sometimes written X  Y.\n\nNotes\n\nFor parametric sets, the exact sum behaves like the Minkowski sum, except that the parameters are shared. Thus, for nonparametric sets, it coincides with the Minkowski sum.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.intersection-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}","page":"API","title":"LazySets.API.intersection","text":"intersection(X::LazySet, Y::LazySet)\n\nCompute the intersection of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the intersection X  Y.\n\nNotes\n\nThe intersection of two sets X and Y is defined as\n\n    X  Y = x mid x  X text and  x  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#Base.:≈-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}","page":"API","title":"Base.:≈","text":"≈(X::LazySet, Y::LazySet)\n\nCheck whether two sets of the same type are approximately equal.\n\nInput\n\nX – set\nY – set of the same base type as X\n\nOutput\n\ntrue iff X is approximately equal to Y.\n\nNotes\n\nThe check is purely syntactic and the sets need to have the same base type, i.e., X::T1 ≈ Y::T2 always returns false even if X and Y represent the same set. But X::T{Int64} ≈ Y::T{Float64} is a valid comparison.\n\nThe convenience alias isapprox is also available.\n\n\"≈\" can be typed by \\approx<tab>.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#Base.isdisjoint-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}","page":"API","title":"Base.isdisjoint","text":"isdisjoint(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nCheck whether two sets are disjoint (i.e., do not intersect), and optionally compute a witness.\n\nInput\n\nX       – set\nY       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X  Y = \nIf the witness option is activated:\n(true, []) iff X  Y = \n(false, v) iff X  Y   for some v  X  Y\n\nNotes\n\nThe convenience alias is_intersection_empty is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.is_intersection_empty","page":"API","title":"LazySets.API.is_intersection_empty","text":"is_intersection_empty(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nConvenience alias for the isdisjoint function.\n\n\n\n\n\n","category":"function"},{"location":"lib/API/#Base.:==-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}","page":"API","title":"Base.:==","text":"==(X::LazySet, Y::LazySet)\n\nCheck whether two sets use exactly the same set representation.\n\nInput\n\nX – set\nY – set\n\nOutput\n\ntrue iff X is equal to Y.\n\nNotes\n\nThe check is purely syntactic and the sets need to have the same base type, i.e., X::T1 == Y::T2 always returns false even if X and Y represent the same set. But X::T{Int64} == Y::T{Float64} is a valid comparison.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.isequivalent-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}","page":"API","title":"LazySets.API.isequivalent","text":"isequivalent(X::LazySet, Y::LazySet)\n\nCheck whether two sets are equivalent, i.e., represent the same set of points.\n\nInput\n\nX – set\nY – set\n\nOutput\n\ntrue iff X is equivalent to Y (up to numerical precision).\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.:⊂-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}","page":"API","title":"LazySets.API.:⊂","text":"⊂(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nCheck whether a set is a strict subset of another set, and optionally compute a witness.\n\nInput\n\nX       – set\nY       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X  Y\nIf the witness option is activated:\n(true, v) iff X  Y for some v  Y  X\n(false, []) iff X  Y does not hold\n\nNotes\n\nStrict inclusion is sometimes written as ⊊. The following identity holds:\n\n    X  Y  X  Y  Y  X\n\nAlgorithm\n\nThe default implementation first checks inclusion of X in Y and then checks noninclusion of Y in X:\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#Base.:⊆-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}","page":"API","title":"Base.:⊆","text":"⊆(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nCheck whether a set is a subset of another set, and optionally compute a witness.\n\nInput\n\nX       – set\nY       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X  Y\nIf the witness option is activated:\n(true, []) iff X  Y\n(false, v) iff X  Y for some v  X  Y\n\nNotes\n\nThe convenience alias issubset is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.linear_combination-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}","page":"API","title":"LazySets.API.linear_combination","text":"linear_combination(X::LazySet, Y::LazySet)\n\nCompute the linear combination of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the linear combination of X and Y.\n\nNotes\n\nThe linear combination of two sets X and Y is defined as\n\n    leftfrac12(1+λ)x + frac12(1-λ)y mid x  X y  Y λ  -1 1right\n\nIf X and Y are convex, their linear combination is identical with the convex hull of their union X  Y.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.minkowski_difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}","page":"API","title":"LazySets.API.minkowski_difference","text":"minkowski_difference(X::LazySet, Y::LazySet)\n\nCompute the Minkowski difference of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the Minkowski difference X  Y.\n\nNotes\n\nThe Minkowski difference of two sets X and Y is defined as\n\n    X  Y = z mid z  Y  X\n\nThe convenience alias pontryagin_difference is also available.\n\nThere is some inconsistency in the literature regarding the naming conventions. In this library, both Minkowski difference and Pontryagin difference refer to the geometric difference of two sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/API/#LazySets.API.pontryagin_difference","page":"API","title":"LazySets.API.pontryagin_difference","text":"pontryagin_difference(X::LazySet, Y::LazySet)\n\nConvenience alias for the minkowski_difference function.\n\n\n\n\n\n","category":"function"},{"location":"lib/API/#LazySets.API.minkowski_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}","page":"API","title":"LazySets.API.minkowski_sum","text":"minkowski_sum(X::LazySet, Y::LazySet)\n\nCompute the Minkowski sum of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the Minkowski sum X  Y.\n\nNotes\n\nThe Minkowski sum of two sets X and Y is defined as\n\n    X  Y = x + y mid x  X y  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/minkowski_sum/","page":"Minkowski Sum","title":"Minkowski Sum","text":"Pages = [\"minkowski_sum.md\"]\nDepth = 3","category":"page"},{"location":"lib/concrete_binary_operations/minkowski_sum/#Minkowski-Sum","page":"Minkowski Sum","title":"Minkowski Sum","text":"","category":"section"},{"location":"lib/concrete_binary_operations/minkowski_sum/#LazySets.API.minkowski_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-concrete_binary_operations-minkowski_sum","page":"Minkowski Sum","title":"LazySets.API.minkowski_sum","text":"minkowski_sum(X::LazySet, Y::LazySet)\n\nCompute the Minkowski sum of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the Minkowski sum X  Y.\n\nNotes\n\nThe Minkowski sum of two sets X and Y is defined as\n\n    X  Y = x + y mid x  X y  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/minkowski_sum/#LazySets.API.minkowski_sum-Tuple{DensePolynomialZonotope, AbstractZonotope}","page":"Minkowski Sum","title":"LazySets.API.minkowski_sum","text":"Extended help\n\nminkowski_sum(PZ::DensePolynomialZonotope, Z::AbstractZonotope)\n\nOutput\n\nA DensePolynomialZonotope.\n\nAlgorithm\n\nThe polynomial zonotope's center is the sum of the centers of PZ and Z, and its generators are the concatenation of the generators of PZ and Z.\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/minkowski_sum/#LazySets.API.minkowski_sum-Tuple{AbstractSparsePolynomialZonotope, AbstractSparsePolynomialZonotope}","page":"Minkowski Sum","title":"LazySets.API.minkowski_sum","text":"Extended help\n\nminkowski_sum(P1::AbstractSparsePolynomialZonotope, P2::AbstractSparsePolynomialZonotope)\n\nAlgorithm\n\nSee Kochdumper [Koc22], Proposition 3.1.19.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#def_SimpleSparsePolynomialZonotope","page":"SimpleSparsePolynomialZonotope","title":"SimpleSparsePolynomialZonotope","text":"","category":"section"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#LazySets.SimpleSparsePolynomialZonotopeModule.SimpleSparsePolynomialZonotope","page":"SimpleSparsePolynomialZonotope","title":"LazySets.SimpleSparsePolynomialZonotopeModule.SimpleSparsePolynomialZonotope","text":"SimpleSparsePolynomialZonotope{N, VN<:AbstractVector{N},\n                               MN<:AbstractMatrix{N},\n                               ME<:AbstractMatrix{Int}}\n    <: AbstractSparsePolynomialZonotope{N}\n\nType that represents a sparse polynomial zonotope that is simple in the sense that there is no distinction between independent and dependent generators.\n\nA simple sparse polynomial zonotope mathcalPZ  ℝ^n is represented by the set\n\nmathcalPZ = leftx  ℝ^n  x = c + _i=1^h left(_k=1^p α_k^E_k i right) g_i α_k  -1 1  i = 1p right\n\nwhere c  ℝ^n is the offset vector (or center), G  ℝ^n  h is the generator matrix with columns g_i (each g_i is called a generator), and where E  mathbbN^ph_0 is the exponent matrix with matrix elements E_k i.\n\nFields\n\nc – offset vector\nG – generator matrix\nE – exponent matrix\n\nNotes\n\nSparse polynomial zonotopes were introduced in Kochdumper and Althoff [KA21]. The simple variant was defined in [Kochdumper21b].\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/","page":"SimpleSparsePolynomialZonotope","title":"SimpleSparsePolynomialZonotope","text":"Alias:","category":"page"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#LazySets.PolynomialZonotope","page":"SimpleSparsePolynomialZonotope","title":"LazySets.PolynomialZonotope","text":"PolynomialZonotope = SimpleSparsePolynomialZonotope\n\nAlias for SimpleSparsePolynomialZonotope.\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#Operations","page":"SimpleSparsePolynomialZonotope","title":"Operations","text":"","category":"section"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#LazySets.API.convex_hull-Tuple{LazySets.API.LazySet}-lib-sets-SimpleSparsePolynomialZonotope","page":"SimpleSparsePolynomialZonotope","title":"LazySets.API.convex_hull","text":"convex_hull(X::LazySet)\n\nCompute the convex hull of a set.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the convex hull of X.\n\nNotes\n\nThe convex hull of a set X is defined as\n\n    λx + (1-λ)y mid x y  X λ  0 1\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#LazySets.API.convex_hull-Tuple{SimpleSparsePolynomialZonotope}","page":"SimpleSparsePolynomialZonotope","title":"LazySets.API.convex_hull","text":"Extended help\n\nconvex_hull(P::SimpleSparsePolynomialZonotope)\n\nOutput\n\nThe tightest convex simple sparse polynomial zonotope containing P.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#LazySets.expmat-Tuple{SimpleSparsePolynomialZonotope}","page":"SimpleSparsePolynomialZonotope","title":"LazySets.expmat","text":"expmat(P::SimpleSparsePolynomialZonotope)\n\nReturn the matrix of exponents of a simple sparse polynomial zonotope.\n\nInput\n\nP – simple sparse polynomial zonotope\n\nOutput\n\nThe matrix of exponents, where each column is a multidegree.\n\nNotes\n\nIn the exponent matrix, each row corresponds to a parameter (lpha_k in the mathematical set definition) and each column corresponds to a monomial.\n\nExamples\n\njulia> S = SimpleSparsePolynomialZonotope([2.0, 0], [1 2;2 2.], [1 4;1 2])\nSimpleSparsePolynomialZonotope{Float64, Vector{Float64}, Matrix{Float64}, Matrix{Int64}}([2.0, 0.0], [1.0 2.0; 2.0 2.0], [1 4; 1 2])\n\njulia> expmat(S)\n2×2 Matrix{Int64}:\n 1  4\n 1  2\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#LazySets.ngens-Tuple{AbstractZonotope}-lib-sets-SimpleSparsePolynomialZonotope","page":"SimpleSparsePolynomialZonotope","title":"LazySets.ngens","text":"ngens(Z::AbstractZonotope)\n\nReturn the number of generators of a zonotopic set.\n\nInput\n\nZ – zonotopic set\n\nOutput\n\nAn integer representing the number of generators.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#LazySets.ngens-Tuple{SimpleSparsePolynomialZonotope}","page":"SimpleSparsePolynomialZonotope","title":"LazySets.ngens","text":"Extended help\n\nngens(P::SimpleSparsePolynomialZonotope)\n\nNotes\n\nThis number corresponds to the number of monomials in the polynomial representation of P.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-SimpleSparsePolynomialZonotope","page":"SimpleSparsePolynomialZonotope","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#Base.rand-Tuple{Type{SimpleSparsePolynomialZonotope}}","page":"SimpleSparsePolynomialZonotope","title":"Base.rand","text":"Extended help\n\nrand(::Type{SimpleSparsePolynomialZonotope};\n     [N]::Type{<:Real}=Float64, [dim]::Int=2, [nparams]::Int=2,\n     [maxdeg]::Int=3, [num_generators]::Int=-1,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1.\n\nThe number of generators can be controlled with the argument num_generators. For a negative value we choose a random number in the range dim:2*dim (except if dim == 1, in which case we only create a single generator). Note that the final number of generators may be lower if redundant monomials are generated.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#LazySets.remove_redundant_generators-Tuple{AbstractZonotope}-lib-sets-SimpleSparsePolynomialZonotope","page":"SimpleSparsePolynomialZonotope","title":"LazySets.remove_redundant_generators","text":"remove_redundant_generators(Z::AbstractZonotope)\n\nRemove all redundant (pairwise linearly dependent) generators of a zonotopic set.\n\nInput\n\nZ – zonotopic set\n\nOutput\n\nA new zonotope with fewer generators, or the same zonotopic set if no generator could be removed.\n\nAlgorithm\n\nBy default this implementation returns the input zonotopic set. Subtypes of AbstractZonotope whose generators can be removed have to define a new method.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#LazySets.remove_redundant_generators-Tuple{SimpleSparsePolynomialZonotope}","page":"SimpleSparsePolynomialZonotope","title":"LazySets.remove_redundant_generators","text":"remove_redundant_generators(S::SimpleSparsePolynomialZonotope)\n\nRemove redundant generators from a simple sparse polynomial zonotope.\n\nInput\n\nS – simple sparse polynomial zonotope\n\nOutput\n\nA new simple sparse polynomial zonotope such that redundant generators have been removed.\n\nNotes\n\nThe result uses dense arrays irrespective of the array type of S.\n\nAlgorithm\n\nLet G be the generator matrix and E the exponent matrix of S. The following simplifications are performed:\n\nZero columns in G and the corresponding columns in E are removed.\nFor zero columns in E, the corresponding column in G is summed to the center.\nRepeated columns in E are grouped together by summing the corresponding columns in G.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#LazySets.SimpleSparsePolynomialZonotopeModule.quadratic_map-Tuple{Vector{<:AbstractMatrix}, SimpleSparsePolynomialZonotope}","page":"SimpleSparsePolynomialZonotope","title":"LazySets.SimpleSparsePolynomialZonotopeModule.quadratic_map","text":"quadratic_map(Q::Vector{<:AbstractMatrix}, S::SimpleSparsePolynomialZonotope)\n\nReturn the quadratic map of a simple sparse polynomial zonotope.\n\nInput\n\nQ – vector of square matrices\nS – simple sparse polynomial zonotope\n\nOutput\n\nThe quadratic map of P represented as a simple sparse polynomial zonotope.\n\nAlgorithm\n\nThis method implements Kochdumper and Althoff [KA21], Proposition 12. See also Kochdumper [Koc22], Proposition 3.1.30.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#LazySets.SimpleSparsePolynomialZonotopeModule.quadratic_map-Tuple{Vector{<:AbstractMatrix}, SimpleSparsePolynomialZonotope, SimpleSparsePolynomialZonotope}","page":"SimpleSparsePolynomialZonotope","title":"LazySets.SimpleSparsePolynomialZonotopeModule.quadratic_map","text":"quadratic_map(Q::Vector{<:AbstractMatrix}, S1::SimpleSparsePolynomialZonotope,\n              S2::SimpleSparsePolynomialZonotope)\n\nReturn the quadratic map of two simple sparse polynomial zonotopes. The quadratic map is the set\n\n    x mid xᵢ = s₁ᵀQᵢs₂ s₁  S₁ s₂  S₂ Qᵢ  Q\n\nInput\n\nQ  – vector of square matrices\nS1 – simple sparse polynomial zonotope\nS2 – simple sparse polynomial zonotope\n\nOutput\n\nThe quadratic map of the given simple sparse polynomial zonotopes represented as a simple sparse polynomial zonotope.\n\nAlgorithm\n\nThis method implements Kochdumper [Koc22], Proposition 3.1.30.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#LazySets.API.cartesian_product-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-sets-SimpleSparsePolynomialZonotope","page":"SimpleSparsePolynomialZonotope","title":"LazySets.API.cartesian_product","text":"cartesian_product(X::LazySet, Y::LazySet)\n\nCompute the Cartesian product of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the Cartesian product X  Y.\n\nNotes\n\nThe Cartesian product of two sets X and Y is defined as\n\n    X  Y = x y mid x  X y  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#LazySets.API.cartesian_product-Tuple{SimpleSparsePolynomialZonotope, SimpleSparsePolynomialZonotope}","page":"SimpleSparsePolynomialZonotope","title":"LazySets.API.cartesian_product","text":"Extended help\n\ncartesian_product(P1::SimpleSparsePolynomialZonotope,\n                  P2::SimpleSparsePolynomialZonotope)\n\nAlgorithm\n\nThis method implements Kochdumper [Koc22], Proposition 3.1.22.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#LazySets.API.convex_hull-Tuple{LazySet, LazySet}-lib-sets-SimpleSparsePolynomialZonotope","page":"SimpleSparsePolynomialZonotope","title":"LazySets.API.convex_hull","text":"convex_hull(X::LazySet, Y::LazySet; [algorithm]=nothing,\n            [backend]=nothing, [solver]=nothing)\n\nCompute the convex hull of two polytopic sets.\n\nInput\n\nX         – polytopic set\nY         – polytopic set\nalgorithm – (optional, default: nothing) the convex-hull algorithm\nbackend   – (optional, default: nothing) backend for polyhedral                computations (used for higher-dimensional sets)\nsolver    – (optional, default: nothing) the linear-programming solver                used in the backend\n\nOutput\n\nIf the sets are empty, the result is an EmptySet. If the convex hull consists of a single point, the result is a Singleton. If the input sets are one-dimensional, the result is an Interval. If the input sets are two-dimensional, the result is a VPolygon. Otherwise the result is a VPolytope.\n\nAlgorithm\n\nWe compute the vertices of both X and Y using vertices_list and then compute the convex hull of the union of those vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#LazySets.API.convex_hull-Tuple{SimpleSparsePolynomialZonotope, SimpleSparsePolynomialZonotope}","page":"SimpleSparsePolynomialZonotope","title":"LazySets.API.convex_hull","text":"Extended help\n\nconvex_hull(P1::SimpleSparsePolynomialZonotope,\n            P2::SimpleSparsePolynomialZonotope)\n\nOutput\n\nThe tightest convex simple sparse polynomial zonotope containing P1 and P2.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#LazySets.API.linear_combination-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-sets-SimpleSparsePolynomialZonotope","page":"SimpleSparsePolynomialZonotope","title":"LazySets.API.linear_combination","text":"linear_combination(X::LazySet, Y::LazySet)\n\nCompute the linear combination of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the linear combination of X and Y.\n\nNotes\n\nThe linear combination of two sets X and Y is defined as\n\n    leftfrac12(1+λ)x + frac12(1-λ)y mid x  X y  Y λ  -1 1right\n\nIf X and Y are convex, their linear combination is identical with the convex hull of their union X  Y.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/#LazySets.API.linear_combination-Tuple{SimpleSparsePolynomialZonotope, SimpleSparsePolynomialZonotope}","page":"SimpleSparsePolynomialZonotope","title":"LazySets.API.linear_combination","text":"Extended help\n\nlinear_combination(P1::SimpleSparsePolynomialZonotope,\n                   P2::SimpleSparsePolynomialZonotope)\n\nNotes\n\nThis method implements the algorithm described in Kochdumper [Koc22], Proposition 3.1.25.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/","page":"SimpleSparsePolynomialZonotope","title":"SimpleSparsePolynomialZonotope","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/","page":"SimpleSparsePolynomialZonotope","title":"SimpleSparsePolynomialZonotope","text":"center","category":"page"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/","page":"SimpleSparsePolynomialZonotope","title":"SimpleSparsePolynomialZonotope","text":"genmat","category":"page"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/","page":"SimpleSparsePolynomialZonotope","title":"SimpleSparsePolynomialZonotope","text":"isoperationtype","category":"page"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/","page":"SimpleSparsePolynomialZonotope","title":"SimpleSparsePolynomialZonotope","text":"ngens_indep","category":"page"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/","page":"SimpleSparsePolynomialZonotope","title":"SimpleSparsePolynomialZonotope","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/","page":"SimpleSparsePolynomialZonotope","title":"SimpleSparsePolynomialZonotope","text":"an_element\narea\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nextrema\nhigh\nhigh\nisbounded\nisconvextype\nisoperation\nispolyhedral\nlow\nlow\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nproject\nsample\nscale\nexact_sum\n≈\nisdisjoint\n==\nisequivalent\n⊂\n⊆\nlinear_combination\nminkowski_difference","category":"page"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/","page":"SimpleSparsePolynomialZonotope","title":"SimpleSparsePolynomialZonotope","text":"Inherited from AbstractPolynomialZonotope:","category":"page"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/","page":"SimpleSparsePolynomialZonotope","title":"SimpleSparsePolynomialZonotope","text":"center\ndim\nextrema\nisboundedtype\nisempty\nisuniversal\norder","category":"page"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/","page":"SimpleSparsePolynomialZonotope","title":"SimpleSparsePolynomialZonotope","text":"Inherited from AbstractSparsePolynomialZonotope:","category":"page"},{"location":"lib/sets/SimpleSparsePolynomialZonotope/","page":"SimpleSparsePolynomialZonotope","title":"SimpleSparsePolynomialZonotope","text":"ngens_dep\nnparams\nlinear_map\nρ\ntranslate\nminkowski_sum","category":"page"},{"location":"lib/approximations/decompose/","page":"Cartesian Decomposition","title":"Cartesian Decomposition","text":"Pages = [\"decompose.md\"]\nDepth = 3","category":"page"},{"location":"lib/approximations/decompose/#Cartesian-Decomposition","page":"Cartesian Decomposition","title":"Cartesian Decomposition","text":"","category":"section"},{"location":"lib/approximations/decompose/#LazySets.Approximations.decompose","page":"Cartesian Decomposition","title":"LazySets.Approximations.decompose","text":"decompose(S::LazySet{N},\n          partition::AbstractVector{<:AbstractVector{Int}},\n          block_options) where {N}\n\nDecompose a high-dimensional set into a Cartesian product of overapproximations of the projections over the specified subspaces.\n\nInput\n\nS             – set\npartition     – vector of blocks (i.e., of vectors of integers) (see the                    Notes below)\nblock_options – mapping from block indices in partition to a                    corresponding overapproximation option; we only require                    access via [⋅] (but see also the Notes below)\n\nOutput\n\nA CartesianProductArray containing the low-dimensional approximated projections.\n\nAlgorithm\n\nFor each block a specific project method is called, dispatching on the corresponding overapproximation option.\n\nNotes\n\nThe argument partition deserves some explanation. Typically, the list of blocks should form a partition of the set 1  n represented as a list of consecutive blocks, where n is the ambient dimension of set S.\n\nHowever, technically there is no problem if the blocks are not consecutive, blocks are missing, blocks occur more than once, or blocks are overlapping. The resulting set must be interpreted with care in such cases (e.g., it will not necessarily be an overapproximation of S).\n\nFor convenience, the argument block_options can also be given as a single option instead of a mapping, which is then interpreted as the option for all blocks.\n\nExamples\n\nThe argument block_options supports different options: one can specify the target set, the degree of accuracy, and template directions. These options are exemplified below, where we use the following example.\n\njulia> S = Ball2(zeros(4), 1.0);  # set to be decomposed (4D 2-norm unit ball)\n\njulia> P2d = [1:2, 3:4];  # a partition with two blocks, each of size two\n\njulia> P1d = [[1], [2], [3], [4]];  # a partition with four blocks, each of size one\n\nDifferent set types\n\nWe can decompose using polygons in constraint representation:\n\njulia> Y = decompose(S, P2d, HPolygon);\n\njulia> all(ai isa HPolygon for ai in Y)\ntrue\n\nFor decomposition into 1D subspaces, we can use Interval:\n\njulia> Y = decompose(S, P1d, Interval);\n\njulia> all(ai isa Interval for ai in Y)\ntrue\n\nHowever, if you need to specify different set types for different blocks, the interface presented so far does not apply. See the paragraph Advanced input for different block approximations below for how to do that.\n\nRefining the decomposition: ε-close approximation\n\nThe ε option can be used to refine a decomposition, i.e., obtain a more accurate result. We use the Iterative refinement algorithm from the Approximations module.\n\nTo illustrate this, consider again the set S from above. We decompose into two 2D polygons. Using smaller ε implies a better precision, thus more constraints in each 2D decomposition. In the following example, we look at the number of constraints in the first block.\n\njulia> d(ε, bi) = array(decompose(S, P2d, (HPolygon => ε)))[bi]\nd (generic function with 1 method)\n\njulia> [length(constraints_list(d(ε, 1))) for ε in [Inf, 0.1, 0.01]]\n3-element Vector{Int64}:\n  4\n  8\n 32\n\nRefining the decomposition: template polyhedra\n\nAnother way to refine a decomposition is by using template polyhedra. The idea is to specify a set of template directions and then compute on each block the polytopic overapproximation obtained by evaluating the support function of the given input set over the template directions.\n\nFor example, octagonal 2D approximations of the set S are obtained with:\n\njulia> B = decompose(S, P2d, OctDirections);\n\njulia> length(B.array) == 2 && all(dim(bi) == 2 for bi in B.array)\ntrue\n\nSee Template directions for the available template directions. Note that, in contrast to the polygonal ε-close approximation from above, this method can be applied to blocks of any size.\n\njulia> B = decompose(S, [1:4], OctDirections);\n\njulia> length(B.array) == 1 && dim(B.array[1]) == 4\ntrue\n\nAdvanced input for different block approximations\n\nInstead of defining the approximation option uniformly for each block, we can define different approximations for different blocks. For this purpose, the argument block_options can also be a mapping from block index (in the partition) to the corresponding approximation option.\n\nFor example, we can approximate the first block with a Hyperrectangle and the second block with ε-close approximation for ε = 01:\n\njulia> res = array(decompose(S, P2d, Dict(1 => Hyperrectangle, 2 => 0.1)));\n\njulia> typeof(res[1]), typeof(res[2])\n(Hyperrectangle{Float64, Vector{Float64}, Vector{Float64}}, HPolygon{Float64, Vector{Float64}})\n\n\n\n\n\ndecompose(S::LazySet, block_options; [block_size]::Int=1)\n\nDecompose a high-dimensional set into a Cartesian product of overapproximations of the projections over uniformly-sized subspaces.\n\nInput\n\nS             – set\nblock_options – overapproximation option or mapping from block indices to a                    corresponding overapproximation option\nblock_size    – (optional; default: 1) size of the blocks\n\nOutput\n\nA CartesianProductArray containing the low-dimensional approximated projections.\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/Bloating/#def_Bloating","page":"Bloating","title":"Bloating","text":"","category":"section"},{"location":"lib/lazy_operations/Bloating/#LazySets.Bloating","page":"Bloating","title":"LazySets.Bloating","text":"Bloating{N, S<:LazySet{N}} <: LazySet{N}\n\nType that represents a uniform expansion of a set in a given norm (also known as bloating).\n\nFields\n\nX – set\nε – (usually positive) bloating factor\np – p-norm (should be  1; default: 2)\n\nNotes\n\nThe Bloating operation preserves convexity: if X is convex, then any bloating of X is convex as well.\n\nIf ε is positive, then Bloating(X, ε, p) is equivalent to the Minkowski sum of X and a ball in the p-norm of radius ε centered in the origin O (i.e., X ⊕ Ballp(p, O, ε)).\n\nSome operations require, or silently assume, that ε is positive. Check the documentation for further information.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/Bloating/#LazySets.API.dim-Tuple{Bloating}","page":"Bloating","title":"LazySets.API.dim","text":"dim(B::Bloating)\n\nReturn the dimension of a bloated set.\n\nInput\n\nB – bloated set\n\nOutput\n\nThe ambient dimension of the bloated set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Bloating/#LazySets.API.σ-Tuple{AbstractVector, Bloating}","page":"Bloating","title":"LazySets.API.σ","text":"σ(d::AbstractVector, B::Bloating)\n\nReturn the support vector of a bloated set in a given direction.\n\nInput\n\nd – direction\nB – bloated set\n\nOutput\n\nThe support vector of the bloated set in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Bloating/#LazySets.API.ρ-Tuple{AbstractVector, Bloating}","page":"Bloating","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, B::Bloating)\n\nReturn the support function of a bloated set in a given direction.\n\nInput\n\nd – direction\nB – bloated set\n\nOutput\n\nThe support function of the bloated set in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Bloating/#LazySets.API.isbounded-Tuple{Bloating}","page":"Bloating","title":"LazySets.API.isbounded","text":"isbounded(B::Bloating)\n\nDetermine whether a bloated set is bounded.\n\nInput\n\nB – bloated set\n\nOutput\n\ntrue iff the wrapped set is bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Bloating/#Base.isempty-Tuple{Bloating}","page":"Bloating","title":"Base.isempty","text":"isempty(B::Bloating)\n\nDetermine whether a bloated set is empty.\n\nInput\n\nB – bloated set\n\nOutput\n\ntrue iff the wrapped set is empty.\n\nNotes\n\nThis implementation disregards negative bloating, which could potentially turn a non-empty set into an empty set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Bloating/#LazySets.API.an_element-Tuple{Bloating}","page":"Bloating","title":"LazySets.API.an_element","text":"an_element(B::Bloating)\n\nReturn some element of a bloated set.\n\nInput\n\nB – bloated set\n\nOutput\n\nAn element in the bloated set.\n\nAlgorithm\n\nThis implementation disregards negative bloating and returns the result of an_element for the wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Bloating/#LazySets.API.constraints_list-Tuple{Bloating}","page":"Bloating","title":"LazySets.API.constraints_list","text":"constraints_list(B::Bloating)\n\nReturn the list of constraints of a bloated set.\n\nInput\n\nB – bloated set\n\nOutput\n\nThe list of constraints of the bloated set.\n\nNotes\n\nThe constraints list is only available for non-negative bloating in the p-norm for p = 1 or p =  and if constraints_list is available for the unbloated set.\n\nAlgorithm\n\nWe call constraints_list on the lazy Minkowski sum with the bloating ball.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Bloating/#LazySets.API.center-Tuple{Bloating}","page":"Bloating","title":"LazySets.API.center","text":"center(B::Bloating)\n\nReturn the center of a bloated set.\n\nInput\n\nB – bloated set\n\nOutput\n\nThe center of the wrapped set.\n\nNotes\n\nThis implementation disregards negative bloating, which could potentially remove the center from the set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Bloating/#LazySets.API.ispolyhedral-Tuple{Bloating}","page":"Bloating","title":"LazySets.API.ispolyhedral","text":"ispolyhedral(B::Bloating)\n\nCheck whether a bloated set is polyhedral.\n\nInput\n\nB – bloated set\n\nOutput\n\ntrue if the set is polyhedral.\n\nAlgorithm\n\nWe check the sufficient condition that the base set is polyhedral and that the norm for bloating is either 1-norm or the infinity norm.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Bloating/","page":"Bloating","title":"Bloating","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/Bloating/","page":"Bloating","title":"Bloating","text":"high\nlow\nreflect","category":"page"},{"location":"lib/sets/Ellipsoid/#def_Ellipsoid","page":"Ellipsoid","title":"Ellipsoid","text":"","category":"section"},{"location":"lib/sets/Ellipsoid/#LazySets.EllipsoidModule.Ellipsoid","page":"Ellipsoid","title":"LazySets.EllipsoidModule.Ellipsoid","text":"Ellipsoid{N<:AbstractFloat, VN<:AbstractVector{N},\n          MN<:AbstractMatrix{N}} <: AbstractCentrallySymmetric{N}\n\nType that represents an ellipsoid.\n\nIt is defined as the set\n\nE = left x  ℝ^n  (x-c)^T Q^-1 (x-c)  1 right\n\nwhere c  ℝ^n is its center and Q  ℝ^nn its shape matrix, which should be a positive definite matrix. An ellipsoid can also be characterized as the image of a Euclidean ball by an invertible linear transformation. It is the higher-dimensional generalization of an ellipse.\n\nFields\n\ncenter       – center of the ellipsoid\nshape_matrix – real positive definite matrix, i.e., it is equal to its                   transpose and x^mathrmTQx  0 for all nonzero x\n\nNotes\n\nBy default, the inner constructor checks that the given shape matrix is positive definite. Use the flag check_posdef=false to disable this check.\n\nExamples\n\nWe create a two-dimensional ellipsoid with center [1, 1]:\n\njulia> using LinearAlgebra\n\njulia> E = Ellipsoid(ones(2), Diagonal([2.0, 0.5]))\nEllipsoid{Float64, Vector{Float64}, Diagonal{Float64, Vector{Float64}}}([1.0, 1.0], [2.0 0.0; 0.0 0.5])\n\nIf the center is not specified, it is assumed that it is the origin. For instance, a three-dimensional ellipsoid centered in the origin with the shape matrix being the identity can be created as follows:\n\njulia> E = Ellipsoid(Matrix(1.0I, 3, 3))\nEllipsoid{Float64, Vector{Float64}, Matrix{Float64}}([0.0, 0.0, 0.0], [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])\n\njulia> dim(E)\n3\n\nThe center and shape matrix of the ellipsoid can be retrieved with the functions center and shape_matrix, respectively:\n\njulia> center(E)\n3-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n\njulia> shape_matrix(E)\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\nThe function an_element returns some element of the ellipsoid:\n\njulia> an_element(E)\n3-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n\njulia> an_element(E) ∈ E\ntrue\n\nWe can evaluate the support vector in a given direction, say [1, 1, 1]:\n\njulia> σ(ones(3), E)\n3-element Vector{Float64}:\n 0.5773502691896258\n 0.5773502691896258\n 0.5773502691896258\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Ellipsoid/#Operations","page":"Ellipsoid","title":"Operations","text":"","category":"section"},{"location":"lib/sets/Ellipsoid/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-Ellipsoid","page":"Ellipsoid","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/#Base.rand-Tuple{Type{Ellipsoid}}","page":"Ellipsoid","title":"Base.rand","text":"Extended help\n\nrand(::Type{Ellipsoid}; [N]::Type{<:AbstractFloat}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nAlgorithm\n\nThe center is a normally distributed vector with entries of mean 0 and standard deviation 1.\n\nThe idea for the shape matrix comes from here. The matrix is symmetric positive definite, but also diagonally dominant.\n\nQ =  frac12(S + S^T) + nI\n\nwhere n = dim and S is a n  n random matrix whose coefficients are uniformly distributed in the interval -1 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/#LazySets.EllipsoidModule.shape_matrix-Tuple{Ellipsoid}","page":"Ellipsoid","title":"LazySets.EllipsoidModule.shape_matrix","text":"shape_matrix(E::Ellipsoid)\n\nReturn the shape matrix of the ellipsoid.\n\nInput\n\nE – ellipsoid\n\nOutput\n\nThe shape matrix of the ellipsoid.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-Ellipsoid","page":"Ellipsoid","title":"Base.:∈","text":"∈(x::AbstractVector, X::LazySet)\n\nCheck whether a point lies in a set.\n\nInput\n\nx – point/vector\nX – set\n\nOutput\n\ntrue iff x  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/#Base.:∈-Tuple{AbstractVector, Ellipsoid}","page":"Ellipsoid","title":"Base.:∈","text":"Extended help\n\n∈(x::AbstractVector, E::Ellipsoid)\n\nAlgorithm\n\nThe point x belongs to the ellipsoid of center c and shape matrix Q if and only if\n\n(x-c)^mathrmT Q^-1 (x-c)  1\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/#LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-Ellipsoid","page":"Ellipsoid","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, X::LazySet)\n\nEvaluate the support function of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nThe evaluation of the support function of X in direction d.\n\nNotes\n\nA convenience alias support_function is also available.\n\nWe have the following identity based on the support vector σ:\n\n    ρ(d X) = d  σ(d X)\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/#LazySets.API.ρ-Tuple{AbstractVector, Ellipsoid}","page":"Ellipsoid","title":"LazySets.API.ρ","text":"Extended help\n\nρ(d::AbstractVector, E::Ellipsoid)\n\nAlgorithm\n\nThe support value is cᵀ d + Bᵀ d₂, where c is the center and Q = B Bᵀ is the shape matrix of E.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-Ellipsoid","page":"Ellipsoid","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/#LazySets.API.σ-Tuple{AbstractVector, Ellipsoid}","page":"Ellipsoid","title":"LazySets.API.σ","text":"Extended help\n\nσ(d::AbstractVector, E::Ellipsoid)\n\nAlgorithm\n\nLet E be an ellipsoid of center c and shape matrix Q = BB^mathrmT. Its support vector along direction d can be deduced from that of the unit Euclidean ball mathcalB_2 using the algebraic relations for the support vector,\n\nσ_BmathcalB_2  c(d) = c + Bσ_mathcalB_2 (B^mathrmT d)\n= c + dfracQdsqrtd^mathrmTQ d\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/#LazySets.API.linear_map-Tuple{AbstractMatrix, LazySets.API.LazySet}-lib-sets-Ellipsoid","page":"Ellipsoid","title":"LazySets.API.linear_map","text":"linear_map(M::AbstractMatrix, X::LazySet)\n\nCompute the linear map M  X.\n\nInput\n\nM – matrix\nX – set\n\nOutput\n\nA set representing the linear map M  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/#LazySets.API.linear_map-Tuple{AbstractMatrix, Ellipsoid}","page":"Ellipsoid","title":"LazySets.API.linear_map","text":"Extended help\n\nlinear_map(M::AbstractMatrix, E::Ellipsoid)\n\nAlgorithm\n\nGiven an ellipsoid c Q and a matrix M, the linear map yields the ellipsoid M c M Q Mᵀ.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/","page":"Ellipsoid","title":"Ellipsoid","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/Ellipsoid/","page":"Ellipsoid","title":"Ellipsoid","text":"center\nisoperationtype\naffine_map\ntranslate!","category":"page"},{"location":"lib/sets/Ellipsoid/","page":"Ellipsoid","title":"Ellipsoid","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Ellipsoid/","page":"Ellipsoid","title":"Ellipsoid","text":"chebyshev_center_radius\nconcretize\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nhigh\nhigh\nispolyhedral\nisoperation\nlow\nlow\nnorm\npolyhedron\nradius\nrationalize\ntriangulate\ntriangulate_faces\nexponential_map\nis_interior_point\nproject\nsample\ntosimplehrep\ntranslate\nconvex_hull\n≈\n==\nisequivalent","category":"page"},{"location":"lib/sets/Ellipsoid/","page":"Ellipsoid","title":"Ellipsoid","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/Ellipsoid/","page":"Ellipsoid","title":"Ellipsoid","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/Ellipsoid/","page":"Ellipsoid","title":"Ellipsoid","text":"Inherited from AbstractCentrallySymmetric:","category":"page"},{"location":"lib/sets/Ellipsoid/","page":"Ellipsoid","title":"Ellipsoid","text":"an_element\ncenter\ndim\nextrema\nextrema\nisbounded\nisboundedtype\nisempty\nisuniversal","category":"page"},{"location":"lib/sets/Universe/#def_Universe","page":"Universe","title":"Universe","text":"","category":"section"},{"location":"lib/sets/Universe/#LazySets.UniverseModule.Universe","page":"Universe","title":"LazySets.UniverseModule.Universe","text":"Universe{N} <: AbstractPolyhedron{N}\n\nType that represents the universal set, i.e., the set of all elements.\n\nFields\n\ndim – the ambient dimension of the set\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Universe/#Operations","page":"Universe","title":"Operations","text":"","category":"section"},{"location":"lib/sets/Universe/#LazySets.API.an_element-Tuple{LazySets.API.LazySet}-lib-sets-Universe","page":"Universe","title":"LazySets.API.an_element","text":"an_element(X::LazySet)\n\nReturn some element of a nonempty set.\n\nInput\n\nX – set\n\nOutput\n\nAn element of X unless X is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#LazySets.API.an_element-Tuple{Universe}","page":"Universe","title":"LazySets.API.an_element","text":"Extended help\n\nan_element(U::Universe)\n\nAlgorithm\n\nThe output is the origin.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#LazySets.constrained_dimensions-Tuple{Universe}","page":"Universe","title":"LazySets.constrained_dimensions","text":"constrained_dimensions(U::Universe)\n\nReturn the indices in which a universe is constrained.\n\nInput\n\nU – universe\n\nOutput\n\nThe empty vector, as the universe is unconstrained in every dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-Universe","page":"Universe","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#Base.rand-Tuple{Type{Universe}}","page":"Universe","title":"Base.rand","text":"Extended help\n\nrand(::Type{Universe}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nOutput\n\nThe (only) universe of the given numeric type and dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-Universe","page":"Universe","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, X::LazySet)\n\nEvaluate the support function of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nThe evaluation of the support function of X in direction d.\n\nNotes\n\nA convenience alias support_function is also available.\n\nWe have the following identity based on the support vector σ:\n\n    ρ(d X) = d  σ(d X)\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#LazySets.API.ρ-Tuple{AbstractVector, Universe}","page":"Universe","title":"LazySets.API.ρ","text":"Extended help\n\nρ(d::AbstractVector, U::Universe)\n\nAlgorithm\n\nIf the direction is all zero, the result is zero. Otherwise, the result is Inf.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-Universe","page":"Universe","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#LazySets.API.σ-Tuple{AbstractVector, Universe}","page":"Universe","title":"LazySets.API.σ","text":"Extended help\n\nσ(d::AbstractVector, U::Universe)\n\nOutput\n\nA vector with infinity values, except in dimensions where the direction is zero.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/","page":"Universe","title":"Universe","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/Universe/","page":"Universe","title":"Universe","text":"area\ncomplement\nconstraints_list\nconstraints\ncopy(::Universe)\ndiameter\ndim\nisbounded\nisboundedtype\nisempty\nisoperationtype\nisuniversal\nnorm\nradius\nrectify\nreflect\ndistance\n∈\npermute\nproject\nrationalize\nscale\nscale!\ntranslate\ntranslate!\ncartesian_product\nconvex_hull\ndistance\nintersection","category":"page"},{"location":"lib/sets/Universe/","page":"Universe","title":"Universe","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Universe/","page":"Universe","title":"Universe","text":"chebyshev_center_radius\nconcretize\nconvex_hull\neltype\neltype\nisoperation\npolyhedron\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\naffine_map\nexponential_map\nis_interior_point\nlinear_map\nsample\n≈\nisdisjoint\n⊆\nminkowski_difference\nexact_sum\n==\nisequivalent\n⊂","category":"page"},{"location":"lib/sets/Universe/","page":"Universe","title":"Universe","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/Universe/","page":"Universe","title":"Universe","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/Universe/","page":"Universe","title":"Universe","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/Universe/","page":"Universe","title":"Universe","text":"extrema\nextrema\nhigh\nhigh\nispolyhedral\nlow\nlow\nvertices_list\nvertices\nminkowski_sum","category":"page"},{"location":"lib/sets/SparsePolynomialZonotope/#def_SparsePolynomialZonotope","page":"SparsePolynomialZonotope","title":"SparsePolynomialZonotope","text":"","category":"section"},{"location":"lib/sets/SparsePolynomialZonotope/#LazySets.SparsePolynomialZonotopeModule.SparsePolynomialZonotope","page":"SparsePolynomialZonotope","title":"LazySets.SparsePolynomialZonotopeModule.SparsePolynomialZonotope","text":"SparsePolynomialZonotope{N, VN<:AbstractVector{N}, MN<:AbstractMatrix{N},\n                         MNI<:AbstractMatrix{N},\n                         ME<:AbstractMatrix{Int},\n                         VI<:AbstractVector{Int}}\n    <: AbstractSparsePolynomialZonotope{N}\n\nType that represents a sparse polynomial zonotope.\n\nA sparse polynomial zonotope mathcalPZ  ℝ^n is represented by the set\n\nmathcalPZ = leftx  ℝ^n  x = c + ᵢ₁ʰleft(ₖ₁ᵖ α_k^E_k i right)Gᵢ+ⱼ₁^qβⱼGIⱼ α_k βⱼ  -1 1  k = 1p j=1q right\n\nwhere c  ℝ^n is the offset vector (or center), Gᵢ  ℝ^n are the dependent generators, GIⱼ  ℝ^n are the independent generators, and E  mathbbN^ph_0 is the exponent matrix with matrix elements E_k i.\n\nIn the implementation, Gᵢ  ℝ^n are arranged as columns of the dependent generator matrix G  ℝ^n  h, and similarly GIⱼ  ℝ^n are arranged as columns of the independent generator matrix GI  ℝ^nq.\n\nThe shorthand notation mathcalPZ =  c G GI E idx  is often used, where idx  mathbbN^p is a list of non-repeated natural numbers storing a unique identifier for each dependent factor αₖ.\n\nFields\n\nc   – offset vector\nG   – dependent generator matrix\nGI  – independent generator matrix\nE   – exponent matrix\nidx – identifier vector of positive integers for the dependent parameters\n\nNotes\n\nSparse polynomial zonotopes were introduced in Kochdumper and Althoff [KA21].\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/SparsePolynomialZonotope/#Operations","page":"SparsePolynomialZonotope","title":"Operations","text":"","category":"section"},{"location":"lib/sets/SparsePolynomialZonotope/#LazySets.expmat-Tuple{SparsePolynomialZonotope}","page":"SparsePolynomialZonotope","title":"LazySets.expmat","text":"expmat(P::SparsePolynomialZonotope)\n\nReturn the matrix of exponents of the sparse polynomial zonotope.\n\nInput\n\nP – sparse polynomial zonotope\n\nOutput\n\nThe matrix of exponents, where each column is a multidegree.\n\nNotes\n\nIn the exponent matrix, each row corresponds to a parameter (αₖ in the definition) and each column to a monomial.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SparsePolynomialZonotope/#LazySets.genmat_dep-Tuple{SparsePolynomialZonotope}","page":"SparsePolynomialZonotope","title":"LazySets.genmat_dep","text":"genmat_dep(P::SparsePolynomialZonotope)\n\nReturn the matrix of dependent generators of a sparse polynomial zonotope.\n\nInput\n\nP – sparse polynomial zonotope\n\nOutput\n\nThe matrix of dependent generators.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SparsePolynomialZonotope/#LazySets.genmat_indep-Tuple{SparsePolynomialZonotope}","page":"SparsePolynomialZonotope","title":"LazySets.genmat_indep","text":"genmat_indep(P::SparsePolynomialZonotope)\n\nReturn the matrix of independent generators of a sparse polynomial zonotope.\n\nInput\n\nP – sparse polynomial zonotope\n\nOutput\n\nThe matrix of independent generators.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SparsePolynomialZonotope/#LazySets.SparsePolynomialZonotopeModule.indexvector-Tuple{SparsePolynomialZonotope}","page":"SparsePolynomialZonotope","title":"LazySets.SparsePolynomialZonotopeModule.indexvector","text":"indexvector(P::SparsePolynomialZonotope)\n\nReturn the index vector of a sparse polynomial zonotope.\n\nInput\n\nP – sparse polynomial zonotope\n\nOutput\n\nThe index vector.\n\nNotes\n\nThe index vector contains positive integers for the dependent parameters.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SparsePolynomialZonotope/#LazySets.polynomial_order-Tuple{SparsePolynomialZonotope}","page":"SparsePolynomialZonotope","title":"LazySets.polynomial_order","text":"polynomial_order(P::SparsePolynomialZonotope)\n\nReturn the polynomial order of a sparse polynomial zonotope.\n\nInput\n\nP – sparse polynomial zonotope\n\nOutput\n\nThe polynomial order.\n\nNotes\n\nThe polynomial order is the maximum sum of all monomials' parameter exponents.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SparsePolynomialZonotope/#Base.rand-Tuple{Type{SparsePolynomialZonotope}}","page":"SparsePolynomialZonotope","title":"Base.rand","text":"rand(::Type{SparsePolynomialZonotope}; [N]::Type{<:Real}=Float64,\n     [dim]::Int=2, [nparams]::Int=2, [maxdeg]::Int=3,\n     [num_dependent_generators]::Int=-1,\n     [num_independent_generators]::Int=-1, [rng]::AbstractRNG=GLOBAL_RNG,\n     [seed]::Union{Int, Nothing}=nothing)\n\nCreate a random sparse polynomial zonotope.\n\nInput\n\nSparsePolynomialZonotope   – type for dispatch\nN                          – (optional, default: Float64) numeric type\ndim                        – (optional, default: 2) dimension\nnparams                    – (optional, default: 2) number of parameters\nmaxdeg                     – (optional, default: 3) maximum degree for each                                 parameter\nnum_dependent_generators   – (optional, default: -1) number of dependent                                 generators (see comment below)\nnum_independent_generators – (optional, default: -1) number of                                 independent generators (see comment below)\nrng                        – (optional, default: GLOBAL_RNG) random                                 number generator\nseed                       – (optional, default: nothing) seed for                                 reseeding\n\nOutput\n\nA random sparse polynomial zonotope.\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1.\n\nThe number of generators can be controlled with the arguments num_dependent_generators and num_dependent_generators. For a negative value we choose a random number in the range dim:2*dim (except if dim == 1, in which case we only create a single generator). Note that the final number of generators may be lower if redundant monomials are generated.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SparsePolynomialZonotope/#LazySets.remove_redundant_generators-Tuple{AbstractZonotope}-lib-sets-SparsePolynomialZonotope","page":"SparsePolynomialZonotope","title":"LazySets.remove_redundant_generators","text":"remove_redundant_generators(Z::AbstractZonotope)\n\nRemove all redundant (pairwise linearly dependent) generators of a zonotopic set.\n\nInput\n\nZ – zonotopic set\n\nOutput\n\nA new zonotope with fewer generators, or the same zonotopic set if no generator could be removed.\n\nAlgorithm\n\nBy default this implementation returns the input zonotopic set. Subtypes of AbstractZonotope whose generators can be removed have to define a new method.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SparsePolynomialZonotope/#LazySets.remove_redundant_generators-Tuple{SparsePolynomialZonotope}","page":"SparsePolynomialZonotope","title":"LazySets.remove_redundant_generators","text":"Extended help\n\nremove_redundant_generators(S::SparsePolynomialZonotope)\n\nNotes\n\nThe result uses dense arrays irrespective of the array type of S.\n\nAlgorithm\n\nLet G be the dependent generator matrix, E the exponent matrix, and GI the independent generator matrix of S. We perform the following simplifications:\n\nRemove zero columns in G and the corresponding columns in E.\nRemove Zero columns in GI.\nFor zero columns in E, add the corresponding column in G to the center.\nGroup repeated columns in E together by summing the corresponding columns in G.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SparsePolynomialZonotope/#LazySets.SparsePolynomialZonotopeModule.uniqueID-Tuple{Int64}","page":"SparsePolynomialZonotope","title":"LazySets.SparsePolynomialZonotopeModule.uniqueID","text":"uniqueID(n::Int)\n\nReturn a collection of n unique identifiers (integers 1, …, n).\n\nInput\n\nn – number of variables\n\nOutput\n\n1:n.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SparsePolynomialZonotope/#LazySets.SparsePolynomialZonotopeModule.merge_id-Union{Tuple{N}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}, AbstractMatrix{N}, AbstractMatrix{N}}} where N<:Integer","page":"SparsePolynomialZonotope","title":"LazySets.SparsePolynomialZonotopeModule.merge_id","text":"merge_id(id1::AbstractVector{Int}, id2::AbstractVector{Int}, \n         E₁::AbstractMatrix{N}, E₂::AbstractMatrix{N}) where {N}\n\nAlign two identifier vectors and their corresponding exponent matrices in compatible form.\n\nInput\n\nid1::AbstractVector{Int} – identifiers corresponding to the rows of E₁\nid2::AbstractVector{Int} – identifiers corresponding to the rows of E₂\nE₁::AbstractMatrix{N} – first exponent matrix of size (p₁ × h₁)\nE₂::AbstractMatrix{N} – second exponent matrix of size (p₂ × h₂)\n\nOutput\n\nĒ₁::Matrix{N}: Aligned version of E₁ \nĒ₂::Matrix{N}: Aligned version of E₂ \nidx::Vector{Int}: Merged identifier vector, containing all elements of id1 and any new ones from id2.\n\nAlgorithm\n\nThis method implements Kochdumper and Althoff [KA21], Proposition 1.\n\nExample\n\njulia> using LazySets.SparsePolynomialZonotopeModule: merge_id\n\njulia> id1 = [1, 2];\n\njulia> E₁ = [1 2; 1 0];\n\njulia> id2 = [2, 3];\n\njulia> E₂ = [1 0 1; 3 2 0];\n\njulia> Ē₁, Ē₂, idx = merge_id(id1, id2, E₁, E₂)\n([1 2; 1 0; 0 0], [0 0 0; 1 0 1; 3 2 0], [1, 2, 3])\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SparsePolynomialZonotope/#LazySets.reduce_order-Tuple{AbstractZonotope, Real}-lib-sets-SparsePolynomialZonotope","page":"SparsePolynomialZonotope","title":"LazySets.reduce_order","text":"reduce_order(Z::AbstractZonotope, r::Real,\n             [method]::AbstractReductionMethod=GIR05())\n\nReduce the order of a zonotopic set by overapproximating with a zonotope with fewer generators.\n\nInput\n\nZ      – zonotopic set\nr      – desired order\nmethod – (optional, default: GIR05()) the reduction method used\n\nOutput\n\nA new zonotope with fewer generators, if possible.\n\nAlgorithm\n\nThe available algorithms are:\n\njulia> subtypes(AbstractReductionMethod)\n4-element Vector{Any}:\n LazySets.ASB10\n LazySets.COMB03\n LazySets.GIR05\n LazySets.SRMB16\n\nSee the documentation of each algorithm for references. Most methods split the given zonotopic set Z into two zonotopes, K and L, where K contains the most \"representative\" generators and L contains the generators that are reduced, Lred, using a box overapproximation. This methodology varies slightly for SRMB16. We follow the notation from Yang and Scott [YS18]. See also Kopetzki et al. [KSA17].\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SparsePolynomialZonotope/#LazySets.reduce_order","page":"SparsePolynomialZonotope","title":"LazySets.reduce_order","text":"Extended help\n\nreduce_order(P::SparsePolynomialZonotope, r::Real,\n             [method]::AbstractReductionMethod=GIR05())\n\nNotes\n\nThis method implements the algorithm described in Kochdumper [Koc22], Proposition 3.1.39.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/SparsePolynomialZonotope/#LazySets.API.exact_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-sets-SparsePolynomialZonotope","page":"SparsePolynomialZonotope","title":"LazySets.API.exact_sum","text":"exact_sum(X::LazySet, Y::LazySet)\n\nCompute the exact sum of two parametric sets.\n\nInput\n\nX – parametric set\nY – parametric set\n\nOutput\n\nA set representing the exact sum, sometimes written X  Y.\n\nNotes\n\nFor parametric sets, the exact sum behaves like the Minkowski sum, except that the parameters are shared. Thus, for nonparametric sets, it coincides with the Minkowski sum.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SparsePolynomialZonotope/#LazySets.API.exact_sum-Tuple{SparsePolynomialZonotope, SparsePolynomialZonotope}","page":"SparsePolynomialZonotope","title":"LazySets.API.exact_sum","text":"Extended help\n\nexact_sum(P1::SparsePolynomialZonotope, P2::SparsePolynomialZonotope)\n\nAlgorithm\n\nThis method implements Kochdumper [Koc22], Proposition 3.1.20.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/SparsePolynomialZonotope/","page":"SparsePolynomialZonotope","title":"SparsePolynomialZonotope","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/SparsePolynomialZonotope/","page":"SparsePolynomialZonotope","title":"SparsePolynomialZonotope","text":"center\nisoperationtype\nscale","category":"page"},{"location":"lib/sets/SparsePolynomialZonotope/","page":"SparsePolynomialZonotope","title":"SparsePolynomialZonotope","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/SparsePolynomialZonotope/","page":"SparsePolynomialZonotope","title":"SparsePolynomialZonotope","text":"an_element\narea\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nextrema\nhigh\nhigh\nisbounded\nisconvextype\nisoperation\nispolyhedral\nlow\nlow\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nproject\nsample\nσ\nconvex_hull\n≈\nisdisjoint\n==\nisequivalent\n⊂\n⊆\nlinear_combination\nminkowski_difference","category":"page"},{"location":"lib/sets/SparsePolynomialZonotope/","page":"SparsePolynomialZonotope","title":"SparsePolynomialZonotope","text":"Inherited from AbstractPolynomialZonotope:","category":"page"},{"location":"lib/sets/SparsePolynomialZonotope/","page":"SparsePolynomialZonotope","title":"SparsePolynomialZonotope","text":"center\ndim\nextrema\nisboundedtype\nisempty\nisuniversal\nngens\norder","category":"page"},{"location":"lib/sets/SparsePolynomialZonotope/","page":"SparsePolynomialZonotope","title":"SparsePolynomialZonotope","text":"Inherited from AbstractSparsePolynomialZonotope:","category":"page"},{"location":"lib/sets/SparsePolynomialZonotope/","page":"SparsePolynomialZonotope","title":"SparsePolynomialZonotope","text":"ngens_dep\nngens_indep\nnparams\nlinear_map\nρ\ntranslate\ncartesian_product\nminkowski_sum","category":"page"},{"location":"lib/concrete_binary_operations/cartesian_product/","page":"Cartesian Product","title":"Cartesian Product","text":"Pages = [\"cartesian_product.md\"]\nDepth = 3","category":"page"},{"location":"lib/concrete_binary_operations/cartesian_product/#Cartesian-Product","page":"Cartesian Product","title":"Cartesian Product","text":"","category":"section"},{"location":"lib/concrete_binary_operations/cartesian_product/#LazySets.API.cartesian_product-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-concrete_binary_operations-cartesian_product","page":"Cartesian Product","title":"LazySets.API.cartesian_product","text":"cartesian_product(X::LazySet, Y::LazySet)\n\nCompute the Cartesian product of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the Cartesian product X  Y.\n\nNotes\n\nThe Cartesian product of two sets X and Y is defined as\n\n    X  Y = x y mid x  X y  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/cartesian_product/#LazySets.API.cartesian_product-Tuple{AbstractSparsePolynomialZonotope, AbstractZonotope}","page":"Cartesian Product","title":"LazySets.API.cartesian_product","text":"Extended help\n\ncartesian_product(SPZ::AbstractSparsePolynomialZonotope, Z::AbstractZonotope)\n\nAlgorithm\n\nThis method implements Kochdumper [Koc22], Proposition 3.1.22.\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/cartesian_product/#LazySets.API.cartesian_product-Tuple{AbstractSparsePolynomialZonotope, AbstractSparsePolynomialZonotope}","page":"Cartesian Product","title":"LazySets.API.cartesian_product","text":"Extended help\n\ncartesian_product(P1::AbstractSparsePolynomialZonotope, P2::AbstractSparsePolynomialZonotope)\n\nAlgorithm\n\nThis method implements Kochdumper [Koc22], Proposition 3.1.22.\n\n\n\n\n\n","category":"method"},{"location":"man/convex_sets/#Introduction-to-Convex-Sets","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"In this section we give a short overview about convex sets supported in this library. Currently we only list the basic convex sets and we refer to this presentation for a short explanation of operations on convex sets and composite set representations that are supported here and that we plan to add in the future.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Pages = [\"convex_sets.md\"]\nDepth = 4","category":"page"},{"location":"man/convex_sets/#Basic-convex-sets","page":"Introduction to Convex Sets","title":"Basic convex sets","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"A set X  ℝ^n is convex if for any two points x, y in X the whole line segment connecting x and y is also contained in X. Formally:","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"    X = λ  x + (1  λ)  y mid x y  X λ  0 1  ℝ","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Below we show an example of a convex set and a non-convex set.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"pentagon = VPolygon([[1., 2.], [2., 1.], [1.5, 0.], [0.5, 0.], [0., 1.]])\n\nplot_raw()  # hide\nplot!(xlims=(0., 2.), ylims=(0., 2.), xticks=[0., 1., 2.],  # hide\n      yticks=[1., 2.], top_margin=3mm)  # hide\nplot1(pentagon, true)  # hide","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"hourglass = UnionSet(VPolygon([[0., 2.], [1., 0.9], [2, 2.]]),\n                     VPolygon([[0., 0.], [1., 1.1], [2, 0.]]))\n\nplot_raw()  # hide\nplot!(xlims=(0., 2.), ylims=(0., 2.), xticks=[0., 1., 2.],  # hide\n      yticks=[1., 2.], top_margin=3mm)  # hide\nplot3(hourglass, true; linecolor=c3)  # hide","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"The set types used in this example will be explained later. As a quick summary, the set type VPolygon represents a convex polygon as the convex hull of a given list of vertices (as opposed to a representation as the intersection of a given list of linear constraints; for that representation see the set type HPolygon). The UnionSet represents the union of two sets.","category":"page"},{"location":"man/convex_sets/#Empty-set","page":"Introduction to Convex Sets","title":"Empty set","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"The simplest convex set is the empty set.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"dimension = 2\nE = EmptySet(dimension)\n\nplot_raw()  # hide\nplot!(xlims=(0., 2.), ylims=(0., 2.), xticks=[0., 1., 2.],  # hide\n      yticks=[1., 2.], top_margin=3mm)  # hide\nplot1(E, true)  # hide","category":"page"},{"location":"man/convex_sets/#Singleton","page":"Introduction to Convex Sets","title":"Singleton","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"The next simplest convex set is the singleton, which consists of a single point.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"S = Singleton([1.0, 1.0])\n\nplot_raw()  # hide\nplot!(S, markercolor=c2, markersize=10, xlims=(0., 2.), ylims=(0., 2.),  # hide\n      xticks=[0., 1., 2.], yticks=[1., 2.], top_margin=3mm)  # hide","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"As a special case, the library also offers a representation of the singleton consisting of the origin.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"dimension = 2\nZ = ZeroSet(dimension)\n\nplot_raw()  # hide\nplot!(Z, markercolor=c2, markersize=10, xlims=(-1., 1.), ylims=(-1., 1.),  # hide\n      xticks=[-1., 0., 1.], yticks=[-1., 0., 1.], top_margin=3mm)  # hide","category":"page"},{"location":"man/convex_sets/#Unit-balls","page":"Introduction to Convex Sets","title":"Unit balls","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Now we consider sets that represent the unit balls in different p-norms.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"     x = (x_1  x_n) _p = sqrt^px_1^p +  + x_n^p","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Formally, a unit ball is the sets of points x with x_p  1.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Balls for p  1 are convex.","category":"page"},{"location":"man/convex_sets/#Infinity-norm","page":"Introduction to Convex Sets","title":"Infinity norm","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"The unit ball in the infinity norm (p = ) is also called hypercube.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Bi = BallInf([0.0, 0.0], 1.0)\n\nplot_raw()  # hide\nplot!(xlims=(-1., 1.), ylims=(-1., 1.), xticks=[-1., 0., 1.],  # hide\n      yticks=[0., 1.], top_margin=3mm)  # hide\nplot1(Bi, true)  # hide","category":"page"},{"location":"man/convex_sets/#Euclidean-norm","page":"Introduction to Convex Sets","title":"Euclidean norm","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"The unit ball in the Euclidean norm (p = 2) is also called hypersphere.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"B2 = Ball2([0.0, 0.0], 1.0)\n\nplot_raw()  # hide\nplot!(xlims=(-1., 1.), ylims=(-1., 1.), xticks=[-1., 0., 1.],  # hide\n      yticks=[0., 1.], top_margin=3mm)  # hide\nplot2(B2, true)  # hide","category":"page"},{"location":"man/convex_sets/#Manhattan-norm","page":"Introduction to Convex Sets","title":"Manhattan norm","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"The unit ball in the Manhattan norm (p = 1) is also called cross-polytope.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"B1 = Ball1([0.0, 0.0], 1.0)\n\nplot_raw()  # hide\nplot!(xlims=(-1., 1.), ylims=(-1., 1.), xticks=[-1., 0., 1.],  # hide\n      yticks=[0., 1.], top_margin=3mm)  # hide\nplot3(B1, true)  # hide","category":"page"},{"location":"man/convex_sets/#More-unit-balls","page":"Introduction to Convex Sets","title":"More unit balls","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Below we show more exotic example of unit balls for p = 3 42 π.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"B3 = Ballp(3., [0.0, 0.0], 1.0)\n\nplot_raw()  # hide\nplot!(xlims=[-1., 1.], ylims=[-1., 1.], xticks=[-1., 0., 1.],  # hide\n      yticks=[0., 1.])  # hide\nplot1(B3, 1e-5, true)  # hide","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"B42 = Ballp(42., [0.0, 0.0], 1.0)\n\nplot_raw()  # hide\nplot!(xlims=[-1., 1.], ylims=[-1., 1.], xticks=[-1., 0., 1.],  # hide\n      yticks=[0., 1.])  # hide\nplot2(B42, 1e-5, true)  # hide","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Bπ = Ballp(π - 2., [0.0, 0.0], 1.0)\n\nplot_raw()  # hide\nplot!(xlims=[-1., 1.], ylims=[-1., 1.], xticks=[-1., 0., 1.],  # hide\n      yticks=[0., 1.])  # hide\nplot3(Bπ, 1e-5, true)  # hide","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Finally, the following example of the unit ball for p = 23 demonstrates that for p  1 the unit balls are not convex.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"(Image: ../assets/ball_two_thirds.png)","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"[Source: Wikimedia]","category":"page"},{"location":"man/convex_sets/#Unbounded-sets","page":"Introduction to Convex Sets","title":"Unbounded sets","text":"","category":"section"},{"location":"man/convex_sets/#Hyperplane","page":"Introduction to Convex Sets","title":"Hyperplane","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"A hyperplane is the generalization of the line (in 2D) and the plane (in 3D). Formally, a hyperplane is parametric in a normal vector a and a constant b and represents the set of points x satisfying a x = b (where  denotes the dot product).","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Hp = Hyperplane([1.0, 1.0], 1.0)\n\nx = [0., 1.]  # hide\ny = [1., 0.]  # hide\narrow_x = [0.5, 0.7]  # hide\narrow_y = [0.5, 0.7]  # hide\nxa = 0.5  # hide\nya = 0.7  # hide\n\nplot_raw()  # hide\nplot!(xlims=(0., 1.0), ylims=(0., 1.0), xticks=[0., 1.], yticks=[1.],  # hide\n      top_margin=3mm)  # hide\nplot_hyperplane!(x, y, c1)  # hide\nplot!(arrow_x, arrow_y, linecolor=c3, arrow=:arrow, linestyle=:dot, width=8)  # hide\nplot!(annotations=(xa, ya, text(L\"a\", 30)))  # hide","category":"page"},{"location":"man/convex_sets/#Half-space","page":"Introduction to Convex Sets","title":"Half-space","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"A half-space is characterized by a hyperplane and represents all points that lie on one side of that hyperplane. Formally, it is the set of points x satisfying a x  b.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Hs = HalfSpace([1.0, 1.0], 1.0)\n\nX = VPolygon([[0., 0.], [1., 0.], [0., 1.]])  # hide\n\nplot_raw()  # hide\nplot!(xlims=(0., 1.0), ylims=(0., 1.0), xticks=[0., 1.], yticks=[1.],  # hide\n      top_margin=3mm)  # hide\nplot2(X, true)  # hide\nplot_hyperplane!(x, y, c2)  # hide\nplot!(arrow_x, arrow_y, linecolor=c3, arrow=:arrow, linestyle=:dot, width=8)  # hide\nplot!(annotations=(xa, ya, text(L\"a\", 30)))  # hide","category":"page"},{"location":"man/convex_sets/#Operations-on-convex-sets","page":"Introduction to Convex Sets","title":"Operations on convex sets","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"To be continued...","category":"page"},{"location":"man/convex_sets/#Composite-convex-sets","page":"Introduction to Convex Sets","title":"Composite convex sets","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"To be continued...","category":"page"},{"location":"lib/interfaces/AbstractPolytope/","page":"Polytopes (AbstractPolytope)","title":"Polytopes (AbstractPolytope)","text":"Pages = [\"AbstractPolytope.md\"]\nDepth = 3","category":"page"},{"location":"lib/interfaces/AbstractPolytope/#def_AbstractPolytope","page":"Polytopes (AbstractPolytope)","title":"Polytopes (AbstractPolytope)","text":"","category":"section"},{"location":"lib/interfaces/AbstractPolytope/","page":"Polytopes (AbstractPolytope)","title":"Polytopes (AbstractPolytope)","text":"A polytope is a bounded set with finitely many vertices (V-representation) resp. facets (H-representation). Note that there is a special interface combination Centrally symmetric polytope.","category":"page"},{"location":"lib/interfaces/AbstractPolytope/#LazySets.AbstractPolytope","page":"Polytopes (AbstractPolytope)","title":"LazySets.AbstractPolytope","text":"AbstractPolytope{N} <: AbstractPolyhedron{N}\n\nAbstract type for compact convex polytopic sets.\n\nNotes\n\nSee HPolytope or VPolytope for standard implementations of this interface.\n\nEvery concrete AbstractPolytope must define the following method:\n\nvertices_list(::AbstractPolytope) – return a list of all vertices\n\njulia> subtypes(AbstractPolytope)\n5-element Vector{Any}:\n AbstractCentrallySymmetricPolytope\n AbstractPolygon\n HPolytope\n Tetrahedron\n VPolytope\n\nA polytope is a bounded polyhedron (see AbstractPolyhedron). Polytopes are compact convex sets with either of the following equivalent properties:\n\nThey are the intersection of a finite number of closed half-spaces.\nThey are the convex hull of finitely many vertices.\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/AbstractPolytope/","page":"Polytopes (AbstractPolytope)","title":"Polytopes (AbstractPolytope)","text":"This interface requires to implement the following function:","category":"page"},{"location":"lib/interfaces/AbstractPolytope/#LazySets.API.vertices_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractPolytope","page":"Polytopes (AbstractPolytope)","title":"LazySets.API.vertices_list","text":"vertices_list(X::LazySet)\n\nCompute a list of vertices of a polytopic set.\n\nInput\n\nX – polytopic set\n\nOutput\n\nA list of the vertices of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolytope/","page":"Polytopes (AbstractPolytope)","title":"Polytopes (AbstractPolytope)","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/AbstractPolytope/#Base.isempty-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractPolytope","page":"Polytopes (AbstractPolytope)","title":"Base.isempty","text":"isempty(X::LazySet, witness::Bool=false)\n\nCheck whether a set is empty.\n\nInput\n\nX       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X = \nIf the witness option is activated:\n(true, []) iff X = \n(false, v) iff X   for some v  X\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolytope/#Base.isempty-Tuple{AbstractPolytope}","page":"Polytopes (AbstractPolytope)","title":"Base.isempty","text":"Extended help\n\nisempty(P::AbstractPolytope)\n\nAlgorithm\n\nThis algorithm checks whether the vertices_list of P is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolytope/#LazySets.API.isuniversal-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractPolytope","page":"Polytopes (AbstractPolytope)","title":"LazySets.API.isuniversal","text":"isuniversal(X::LazySet, witness::Bool=false)\n\nCheck whether a set is universal.\n\nInput\n\nX       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X = ℝ^n\nIf the witness option is activated:\n(true, []) iff X = ℝ^n\n(false, v) iff X  ℝ^n for some v  X\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolytope/#LazySets.API.isuniversal","page":"Polytopes (AbstractPolytope)","title":"LazySets.API.isuniversal","text":"Extended help\n\nisuniversal(P::AbstractPolytope, [witness]::Bool=false)\n\nAlgorithm\n\nA witness is produced using isuniversal(H) where H is the first linear constraint of P.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractPolytope/#LazySets.API.volume-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractPolytope","page":"Polytopes (AbstractPolytope)","title":"LazySets.API.volume","text":"volume(X::LazySet)\n\nCompute the volume, or Lebesgue measure, of a set.\n\nInput\n\nX – set\n\nOutput\n\nA real number representing the Lebesgue measure of X.\n\nNotes\n\nThe Lebesgue measure has the following common special cases:\n\nIn 1D, it coincides with the length.\nIn 2D, it coincides with the area (see also area).\nIn 3D, it coincides with the volume.\n\nIn higher dimensions, it is also known as the hypervolume or simply volume.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolytope/#LazySets.API.volume-Tuple{AbstractPolytope}","page":"Polytopes (AbstractPolytope)","title":"LazySets.API.volume","text":"Extended help\n\nvolume(P::AbstractPolytope; backend=default_polyhedra_backend(P))\n\nInput\n\nbackend – (optional, default: default_polyhedra_backend(P)) the backend              for polyhedral computations; see Polyhedra's              documentation for further              information\n\nAlgorithm\n\nThe volume is computed by the Polyhedra library.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolytope/#Base.:⊆-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-AbstractPolytope","page":"Polytopes (AbstractPolytope)","title":"Base.:⊆","text":"⊆(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nCheck whether a set is a subset of another set, and optionally compute a witness.\n\nInput\n\nX       – set\nY       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X  Y\nIf the witness option is activated:\n(true, []) iff X  Y\n(false, v) iff X  Y for some v  X  Y\n\nNotes\n\nThe convenience alias issubset is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolytope/#Base.:⊆","page":"Polytopes (AbstractPolytope)","title":"Base.:⊆","text":"Extended help\n\n⊆(P::AbstractPolytope, S::LazySet, [witness]::Bool=false;\n  [algorithm]=\"constraints\")\n\nInput\n\nalgorithm – (optional, default: \"constraints\") algorithm for the                inclusion check; available options are:\n\"constraints\", using the list of constraints of S (requires that S is polyhedral) and support-function evaluations of S\n\"vertices\", using the list of vertices of P and membership evaluations of S\n\nNotes\n\nS is assumed to be convex, which is asserted via isconvextype.\n\nAlgorithm\n\n\"vertices\":\n\nSince S is convex, P  S iff v  S for all vertices v of P.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractPolytope/","page":"Polytopes (AbstractPolytope)","title":"Polytopes (AbstractPolytope)","text":"Undocumented implementations:","category":"page"},{"location":"lib/interfaces/AbstractPolytope/","page":"Polytopes (AbstractPolytope)","title":"Polytopes (AbstractPolytope)","text":"isbounded\nisboundedtype\nminkowski_sum","category":"page"},{"location":"lib/interfaces/AbstractPolytope/","page":"Polytopes (AbstractPolytope)","title":"Polytopes (AbstractPolytope)","text":"Inherited from LazySet:","category":"page"},{"location":"lib/interfaces/AbstractPolytope/","page":"Polytopes (AbstractPolytope)","title":"Polytopes (AbstractPolytope)","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nlinear_map\nsample\nscale\nρ\ntranslate\ncartesian_product\nconvex_hull\nexact_sum\n≈\n==\nisequivalent\n⊂\n⊆\nminkowski_difference","category":"page"},{"location":"lib/interfaces/AbstractPolytope/","page":"Polytopes (AbstractPolytope)","title":"Polytopes (AbstractPolytope)","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/interfaces/AbstractPolytope/","page":"Polytopes (AbstractPolytope)","title":"Polytopes (AbstractPolytope)","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/interfaces/AbstractPolytope/","page":"Polytopes (AbstractPolytope)","title":"Polytopes (AbstractPolytope)","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/interfaces/AbstractPolytope/","page":"Polytopes (AbstractPolytope)","title":"Polytopes (AbstractPolytope)","text":"an_element\nextrema\nextrema\nhigh\nhigh\nispolyhedral\nlow\nlow\n∈\nproject\nintersection\nisdisjoint","category":"page"},{"location":"lib/interfaces/AbstractPolytope/","page":"Polytopes (AbstractPolytope)","title":"Polytopes (AbstractPolytope)","text":"Some common functions implemented by several subtypes:","category":"page"},{"location":"lib/interfaces/AbstractPolytope/#LazySets.remove_redundant_vertices-Tuple{AbstractPolytope}","page":"Polytopes (AbstractPolytope)","title":"LazySets.remove_redundant_vertices","text":"remove_redundant_vertices(P::AbstractPolytope)\n\nReturn an equivalent polytope in vertex representation with redundant vertices removed.\n\nInput\n\nP – polytope in vertex representation\n\nOutput\n\nA new polytope with the redundant vertices removed.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolytope/#LazySets.remove_redundant_vertices!-Tuple{AbstractPolytope}","page":"Polytopes (AbstractPolytope)","title":"LazySets.remove_redundant_vertices!","text":"remove_redundant_vertices!(P::AbstractPolytope)\n\nRemove the redundant vertices from a polytope in vertex representation in-place.\n\nInput\n\nP – polytope in vertex representation\n\nOutput\n\nA new polytope with the redundant vertices removed.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolytope/#Implementations","page":"Polytopes (AbstractPolytope)","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/AbstractPolytope/","page":"Polytopes (AbstractPolytope)","title":"Polytopes (AbstractPolytope)","text":"Polytope in constraint representation (HPolytope)\nPolytope in vertex representation (VPolytope)","category":"page"},{"location":"lib/approximations/approximate/","page":"Approximation","title":"Approximation","text":"Pages = [\"approximate.md\"]\nDepth = 3","category":"page"},{"location":"lib/approximations/approximate/#Approximation","page":"Approximation","title":"Approximation","text":"","category":"section"},{"location":"lib/approximations/approximate/#LazySets.Approximations.approximate","page":"Approximation","title":"LazySets.Approximations.approximate","text":"approximate(R::Rectification; apply_convex_hull::Bool=false)\n\nApproximate a rectification of a polytopic set with a convex polytope.\n\nInput\n\nR                 – rectification of a polytopic set\napply_convex_hull – (optional; default: false) option to remove redundant                        vertices\n\nOutput\n\nA polytope in vertex representation (VPolygon in 2D, VPolytope otherwise). There is no guarantee that the result over- or underapproximates R.\n\nAlgorithm\n\nLet X be the set that is rectified. We compute the vertices of X, rectify them, and return the convex hull of the result.\n\nNotes\n\nLet X be the set that is rectified and let p and q be two vertices on a facet of X. Intuitively, an approximation may occur if the line segment connecting these vertices crosses a coordinate hyperplane and if the line segment connecting the rectified vertices has a different angle.\n\nAs a corollary, the approximation is exact for the special cases that the original set is contained in either the positive or negative orthant or is axis-aligned.\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/ResetMap/#def_ResetMap","page":"ResetMap","title":"Reset map (ResetMap)","text":"","category":"section"},{"location":"lib/lazy_operations/ResetMap/#LazySets.ResetMap","page":"ResetMap","title":"LazySets.ResetMap","text":"ResetMap{N, S<:LazySet{N}} <: AbstractAffineMap{N, S}\n\nType that represents a lazy reset map. A reset map is a special case of an affine map A x + b x  X where the linear map A is the identity matrix with zero entries in all reset dimensions, and the translation vector b is zero in all other dimensions.\n\nFields\n\nX      – set\nresets – resets (a mapping from an index to a new value)\n\nNotes\n\nThe reset map preserves convexity: if X is convex, then any reset map of X is convex as well.\n\nExamples\n\njulia> X = BallInf([2.0, 2.0, 2.0], 1.0);\n\njulia> r = Dict(1 => 4.0, 3 => 0.0);\n\njulia> rm = ResetMap(X, r);\n\n\nHere rm modifies the set X such that x1 is reset to 4 and x3 is reset to 0, while x2 is not modified. Hence rm is equivalent to the set VPolytope([[4.0, 1.0, 0.0], [4.0, 3.0, 0.0]]), i.e., an axis-aligned line segment embedded in 3D.\n\nThe corresponding affine map A x + b would be:\n\n    eginpmatrix 0  0  0  0  1  0  0  0  0 ndpmatrix x +\n    eginpmatrix 4  0  0 ndpmatrix\n\nUse the function matrix (resp. vector) to create the matrix A (resp. vector b) corresponding to a given reset map.\n\njulia> matrix(rm)\n3×3 LinearAlgebra.Diagonal{Float64, Vector{Float64}}:\n 0.0   ⋅    ⋅\n  ⋅   1.0   ⋅\n  ⋅    ⋅   0.0\n\njulia> vector(rm)\n3-element SparseArrays.SparseVector{Float64, Int64} with 1 stored entry:\n  [1]  =  4.0\n\nThe application of a ResetMap to a ZeroSet or an EmptySet is simplified automatically.\n\njulia> ResetMap(ZeroSet(3), r)\nSingleton{Float64, SparseArrays.SparseVector{Float64, Int64}}(sparsevec([1], [4.0], 3))\n\njulia> ResetMap(EmptySet(3), r)\n∅(3)\n\nThe (in this case unique) support vector of rm in direction [1, 1, 1] is:\n\njulia> σ(ones(3), rm)\n3-element Vector{Float64}:\n 4.0\n 3.0\n 0.0\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/ResetMap/#LazySets.API.dim-Tuple{ResetMap}","page":"ResetMap","title":"LazySets.API.dim","text":"dim(rm::ResetMap)\n\nReturn the dimension of a reset map.\n\nInput\n\nrm – reset map\n\nOutput\n\nThe ambient dimension of a reset map.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ResetMap/#LazySets.API.ρ-Tuple{AbstractVector, ResetMap}","page":"ResetMap","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, rm::ResetMap)\n\nEvaluate the support function of a reset map.\n\nInput\n\nd  – direction\nrm – reset map\n\nOutput\n\nThe evaluation of the support function in the given direction.\n\nNotes\n\nWe use the usual dot-product definition, but for unbounded sets we redefine the product between 0 and  as 0; Julia returns NaN here.\n\njulia> Inf * 0.0\nNaN\n\nSee the discussion here.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ResetMap/#LazySets.API.σ-Tuple{AbstractVector, ResetMap}","page":"ResetMap","title":"LazySets.API.σ","text":"σ(d::AbstractVector, rm::ResetMap)\n\nReturn a support vector of a reset map.\n\nInput\n\nd  – direction\nrm – reset map\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ResetMap/#LazySets.API.an_element-Tuple{ResetMap}","page":"ResetMap","title":"LazySets.API.an_element","text":"an_element(rm::ResetMap)\n\nReturn some element of a reset map.\n\nInput\n\nrm – reset map\n\nOutput\n\nAn element in the reset map.\n\nAlgorithm\n\nThis method relies on the an_element implementation for the wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ResetMap/#LazySets.matrix-Tuple{ResetMap}","page":"ResetMap","title":"LazySets.matrix","text":"matrix(rm::ResetMap)\n\nReturn the A matrix of the affine map A x + b x  X represented by a reset map.\n\nInput\n\nrm – reset map\n\nOutput\n\nThe (Diagonal) matrix for the affine map A x + b x  X represented by the reset map.\n\nAlgorithm\n\nWe construct the identity matrix and set all entries in the reset dimensions to zero.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ResetMap/#LazySets.vector-Tuple{ResetMap}","page":"ResetMap","title":"LazySets.vector","text":"vector(rm::ResetMap)\n\nReturn the b vector of the affine map A x + b x  X represented by a reset map.\n\nInput\n\nrm – reset map\n\nOutput\n\nThe (sparse) vector for the affine map A x + b x  X represented by the reset map. The vector contains the reset value for all reset dimensions and is zero for all other dimensions.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ResetMap/#LazySets.set-Tuple{ResetMap}","page":"ResetMap","title":"LazySets.set","text":"set(rm::ResetMap)\n\nReturn the set wrapped by a reset map.\n\nInput\n\nrm – reset map\n\nOutput\n\nThe wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ResetMap/#LazySets.API.constraints_list-Tuple{ResetMap}","page":"ResetMap","title":"LazySets.API.constraints_list","text":"constraints_list(rm::ResetMap)\n\nReturn a list of constraints of a polyhedral reset map.\n\nInput\n\nrm – reset map of a polyhedron\n\nOutput\n\nA list of constraints of the reset map.\n\nNotes\n\nWe assume that the underlying set rm.X is a polyhedron, i.e., offers a method constraints_list(X).\n\nAlgorithm\n\nIf the set rm.X is hyperrectangular, we iterate through all dimensions. For each reset we construct the corresponding (flat) constraints, and in the other dimensions we construct the corresponding constraints of the underlying set.\n\nFor more general sets, we fall back to constraints_list of a LinearMap of the A-matrix in the affine-map view of a reset map. Each reset dimension i is projected to zero, expressed by two constraints for each reset dimension. Then it remains to shift these constraints to the new value.\n\nFor instance, if the dimension 5 was reset to 4, then there will be constraints x₅  0 and -x₅  0. We then modify the right-hand side of these constraints to x₅  4 and -x₅  -4, respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ResetMap/","page":"ResetMap","title":"ResetMap","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/ResetMap/","page":"ResetMap","title":"ResetMap","text":"norm\nradius\ndiameter\nsingleton_list\nreflect","category":"page"},{"location":"lib/lazy_operations/ResetMap/","page":"ResetMap","title":"ResetMap","text":"Inherited from AbstractAffineMap:","category":"page"},{"location":"lib/lazy_operations/ResetMap/","page":"ResetMap","title":"ResetMap","text":"isempty\nisbounded\n∈\nvertices_list\nlinear_map","category":"page"},{"location":"lib/interfaces/AbstractZonotope/","page":"Zonotopes (AbstractZonotope)","title":"Zonotopes (AbstractZonotope)","text":"Pages = [\"AbstractZonotope.md\"]\nDepth = 3","category":"page"},{"location":"lib/interfaces/AbstractZonotope/#def_AbstractZonotope","page":"Zonotopes (AbstractZonotope)","title":"Zonotopes (AbstractZonotope)","text":"","category":"section"},{"location":"lib/interfaces/AbstractZonotope/","page":"Zonotopes (AbstractZonotope)","title":"Zonotopes (AbstractZonotope)","text":"A zonotope is a specific centrally symmetric polytope characterized by a center and a collection of generators.","category":"page"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.AbstractZonotope","page":"Zonotopes (AbstractZonotope)","title":"LazySets.AbstractZonotope","text":"AbstractZonotope{N} <: AbstractCentrallySymmetricPolytope{N}\n\nAbstract type for zonotopic sets.\n\nNotes\n\nMathematically, a zonotope is defined as the set\n\nZ = left c + _i=1^p ξ_i g_i ξ_i  -1 1  i = 1 p right\n\nwhere c  ℝ^n is its center and g_i_i=1^p, g_i  ℝ^n, is the set of generators. This characterization defines a zonotope as the finite Minkowski sum of line segments. Zonotopes can be equivalently described as the image of a unit infinity-norm ball in ℝ^n by an affine transformation.\n\nSee Zonotope for a standard implementation of this interface.\n\nEvery concrete AbstractZonotope must define the following functions:\n\ngenerators(::AbstractZonotope) – return an iterator over the generators\ngenmat(::AbstractZonotope) – return a generator matrix\n\nSince the functions genmat and generators can be defined in terms of each other, it is sufficient to only genuinely implement one of them and let the implementation of the other function call the fallback implementation genmat_fallback resp. generators_fallback.\n\nThe subtypes of AbstractZonotope (including abstract interfaces):\n\njulia> subtypes(AbstractZonotope)\n5-element Vector{Any}:\n AbstractHyperrectangle\n HParallelotope\n LineSegment\n Zonotope\n ZonotopeMD\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/AbstractZonotope/","page":"Zonotopes (AbstractZonotope)","title":"Zonotopes (AbstractZonotope)","text":"This interface requires to implement the following functions:","category":"page"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.generators-Tuple{AbstractZonotope}","page":"Zonotopes (AbstractZonotope)","title":"LazySets.generators","text":"generators(Z::AbstractZonotope)\n\nReturn an iterator over the generators of a zonotopic set.\n\nInput\n\nZ – zonotopic set\n\nOutput\n\nAn iterator over the generators of Z.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.genmat-Tuple{AbstractZonotope}","page":"Zonotopes (AbstractZonotope)","title":"LazySets.genmat","text":"genmat(Z::AbstractZonotope)\n\nReturn a generator matrix of a zonotopic set.\n\nInput\n\nZ – zonotopic set\n\nOutput\n\nA generator matrix of Z.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/","page":"Zonotopes (AbstractZonotope)","title":"Zonotopes (AbstractZonotope)","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractZonotope","page":"Zonotopes (AbstractZonotope)","title":"LazySets.API.constraints_list","text":"constraints_list(X::LazySet)\n\nCompute a list of linear constraints of a polyhedral set.\n\nInput\n\nX – polyhedral set\n\nOutput\n\nA list of the linear constraints of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.API.constraints_list-Tuple{AbstractZonotope}","page":"Zonotopes (AbstractZonotope)","title":"LazySets.API.constraints_list","text":"Extended help\n\nconstraints_list(P::AbstractZonotope)\n\nAlgorithm\n\nThis is the (inefficient) fallback implementation for rational numbers. It first computes the vertices and then converts the corresponding polytope to constraint representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.API.constraints_list-Tuple{AbstractZonotope{<:AbstractFloat}}","page":"Zonotopes (AbstractZonotope)","title":"LazySets.API.constraints_list","text":"Extended help\n\nconstraints_list(Z::AbstractZonotope{<:AbstractFloat})\n\nNotes\n\nThe main algorithm assumes that the generator matrix is full rank. The result has 2 binompn-1 (with p being the number of generators and n being the ambient dimension) constraints, which is optimal under this assumption. If this assumption is not given, the implementation tries to work around.\n\nAlgorithm\n\nWe follow the algorithm presented in Althoff et al. [ASB10]. Three cases are not covered by that algorithm, so we handle them separately. The first case is zonotopes in one dimension. The second case is that there are fewer generators than dimensions, p  n, or the generator matrix is not full rank, in which case we fall back to the (slower) computation based on the vertex representation. The third case is that the zonotope is flat in some dimensions, in which case we project the zonotope to the non-flat dimensions and extend the result later.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.ngens-Tuple{AbstractZonotope}","page":"Zonotopes (AbstractZonotope)","title":"LazySets.ngens","text":"ngens(Z::AbstractZonotope)\n\nReturn the number of generators of a zonotopic set.\n\nInput\n\nZ – zonotopic set\n\nOutput\n\nAn integer representing the number of generators.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.order-Tuple{AbstractZonotope}","page":"Zonotopes (AbstractZonotope)","title":"LazySets.order","text":"order(Z::AbstractZonotope)\n\nReturn the order of a zonotopic set.\n\nInput\n\nZ – zonotopic set\n\nOutput\n\nA rational number representing the order of the zonotopic set.\n\nNotes\n\nThe order of a zonotopic set is defined as the quotient of its number of generators and its dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.API.reflect-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractZonotope","page":"Zonotopes (AbstractZonotope)","title":"LazySets.API.reflect","text":"reflect(X::LazySet)\n\nCompute the reflection of a set in the origin.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the reflection -X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.API.reflect-Tuple{AbstractZonotope}","page":"Zonotopes (AbstractZonotope)","title":"LazySets.API.reflect","text":"Extended help\n\nreflect(Z::AbstractZonotope)\n\nAlgorithm\n\nIf Z has center c and generator matrix G, then -Z has center -c and generator matrix G. For the latter, observe that G and -G behave the same way.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.remove_redundant_generators-Tuple{AbstractZonotope}","page":"Zonotopes (AbstractZonotope)","title":"LazySets.remove_redundant_generators","text":"remove_redundant_generators(Z::AbstractZonotope)\n\nRemove all redundant (pairwise linearly dependent) generators of a zonotopic set.\n\nInput\n\nZ – zonotopic set\n\nOutput\n\nA new zonotope with fewer generators, or the same zonotopic set if no generator could be removed.\n\nAlgorithm\n\nBy default this implementation returns the input zonotopic set. Subtypes of AbstractZonotope whose generators can be removed have to define a new method.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.togrep-Tuple{AbstractZonotope}","page":"Zonotopes (AbstractZonotope)","title":"LazySets.togrep","text":"togrep(Z::AbstractZonotope)\n\nReturn a generator representation of a zonotopic set.\n\nInput\n\nZ – zonotopic set\n\nOutput\n\nThe same set in generator representation. This fallback implementation returns a Zonotope; however, more specific implementations may return other generator representations.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.API.vertices_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractZonotope","page":"Zonotopes (AbstractZonotope)","title":"LazySets.API.vertices_list","text":"vertices_list(X::LazySet)\n\nCompute a list of vertices of a polytopic set.\n\nInput\n\nX – polytopic set\n\nOutput\n\nA list of the vertices of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.API.vertices_list-Tuple{AbstractZonotope}","page":"Zonotopes (AbstractZonotope)","title":"LazySets.API.vertices_list","text":"Extended help\n\nvertices_list(Z::AbstractZonotope; [apply_convex_hull]::Bool=true)\n\nInput\n\napply_convex_hull – (optional, default: true) if true, post-process the                        computation with the convex hull of the points\n\nAlgorithm\n\nTwo-dimensional case\n\nWe use a trick to speed up enumerating vertices of 2-dimensional zonotopic sets with all generators in the first quadrant or third quadrant (same sign). Namely, sort the generators by angle and add them clockwise in increasing order and counterclockwise in decreasing order. A more detailed explanation can be found here.\n\nTo avoid the cumulative sum from both directions separately, we build a 2D index matrix to sum generators for both directions in one matrix-vector product.\n\nGeneral case\n\nIf the zonotopic set has p generators, each vertex is the result of summing the center with some linear combination of generators, where the combination factors are ξ_i  -1 1.\n\nThere are at most 2^p distinct vertices. Use the flag apply_convex_hull to control whether a convex-hull algorithm is applied to the vertices computed by this method; otherwise, redundant vertices may be present.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope","page":"Zonotopes (AbstractZonotope)","title":"Base.:∈","text":"∈(x::AbstractVector, X::LazySet)\n\nCheck whether a point lies in a set.\n\nInput\n\nx – point/vector\nX – set\n\nOutput\n\ntrue iff x  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#Base.:∈-Tuple{AbstractVector, AbstractZonotope}","page":"Zonotopes (AbstractZonotope)","title":"Base.:∈","text":"Extended help\n\n∈(x::AbstractVector, Z::AbstractZonotope; solver=nothing)\n\nInput\n\nsolver – (optional, default: nothing) the backend used to solve the             linear program\n\nExamples\n\njulia> Z = Zonotope([1.0, 0.0], [0.1 0.0; 0.0 0.1]);\n\njulia> [1.0, 0.2] ∈ Z\nfalse\njulia> [1.0, 0.1] ∈ Z\ntrue\n\nNotes\n\nIf solver == nothing, we fall back to default_lp_solver(N).\n\nAlgorithm\n\nThe membership problem is reduced to the following linear program. Let p and n be the number of generators and ambient dimension, respectively. We consider the p-dimensional space of elements (ξ_1  ξ_p) constrained to ξ_i  -1 1 for all i = 1  p such that x-c = Gξ holds.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.API.linear_map-Tuple{AbstractMatrix, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope","page":"Zonotopes (AbstractZonotope)","title":"LazySets.API.linear_map","text":"linear_map(M::AbstractMatrix, X::LazySet)\n\nCompute the linear map M  X.\n\nInput\n\nM – matrix\nX – set\n\nOutput\n\nA set representing the linear map M  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.API.linear_map-Tuple{AbstractMatrix, AbstractZonotope}","page":"Zonotopes (AbstractZonotope)","title":"LazySets.API.linear_map","text":"Extended help\n\nlinear_map(M::AbstractMatrix, Z::AbstractZonotope)\n\nOutput\n\nA Zonotope.\n\nAlgorithm\n\nWe apply the linear map to the center and the generators.\n\nIf the map has outpu dimension 1, a specialized algorithm ensures that the resulting zonotope only has a single generator.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.reduce_order","page":"Zonotopes (AbstractZonotope)","title":"LazySets.reduce_order","text":"reduce_order(Z::AbstractZonotope, r::Real,\n             [method]::AbstractReductionMethod=GIR05())\n\nReduce the order of a zonotopic set by overapproximating with a zonotope with fewer generators.\n\nInput\n\nZ      – zonotopic set\nr      – desired order\nmethod – (optional, default: GIR05()) the reduction method used\n\nOutput\n\nA new zonotope with fewer generators, if possible.\n\nAlgorithm\n\nThe available algorithms are:\n\njulia> subtypes(AbstractReductionMethod)\n4-element Vector{Any}:\n LazySets.ASB10\n LazySets.COMB03\n LazySets.GIR05\n LazySets.SRMB16\n\nSee the documentation of each algorithm for references. Most methods split the given zonotopic set Z into two zonotopes, K and L, where K contains the most \"representative\" generators and L contains the generators that are reduced, Lred, using a box overapproximation. This methodology varies slightly for SRMB16. We follow the notation from Yang and Scott [YS18]. See also Kopetzki et al. [KSA17].\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractZonotope/#Base.split-Tuple{AbstractZonotope, Int64}","page":"Zonotopes (AbstractZonotope)","title":"Base.split","text":"split(Z::AbstractZonotope, j::Int)\n\nReturn two zonotopes obtained by splitting the given zonotopic set.\n\nInput\n\nZ – zonotopic set\nj – index of the generator to be split\n\nOutput\n\nThe zonotope obtained by splitting Z into two zonotopes such that their union is Z and their intersection is possibly non-empty.\n\nAlgorithm\n\nThis function implements Althoff et al. [ASB08], Prop. 3, which we state next. The zonotopic set Z = c g^(1  p) is split into:\n\nZ₁ = c - frac12g^(j) (g^(1 j-1) frac12g^(j) g^(j+1  p)) \nZ₂ = c + frac12g^(j) (g^(1 j-1) frac12g^(j) g^(j+1  p))\n\nsuch that Z₁  Z₂ = Z and Z₁  Z₂ = Z^*, where\n\nZ^* = c (g^(1j-1) g^(j+1 p))\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#Base.split-Tuple{AbstractZonotope, AbstractVector{Int64}, AbstractVector{Int64}}","page":"Zonotopes (AbstractZonotope)","title":"Base.split","text":"split(Z::AbstractZonotope, gens::AbstractVector{Int},\n      nparts::AbstractVector{Int})\n\nSplit a zonotopic set along the given generators into a vector of zonotopes.\n\nInput\n\nZ    – zonotopic set\ngens – vector of indices of the generators to be split\nn    – vector of integers describing the number of partitions in the           corresponding generator\n\nOutput\n\nThe zonotopes obtained by splitting Z into 2^{n_i} zonotopes for each generator i such that their union is Z and their intersection is possibly non-empty.\n\nExamples\n\nSplitting of a two-dimensional zonotopic set along its first generator:\n\njulia> Z = Zonotope([1.0, 0.0], [0.1 0.0; 0.0 0.1])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.0, 0.0], [0.1 0.0; 0.0 0.1])\n\njulia> split(Z, [1], [1])\n2-element Vector{Zonotope{Float64, Vector{Float64}, Matrix{Float64}}}:\n Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.95, 0.0], [0.05 0.0; 0.0 0.1])\n Zonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.05, 0.0], [0.05 0.0; 0.0 0.1])\n\nHere, the first vector in the arguments corresponds to the zonotopic set's generator to be split, and the second vector corresponds to the exponent of 2^n parts that the set will be split into along the corresponding generator.\n\nAs an example, below we split a two-dimensional zonotope along both of its generators, each time into four parts.\n\njulia> Z = Zonotope([1.0, 0.0], [0.1 0.0; 0.0 0.1])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.0, 0.0], [0.1 0.0; 0.0 0.1])\n\njulia> split(Z, [1, 2], [2, 2])\n16-element Vector{Zonotope{Float64, Vector{Float64}, Matrix{Float64}}}:\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.925, -0.075], [0.025 0.0; 0.0 0.025])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.925, -0.025], [0.025 0.0; 0.0 0.025])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.925, 0.025], [0.025 0.0; 0.0 0.025])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.925, 0.075], [0.025 0.0; 0.0 0.025])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.975, -0.075], [0.025 0.0; 0.0 0.025])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.975, -0.025], [0.025 0.0; 0.0 0.025])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.975, 0.025], [0.025 0.0; 0.0 0.025])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([0.975, 0.075], [0.025 0.0; 0.0 0.025])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.025, -0.075], [0.025 0.0; 0.0 0.025])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.025, -0.025], [0.025 0.0; 0.0 0.025])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.025, 0.025], [0.025 0.0; 0.0 0.025])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.025, 0.075], [0.025 0.0; 0.0 0.025])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.075, -0.075], [0.025 0.0; 0.0 0.025])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.075, -0.025], [0.025 0.0; 0.0 0.025])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.075, 0.025], [0.025 0.0; 0.0 0.025])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.075, 0.075], [0.025 0.0; 0.0 0.025])\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope","page":"Zonotopes (AbstractZonotope)","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, X::LazySet)\n\nEvaluate the support function of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nThe evaluation of the support function of X in direction d.\n\nNotes\n\nA convenience alias support_function is also available.\n\nWe have the following identity based on the support vector σ:\n\n    ρ(d X) = d  σ(d X)\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.API.ρ-Tuple{AbstractVector, AbstractZonotope}","page":"Zonotopes (AbstractZonotope)","title":"LazySets.API.ρ","text":"Extended help\n\nρ(d::AbstractVector, Z::AbstractZonotope)\n\nAlgorithm\n\nThe support value is cᵀ d + Gᵀ d₁, where c is the center and G is the generator matrix of Z.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope","page":"Zonotopes (AbstractZonotope)","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.API.σ-Tuple{AbstractVector, AbstractZonotope}","page":"Zonotopes (AbstractZonotope)","title":"LazySets.API.σ","text":"Extended help\n\nσ(d::AbstractVector, Z::AbstractZonotope)\n\nNotes\n\nIf the direction has norm zero, the vertex with ξ_i = 1    i = 1 p is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#Base.isdisjoint-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope","page":"Zonotopes (AbstractZonotope)","title":"Base.isdisjoint","text":"isdisjoint(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nCheck whether two sets are disjoint (i.e., do not intersect), and optionally compute a witness.\n\nInput\n\nX       – set\nY       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X  Y = \nIf the witness option is activated:\n(true, []) iff X  Y = \n(false, v) iff X  Y   for some v  X  Y\n\nNotes\n\nThe convenience alias is_intersection_empty is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#Base.isdisjoint","page":"Zonotopes (AbstractZonotope)","title":"Base.isdisjoint","text":"Extended help\n\nisdisjoint(Z1::AbstractZonotope, Z2::AbstractZonotope,\n           [witness]::Bool=false; [solver]=nothing)\n\nInput\n\nsolver  – (optional, default: nothing) the backend used to solve the              linear program\n\nAlgorithm\n\nThe algorithm is taken from Guibas et al. [GNZ03].\n\nZ1  Z2 =  iff c_1 - c_2  Z(0 (g_1 g_2)) where c_i and g_i are the center and generators of zonotope Zi and Z(c g) represents the zonotope with center c and generators g.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.API.minkowski_difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope","page":"Zonotopes (AbstractZonotope)","title":"LazySets.API.minkowski_difference","text":"minkowski_difference(X::LazySet, Y::LazySet)\n\nCompute the Minkowski difference of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the Minkowski difference X  Y.\n\nNotes\n\nThe Minkowski difference of two sets X and Y is defined as\n\n    X  Y = z mid z  Y  X\n\nThe convenience alias pontryagin_difference is also available.\n\nThere is some inconsistency in the literature regarding the naming conventions. In this library, both Minkowski difference and Pontryagin difference refer to the geometric difference of two sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.API.minkowski_difference-Tuple{AbstractZonotope, AbstractZonotope}","page":"Zonotopes (AbstractZonotope)","title":"LazySets.API.minkowski_difference","text":"Extended help\n\nminkowski_difference(Z1::AbstractZonotope, Z2::AbstractZonotope)\n\nOutput\n\nAn HPolytope.\n\nAlgorithm\n\nFor one-dimensional sets, this method implements a simple algorithm for intervals. For two-dimensional sets, this method implements Althoff [Alt15], Proposition 6. For higher-dimensional sets, this method implements Althoff [Alt15], Theorem 3.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.API.minkowski_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-AbstractZonotope","page":"Zonotopes (AbstractZonotope)","title":"LazySets.API.minkowski_sum","text":"minkowski_sum(X::LazySet, Y::LazySet)\n\nCompute the Minkowski sum of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the Minkowski sum X  Y.\n\nNotes\n\nThe Minkowski sum of two sets X and Y is defined as\n\n    X  Y = x + y mid x  X y  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.API.minkowski_sum-Tuple{AbstractZonotope, AbstractZonotope}","page":"Zonotopes (AbstractZonotope)","title":"LazySets.API.minkowski_sum","text":"Extended help\n\nminkowski_sum(Z1::AbstractZonotope, Z2::AbstractZonotope)\n\nAlgorithm\n\nThe resulting zonotope is obtained by summing up the centers and concatenating the generators of Z1 and Z2.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/","page":"Zonotopes (AbstractZonotope)","title":"Zonotopes (AbstractZonotope)","text":"Undocumented implementations:","category":"page"},{"location":"lib/interfaces/AbstractZonotope/","page":"Zonotopes (AbstractZonotope)","title":"Zonotopes (AbstractZonotope)","text":"project\ncartesian_product","category":"page"},{"location":"lib/interfaces/AbstractZonotope/","page":"Zonotopes (AbstractZonotope)","title":"Zonotopes (AbstractZonotope)","text":"Inherited from LazySet:","category":"page"},{"location":"lib/interfaces/AbstractZonotope/","page":"Zonotopes (AbstractZonotope)","title":"Zonotopes (AbstractZonotope)","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nsample\nscale\ntranslate\nconvex_hull\nexact_sum\n≈\n==\nisequivalent\n⊂","category":"page"},{"location":"lib/interfaces/AbstractZonotope/","page":"Zonotopes (AbstractZonotope)","title":"Zonotopes (AbstractZonotope)","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/interfaces/AbstractZonotope/","page":"Zonotopes (AbstractZonotope)","title":"Zonotopes (AbstractZonotope)","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/interfaces/AbstractZonotope/","page":"Zonotopes (AbstractZonotope)","title":"Zonotopes (AbstractZonotope)","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/interfaces/AbstractZonotope/","page":"Zonotopes (AbstractZonotope)","title":"Zonotopes (AbstractZonotope)","text":"high\nhigh\nispolyhedral\nlow\nlow\nintersection","category":"page"},{"location":"lib/interfaces/AbstractZonotope/","page":"Zonotopes (AbstractZonotope)","title":"Zonotopes (AbstractZonotope)","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/interfaces/AbstractZonotope/","page":"Zonotopes (AbstractZonotope)","title":"Zonotopes (AbstractZonotope)","text":"isbounded\nisboundedtype\nvolume\n⊆","category":"page"},{"location":"lib/interfaces/AbstractZonotope/","page":"Zonotopes (AbstractZonotope)","title":"Zonotopes (AbstractZonotope)","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/interfaces/AbstractZonotope/","page":"Zonotopes (AbstractZonotope)","title":"Zonotopes (AbstractZonotope)","text":"an_element\ncenter\ndim\nextrema\nextrema\nisempty\nisuniversal","category":"page"},{"location":"lib/interfaces/AbstractZonotope/#Internal-methods","page":"Zonotopes (AbstractZonotope)","title":"Internal methods","text":"","category":"section"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.generators_fallback-Tuple{AbstractZonotope}","page":"Zonotopes (AbstractZonotope)","title":"LazySets.generators_fallback","text":"generators_fallback(Z::AbstractZonotope)\n\nFallback definition of generators for zonotopic sets.\n\nInput\n\nZ – zonotopic set\n\nOutput\n\nAn iterator over the generators of Z.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.genmat_fallback-Tuple{AbstractZonotope}","page":"Zonotopes (AbstractZonotope)","title":"LazySets.genmat_fallback","text":"genmat_fallback(Z::AbstractZonotope; [gens]=generators(Z), [ngens]=nothing)\n\nFallback definition of genmat for zonotopic sets.\n\nInput\n\nZ     – zonotopic set\ngens  – (optional; default: generators(Z)) iterator over generators\nngens – (optional; default: nothing) number of generators or nothing if            unknown\n\nOutput\n\nA matrix where each column represents one generator of Z.\n\nNotes\n\nPassing the number of generators (ngens) is more efficient, since otherwise the generators have to be obtained from the iterator (gens) and stored in an intermediate vector until the final result matrix can be allocated.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractZonotope/#Order-reduction-methods","page":"Zonotopes (AbstractZonotope)","title":"Order-reduction methods","text":"","category":"section"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.AbstractReductionMethod","page":"Zonotopes (AbstractZonotope)","title":"LazySets.AbstractReductionMethod","text":"AbstractReductionMethod\n\nAbstract supertype for order-reduction methods of a zonotopic set.\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.ASB10","page":"Zonotopes (AbstractZonotope)","title":"LazySets.ASB10","text":"ASB10 <: AbstractReductionMethod\n\nZonotope order-reduction method from Althoff et al. [ASB10].\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.COMB03","page":"Zonotopes (AbstractZonotope)","title":"LazySets.COMB03","text":"COMB03 <: AbstractReductionMethod\n\nZonotope order-reduction method from Combastel [Com03].\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.GIR05","page":"Zonotopes (AbstractZonotope)","title":"LazySets.GIR05","text":"GIR05 <: AbstractReductionMethod\n\nZonotope order-reduction method from Girard [Gir05].\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/AbstractZonotope/#LazySets.SRMB16","page":"Zonotopes (AbstractZonotope)","title":"LazySets.SRMB16","text":"SRMB16 <: AbstractReductionMethod\n\nZonotope order-reduction method from Scott et al. [SRMB16].\n\nFields\n\nϵ – (optional; default: 1e-6) pivot threshold\nδ – (optional; default: 1e-3) volume threshold\n\nNotes\n\nThe method reorders the generator matrix using reduced row echelon form (rref) to the form T  V, then iteratively removes one generator from V while updating T.\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/AbstractZonotope/#Implementations","page":"Zonotopes (AbstractZonotope)","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/AbstractZonotope/","page":"Zonotopes (AbstractZonotope)","title":"Zonotopes (AbstractZonotope)","text":"Zonotope\nLine segment (LineSegment)","category":"page"},{"location":"lib/approximations/template_directions/","page":"Template directions","title":"Template directions","text":"Pages = [\"template_directions.md\"]\nDepth = 3","category":"page"},{"location":"lib/approximations/template_directions/#Template-directions","page":"Template directions","title":"Template directions","text":"","category":"section"},{"location":"lib/approximations/template_directions/","page":"Template directions","title":"Template directions","text":"See also overapproximate(X::LazySet, dir::AbstractDirections).","category":"page"},{"location":"lib/approximations/template_directions/#LazySets.Approximations.AbstractDirections","page":"Template directions","title":"LazySets.Approximations.AbstractDirections","text":"AbstractDirections{N, VN}\n\nAbstract type for representations of direction vectors.\n\nNotes\n\nThis type is parameterized by N and VN, where:\n\nN stands for the numeric type\nVN stands for the vector type with coefficients of type N\n\nEach implementing subtype is an iterator over a set of directions. For that they implement the standard iterator methods from Base, namely Base.length (returns the number of directions) and Base.iterate. Moreover, the following methods should be implemented:\n\ndim    – return the ambient dimension of the vectors\neltype – return the type of each vector\n\nOptionally, subtypes may implement:\n\nisbounding   – (defaults to false) return true if an overapproximation                   with the direction vectors results in a bounded set, given a                   bounded input set, and false otherwise\nisnormalized – (defaults to false) is true if each direction vector has                   norm one w.r.t. the usual vector 2-norm\n\n\n\n\n\n","category":"type"},{"location":"lib/approximations/template_directions/#LazySets.Approximations.isbounding","page":"Template directions","title":"LazySets.Approximations.isbounding","text":"isbounding(ad::AbstractDirections)\nisbounding(ad::Type{<:AbstractDirections})\n\nCheck whether an overapproximation with a set of direction vectors results in a bounded set, given a bounded input set.\n\nInput\n\nad – direction vectors or a subtype of AbstractDirections\n\nOutput\n\nGiven a bounded set X, we can construct an outer polyhedral approximation of X by using the direction vectors ad as normal vectors of the facets. If this function returns true, then the result is again guaranteed to be a bounded set (i.e., a polytope). Note that the result does not depend on the specific shape of X, as long as X is bounded.\n\nNotes\n\nBy default, this function returns false in order to be conservative. Custom subtypes of AbstractDirections should hence add a method for this function.\n\nThe function can be applied to an instance of an AbstractDirections subtype or to the subtype itself. By default, the check on the instance falls back to the check on the subtype.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/template_directions/#LazySets.Approximations.isnormalized","page":"Template directions","title":"LazySets.Approximations.isnormalized","text":"isnormalized(ad::AbstractDirections)\nisnormalized(ad::Type{<:AbstractDirections})\n\nCheck whether the given direction vectors are normalized with respect to the 2-norm.\n\nInput\n\nad – direction vectors or a subtype of AbstractDirections\n\nOutput\n\ntrue if the 2-norm of each element in ad is one and false otherwise.\n\nNotes\n\nBy default, this function returns false in order to be conservative. Custom subtypes of AbstractDirections should hence add a method for this function.\n\nThe function can be applied to an instance of an AbstractDirections subtype or to the subtype itself. By default, the check on the instance falls back to the check on the subtype.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/template_directions/#LazySets.API.project-Tuple{LazySet, AbstractVector{Int64}, Type{<:LazySets.Approximations.AbstractDirections}}","page":"Template directions","title":"LazySets.API.project","text":"project(S::LazySet,\n        block::AbstractVector{Int},\n        directions::Type{<:AbstractDirections},\n        [n]::Int;\n        [kwargs...]\n       )\n\nProject a high-dimensional set to a given block using direction vectors.\n\nInput\n\nS          – set\nblock      – block structure - a vector with the dimensions of interest\ndirections – direction vectors\nn          – (optional, default: dim(S)) ambient dimension of the set S\n\nOutput\n\nThe polyhedral overapproximation of the projection of S in the given directions.\n\n\n\n\n\n","category":"method"},{"location":"lib/approximations/template_directions/#LazySets.Approximations.BoxDirections","page":"Template directions","title":"LazySets.Approximations.BoxDirections","text":"BoxDirections{N, VN} <: AbstractDirections{N, VN}\n\nBox directions representation.\n\nFields\n\nn – dimension\n\nNotes\n\nBox directions can be seen as the vectors where only one entry is ±1, and all other entries are 0. In dimension n, there are 2n such directions.\n\nThe default vector representation used in this template is a ReachabilityBase.Arrays.SingleEntryVector, although other implementations can be used such as a regular Vector and a SparseVector.\n\nExamples\n\nThe template can be constructed by passing the dimension. For example, in dimension two:\n\njulia> dirs = BoxDirections(2)\nBoxDirections{Float64, ReachabilityBase.Arrays.SingleEntryVector{Float64}}(2)\n\njulia> length(dirs)\n4\n\nBy default, each direction is represented as a SingleEntryVector, i.e., a vector with only one non-zero element,\n\njulia> eltype(dirs)\nReachabilityBase.Arrays.SingleEntryVector{Float64}\n\nIn two dimensions, the directions defined by BoxDirections are normal to the facets of a box.\n\njulia> collect(dirs)\n4-element Vector{ReachabilityBase.Arrays.SingleEntryVector{Float64}}:\n [1.0, 0.0]\n [0.0, 1.0]\n [0.0, -1.0]\n [-1.0, 0.0]\n\nThe numeric type can be specified as well:\n\njulia> dirs = BoxDirections{Rational{Int}}(10)\nBoxDirections{Rational{Int64}, ReachabilityBase.Arrays.SingleEntryVector{Rational{Int64}}}(10)\n\njulia> length(dirs)\n20\n\n\n\n\n\n","category":"type"},{"location":"lib/approximations/template_directions/#LazySets.Approximations.DiagDirections","page":"Template directions","title":"LazySets.Approximations.DiagDirections","text":"DiagDirections{N, VN} <: AbstractDirections{N, VN}\n\nDiagonal directions representation.\n\nFields\n\nn – dimension\n\nNotes\n\nDiagonal directions are vectors where all entries are ±1. In dimension n, there are in total 2^n such directions.\n\nExamples\n\nThe template can be constructed by passing the dimension. For example, in dimension two:\n\njulia> dirs = DiagDirections(2)\nDiagDirections{Float64, Vector{Float64}}(2)\n\njulia> length(dirs) # number of directions\n4\n\nBy default, each direction is represented as a regular Vector:\n\njulia> eltype(dirs)\nVector{Float64} (alias for Array{Float64, 1})\n\nIn two dimensions, the directions defined by DiagDirections are normal to the facets of a ball in the 1-norm.\n\njulia> collect(dirs)\n4-element Vector{Vector{Float64}}:\n [1.0, 1.0]\n [-1.0, 1.0]\n [1.0, -1.0]\n [-1.0, -1.0]\n\nThe numeric type can be specified as well:\n\njulia> dirs = DiagDirections{Rational{Int}}(10)\nDiagDirections{Rational{Int64}, Vector{Rational{Int64}}}(10)\n\njulia> length(dirs)\n1024\n\n\n\n\n\n","category":"type"},{"location":"lib/approximations/template_directions/#LazySets.Approximations.OctDirections","page":"Template directions","title":"LazySets.Approximations.OctDirections","text":"OctDirections{N, VN} <: AbstractDirections{N, VN}\n\nOctagon directions representation.\n\nFields\n\nn – dimension\n\nNotes\n\nOctagon directions consist of all vectors that are zero almost everywhere except in two dimensions i, j (possibly i = j) where it is 1. In dimension n, there are 2n^2 such directions.\n\nExamples\n\nThe template can be constructed by passing the dimension. For example, in dimension two:\n\njulia> dirs = OctDirections(2)\nOctDirections{Float64, SparseArrays.SparseVector{Float64, Int64}}(2)\n\njulia> length(dirs) # number of directions\n8\n\nBy default, the directions are represented as sparse vectors:\n\njulia> eltype(dirs)\nSparseArrays.SparseVector{Float64, Int64}\n\nIn two dimensions, the directions are normal to the facets of an octagon.\n\njulia> first(dirs)\n2-element SparseArrays.SparseVector{Float64, Int64} with 2 stored entries:\n  [1]  =  1.0\n  [2]  =  1.0\n\njulia> Vector.(collect(dirs))\n8-element Vector{Vector{Float64}}:\n [1.0, 1.0]\n [1.0, -1.0]\n [-1.0, 1.0]\n [-1.0, -1.0]\n [1.0, 0.0]\n [0.0, 1.0]\n [0.0, -1.0]\n [-1.0, 0.0]\n\nThe numeric type can be specified as well:\n\njulia> dirs = OctDirections{Rational{Int}}(10)\nOctDirections{Rational{Int64}, SparseArrays.SparseVector{Rational{Int64}, Int64}}(10)\n\njulia> length(dirs)\n200\n\n\n\n\n\n","category":"type"},{"location":"lib/approximations/template_directions/#LazySets.Approximations.BoxDiagDirections","page":"Template directions","title":"LazySets.Approximations.BoxDiagDirections","text":"BoxDiagDirections{N, VN} <: AbstractDirections{N, VN}\n\nBox-diagonal directions representation.\n\nFields\n\nn – dimension\n\nNotes\n\nBox-diagonal directions can be seen as the union of diagonal directions (all entries are ±1) and box directions (one entry is ±1, all other entries are 0). The iterator first enumerates all diagonal directions and then all box directions. In dimension n, there are in total 2^n + 2n such directions (exception: for n = 1, there are 2 directions).\n\nExamples\n\nThe template can be constructed by passing the dimension. For example, in two dimensions:\n\njulia> dirs = BoxDiagDirections(2)\nBoxDiagDirections{Float64, Vector{Float64}}(2)\n\njulia> length(dirs) # number of directions\n8\n\nBy default, each direction is represented as a regular vector:\n\njulia> eltype(dirs)\nVector{Float64} (alias for Array{Float64, 1})\n\nIn two dimensions, the directions are normal to the facets of an octagon, i.e., the template coincides with OctDirections.\n\njulia> collect(dirs)\n8-element Vector{Vector{Float64}}:\n [1.0, 1.0]\n [-1.0, 1.0]\n [1.0, -1.0]\n [-1.0, -1.0]\n [1.0, 0.0]\n [0.0, 1.0]\n [0.0, -1.0]\n [-1.0, 0.0]\n\nThe numeric type can be specified as well:\n\njulia> dirs = BoxDiagDirections{Rational{Int}}(10)\nBoxDiagDirections{Rational{Int64}, Vector{Rational{Int64}}}(10)\n\njulia> length(dirs)\n1044\n\n\n\n\n\n","category":"type"},{"location":"lib/approximations/template_directions/#LazySets.Approximations.PolarDirections","page":"Template directions","title":"LazySets.Approximations.PolarDirections","text":"PolarDirections{N<:AbstractFloat, VN<:AbstractVector{N}} <: AbstractDirections{N, VN}\n\nPolar directions representation.\n\nFields\n\nNφ    – length of the partition of the polar angle\nstack – list of computed directions\n\nNotes\n\nThe PolarDirections constructor computes a sample of the unit sphere in ℝ^2, which is parameterized by the polar angle φ  Dφ = 0 2π; see the Wikipedia entry on the polar coordinate system for details. The resulting directions are stored in stack.\n\nThe integer argument Nφ defines how many samples of Dφ are taken. The Cartesian components of each direction are obtained with\n\ncos(φᵢ) sin(φᵢ)\n\nExamples\n\nThe integer passed as an argument is used to discretize φ:\n\njulia> pd = PolarDirections(2);\n\njulia> pd.stack\n2-element Vector{Vector{Float64}}:\n [1.0, 0.0]\n [-1.0, 1.2246467991473532e-16]\n\njulia> length(pd)\n2\n\n\n\n\n\n","category":"type"},{"location":"lib/approximations/template_directions/#LazySets.Approximations.SphericalDirections","page":"Template directions","title":"LazySets.Approximations.SphericalDirections","text":"SphericalDirections{N<:AbstractFloat, VN<:AbstractVector{N}} <: AbstractDirections{N, VN}\n\nSpherical directions representation.\n\nFields\n\nNθ    – length of the partition of the azimuthal angle\nNφ    – length of the partition of the polar angle\nstack – list of computed directions\n\nNotes\n\nThe SphericalDirections constructor provides a sample of the unit sphere in ℝ^3, which is parameterized by the azimuthal and polar angles θ  Dθ = 0 π and φ  Dφ = 0 2π respectively; see the Wikipedia entry on the spherical coordinate system for details.\n\nThe integer arguments Nθ and Nφ define how many samples along the domains Dθ and Dφ are respectively taken. The Cartesian components of each direction are obtained with\n\nsin(θᵢ)*cos(φᵢ) sin(θᵢ)*sin(φᵢ) cos(θᵢ)\n\nThe north and south poles are treated separately so that those points are not considered more than once.\n\nExamples\n\nThe template can be built in different ways. If you pass only one integer, the same value is used to discretize both θ and φ:\n\njulia> sd = SphericalDirections(3);\n\njulia> sd.Nθ, sd.Nφ\n(3, 3)\n\njulia> length(sd)\n4\n\nPass two integers to control the discretization in θ and in φ separately:\n\njulia> sd = SphericalDirections(4, 5);\n\njulia> length(sd)\n10\n\njulia> sd = SphericalDirections(4, 8);\n\njulia> length(sd)\n16\n\n\n\n\n\n","category":"type"},{"location":"lib/approximations/template_directions/#LazySets.Approximations.CustomDirections","page":"Template directions","title":"LazySets.Approximations.CustomDirections","text":"CustomDirections{N, VN<:AbstractVector{N}} <: AbstractDirections{N, VN}\n\nUser-defined direction vectors.\n\nFields\n\ndirections          – list of direction vectors\nn                   – (optional; default: computed from directions)                          dimension\ncheck_boundedness   – (optional; default: true) flag to check boundedness\ncheck_normalization – (optional; default: true) flag to check whether all                          directions are normalized\n\nNotes\n\nThis struct is a wrapper for a list of user-defined directions. There are fields for the list of directions, their dimension, and (boolean) cache fields for the boundedness and normalization properties. The latter are checked by default upon construction.\n\nTo check boundedness, we construct the polyhedron with constraints dx = 1 for each direction d and check if this set is bounded. (Note that the bound 1 is arbitrary and that this set may be empty, which however implies boundedness.)\n\nThe dimension will also be determined automatically, unless the empty vector is passed (in which case the optional argument n needs to be specified).\n\nExamples\n\nCreate a template with box directions in dimension two:\n\njulia> dirs = CustomDirections([[1.0, 0.0], [-1.0, 0.0], [0.0, 1.0], [0.0, -1.0]]);\n\njulia> dirs.directions\n4-element Vector{Vector{Float64}}:\n [1.0, 0.0]\n [-1.0, 0.0]\n [0.0, 1.0]\n [0.0, -1.0]\n\njulia> LazySets.Approximations.isbounding(dirs)\ntrue\n\njulia> LazySets.Approximations.isnormalized(dirs)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/BallInf/#def_BallInf","page":"BallInf","title":"Infinity-norm ball (BallInf)","text":"","category":"section"},{"location":"lib/sets/BallInf/#LazySets.BallInfModule.BallInf","page":"BallInf","title":"LazySets.BallInfModule.BallInf","text":"BallInf{N, VN<:AbstractVector{N}} <: AbstractHyperrectangle{N}\n\nType that represents a ball in the infinity norm.\n\nFields\n\ncenter – center of the ball as a real vector\nradius – radius of the ball as a real scalar ( 0)\n\nNotes\n\nMathematically, a ball in the infinity norm is defined as the set\n\nmathcalB_^n(c r) =  x  ℝ^n   x - c _  r \n\nwhere c  ℝ^n is its center and r  ℝ_+ its radius. Here   _ denotes the infinity norm, defined as  x _ = maxlimits_i=1n vert x_i vert for any x  ℝ^n.\n\nExamples\n\nConstruct the two-dimensional unit ball and compute its support function along the positive x=y direction:\n\njulia> B = BallInf(zeros(2), 1.0)\nBallInf{Float64, Vector{Float64}}([0.0, 0.0], 1.0)\n\njulia> dim(B)\n2\n\njulia> ρ([1.0, 1.0], B)\n2.0\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/BallInf/#Operations","page":"BallInf","title":"Operations","text":"","category":"section"},{"location":"lib/sets/BallInf/#LazySets.isflat-Tuple{BallInf}","page":"BallInf","title":"LazySets.isflat","text":"isflat(B::BallInf)\n\nDetermine whether a ball in the infinity norm is flat, i.e., whether its radius is zero.\n\nInput\n\nB – ball in the infinity norm\n\nOutput\n\ntrue iff the ball is flat.\n\nNotes\n\nFor robustness with respect to floating-point inputs, this function relies on the result of isapproxzero applied to the radius of the ball. Hence, this function depends on the absolute zero tolerance ABSZTOL.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#LazySets.ngens-Tuple{BallInf}","page":"BallInf","title":"LazySets.ngens","text":"ngens(B::BallInf)\n\nReturn the number of generators of a ball in the infinity norm.\n\nInput\n\nB – ball in the infinity norm\n\nOutput\n\nThe number of generators.\n\nAlgorithm\n\nA ball in the infinity norm has either one generator for each dimension, or zero generators if it is a degenerated ball of radius zero.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#LazySets.API.radius-lib-sets-BallInf","page":"BallInf","title":"LazySets.API.radius","text":"radius(X::LazySet, [p]::Real=Inf)\n\nReturn the radius of a set.\n\nInput\n\nX – set\np – (optional, default: Inf) norm\n\nOutput\n\nA real number representing the radius.\n\nNotes\n\nThe radius of a set is the radius of the enclosing ball (of the given p-norm) of minimal volume.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/BallInf/#LazySets.API.radius","page":"BallInf","title":"LazySets.API.radius","text":"Extended help\n\nradius(B::BallInf, [p]::Real=Inf)\n\nNotes\n\nThe result is defined as the radius of the enclosing ball of the given p-norm of minimal volume with the same center.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/BallInf/#LazySets.radius_hyperrectangle-Tuple{BallInf}","page":"BallInf","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(B::BallInf)\n\nReturn the box radius of a ball in the infinity norm.\n\nInput\n\nB – ball in the infinity norm\n\nOutput\n\nThe box radius of the ball in the infinity norm, which is the same in every dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#LazySets.radius_hyperrectangle-Tuple{BallInf, Int64}","page":"BallInf","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(B::BallInf, i::Int)\n\nReturn the box radius of a ball in the infinity norm in a given dimension.\n\nInput\n\nB – ball in the infinity norm\ni – dimension of interest\n\nOutput\n\nThe box radius of the ball in the infinity norm in the given dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-BallInf","page":"BallInf","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#Base.rand-Tuple{Type{BallInf}}","page":"BallInf","title":"Base.rand","text":"Extended help\n\nrand(::Type{BallInf}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the radius is nonnegative.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#LazySets.API.reflect-Tuple{LazySets.API.LazySet}-lib-sets-BallInf","page":"BallInf","title":"LazySets.API.reflect","text":"reflect(X::LazySet)\n\nCompute the reflection of a set in the origin.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the reflection -X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#LazySets.API.reflect-Tuple{BallInf}","page":"BallInf","title":"LazySets.API.reflect","text":"Extended help\n\nreflect(B::BallInf)\n\nAlgorithm\n\nIf B has center c and radius r, then -B has center -c and radius r.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#LazySets.API.volume-Tuple{LazySets.API.LazySet}-lib-sets-BallInf","page":"BallInf","title":"LazySets.API.volume","text":"volume(X::LazySet)\n\nCompute the volume, or Lebesgue measure, of a set.\n\nInput\n\nX – set\n\nOutput\n\nA real number representing the Lebesgue measure of X.\n\nNotes\n\nThe Lebesgue measure has the following common special cases:\n\nIn 1D, it coincides with the length.\nIn 2D, it coincides with the area (see also area).\nIn 3D, it coincides with the volume.\n\nIn higher dimensions, it is also known as the hypervolume or simply volume.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#LazySets.API.volume-Tuple{BallInf}","page":"BallInf","title":"LazySets.API.volume","text":"Extended help\n\nvolume(B::BallInf)\n\nAlgorithm\n\nWe compute the volume by iterative multiplication of the radius.\n\nFor floating-point inputs we use this implementation for balls of dimension less than 50. For balls of higher dimension we instead compute exp(n * log(2r)), where r is the radius of the ball.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-BallInf","page":"BallInf","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, X::LazySet)\n\nEvaluate the support function of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nThe evaluation of the support function of X in direction d.\n\nNotes\n\nA convenience alias support_function is also available.\n\nWe have the following identity based on the support vector σ:\n\n    ρ(d X) = d  σ(d X)\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#LazySets.API.ρ-Tuple{AbstractVector, BallInf}","page":"BallInf","title":"LazySets.API.ρ","text":"Extended help\n\nρ(d::AbstractVector, B::BallInf)\n\nAlgorithm\n\nLet B be a ball in the infinity norm with center c and radius r and let d be the direction of interest. For balls with dimensions less than 30, we use the implementation for AbstractHyperrectangle, tailored to a BallInf, which computes\n\n    _i=1^n d_i (c_i + textrmsgn(d_i)  r)\n\nwhere textrmsgn(α) = 1 if α  0 and textrmsgn(α) = -1 if α  0.\n\nFor balls of higher dimension, we instead exploit that for a support vector v = σ(d B) = c + textrmsgn(d)  (r  r)ᵀ we have\n\n    ρ(d B) = d v = d c + d textrmsgn(d)  (r  r)ᵀ = d c + r  _i=1^n d_i\n\nwhere   denotes the dot product.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#LazySets.API.translate!-Tuple{LazySets.API.LazySet, AbstractVector}-lib-sets-BallInf","page":"BallInf","title":"LazySets.API.translate!","text":"translate!(X::LazySet, v::AbstractVector)\n\nTranslate a set with a vector by modifying it.\n\nInput\n\nX – set\nv – vector\n\nOutput\n\nThe translated set representing X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#LazySets.API.translate!-Tuple{BallInf, AbstractVector}","page":"BallInf","title":"LazySets.API.translate!","text":"Extended help\n\ntranslate!(B::BallInf, v::AbstractVector)\n\nAlgorithm\n\nWe add the vector to the center of the ball.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"area\ncenter\nhigh\nhigh\nisoperationtype\nlow\nlow\nproject\nscale\nσ\nminkowski_sum","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"ball_norm\nradius_ball","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"chebyshev_center_radius\ncomplement\nconcretize\ncopy(::Type{LazySet})\ndiameter\nconstraints\nconvex_hull\neltype\neltype\nisoperation\npolyhedron\nrationalize\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nsample\ntranslate\nconvex_hull\n≈\n==\nisequivalent\n⊂","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"ispolyhedral","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"isbounded\nisboundedtype","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"an_element\ncenter\ndim\nisempty\nisuniversal","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"order\nremove_redundant_generators\ntogrep\nlinear_map\nreduce_order\nsplit\nsplit","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"Inherited from AbstractHyperrectangle:","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"constraints_list\ndistance\nextrema\nextrema\ngenerators\ngenmat\nnorm\nrectify\nvertices_list\n∈\ncartesian_product\ndifference\ndistance\nintersection\nisdisjoint\n⊆\nminkowski_difference","category":"page"},{"location":"lib/sets/ZonotopeMD/#def_ZonotopeMD","page":"ZonotopeMD","title":"ZonotopeMD","text":"","category":"section"},{"location":"lib/sets/ZonotopeMD/#LazySets.ZonotopeMDModule.ZonotopeMD","page":"ZonotopeMD","title":"LazySets.ZonotopeMDModule.ZonotopeMD","text":"ZonotopeMD{N,VN<:AbstractVector{N},MN<:AbstractMatrix{N},DN<:AbstractVector{N}}\n    <: AbstractZonotope{N}\n\nType that represents a structured zonotope.\n\nFields\n\ncenter – center of the zonotope\nM      – matrix of general (non-axis-aligned) generators\nd      – vector representing a diagonal matrix of axis-aligned generators\n\nNotes\n\nA structured zonotope is defined as the set\n\nZ = left x  ℝ^n  x = c + Mξ + dIη  ξ  -1 1^m  η  -1 1^n right\n\nwhere M  ℝ^nm is a matrix of general generators with m = n (k - 1) and d  ℝⁿ is a vector of axis-aligned generators. Equivalently, this can be seen as a zonotope with generator matrix M D, where D is the diagonal matrix formed from the vector d.\n\nA ZonotopeMD can be constructed in two ways: by passing M and a vector d separately or by passing the full generator matrix M D.\n\nExamples\n\nConstructing a structured zonotope from a center, general generator matrix M, and diagonal vector d:\n\njulia> c = [0.0, 0.0];\n\njulia> M = [1.0 2.0; 3.0 1.0];\n\njulia> d = [0.1, 0.2];\n\njulia> Z = ZonotopeMD(c, M, d)\nZonotopeMD{Float64, Vector{Float64}, Matrix{Float64}, Vector{Float64}}([0.0, 0.0], [1.0 2.0; 3.0 1.0], [0.1, 0.2])\n\njulia> center(Z)\n2-element Vector{Float64}:\n 0.0\n 0.0\n\njulia> genmat(Z)\n2×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 6 stored entries:\n 1.0  2.0  0.1   ⋅\n 3.0  1.0   ⋅   0.2\n\nConstructing the same zonotope by passing the full generator matrix M D directly:\n\njulia> G = [1.0 2.0 0.1 0.0;\n            3.0 1.0 0.0 0.2];\n\njulia> Z2 = ZonotopeMD(c, G)\nZonotopeMD{Float64, Vector{Float64}, Matrix{Float64}, Vector{Float64}}([0.0, 0.0], [1.0 2.0; 3.0 1.0], [0.1, 0.2])\n\nThe generator matrix returned by genmat is the concatenation M D represented as a sparse matrix.\n\njulia> genmat(Z2) == G\ntrue\n\nOne can also convert back to a standard Zonotope if needed:\n\njulia> Zstd = convert(Zonotope, Z)\nZonotope{Float64, Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}([0.0, 0.0], sparse([1, 2, 1, 2, 1, 2], [1, 1, 2, 2, 3, 4], [1.0, 3.0, 2.0, 1.0, 0.1, 0.2], 2, 4))\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/ZonotopeMD/#Operations","page":"ZonotopeMD","title":"Operations","text":"","category":"section"},{"location":"lib/sets/ZonotopeMD/#LazySets.genmat-Tuple{ZonotopeMD}","page":"ZonotopeMD","title":"LazySets.genmat","text":"genmat(Z::ZonotopeMD)\n\nReturn the generator matrix of a structured zonotope.\n\nInput\n\nZ – structured zonotope\n\nOutput\n\nA matrix where each column represents one generator of the zonotope Z.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/ZonotopeMD/#LazySets.API.cartesian_product-Tuple{ZonotopeMD, ZonotopeMD}","page":"ZonotopeMD","title":"LazySets.API.cartesian_product","text":"cartesian_product(Z1::ZonotopeMD, Z2::ZonotopeMD)\n\nReturn the Cartesian product of two structured zonotopes.\n\nInput\n\nZ1 – structured zonotope\nZ2 – structured zonotope\n\nOutput\n\nA new ZonotopeMD representing the Cartesian product Z1 × Z2.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/ZonotopeMD/","page":"ZonotopeMD","title":"ZonotopeMD","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/ZonotopeMD/","page":"ZonotopeMD","title":"ZonotopeMD","text":"center","category":"page"},{"location":"lib/sets/ZonotopeMD/","page":"ZonotopeMD","title":"ZonotopeMD","text":"ngens","category":"page"},{"location":"lib/sets/ZonotopeMD/","page":"ZonotopeMD","title":"ZonotopeMD","text":"isoperationtype","category":"page"},{"location":"lib/sets/ZonotopeMD/","page":"ZonotopeMD","title":"ZonotopeMD","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/ZonotopeMD/","page":"ZonotopeMD","title":"ZonotopeMD","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nsample\ntranslate\nconvex_hull\nexact_sum\n≈\n==\nisequivalent\n⊂","category":"page"},{"location":"lib/sets/ZonotopeMD/","page":"ZonotopeMD","title":"ZonotopeMD","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/ZonotopeMD/","page":"ZonotopeMD","title":"ZonotopeMD","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/ZonotopeMD/","page":"ZonotopeMD","title":"ZonotopeMD","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/ZonotopeMD/","page":"ZonotopeMD","title":"ZonotopeMD","text":"high\nhigh\nispolyhedral\nlow\nlow\nintersection","category":"page"},{"location":"lib/sets/ZonotopeMD/","page":"ZonotopeMD","title":"ZonotopeMD","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/ZonotopeMD/","page":"ZonotopeMD","title":"ZonotopeMD","text":"isbounded\nvolume\nisboundedtype","category":"page"},{"location":"lib/sets/ZonotopeMD/","page":"ZonotopeMD","title":"ZonotopeMD","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/sets/ZonotopeMD/","page":"ZonotopeMD","title":"ZonotopeMD","text":"an_element\ncenter\ndim\nextrema\nextrema\nisempty\nisuniversal","category":"page"},{"location":"lib/sets/ZonotopeMD/","page":"ZonotopeMD","title":"ZonotopeMD","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/sets/ZonotopeMD/","page":"ZonotopeMD","title":"ZonotopeMD","text":"constraints_list\nconstraints_list\norder\nreflect\ntogrep\nvertices_list\n∈\nlinear_map\nproject\nreduce_order\nsplit\nsplit\nρ\nσ\nisdisjoint\n⊆\nminkowski_difference\nminkowski_sum","category":"page"},{"location":"lib/concrete_binary_operations/overview/#Binary-set-operations","page":"Binary set operations","title":"Binary set operations","text":"","category":"section"},{"location":"lib/concrete_binary_operations/overview/","page":"Binary set operations","title":"Binary set operations","text":"The following table lists all operations that take two set as argument in the entries. In the rows we list all set types, both the interfaces (where we abbreviate the Abstract prefix), the basic set types, and the lazy set operations, each sorted alphabetically. In the columns we also list the operations, but abbreviated. The table entries consist of subsets of the following list of operations.","category":"page"},{"location":"lib/concrete_binary_operations/overview/","page":"Binary set operations","title":"Binary set operations","text":"\"⊆\" stands for the subset check issubset.\n\"⊎\" stands for the disjointness check isdisjoint.\n\"∩\" stands for the concrete intersection operation intersection.\n\"C\" stands for the conversion operation convert.\n\"-\" indicates that the two types' dimensionality constraints are incompatible.\nA suffix \"i\" indicates that the operation is inherited from a supertype.","category":"page"},{"location":"lib/concrete_binary_operations/overview/","page":"Binary set operations","title":"Binary set operations","text":"type ↓ \\ type → LazyS APtop ACSym ACSPt APgon AHrec AHPgn ASing Ball1 Ball2 BInf Ballp Ellip Empty HalfS HPgon HPhed HPtop Hplan Hrect Itrvl Line2D LineS Single Universe VPgon VPtop ZeroS Zonot CP CPA CH CHA EMap EPM Itsct ItscA LiMap MS MSA CMS ReMap SIH Transl UnionSet UnionSArr Complem\nInterfaces                                               \nLazySet ⊎ ⊆  ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆  ⊎i ⊆i ⊎ ⊆i ⊎  ∩ ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆  ⊎ ⊆i ⊎i ⊆  ⊎ ⊆i ⊎ ⊆i ⊎ ⊆i ⊎i ⊆i ⊎i ⊎ ⊆i ⊎i ⊆i ⊎i ∩i ⊆  ⊎  ∩ ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎  ∩ ⊎  ∩ ⊆  ⊎\nAPolytope ⊆  ⊎i ⊆i ⊎i ∩ ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩ ⊆i ⊎i ∩ ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆  ⊎  ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nACentrallySymmetric ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nACentrallySymmetricPolytope ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nAPolygon ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i - ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nAHyperrectangle ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎  ∩ ⊆i ⊎i ∩i ⊆i ⊎  ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nAHPolygon ⊆i ⊎ ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩ ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i - ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i C ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nASingleton ⊆  ⊎  ∩ ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎  ∩i ⊆i ⊎i ∩i ⊆  ⊎  ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎  ∩ ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\n               ⊎                                \nBasic set types               ⊎                                \nBall1 ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nBall2 ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆  ⊎i ∩i ⊆i ⊎i ⊆ ⊎ ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆  ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆  ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nBallInf ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nBallp ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆  ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆  ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆  ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nEllipsoid ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nEmptySet ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆  ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nHalfSpace ⊎ ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎ ⊆i ⊎i ⊆i ⊎i ∩ ⊆i ⊎i ∩ ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎  ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nHPolygon/HPolygonOpt ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i C ⊆i ⊎i ∩i C ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i C ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ∩i C ⊆i ⊎i ⊆i ⊎i ∩i Ci - ⊆i ⊎i ⊆i ⊎i ∩i C ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nHPolyhedron ⊎ ⊆i ⊎i ∩  C ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊎i ⊆i ⊎i ∩i Ci ⊎i ⊎i ⊎i ⊆i ⊎i ∩ ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩ ⊆i ⊎i ∩  Ci ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩  Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ∩i Ci ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nHPolytope ⊆i ⊎ ⊆i ⊎i ∩  C ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i C ⊆i ⊎i ∩i C ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩ ⊆i ⊎i ∩i C ⊆i ⊎i ∩ ⊆i ⊎i ∩  Ci ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩  C ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nHyperplane ⊎ ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎  ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎ ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nHyperrectangle ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i C ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nInterval ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i - ⊆i ⊎i ∩i - ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i - ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i - - ⊆i ⊎i ∩i ⊆i ⊎i ∩i - ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nLine2D ⊎ ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i - ⊎i ∩ ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎  ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nLineSegment ⊆  ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i - ⊆i ⊎i ⊆i ⊎  ∩i ⊆i ⊎i ∩i ⊆  ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nSingleton ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nUniverse ⊆  ⊎  ∩ ⊆  ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎  ∩ ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎i ∩i ⊆i ⊎  ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎  ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎  ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎  ∩ ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nVPolygon ⊆i ⊎i ⊆i ⊎i ∩i C ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i C ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ∩i Ci - ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nVPolytope ⊆i ⊎i ⊆i ⊎i ∩i C ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩ ⊆i ⊎i ∩  C ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩  Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nZeroSet ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nZonotope ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i C ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎ ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎  ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\n               ⊎                                \nLazy set operation types               ⊎                                \nCartesianProduct ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nCartesianProductArray ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆  ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nConvexHull ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nConvexHullArray ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nExponentialMap ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nExponentialProjectionMap ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nIntersection ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nIntersectionArray ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nLinearMap ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nMinkowskiSum ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nMinkowskiSumArray ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nCachedMinkowskiSumArray ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nResetMap ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nSymmetricIntervalHull ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nTranslation ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nUnionSet ⊆  ⊎  ∩ ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊎ ⊎ \nUnionSetArray ⊆  ⊎  ∩ ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊎ ⊎ \nComplement ⊎ ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i   ","category":"page"},{"location":"lib/approximations/box_approximation/","page":"Box Approximation","title":"Box Approximation","text":"Pages = [\"box_approximation.md\"]\nDepth = 3","category":"page"},{"location":"lib/approximations/box_approximation/#Box-Approximation","page":"Box Approximation","title":"Box Approximation","text":"","category":"section"},{"location":"lib/approximations/box_approximation/#LazySets.Approximations.box_approximation","page":"Box Approximation","title":"LazySets.Approximations.box_approximation","text":"box_approximation(S::LazySet)\n\nOverapproximate a set by a tight hyperrectangle.\n\nInput\n\nS – set\n\nOutput\n\nA tight hyperrectangle.\n\nNotes\n\nAn alias for this function is interval_hull.\n\nAlgorithm\n\nThe center and radius of the hyperrectangle are obtained by averaging the low and high coordinates of S computed with the extrema function.\n\n\n\n\n\nbox_approximation(S::CartesianProductArray{N, <:AbstractHyperrectangle}) where {N}\n\nOverapproximate the Cartesian product of a finite number of hyperrectangular sets by a tight hyperrectangle.\n\nInput\n\nS– Cartesian product of a finite number of hyperrectangular sets\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nThis method falls back to the convert method. Since the sets wrapped by the Cartesian product array are hyperrectangles, this can be done without overapproximation.\n\n\n\n\n\nbox_approximation(S::CartesianProduct{N, <:AbstractHyperrectangle, <:AbstractHyperrectangle}) where {N}\n\nOverapproximate the Cartesian product of two hyperrectangular sets by a tight hyperrectangle.\n\nInput\n\nS– Cartesian product of two hyperrectangular sets\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nThis method falls back to the convert method. Since the sets wrapped by the Cartesian product array are hyperrectangles, this can be done without overapproximation.\n\n\n\n\n\nbox_approximation(lm::LinearMap{N, <:AbstractHyperrectangle}) where {N}\n\nReturn a tight overapproximation of the linear map of a hyperrectangular set using a hyperrectangle.\n\nInput\n\nlm– linear map of a hyperrectangular set\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nIf c and r denote the center and vector radius of a hyperrectangle H, a tight hyperrectangular overapproximation of M * H is obtained by transforming c ↦ M*c and r ↦ abs.(M) * r, where abs.(⋅) denotes the element-wise absolute-value operator.\n\n\n\n\n\nbox_approximation(R::Rectification{N}) where {N}\n\nOverapproximate the rectification of a set by a tight hyperrectangle.\n\nInput\n\nR– rectification of a set\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nBox approximation and rectification distribute. We first check whether the wrapped set is empty. If so, we return the empty set. Otherwise, we compute the box approximation of the wrapped set, rectify the resulting box (which is simple), and finally convert the resulting set to a box.\n\n\n\n\n\nbox_approximation(Z::AbstractZonotope)\n\nReturn a tight overapproximation of a zonotope with an axis-aligned box.\n\nInput\n\nZ – zonotope\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nThis function implements the method in Althoff et al. [ASB10], Section 5.1.2. A zonotope Z = c G can be tightly overapproximated by an axis-aligned hyperrectangle such that its center is c and the radius along dimension i is the column-sum of the absolute values of the i-th row of G for i = 1 p, where p is the number of generators of Z.\n\n\n\n\n\nbox_approximation(am::AbstractAffineMap{N, <:AbstractHyperrectangle}) where {N}\n\nOverapproximate the affine map of a hyperrectangular set by a tight hyperrectangle.\n\nInput\n\nam – affine map of a hyperrectangular set\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nIf c and r denote the center and vector radius of a hyperrectangle H and v is the translation vector, a tight hyperrectangular overapproximation of M * H + v is obtained by transforming c ↦ M*c+v and r ↦ abs.(M) * r, where abs.(⋅) denotes the element-wise absolute-value operator.\n\n\n\n\n\nbox_approximation(ch::ConvexHull; [algorithm]::String=\"box\")\n\nOverapproximate a convex hull with a tight hyperrectangle.\n\nInput\n\nch        – convex hull\nalgorithm – (optional; default: \"box\") algorithm choice\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nLet X and Y be the two sets of ch. We make use of the following property:\n\n(CH(X Y))\n    = left( X  Y right)\n    = left( (X)  (Y) right)\n\nIf algorithm == \"extrema\", we compute the low and high coordinates of X and Y via extrema.\n\nIf algorithm == \"box\", we instead compute the box approximations of X and Y via box_approximation.\n\nIn both cases we then take the box approximation of the result.\n\nThe \"extrema\" algorithm is more efficient if extrema is efficient because it does not need to allocate the intermediate hyperrectangles.\n\n\n\n\n\nbox_approximation(ms::MinkowskiSum)\n\nOverapproximate the Minkowski sum of two sets with a tight hyperrectangle.\n\nInput\n\nms – Minkowski sum\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nThe box approximation distributes over the Minkowski sum:\n\n(X  Y) = (X)  (Y)\n\nIt suffices to compute the box approximation of each summand and then take the concrete Minkowski sum for hyperrectangles.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/box_approximation/#LazySets.Approximations.interval_hull","page":"Box Approximation","title":"LazySets.Approximations.interval_hull","text":"interval_hull\n\nAlias for box_approximation.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/box_approximation/#LazySets.□-Tuple{LazySet}","page":"Box Approximation","title":"LazySets.□","text":"□(X::LazySet)\n\nAlias for box_approximation(X).\n\n\n\n\n\n","category":"method"},{"location":"lib/approximations/box_approximation/#LazySets.Approximations.symmetric_interval_hull","page":"Box Approximation","title":"LazySets.Approximations.symmetric_interval_hull","text":"symmetric_interval_hull(S::LazySet{N}) where {N}\n\nOverapproximate a set by a tight hyperrectangle centered in the origin.\n\nInput\n\nS – set\n\nOutput\n\nA tight hyperrectangle that is centrally symmetric wrt. the origin.\n\nNotes\n\nAn alias for this function is box_approximation_symmetric.\n\nAlgorithm\n\nThe center of the box is the origin, and the radius is obtained via the extrema function.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/box_approximation/#LazySets.Approximations.box_approximation_symmetric","page":"Box Approximation","title":"LazySets.Approximations.box_approximation_symmetric","text":"box_approximation_symmetric\n\nAlias for symmetric_interval_hull.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/box_approximation/#LazySets.Approximations.ballinf_approximation","page":"Box Approximation","title":"LazySets.Approximations.ballinf_approximation","text":"ballinf_approximation(S::LazySet)\n\nOverapproximate a set by a tight ball in the infinity norm.\n\nInput\n\nS – set\n\nOutput\n\nA tight ball in the infinity norm.\n\nAlgorithm\n\nThe center and radius of the ball are obtained by averaging the low and high coordinates of S computed with the extrema function.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/VPolygon/#def_VPolygon","page":"VPolygon","title":"Polygon in vertex representation (VPolygon)","text":"","category":"section"},{"location":"lib/sets/VPolygon/#LazySets.VPolygonModule.VPolygon","page":"VPolygon","title":"LazySets.VPolygonModule.VPolygon","text":"VPolygon{N, VN<:AbstractVector{N}} <: AbstractPolygon{N}\n\nType that represents a polygon by its vertices.\n\nFields\n\nvertices – the list of vertices\n\nNotes\n\nThis type assumes that all vertices are sorted in counter-clockwise fashion.\n\nTo ensure this property, the constructor of VPolygon runs a convex-hull algorithm on the vertices by default. This also removes redundant vertices. If the vertices are known to be sorted, the flag apply_convex_hull=false can be used to skip this preprocessing.\n\nExamples\n\nA polygon in vertex representation can be constructed by passing the list of vertices. For example, we can build the right triangle\n\njulia> P = VPolygon([[0, 0], [1, 0], [0, 1]]);\n\njulia> P.vertices\n3-element Vector{Vector{Int64}}:\n [0, 0]\n [1, 0]\n [0, 1]\n\nAlternatively, a VPolygon can be constructed passing a matrix of vertices, where each column represents a vertex:\n\njulia> M = [0 1 0; 0 0 1.]\n2×3 Matrix{Float64}:\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> P = VPolygon(M);\n\njulia> P.vertices\n3-element Vector{Vector{Float64}}:\n [0.0, 0.0]\n [1.0, 0.0]\n [0.0, 1.0]\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/VPolygon/#Conversion","page":"VPolygon","title":"Conversion","text":"","category":"section"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"convert(::Type{VPolygon}, ::LazySet)","category":"page"},{"location":"lib/sets/VPolygon/#Operations","page":"VPolygon","title":"Operations","text":"","category":"section"},{"location":"lib/sets/VPolygon/#LazySets.API.an_element-Tuple{LazySets.API.LazySet}-lib-sets-VPolygon","page":"VPolygon","title":"LazySets.API.an_element","text":"an_element(X::LazySet)\n\nReturn some element of a nonempty set.\n\nInput\n\nX – set\n\nOutput\n\nAn element of X unless X is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.API.an_element-Tuple{VPolygon}","page":"VPolygon","title":"LazySets.API.an_element","text":"Extended help\n\nan_element(P::VPolygon)\n\nOutput\n\nThe first vertex of the polygon in vertex representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.API.area-Tuple{LazySets.API.LazySet}-lib-sets-VPolygon","page":"VPolygon","title":"LazySets.API.area","text":"area(X::LazySet)\n\nCompute the area of a two-dimensional set, respectively the surface area of a three-dimensional set.\n\nInput\n\nX – two- or three-dimensional set\n\nOutput\n\nA number representing the (surface) area of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.API.area-Tuple{VPolygon}","page":"VPolygon","title":"LazySets.API.area","text":"Extended help\n\narea(V::VPolygon)\n\nAlgorithm\n\nSee area(::LazySets.LazySet).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-VPolygon","page":"VPolygon","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#Base.rand-Tuple{Type{VPolygon}}","page":"VPolygon","title":"Base.rand","text":"Extended help\n\nrand(::Type{VPolygon}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nInput\n\nnum_vertices – (optional, default: -1) number of vertices of the                   polygon (see comment below)\n\nNotes\n\nThe number of vertices can be controlled with the argument num_vertices. For a negative value we choose a random number in the range 3:10.\n\nAlgorithm\n\nWe follow the idea described here based on Valtr [Val95]. There is also a nice video available here.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.remove_redundant_vertices-Tuple{VPolygon}","page":"VPolygon","title":"LazySets.remove_redundant_vertices","text":"remove_redundant_vertices(P::VPolygon;\n                          [algorithm]::String=\"monotone_chain\")\n\nReturn a polygon obtained by removing the redundant vertices of the given polygon.\n\nInput\n\nP         – polygon in vertex representation\nalgorithm – (optional, default: \"monotone_chain\") the algorithm used to                compute the convex hull\n\nOutput\n\nA new polygon such that its vertices are the convex hull of the given polygon.\n\nAlgorithm\n\nSee remove_redundant_vertices!(::VPolygon).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.remove_redundant_vertices!-Tuple{VPolygon}","page":"VPolygon","title":"LazySets.remove_redundant_vertices!","text":"remove_redundant_vertices!(P::VPolygon;\n                           [algorithm]::String=\"monotone_chain\")\n\nRemove the redundant vertices from the given polygon in-place.\n\nInput\n\nP         – polygon in vertex representation\nalgorithm – (optional, default: \"monotone_chain\") the algorithm used to                compute the convex hull\n\nOutput\n\nThe modified polygon whose redundant vertices have been removed.\n\nAlgorithm\n\nA convex-hull algorithm is used to compute the convex hull of the vertices of the polygon P; see ?convex_hull for details on the available algorithms. The vertices are sorted in counter-clockwise fashion.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.tohrep-Union{Tuple{VPolygon}, Tuple{HPOLYGON}, Tuple{VPolygon, Type{HPOLYGON}}} where HPOLYGON<:AbstractHPolygon","page":"VPolygon","title":"LazySets.tohrep","text":"tohrep(P::VPolygon, ::Type{HPOLYGON}=HPolygon) where {HPOLYGON<:AbstractHPolygon}\n\nBuild a constraint representation of the given polygon.\n\nInput\n\nP        – polygon in vertex representation\nHPOLYGON – (optional, default: HPolygon) type of target polygon\n\nOutput\n\nA polygon in constraint representation, an AbstractHPolygon.\n\nAlgorithm\n\nThe algorithm adds an edge for each consecutive pair of vertices. Since the vertices are already ordered in counter-clockwise fashion (CCW), the constraints will be sorted automatically (CCW).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.tovrep-Tuple{VPolygon}","page":"VPolygon","title":"LazySets.tovrep","text":"tovrep(P::VPolygon)\n\nBuild a vertex representation of the given polygon.\n\nInput\n\nP – polygon in vertex representation\n\nOutput\n\nThe same polygon instance.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#Base.:∈-Tuple{AbstractVector, VPolygon}","page":"VPolygon","title":"Base.:∈","text":"Extended help\n\n∈(x::AbstractVector, P::VPolygon)\n\nAlgorithm\n\nThis implementation exploits that the polygon's vertices are sorted in counter-clockwise fashion. Under this assumption we can just check if the vertex lies on the left of each edge, using the dot product.\n\nExamples\n\njulia> P = VPolygon([[2.0, 3.0], [3.0, 1.0], [5.0, 1.0], [4.0, 5.0]]);\n\njulia> [4.5, 3.1] ∈ P\nfalse\njulia> [4.5, 3.0] ∈ P\ntrue\njulia> [4.4, 3.4] ∈ P  #  point lies on the edge\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.API.linear_map-Tuple{AbstractMatrix, VPolygon}","page":"VPolygon","title":"LazySets.API.linear_map","text":"linear_map(M::AbstractMatrix, P::VPolygon; [apply_convex_hull]::Bool=false)\n\nConcrete linear map of a polygon in vertex representation.\n\nInput\n\nM                 – matrix\nP                 – polygon in vertex representation\napply_convex_hull – (optional; default: false) flag to apply a                        convex-hull operation (only relevant for                        higher-dimensional maps)\n\nOutput\n\nThe type of the result depends on the dimension. in 1D it is an interval, in 2D it is a VPolygon, and in all other cases it is a VPolytope.\n\nAlgorithm\n\nThis implementation uses the internal _linear_map_vrep method.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-VPolygon","page":"VPolygon","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.API.σ-Tuple{AbstractVector, VPolygon}","page":"VPolygon","title":"LazySets.API.σ","text":"Extended help\n\nσ(d::AbstractVector, P::VPolygon)\n\nOutput\n\nIf the direction has norm zero, the first vertex is returned.\n\nAlgorithm\n\nThis implementation uses a binary search algorithm when the polygon has more than 10 vertices and a brute-force search when it has 10 or fewer vertices. The brute-force search compares the projection of each vector along the given direction and runs in O(n) where n is the number of vertices. The binary search runs in O(log n) and we follow this implementation based on an algorithm described in O’Rourke [O’R98].\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.API.intersection-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-sets-VPolygon","page":"VPolygon","title":"LazySets.API.intersection","text":"intersection(X::LazySet, Y::LazySet)\n\nCompute the intersection of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the intersection X  Y.\n\nNotes\n\nThe intersection of two sets X and Y is defined as\n\n    X  Y = x mid x  X text and  x  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.API.intersection-Tuple{VPolygon, VPolygon}","page":"VPolygon","title":"LazySets.API.intersection","text":"Extended help\n\nintersection(P1::VPolygon, P2::VPolygon; apply_convex_hull::Bool=true)\n\nOutput\n\nA VPolygon, or an EmptySet if the intersection is empty.\n\nAlgorithm\n\nThis function applies the Sutherland–Hodgman polygon clipping algorithm. The implementation is based on the one found in rosetta code.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.API.minkowski_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-sets-VPolygon","page":"VPolygon","title":"LazySets.API.minkowski_sum","text":"minkowski_sum(X::LazySet, Y::LazySet)\n\nCompute the Minkowski sum of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the Minkowski sum X  Y.\n\nNotes\n\nThe Minkowski sum of two sets X and Y is defined as\n\n    X  Y = x + y mid x  X y  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.API.minkowski_sum-Tuple{VPolygon, VPolygon}","page":"VPolygon","title":"LazySets.API.minkowski_sum","text":"Extended help\n\nminkowski_sum(P::VPolygon, Q::VPolygon)\n\nAlgorithm\n\nWe treat each edge of the polygons as a vector, attaching them in polar order (attaching the tail of the next vector to the head of the previous vector). The resulting polygonal chain will be a polygon, which is the Minkowski sum of the given polygons. This algorithm assumes that the vertices of P and Q are sorted in counter-clockwise fashion and has linear complexity O(m+n), where m and n are the number of vertices of P and Q, respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"constraints_list\nextrema\nextrema\nhigh\nhigh\nisoperationtype\nlow\nlow\nvertices_list\npermute\nproject\ntranslate\ntranslate!\nconvex_hull","category":"page"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"chebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nsample\nscale\nρ\ncartesian_product\nexact_sum\n≈\n==\nisequivalent\n⊂\nminkowski_difference","category":"page"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"ispolyhedral","category":"page"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"isbounded\nisboundedtype\nisempty\nisuniversal\nisdisjoint\n⊆","category":"page"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"Inherited from AbstractPolygon:","category":"page"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"dim\nvolume","category":"page"},{"location":"man/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"In this section we review the recommended setup to start working with this package.","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Pages = [\"getting_started.md\"]","category":"page"},{"location":"man/getting_started/#Setup","page":"Getting Started","title":"Setup","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"This package requires Julia v1.0 or later. Refer to the official documentation on how to install it for your system. Below we explain the steps for setting up LazySets on your system and checking that it builds correctly.","category":"page"},{"location":"man/getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"To install LazySets, use the following command inside Julia's REPL:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> import Pkg; Pkg.add(\"LazySets\")","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"or replace add by develop if you want to develop the code.","category":"page"},{"location":"man/getting_started/#Building-the-package","page":"Getting Started","title":"Building the package","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Use the following command from Julia's REPL:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using LazySets","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"This should precompile the package and make it available afterward.","category":"page"},{"location":"man/getting_started/#Optional-dependencies","page":"Getting Started","title":"Optional dependencies","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"An optional dependency is a package that is not required to compile and use LazySets.jl, although some extra functionality is available provided that you load that package. For example, if you want to work with sets defined using simple algebraic expressions you can install Symbolics.jl as usual with the package manager, ] add Symbolics, then load it together with LazySets to have new functionality.","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using LazySets, Symbolics\n\njulia> var = @variables x[1:10]\n(Num[x₁, x₂, x₃, x₄, x₅, x₆, x₇, x₈, x₉, x₁₀],)\n\njulia> Hyperplane(x[1] + x[2] == 1/2, var)\nHyperplane{Float64,Array{Float64,1}}([1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 0.5)","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"defines the hyperplane H   x  ℝ^10  x_1 + x_2 = 12. The Hyperplane constructor (and other constructors) automatically work with Symbolics's variables once using Symbolics is ran in your session.","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"The full list of optional dependencies can be found in section Optional Features.","category":"page"},{"location":"man/getting_started/#Running-the-unit-tests","page":"Getting Started","title":"Running the unit tests","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"To run the full test suite, do","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"] test LazySets","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Please note that it is required that you first install all the optional dependencies as specified in Installing all dependencies. It is possible to use optional flags to select a portion of tests to be run. See the script test/runtests.jl for details.","category":"page"},{"location":"lib/lazy_operations/UnionSet/#Union","page":"UnionSet","title":"Union","text":"","category":"section"},{"location":"lib/lazy_operations/UnionSet/#def_UnionSet","page":"UnionSet","title":"Binary set union (UnionSet)","text":"","category":"section"},{"location":"lib/lazy_operations/UnionSet/#LazySets.UnionSet","page":"UnionSet","title":"LazySets.UnionSet","text":"UnionSet{N, S1<:LazySet{N}, S2<:LazySet{N}} <: LazySet{N}\n\nType that represents the set union of two sets.\n\nFields\n\nX – set\nY – set\n\nNotes\n\nThe union of convex sets is typically not convex.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/UnionSet/#Base.:∪-Tuple{LazySet, LazySet}","page":"UnionSet","title":"Base.:∪","text":"∪\n\nAlias for UnionSet.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.swap-Tuple{UnionSet}","page":"UnionSet","title":"LazySets.swap","text":"swap(cup::UnionSet)\n\nReturn a new UnionSet object with the arguments swapped.\n\nInput\n\ncup – union of two sets\n\nOutput\n\nA new UnionSet object with the arguments swapped.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.API.dim-Tuple{UnionSet}","page":"UnionSet","title":"LazySets.API.dim","text":"dim(cup::UnionSet)\n\nReturn the dimension of the union of two sets.\n\nInput\n\ncup – union of two sets\n\nOutput\n\nThe ambient dimension of the union of two sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.API.σ-Tuple{AbstractVector, UnionSet}","page":"UnionSet","title":"LazySets.API.σ","text":"σ(d::AbstractVector, cup::UnionSet; [algorithm]=\"support_vector\")\n\nReturn a support vector of the union of two sets in a given direction.\n\nInput\n\nd         – direction\ncup       – union of two sets\nalgorithm – (optional, default: \"supportvector\"): the algorithm to compute                the support vector; if \"supportvector\", use the support                vector of each argument; if \"support_function\" use the support                function of each argument and evaluate the support vector of                only one of them\n\nOutput\n\nA support vector in the given direction.\n\nAlgorithm\n\nThe support vector of the union of two sets X and Y can be obtained as the vector that maximizes the support function of either X or Y, i.e., it is sufficient to find the argmax(ρ(d X) ρ(d Y)) and evaluate its support vector.\n\nThe default implementation, with option algorithm=\"support_vector\", computes the support vector of X and Y and then compares the support function using a dot product.\n\nIf the support function can be computed more efficiently, the alternative implementation algorithm=\"support_function\" can be used, which evaluates the support function of each set directly and then calls only the support vector of either X or Y.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.API.ρ-Tuple{AbstractVector, UnionSet}","page":"UnionSet","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, cup::UnionSet)\n\nEvaluate the support function of the union of two sets in a given direction.\n\nInput\n\nd   – direction\ncup – union of two sets\n\nOutput\n\nThe evaluation of the support function in the given direction.\n\nAlgorithm\n\nThe support function of the union of two sets X and Y evaluates to the maximum of the support-function evaluations of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.API.an_element-Tuple{UnionSet}","page":"UnionSet","title":"LazySets.API.an_element","text":"an_element(cup::UnionSet)\n\nReturn some element of the union of two sets.\n\nInput\n\ncup – union of two sets\n\nOutput\n\nAn element in the union of two sets.\n\nAlgorithm\n\nWe use an_element on the first non-empty wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#Base.:∈-Tuple{AbstractVector, UnionSet}","page":"UnionSet","title":"Base.:∈","text":"∈(x::AbstractVector, cup::UnionSet)\n\nCheck whether a given point is contained in the union of two sets.\n\nInput\n\nx   – point/vector\ncup – union of two sets\n\nOutput\n\ntrue iff x  cup.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#Base.isempty-Tuple{UnionSet}","page":"UnionSet","title":"Base.isempty","text":"isempty(cup::UnionSet)\n\nCheck whether the union of two sets is empty.\n\nInput\n\ncup – union of two sets\n\nOutput\n\ntrue iff the union is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.API.isbounded-Tuple{UnionSet}","page":"UnionSet","title":"LazySets.API.isbounded","text":"isbounded(cup::UnionSet)\n\nCheck whether the union of two sets is bounded.\n\nInput\n\ncup – union of two sets\n\nOutput\n\ntrue iff the union is bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.API.vertices_list-Tuple{UnionSet}","page":"UnionSet","title":"LazySets.API.vertices_list","text":"vertices_list(cup::UnionSet; [apply_convex_hull]::Bool=false,\n              [backend]=nothing)\n\nReturn the list of vertices of the union of two sets.\n\nInput\n\ncup               – union of two sets\napply_convex_hull – (optional, default: false) if true, post-process                        the vertices using a convex-hull algorithm\nbackend           – (optional, default: nothing) backend for computing                        the convex hull (see argument apply_convex_hull)\n\nOutput\n\nThe list of vertices, possibly reduced to the list of vertices of the convex hull.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#def_UnionSetArray","page":"UnionSet","title":"n-ary set union (UnionSetArray)","text":"","category":"section"},{"location":"lib/lazy_operations/UnionSet/#LazySets.UnionSetArray","page":"UnionSet","title":"LazySets.UnionSetArray","text":"UnionSetArray{N, S<:LazySet{N}} <: LazySet{N}\n\nType that represents the set union of a finite number of sets.\n\nFields\n\narray – array of sets\n\nNotes\n\nThe union of convex sets is typically not convex.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/UnionSet/#LazySets.UnionSet!","page":"UnionSet","title":"LazySets.UnionSet!","text":"UnionSet!(X, Y)\n\nConvenience function to compute the lazy union and modify UnionSetArrays in-place.\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/UnionSet/#LazySets.API.dim-Tuple{UnionSetArray}","page":"UnionSet","title":"LazySets.API.dim","text":"dim(cup::UnionSetArray)\n\nReturn the dimension of the union of a finite number of sets.\n\nInput\n\ncup – union of a finite number of sets\n\nOutput\n\nThe ambient dimension of the union of a finite number of sets, or 0 if there is no set in the array.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.array-Tuple{UnionSetArray}","page":"UnionSet","title":"LazySets.array","text":"array(cup::UnionSetArray)\n\nReturn the array of the union of a finite number of sets.\n\nInput\n\ncup – union of a finite number of sets\n\nOutput\n\nThe array of the union.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.API.σ-Tuple{AbstractVector, UnionSetArray}","page":"UnionSet","title":"LazySets.API.σ","text":"σ(d::AbstractVector, cup::UnionSetArray; [algorithm]=\"support_vector\")\n\nReturn a support vector of the union of a finite number of sets in a given direction.\n\nInput\n\nd         – direction\ncup       – union of a finite number of sets\nalgorithm – (optional, default: \"supportvector\"): the algorithm to compute                the support vector; if \"supportvector\", use the support                vector of each argument; if \"support_function\", use the support                function of each argument and evaluate the support vector of                only one of them\n\nOutput\n\nA support vector in the given direction.\n\nAlgorithm\n\nThe support vector of the union of a finite number of sets X₁ X₂  can be obtained as the vector that maximizes the support function, i.e., it is sufficient to find the argmax(ρ(d X₂) ρ(d X₂) ) and evaluate its support vector.\n\nThe default implementation, with option algorithm=\"support_vector\", computes the support vector of all X₁ X₂  and then compares the support function using the dot product.\n\nIf the support function can be computed more efficiently, the alternative implementation algorithm=\"support_function\" can be used, which evaluates the support function of each set directly and then calls only the support vector of one of the Xᵢ.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.API.ρ-Tuple{AbstractVector, UnionSetArray}","page":"UnionSet","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, cup::UnionSetArray)\n\nEvaluate the support function of the union of a finite number of sets in a given direction.\n\nInput\n\nd   – direction\ncup – union of a finite number of sets\n\nOutput\n\nThe evaluation of the support function in the given direction.\n\nAlgorithm\n\nThe support function of the union of a finite number of sets X₁ X₂  can be obtained as the maximum of ρ(d X₂) ρ(d X₂) .\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.API.an_element-Tuple{UnionSetArray}","page":"UnionSet","title":"LazySets.API.an_element","text":"an_element(cup::UnionSetArray)\n\nReturn some element of the union of a finite number of sets.\n\nInput\n\ncup – union of a finite number of sets\n\nOutput\n\nAn element in the union of a finite number of sets.\n\nAlgorithm\n\nWe use an_element on the first non-empty wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#Base.:∈-Tuple{AbstractVector, UnionSetArray}","page":"UnionSet","title":"Base.:∈","text":"∈(x::AbstractVector, cup::UnionSetArray)\n\nCheck whether a given point is contained in the union of a finite number of sets.\n\nInput\n\nx   – point/vector\ncup – union of a finite number of sets\n\nOutput\n\ntrue iff x  cup.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#Base.isempty-Tuple{UnionSetArray}","page":"UnionSet","title":"Base.isempty","text":"isempty(cup::UnionSetArray)\n\nCheck whether the union of a finite number of sets is empty.\n\nInput\n\ncup – union of a finite number of sets\n\nOutput\n\ntrue iff the union is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.API.isbounded-Tuple{UnionSetArray}","page":"UnionSet","title":"LazySets.API.isbounded","text":"isbounded(cup::UnionSetArray)\n\nCheck whether the union of a finite number of sets is bounded.\n\nInput\n\ncup – union of a finite number of sets\n\nOutput\n\ntrue iff the union is bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.API.vertices_list-Tuple{UnionSetArray}","page":"UnionSet","title":"LazySets.API.vertices_list","text":"vertices_list(cup::UnionSetArray; [apply_convex_hull]::Bool=false,\n              [backend]=nothing)\n\nReturn a list of vertices of the union of a finite number of sets.\n\nInput\n\ncup               – union of a finite number of sets\napply_convex_hull – (optional, default: false) if true, post-process                        the vertices using a convex-hull algorithm\nbackend           – (optional, default: nothing) backend for computing                        the convex hull (see argument apply_convex_hull)\n\nOutput\n\nA list of vertices, possibly reduced to the list of vertices of the convex hull.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","text":"Pages = [\"AbstractCentrallySymmetricPolytope.md\"]\nDepth = 3","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/#def_AbstractCentrallySymmetricPolytope","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","text":"","category":"section"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","text":"A centrally symmetric polytope is a combination of two other interfaces: Centrally symmetric sets and Polytope.","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/#LazySets.AbstractCentrallySymmetricPolytope","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"LazySets.AbstractCentrallySymmetricPolytope","text":"AbstractCentrallySymmetricPolytope{N} <: AbstractPolytope{N}\n\nAbstract type for centrally symmetric, polytopic sets. It combines the AbstractCentrallySymmetric and AbstractPolytope interfaces. Such a type combination is necessary as long as Julia does not support multiple inheritance.\n\nNotes\n\nEvery concrete AbstractCentrallySymmetricPolytope must define the following AbstractCentrallySymmetric method, in addition to the AbstractPolytope methods:\n\ncenter(::AbstractCentrallySymmetricPolytope) – return the center point\n\nThe subtypes of AbstractCentrallySymmetricPolytope (including abstract interfaces):\n\njulia> subtypes(AbstractCentrallySymmetricPolytope)\n2-element Vector{Any}:\n AbstractZonotope\n Ball1\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","text":"This interface requires to implement the required functions of both the AbstractCentrallySymmetric and AbstractPolytope interfaces:","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/#LazySets.API.center-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractCentrallySymmetricPolytope","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"LazySets.API.center","text":"center(X::LazySet)\n\nCompute the center of a centrally symmetric set.\n\nInput\n\nX – centrally symmetric set\n\nOutput\n\nA vector with the center, or midpoint, of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/#LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractCentrallySymmetricPolytope","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"LazySets.API.constraints_list","text":"constraints_list(X::LazySet)\n\nCompute a list of linear constraints of a polyhedral set.\n\nInput\n\nX – polyhedral set\n\nOutput\n\nA list of the linear constraints of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/#LazySets.API.vertices_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractCentrallySymmetricPolytope","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"LazySets.API.vertices_list","text":"vertices_list(X::LazySet)\n\nCompute a list of vertices of a polytopic set.\n\nInput\n\nX – polytopic set\n\nOutput\n\nA list of the vertices of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","text":"This interface shares the following functions with AbstractCentrallySymmetric:","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/#LazySets.API.an_element-Tuple{AbstractCentrallySymmetricPolytope}","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"LazySets.API.an_element","text":"Extended help\n\nan_element(S::AbstractCentrallySymmetricPolytope)\n\nOutput\n\nThe center of the centrally symmetric set.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/#Base.extrema-Tuple{AbstractCentrallySymmetricPolytope}","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Base.extrema","text":"Extended help\n\nextrema(S::AbstractCentrallySymmetricPolytope)\n\nNotes\n\nThe result is equivalent to (low(S), high(S)).\n\nAlgorithm\n\nWe compute high(S) and then compute the lowest coordinates with the help of center(S) (which is assumed to be cheaper to obtain).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/#Base.extrema-Tuple{AbstractCentrallySymmetricPolytope, Int64}","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Base.extrema","text":"Extended help\n\nextrema(S::AbstractCentrallySymmetricPolytope, i::Int)\n\nNotes\n\nThe result is equivalent to (low(S, i), high(S, i)).\n\nAlgorithm\n\nWe compute high(S, i) and then compute the lowest coordinates with the help of center(S, i) (which is assumed to be cheaper to obtain).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/#LazySets.API.isuniversal","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"LazySets.API.isuniversal","text":"Extended help\n\nisuniversal(S::AbstractCentrallySymmetricPolytope, [witness]::Bool=false)\n\nAlgorithm\n\nA witness is obtained by computing the support vector in direction d = [1, 0, …, 0] and adding d on top.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","text":"Undocumented implementations shared with AbstractCentrallySymmetric:","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","text":"center\ndim\nisempty","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","text":"Inherited from LazySet:","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nlinear_map\nsample\nscale\nρ\ntranslate\ncartesian_product\nconvex_hull\nexact_sum\n≈\n==\nisequivalent\n⊂\nminkowski_difference","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","text":"high\nhigh\nispolyhedral\nlow\nlow\n∈\nproject\nintersection\nisdisjoint","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","text":"isbounded\nisboundedtype\nvolume\n⊆\nminkowski_sum","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/#Implementations","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/AbstractCentrallySymmetricPolytope/","page":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","title":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","text":"Manhattan-norm ball (Ball1)","category":"page"},{"location":"lib/conversion/#Conversion-between-set-representations","page":"Conversions between set representations","title":"Conversion between set representations","text":"","category":"section"},{"location":"lib/conversion/","page":"Conversions between set representations","title":"Conversions between set representations","text":"This section of the manual lists the conversion functions between set representations.","category":"page"},{"location":"lib/conversion/","page":"Conversions between set representations","title":"Conversions between set representations","text":"Pages = [\"conversion.md\"]\nDepth = 3","category":"page"},{"location":"lib/conversion/#Base.convert-Union{Tuple{IN}, Tuple{N}, Tuple{Type{Interval}, Rectification{N, IN}}} where {N, IN<:Interval}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Interval}, r::Rectification{N, IN}) where {N, IN<:Interval}\n\nConvert a rectification of an interval to an interval.\n\nInput\n\nInterval – target type\nr        – rectification of an interval\n\nOutput\n\nAn Interval.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{IT}, Tuple{N}, Tuple{Type{Interval}, MinkowskiSum{N, IT, IT}}} where {N, IT<:Interval}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Interval}, ms::MinkowskiSum{N, IT, IT}) where {N, IT<:Interval}\n\nConvert the Minkowski sum of two intervals to an interval.\n\nInput\n\nInterval – target type\nms       – Minkowski sum of two intervals\n\nOutput\n\nAn interval.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Hyperrectangle}, CartesianProduct{N, HN1, HN2}}} where {N, HN1<:AbstractHyperrectangle, HN2<:AbstractHyperrectangle}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Hyperrectangle}, cp::CartesianProduct{N, HN1, HN2})\n    where {N, HN1<:AbstractHyperrectangle, HN2<:AbstractHyperrectangle}\n\nConvert the Cartesian product of two hyperrectangular sets to a single hyperrectangle.\n\nInput\n\nHyperrectangle – target type\nS              – Cartesian product of two hyperrectangular sets\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nThe result is obtained by concatenating the center and radius of each hyperrectangle. This implementation uses the center and radius_hyperrectangle methods.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Hyperrectangle}, CartesianProductArray{N, HN}}} where {N, HN<:AbstractHyperrectangle}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Hyperrectangle}, cpa::CartesianProductArray{N, HN})\n    where {N, HN<:AbstractHyperrectangle}\n\nConvert the Cartesian product of a finite number of hyperrectangular sets to a single hyperrectangle.\n\nInput\n\nHyperrectangle – target type\nS              – Cartesian product array of hyperrectangular set\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nThis implementation uses the center and radius_hyperrectangle methods of AbstractHyperrectangle.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{IN}, Tuple{N}, Tuple{Type{Hyperrectangle}, CartesianProductArray{N, IN}}} where {N, IN<:Interval}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Hyperrectangle},\n        cpa::CartesianProductArray{N, IN}) where {N, IN<:Interval}\n\nConvert the Cartesian product of a finite number of intervals to a single hyperrectangle.\n\nInput\n\nHyperrectangle – target type\nS              – Cartesian product array of intervals\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nThis implementation uses the min and max methods of Interval to reduce the allocations and improve performance (see LazySets#1143).\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{AH}, Tuple{N}, Tuple{Type{Hyperrectangle}, Rectification{N, AH}}} where {N, AH<:AbstractHyperrectangle}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Hyperrectangle}, r::Rectification{N, AH})\n    where {N, AH<:AbstractHyperrectangle}\n\nConvert a rectification of a hyperrectangle to a hyperrectangle.\n\nInput\n\nHyperrectangle – target type\nr              – rectification of a hyperrectangle\n\nOutput\n\nA Hyperrectangle.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{HPolygon}, LazySet}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{HPolygon}, X::LazySet; [check_boundedness]::Bool=true,\n        prune::Bool=true)\n\nConvert a two-dimensional polytopic set to a polygon in constraint representation.\n\nInput\n\nHPolygon             – target type\nX                 – two-dimensional polytopic set\ncheck_boundedness – (optional, default !isboundedtype(typeof(X))) if                        true check whether the set X is bounded before                        creating the polygon\nprune             – (optional, default: true) flag for removing redundant                        constraints in the end\n\nOutput\n\nA polygon in constraint representation.\n\nAlgorithm\n\nWe compute the list of constraints of X, then instantiate the polygon.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{HPolygon}, VPolygon}","page":"Conversions between set representations","title":"Base.convert","text":"convert(T::Type{HPolygon}, P::VPolygon)\n\nConvert a polygon in vertex representation to a polygon in constraint representation.\n\nInput\n\nHPolygon – target type\nP     – polygon in vertex representation\n\nOutput\n\nA polygon in constraint representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{N}, Tuple{Type{HPolygon}, LineSegment{N, VN} where VN<:AbstractVector{N}}} where N","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{HPolygon}, L::LineSegment{N}) where {N}\n\nConvert a line segment to a polygon in constraint representation.\n\nInput\n\nHPolygon – target type\nL     – line segment\nprune – (optional, default: false) flag for removing redundant            constraints in the end\n\nOutput\n\nA flat polygon in constraint representation with the minimal number of constraints (four).\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{HPolygonOpt}, LazySet}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{HPolygonOpt}, X::LazySet; [check_boundedness]::Bool=true,\n        prune::Bool=true)\n\nConvert a two-dimensional polytopic set to a polygon in constraint representation.\n\nInput\n\nHPolygonOpt             – target type\nX                 – two-dimensional polytopic set\ncheck_boundedness – (optional, default !isboundedtype(typeof(X))) if                        true check whether the set X is bounded before                        creating the polygon\nprune             – (optional, default: true) flag for removing redundant                        constraints in the end\n\nOutput\n\nA polygon in constraint representation.\n\nAlgorithm\n\nWe compute the list of constraints of X, then instantiate the polygon.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{HPolygonOpt}, VPolygon}","page":"Conversions between set representations","title":"Base.convert","text":"convert(T::Type{HPolygonOpt}, P::VPolygon)\n\nConvert a polygon in vertex representation to a polygon in constraint representation.\n\nInput\n\nHPolygonOpt – target type\nP     – polygon in vertex representation\n\nOutput\n\nA polygon in constraint representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{N}, Tuple{Type{HPolygonOpt}, LineSegment{N, VN} where VN<:AbstractVector{N}}} where N","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{HPolygonOpt}, L::LineSegment{N}) where {N}\n\nConvert a line segment to a polygon in constraint representation.\n\nInput\n\nHPolygonOpt – target type\nL     – line segment\nprune – (optional, default: false) flag for removing redundant            constraints in the end\n\nOutput\n\nA flat polygon in constraint representation with the minimal number of constraints (four).\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{VPolygon}, AbstractHPolygon}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{VPolygon}, P::AbstractHPolygon)\n\nConvert a polygon in constraint representation to a polygon in vertex representation.\n\nInput\n\nVPolygon – target type\nP        – polygon in constraint representation\n\nOutput\n\nA polygon in vertex representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{ZN}, Tuple{N}, Tuple{Type{Zonotope}, LinearMap{N, ZN, NM} where NM}} where {N, ZN<:AbstractZonotope}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Zonotope}, S::LinearMap{N, ZN})\n    where {N, ZN<:AbstractZonotope}\n\nConvert the lazy linear map of a zonotopic set to a zonotope.\n\nInput\n\nZonotope – target type\nS        – linear map of a zonotopic set\n\nOutput\n\nA zonotope.\n\nAlgorithm\n\nThis method first applies the (concrete) linear map to the zonotopic set and then converts the result to a Zonotope type.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope}, LinearMap{N, CartesianProduct{N, HN1, HN2}, NM} where NM}} where {N, HN1<:AbstractHyperrectangle, HN2<:AbstractHyperrectangle}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Zonotope}, S::LinearMap{N, CartesianProduct{N, HN1, HN2}}\n       ) where {N, HN1<:AbstractHyperrectangle,\n                HN2<:AbstractHyperrectangle}\n\nConvert the lazy linear map of the Cartesian product of two hyperrectangular sets to a zonotope.\n\nInput\n\nZonotope – target type\nS        – linear map of the Cartesian product of hyperrectangular sets\n\nOutput\n\nA zonotope.\n\nAlgorithm\n\nThis method first converts the Cartesian product to a zonotope, and then applies the (concrete) linear map to the zonotope.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope}, LinearMap{N, CartesianProductArray{N, HN}, NM} where NM}} where {N, HN<:AbstractHyperrectangle}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Zonotope},S::LinearMap{N, CartesianProductArray{N, HN}})\n    where {N, HN<:AbstractHyperrectangle}\n\nConvert the lazy linear map of the Cartesian product of a finite number of hyperrectangular sets to a zonotope.\n\nInput\n\nZonotope – target type\nS        – linear map of a CartesianProductArray of hyperrectangular sets\n\nOutput\n\nA zonotope.\n\nAlgorithm\n\nThis method first converts the Cartesian product array to a zonotope, and then applies the (concrete) linear map to the zonotope.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{ZN2}, Tuple{ZN1}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProduct{N, ZN1, ZN2}}} where {N, ZN1<:AbstractZonotope, ZN2<:AbstractZonotope}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Zonotope}, cp::CartesianProduct{N, ZN1, ZN2}\n       ) where {N, ZN1<:AbstractZonotope, ZN2<:AbstractZonotope}\n\nConvert the Cartesian product of two zonotopic sets to a new zonotope.\n\nInput\n\nZonotope – target type\nS        – Cartesian product of two zonotopic sets\n\nOutput\n\nA zonotope.\n\nAlgorithm\n\nThe Cartesian product is obtained by:\n\nConcatenating the centers of each input zonotope.\nArranging the generators in block-diagonal fashion, and filled with zeros in the off-diagonal; for this reason, the generator matrix of the returned zonotope is built as a sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProduct{N, HN1, HN2}}} where {N, HN1<:AbstractHyperrectangle, HN2<:AbstractHyperrectangle}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Zonotope}, cp::CartesianProduct{N, HN1, HN2}) where {N,\n        HN1<:AbstractHyperrectangle, HN2<:AbstractHyperrectangle}\n\nConvert the Cartesian product of two hyperrectangular sets to a zonotope.\n\nInput\n\nZonotope – target type\ncp       – Cartesian product of two hyperrectangular sets\n\nOutput\n\nThis method falls back to the conversion of the Cartesian product to a single hyperrectangle, and then from a hyperrectangle to a zonotope.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{AZ}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProductArray{N, AZ}}} where {N, AZ<:AbstractZonotope}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Zonotope}, cpa::CartesianProductArray{N, AZ})\n    where {N, AZ<:AbstractZonotope}\n\nConvert a Cartesian product array of zonotopic sets to a zonotope.\n\nInput\n\nZonotope – target type\ncpa       – Cartesian product array of zonotopic sets\n\nOutput\n\nA zonotope with sparse matrix representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProductArray{N, HN}}} where {N, HN<:AbstractHyperrectangle}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Zonotope}, cpa::CartesianProductArray{N, HN})\n    where {N, HN<:AbstractHyperrectangle}\n\nConvert the Cartesian product array of hyperrectangular sets to a zonotope.\n\nInput\n\nZonotope – target type\ncpa      – Cartesian product array of hyperrectangular sets\n\nOutput\n\nA zonotope.\n\nAlgorithm\n\nThis method falls back to the conversion of the Cartesian product to a single hyperrectangle, and then from a hyperrectangle to a zonotope.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProduct{N, Interval{N}, Interval{N}}}, AbstractHyperrectangle{N}}} where N","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{CartesianProduct{N, Interval{N}, Interval{N}}},\n        H::AbstractHyperrectangle{N}) where {N}\n\nConvert a two-dimensional hyperrectangle to the Cartesian product of two intervals.\n\nInput\n\nCartesianProduct – target type\nH                – hyperrectangle\n\nOutput\n\nThe Cartesian product of two intervals.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProductArray{N, Interval{N}}}, AbstractHyperrectangle{N}}} where N","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{CartesianProductArray{N, Interval{N}}},\n        H::AbstractHyperrectangle{N}) where {N}\n\nConvert a hyperrectangle to the Cartesian product array of intervals.\n\nInput\n\nCartesianProductArray – target type\nH                     – hyperrectangle\n\nOutput\n\nThe Cartesian product of a finite number of intervals.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{ST}, Tuple{N}, Tuple{Type{MinkowskiSumArray}, MinkowskiSum{N, ST, MinkowskiSumArray{N, ST}}}} where {N, ST}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{MinkowskiSumArray},\n        X::MinkowskiSum{N, ST, MinkowskiSumArray{N, ST}}) where {N, ST}\n\nConvert the Minkowski sum of a Minkowski sum array to a Minkowski sum array.\n\nInput\n\nMinkowskiSumArray  – target type\nX                  – Minkowski sum of a Minkowski sum array\n\nOutput\n\nA Minkowski sum array.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{N}, Tuple{Type{AffineMap{N, PT, N, MN, VN} where {N, VN<:AbstractVector{N}, MN<:AbstractMatrix{N}, PT<:AbstractPolyhedron{N}}}, AbstractPolyhedron{N}}} where N","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{STAR}, P::AbstractPolyhedron{N}) where {N}\n\nConvert a polyhedral set to a star set represented as a lazy affine map.\n\nInput\n\nSTAR – target type\nP    – polyhedral set\n\nOutput\n\nA star set.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{AffineMap{N, PT, N, MN, VN} where {N, VN<:AbstractVector{N}, MN<:AbstractMatrix{N}, PT<:AbstractPolyhedron{N}}}, Star}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{STAR}, X::Star)\n\nConvert a star set to its equivalent representation as a lazy affine map.\n\nInput\n\nSTAR – target type\nX    – star set\n\nOutput\n\nA star set.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{SimpleSparsePolynomialZonotope}, AbstractZonotope}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{SimpleSparsePolynomialZonotope}, Z::AbstractZonotope)\n\nConvert a zonotope to a simple sparse polynomial zonotope.\n\nInput\n\nSimpleSparsePolynomialZonotope – target type\nZ                              – zonotopic set\n\nOutput\n\nA simple sparse polynomial zonotope.\n\nAlgorithm\n\nThis method implements Kochdumper and Althoff [KA21], Proposition 3.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{SimpleSparsePolynomialZonotope}, AbstractSparsePolynomialZonotope}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{SimpleSparsePolynomialZonotope}, SPZ::AbstractSparsePolynomialZonotope)\n\nConvert a sparse polynomial zonotope to simple sparse polynomial zonotope.\n\nInput\n\nSimpleSparsePolynomialZonotope – target type\nSPZ                            – sparse polynomial zonotope\n\nOutput\n\nA simple sparse polynomial zonotope.\n\nAlgorithm\n\nThe method implements Kochdumper [Koc22], Proposition 3.1.4.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{N}, Tuple{Type{SparsePolynomialZonotope}, AbstractZonotope{N}}} where N","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{SparsePolynomialZonotope}, Z::AbstractZonotope{N}) where {N}\n\nConvert a zonotope to sparse polynomial zonotope.\n\nInput\n\nSparsePolynomialZonotope – target type\nZ                        – zonotopic set\n\nOutput\n\nA sparse polynomial zonotope.\n\nAlgorithm\n\nThe method implements Kochdumper [Koc22], Proposition 3.1.19.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{N}, Tuple{Type{SparsePolynomialZonotope}, SimpleSparsePolynomialZonotope{N, VN, MN} where {VN<:AbstractVector{N}, MN<:AbstractMatrix{N}}}} where N","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{SparsePolynomialZonotope}, SSPZ::SimpleSparsePolynomialZonotope)\n\nConvert a simple sparse polynomial zonotope to a sparse polynomial zonotope.\n\nInput\n\nSparsePolynomialZonotope – target type\nSSPZ                     – simple sparse polynomial zonotope\n\nOutput\n\nA sparse polynomial zonotope.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHPolygon/","page":"Polygons in constraint representation (AbstractHPolygon)","title":"Polygons in constraint representation (AbstractHPolygon)","text":"Pages = [\"AbstractHPolygon.md\"]\nDepth = 3","category":"page"},{"location":"lib/interfaces/AbstractHPolygon/#def_AbstractHPolygon","page":"Polygons in constraint representation (AbstractHPolygon)","title":"Polygons in constraint representation (AbstractHPolygon)","text":"","category":"section"},{"location":"lib/interfaces/AbstractHPolygon/","page":"Polygons in constraint representation (AbstractHPolygon)","title":"Polygons in constraint representation (AbstractHPolygon)","text":"An HPolygon is a polygon in H-representation (or constraint representation).","category":"page"},{"location":"lib/interfaces/AbstractHPolygon/#LazySets.AbstractHPolygon","page":"Polygons in constraint representation (AbstractHPolygon)","title":"LazySets.AbstractHPolygon","text":"AbstractHPolygon{N} <: AbstractPolygon{N}\n\nAbstract type for polygons in constraint representation.\n\nNotes\n\nSee HPolygon for a standard implementation of this interface.\n\nAll subtypes must satisfy the invariant that constraints are sorted counter-clockwise.\n\nEvery concrete AbstractHPolygon must have the following fields:\n\nconstraints::Vector{HalfSpace{N,AbstractVector{N}}} – constraints vector\n\nThe subtypes of AbstractHPolygon:\n\njulia> subtypes(AbstractHPolygon)\n2-element Vector{Any}:\n HPolygon\n HPolygonOpt\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/AbstractHPolygon/","page":"Polygons in constraint representation (AbstractHPolygon)","title":"Polygons in constraint representation (AbstractHPolygon)","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/AbstractHPolygon/#LazySets.API.an_element-Tuple{AbstractHPolygon}","page":"Polygons in constraint representation (AbstractHPolygon)","title":"LazySets.API.an_element","text":"an_element(P::AbstractHPolygon)\n\nReturn some element of a polygon in constraint representation.\n\nInput\n\nP – polygon in constraint representation\n\nOutput\n\nA vertex of the polygon in constraint representation (the first one in the order of the constraints).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHPolygon/#LazySets.API.constraints_list-Tuple{AbstractHPolygon}","page":"Polygons in constraint representation (AbstractHPolygon)","title":"LazySets.API.constraints_list","text":"constraints_list(P::AbstractHPolygon)\n\nReturn the list of constraints defining a polygon in constraint representation.\n\nInput\n\nP – polygon in constraint representation\n\nOutput\n\nThe list of constraints of the polygon. The implementation guarantees that the constraints are sorted counter-clockwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHPolygon/#LazySets.API.isbounded","page":"Polygons in constraint representation (AbstractHPolygon)","title":"LazySets.API.isbounded","text":"isbounded(P::AbstractHPolygon, [use_type_assumption]::Bool=true)\n\nDetermine whether a polygon in constraint representation is bounded.\n\nInput\n\nP                   – polygon in constraint representation\nuse_type_assumption – (optional, default: true) flag for ignoring the                          type assumption that polygons are bounded\n\nOutput\n\ntrue if use_type_assumption is activated. Otherwise, true iff P is bounded.\n\nAlgorithm\n\nIf !use_type_assumption, we use _isbounded_unit_dimensions.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractHPolygon/#LinearAlgebra.normalize-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}, Tuple{AbstractHPolygon{N}, Real}} where N","page":"Polygons in constraint representation (AbstractHPolygon)","title":"LinearAlgebra.normalize","text":"normalize(P::AbstractHPolygon{N}, p::Real=N(2)) where {N}\n\nNormalize a polygon in constraint representation.\n\nInput\n\nP – polygon in constraint representation\np – (optional, default: 2) norm\n\nOutput\n\nA new polygon in constraint representation whose normal directions a_i are normalized, i.e., such that a_i_p = 1 holds.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHPolygon/#Base.rand-Union{Tuple{Type{HPOLYGON}}, Tuple{HPOLYGON}} where HPOLYGON<:AbstractHPolygon","page":"Polygons in constraint representation (AbstractHPolygon)","title":"Base.rand","text":"rand(::Type{HPOLYGON}; [N]::Type=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing,\n     [num_constraints]::Int=-1) where {HPOLYGON<:AbstractHPolygon}\n\nCreate a random polygon in constraint representation.\n\nInput\n\nHPOLYGON        – type for dispatch\nN               – (optional, default: Float64) numeric type\ndim             – (optional, default: 2) dimension\nrng             – (optional, default: GLOBAL_RNG) random number generator\nseed            – (optional, default: nothing) seed for reseeding\nnum_constraints – (optional, default: -1) number of constraints of the                      polygon (must be 3 or bigger; see comment below)\n\nOutput\n\nA random polygon in constraint representation.\n\nAlgorithm\n\nWe create a random polygon in vertex representation and convert it to constraint representation. See rand(::Type{VPolygon}). For non-flat polygons the number of vertices and the number of constraints are identical.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHPolygon/#LazySets.remove_redundant_constraints!-Tuple{AbstractHPolygon}","page":"Polygons in constraint representation (AbstractHPolygon)","title":"LazySets.remove_redundant_constraints!","text":"remove_redundant_constraints!(P::AbstractHPolygon)\n\nRemove all redundant constraints of a polygon in constraint representation.\n\nInput\n\nP – polygon in constraint representation\n\nOutput\n\nThe same polygon with all redundant constraints removed.\n\nNotes\n\nSince we only consider bounded polygons and a polygon needs at least three constraints to be bounded, we stop removing redundant constraints if there are three or fewer constraints left. Hence for unbounded polygons the result may be unexpected.\n\nAlgorithm\n\nWe go through all consecutive triples of constraints and check if the one in the middle is redundant. For this we assume that the constraints are sorted.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHPolygon/#LazySets.tohrep-Tuple{HPOLYGON} where HPOLYGON<:AbstractHPolygon","page":"Polygons in constraint representation (AbstractHPolygon)","title":"LazySets.tohrep","text":"tohrep(P::HPOLYGON) where {HPOLYGON<:AbstractHPolygon}\n\nBuild a constraint representation of the given polygon.\n\nInput\n\nP – polygon in constraint representation\n\nOutput\n\nThe identity, i.e., the same polygon instance.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHPolygon/#LazySets.tovrep-Tuple{AbstractHPolygon}","page":"Polygons in constraint representation (AbstractHPolygon)","title":"LazySets.tovrep","text":"tovrep(P::AbstractHPolygon)\n\nBuild a vertex representation of a polygon in constraint representation.\n\nInput\n\nP – polygon in constraint representation\n\nOutput\n\nThe same polygon but in vertex representation, a VPolygon.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHPolygon/#LazySets.API.vertices_list-Tuple{AbstractHPolygon}","page":"Polygons in constraint representation (AbstractHPolygon)","title":"LazySets.API.vertices_list","text":"vertices_list(P::AbstractHPolygon;\n              apply_convex_hull::Bool=true,\n              check_feasibility::Bool=true)\n\nReturn the list of vertices of a polygon in constraint representation.\n\nInput\n\nP                 – polygon in constraint representation\napply_convex_hull – (optional, default: true) flag to post-process the                        intersection of constraints with a convex hull\ncheck_feasibility – (optional, default: true) flag to check whether the                        polygon was empty (required for correctness in case of                        empty polygons)\n\nOutput\n\nList of vertices.\n\nNotes\n\nBy construction an AbstractHPolygon should not contain any redundant vertices. Still the apply_convex_hull argument is activated by default to remove potential duplicate vertices. They can exist due to numeric instability.\n\njulia> p = HPolygon([HalfSpace([1.0, 0.0], 1.0),\n                     HalfSpace([0.0, 1.0], 1.0),\n                     HalfSpace([-1.0, 0.0], -1.0),\n                     HalfSpace([0.0, -1.0], -1.0)]);\n\njulia> vertices_list(p, apply_convex_hull=false)\n4-element Vector{Vector{Float64}}:\n [1.0, 1.0]\n [1.0, 1.0]\n [1.0, 1.0]\n [1.0, 1.0]\n\nIf it is known that each constraint has a \"proper\" distance to the next vertex, this step can be skipped.\n\nAlgorithm\n\nWe compute each vertex as the intersection of consecutive lines defined by the half-spaces. If check_feasibility is active, we then check if the constraints of the polygon were actually feasible (i.e., they pointed in the right direction). For this we compute the average of all vertices and check membership in each constraint.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHPolygon/#LazySets.addconstraint!-Tuple{AbstractHPolygon, HalfSpace}","page":"Polygons in constraint representation (AbstractHPolygon)","title":"LazySets.addconstraint!","text":"addconstraint!(P::AbstractHPolygon, constraint::HalfSpace;\n               [linear_search]::Bool=length(P.constraints) < 10,\n               [prune]::Bool=true)\n\nAdd a linear constraint to a polygon in constraint representation, keeping the constraints sorted by their normal directions.\n\nInput\n\nP             – polygon in constraint representation\nconstraint    – linear constraint to add\nlinear_search – (optional, default:                    length(constraints) < 10) flag to                    choose between linear and binary search\nprune         – (optional, default: true) flag for removing redundant                    constraints in the end\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHPolygon/#LazySets.addconstraint!-Tuple{Vector{<:HalfSpace}, HalfSpace}","page":"Polygons in constraint representation (AbstractHPolygon)","title":"LazySets.addconstraint!","text":"addconstraint!(constraints::Vector{<:HalfSpace}, new_constraint::HalfSpace;\n               [linear_search]::Bool=length(P.constraints) < 10,\n               [prune]::Bool=true)\n\nAdd a linear constraint to a sorted vector of constrains, keeping the constraints sorted by their normal directions.\n\nInput\n\nconstraints    – vector of linear constraints\nnew_constraint – linear constraint to add\nlinear_search  – (optional, default:                     length(constraints) < 10) flag to                     choose between linear and binary search\nprune          – (optional, default: true) flag for removing redundant                     constraints in the end\n\nAlgorithm\n\nIf prune is active, we check if the new constraint is redundant. If the constraint is not redundant, we perform the same check to the left and to the right until we find the first constraint that is not redundant.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHPolygon/#Base.:∈-Tuple{AbstractVector, AbstractHPolygon}","page":"Polygons in constraint representation (AbstractHPolygon)","title":"Base.:∈","text":"∈(x::AbstractVector, P::AbstractHPolygon)\n\nCheck whether a given two-dimensional point is contained in a polygon in constraint representation.\n\nInput\n\nx – two-dimensional point/vector\nP – polygon in constraint representation\n\nOutput\n\ntrue iff x  P.\n\nAlgorithm\n\nThis implementation checks if the point lies inside each constraint.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHPolygon/#LazySets.isredundant-Tuple{HalfSpace, HalfSpace, HalfSpace}","page":"Polygons in constraint representation (AbstractHPolygon)","title":"LazySets.isredundant","text":"isredundant(cmid::HalfSpace, cright::HalfSpace, cleft::HalfSpace)\n\nCheck whether a linear constraint is redundant wrt. two surrounding constraints.\n\nInput\n\ncmid   – linear constraint of concern\ncright – linear constraint to the right (clockwise turn)\ncleft  – linear constraint to the left (counter-clockwise turn)\n\nOutput\n\ntrue iff the constraint is redundant.\n\nAlgorithm\n\nWe first check whether the angle between the surrounding constraints is < 180°, which is a necessary condition (unless the direction is identical to one of the other two constraints). If so, we next check if the angle is 0°, in which case the constraint cmid is redundant unless it is strictly tighter than the other two constraints. If the angle is strictly between 0° and 180°, the constraint cmid is redundant if and only if the vertex defined by the other two constraints lies inside the set defined by cmid.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHPolygon/#Implementations","page":"Polygons in constraint representation (AbstractHPolygon)","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/AbstractHPolygon/","page":"Polygons in constraint representation (AbstractHPolygon)","title":"Polygons in constraint representation (AbstractHPolygon)","text":"Polygon in constraint representation (HPolygon)\nPolygon in optimized constraint representation (HPolygonOpt)","category":"page"},{"location":"lib/concrete_binary_operations/difference/","page":"Set difference","title":"Set difference","text":"Pages = [\"difference.md\"]\nDepth = 3","category":"page"},{"location":"lib/concrete_binary_operations/difference/#Set-difference","page":"Set difference","title":"Set difference","text":"","category":"section"},{"location":"lib/concrete_binary_operations/difference/#LazySets.API.difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-concrete_binary_operations-difference","page":"Set difference","title":"LazySets.API.difference","text":"difference(X::LazySet, Y::LazySet)\n\nCompute the set difference of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the difference X  Y.\n\nNotes\n\nThe set difference is defined as:\n\n    X  Y = x mid x  X text and  x  Y \n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/difference/","page":"Set difference","title":"Set difference","text":"Currently, there are no specialized docstrings for this function.","category":"page"},{"location":"lib/sets/Star/#def_Star","page":"Star","title":"Star","text":"","category":"section"},{"location":"lib/sets/Star/#LazySets.StarModule.Star","page":"Star","title":"LazySets.StarModule.Star","text":"Star{N, VN<:AbstractVector{N}, MN<:AbstractMatrix{N}, PT<:AbstractPolyhedron{N}} <: AbstractPolyhedron{N}\n\nGeneralized star set with a polyhedral predicate, i.e.\n\nX = x  ℝ^n  x = x₀ + _i=1^m α_i v_itextrmst  P(α) =  \n\nwhere x₀  ℝ^n is the center, the m vectors v₁  vₘ form the basis of the star set, and the combination factors α = (α₁  αₘ)  ℝ^m are the predicate's decision variables, i.e., P  α  ℝ^m    where the polyhedral predicate satisfies P(α) =  if and only if Aα  b for some fixed A  ℝ^p  m and b  ℝ^p.\n\nFields\n\nc – vector that represents the center\nV – matrix where each column corresponds to a basis vector\nP – polyhedral set that represents the predicate\n\nNotes\n\nThe predicate function is implemented as a conjunction of linear constraints, i.e., a subtype of AbstractPolyhedron. By a slight abuse of notation, the predicate is also used to denote the subset of ℝ^n such that P(α) =  holds.\n\nThe m basis vectors (each one n-dimensional) are stored as the columns of an n  m matrix.\n\nWe remark that a Star is mathematically equivalent to the affine map of the polyhedral set P, with the transformation matrix and translation vector being V and c, respectively.\n\nStar sets as defined here were introduced in Duggirala and Viswanathan [DV16]; see also Bak and Duggirala [BD17] for a preliminary definition.\n\nExamples\n\nThis example is drawn from Example 1 in [2]. Consider the two-dimensional plane ℝ^2. Let\n\njulia> V = [[1.0, 0.0], [0.0, 1.0]];\n\nbe the basis vectors and take\n\njulia> c = [3.0, 3.0];\n\nas the center of the star set. Let the predicate be the infinity-norm ball of radius 1,\n\njulia> P = BallInf(zeros(2), 1.0);\n\nWe construct the star set X = c V P as follows:\n\njulia> S = Star(c, V, P)\nStar{Float64, Vector{Float64}, Matrix{Float64}, BallInf{Float64, Vector{Float64}}}([3.0, 3.0], [1.0 0.0; 0.0 1.0], BallInf{Float64, Vector{Float64}}([0.0, 0.0], 1.0))\n\nWe can use getter functions for each component field:\n\njulia> center(S)\n2-element Vector{Float64}:\n 3.0\n 3.0\n\njulia> basis(S)\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\njulia> predicate(S)\nBallInf{Float64, Vector{Float64}}([0.0, 0.0], 1.0)\n\nIn this case, the generalized star S above is equivalent to the rectangle T below.\n\n    T = (x y)  ℝ^2  (2  x  4)  (2  y  4) \n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Star/#Conversion","page":"Star","title":"Conversion","text":"","category":"section"},{"location":"lib/sets/Star/","page":"Star","title":"Star","text":"convert(::Type{Star}, ::AbstractPolyhedron)","category":"page"},{"location":"lib/sets/Star/#Operations","page":"Star","title":"Operations","text":"","category":"section"},{"location":"lib/sets/Star/#LazySets.API.an_element-Tuple{LazySets.API.LazySet}-lib-sets-Star","page":"Star","title":"LazySets.API.an_element","text":"an_element(X::LazySet)\n\nReturn some element of a nonempty set.\n\nInput\n\nX – set\n\nOutput\n\nAn element of X unless X is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Star/#LazySets.API.an_element-Tuple{Star}","page":"Star","title":"LazySets.API.an_element","text":"Extended help\n\nan_element(X::Star)\n\nAlgorithm\n\nWe apply the affine map to the result of an_element on the predicate.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Star/#LazySets.StarModule.basis-Tuple{Star}","page":"Star","title":"LazySets.StarModule.basis","text":"basis(X::Star)\n\nReturn the basis vectors of a star.\n\nInput\n\nX – star\n\nOutput\n\nA matrix where each column is a basis vector of the star.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Star/#LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}-lib-sets-Star","page":"Star","title":"LazySets.API.constraints_list","text":"constraints_list(X::LazySet)\n\nCompute a list of linear constraints of a polyhedral set.\n\nInput\n\nX – polyhedral set\n\nOutput\n\nA list of the linear constraints of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Star/#LazySets.API.constraints_list-Tuple{Star}","page":"Star","title":"LazySets.API.constraints_list","text":"Extended help\n\nconstraints_list(X::Star)\n\nAlgorithm\n\nSee constraints_list(::LazySets.AbstractAffineMap).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Star/#LazySets.API.isbounded-Tuple{LazySets.API.LazySet}-lib-sets-Star","page":"Star","title":"LazySets.API.isbounded","text":"isbounded(X::LazySet)\n\nCheck whether a set is bounded.\n\nInput\n\nX – set\n\nOutput\n\ntrue iff the set is bounded.\n\nNotes\n\nSee also isboundedtype(::Type{<:LazySet}).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Star/#LazySets.API.isbounded-Tuple{Star}","page":"Star","title":"LazySets.API.isbounded","text":"Extended help\n\nisbounded(X::Star; cond_tol::Number=DEFAULT_COND_TOL)\n\nAlgorithm\n\nSee isbounded(::LazySets.AbstractAffineMap).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Star/#LazySets.StarModule.predicate-Tuple{Star}","page":"Star","title":"LazySets.StarModule.predicate","text":"predicate(X::Star)\n\nReturn the predicate of a star.\n\nInput\n\nX – star\n\nOutput\n\nA polyhedral set representing the predicate of the star.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Star/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-Star","page":"Star","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Star/#Base.rand-Tuple{Type{Star}}","page":"Star","title":"Base.rand","text":"Extended help\n\nrand(::Type{Star}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nAlgorithm\n\nA predicate P can be passed directly. If P is nothing (default), we generate a random HPolytope of dimension dim.\n\nAll numbers are normally distributed with mean 0 and standard deviation 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Star/#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-Star","page":"Star","title":"Base.:∈","text":"∈(x::AbstractVector, X::LazySet)\n\nCheck whether a point lies in a set.\n\nInput\n\nx – point/vector\nX – set\n\nOutput\n\ntrue iff x  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Star/#Base.:∈-Tuple{AbstractVector, Star}","page":"Star","title":"Base.:∈","text":"Extended help\n\n∈(v::AbstractVector, X::Star)\n\nAlgorithm\n\nSee ∈(::AbstractVector, ::LazySets.AbstractAffineMap).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Star/","page":"Star","title":"Star","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/Star/","page":"Star","title":"Star","text":"center\ncenter\ndim\nisempty\nisoperationtype\nvertices_list\naffine_map\nlinear_map\nρ\nσ","category":"page"},{"location":"lib/sets/Star/","page":"Star","title":"Star","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Star/","page":"Star","title":"Star","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisboundedtype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\nvolume\nexponential_map\nis_interior_point\nsample\nscale\ntranslate\ncartesian_product\nconvex_hull\nexact_sum\n≈\n==\nisequivalent\n⊂\nminkowski_difference","category":"page"},{"location":"lib/sets/Star/","page":"Star","title":"Star","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/Star/","page":"Star","title":"Star","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/Star/","page":"Star","title":"Star","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/Star/","page":"Star","title":"Star","text":"extrema\nextrema\nhigh\nhigh\nispolyhedral\nisuniversal\nlow\nlow\nproject\nintersection\nisdisjoint\n⊆\nminkowski_sum","category":"page"},{"location":"man/convex_hulls/#Convex-Hulls","page":"Convex Hulls","title":"Convex Hulls","text":"","category":"section"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"In this section we illustrate the convex hull operation. We give examples of the symbolic implementation, and the concrete convex hull in low dimensions. We show how to test if a point lies in the convex hull of a set of points in the plane using LazySets. Moreover, we give examples of creating the convex hull of sets whose vertices are represented as static vectors, which can dramatically improve performance in many use cases. Finally, we give an example of creating the convex hull of points in higher dimensions.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Pages = [\"convex_hulls.md\"]\nDepth = 3","category":"page"},{"location":"man/convex_hulls/#Symbolic-convex-hull","page":"Convex Hulls","title":"Symbolic convex hull","text":"","category":"section"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"The lazy convex hull, ConvexHull, is the binary operator that implements the convex hull of the union between two convex sets.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"using Plots, LazySets\n\nA = 1/sqrt(2.) * [1 -1; 1 1]\nBn = n -> BallInf(ones(n), 0.2)\n\nX = Bn(2)\nY = CH(X, exp(A) * X)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"The name CH is an alias for ConvexHull, so you can use both interchangeably. This type is parametric in the operands's types.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"p = plot(X, 1e-2, color=\"blue\")\nplot!(p, exp(A) * X, color=\"green\")\nplot!(p, Y, color=\"red\", alpha=0.2)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"We can as well work with a 100-dimensional set:","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"using SparseArrays\n\nX = Bn(100)\nA = blockdiag([sparse(A) for i in 1:50]...)\nY = CH(X, exp(Matrix(A)) * X)\n\ndim(Y)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"To take the convex hull of a large number of sets, there is the n-ary type ConvexHullArray. For instance, below we create a collection of balls b via list comprehension, and pass them to create a new ConvexHullArray instance.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"b = [Ball2([2*pi*i/100, sin(2*pi*i/100)], 0.05) for i in 1:100];\nc = ConvexHullArray(b);\n\nplot(c, alpha=0.1, color=\"blue\")\nplot!(b, alpha=0.5, color=\"red\")","category":"page"},{"location":"man/convex_hulls/#2D-convex-hull","page":"Convex Hulls","title":"2D convex hull","text":"","category":"section"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"In two dimensions the convex_hull function computes the concrete convex hull of a set of points.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"points = N -> [randn(2) for i in 1:N]\nv = points(30)\nhull = convex_hull(v)\ntypeof(hull), length(v), length(hull)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Notice that the output is a vector of floating point numbers representing the coordinates of the points, and that the number of points in the convex hull has decreased.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"We can plot both the random points and the polygon generated by the convex hull with the plot function:","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"p = plot([Singleton(vi) for vi in v])\nplot!(p, VPolygon(hull), alpha=0.2)","category":"page"},{"location":"man/convex_hulls/#Test-point-in-convex-hull","page":"Convex Hulls","title":"Test point in convex hull","text":"","category":"section"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"One can check whether a point lies inside or outside of a convex hull efficiently in two dimensions, using the fact that the output of convex_hull returns the points ordered in counter-clockwise fashion.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"note: Note\nTo check if a point p::AbstractVector is in another set, e.g. a polygon in vertex representation V, use p ∈ V. However, if you are working with a Singleton, which is a set with one element, use set inclusion ⊆. The following example illustrates this difference.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"julia> Singleton(v[1]) ∈ VPolygon(hull)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"ERROR: cannot make a point-in-set check if the left-hand side is a set; either\ncheck for set inclusion, as in `S ⊆ X`, or check for membership, as in\n`element(S) ∈ X` (the results are equivalent but the implementations may differ)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"As the error suggests, either use element to access the element of the singleton and check if it belongs to the right-hand side set:","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"element(Singleton(v[1])) ∈ VPolygon(hull)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Or use set inclusion between the singleton and the right-hand side set:","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Singleton(v[1]) ⊆ VPolygon(hull)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Let us note that one can also make the point-in-convex-hull test by solving a feasibility problem; actually, this is the fallback implementation used for in any dimension. However, the specialized approach in 2D is more efficient.","category":"page"},{"location":"man/convex_hulls/#Using-static-vectors","page":"Convex Hulls","title":"Using static vectors","text":"","category":"section"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Usual vectors are such that you can push! and pop! without changing its type: the size is not a static property. Vectors of fixed size, among other types, are provided by the StaticArrays.jl package from the JuliaArrays ecosystem. Using static arrays for vectors of \"small\" dimension can dramatically improve performance.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Since the convex hull algorithm supports any AbstractVector, it can be applied with static vectors. The following example illustrates this fact.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"v = points(1000)\nconvex_hull(points(3)) # warm-up\n\n@time convex_hull(v)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Now working with static vectors:","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"using StaticArrays\n\nconvex_hull([@SVector(rand(2)) for i in 1:3]) # warm-up\n\nv_static = [SVector{2, Float64}(vi) for vi in v]\n@time convex_hull(v_static)","category":"page"},{"location":"man/convex_hulls/#Higher-dimensional-convex-hull","page":"Convex Hulls","title":"Higher-dimensional convex hull","text":"","category":"section"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"One can compute the convex hull of points in higher dimensions using convex_hull. The appropriate algorithm is decided based on the dimensionality of the given points.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"using Polyhedra\n\nv = [randn(3) for _ in 1:30]\nhull = convex_hull(v)\ntypeof(hull), length(v), length(hull)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Here, convex_hull is now using the concrete polyhedra library Polyhedra, hence it needs to be loaded beforehand.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"One can check whether a point belongs to the convex hull using ∈ as follows:","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"P = VPolytope(hull)\nx = sum(hull)/length(hull)\n\nx ∈ P","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Here x ∈ P solves a feasibility problem; see the docs of ?∈ for details. Equivalently, using set inclusion:","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Singleton(x) ⊆ P","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"If no additional arguments are passed, convex_hull uses the default polyhedra library from default_polyhedra_backend for the given input; different options can be passed through the backend keyword; see the Julia polyhedra website for all the available backends.","category":"page"},{"location":"lib/lazy_operations/QuadraticMap/#def_QuadraticMap","page":"QuadraticMap","title":"Quadratic map (QuadraticMap)","text":"","category":"section"},{"location":"lib/lazy_operations/QuadraticMap/#LazySets.QuadraticMap","page":"QuadraticMap","title":"LazySets.QuadraticMap","text":"QuadraticMap{N, S<:LazySet{N}, MVT<:AbstractVector{<:AbstractMatrix{N}}} <: LazySet{N}\n\nType that represents a quadratic map of a set.\n\nFields\n\nQ – matrices\nX – set\n\nNotes\n\nThe quadratic map of a set X given n square matrices Q^(i) is defined as\n\nleft λ mid λ_i = x^T Q^(i) xi = 1  nx  X right\n\nwhere each coordinate i is influenced by the i-th matrix Q^(i).\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/QuadraticMap/#LazySets.API.dim-Tuple{QuadraticMap}","page":"QuadraticMap","title":"LazySets.API.dim","text":"dim(qm::QuadraticMap)\n\nReturn the dimension of a quadratic map.\n\nInput\n\nqm – quadratic map\n\nOutput\n\nThe ambient dimension of the quadratic map.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/","page":"General sets (LazySet)","title":"General sets (LazySet)","text":"Pages = [\"LazySet.md\"]\nDepth = 3","category":"page"},{"location":"lib/interfaces/LazySet/#def_LazySet","page":"General sets (LazySet)","title":"General sets (LazySet)","text":"","category":"section"},{"location":"lib/interfaces/LazySet/","page":"General sets (LazySet)","title":"General sets (LazySet)","text":"Every set type in this library is a subtype of the abstract type LazySet.","category":"page"},{"location":"lib/interfaces/LazySet/#LazySets.LazySet","page":"General sets (LazySet)","title":"LazySets.LazySet","text":"LazySet{N}\n\nAbstract type for the set types in LazySets.\n\nNotes\n\nLazySet types should be parameterized with a type N, typically N<:Real, for using different numeric types.\n\nEvery LazySet must implement the following function:\n\ndim(X::LazySet) – the ambient dimension of X\n\nWhile not strictly required, it is useful to implement the following function:\n\nσ(d::AbstractVector, X::LazySet) – the support vector of X in a given   direction d\n\nImplementing the function\n\nρ(d::AbstractVector, X::LazySet) – the support function of X in a given   direction d\n\nis optional because there is a fallback implementation relying on σ. However, for potentially unbounded sets (which includes most lazy set types) this fallback cannot be used and an explicit implementation should be provided.\n\nThe subtypes of LazySet (including abstract interfaces):\n\njulia> subtypes(LazySet, false)\n17-element Vector{Any}:\n AbstractAffineMap\n AbstractPolynomialZonotope\n Bloating\n CachedMinkowskiSumArray\n CartesianProduct\n CartesianProductArray\n Complement\n ConvexSet\n Intersection\n IntersectionArray\n MinkowskiSum\n MinkowskiSumArray\n Polygon\n QuadraticMap\n Rectification\n UnionSet\n UnionSetArray\n\nIf we only consider concrete subtypes, then:\n\njulia> concrete_subtypes = subtypes(LazySet, true);\n\njulia> length(concrete_subtypes)\n54\n\njulia> println.(concrete_subtypes);\nAffineMap\nBall1\nBall2\nBallInf\nBallp\nBloating\nCachedMinkowskiSumArray\nCartesianProduct\nCartesianProductArray\nComplement\nConvexHull\nConvexHullArray\nDensePolynomialZonotope\nEllipsoid\nEmptySet\nExponentialMap\nExponentialProjectionMap\nHParallelotope\nHPolygon\nHPolygonOpt\nHPolyhedron\nHPolytope\nHalfSpace\nHyperplane\nHyperrectangle\nIntersection\nIntersectionArray\nInterval\nInverseLinearMap\nLine\nLine2D\nLineSegment\nLinearMap\nMinkowskiSum\nMinkowskiSumArray\nPolygon\nQuadraticMap\nRectification\nResetMap\nSimpleSparsePolynomialZonotope\nSingleton\nSparsePolynomialZonotope\nStar\nSymmetricIntervalHull\nTetrahedron\nTranslation\nUnionSet\nUnionSetArray\nUniverse\nVPolygon\nVPolytope\nZeroSet\nZonotope\nZonotopeMD\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/LazySet/","page":"General sets (LazySet)","title":"General sets (LazySet)","text":"This interface requires to implement the following function:","category":"page"},{"location":"lib/interfaces/LazySet/#LazySets.API.dim-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.dim","text":"dim(X::LazySet)\n\nCompute the ambient dimension of a set.\n\nInput\n\nX – set\n\nOutput\n\nThe ambient dimension of the set.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#Support-vector-and-support-function","page":"General sets (LazySet)","title":"Support vector and support function","text":"","category":"section"},{"location":"lib/interfaces/LazySet/","page":"General sets (LazySet)","title":"General sets (LazySet)","text":"Most LazySet types (particularly convex ones) define a function σ to compute the support vector. The support function, ρ, can optionally be defined; otherwise, a fallback definition based on σ is used.","category":"page"},{"location":"lib/interfaces/LazySet/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, X::LazySet)\n\nEvaluate the support function of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nThe evaluation of the support function of X in direction d.\n\nNotes\n\nA convenience alias support_function is also available.\n\nWe have the following identity based on the support vector σ:\n\n    ρ(d X) = d  σ(d X)\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.ρ-Tuple{AbstractVector, LazySet}","page":"General sets (LazySet)","title":"LazySets.API.ρ","text":"Extended help\n\nρ(d::AbstractVector, X::LazySet)\n\nAlgorithm\n\nThe default implementation computes a support vector via σ.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#Globally-defined-set-functions-and-default-implementations","page":"General sets (LazySet)","title":"Globally defined set functions and default implementations","text":"","category":"section"},{"location":"lib/interfaces/LazySet/#LazySets.API.an_element-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.an_element","text":"an_element(X::LazySet)\n\nReturn some element of a nonempty set.\n\nInput\n\nX – set\n\nOutput\n\nAn element of X unless X is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.an_element-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.API.an_element","text":"Extended help\n\nan_element(X::LazySet)\n\nAlgorithm\n\nThe default implementation computes a support vector along direction 1 0  0. This may fail for unbounded sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.area-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.area","text":"area(X::LazySet)\n\nCompute the area of a two-dimensional set, respectively the surface area of a three-dimensional set.\n\nInput\n\nX – two- or three-dimensional set\n\nOutput\n\nA number representing the (surface) area of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.area-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.API.area","text":"Extended help\n\narea(X::LazySet)\n\nNotes\n\nThis algorithm is applicable to any two-dimensional polytopic set X whose list of vertices can be computed via vertices_list.\n\nAlgorithm\n\nLet m be the number of vertices of X. We consider the following instances:\n\nm = 0, 1, 2: the output is zero.\nm = 3: the triangle case is solved using the Shoelace formula with 3 points.\nm = 4: the quadrilateral case is solved by the factored version of the          Shoelace formula with 4 points.\n\nOtherwise, the general Shoelace formula is used; for details see the Wikipedia page.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.chebyshev_center_radius-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.chebyshev_center_radius","text":"chebyshev_center_radius(P::LazySet;\n                        [backend]=default_polyhedra_backend(P),\n                        [solver]=default_lp_solver_polyhedra(eltype(P); presolve=true))\n\nCompute a Chebyshev center and the corresponding radius of a polytopic set.\n\nInput\n\nP       – polytopic set\nbackend – (optional; default: default_polyhedra_backend(P)) the backend              for polyhedral computations\nsolver  – (optional; default:              default_lp_solver_polyhedra(N; presolve=true)) the LP solver              passed to Polyhedra\n\nOutput\n\nThe pair (c, r) where c is a Chebyshev center of P and r is the radius of the largest Euclidean ball with center c enclosed by P.\n\nNotes\n\nThe Chebyshev center is the center of a largest Euclidean ball enclosed by P. In general, the center of such a ball is not unique, but the radius is.\n\nAlgorithm\n\nWe call Polyhedra.chebyshevcenter.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.complement-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.complement","text":"complement(X::LazySet)\n\nCompute the complement of a set.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the complement of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.complement-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.API.complement","text":"Extended help\n\ncomplement(X::LazySet)\n\nAlgorithm\n\nThe default implementation assumes that X is polyhedral and returns a UnionSetArray of HalfSpaces, i.e., the output is the union of the linear constraints which are obtained by complementing each constraint of X. For any pair of sets (X Y) we have the identity (X  Y)^C = X^C  Y^C. We can apply this identity for each constraint that defines a polyhedral set.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.concretize-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.concretize","text":"concretize(X::LazySet)\n\nConstruct a concrete representation of a (possibly lazy) set.\n\nInput\n\nX – set\n\nOutput\n\nA concrete representation of X (as far as possible).\n\nNotes\n\nSince not every lazy set has a concrete set representation in this library, the result may still be partially lazy.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.concretize-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.API.concretize","text":"Extended help\n\nconcretize(X::LazySet)\n\nAlgorithm\n\nThe default implementation returns X. All relevant lazy set types should override this behavior, typically by recursively calling concretize on the set arguments.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.constraints-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.constraints","text":"constraints(X::LazySet)\n\nConstruct an iterator over the constraints of a polyhedral set.\n\nInput\n\nX – polyhedral set\n\nOutput\n\nAn iterator over the constraints of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.constraints-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.API.constraints","text":"Extended help\n\nconstraints(X::LazySet)\n\nAlgorithm\n\nThe default implementation computes all constraints via constraints_list.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.convex_hull-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.convex_hull","text":"convex_hull(X::LazySet)\n\nCompute the convex hull of a set.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the convex hull of X.\n\nNotes\n\nThe convex hull of a set X is defined as\n\n    λx + (1-λ)y mid x y  X λ  0 1\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.convex_hull-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.API.convex_hull","text":"Extended help\n\nconvex_hull(X::LazySet; kwargs...)\n\nOutput\n\nThe set X itself if its type indicates that it is convex, or a new set with the list of the vertices describing the convex hull.\n\nAlgorithm\n\nFor non-convex sets, this method relies on the vertices_list method.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/","page":"General sets (LazySet)","title":"General sets (LazySet)","text":"copy(::Type{LazySet})","category":"page"},{"location":"lib/interfaces/LazySet/#LazySets.triangulate-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.triangulate","text":"triangulate(X::LazySet; [algorithm]::String=\"delaunay\", [kwargs]...)\n\nCompute a triangulation of the given polytopic set.\n\nInput\n\nX         – polytopic set\nalgorithm – (optional; default: delaunay) string to choose the                type of triangulation\nkwargs    – further keyword arguments passed to the algorithm\n\nOutput\n\nA union of polytopes in vertex representation.\n\nAlgorithm\n\nThe algorithm is selected with the argument algorithm.\n\n\"delaunay\": This algorithm computes a Delaunay triangulation.\n\nThis algorithm can receive another optional argument compute_triangles_3d, a Boolean flag that defaults to false. It is used to compute the 2D triangulation of a 3D set if true.\n\nThe implementation requires the package MiniQhull.jl, which uses the library Qhull.\n\nThe algorithm works in arbitrary dimension and requires that the list of vertices of X can be obtained.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.diameter-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.diameter","text":"diameter(X::LazySet, [p]::Real=Inf)\n\nReturn the diameter of a set.\n\nInput\n\nX – set\np – (optional, default: Inf) norm\n\nOutput\n\nA real number representing the diameter.\n\nNotes\n\nThe diameter of a set is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given p-norm) of minimal volume.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/LazySet/#LazySets.API.diameter","page":"General sets (LazySet)","title":"LazySets.API.diameter","text":"Extended help\n\ndiameter(X::LazySet, [p]::Real=Inf)\n\nAlgorithm\n\nThe default implementation applies the function radius and doubles the result.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/LazySet/#Base.eltype-Tuple{Type{<:LazySets.API.LazySet}}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"Base.eltype","text":"eltype(T::Type{<:LazySet})\n\nDetermine the numeric type of a set type.\n\nInput\n\nT – set type\n\nOutput\n\nThe numeric type of T.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#Base.eltype-Tuple{Type{<:LazySet}}","page":"General sets (LazySet)","title":"Base.eltype","text":"Extended help\n\neltype(::Type{<:LazySet{N}}) where {N}\n\nAlgorithm\n\nThe default implementation assumes that the first type parameter is the numeric type.\n\n\n\n\n\nExtended help\n\neltype(::LazySet{N}) where {N}\n\nAlgorithm\n\nThe default implementation assumes that the first type parameter is the numeric type.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#Base.eltype-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"Base.eltype","text":"eltype(X::LazySet)\n\nDetermine the numeric type of a set.\n\nInput\n\nX – set\n\nOutput\n\nThe numeric type of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#Base.eltype-Tuple{LazySet}","page":"General sets (LazySet)","title":"Base.eltype","text":"Extended help\n\neltype(::Type{<:LazySet{N}}) where {N}\n\nAlgorithm\n\nThe default implementation assumes that the first type parameter is the numeric type.\n\n\n\n\n\nExtended help\n\neltype(::LazySet{N}) where {N}\n\nAlgorithm\n\nThe default implementation assumes that the first type parameter is the numeric type.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#Base.extrema-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"Base.extrema","text":"extrema(X::LazySet)\n\nCompute the lowest and highest coordinate of a set in each dimension.\n\nInput\n\nX – set\n\nOutput\n\nTwo vectors with the lowest and highest coordinates of X in each dimension.\n\nNotes\n\nSee also extrema(X::LazySet, i::Int).\n\nThe result is equivalent to (low(X), high(X)), but sometimes it can be computed more efficiently.\n\nThe resulting points are the lowest and highest corners of the box approximation, so they are not necessarily contained in X.\n\nAlgorithm\n\nThe default implementation computes the extrema via low and high.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#Base.extrema-Tuple{LazySet}","page":"General sets (LazySet)","title":"Base.extrema","text":"Extended help\n\nextrema(X::LazySet)\n\nAlgorithm\n\nThe default implementation computes the extrema via low and high.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#Base.extrema-Tuple{LazySets.API.LazySet, Int64}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"Base.extrema","text":"extrema(X::LazySet, i::Int)\n\nCompute the lowest and highest coordinate of a set in a given dimension.\n\nInput\n\nX – set\ni – dimension\n\nOutput\n\nTwo real numbers representing the lowest and highest coordinate of the set in the given dimension.\n\nNotes\n\nThe result is equivalent to (low(X, i), high(X, i)), but sometimes it can be computed more efficiently.\n\nThe resulting values are the lower and upper ends of the projection.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#Base.extrema-Tuple{LazySet, Int64}","page":"General sets (LazySet)","title":"Base.extrema","text":"Extended help\n\nextrema(X::LazySet, i::Int)\n\nAlgorithm\n\nThe default implementation computes the extrema via low and high.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.high-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.high","text":"high(X::LazySet)\n\nCompute the highest coordinate of a set in each dimension.\n\nInput\n\nX – set\n\nOutput\n\nA vector with the highest coordinate of the set in each dimension.\n\nNotes\n\nSee also high(X::LazySet, i::Int).\n\nThe result is the uppermost corner of the box approximation, so it is not necessarily contained in X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.high-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.API.high","text":"Extended help\n\nhigh(X::LazySet)\n\nAlgorithm\n\nThe default implementation applies high in each dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.isbounded-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.isbounded","text":"isbounded(X::LazySet)\n\nCheck whether a set is bounded.\n\nInput\n\nX – set\n\nOutput\n\ntrue iff the set is bounded.\n\nNotes\n\nSee also isboundedtype(::Type{<:LazySet}).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.isbounded-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.API.isbounded","text":"Extended help\n\nisbounded(X::LazySet; [algorithm]=\"support_function\")\n\nInput\n\nalgorithm – (optional, default: \"support_function\") algorithm choice,                possible options are \"support_function\" and \"stiemke\"\n\nAlgorithm\n\nSee the documentation of _isbounded_unit_dimensions or _isbounded_stiemke for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets._isbounded_unit_dimensions-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets._isbounded_unit_dimensions","text":"_isbounded_unit_dimensions(X::LazySet)\n\nCheck whether a set is bounded in each unit dimension.\n\nInput\n\nX – set\n\nOutput\n\ntrue iff the set is bounded in each unit dimension.\n\nAlgorithm\n\nThis function asks for upper and lower bounds in each ambient dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.isboundedtype-Tuple{Type{<:LazySets.API.LazySet}}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.isboundedtype","text":"isboundedtype(T::Type{<:LazySet})\n\nCheck whether a set type only represents bounded sets.\n\nInput\n\nT – set type\n\nOutput\n\ntrue iff the set type only represents bounded sets.\n\nNotes\n\nSee also isbounded(::LazySet).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.isboundedtype-Tuple{Type{<:LazySet}}","page":"General sets (LazySet)","title":"LazySets.API.isboundedtype","text":"Extended help\n\nisboundedtype(::Type{<:LazySet})\n\nNotes\n\nNote that some sets may still represent an unbounded set even though their type actually does not (example: HPolytope, because the construction with non-bounding linear constraints is allowed).\n\nAlgorithm\n\nThe default implementation returns false. All set types that can determine boundedness should override this behavior.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.isconvextype-Tuple{Type{<:LazySets.API.LazySet}}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.isconvextype","text":"isconvextype(T::Type{<:LazySet})\n\nCheck whether T is convex just by using type information.\n\nInput\n\nT – subtype of LazySet\n\nOutput\n\ntrue iff the set type only represents convex sets.\n\nNotes\n\nSince this operation only acts on types (not on values), it can return false negatives, i.e., there may be instances where the set is convex, even though the answer of this function is false. The examples below illustrate this point.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.isconvextype-Tuple{Type{<:LazySet}}","page":"General sets (LazySet)","title":"LazySets.API.isconvextype","text":"Extended help\n\nisconvextype(::Type{<:LazySet})\n\nAlgorithm\n\nThe default implementation returns false. All set types that can determine convexity should override this behavior.\n\nExamples\n\nA ball in the infinity norm is always convex:\n\njulia> isconvextype(BallInf)\ntrue\n\nThe union (UnionSet) of two sets may in general be either convex or not. Since convexity cannot be decided by just using type information, isconvextype returns false.\n\njulia> isconvextype(UnionSet)\nfalse\n\nHowever, the type parameters of set operations allow to decide convexity in some cases by falling back to the convexity information of the argument types. Consider the lazy intersection. The intersection of two convex sets is always convex:\n\njulia> isconvextype(Intersection{Float64, BallInf{Float64}, BallInf{Float64}})\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#Base.isempty-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"Base.isempty","text":"isempty(X::LazySet, witness::Bool=false)\n\nCheck whether a set is empty.\n\nInput\n\nX       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X = \nIf the witness option is activated:\n(true, []) iff X = \n(false, v) iff X   for some v  X\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/LazySet/#Base.isempty","page":"General sets (LazySet)","title":"Base.isempty","text":"Extended help\n\nisempty(P::LazySet, witness::Bool=false;\n        [use_polyhedra_interface]::Bool=false, [solver]=nothing,\n        [backend]=nothing)\n\nInput\n\nwitness – (optional, default: false) compute a witness if activated\nuse_polyhedra_interface – (optional, default: false) if true, we use              the Polyhedra interface for the emptiness test\nsolver  – (optional, default: nothing) LP-solver backend; uses              default_lp_solver if not provided\nbackend – (optional, default: nothing) backend for polyhedral              computations in Polyhedra; uses default_polyhedra_backend(P)              if not provided\n\nNotes\n\nThis implementation assumes that P is polyhedral.\n\nThe default value of the backend is set internally and depends on whether the use_polyhedra_interface option is set. If the option is set, we use default_polyhedra_backend(P).\n\nWitness production is not supported if use_polyhedra_interface is true.\n\nAlgorithm\n\nThe algorithm sets up a feasibility LP for the constraints of P. If use_polyhedra_interface is true, we call Polyhedra.isempty. Otherwise, we set up the LP internally.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/LazySet/#LazySets.API.isoperation-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.isoperation","text":"isoperation(X::LazySet)\n\nCheck whether a set is an instance of a (lazy) set operation.\n\nInput\n\nX – set\n\nOutput\n\ntrue iff X is an instance of a set-based operation.\n\nNotes\n\nSee also isoperationtype(::Type{<:LazySet}).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.isoperation-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.API.isoperation","text":"Extended help\n\nisoperation(X::LazySet)\n\nAlgorithm\n\nThe default implementation checks whether the set type of the input is an operation type using isoperationtype(::Type{<:LazySet}).\n\nExamples\n\njulia> B = BallInf([0.0, 0.0], 1.0);\n\njulia> isoperation(B)\nfalse\n\njulia> isoperation(B ⊕ B)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.ispolyhedral-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.ispolyhedral","text":"ispolyhedral(X::LazySet)\n\nCheck whether a set is polyhedral.\n\nInput\n\nX – set\n\nOutput\n\ntrue only if the set is polyhedral.\n\nNotes\n\nThe answer is conservative, i.e., may sometimes be false even if the set is polyhedral.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.ispolyhedral-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.API.ispolyhedral","text":"Extended help\n\nispolyhedral(::LazySet)\n\nAlgorithm\n\nThe default implementation returns false. All set types that can determine the polyhedral property should override this behavior.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.low-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.low","text":"low(X::LazySet)\n\nCompute the lowest coordinates of a set in each dimension.\n\nInput\n\nX – set\n\nOutput\n\nA vector with the lowest coordinate of the set in each dimension.\n\nNotes\n\nSee also low(X::LazySet, i::Int).\n\nThe result is the lowermost corner of the box approximation, so it is not necessarily contained in X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.low-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.API.low","text":"Extended help\n\nlow(X::LazySet)\n\nAlgorithm\n\nThe default implementation applies low in each dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LinearAlgebra.norm-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LinearAlgebra.norm","text":"norm(X::LazySet, [p]::Real=Inf)\n\nReturn the norm of a set.\n\nInput\n\nX – set\np – (optional, default: Inf) norm\n\nOutput\n\nA real number representing the norm.\n\nNotes\n\nThe norm of a set is the norm of the enclosing ball (of the given p-norm) of minimal volume that is centered in the origin.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/LazySet/#LinearAlgebra.norm","page":"General sets (LazySet)","title":"LinearAlgebra.norm","text":"Extended help\n\nnorm(X::LazySet, [p]::Real=Inf)\n\nAlgorithm\n\nThe default implementation handles the case p == Inf using extrema. Otherwise it checks whether X is polytopic, in which case it iterates over all vertices.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/LazySet/#Polyhedra.polyhedron-Tuple{LazySet}","page":"General sets (LazySet)","title":"Polyhedra.polyhedron","text":"polyhedron(P::LazySet; [backend]=default_polyhedra_backend(P))\n\nCompute a set representation from Polyhedra.jl.\n\nInput\n\nP       – polyhedral set\nbackend – (optional, default: call default_polyhedra_backend(P))               the polyhedral computations backend\n\nOutput\n\nA set representation in the Polyhedra library.\n\nNotes\n\nFor further information on the supported backends see Polyhedra's documentation.\n\nAlgorithm\n\nThis default implementation uses tosimplehrep, which computes the constraint representation of P. Set types preferring the vertex representation should implement their own method.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.radius-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.radius","text":"radius(X::LazySet, [p]::Real=Inf)\n\nReturn the radius of a set.\n\nInput\n\nX – set\np – (optional, default: Inf) norm\n\nOutput\n\nA real number representing the radius.\n\nNotes\n\nThe radius of a set is the radius of the enclosing ball (of the given p-norm) of minimal volume.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/LazySet/#LazySets.API.radius","page":"General sets (LazySet)","title":"LazySets.API.radius","text":"Extended help\n\nradius(X::LazySet, [p]::Real=Inf)\n\nAlgorithm\n\nThe default implementation handles the case p == Inf using ballinf_approximation.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/LazySet/#Base.rationalize-Union{Tuple{T}, Tuple{Type{T}, LazySet{<:AbstractFloat}, Real}} where T<:Integer","page":"General sets (LazySet)","title":"Base.rationalize","text":"rationalize(::Type{T}, X::LazySet, tol::Real) where {T<:Integer}\n\nApproximate a set represented with floating-point numbers as a set represented with rationals of the given integer type.\n\nInput\n\nT   – (optional, default: Int) integer type to represent the rationals\nX   – set represented by floating-point components\ntol – (optional, default: eps(N)) tolerance of the result; each rationalized          component will differ by no more than tol with respect to the floating-point value\n\nOutput\n\nA set of the same base type as X where each numerical component is of type Rational{T}.\n\nAlgorithm\n\nThe default implementation rationalizes each field.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#ReachabilityBase.Arrays.rectify-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"ReachabilityBase.Arrays.rectify","text":"rectify(X::LazySet)\n\nCompute the rectification of a set.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the rectification of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#ReachabilityBase.Arrays.rectify","page":"General sets (LazySet)","title":"ReachabilityBase.Arrays.rectify","text":"Extended help\n\nrectify(X::LazySet, [concrete_intersection]::Bool=false)\n\nAlgorithm\n\nFor each dimension in which X is both positive and negative, we split X into these two parts and then project the negative part to zero.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/LazySet/#LazySets.API.reflect-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.reflect","text":"reflect(X::LazySet)\n\nCompute the reflection of a set in the origin.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the reflection -X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.reflect-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.API.reflect","text":"Extended help\n\nreflect(P::LazySet)\n\nOutput\n\nThe set -P, which is either of type HPolytope if P is a polytope (i.e., bounded) or of type HPolyhedron otherwise.\n\nAlgorithm\n\nThis function requires that the list of constraints of the set P is available, i.e., that it can be written as P = z  ℝⁿ  sᵢᵀz  rᵢ i = 1  N\n\nThis function can be used to implement the alternative definition of the Minkowski difference\n\n    A  B = a  b mid a  A b  B = A  (-B)\n\nby calling minkowski_sum(A, reflect(B)).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.singleton_list-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.singleton_list","text":"singleton_list(P::LazySet)\n\nReturn the vertices of a polytopic set as a list of singletons.\n\nInput\n\nP – polytopic set\n\nOutput\n\nA list of the vertices of P as Singletons.\n\nNotes\n\nThis function relies on vertices_list, which raises an error if the set is not polytopic (e.g., unbounded).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.triangulate_faces-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.triangulate_faces","text":"triangulate_faces(X::LazySet)\n\nTriangulate the faces of a three-dimensional polytopic set.\n\nInput\n\nX – three-dimensional polytopic set\n\nOutput\n\nA tuple (p, c) where p is a matrix, with each column containing a point, and c is a list of 3-tuples containing the indices of the points in each triangle.\n\nNotes\n\nThis function triangulates all faces of a 3D polytope. The result is a list of (flat) triangles in 3D which describe the boundary of X.\n\nX must contain at least three vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.tohrep-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.tohrep","text":"tohrep(P::LazySet)\n\nConvert a polyhedral set to constraint representation.\n\nInput\n\nP – polyhedral set\n\nOutput\n\nAn HPolyhedron if P is bounded (via isboundedtype) or an HPolytope otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.tosimplehrep-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.tosimplehrep","text":"tosimplehrep(S::LazySet)\n\nReturn the simple constraint representation Ax  b of a polyhedral set from its list of linear constraints.\n\nInput\n\nS – polyhedral set\n\nOutput\n\nThe tuple (A, b) where A is the matrix of normal directions and b is the vector of offsets.\n\nAlgorithm\n\nThis fallback implementation relies on constraints_list(S).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.tovrep-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.tovrep","text":"tovrep(P::LazySet)\n\nConvert a polytopic set to vertex representation.\n\nInput\n\nP – polytopic set\n\nOutput\n\nA VPolytope.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.vertices-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.vertices","text":"vertices(X::LazySet)\n\nConstruct an iterator over the vertices of a polytopic set.\n\nInput\n\nX – polytopic set\n\nOutput\n\nAn iterator over the vertices of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.vertices-Tuple{LazySet}","page":"General sets (LazySet)","title":"LazySets.API.vertices","text":"Extended help\n\nvertices(X::LazySet)\n\nAlgorithm\n\nThe default implementation computes all vertices via vertices_list.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.affine_map-Tuple{AbstractMatrix, LazySets.API.LazySet, AbstractVector}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.affine_map","text":"affine_map(M::AbstractMatrix, X::LazySet, v::AbstractVector)\n\nCompute the affine map M  X + v.\n\nInput\n\nM – matrix\nX – set\nv – translation vector\n\nOutput\n\nA set representing the affine map M  X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.affine_map-Tuple{Any, LazySet, AbstractVector}","page":"General sets (LazySet)","title":"LazySets.API.affine_map","text":"Extended help\n\naffine_map(M, X::LazySet, v::AbstractVector; [kwargs]...)\n\nAlgorithm\n\nThe default implementation applies the functions linear_map and translate.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.exponential_map-Tuple{AbstractMatrix, LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.exponential_map","text":"exponential_map(M::AbstractMatrix, X::LazySet)\n\nCompute the exponential map of M and X, i.e., eᴹ  X.\n\nInput\n\nM – matrix\nX – set\n\nOutput\n\nA set representing the exponential map eᴹ  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.exponential_map-Tuple{AbstractMatrix, LazySet}","page":"General sets (LazySet)","title":"LazySets.API.exponential_map","text":"Extended help\n\nexponential_map(M::AbstractMatrix, X::LazySet)\n\nAlgorithm\n\nThe default implementation applies the functions exp and linear_map.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.is_interior_point-Tuple{AbstractVector{<:Real}, LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.is_interior_point","text":"is_interior_point(v::AbstractVector{<:Real}, X::LazySet; kwargs...) end\n\nCheck whether a point is contained in the interior of a set.\n\nInput\n\nv  – point/vector\nX  – set\np  – (optional; default: Inf) norm of the ball used to apply the error         tolerance\nε  – (optional; default: _rtol(eltype(X))) error tolerance of the check\n\nOutput\n\ntrue iff the point v is strictly contained in X with tolerance ε.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.is_interior_point-Tuple{AbstractVector{<:Real}, LazySet}","page":"General sets (LazySet)","title":"LazySets.API.is_interior_point","text":"Extended help\n\nis_interior_point(v::AbstractVector{<:Real}, X::LazySet; [kwargs]...)\n\nAlgorithm\n\nThe default implementation determines v ∈ interior(X) with error tolerance ε by checking whether a Ballp of norm p with center v and radius ε is contained in X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.linear_map-Tuple{AbstractMatrix, LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.linear_map","text":"linear_map(M::AbstractMatrix, X::LazySet)\n\nCompute the linear map M  X.\n\nInput\n\nM – matrix\nX – set\n\nOutput\n\nA set representing the linear map M  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.linear_map-Tuple{AbstractMatrix, LazySet}","page":"General sets (LazySet)","title":"LazySets.API.linear_map","text":"Extended help\n\nlinear_map(M::AbstractMatrix, P::LazySet; kwargs...)\n\nAlgorithm\n\nThe default implementation assumes that P is polyhedral and applies an algorithm based on the set type (see _linear_map_polyhedron).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.project","page":"General sets (LazySet)","title":"LazySets.API.project","text":"project(X::LazySet, block::AbstractVector{Int}, [::Nothing=nothing],\n        [n]::Int=dim(X); [kwargs...])\n\nProject a set to a given block by using a concrete linear map.\n\nInput\n\nX       – set\nblock   – block structure - a vector with the dimensions of interest\nnothing – (default: nothing) needed for dispatch\nn       – (optional, default: dim(X)) ambient dimension of the set X\n\nOutput\n\nA set representing the projection of X to block block.\n\nAlgorithm\n\nWe apply the function linear_map.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/LazySet/#LazySets.API.project-2","page":"General sets (LazySet)","title":"LazySets.API.project","text":"project(X::LazySet, block::AbstractVector{Int}, set_type::Type{<:LazySet},\n        [n]::Int=dim(X); [kwargs...])\n\nProject a set to a given block and set type, possibly involving an overapproximation.\n\nInput\n\nX        – set\nblock    – block structure - a vector with the dimensions of interest\nset_type – target set type\nn        – (optional, default: dim(X)) ambient dimension of the set X\n\nOutput\n\nA set of type set_type representing an overapproximation of the projection of X.\n\nAlgorithm\n\nProject the set X with M⋅X, where M is the identity matrix in the block\n\ncoordinates and zero otherwise.\n\nOverapproximate the projected set using overapproximate and set_type.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/LazySet/#LazySets.API.project-3","page":"General sets (LazySet)","title":"LazySets.API.project","text":"project(X::LazySet, block::AbstractVector{Int},\n        set_type_and_precision::Pair{<:UnionAll,<:Real}, [n]::Int=dim(X);\n        [kwargs...])\n\nProject a set to a given block and set type with a certified error bound.\n\nInput\n\nX     – set\nblock – block structure - a vector with the dimensions of interest\nset_type_and_precision – pair (T, ε) of a target set type T and an                             error bound ε for approximation\nn     – (optional, default: dim(X)) ambient dimension of the set X\n\nOutput\n\nA set representing the epsilon-close approximation of the projection of X.\n\nNotes\n\nCurrently we only support HPolygon as set type, which implies that the set must be two-dimensional.\n\nAlgorithm\n\nProject the set X with M⋅X, where M is the identity matrix in the block\n\ncoordinates and zero otherwise.\n\nOverapproximate the projected set with the given error bound ε.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/LazySet/#LazySets.API.project-4","page":"General sets (LazySet)","title":"LazySets.API.project","text":"project(X::LazySet, block::AbstractVector{Int}, ε::Real, [n]::Int=dim(X);\n        [kwargs...])\n\nProject a set to a given block and set type with an error bound.\n\nInput\n\nX     – set\nblock – block structure - a vector with the dimensions of interest\nε     – error bound for approximation\nn     – (optional, default: dim(X)) ambient dimension of the set X\n\nOutput\n\nA set representing the epsilon-close approximation of the projection of X.\n\nAlgorithm\n\nProject the set X with M⋅X, where M is the identity matrix in the block\n\ncoordinates and zero otherwise.\n\nOverapproximate the projected set with the given error bound ε.\n\nThe target set type is chosen automatically.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/LazySet/#LazySets.API.scale-Tuple{Real, LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.scale","text":"scale(α::Real, X::LazySet)\n\nCompute the scaling of a set.\n\nInput\n\nα – scalar\nX – set\n\nOutput\n\nA set representing α  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.scale-Tuple{Real, LazySet}","page":"General sets (LazySet)","title":"LazySets.API.scale","text":"Extended help\n\nscale(α::Real, X::LazySet)\n\nAlgorithm\n\nThe default implementation computes linear_map with the diagonal matrix α*I.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.translate-Tuple{LazySets.API.LazySet, AbstractVector}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.translate","text":"translate(X::LazySet, v::AbstractVector)\n\nCompute the translation of a set with a vector.\n\nInput\n\nX – set\nv – vector\n\nOutput\n\nA set representing X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.translate-Tuple{LazySet, AbstractVector}","page":"General sets (LazySet)","title":"LazySets.API.translate","text":"Extended help\n\ntranslate(X::LazySet, v::AbstractVector)\n\nAlgorithm\n\nThe default implementation calls translate! on a copy of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.cartesian_product-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.cartesian_product","text":"cartesian_product(X::LazySet, Y::LazySet)\n\nCompute the Cartesian product of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the Cartesian product X  Y.\n\nNotes\n\nThe Cartesian product of two sets X and Y is defined as\n\n    X  Y = x y mid x  X y  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.cartesian_product-Tuple{LazySet, LazySet}","page":"General sets (LazySet)","title":"LazySets.API.cartesian_product","text":"cartesian_product(X::LazySet, Y::LazySet; [backend]=nothing,\n                  [algorithm]::String=\"vrep\")\n\nCompute the Cartesian product of two sets.\n\nInput\n\nX         – set\nY         – set\nbackend   – (optional, default: nothing) backend for polyhedral                computation\nalgorithm – (optional, default: \"hrep\") the method used to transform the                sets X and Y before taking the Cartesian product; choose                between:\n\"vrep\" (use the vertex representation)\n\"hrep\" (use the constraint representation)\n\"hrep_polyhedra\" (use the constraint representation and Polyhedra)\n\nOutput\n\nThe VPolytope (if \"vrep\" was used) or HPolytope/HPolyhedron (if \"hrep\" or \"hrep_polyhedra\" was used) obtained by the concrete Cartesian product of X and Y. The choice between HPolytope and HPolyhedron is made based on boundedness information deduced from the type.\n\nNotes\n\nFor further information on the supported backends see Polyhedra's documentation.\n\nIf X can be converted to a one-dimensional interval and the vertices of Y are available, use algorithm=\"vrep\".\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.convex_hull-Tuple{LazySet, LazySet}","page":"General sets (LazySet)","title":"LazySets.API.convex_hull","text":"convex_hull(X::LazySet, Y::LazySet; [algorithm]=nothing,\n            [backend]=nothing, [solver]=nothing)\n\nCompute the convex hull of two polytopic sets.\n\nInput\n\nX         – polytopic set\nY         – polytopic set\nalgorithm – (optional, default: nothing) the convex-hull algorithm\nbackend   – (optional, default: nothing) backend for polyhedral                computations (used for higher-dimensional sets)\nsolver    – (optional, default: nothing) the linear-programming solver                used in the backend\n\nOutput\n\nIf the sets are empty, the result is an EmptySet. If the convex hull consists of a single point, the result is a Singleton. If the input sets are one-dimensional, the result is an Interval. If the input sets are two-dimensional, the result is a VPolygon. Otherwise the result is a VPolytope.\n\nAlgorithm\n\nWe compute the vertices of both X and Y using vertices_list and then compute the convex hull of the union of those vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#Base.:≈-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"Base.:≈","text":"≈(X::LazySet, Y::LazySet)\n\nCheck whether two sets of the same type are approximately equal.\n\nInput\n\nX – set\nY – set of the same base type as X\n\nOutput\n\ntrue iff X is approximately equal to Y.\n\nNotes\n\nThe check is purely syntactic and the sets need to have the same base type, i.e., X::T1 ≈ Y::T2 always returns false even if X and Y represent the same set. But X::T{Int64} ≈ Y::T{Float64} is a valid comparison.\n\nThe convenience alias isapprox is also available.\n\n\"≈\" can be typed by \\approx<tab>.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#Base.:≈-Tuple{LazySet, LazySet}","page":"General sets (LazySet)","title":"Base.:≈","text":"Extended help\n\n≈(X::LazySet, Y::LazySet)\n\nAlgorithm\n\nThe default implementation recursively compares the fields of X and Y until a mismatch is found.\n\nExamples\n\njulia> HalfSpace([1], 1) ≈ HalfSpace([1.0], 1.0)\ntrue\n\njulia> HalfSpace([1], 1) ≈ HalfSpace([1.00000001], 0.99999999)\ntrue\n\njulia> BallInf([0.0], 1.0) ≈ Hyperrectangle([0.0], [1.0])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#Base.isdisjoint-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"Base.isdisjoint","text":"isdisjoint(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nCheck whether two sets are disjoint (i.e., do not intersect), and optionally compute a witness.\n\nInput\n\nX       – set\nY       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X  Y = \nIf the witness option is activated:\n(true, []) iff X  Y = \n(false, v) iff X  Y   for some v  X  Y\n\nNotes\n\nThe convenience alias is_intersection_empty is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#Base.isdisjoint","page":"General sets (LazySet)","title":"Base.isdisjoint","text":"Extended help\n\nisdisjoint(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nAlgorithm\n\nThis is a fallback implementation that computes the concrete intersection, intersection, of the given sets.\n\nA witness is constructed using the an_element implementation of the result.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/LazySet/#Base.:==-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"Base.:==","text":"==(X::LazySet, Y::LazySet)\n\nCheck whether two sets use exactly the same set representation.\n\nInput\n\nX – set\nY – set\n\nOutput\n\ntrue iff X is equal to Y.\n\nNotes\n\nThe check is purely syntactic and the sets need to have the same base type, i.e., X::T1 == Y::T2 always returns false even if X and Y represent the same set. But X::T{Int64} == Y::T{Float64} is a valid comparison.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#Base.:==-Tuple{LazySet, LazySet}","page":"General sets (LazySet)","title":"Base.:==","text":"Extended help\n\n==(X::LazySet, Y::LazySet)\n\nAlgorithm\n\nThe default implementation recursively compares the fields of X and Y until a mismatch is found.\n\nExamples\n\njulia> HalfSpace([1], 1) == HalfSpace([1.0], 1.0)\ntrue\n\njulia> HalfSpace([1], 1) == HalfSpace([1.00000001], 0.99999999)\nfalse\n\njulia> BallInf([0.0], 1.0) == Hyperrectangle([0.0], [1.0])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.isequivalent-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.isequivalent","text":"isequivalent(X::LazySet, Y::LazySet)\n\nCheck whether two sets are equivalent, i.e., represent the same set of points.\n\nInput\n\nX – set\nY – set\n\nOutput\n\ntrue iff X is equivalent to Y (up to numerical precision).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.isequivalent-Tuple{LazySet, LazySet}","page":"General sets (LazySet)","title":"LazySets.API.isequivalent","text":"Extended help\n\nisequivalent(X::LazySet, Y::LazySet)\n\nAlgorithm\n\nThe default implementation first checks X ≈ Y, which returns true if and only if X and Y have the same base type and approximately the same values. If that fails, the implementation checks the double inclusion X ⊆ Y && Y ⊆ X.\n\nExamples\n\njulia> X = BallInf([0.1, 0.2], 0.3);\n\njulia> Y = convert(HPolytope, X);\n\njulia> X == Y\nfalse\n\njulia> isequivalent(X, Y)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.:⊂-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"LazySets.API.:⊂","text":"⊂(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nCheck whether a set is a strict subset of another set, and optionally compute a witness.\n\nInput\n\nX       – set\nY       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X  Y\nIf the witness option is activated:\n(true, v) iff X  Y for some v  Y  X\n(false, []) iff X  Y does not hold\n\nNotes\n\nStrict inclusion is sometimes written as ⊊. The following identity holds:\n\n    X  Y  X  Y  Y  X\n\nAlgorithm\n\nThe default implementation first checks inclusion of X in Y and then checks noninclusion of Y in X:\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.:⊂","page":"General sets (LazySet)","title":"LazySets.API.:⊂","text":"Extended help\n\n⊂(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nAlgorithm\n\nThe default implementation first checks inclusion of X in Y and then checks noninclusion of Y in X:\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/LazySet/#Base.:⊆-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet","page":"General sets (LazySet)","title":"Base.:⊆","text":"⊆(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nCheck whether a set is a subset of another set, and optionally compute a witness.\n\nInput\n\nX       – set\nY       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X  Y\nIf the witness option is activated:\n(true, []) iff X  Y\n(false, v) iff X  Y for some v  X  Y\n\nNotes\n\nThe convenience alias issubset is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#Base.:⊆","page":"General sets (LazySet)","title":"Base.:⊆","text":"Extended help\n\n⊆(X::LazySet, Y::LazySet, witness::Bool=false)\n\nAlgorithm\n\nThe default implementation assumes that Y is polyhedral, i.e., that constraints_list(Y) is available, and checks inclusion of X in every constraint of Y.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/LazySet/#LazySets.API.minkowski_difference-Tuple{LazySet, LazySet}","page":"General sets (LazySet)","title":"LazySets.API.minkowski_difference","text":"minkowski_difference(P::LazySet, Q::LazySet)\n\nConcrete Minkowski difference (geometric difference) of a polytopic set and a compact set.\n\nInput\n\nP – polytopic set\nQ – compact set that is subtracted from P\n\nOutput\n\nAn HPolytope that corresponds to the Minkowski difference of P minus Q if P is bounded, and an HPolyhedron if P is unbounded.\n\nNotes\n\nThis implementation requires that the set P is polyhedral and that the set Q is bounded.\n\nAlgorithm\n\nThis method implements Kolmanovsky and Gilbert [KG98], Theorem 2.3:\n\nSuppose P is a polyhedron\n\nP = z  ℝ^n sᵢᵀz  rᵢi = 1  k\n\nwhere sᵢ  ℝ^n sᵢ  0, and rᵢ  ℝ. Assume ρ(sᵢQ) is defined for i = 1  k. Then the Minkowski difference is\n\nz  ℝ^n sᵢᵀz  rᵢ - ρ(sᵢQ)i = 1  k\n\nWhile the algorithm applies the support function to Q, we have that P  Q = P  textCH(Q) whenever P is convex, where CH denotes the convex hull. Hence, if Q is not convex by type information, we wrap it in a lazy ConvexHull.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.API.minkowski_sum-Tuple{LazySet, LazySet}","page":"General sets (LazySet)","title":"LazySets.API.minkowski_sum","text":"minkowski_sum(P::LazySet, Q::LazySet;\n              [backend]=nothing, [algorithm]=nothing, [prune]=true)\n\nCompute the Minkowski sum of two polyhedral sets.\n\nInput\n\nP         – polyhedral set\nQ         – polyhedral set\nbackend   – (optional, default: nothing) polyhedral computations backend\nalgorithm – (optional, default: nothing) algorithm to eliminate                variables; available options are Polyhedra.FourierMotzkin,                Polyhedra.BlockElimination, and Polyhedra.ProjectGenerators\nprune     – (optional, default: true) if true, apply a post-processing                to remove redundant constraints or vertices\n\nOutput\n\nIn two dimensions, if the sets are polygons, the result is a VPolygon. In higher dimensions, the result is an HPolytope if both P and Q are known to be bounded by their types, and an HPolyhedron otherwise.\n\nNotes\n\nThis method requires that the list of constraints of both sets P and Q can be obtained. After obtaining the respective lists of constraints, the minkowski_sum method for polyhedral sets is used.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/","page":"General sets (LazySet)","title":"General sets (LazySet)","text":"Undocumented implementations:","category":"page"},{"location":"lib/interfaces/LazySet/","page":"General sets (LazySet)","title":"General sets (LazySet)","text":"high\nlow\nexact_sum\nlinear_combination","category":"page"},{"location":"lib/interfaces/LazySet/#Plotting","page":"General sets (LazySet)","title":"Plotting","text":"","category":"section"},{"location":"lib/interfaces/LazySet/","page":"General sets (LazySet)","title":"General sets (LazySet)","text":"Plotting via the Plots package is available for one- or two-dimensional sets. The default algorithm is to plot an outer approximation using the support function (1D) respectively the support vector (2D). This means that (1) plotting will fail if these functionalities are not available (e.g., for lazy Intersections) and (2) that plots of non-convex sets can be misleading. The implementation below internally relies on the function plot_recipe. For some set types (e.g., Intersection), the default implementation is overridden.","category":"page"},{"location":"lib/interfaces/LazySet/#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol, Any}, LazySet{N}}, Tuple{AbstractDict{Symbol, Any}, LazySet{N}, Real}} where N","page":"General sets (LazySet)","title":"RecipesBase.apply_recipe","text":"plot_lazyset(X::LazySet{N}, [ε]::Real=N(PLOT_PRECISION); ...) where {N}\n\nPlot a set.\n\nInput\n\nX – set\nε – (optional, default: PLOT_PRECISION) approximation error bound\n\nNotes\n\nThis recipe just defines the default plotting options and then calls the function plot_recipe, which then implements the set-specific plotting.\n\nThe argument ε is ignored by some set types, e.g., for polyhedra (subtypes of AbstractPolyhedron).\n\nExamples\n\njulia> B = Ball2(ones(2), 0.1);\n\njulia> plot(B, 1e-3)  # default accuracy value (explicitly given for clarity here)\n\njulia> plot(B, 1e-2)  # faster but less accurate than the previous call\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#RecipesBase.apply_recipe-Union{Tuple{VN}, Tuple{N}, Tuple{AbstractDict{Symbol, Any}, AbstractVector{VN}}, Tuple{AbstractDict{Symbol, Any}, AbstractVector{VN}, Real}, Tuple{AbstractDict{Symbol, Any}, AbstractVector{VN}, Real, Int64}} where {N, VN<:LazySet{N}}","page":"General sets (LazySet)","title":"RecipesBase.apply_recipe","text":"plot_list(list::AbstractVector{VN}, [ε]::Real=N(PLOT_PRECISION),\n          [Nφ]::Int=PLOT_POLAR_DIRECTIONS; [same_recipe]=false; ...)\n    where {N, VN<:LazySet{N}}\n\nPlot a list of sets.\n\nInput\n\nlist – list of sets (1D or 2D)\nε    – (optional, default: PLOT_PRECISION) approximation error bound\nNφ   – (optional, default: PLOT_POLAR_DIRECTIONS) number of polar           directions (used to plot lazy intersections)\nsame_recipe – (optional, default: false) switch for faster plotting but           without individual plot recipes (see notes below)\n\nNotes\n\nFor each set in the list we apply an individual plot recipe.\n\nThe option same_recipe provides access to a faster plotting scheme where all sets in the list are first converted to polytopes and then plotted in one single run. This, however, is not suitable when plotting flat sets (line segments, singletons) because then the polytope plot recipe does not deliver good results. Hence by default we do not use this option. For plotting a large number of (non-flat) polytopes, we highly advise activating this option.\n\nExamples\n\njulia> B1 = BallInf(zeros(2), 0.4);\n\njulia> B2 = BallInf(ones(2), 0.4);\n\njulia> plot([B1, B2])\n\nSome of the sets in the list may not be plotted precisely but rather overapproximated first. The second argument ε controls the accuracy of this overapproximation.\n\njulia> Bs = [BallInf(zeros(2), 0.4), Ball2(ones(2), 0.4)];\n\njulia> plot(Bs, 1e-3)  # default accuracy value (explicitly given for clarity)\n\njulia> plot(Bs, 1e-2)  # faster but less accurate than the previous call\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.plot_vlist-Union{Tuple{S}, Tuple{S, Real}} where S<:LazySet","page":"General sets (LazySet)","title":"LazySets.plot_vlist","text":"plot_vlist(X::S, ε::Real) where {S<:LazySet}\n\nReturn a list of vertices used for plotting a two-dimensional set.\n\nInput\n\nX – two-dimensional set\nε – precision parameter\n\nOutput\n\nA list of vertices of a polygon P. For convex X, P usually satisfies that the Hausdorff distance to X is less than ε.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/#LazySets.plot_recipe-Tuple{LazySet, Any}","page":"General sets (LazySet)","title":"LazySets.plot_recipe","text":"plot_recipe(X::LazySet, [ε])\n\nConvert a compact convex set to a pair (x, y) of points for plotting.\n\nInput\n\nX – compact convex set\nε – approximation-error bound\n\nOutput\n\nA pair (x, y) of points that can be plotted.\n\nNotes\n\nWe do not support three-dimensional or higher-dimensional sets at the moment.\n\nAlgorithm\n\nOne-dimensional sets are converted to an Interval.\n\nFor two-dimensional sets, we first compute a polygonal overapproximation. The second argument, ε, corresponds to the error in Hausdorff distance between the overapproximating set and X. On the other hand, if you only want to produce a fast box-overapproximation of X, pass ε=Inf.\n\nFinally, we use the plot recipe for the constructed set (interval or polygon).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/LazySet/","page":"General sets (LazySet)","title":"General sets (LazySet)","text":"For three-dimensional sets, we support Makie:","category":"page"},{"location":"lib/interfaces/LazySet/#LazySets.plot3d","page":"General sets (LazySet)","title":"LazySets.plot3d","text":"plot3d(S::LazySet; [backend]=default_polyhedra_backend(S), [alpha]=1.0,\n       [color]=:blue, [colormap]=:viridis, [colorrange]=nothing,\n       [interpolate]=false, [overdraw]=false, [shading]=true,\n       [transparency]=true, [visible]=true)\n\nPlot a three-dimensional set using Makie.\n\nInput\n\nS            – set\nbackend      – (optional, default: default_polyhedra_backend(S)) backend                   for polyhedral computations\nalpha        – (optional, default: 1.0) float in [0,1]; the alpha or                   transparency value\ncolor        – (optional, default: :blue) Symbol or Colorant; the                   color of the main plot element (markers, lines, etc.), which                   can be a color symbol/string like :red\ncolormap     – (optional, default: :viridis) the color map of the main                   plot; use available_gradients() to see which gradients are                   available, which can also be used as [:red, :black]\ncolorrange   – (optional, default: nothing, which falls back to                   Makie.Automatic()) a tuple (min, max) where min and                   max specify the data range to be used for indexing the                   colormap\ninterpolate  – (optional, default: false) a boolean for heatmap and                   images; toggles color interpolation between nearby pixels\noverdraw     – (optional, default: false)\nshading      – (optional, default: true) a boolean that toggles shading                   (for meshes)\ntransparency – (optional, default: true) if true, the set is                   transparent, otherwise it is displayed as a solid object\nvisible      – (optional, default: true) a boolean that toggles                   visibility of the plot\n\nFor a complete list of attributes and usage see Makie's documentation.\n\nNotes\n\nThis plot recipe works by computing the list of constraints of S and converting to a polytope in H-representation. Then, this polytope is transformed with Polyhedra.Mesh and plotted using the mesh function.\n\nIf the function constraints_list is not applicable to your set S, try overapproximation first; e.g. via\n\njulia> Sapprox = overapproximate(S, SphericalDirections(10))\n\njulia> using Polyhedra, GLMakie\n\njulia> plot3d(Sapprox)\n\nThe number 10 above corresponds to the number of directions considered; for better resolution use higher values (but it will take longer).\n\nFor efficiency consider using the CDDLib backend, as in\n\njulia> using CDDLib\n\njulia> plot3d(Sapprox, backend=CDDLib.Library())\n\nExamples\n\nThe functionality requires both Polyhedra and a Makie backend. After loading LazySets, do using Polyhedra, GLMakie (or another Makie backend).\n\njulia> using LazySets, Polyhedra, GLMakie\n\njulia> plot3d(10 * rand(Hyperrectangle, dim=3))\n\njulia> plot3d!(10 * rand(Hyperrectangle, dim=3), color=:red)\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/LazySet/#LazySets.plot3d!","page":"General sets (LazySet)","title":"LazySets.plot3d!","text":"plot3d!(S::LazySet; backend=default_polyhedra_backend(S), [alpha]=1.0,\n       [color]=:blue, [colormap]=:viridis, [colorrange]=nothing,\n       [interpolate]=false, [overdraw]=false, [shading]=true,\n       [transparency]=true, [visible]=true)\n\nPlot a three-dimensional set using Makie.\n\nInput\n\nSee plot3d for the description of the inputs. For a complete list of attributes and usage see Makie's documentation.\n\nNotes\n\nSee the documentation of plot3d for examples.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/LazySet/#Aliases-for-set-types","page":"General sets (LazySet)","title":"Aliases for set types","text":"","category":"section"},{"location":"lib/interfaces/LazySet/#LazySets.CompactSet","page":"General sets (LazySet)","title":"LazySets.CompactSet","text":"CompactSet\n\nAn alias for compact set types.\n\nNotes\n\nMost lazy operations are not captured by this alias because whether their result is compact depends on the argument(s).\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/LazySet/#LazySets.NonCompactSet","page":"General sets (LazySet)","title":"LazySets.NonCompactSet","text":"NonCompactSet\n\nAn alias for non-compact set types.\n\nNotes\n\nMost lazy operations are not captured by this alias because whether their result is non-compact depends on the argument(s).\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/LazySet/#Implementations","page":"General sets (LazySet)","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/LazySet/","page":"General sets (LazySet)","title":"General sets (LazySet)","text":"Concrete set representations:","category":"page"},{"location":"lib/interfaces/LazySet/","page":"General sets (LazySet)","title":"General sets (LazySet)","text":"Empty set (EmptySet)","category":"page"},{"location":"lib/interfaces/LazySet/","page":"General sets (LazySet)","title":"General sets (LazySet)","text":"Lazy set operations:","category":"page"},{"location":"lib/interfaces/LazySet/","page":"General sets (LazySet)","title":"General sets (LazySet)","text":"Affine map (AffineMap)\nLinear map (LinearMap)\nExponential map (ExponentialMap)\nExponential projection map (ExponentialProjectionMap)\nReset map (ResetMap)\nTranslation\nBloating\nBinary Cartesian product (CartesianProduct)\nn-ary Cartesian product (CartesianProductArray)\nBinary convex hull (ConvexHull)\nn-ary convex hull (ConvexHullArray)\nBinary intersection\nn-ary intersection (IntersectionArray)\nBinary Minkowski sum (MinkowskiSum)\nn-ary Minkowski sum (MinkowskiSumArray)\nn-ary Minkowski sum with cache (CachedMinkowskiSumArray)\nBinary set union (UnionSet)\nn-ary set union (UnionSetArray)\nComplement\nRectification","category":"page"},{"location":"lib/lazy_operations/CartesianProduct/#Cartesian-product","page":"CartesianProduct","title":"Cartesian product","text":"","category":"section"},{"location":"lib/lazy_operations/CartesianProduct/#def_CartesianProduct","page":"CartesianProduct","title":"Binary Cartesian product (CartesianProduct)","text":"","category":"section"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.CartesianProduct","page":"CartesianProduct","title":"LazySets.CartesianProduct","text":"CartesianProduct{N, S1<:LazySet{N}, S2<:LazySet{N}} <: LazySet{N}\n\nType that represents the Cartesian product of two sets, i.e., the set\n\nZ =  z  ℝ^n + m  z = (x y)qquad x  X y  Y \n\nIf X  ℝ^n and Y  ℝ^m, then Z is n+m-dimensional.\n\nFields\n\nX – first set\nY – second set\n\nNotes\n\nSee also CartesianProductArray for an implementation of a Cartesian product of more than two sets.\n\nThe EmptySet is the almost absorbing element for CartesianProduct (except that the dimension is adapted).\n\nThe Cartesian product preserves convexity: if the set arguments are convex, then their Cartesian product is convex as well.\n\nIn some docstrings the word \"block\" is used to denote each wrapped set, with the natural order, i.e. we say that the first block of a Cartesian product cp is cp.X and the second block is cp.Y.\n\nExamples\n\nThe Cartesian product of two sets X and Y can be constructed either using CartesianProduct(X, Y) or the short-cut notation X × Y (to enter the times symbol, write \\times<tab>).\n\njulia> I1 = Interval(0, 1);\n\njulia> I2 = Interval(2, 4);\n\njulia> I12 = I1 × I2;\n\njulia> typeof(I12)\nCartesianProduct{Float64, Interval{Float64}, Interval{Float64}}\n\nA hyperrectangle is the Cartesian product of intervals, so we can convert I12 to a Hyperrectangle type:\n\njulia> convert(Hyperrectangle, I12)\nHyperrectangle{Float64, Vector{Float64}, Vector{Float64}}([0.5, 3.0], [0.5, 1.0])\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/CartesianProduct/#LinearAlgebra.:×-Tuple{LazySet, LazySet}","page":"CartesianProduct","title":"LinearAlgebra.:×","text":"×(X::LazySet, Y::LazySet)\n\nAlias for the binary Cartesian product.\n\nNotes\n\nThe function symbol can be typed via \\times<tab>.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#Base.:*-Tuple{LazySet, LazySet}","page":"CartesianProduct","title":"Base.:*","text":"    *(X::LazySet, Y::LazySet)\n\nAlias for the binary Cartesian product.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.swap-Tuple{CartesianProduct}","page":"CartesianProduct","title":"LazySets.swap","text":"swap(cp::CartesianProduct)\n\nReturn a new CartesianProduct object with the arguments swapped.\n\nInput\n\ncp – Cartesian product\n\nOutput\n\nA new CartesianProduct object with the arguments swapped.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.dim-Tuple{CartesianProduct}","page":"CartesianProduct","title":"LazySets.API.dim","text":"dim(cp::CartesianProduct)\n\nReturn the dimension of a Cartesian product.\n\nInput\n\ncp – Cartesian product\n\nOutput\n\nThe ambient dimension of the Cartesian product.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.ρ-Tuple{AbstractVector, CartesianProduct}","page":"CartesianProduct","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, cp::CartesianProduct)\n\nEvaluate the support function of a Cartesian product.\n\nInput\n\nd  – direction\ncp – Cartesian product\n\nOutput\n\nThe evaluation of the support function in the given direction. If the direction has norm zero, the result depends on the wrapped sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.σ-Tuple{AbstractVector, CartesianProduct}","page":"CartesianProduct","title":"LazySets.API.σ","text":"σ(d::AbstractVector, cp::CartesianProduct)\n\nReturn a support vector of a Cartesian product.\n\nInput\n\nd  – direction\ncp – Cartesian product\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the wrapped sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.isbounded-Tuple{CartesianProduct}","page":"CartesianProduct","title":"LazySets.API.isbounded","text":"isbounded(cp::CartesianProduct)\n\nCheck whether a Cartesian product is bounded.\n\nInput\n\ncp – Cartesian product\n\nOutput\n\ntrue iff both wrapped sets are bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#Base.:∈-Tuple{AbstractVector, CartesianProduct}","page":"CartesianProduct","title":"Base.:∈","text":"∈(x::AbstractVector, cp::CartesianProduct)\n\nCheck whether a given point is contained in a Cartesian product.\n\nInput\n\nx  – point/vector\ncp – Cartesian product\n\nOutput\n\ntrue iff x  cp.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#Base.isempty-Tuple{CartesianProduct}","page":"CartesianProduct","title":"Base.isempty","text":"isempty(cp::CartesianProduct)\n\nCheck whether a Cartesian product is empty.\n\nInput\n\ncp – Cartesian product\n\nOutput\n\ntrue iff any of the sub-blocks is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.center-Tuple{CartesianProduct}","page":"CartesianProduct","title":"LazySets.API.center","text":"center(cp::CartesianProduct)\n\nReturn the center of a Cartesian product of centrally-symmetric sets.\n\nInput\n\ncp – Cartesian product of centrally-symmetric sets\n\nOutput\n\nThe center of the Cartesian product.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.constraints_list-Tuple{CartesianProduct}","page":"CartesianProduct","title":"LazySets.API.constraints_list","text":"constraints_list(cp::CartesianProduct)\n\nReturn the list of constraints of a (polyhedral) Cartesian product.\n\nInput\n\ncp – polyhedral Cartesian product\n\nOutput\n\nA list of constraints.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.vertices_list-Tuple{CartesianProduct}","page":"CartesianProduct","title":"LazySets.API.vertices_list","text":"vertices_list(cp::CartesianProduct)\n\nReturn the list of vertices of a (polytopic) Cartesian product.\n\nInput\n\ncp – polytopic Cartesian product\n\nOutput\n\nA list of vertices.\n\nAlgorithm\n\nWe assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.linear_map-Tuple{AbstractMatrix, CartesianProduct}","page":"CartesianProduct","title":"LazySets.API.linear_map","text":"linear_map(M::AbstractMatrix, cp::CartesianProduct)\n\nConcrete linear map of a (polyhedral) Cartesian product.\n\nInput\n\nM  – matrix\ncp – Cartesian product\n\nOutput\n\nA polytope if cp is bounded and a polyhedron otherwise.\n\nAlgorithm\n\nWe convert the Cartesian product to constraint representation and then call linear_map on the corresponding polyhedron.\n\nThis is a fallback implementation and will fail if the wrapped sets are not polyhedral.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.volume-Tuple{CartesianProduct}","page":"CartesianProduct","title":"LazySets.API.volume","text":"volume(cp::CartesianProduct)\n\nCompute the volume of a Cartesian product.\n\nInput\n\ncp – Cartesian product\n\nOutput\n\nThe volume.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.project-Union{Tuple{N}, Tuple{CartesianProduct{N, <:Interval, <:AbstractHyperrectangle}, AbstractVector{Int64}}} where N","page":"CartesianProduct","title":"LazySets.API.project","text":"project(cp::CartesianProduct{N,<:Interval,<:AbstractHyperrectangle},\n        block::AbstractVector{Int};\n        [kwargs...]) where {N}\n\nConcrete projection of the Cartesian product of an interval and a hyperrectangular set.\n\nInput\n\ncp    – Cartesian product of an interval and a hyperrectangle\nblock – block structure, a vector with the dimensions of interest\n\nOutput\n\nA hyperrectangle representing the projection of the Cartesian product cp on the dimensions specified by block.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.project-Union{Tuple{N}, Tuple{CartesianProduct{N, <:Interval, <:AbstractZonotope}, AbstractVector{Int64}}} where N","page":"CartesianProduct","title":"LazySets.API.project","text":"project(cp::CartesianProduct{N,<:Interval,<:AbstractZonotope},\n        block::AbstractVector{Int};\n        [kwargs...]) where {N}\n\nConcrete projection of the Cartesian product of an interval and a zonotopic set.\n\nInput\n\ncp    – Cartesian product of an interval and a zonotopic set\nblock – block structure, a vector with the dimensions of interest\n\nOutput\n\nA zonotope representing the projection of the Cartesian product cp on the dimensions specified by block.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.project-Union{Tuple{N}, Tuple{CartesianProduct{N, <:Interval, <:Union{VPolygon, VPolytope}}, AbstractVector{Int64}}} where N","page":"CartesianProduct","title":"LazySets.API.project","text":"project(cp::CartesianProduct{N,<:Interval,<:Union{VPolygon,VPolytope}\n        block::AbstractVector{Int};\n        [kwargs...]) where {N}\n\nConcrete projection of the Cartesian product of an interval and a set in vertex representation.\n\nInput\n\ncp    – Cartesian product of an interval and a VPolygon or a VPolytope\nblock – block structure, a vector with the dimensions of interest\n\nOutput\n\nA VPolytope representing the projection of the Cartesian product cp on the dimensions specified by block.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/","page":"CartesianProduct","title":"CartesianProduct","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/CartesianProduct/","page":"CartesianProduct","title":"CartesianProduct","text":"norm\nradius\ndiameter\n[an_element](@ref an_element(::LazySet)\nsingleton_list\nreflect","category":"page"},{"location":"lib/lazy_operations/CartesianProduct/#def_CartesianProductArray","page":"CartesianProduct","title":"n-ary Cartesian product (CartesianProductArray)","text":"","category":"section"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.CartesianProductArray","page":"CartesianProduct","title":"LazySets.CartesianProductArray","text":"CartesianProductArray{N, S<:LazySet{N}} <: LazySet{N}\n\nType that represents the Cartesian product of a finite number of sets.\n\nFields\n\narray – array of sets\n\nNotes\n\nThe Cartesian product preserves convexity: if the set arguments are convex, then their Cartesian product is convex as well.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.CartesianProduct!","page":"CartesianProduct","title":"LazySets.CartesianProduct!","text":"CartesianProduct!(X, Y)\n\nConvenience function to compute the lazy Cartesian product and modify CartesianProductArrays in-place.\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/CartesianProduct/#LinearAlgebra.:×-Tuple{LazySet, Vararg{LazySet}}","page":"CartesianProduct","title":"LinearAlgebra.:×","text":"×(X::LazySet, Xs::LazySet...)\n×(Xs::Vector{<:LazySet})\n\nAlias for the n-ary Cartesian product.\n\nNotes\n\nThe function symbol can be typed via \\times<tab>.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#Base.:*-Tuple{LazySet, Vararg{LazySet}}","page":"CartesianProduct","title":"Base.:*","text":"    *(X::LazySet, Xs::LazySet...)\n    *(Xs::Vector{<:LazySet})\n\nAlias for the n-ary Cartesian product.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.dim-Tuple{CartesianProductArray}","page":"CartesianProduct","title":"LazySets.API.dim","text":"dim(cpa::CartesianProductArray)\n\nReturn the dimension of a Cartesian product of a finite number of sets.\n\nInput\n\ncpa – Cartesian product of a finite number of sets\n\nOutput\n\nThe ambient dimension of the Cartesian product of a finite number of sets, or 0 if there is no set in the array.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.ρ-Tuple{AbstractVector, CartesianProductArray}","page":"CartesianProduct","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, cpa::CartesianProductArray)\n\nEvaluate the support function of a Cartesian product of a finite number of sets.\n\nInput\n\nd   – direction\ncpa – Cartesian product of a finite number of sets\n\nOutput\n\nThe evaluation of the support function in the given direction. If the direction has norm zero, the result depends on the wrapped sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.σ-Tuple{AbstractVector, CartesianProductArray}","page":"CartesianProduct","title":"LazySets.API.σ","text":"σ(d::AbstractVector, cpa::CartesianProductArray)\n\nCompute a support vector of a Cartesian product of a finite number of sets.\n\nInput\n\nd   – direction\ncpa – Cartesian product of a finite number of sets\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the product sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.isbounded-Tuple{CartesianProductArray}","page":"CartesianProduct","title":"LazySets.API.isbounded","text":"isbounded(cpa::CartesianProductArray)\n\nCheck whether a Cartesian product of a finite number of sets is bounded.\n\nInput\n\ncpa – Cartesian product of a finite number of sets\n\nOutput\n\ntrue iff all wrapped sets are bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#Base.:∈-Tuple{AbstractVector, CartesianProductArray}","page":"CartesianProduct","title":"Base.:∈","text":"∈(x::AbstractVector, cpa::CartesianProductArray)\n\nCheck whether a given point is contained in a Cartesian product of a finite number of sets.\n\nInput\n\nx   – point/vector\ncpa – Cartesian product of a finite number of sets\n\nOutput\n\ntrue iff x  textcpa.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#Base.isempty-Tuple{CartesianProductArray}","page":"CartesianProduct","title":"Base.isempty","text":"isempty(cpa::CartesianProductArray)\n\nCheck whether a Cartesian product of a finite number of sets is empty.\n\nInput\n\ncpa – Cartesian product of a finite number of sets\n\nOutput\n\ntrue iff any of the sub-blocks is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.center-Tuple{CartesianProductArray}","page":"CartesianProduct","title":"LazySets.API.center","text":"center(cpa::CartesianProductArray)\n\nCompute the center of a Cartesian product of a finite number of centrally-symmetric sets.\n\nInput\n\ncpa – Cartesian product of a finite number of centrally-symmetric sets\n\nOutput\n\nThe center of the Cartesian product of a finite number of sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.constraints_list-Tuple{CartesianProductArray}","page":"CartesianProduct","title":"LazySets.API.constraints_list","text":"constraints_list(cpa::CartesianProductArray)\n\nCompute a list of constraints of a (polyhedral) Cartesian product of a finite number of sets.\n\nInput\n\ncpa – Cartesian product of a finite number of sets\n\nOutput\n\nA list of constraints.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.vertices_list-Tuple{CartesianProductArray}","page":"CartesianProduct","title":"LazySets.API.vertices_list","text":"vertices_list(cpa::CartesianProductArray)\n\nCompute a list of vertices of a (polytopic) Cartesian product of a finite number of sets.\n\nInput\n\ncpa – Cartesian product of a finite number of sets\n\nOutput\n\nA list of vertices.\n\nAlgorithm\n\nWe assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.linear_map-Tuple{AbstractMatrix, CartesianProductArray}","page":"CartesianProduct","title":"LazySets.API.linear_map","text":"linear_map(M::AbstractMatrix, cpa::CartesianProductArray)\n\nConcrete linear map of a Cartesian product of a finite number of (polyhedral) sets.\n\nInput\n\nM   – matrix\ncpa – Cartesian product of a finite number of sets\n\nOutput\n\nA polyhedron or polytope.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.array-Tuple{CartesianProductArray}","page":"CartesianProduct","title":"LazySets.array","text":"array(cpa::CartesianProductArray)\n\nReturn the array of a Cartesian product of a finite number of sets.\n\nInput\n\ncpa – Cartesian product of a finite number of sets\n\nOutput\n\nThe array of a Cartesian product of a finite number of sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.API.volume-Tuple{CartesianProductArray}","page":"CartesianProduct","title":"LazySets.API.volume","text":"volume(cpa::CartesianProductArray)\n\nCompute the volume of a Cartesian product of a finite number of sets.\n\nInput\n\ncpa – Cartesian product of a finite number of sets\n\nOutput\n\nThe volume.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.block_structure-Tuple{CartesianProductArray}","page":"CartesianProduct","title":"LazySets.block_structure","text":"block_structure(cpa::CartesianProductArray)\n\nCompute an array containing the dimension ranges of each block of a Cartesian product of a finite number of sets.\n\nInput\n\ncpa – Cartesian product of a finite number of sets\n\nOutput\n\nA vector of ranges.\n\nExample\n\njulia> using LazySets: block_structure\n\njulia> cpa = CartesianProductArray([BallInf(zeros(n), 1.0) for n in [3, 1, 2]]);\n\njulia> block_structure(cpa)\n3-element Vector{UnitRange{Int64}}:\n 1:3\n 4:4\n 5:6\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.block_to_dimension_indices-Tuple{CartesianProductArray, Vector{Int64}}","page":"CartesianProduct","title":"LazySets.block_to_dimension_indices","text":"block_to_dimension_indices(cpa::CartesianProductArray{N},\n                           vars::Vector{Int}) where {N}\n\nCompute a vector mapping block index i to tuple (f, l) such that either f = l = -1 or f is the first dimension index and l is the last dimension index of the i-th block, depending on whether one of the block's dimension indices is specified in vars.\n\nInput\n\ncpa  – Cartesian product of a finite number of sets\nvars – list containing the variables of interest, sorted in ascending order\n\nOutput\n\n(i) A vector of pairs, where each pair corresponds to the range of dimensions in the i-th block.\n\n(ii) The number of constrained blocks.\n\nExample\n\njulia> using LazySets: block_to_dimension_indices\n\njulia> cpa = CartesianProductArray([BallInf(zeros(n), 1.0) for n in [1, 3, 2, 3]]);\n\njulia> m, k = block_to_dimension_indices(cpa, [2, 4, 8]);\n\njulia> m\n4-element Vector{Tuple{Int64, Int64}}:\n (-1, -1)\n (2, 4)\n (-1, -1)\n (7, 9)\n\njulia> k\n2\n\nThe vector m represents the mapping \"second block from dimension 2 to dimension 4, fourth block from dimension 7 to dimension 9.\" These blocks contain the dimensions specified in vars=[2, 4, 8]. The number of constrained blocks is k = 2 (2nd and 4th blocks).\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.substitute_blocks-Tuple{CartesianProductArray, CartesianProductArray, Vector{Tuple{Int64, Int64}}}","page":"CartesianProduct","title":"LazySets.substitute_blocks","text":"substitute_blocks(low_dim_cpa::CartesianProductArray,\n                  orig_cpa::CartesianProductArray,\n                  blocks::Vector{Tuple{Int, Int}})\n\nReturn a Cartesian product of a finite number of sets (CPA) obtained by merging an original CPA with a low-dimensional CPA, which represents the updated subset of variables in the specified blocks.\n\nInput\n\nlow_dim_cpa – low-dimensional Cartesian product of a finite number of sets\norig_cpa    – original high-dimensional Cartesian product of a finite                  number of sets\nblocks      – index of the first variable in each block of orig_cpa\n\nOutput\n\nThe merged Cartesian product.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/","page":"CartesianProduct","title":"CartesianProduct","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/CartesianProduct/","page":"CartesianProduct","title":"CartesianProduct","text":"norm\nradius\ndiameter\n[an_element](@ref an_element(::LazySet)\nsingleton_list\nreflect","category":"page"},{"location":"man/concrete_polyhedra/#Concrete-Polyhedra","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"","category":"section"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"The focus of LazySets.jl is to wrap set representations and operations into specialized types, delaying the evaluation of the result of an expression until it is necessary. However, sometimes it is desirable to perform an explicit computation. For concrete operations with polyhedra we rely on the polyhedra manipulation library Polyhedra.jl.","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"Polyhedra.jl provides a unified interface to well-known implementations of polyhedral computations (which we also call backends) such as CDD or LRS. See the complete list in the documentation of Polyhedra.jl. This is a great advantage because we can easily use a library that supports floating point arithmetic, rational arithmetic, multiple precision, etc. The libraries also include projection and elimination of variables through Fourier-Motzkin. If you are interested in specific numeric types different from the default Float64, such as Float32, these may not be supported by the backend, in which case Julia may automatically promote to, e.g., Float64. As an example, CDD (which is used via the wrapper package CDDLib.jl) can only be used with numeric type Float64 for floating-point arithmetic and with numeric type Rational{BigInt} for exact arithmetic.","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"Below we give examples of operations that are performed using Polyhedra.jl.","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"Pages = [\"concrete_polyhedra.md\"]\nDepth = 3","category":"page"},{"location":"man/concrete_polyhedra/#Creating-polyhedra","page":"Concrete Polyhedra","title":"Creating polyhedra","text":"","category":"section"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"To use the Polyhedra.jl interface, you need to load the package with using Polyhedra. Let's create an H-representation object:","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"using Plots, LazySets, Polyhedra, LinearAlgebra\n\nA = [1. 1;1 -1;-1 0]\nb = [1.,0,0]\nH = Polyhedra.hrep(A, b)","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"It is used to instantiate a new polyhedron:","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"p = polyhedron(H)","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"Now, p is of the generic type Polyhedra.SimplePolyhedron{2,Float64, ...}, where 2 states for its ambient dimension, and Float64 the numeric field. The remaining fields specify the type of representation:","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"typeof(p)","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"Observe that we can use a particular backend, such as the CDD library:","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"using CDDLib\n\np = polyhedron(H, CDDLib.Library())","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"On the other hand, a LazySets.HPolytope object can be constructed from p:","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"x = convert(HPolytope, p)\nx.constraints","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"Conversely, from a HPolytope we can build a polyhedron:","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"y = polyhedron(x)\ntypeof(y)","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"Moreover, you can specify the backend with an extra argument. For instance, we can use an exact representation through the Library(:exact):","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"A, b = Rational{Int}[1 1;1 -1;-1 0], Rational{Int}[1,0,0]\np = HPolytope(A, b)\n\npolyhedron(p; backend=CDDLib.Library(:exact))","category":"page"},{"location":"man/concrete_polyhedra/#Methods","page":"Concrete Polyhedra","title":"Methods","text":"","category":"section"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"The utility methods available are convex hull, intersection and cartesian product. The dual representation as a list of vertices can be obtained with the vertices_list function.","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"p = HPolytope([LinearConstraint([1.0, 0.0], 1.0),\n               LinearConstraint([0.0, 1.0], 1.0),\n               LinearConstraint([-1.0, 0.0], 1.0),\n               LinearConstraint([0.0, -1.0], 1.0)])\n\nconstraints_list(p)","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"vertices_list(p)","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"For example, the concrete intersection of two polytopes is performed with the intersection method.","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"E = Ellipsoid(ones(2), Diagonal([2.0, 0.5]))\nB = Ball1([2.5, 1.5], .8)\n\nimport LazySets.Approximations.overapproximate\npolyoverapprox(x) = HPolytope(overapproximate(x, 1e-3).constraints)\n\nEpoly = polyoverapprox(E)\nBpoly = polyoverapprox(B)\nX = intersection(Epoly, Bpoly)\n\nplot(E, 1e-3, aspectratio=1, alpha=0.4)\nplot!(B, 1e-3, alpha=0.4)\nplot!(X, 1e-3, alpha=0.4, color=\"black\")","category":"page"},{"location":"man/concrete_polyhedra/#Projections","page":"Concrete Polyhedra","title":"Projections","text":"","category":"section"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"Projection of high-dimensional polyhedra and elimination of variables can be performed with the eliminate function, which supports three types of methods: :FourierMotzkin, :BlockElimination and :ProjectGenerators.","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"For further details, see the documentation of Polyhedra.jl.","category":"page"},{"location":"lib/interfaces/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"lib/interfaces/overview/#LazySets.LazySets","page":"Overview","title":"LazySets.LazySets","text":"LazySets\n\nScalable symbolic-numeric set computations in Julia.\n\n\n\n\n\n","category":"module"},{"location":"lib/interfaces/overview/","page":"Overview","title":"Overview","text":"This section of the manual describes the interfaces for different set types. Every set that fits the description of an interface should also implement it. This helps in several ways:","category":"page"},{"location":"lib/interfaces/overview/","page":"Overview","title":"Overview","text":"avoid code duplicates,\nprovide functions for many sets at once,\nallow changes in the source code without changing the API.","category":"page"},{"location":"lib/interfaces/overview/","page":"Overview","title":"Overview","text":"The interface functions are outlined in the interface documentation. For implementations of the interfaces see the corresponding sub-pages linked in the respective sections.","category":"page"},{"location":"lib/interfaces/overview/","page":"Overview","title":"Overview","text":"note: Note\nThe naming convention is such that all interface names (with the exception of the main abstract type LazySet) should be preceded by Abstract.","category":"page"},{"location":"lib/interfaces/overview/","page":"Overview","title":"Overview","text":"The following diagram shows the interface hierarchy.","category":"page"},{"location":"lib/interfaces/overview/","page":"Overview","title":"Overview","text":"(Image: )","category":"page"},{"location":"lib/lazy_operations/Translation/#def_Translation","page":"Translation","title":"Translation","text":"","category":"section"},{"location":"lib/lazy_operations/Translation/#LazySets.Translation","page":"Translation","title":"LazySets.Translation","text":"Translation{N, S<:LazySet{N}, VN<:AbstractVector{N}}\n    <: AbstractAffineMap{N, S}\n\nType that represents a lazy translation.\n\nThe translation of set X along vector v is the map:\n\nx  x + vqquad x  X\n\nA translation is a special case of an affine map A x + b x  X where the linear map A is the identity matrix and the translation vector b is v.\n\nFields\n\nX – set\nv – vector that defines the translation\n\nNotes\n\nTranslation preserves convexity: if X is convex, then any translation of X is convex as well.\n\nExample\n\njulia> X = BallInf([2.0, 2.0, 2.0], 1.0);\n\njulia> v = [1.0, 0.0, 0.0]; # translation along dimension 1\n\njulia> tr = Translation(X, v);\n\njulia> typeof(tr)\nTranslation{Float64, BallInf{Float64, Vector{Float64}}, Vector{Float64}}\n\njulia> tr.X\nBallInf{Float64, Vector{Float64}}([2.0, 2.0, 2.0], 1.0)\n\njulia> tr.v\n3-element Vector{Float64}:\n 1.0\n 0.0\n 0.0\n\nBoth the sum operator + and the Minkowski-sum operator ⊕ are overloaded to create translations:\n\njulia> X + v == X ⊕ v == Translation(X, v)\ntrue\n\nThe translation of a translation is performed immediately:\n\njulia> tr = (X + v) + v\nTranslation{Float64, BallInf{Float64, Vector{Float64}}, Vector{Float64}}(BallInf{Float64, Vector{Float64}}([2.0, 2.0, 2.0], 1.0), [2.0, 0.0, 0.0])\n\njulia> tr.v\n3-element Vector{Float64}:\n 2.0\n 0.0\n 0.0\n\nThe dimension of a translation is obtained with the dim function:\n\njulia> dim(tr)\n3\n\nFor the support vector (resp. support function) along vector d, use σ and ρ, respectively:\n\njulia> σ([1.0, 0.0, 0.0], tr)\n3-element Vector{Float64}:\n 5.0\n 2.0\n 2.0\n\njulia> ρ([1.0, 0.0, 0.0], tr)\n5.0\n\nSee the docstring of each of these functions for details.\n\nThe an_element function is useful to obtain an element of a translation:\n\njulia> e = an_element(tr)\n3-element Vector{Float64}:\n 4.0\n 2.0\n 2.0\n\nThe lazy linear map of a translation is an affine map, since the following simplification rule applies: M * (X  v) = (M * X)  (M * v):\n\njulia> using LinearAlgebra: I\n\njulia> M = Matrix(2.0I, 3, 3);\n\njulia> Q = M * tr;\n\njulia> Q isa AffineMap && Q.M == M && Q.X == tr.X && Q.v == 2 * tr.v\ntrue\n\nUse the isempty method to check whether the translation is empty:\n\njulia> isempty(tr)\nfalse\n\nThe list of constraints of the translation of a polyhedral set (a set whose constraints_list is available) can be computed from a lazy translation:\n\njulia> constraints_list(tr)\n6-element Vector{HalfSpace{Float64, ReachabilityBase.Arrays.SingleEntryVector{Float64}}}:\n HalfSpace{Float64, ReachabilityBase.Arrays.SingleEntryVector{Float64}}([1.0, 0.0, 0.0], 5.0)\n HalfSpace{Float64, ReachabilityBase.Arrays.SingleEntryVector{Float64}}([0.0, 1.0, 0.0], 3.0)\n HalfSpace{Float64, ReachabilityBase.Arrays.SingleEntryVector{Float64}}([0.0, 0.0, 1.0], 3.0)\n HalfSpace{Float64, ReachabilityBase.Arrays.SingleEntryVector{Float64}}([-1.0, 0.0, 0.0], -3.0)\n HalfSpace{Float64, ReachabilityBase.Arrays.SingleEntryVector{Float64}}([0.0, -1.0, 0.0], -1.0)\n HalfSpace{Float64, ReachabilityBase.Arrays.SingleEntryVector{Float64}}([0.0, 0.0, -1.0], -1.0)\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/Translation/#Base.:+-Tuple{LazySet, AbstractVector}","page":"Translation","title":"Base.:+","text":"+(X::LazySet, v::AbstractVector)\n\nConvenience constructor for a translation.\n\nInput\n\nX – set\nv – vector\n\nOutput\n\nThe symbolic translation of X along vector v.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Translation/#LazySets.:⊕-Tuple{LazySet, AbstractVector}","page":"Translation","title":"LazySets.:⊕","text":"⊕(X::LazySet, v::AbstractVector)\n\nUnicode alias constructor ⊕ (oplus) for the lazy translation operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Translation/#LazySets.API.ρ-Tuple{AbstractVector, Translation}","page":"Translation","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, tr::Translation)\n\nEvaluate the support function of a translation.\n\nInput\n\nd  – direction\ntr – translation of a set\n\nOutput\n\nThe evaluation of the support function in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Translation/#LazySets.API.σ-Tuple{AbstractVector, Translation}","page":"Translation","title":"LazySets.API.σ","text":"σ(d::AbstractVector, tr::Translation)\n\nReturn a support vector of a translation.\n\nInput\n\nd  – direction\ntr – translation of a set\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Translation/#LazySets.API.an_element-Tuple{Translation}","page":"Translation","title":"LazySets.API.an_element","text":"an_element(tr::Translation)\n\nReturn some element of a translation.\n\nInput\n\ntr – translation of a set\n\nOutput\n\nAn element in the translation.\n\nNotes\n\nThis function first asks for an_element of the wrapped set, then translates this element according to the given translation vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Translation/#LazySets.API.constraints_list-Tuple{Translation}","page":"Translation","title":"LazySets.API.constraints_list","text":"constraints_list(tr::Translation)\n\nReturn a list of constraints of the translation of a set.\n\nInput\n\ntr – translation of a polyhedron\n\nOutput\n\nA list of constraints of the translation.\n\nNotes\n\nWe assume that the set wrapped by the lazy translation X offers a method constraints_list(⋅).\n\nAlgorithm\n\nLet the translation be defined by the set of points y such that y = x + v for all x ∈ X. Then, each defining halfspace a⋅x ≤ b is transformed to a⋅y ≤ b + a⋅v.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Translation/#LazySets.API.linear_map-Tuple{AbstractMatrix, Translation}","page":"Translation","title":"LazySets.API.linear_map","text":"linear_map(M::AbstractMatrix, tr::Translation)\n\nConcrete linear map of a translation.\n\nInput\n\nM  – matrix\ntr – translation of a set\n\nOutput\n\nA concrete set corresponding to the linear map. The type of the result depends on the type of the set wrapped by tr.\n\nAlgorithm\n\nWe compute affine_map(M, tr.X, M * tr.v).\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Translation/#Base.:∈-Tuple{AbstractVector, Translation}","page":"Translation","title":"Base.:∈","text":"∈(x::AbstractVector, tr::Translation)\n\nCheck whether a given point is contained in the translation of a set.\n\nInput\n\nx  – point/vector\ntr – translation of a set\n\nOutput\n\ntrue iff x  tr.\n\nAlgorithm\n\nThis implementation relies on the set-membership function for the wrapped set tr.X, since x  X  v iff x - v  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Translation/#LazySets.API.center-Tuple{Translation}","page":"Translation","title":"LazySets.API.center","text":"center(tr::Translation)\n\nReturn the center of the translation of a centrally-symmetric set.\n\nInput\n\ntr – translation of a centrally-symmetric set\n\nOutput\n\nThe translation of the center of the wrapped set by the translation vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Translation/","page":"Translation","title":"Translation","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/Translation/","page":"Translation","title":"Translation","text":"norm\nradius\ndiameter\nsingleton_list\nreflect","category":"page"},{"location":"lib/lazy_operations/Translation/","page":"Translation","title":"Translation","text":"Inherited from AbstractAffineMap:","category":"page"},{"location":"lib/lazy_operations/Translation/","page":"Translation","title":"Translation","text":"dim\nisempty\nisbounded\nvertices_list","category":"page"},{"location":"man/parallel_approximations/#Parallel-Approximations","page":"Parallel Approximations","title":"Parallel Approximations","text":"","category":"section"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"A subset of the approximation algorithms are implemented in parallel in the LazySets.Parallel module. In order to use parallel versions of the algorithms, you can write:","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"using LazySets\nimport LazySets.Parallel\n\n# call a method implemented in parallel, for example:\nS = Ball2(ones(100), 1.0)\nParallel.box_approximation(S)","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"Note that after importing or using LazySets.Parallel, the version of the function used must be fully qualified, eg. LazySets.Approximations.box_approximation for the sequential version or LazySets.Parallel.box_approximation for the parallel version.","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"The parallelization strategy that is available uses processes. To set the number of processes N, use the flag -p N at julia startup. For example, do","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"$ julia -p 4","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"to launch 4 additional local worker julia processes. Use the keyword auto, as in","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"$ julia -p auto","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"to launch as many workers as the number of local CPU cores.","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"Pages = [\"parallel_approximations.md\"]\nDepth = 3","category":"page"},{"location":"man/parallel_approximations/#Parallel-interval-hulls","page":"Parallel Approximations","title":"Parallel interval hulls","text":"","category":"section"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"As an illustration of the symmetric interval hull approximation of a nested lazy set computed in parallel, consider the following calculation. It arises in the discretization of set-based ODEs, and is defined below for an artificial example of a tridiagonal matrix of order n, where n is a positive integer.","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"using LazySets, Expokit\nusing SparseArrays, LinearAlgebra\n\n# define an nxn tridiagonal matrix\nA(n) = sparse(diagm(0 => fill(0.05, n), -1 => fill(-1, n-1), 1 => fill(-1, n-1)))\n\n# step size and initial set\nδ = 0.1\nX0(n) = Ball2(ones(n), 0.1)\n\n# input coefficients matrix (nx2 matrix with coefficients from -1 to 1)\nb(n) = vcat(range(-1, stop=1, length=n))\nB(n) = [b(n) b(n)]\nU = BallInf(zeros(2), 1.2)\n\n# lazy matrix exponential\neAδ(n) = SparseMatrixExp(A(n) * δ)\n\n# set that we want to overapproximate with an interval hull\nY(n) = ConvexHull(eAδ(n) * X0(n) ⊕ (δ * B(n) * U), X0(n))","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"The set Y(n) is parametric in the system's dimension n, to facilitate benchmarking. We will explore the computational cost as the dimension n increases, and compare the sequential algorithm with the parallel algorithm.","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"Given the lazy set Y(n), we want to calculate the symmetric interval hull, which corresponds to finding the smallest n-dimensional hyperrectangle that contains the set Y(n) and is symmetric with respect to the origin. Notice that this operation is inherently parallel, since one can evaluate the support function of Y independently in each dimension from 1 to n.","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"The sequential algorithm returns the following execution times. We use the @btime macro from the BenchmarkTools package to have a more accurate timing than @time; the $n argument is used for interpolation of the arguments (if you are not benchmarking, pass n to symmetric_interval_hull, as usual).","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"using BenchmarkTools\n\nfor n in [50, 100, 500, 1000]\n    @btime res = Approximations.symmetric_interval_hull(Y($n));\nend","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"  59.103 ms (11554 allocations: 25.89 MiB)\n  129.453 ms (23118 allocations: 54.16 MiB)\n  1.943 s (115530 allocations: 381.26 MiB)\n  10.017 s (232506 allocations: 1.01 GiB)","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"For the parallel benchmark, we start Julia with 4 processes with the command $ julia -p 4 and call LazySets.Parallel.symmetric_interval_hull(Y(n)).","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"import LazySets.Parallel\n\nfor n in [50, 100, 500, 1000]\n    @btime LazySets.Parallel.symmetric_interval_hull($Y($n));\nend","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"  6.846 ms (2550 allocations: 160.59 KiB)\n  13.544 ms (3528 allocations: 271.94 KiB)\n  387.556 ms (11155 allocations: 2.51 MiB)\n  2.638 s (22156 allocations: 8.77 MiB)","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"In the following table we summarize the speedup.","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"n Sequential (s) Parallel p=4 (s) Speedup\n50 0.059 0.007 8.42\n100 0.129 0.013 9.92\n500 1.94 0.387 4.96\n1000 10.0 2.64 3.79","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"The results in this section were obtained with a standard MacBook Pro laptop with the following specifications:","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"julia> versioninfo()","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"Julia Version 1.0.2\nCommit d789231e99 (2018-11-08 20:11 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin14.5.0)\n  CPU: Intel(R) Core(TM) i7-4770HQ CPU @ 2.20GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-6.0.0 (ORCJIT, haswell)","category":"page"},{"location":"man/polyhedral_approximations/#Polyhedral-Approximations","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"","category":"section"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"In this section we review the mathematical notation and results from convex geometry that are used throughout LazySets.","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"Pages = [\"polyhedral_approximations.md\"]\nDepth = 3","category":"page"},{"location":"man/polyhedral_approximations/#Preliminaries","page":"Polyhedral Approximations","title":"Preliminaries","text":"","category":"section"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"Let us introduce some notation. For p geq 1, the p-norm of an n-dimensional vector x  ℝ^n is denoted  x _p.","category":"page"},{"location":"man/polyhedral_approximations/#Support-Function","page":"Polyhedral Approximations","title":"Support Function","text":"","category":"section"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"The support function is a basic notion for approximating convex sets. Let mathcalX subset ℝ^n be a compact convex set. The support function of mathcalX is the function rho_mathcalX  ℝ^nto ℝ, defined as","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"rho_mathcalX(ell) = maxlimits_x  mathcalX ell^mathrmT x","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"We recall the following elementary properties of the support function. Let (ell_1 ell_2) denote the concatenation of vectors ell_1 and ell_2.","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"Proposition. For all compact convex sets mathcalX, mathcalY in ℝ^n, mathcalZ in ℝ^m, all n n real matrices M, all scalars lambda, and all vectors ell ell_1  ℝ^n, ell_2  ℝ^m, we have:","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"beginaligned\nquad rho_lambdamathcalX (ell) = rho_mathcalX (lambda ell)\ntext and  rho_lambdamathcalX (ell) = lambda rho_mathcalX (ell) text if  lambda  0 1mm\n\nquad rho_MmathcalX (ell) = rho_mathcalX (M^mathrmT ell) 1mm\n\nquad rho_mathcalX  mathcalY (ell) = rho_mathcalX (ell) + rho_mathcalY (ell) 1mm\n\nquad rho_mathcalX  mathcalZ (ell_1 ell_2) = (ell_1 ell_2)^mathrmT sigma_mathcalX  mathcalZ(ell_1 ell_2) = rho_mathcalX(ell_1) + rho_mathcalZ(ell_2) 1mm\n\nquad rho_mathrmCH(mathcalX  mathcalY) (ell) = max (rho_mathcalX (ell) rho_mathcalY (ell))\nendaligned","category":"page"},{"location":"man/polyhedral_approximations/#Support-Vector","page":"Polyhedral Approximations","title":"Support Vector","text":"","category":"section"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"The farthest points of mathcalX in the direction ell are the support vectors denoted sigma_mathcalX(ell). These points correspond to the optimal points for the support function, i.e.,","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"sigma_mathcalX(ell) =  x  mathcalX  ell^mathrmT x  = rho_mathcalX(ell)  ","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"Since all support vectors in a given direction evaluate to the same value of the support function, we often speak of the support vector, where the choice of any support vector is implied.","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"(Image: Illustration of the support function and the support vector)","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"Proposition 2. Under the same conditions as in Proposition 1, the following hold:","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"beginaligned\nquad sigma_lambdamathcalX (ell) = lambda sigma_mathcalX (lambda ell) 1mm\n\nquad sigma_MmathcalX (ell) = Msigma_mathcalX (M^mathrmT ell) 1mm\n\nquad sigma_mathcalX  mathcalY (ell) = sigma_mathcalX (ell)  sigma_mathcalY (ell) 1mm\n\nquad sigma_mathcalX  mathcalZ (ell_1 ell_2) = (sigma_mathcalX(ell_1) sigma_mathcalZ(ell_2)) 1mm\n\nquad sigma_mathrmCH(mathcalX  mathcalY) (ell) =\ntextargmax_x y (ell^mathrmT x ell^mathrmT y)\ntext where  x  sigma_mathcalX(ell) y  sigma_mathcalY(ell)\nendaligned","category":"page"},{"location":"man/polyhedral_approximations/#Polyhedral-approximation-of-a-convex-set","page":"Polyhedral Approximations","title":"Polyhedral approximation of a convex set","text":"","category":"section"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"The projection of a set into a low dimensional space (a special case of M mathcalX) can be conveniently evaluated using support functions, since sigma_MmathcalX(ell) = sigma_mathcalX(M^Tell). Moreover, for some classical convex sets such as unit balls in the infinity norm, in the 2-norm, or polyhedra in constraint representation, the support functions can be efficiently computed. For example, the support function of the unit ball mathcalB_p^n is rho_mathcalB_p^n(ell) = ell_fracpp-1","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"Given directions ell_1ell_m, a tight overapproximation of mathcalX is the outer polyhedron given by the constraints","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"beginaligned\nquad bigwedge_i ell_i^T x leq rho_mathcalX(ell_i)\nendaligned","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"For instance, a bounding box involves evaluating the support function in 2n directions. To quantify this, we use the following distance measure.","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"A set mathcalhatX is within Hausdorff distance ε of mathcalX if and only if","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"mathcalhatX subseteq mathcalX  εmathcalB_p^n text and  mathcalX subseteq mathcalhatX  εmathcalB_p^n","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"The infimum ε geq 0 that satisfies the above equation is called the Hausdorff distance between mathcalX and mathcalhatX with respect to the p-norm, and is denoted d_H^pbigl(mathcalXmathcalhatXbigr).","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"Another useful characterization of the Hausdorff distance is the following. Let mathcalX mathcalY subset ℝ^n be polytopes. Then","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"d^p_H(mathcalX mathcalY) = max_ell  mathcalB_p^n leftrho_mathcalY(ell) - rho_mathcalX(ell)right","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"In the special case mathcalX subseteq mathcalY, the absolute value can be removed.","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"By adding directions using Kamenev's algorithm (s. below), the outer polyhedron in (3) is within Hausdorff distance ε X_p for mathcalOleft(frac1ε^n-1right) directions, and this bound is optimal. It follows that accurate outer polyhedral approximations are possible only in low dimensions. For n=2, the bound can be lowered to mathcalOleft(frac1sqrtεright) directions, which is particularly efficient and the reason why we chose to decompose the system into subsystems of dimension 2.","category":"page"},{"location":"man/polyhedral_approximations/#Kamenev's-algorithm","page":"Polyhedral Approximations","title":"Kamenev's algorithm","text":"","category":"section"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"An overapproximation of the projections of a polyhedron given in constraint form can be obtained using Kamenev's algorithm; this is a particularly effective algorithm in two dimensions. Kamenev's algorithm proceeds as follows. Starting with at least n linearly independent template directions, compute an outer approximation. From the corresponding support vectors, compute an inner approximation, as the convex hull of the support vectors. Now compute the facet normals of the inner approximation, and the distance between the facets of the inner and the vertices of the outer approximation. Finally, pick the facet normal with the largest distance, and add it to the template directions. This procedure is repeated until the distance is smaller than the desired error.","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"For more details we refer to Kamenev [Kam96] and Lotov and Pospelov [LP08].","category":"page"},{"location":"man/reach_zonotopes/#A-Reachability-Algorithm-Using-Zonotopes","page":"A Reachability Algorithm","title":"A Reachability Algorithm Using Zonotopes","text":"","category":"section"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"Pages = [\"reach_zonotopes.md\"]\nDepth = 3","category":"page"},{"location":"man/reach_zonotopes/#Introduction","page":"A Reachability Algorithm","title":"Introduction","text":"","category":"section"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"In this section we present an algorithm implemented using LazySets that computes the reach sets of an affine ordinary differential equation (ODE). This algorithm is taken from Girard [Gir05]. We have chosen this algorithm for the purpose of illustration of a complete application of LazySets.","category":"page"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"Let us introduce some notation. Consider the continuous initial set-valued problem (IVP)","category":"page"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"    x(t) = A x(t) + u(t)","category":"page"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"in the time interval t  0 T, where:","category":"page"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"A is a real matrix of order n,\nu(t) is a non-deterministic input such that  u(t) _  μ for all t,\nx(0)  mathcalX_0, where mathcalX_0 is a convex set.","category":"page"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"Given a step size δ, Algorithm1 returns a sequence of sets that overapproximates the states reachable by any trajectory of this IVP.","category":"page"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"We present the algorithm parametric in the option to compute the sets in a lazy or in a concrete way. If the parameter lazy is true, the implementation constructs a LinearMap wrapper (represented as a multiplication * of a matrix and a set) and a MinkowskiSum wrapper (represented as a sum ⊕ of two sets). If the parameter lazy is false, the implementation calls the concrete counterparts linear_map and minkowski_sum.","category":"page"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"For further applications of LazySets in reachability analysis, we refer to the library JuliaReach/ReachabilityAnalysis.jl.","category":"page"},{"location":"man/reach_zonotopes/#Algorithm","page":"A Reachability Algorithm","title":"Algorithm","text":"","category":"section"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"using Plots, LazySets, LinearAlgebra, SparseArrays\n\nfunction Algorithm1(A, X0, δ, μ, T; lazy::Bool=false)\n    # bloating factors\n    Anorm = norm(A, Inf)\n    α = (exp(δ * Anorm) - 1 - δ * Anorm) / norm(X0, Inf)\n    β = (exp(δ * Anorm) - 1) * μ / Anorm\n\n    # discretized system\n    n = size(A, 1)\n    ϕ = exp(δ * A)\n    N = floor(Int, T / δ)\n\n    # preallocate arrays\n    Q = Vector{LazySet{Float64}}(undef, N)\n    R = Vector{LazySet{Float64}}(undef, N)\n\n    # initial reach set in the time interval [0, δ]\n    ϕp = (I+ϕ) / 2\n    ϕm = (I-ϕ) / 2\n    c = X0.center\n    Q1_generators = hcat(ϕp * X0.generators, ϕm * c, ϕm * X0.generators)\n    Q[1] = lazy ?\n        Zonotope(ϕp * c, Q1_generators) ⊕ BallInf(zeros(n), α + β) :\n        minkowski_sum(Zonotope(ϕp * c, Q1_generators), BallInf(zeros(n), α + β))\n    R[1] = Q[1]\n\n    # set recurrence for [δ, 2δ], ..., [(N-1)δ, Nδ]\n    ballβ = BallInf(zeros(n), β)\n    for i in 2:N\n        Q[i] = lazy ?\n            ϕ * Q[i-1] ⊕ ballβ :\n            minkowski_sum(linear_map(ϕ, Q[i-1]), ballβ)\n        R[i] = Q[i]\n    end\n    return R\nend\nnothing # hide","category":"page"},{"location":"man/reach_zonotopes/#Projection","page":"A Reachability Algorithm","title":"Projection","text":"","category":"section"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"function project(R, vars, n)\n    # projection matrix\n    M = sparse(1:2, vars, [1., 1.], 2, n)\n    return [M * Ri for Ri in R]\nend\nnothing # hide","category":"page"},{"location":"man/reach_zonotopes/#Example-1","page":"A Reachability Algorithm","title":"Example 1","text":"","category":"section"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"A = [-1 -4; 4 -1]\nX0 = Zonotope([1.0, 0.0], Matrix(0.1*I, 2, 2))\nμ = 0.05\nδ = 0.02\nT = 2.\n\nR = Algorithm1(A, X0, δ, μ, 2 * δ); # warm-up\n\nR = Algorithm1(A, X0, δ, μ, T)\n\nplot(R, 1e-2, 0; same_recipe=true, fillalpha=0.1)","category":"page"},{"location":"man/reach_zonotopes/#Example-2","page":"A Reachability Algorithm","title":"Example 2","text":"","category":"section"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"A = Matrix{Float64}([-1 -4 0 0 0;\n                      4 -1 0 0 0;\n                      0 0 -3 1 0;\n                      0 0 -1 -3 0;\n                      0 0 0 0 -2])\nX0 = Zonotope([1.0, 0.0, 0.0, 0.0, 0.0], Matrix(0.1*I, 5, 5))\nμ = 0.01\nδ = 0.005\nT = 1.\n\nR = Algorithm1(A, X0, δ, μ, 2 * δ); # warm-up\n\nR = Algorithm1(A, X0, δ, μ, T)\nRproj = project(R, [1, 3], 5)\n\nplot(Rproj, 1e-2, 0; same_recipe=true, fillalpha=0.1, xlabel=\"x1\", ylabel=\"x3\")","category":"page"},{"location":"lib/lazy_operations/ConvexHull/#Convex-hull","page":"ConvexHull","title":"Convex hull","text":"","category":"section"},{"location":"lib/lazy_operations/ConvexHull/#def_ConvexHull","page":"ConvexHull","title":"Binary convex hull (ConvexHull)","text":"","category":"section"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.ConvexHull","page":"ConvexHull","title":"LazySets.ConvexHull","text":"ConvexHull{N, S1<:LazySet{N}, S2<:LazySet{N}} <: ConvexSet{N}\n\nType that represents the convex hull of the union of two sets, i.e., the set\n\nZ = z  ℝ^n  z = λx + (1-λ)yqquad x  X y  Yλ  0 1 \n\nFields\n\nX – set\nY – set\n\nNotes\n\nThe EmptySet is the neutral element for ConvexHull.\n\nThis type is always convex.\n\nExamples\n\nThe convex hull of two 100-dimensional Euclidean balls:\n\njulia> b1, b2 = Ball2(zeros(100), 0.1), Ball2(4*ones(100), 0.2);\n\njulia> c = ConvexHull(b1, b2);\n\njulia> typeof(c)\nConvexHull{Float64, Ball2{Float64, Vector{Float64}}, Ball2{Float64, Vector{Float64}}}\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.CH","page":"ConvexHull","title":"LazySets.CH","text":"CH\n\nAlias for ConvexHull.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.swap-Tuple{ConvexHull}","page":"ConvexHull","title":"LazySets.swap","text":"swap(ch::ConvexHull)\n\nReturn a new ConvexHull object with the arguments swapped.\n\nInput\n\nch – convex hull of two sets\n\nOutput\n\nA new ConvexHull object with the arguments swapped.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.API.dim-Tuple{ConvexHull}","page":"ConvexHull","title":"LazySets.API.dim","text":"dim(ch::ConvexHull)\n\nReturn the dimension of a convex hull of two sets.\n\nInput\n\nch – convex hull of two sets\n\nOutput\n\nThe ambient dimension of the convex hull of two sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.API.ρ-Tuple{AbstractVector, ConvexHull}","page":"ConvexHull","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, ch::ConvexHull)\n\nEvaluate the support function of the convex hull of two sets in a given direction.\n\nInput\n\nd  – direction\nch – convex hull of two sets\n\nOutput\n\nThe evaluation of the support function of the convex hull in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.API.σ-Tuple{AbstractVector, ConvexHull}","page":"ConvexHull","title":"LazySets.API.σ","text":"σ(d::AbstractVector, ch::ConvexHull)\n\nReturn a support vector of the convex hull of two sets in a given direction.\n\nInput\n\nd  – direction\nch – convex hull of two sets\n\nOutput\n\nA support vector of the convex hull in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.API.isbounded-Tuple{ConvexHull}","page":"ConvexHull","title":"LazySets.API.isbounded","text":"isbounded(ch::ConvexHull)\n\nCheck whether the convex hull of two sets is bounded.\n\nInput\n\nch – convex hull of two sets\n\nOutput\n\ntrue iff both wrapped sets are bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#Base.isempty-Tuple{ConvexHull}","page":"ConvexHull","title":"Base.isempty","text":"isempty(ch::ConvexHull)\n\nCheck whether the convex hull of two sets is empty.\n\nInput\n\nch – convex hull\n\nOutput\n\ntrue iff both wrapped sets are empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.API.vertices_list-Tuple{ConvexHull}","page":"ConvexHull","title":"LazySets.API.vertices_list","text":"vertices_list(ch::ConvexHull; [apply_convex_hull]::Bool=true,\n              [backend]=nothing)\n\nReturn a list of vertices of the convex hull of two sets.\n\nInput\n\nch                – convex hull of two sets\napply_convex_hull – (optional, default: true) if true, post-process the                        vertices using a convex-hull algorithm\nbackend           – (optional, default: nothing) backend for computing                        the convex hull (see argument apply_convex_hull)\n\nOutput\n\nA list of vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/","page":"ConvexHull","title":"ConvexHull","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/ConvexHull/","page":"ConvexHull","title":"ConvexHull","text":"norm\nradius\ndiameter\n[an_element](@ref an_element(::LazySet)\nsingleton_list\nreflect","category":"page"},{"location":"lib/lazy_operations/ConvexHull/#def_ConvexHullArray","page":"ConvexHull","title":"n-ary convex hull (ConvexHullArray)","text":"","category":"section"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.ConvexHullArray","page":"ConvexHull","title":"LazySets.ConvexHullArray","text":"ConvexHullArray{N, S<:LazySet{N}} <: ConvexSet{N}\n\nType that represents the symbolic convex hull of a finite number of sets.\n\nFields\n\narray – array of sets\n\nNotes\n\nThe EmptySet is the neutral element for ConvexHullArray.\n\nA ConvexHullArray is always convex.\n\nExamples\n\nConvex hull of 100 two-dimensional balls whose centers follow a sinusoidal:\n\njulia> b = [Ball2([2*pi*i/100, sin(2*pi*i/100)], 0.05) for i in 1:100];\n\njulia> c = ConvexHullArray(b);\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.CHArray","page":"ConvexHull","title":"LazySets.CHArray","text":"CHArray\n\nAlias for ConvexHullArray.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.ConvexHull!","page":"ConvexHull","title":"LazySets.ConvexHull!","text":"ConvexHull!(X, Y)\n\nConvenience function to compute the lazy convex hull and modify ConvexHullArrays in-place.\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.API.dim-Tuple{ConvexHullArray}","page":"ConvexHull","title":"LazySets.API.dim","text":"dim(cha::ConvexHullArray)\n\nReturn the dimension of the convex hull of a finite number of sets.\n\nInput\n\ncha – convex hull of a finite number of sets\n\nOutput\n\nThe ambient dimension of the convex hull of a finite number of sets, or 0 if there is no set in the array.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.API.ρ-Tuple{AbstractVector, ConvexHullArray}","page":"ConvexHull","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, cha::ConvexHullArray)\n\nEvaluate the support function of a convex hull of a finite number of sets in a given direction.\n\nInput\n\nd   – direction\ncha – convex hull of a finite number of sets\n\nOutput\n\nThe evaluation of the support function of the convex hull of a finite number of sets in the given direction.\n\nAlgorithm\n\nThis algorithm calculates the maximum over all ρ(d X_i), where the X_1  X_k are the sets in the array of cha.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.API.σ-Tuple{AbstractVector, ConvexHullArray}","page":"ConvexHull","title":"LazySets.API.σ","text":"σ(d::AbstractVector, cha::ConvexHullArray)\n\nReturn a support vector of a convex hull of a finite number of sets in a given direction.\n\nInput\n\nd   – direction\ncha – convex hull of a finite number of sets\n\nOutput\n\nA support vector in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.API.isbounded-Tuple{ConvexHullArray}","page":"ConvexHull","title":"LazySets.API.isbounded","text":"isbounded(cha::ConvexHullArray)\n\nCheck whether a convex hull of a finite number of sets is bounded.\n\nInput\n\ncha – convex hull of a finite number of sets\n\nOutput\n\ntrue iff all wrapped sets are bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.array-Tuple{ConvexHullArray}","page":"ConvexHull","title":"LazySets.array","text":"array(cha::ConvexHullArray)\n\nReturn the array of a convex hull of a finite number of sets.\n\nInput\n\ncha – convex hull of a finite number of sets\n\nOutput\n\nThe array of a convex hull of a finite number of sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#Base.isempty-Tuple{ConvexHullArray}","page":"ConvexHull","title":"Base.isempty","text":"isempty(cha::ConvexHullArray)\n\nCheck whether a convex hull of a finite number of sets is empty.\n\nInput\n\ncha – convex hull of a finite number of sets\n\nOutput\n\ntrue iff all wrapped sets are empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.API.vertices_list-Tuple{ConvexHullArray}","page":"ConvexHull","title":"LazySets.API.vertices_list","text":"vertices_list(cha::ConvexHullArray; [apply_convex_hull]::Bool=true,\n              [backend]=nothing, [prune]::Bool=apply_convex_hull)\n\nReturn a list of vertices of the convex hull of a finite number of sets.\n\nInput\n\ncha               – convex hull of a finite number of sets\napply_convex_hull – (optional, default: true) if true, post-process the                        vertices using a convex-hull algorithm\nbackend           – (optional, default: nothing) backend for computing                        the convex hull (see argument apply_convex_hull)\nprune             – (optional, default: apply_convex_hull) alias for                        apply_convex_hull\n\nOutput\n\nA list of vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/","page":"ConvexHull","title":"ConvexHull","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/ConvexHull/","page":"ConvexHull","title":"ConvexHull","text":"norm\nradius\ndiameter\n[an_element](@ref an_element(::LazySet)\nsingleton_list\nreflect","category":"page"},{"location":"lib/sets/Polygon/#def_Polygon","page":"Polygon","title":"Non-convex polygon (Polygon)","text":"","category":"section"},{"location":"lib/sets/Polygon/#LazySets.PolygonModule.Polygon","page":"Polygon","title":"LazySets.PolygonModule.Polygon","text":"Polygon{N, VN<:AbstractVector{N}} <: LazySet{N}\n\nType that represents a non-convex polygon by its vertices.\n\nFields\n\nvertices – the list of vertices (in clockwise or counter-clockwise order)\n\nExamples\n\nA non-convex polygon in vertex representation can be constructed by passing the list of vertices. For example, we can build a tooth:\n\njulia> P = Polygon([[0.0, 0], [0, 2], [2, 2], [2, 0], [1, 1]]);\n\njulia> P.vertices\n5-element Vector{Vector{Float64}}:\n [0.0, 0.0]\n [0.0, 2.0]\n [2.0, 2.0]\n [2.0, 0.0]\n [1.0, 1.0]\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Polygon/","page":"Polygon","title":"Polygon","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/Polygon/","page":"Polygon","title":"Polygon","text":"convex_hull\ndim\nisbounded\nisboundedtype\nisconvextype\nisempty\nisoperationtype\nisuniversal\n∈\nρ\nσ","category":"page"},{"location":"lib/sets/Polygon/","page":"Polygon","title":"Polygon","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Polygon/","page":"Polygon","title":"Polygon","text":"an_element\narea\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nextrema\nextrema\nhigh\nhigh\nisoperation\nispolyhedral\nlow\nlow\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nlinear_map\nproject\nsample\nscale\nscale!\ntranslate\ntranslate!\ncartesian_product\nconvex_hull\nexact_sum\n≈\nisdisjoint\n==\nisequivalent\n⊂\n⊆\nlinear_combination\nminkowski_difference\nminkowski_sum","category":"page"},{"location":"lib/approximations/iterative_refinement/","page":"Iterative refinement","title":"Iterative refinement","text":"Pages = [\"iterative_refinement.md\"]\nDepth = 3","category":"page"},{"location":"lib/approximations/iterative_refinement/#Iterative-refinement","page":"Iterative refinement","title":"Iterative refinement","text":"","category":"section"},{"location":"lib/approximations/iterative_refinement/#LazySets.Approximations.overapproximate_hausdorff","page":"Iterative refinement","title":"LazySets.Approximations.overapproximate_hausdorff","text":"overapproximate_hausdorff(X::S, ε::Real) where {N<:AbstractFloat, S<:LazySet{N}}\n\nReturn an ε-close overapproximation of the given 2D convex set (in terms of the Hausdorff distance) in the form of a polygon in constraint representation.\n\nInput\n\nX – 2D convex set\nε – error bound\n\nOutput\n\nA polygon in constraint representation.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/iterative_refinement/#LazySets.Approximations.LocalApproximation","page":"Iterative refinement","title":"LazySets.Approximations.LocalApproximation","text":"LocalApproximation{N, VN<:AbstractVector{N}}\n\nType that represents a local approximation in 2D.\n\nFields\n\np1        – first inner point\nd1        – first direction\np2        – second inner point\nd2        – second direction\nq         – intersection of the lines l1 ⟂ d1 at p1 and l2 ⟂ d2 at p2\nrefinable – flag stating whether this approximation is refinable\nerr       – error upper bound\n\nNotes\n\nThe criteria for being refinable are determined in new_approx.\n\n\n\n\n\n","category":"type"},{"location":"lib/approximations/iterative_refinement/#LazySets.Approximations.PolygonalOverapproximation","page":"Iterative refinement","title":"LazySets.Approximations.PolygonalOverapproximation","text":"PolygonalOverapproximation{N, SN<:LazySet{N}, VN<:AbstractVector{N}}\n\nType that represents a polygonal overapproximation of a convex set.\n\nFields\n\nS            – convex set\napprox_stack – stack of local approximations that still need to be examined\nconstraints  – vector of half-spaces that are already finalized                   (i.e., they satisfy the given error bound)\n\n\n\n\n\n","category":"type"},{"location":"lib/approximations/iterative_refinement/#LazySets.Approximations.new_approx","page":"Iterative refinement","title":"LazySets.Approximations.new_approx","text":"new_approx(S::LazySet, p1::VN, d1::VN,\n           p2::VN, d2::VN) where {N<:AbstractFloat, VN<:AbstractVector{N}}\n\nCreate a LocalApproximation instance for the given excerpt of a polygonal overapproximation.\n\nInput\n\nS  – convex set\np1 – first inner point\nd1 – first direction\np2 – second inner point\nd2 – second direction\n\nOutput\n\nA local approximation of S in the given directions.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/iterative_refinement/#LazySets.Approximations.addapproximation!","page":"Iterative refinement","title":"LazySets.Approximations.addapproximation!","text":"addapproximation!(Ω::PolygonalOverapproximation, p1::VN, d1::VN,\n                  p2::VN, d2::VN) where {N, VN<:AbstractVector{N}}\n\nInput\n\nΩ  – polygonal overapproximation of a convex set\np1 – first inner point\nd1 – first direction\np2 – second inner point\nd2 – second direction\n\nOutput\n\nThe list of local approximations in Ω of the set Ω.S is updated in-place and the new approximation is returned by this function.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/iterative_refinement/#LazySets.Approximations.refine-Tuple{LazySets.Approximations.LocalApproximation, LazySet}","page":"Iterative refinement","title":"LazySets.Approximations.refine","text":"refine(approx::LocalApproximation, S::LazySet)\n\nRefine a given local approximation of the polygonal overapproximation of a convex set by splitting along the normal direction of the approximation.\n\nInput\n\napprox – local approximation to be refined\nS      – 2D convex set\n\nOutput\n\nThe tuple consisting of the refined right and left local approximations.\n\n\n\n\n\n","category":"method"},{"location":"lib/approximations/iterative_refinement/#LazySets.Approximations.tohrep-Tuple{LazySets.Approximations.PolygonalOverapproximation}","page":"Iterative refinement","title":"LazySets.Approximations.tohrep","text":"tohrep(Ω::PolygonalOverapproximation)\n\nConvert a polygonal overapproximation into a polygon in constraint representation.\n\nInput\n\nΩ – polygonal overapproximation of a convex set\n\nOutput\n\nA polygon in constraint representation.\n\nAlgorithm\n\nInternally, the constraints of Ω are already sorted.\n\n\n\n\n\n","category":"method"},{"location":"lib/approximations/iterative_refinement/#Base.convert-Tuple{Type{HalfSpace}, LazySets.Approximations.LocalApproximation}","page":"Iterative refinement","title":"Base.convert","text":"convert(::Type{HalfSpace}, approx::LocalApproximation)\n\nConvert a local approximation to a half-space.\n\nInput\n\napprox – local approximation\n\nOutput\n\nA half-space.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","text":"Pages = [\"AbstractSparsePolynomialZonotope.md\"]\nDepth = 3","category":"page"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/#def_AbstractSparsePolynomialZonotope","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","text":"","category":"section"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/#LazySets.AbstractSparsePolynomialZonotope","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"LazySets.AbstractSparsePolynomialZonotope","text":"AbstractSparsePolynomialZonotope{N} <: AbstractPolynomialZonotope{N}\n\nAbstract type for sparse polynomial zonotope sets.\n\nNotes\n\nSee SparsePolynomialZonotope for a standard implementation of this interface.\n\nEvery concrete AbstractSparsePolynomialZonotope must define the following functions:\n\nexpmat(::AbstractSparsePolynomialZonotope) – return the exponent matrix (sparse PZ only)\ngenmat_dep(::AbstractSparsePolynomialZonotope) – return the matrix of dependent generators\ngenmat_indep(::AbstractSparsePolynomialZonotope) – return the matrix of independent generators\n\nThe subtypes of AbstractSparsePolynomialZonotope (including abstract interfaces):\n\njulia> subtypes(AbstractSparsePolynomialZonotope)\n2-element Vector{Any}:\n SimpleSparsePolynomialZonotope\n SparsePolynomialZonotope\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","text":"This interface requires to implement the following functions:","category":"page"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/#LazySets.expmat-Tuple{AbstractSparsePolynomialZonotope}","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"LazySets.expmat","text":"expmat(P::AbstractSparsePolynomialZonotope)\n\nReturn the matrix of exponents of a sparse polynomial zonotope.\n\nInput\n\nP – sparse polynomial zonotope\n\nOutput\n\nThe matrix of exponents, where each column is a multidegree.\n\nNotes\n\nIn the exponent matrix, each row corresponds to a parameter (αₖ in the definition) and each column corresponds to a monomial.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/#LazySets.genmat_dep-Tuple{AbstractSparsePolynomialZonotope}","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"LazySets.genmat_dep","text":"genmat_dep(P::AbstractSparsePolynomialZonotope)\n\nReturn the matrix of dependent generators of a sparse polynomial zonotope.\n\nInput\n\nP – sparse polynomial zonotope\n\nOutput\n\nThe matrix of dependent generators.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/#LazySets.genmat_indep-Tuple{AbstractSparsePolynomialZonotope}","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"LazySets.genmat_indep","text":"genmat_indep(P::AbstractSparsePolynomialZonotope)\n\nReturn the matrix of independent generators of a sparse polynomial zonotope.\n\nInput\n\nP – sparse polynomial zonotope\n\nOutput\n\nThe matrix of independent generators.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/#LazySets.nparams-Tuple{AbstractSparsePolynomialZonotope}","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"LazySets.nparams","text":"nparams(P::AbstractSparsePolynomialZonotope)\n\nReturn the number of dependent parameters in the polynomial representation of a sparse polynomial zonotope.\n\nInput\n\nP – sparse polynomial zonotope\n\nOutput\n\nThe number of dependent parameters in the polynomial representation.\n\nNotes\n\nThis number corresponds to the number of rows in the exponent matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/#LazySets.API.ρ-Tuple{AbstractVector, SparsePolynomialZonotope}","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"LazySets.API.ρ","text":"Extended help\n\nρ(d::AbstractVector, X::LazySet)\n\nAlgorithm\n\nThe default implementation computes a support vector via σ.\n\n\n\n\n\nρ(d::AbstractVector, P::AbstractSparsePolynomialZonotope; [enclosure_method]=nothing)\n\nBound the support function of P in the direction d.\n\nInput\n\nd                – direction\nP                – sparse polynomial zonotope\nenclosure_method – (optional; default: nothing) method to use for                       enclosure; an AbstractEnclosureAlgorithm from the                       Rangeenclosures.jl                       package\n\nOutput\n\nAn overapproximation of the support function in the given direction.\n\nAlgorithm\n\nThis method implements Kochdumper [Koc22], Proposition 3.1.16.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","text":"Undocumented implementations:","category":"page"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","text":"extrema","category":"page"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","text":"ngens_dep\nngens_indep","category":"page"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","text":"linear_map\ntranslate","category":"page"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","text":"Inherited from LazySet:","category":"page"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","text":"an_element\narea\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nextrema\nextrema\nhigh\nhigh\nisbounded\nisoperation\nispolyhedral\nlow\nlow\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nproject\nsample\nscale\ncartesian_product\nconvex_hull\nexact_sum\n≈\nisdisjoint\n==\nisequivalent\n⊂\n⊆\nminkowski_difference\nminkowski_sum","category":"page"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","text":"Inherited from AbstractPolynomialZonotope:","category":"page"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","text":"center\ndim\nisboundedtype\nisempty\nisuniversal\nngens\norder","category":"page"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/#Implementations","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/AbstractSparsePolynomialZonotope/","page":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","title":"Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)","text":"Sparse polynomial zonotope (SparsePolynomialZonotope)\nSimplified sparse polynomial zonotope (SimpleSparsePolynomialZonotope)","category":"page"},{"location":"lib/approximations/hausdorff_distance/","page":"Hausdorff Distance","title":"Hausdorff Distance","text":"Pages = [\"hausdorff_distance.md\"]\nDepth = 3","category":"page"},{"location":"lib/approximations/hausdorff_distance/#Hausdorff-Distance","page":"Hausdorff Distance","title":"Hausdorff Distance","text":"","category":"section"},{"location":"lib/approximations/hausdorff_distance/#LazySets.Approximations.hausdorff_distance","page":"Hausdorff Distance","title":"LazySets.Approximations.hausdorff_distance","text":"hausdorff_distance(X::LazySet{N}, Y::LazySet{N}; [p]::N=N(Inf),\n                   [ε]=N(1e-3)) where {N}\n\nCompute the Hausdorff distance between two convex sets up to a given threshold.\n\nInput\n\nX – convex set\nY – convex set\np – (optional, default: Inf) norm parameter of the Hausdorff distance\nε – (optional, default: 1e-3) precision threshold; the true Hausdorff        distance is allowed to diverge from the result by at most this value\n\nOutput\n\nA value from the ε-neighborhood of the Hausdorff distance between X and Y.\n\nNotes\n\nGiven a p-norm, the Hausdorff distance d_H^p(X Y) between sets X and Y is defined as follows:\n\n    d_H^p(X Y) = infδ  0 mid Y  X  δ 𝐵_p^n text and  X  Y  δ 𝐵_p^n\n\nHere 𝐵_p^n is the n-dimensional unit ball in the p-norm.\n\nThe implementation may internally rely on the support function of X and Y; hence any imprecision in the implementation of the support function may affect the result. At the time of writing, the only convex set type with imprecise support function is the lazy Intersection.\n\nAlgorithm\n\nWe perform binary search for bounding the Hausdorff distance in an interval l u, where initially l is 0 and u is described below. The binary search terminates when u - l  ε, i.e., the interval becomes sufficiently small.\n\nTo find an upper bound u, we start with the heuristics of taking the biggest distance in the axis-parallel directions. As long as this bound does not work, we increase the bound by 2.\n\nGiven a value δ, to check whether the sets are within Hausdorff distance δ, we simply check the inclusions given above, where on the right-hand side we use a lazy Bloating.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/Ball2/#def_Ball2","page":"Ball2","title":"Euclidean-norm ball (Ball2)","text":"","category":"section"},{"location":"lib/sets/Ball2/#LazySets.Ball2Module.Ball2","page":"Ball2","title":"LazySets.Ball2Module.Ball2","text":"Ball2{N<:AbstractFloat, VN<:AbstractVector{N}} <: AbstractBallp{N}\n\nType that represents a ball in the 2-norm.\n\nFields\n\ncenter – center of the ball as a real vector\nradius – radius of the ball as a real scalar ( 0)\n\nNotes\n\nMathematically, a ball in the 2-norm is defined as the set\n\nmathcalB_2^n(c r) =  x  ℝ^n   x - c _2  r \n\nwhere c  ℝ^n is its center and r  ℝ_+ its radius. Here   _2 denotes the Euclidean norm (also known as 2-norm), defined as  x _2 = left( limits_i=1^n x_i^2 right)^12 for any x  ℝ^n.\n\nExamples\n\nCreate a five-dimensional ball B in the 2-norm centered at the origin with radius 0.5:\n\njulia> B = Ball2(zeros(5), 0.5)\nBall2{Float64, Vector{Float64}}([0.0, 0.0, 0.0, 0.0, 0.0], 0.5)\n\njulia> dim(B)\n5\n\nEvaluate B's support vector in the direction 12345:\n\njulia> σ([1.0, 2, 3, 4, 5], B)\n5-element Vector{Float64}:\n 0.06741998624632421\n 0.13483997249264842\n 0.20225995873897262\n 0.26967994498529685\n 0.3370999312316211\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Ball2/#Operations","page":"Ball2","title":"Operations","text":"","category":"section"},{"location":"lib/sets/Ball2/#LazySets.chebyshev_center_radius-Tuple{Ball2}","page":"Ball2","title":"LazySets.chebyshev_center_radius","text":"chebyshev_center_radius(B::Ball2; [kwargs]...)\n\nCompute a Chebyshev center and the corresponding radius of a ball in the 2-norm.\n\nInput\n\nB      – ball in the 2-norm\nkwargs – further keyword arguments (ignored)\n\nOutput\n\nThe pair (c, r) where c is the Chebyshev center of B and r is the radius of the largest Euclidean ball with center c enclosed by B.\n\nNotes\n\nThe Chebyshev center of a ball in the 2-norm is just the center of the ball.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-Ball2","page":"Ball2","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#Base.rand-Tuple{Type{Ball2}}","page":"Ball2","title":"Base.rand","text":"Extended help\n\nrand(::Type{Ball2}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the radius is nonnegative.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#LazySets.API.reflect-Tuple{LazySets.API.LazySet}-lib-sets-Ball2","page":"Ball2","title":"LazySets.API.reflect","text":"reflect(X::LazySet)\n\nCompute the reflection of a set in the origin.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the reflection -X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#LazySets.API.reflect-Tuple{Ball2}","page":"Ball2","title":"LazySets.API.reflect","text":"Extended help\n\nreflect(B::Ball2)\n\nAlgorithm\n\nIf B has center c and radius r, then -B has center -c and radius r.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#LazySets.API.volume-Tuple{LazySets.API.LazySet}-lib-sets-Ball2","page":"Ball2","title":"LazySets.API.volume","text":"volume(X::LazySet)\n\nCompute the volume, or Lebesgue measure, of a set.\n\nInput\n\nX – set\n\nOutput\n\nA real number representing the Lebesgue measure of X.\n\nNotes\n\nThe Lebesgue measure has the following common special cases:\n\nIn 1D, it coincides with the length.\nIn 2D, it coincides with the area (see also area).\nIn 3D, it coincides with the volume.\n\nIn higher dimensions, it is also known as the hypervolume or simply volume.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#LazySets.API.volume-Tuple{Ball2}","page":"Ball2","title":"LazySets.API.volume","text":"Extended help\n\nvolume(B::Ball2)\n\nAlgorithm\n\nThis method implements the well-known formula for the volume of an n-dimensional ball using factorials. For details, see the Wikipedia article Volume of an n-ball.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-Ball2","page":"Ball2","title":"Base.:∈","text":"∈(x::AbstractVector, X::LazySet)\n\nCheck whether a point lies in a set.\n\nInput\n\nx – point/vector\nX – set\n\nOutput\n\ntrue iff x  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#Base.:∈-Tuple{AbstractVector, Ball2}","page":"Ball2","title":"Base.:∈","text":"Extended help\n\n∈(x::AbstractVector, B::Ball2)\n\nNotes\n\nThis implementation is worst-case optimized, i.e., it is optimistic and first computes (see below) the whole sum before comparing to the radius. In applications where the point is typically far away from the ball, a fail-fast implementation with interleaved comparisons could be more efficient.\n\nAlgorithm\n\nLet B be an n-dimensional ball in the 2-norm with radius r and let c_i and x_i be the ball's center and the vector x in dimension i, respectively. Then x  B iff left( _i=1^n c_i - x_i^2 right)^12  r.\n\nExamples\n\njulia> B = Ball2([1., 1.], sqrt(0.5))\nBall2{Float64, Vector{Float64}}([1.0, 1.0], 0.7071067811865476)\n\njulia> [.5, 1.6] ∈ B\nfalse\n\njulia> [.5, 1.5] ∈ B\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#LazySets.API.sample-Tuple{LazySets.API.LazySet, Int64}-lib-sets-Ball2","page":"Ball2","title":"LazySets.API.sample","text":"sample(X::LazySet, [m]::Int=1;\n       [rng]::AbstractRNG=GLOBAL_RNG,\n       [seed]::Union{Int,Nothing}=nothing)\n\nCompute random samples from a set.\n\nInput\n\nX    – set\nm    – (optional; default: 1) number of random samples\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA vector of m elements in X if X is nonempty, and an error otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#LazySets.API.sample-Tuple{Ball2, Int64}","page":"Ball2","title":"LazySets.API.sample","text":"Extended help\n\nsample(B::Ball2, [nsamples]::Int;\n       [rng]::AbstractRNG=GLOBAL_RNG,\n       [seed]::Union{Int, Nothing}=nothing)\n\nAlgorithm\n\nRandom sampling with uniform distribution in B is computed using Muller's method of normalized Gaussians. This method requires the package Distributions. See _sample_unit_nball_muller! for implementation details.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-Ball2","page":"Ball2","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, X::LazySet)\n\nEvaluate the support function of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nThe evaluation of the support function of X in direction d.\n\nNotes\n\nA convenience alias support_function is also available.\n\nWe have the following identity based on the support vector σ:\n\n    ρ(d X) = d  σ(d X)\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#LazySets.API.ρ-Tuple{AbstractVector, Ball2}","page":"Ball2","title":"LazySets.API.ρ","text":"Extended help\n\nρ(d::AbstractVector, B::Ball2)\n\nAlgorithm\n\nLet c and r be the center and radius of the ball B in the 2-norm, respectively. Then:\n\nρ(d B) = d c + r d_2\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-Ball2","page":"Ball2","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#LazySets.API.σ-Tuple{AbstractVector, Ball2}","page":"Ball2","title":"LazySets.API.σ","text":"Extended help\n\nσ(d::AbstractVector, B::Ball2)\n\nNotes\n\nLet c and r be the center and radius of a ball B in the 2-norm, respectively. For nonzero direction d we have\n\nσ(d B) = c + r fracdd_2\n\nThis function requires computing the 2-norm of the input direction, which is performed in the given precision of the numeric datatype of both the direction and the set. Exact inputs are not supported.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#LazySets.API.translate!-Tuple{LazySets.API.LazySet, AbstractVector}-lib-sets-Ball2","page":"Ball2","title":"LazySets.API.translate!","text":"translate!(X::LazySet, v::AbstractVector)\n\nTranslate a set with a vector by modifying it.\n\nInput\n\nX – set\nv – vector\n\nOutput\n\nThe translated set representing X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#LazySets.API.translate!-Tuple{Ball2, AbstractVector}","page":"Ball2","title":"LazySets.API.translate!","text":"Extended help\n\ntranslate!(B::Ball2, v::AbstractVector)\n\nTranslate (i.e., shift) a ball in the 2-norm by the given vector, in-place.\n\nAlgorithm\n\nWe add the vector to the center of the ball.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#Base.isdisjoint-lib-sets-Ball2","page":"Ball2","title":"Base.isdisjoint","text":"isdisjoint(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nCheck whether two sets are disjoint (i.e., do not intersect), and optionally compute a witness.\n\nInput\n\nX       – set\nY       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X  Y = \nIf the witness option is activated:\n(true, []) iff X  Y = \n(false, v) iff X  Y   for some v  X  Y\n\nNotes\n\nThe convenience alias is_intersection_empty is also available.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/Ball2/#Base.isdisjoint","page":"Ball2","title":"Base.isdisjoint","text":"Extended help\n\nisdisjoint(B1::Ball2, B2::Ball2, [witness]::Bool=false)\n\nAlgorithm\n\nB1  B2 =  iff  c_2 - c_1 _2  r_1 + r_2.\n\nA witness is computed depending on the smaller/bigger ball (to break ties, choose B1 for the smaller ball) as follows.\n\nIf the smaller ball's center is contained in the bigger ball, we return it.\nOtherwise start in the smaller ball's center and move toward the other center until hitting the smaller ball's border. In other words, the witness is the point in the smaller ball that is closest to the center of the bigger ball.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/Ball2/#Base.:⊆-lib-sets-Ball2","page":"Ball2","title":"Base.:⊆","text":"⊆(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nCheck whether a set is a subset of another set, and optionally compute a witness.\n\nInput\n\nX       – set\nY       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X  Y\nIf the witness option is activated:\n(true, []) iff X  Y\n(false, v) iff X  Y for some v  X  Y\n\nNotes\n\nThe convenience alias issubset is also available.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/Ball2/#Base.:⊆","page":"Ball2","title":"Base.:⊆","text":"Extended help\n\n⊆(B1::Ball2, B2::Ball2, [witness]::Bool=false)\n\nAlgorithm\n\nB1  B2 iff  c_1 - c_2 _2 + r_1  r_2\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/Ball2/","page":"Ball2","title":"Ball2","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/Ball2/","page":"Ball2","title":"Ball2","text":"area\ncenter\nisoperationtype\nproject\nscale","category":"page"},{"location":"lib/sets/Ball2/","page":"Ball2","title":"Ball2","text":"ball_norm\nradius_ball","category":"page"},{"location":"lib/sets/Ball2/","page":"Ball2","title":"Ball2","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Ball2/","page":"Ball2","title":"Ball2","text":"concretize\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nhigh\nispolyhedral\nlow\nnorm\npolyhedron\nradius\nrationalize\nrectify\ntosimplehrep\ntranslate\ntriangulate\ntriangulate_faces\nis_interior_point\ncartesian_product\nconvex_hull\n≈\n==\nisequivalent\n⊂","category":"page"},{"location":"lib/sets/Ball2/","page":"Ball2","title":"Ball2","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/Ball2/","page":"Ball2","title":"Ball2","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/Ball2/","page":"Ball2","title":"Ball2","text":"Inherited from AbstractCentrallySymmetric:","category":"page"},{"location":"lib/sets/Ball2/","page":"Ball2","title":"Ball2","text":"an_element\ncenter\ndim\nextrema\nextrema\nisbounded\nisboundedtype\nisempty\nisuniversal","category":"page"},{"location":"lib/sets/Ball2/","page":"Ball2","title":"Ball2","text":"Inherited from AbstractBallp:","category":"page"},{"location":"lib/sets/Ball2/","page":"Ball2","title":"Ball2","text":"high\nlow\nminkowski_sum","category":"page"},{"location":"lib/sets/Ball2/#LazySets.Ball2Module._sample_unit_nball_muller!","page":"Ball2","title":"LazySets.Ball2Module._sample_unit_nball_muller!","text":"_sample_unit_nball_muller!(D::Vector{<:Vector}, n::Int, p::Int;\n                           [rng]::AbstractRNG=GLOBAL_RNG,\n                           [seed]::Union{Int, Nothing}=nothing)\n\nDraw samples from a uniform distribution on an n-dimensional unit ball using Muller's method.\n\nInput\n\nD    – output, vector of points\nn    – dimension of the ball\np    – number of random samples\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nThe modified vector D.\n\nAlgorithm\n\nThis function implements Muller's method of normalized Gaussians Muller [Mul59] to uniformly sample from the interior of the unit ball.\n\nGiven n Gaussian random variables Z₁ Z₂  Z_n and a uniformly distributed random variable r with support in 0 1, the distribution of the vectors\n\ndfracr^1nα left(z₁ z₂  z_nright)^T\n\nwhere α = sqrtz₁² + z₂² +  + z_n², is uniform over the n-dimensional unit ball.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"Pages = [\"AbstractSingleton.md\"]\nDepth = 3","category":"page"},{"location":"lib/interfaces/AbstractSingleton/#def_AbstractSingleton","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"","category":"section"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"A singleton is a special hyperrectangle consisting of only one point.","category":"page"},{"location":"lib/interfaces/AbstractSingleton/#LazySets.AbstractSingleton","page":"Singletons (AbstractSingleton)","title":"LazySets.AbstractSingleton","text":"AbstractSingleton{N} <: AbstractHyperrectangle{N}\n\nAbstract type for sets with a single value.\n\nNotes\n\nSee Singleton for a standard implementation of this interface.\n\nEvery concrete AbstractSingleton must define the following function:\n\nelement(::AbstractSingleton) – return the single element\n\nAmong other functions, the following function is then automatically defined:\n\nelement(::AbstractSingleton, i::Int) – return the single element at index                                           i\n\njulia> subtypes(AbstractSingleton)\n2-element Vector{Any}:\n Singleton\n ZeroSet\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"This interface requires to implement the following function:","category":"page"},{"location":"lib/interfaces/AbstractSingleton/#LazySets.element-Tuple{AbstractSingleton}","page":"Singletons (AbstractSingleton)","title":"LazySets.element","text":"element(S::AbstractSingleton)\n\nReturn the element of a set with a single value.\n\nInput\n\nS – set with a single value\n\nOutput\n\nThe unique element of S.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/AbstractSingleton/#LazySets.element-Tuple{AbstractSingleton, Int64}","page":"Singletons (AbstractSingleton)","title":"LazySets.element","text":"element(S::AbstractSingleton, i::Int)\n\nReturn the i-th entry of the element of a set with a single value.\n\nInput\n\nS – set with a single value\ni – dimension of interest\n\nOutput\n\nThe i-th entry of the element.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractSingleton/#LazySets.API.reflect-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractSingleton","page":"Singletons (AbstractSingleton)","title":"LazySets.API.reflect","text":"reflect(X::LazySet)\n\nCompute the reflection of a set in the origin.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the reflection -X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractSingleton/#LazySets.API.reflect-Tuple{AbstractSingleton}","page":"Singletons (AbstractSingleton)","title":"LazySets.API.reflect","text":"Extended help\n\nreflect(S::AbstractSingleton)\n\nOutput\n\nA Singleton.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractSingleton/#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractSingleton","page":"Singletons (AbstractSingleton)","title":"Base.:∈","text":"∈(x::AbstractVector, X::LazySet)\n\nCheck whether a point lies in a set.\n\nInput\n\nx – point/vector\nX – set\n\nOutput\n\ntrue iff x  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractSingleton/#Base.:∈-Tuple{AbstractVector, AbstractSingleton}","page":"Singletons (AbstractSingleton)","title":"Base.:∈","text":"Extended help\n\n∈(x::AbstractVector, S::AbstractSingleton)\n\nNotes\n\nThis implementation performs an approximate comparison to account for imprecision in floating-point computations.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractSingleton/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractSingleton","page":"Singletons (AbstractSingleton)","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractSingleton/#LazySets.API.σ-Tuple{AbstractVector, AbstractSingleton}","page":"Singletons (AbstractSingleton)","title":"LazySets.API.σ","text":"Extended help\n\nσ(d::AbstractVector, S::AbstractSingleton)\n\nAlgorithm\n\nThe support vector is the set's vector itself, irrespective of the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"Undocumented implementations:","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"center\ncenter","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"chebyshev_center_radius","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"constraints_list","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"generators\ngenmat","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"high\nhigh\nlow\nlow","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"ngens\nradius_hyperrectangle\nradius_hyperrectangle","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"vertices\nvertices_list\nρ\ncartesian_product\ndistance\nintersection\nisdisjoint\nisequivalent\n⊆\nminkowski_sum","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"Inherited from LazySet:","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"complement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisoperation\npolyhedron\nrationalize\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\naffine_map\nexponential_map\nis_interior_point\nsample\nscale\ntranslate\nconvex_hull\nexact_sum\n≈\n==\n⊂","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"ispolyhedral","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"isbounded\nisboundedtype","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"an_element\ndim\nisempty\nisuniversal","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"order\nremove_redundant_generators\ntogrep\nlinear_map\nreduce_order\nsplit\nsplit","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"Inherited from AbstractHyperrectangle:","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"area\nextrema\nextrema\nisflat\nnorm\nradius\nrectify\nvolume\ndistance\ndifference\nminkowski_difference","category":"page"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"Plotting singletons is available too:","category":"page"},{"location":"lib/interfaces/AbstractSingleton/#LazySets.plot_recipe-Union{Tuple{AbstractSingleton{N}}, Tuple{N}, Tuple{AbstractSingleton{N}, Any}} where N","page":"Singletons (AbstractSingleton)","title":"LazySets.plot_recipe","text":"plot_recipe(S::AbstractSingleton{N}, [ε]=zero(N)) where {N}\n\nConvert a singleton to a pair (x, y) of points for plotting.\n\nInput\n\nS – singleton\nε – (optional, default: 0) ignored, used for dispatch\n\nOutput\n\nA pair (x, y) of one point that can be plotted.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractSingleton/#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol, Any}, AbstractSingleton{N}}, Tuple{AbstractDict{Symbol, Any}, AbstractSingleton{N}, Real}} where N","page":"Singletons (AbstractSingleton)","title":"RecipesBase.apply_recipe","text":"plot_singleton(S::AbstractSingleton{N}, [ε]::Real=zero(N); ...) where {N}\n\nPlot a singleton.\n\nInput\n\nS – singleton\nε – (optional, default: 0) ignored, used for dispatch\n\nExamples\n\njulia> plot(Singleton([0.5, 1.0]))\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractSingleton/#Implementations","page":"Singletons (AbstractSingleton)","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/AbstractSingleton/","page":"Singletons (AbstractSingleton)","title":"Singletons (AbstractSingleton)","text":"Singleton\nOrigin (ZeroSet)","category":"page"},{"location":"lib/interfaces/ConvexSet/","page":"Convex sets (ConvexSet)","title":"Convex sets (ConvexSet)","text":"Pages = [\"ConvexSet.md\"]\nDepth = 3","category":"page"},{"location":"lib/interfaces/ConvexSet/#def_ConvexSet","page":"Convex sets (ConvexSet)","title":"Convex sets (ConvexSet)","text":"","category":"section"},{"location":"lib/interfaces/ConvexSet/","page":"Convex sets (ConvexSet)","title":"Convex sets (ConvexSet)","text":"Every convex set in this library implements this interface.","category":"page"},{"location":"lib/interfaces/ConvexSet/#LazySets.ConvexSet","page":"Convex sets (ConvexSet)","title":"LazySets.ConvexSet","text":"ConvexSet{N} <: LazySet{N}\n\nAbstract type for convex sets, i.e., sets characterized by a (possibly infinite) intersection of halfspaces, or equivalently, sets S such that for any two elements x y  S and 0  λ  1 it holds that λx + (1-λ)y  S.\n\nNotes\n\nEvery concrete ConvexSet must define the following function:\n\nσ(::AbstractVector, ::LazySet) – return a support vector in the given direction\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/ConvexSet/","page":"Convex sets (ConvexSet)","title":"Convex sets (ConvexSet)","text":"This interface requires to implement the following function:","category":"page"},{"location":"lib/interfaces/ConvexSet/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-ConvexSet","page":"Convex sets (ConvexSet)","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/ConvexSet/","page":"Convex sets (ConvexSet)","title":"Convex sets (ConvexSet)","text":"This interface defines the following functions (undocumented):","category":"page"},{"location":"lib/interfaces/ConvexSet/","page":"Convex sets (ConvexSet)","title":"Convex sets (ConvexSet)","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/interfaces/ConvexSet/","page":"Convex sets (ConvexSet)","title":"Convex sets (ConvexSet)","text":"Inherited from LazySet:","category":"page"},{"location":"lib/interfaces/ConvexSet/","page":"Convex sets (ConvexSet)","title":"Convex sets (ConvexSet)","text":"an_element\narea\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nextrema\nextrema\nhigh\nhigh\nisbounded\nisboundedtype\nisempty\nisoperation\nispolyhedral\nlow\nlow\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nlinear_map\nproject\nsample\nscale\nρ\ntranslate\ncartesian_product\nconvex_hull\nexact_sum\n≈\nisdisjoint\n==\nisequivalent\n⊂\n⊆\nminkowski_difference\nminkowski_sum","category":"page"},{"location":"lib/approximations/overapproximate/","page":"Overapproximation","title":"Overapproximation","text":"Pages = [\"overapproximate.md\"]\nDepth = 3","category":"page"},{"location":"lib/approximations/overapproximate/#Overapproximation","page":"Overapproximation","title":"Overapproximation","text":"","category":"section"},{"location":"lib/approximations/overapproximate/#LazySets.Approximations.overapproximate","page":"Overapproximation","title":"LazySets.Approximations.overapproximate","text":"overapproximate(X::S, ::Type{S}, args...) where {S<:LazySet}\n\nOverapproximating a set of type S with type S is a no-op.\n\nInput\n\nX       – set\nType{S} – target set type\nargs    – further arguments (ignored)\nkwargs  – further keyword arguments (ignored)\n\nOutput\n\nThe input set.\n\n\n\n\n\noverapproximate(S::LazySet, T::Type{<:LazySet}, [args]...; [kwargs]...)\n\nDefault overapproximation method that falls back to convert.\n\nInput\n\nX       – set\nType{S} – target set type\nargs    – further arguments\nkwargs  – further keyword arguments\n\nOutput\n\nThe result of convert, or a MethodError if no such method exists.\n\n\n\n\n\noverapproximate(S::LazySet)\n\nAlias for overapproximate(S, Hyperrectangle) resp. box_approximation(S).\n\n\n\n\n\noverapproximate(S::LazySet, ::Type{<:Hyperrectangle})\n\nAlias for box_approximation(S).\n\n\n\n\n\noverapproximate(S::LazySet, ::Type{<:BallInf})\n\nAlias for ballinf_approximation(S).\n\n\n\n\n\noverapproximate(S::LazySet{N},\n                ::Type{<:HPolygon},\n                [ε]::Real=Inf) where {N}\n\nOverapproximate a given 2D set using iterative refinement.\n\nInput\n\nS        – two-dimensional bounded set\nHPolygon – target set type\nε        – (optional, default: Inf) error tolerance\nprune    – (optional, default: true) flag for removing redundant               constraints in the end\n\nOutput\n\nA polygon in constraint representation.\n\nNotes\n\nThe result is always a convex overapproximation of the input set.\n\nIf no error tolerance ε is given, or is Inf, the result is a box-shaped polygon. For convex input sets, the result is an ε-close polygonal overapproximation with respect to the Hausdorff distance.\n\n\n\n\n\noverapproximate(S::LazySet, ε::Real)\n\nAlias for overapproximate(S, HPolygon, ε).\n\n\n\n\n\noverapproximate(X::LazySet{N}, dirs::AbstractDirections;\n                [prune]::Bool=true) where {N}\n\nOverapproximate a (possibly unbounded) set with template directions.\n\nInput\n\nX     – set\ndirs  – directions\nprune – (optional, default: true) flag for removing redundant constraints\n\nOutput\n\nA polyhedron overapproximating the set X with the directions from dirs. The overapproximation is computed using the support function. The result is an HPolytope if it is bounded and otherwise an HPolyhedron.\n\n\n\n\n\noverapproximate(X::LazySet{N}, dirs::Type{<:AbstractDirections}) where {N}\n\nOverapproximate a set with template directions.\n\nInput\n\nX    – set\ndirs – type of direction representation\n\nOutput\n\nA polyhedron overapproximating the set X with the directions from dirs. The result is an HPolytope if it is bounded and otherwise an HPolyhedron.\n\n\n\n\n\noverapproximate(cap::Intersection{N, <:LazySet, <:AbstractPolyhedron},\n                dirs::AbstractDirections;\n                kwargs...\n               ) where {N}\n\nOverapproximate the intersection between a set and a polyhedron given a set of template directions.\n\nInput\n\ncap    – intersection of a set and a polyhedron\ndirs   – template directions\nkwargs – additional arguments that are passed to the support function             algorithm\n\nOutput\n\nA polytope or polyhedron in H-representation such that the normal direction of each half-space is given by an element of dirs.\n\nAlgorithm\n\nLet di be a direction drawn from the set of template directions dirs. Let X be the set and let P be the polyhedron. We overapproximate the set X ∩ H with a polytope or polyhedron in constraint representation using a given set of template directions dirs.\n\nThe idea is to solve the univariate optimization problem ρ(di, X ∩ Hi) for each half-space of the set P and then take the minimum. This gives an overapproximation of the exact support function.\n\nThis algorithm is inspired from Frehse and Ray [FR12].\n\nNotes\n\nThis method relies on having available the constraints_list of the polyhedron P.\n\nThis method may return a non-empty set even if the original set is empty.\n\n\n\n\n\noverapproximate(cap::Intersection{N, <:HalfSpace, <:AbstractPolytope},\n                dirs::AbstractDirections;\n                [kwargs]...\n               ) where {N}\n\nOverapproximate the intersection between a half-space and a polytope given a set of template directions.\n\nInput\n\ncap    – intersection of a half-space and a polytope\ndirs   – template directions\nkwargs – additional arguments that are passed to the support function             algorithm\n\nOutput\n\nA polytope in H-representation such that the normal direction of each half-space is given by an element of dirs.\n\n\n\n\n\noverapproximate(Z::AbstractZonotope, ::Type{<:HParallelotope},\n                [indices]=1:dim(Z))\n\nOverapproximate a zonotopic set with a parallelotope in constraint representation.\n\nInput\n\nZ              – zonotopic set\nHParallelotope – target set type\nindices        – (optional; default: 1:dim(Z)) generator indices selected                      when constructing the parallelotope\n\nOutput\n\nAn overapproximation of the given zonotopic set using a parallelotope.\n\nAlgorithm\n\nThe algorithm is based on Proposition 8 discussed in Althoff et al. [ASB10], Section 5.\n\n\n\n\n\noverapproximate(X::Intersection{N, <:AbstractZonotope, <:Hyperplane},\n                dirs::AbstractDirections) where {N}\n\nOverapproximate the intersection between a zonotopic set and a hyperplane with a polyhedron or polytope using the given directions.\n\nInput\n\nX    – intersection between a zonotopic set and a hyperplane\ndirs – type of direction representation\n\nOutput\n\nAn overapproximation of the intersection between a zonotopic set and a hyperplane. If the directions are bounding, the result is an HPolytope, otherwise the result is an HPolyhedron.\n\nAlgorithm\n\nThis function implements Guernic [Gue09], Algorithm 8.1.\n\n\n\n\n\noverapproximate(QM::QuadraticMap{N, <:SparsePolynomialZonotope},\n                ::Type{<:SparsePolynomialZonotope}) where {N}\n\nOverapproximate a quadratic map of a sparse polynomial zonotope with a sparse polynomial zonotope.\n\nInput\n\nQM                       – quadratic map of a sparse polynomial zonotope\nSparsePolynomialZonotope – target type\n\nOutput\n\nA sparse polynomial zonotope overapproximating the quadratic map of a sparse polynomial zonotope.\n\nAlgorithm\n\nThis method implements Kochdumper and Althoff [KA21], Proposition 13.\n\n\n\n\n\noverapproximate(P::VPolygon, ::Type{<:LinearMap{N,<:Hyperrectangle}}) where {N}\n\nOverapproximate a convex polygon with a minimal-area rotated rectangle.\n\nInput\n\nP – convex polygon\nLinearMap{N,<:Hyperrectangle} – target type\n\nOutput\n\nA LinearMap of a Hyperrectangle.\n\nAlgorithm\n\nThis method follows an approach described in this post, which itself is based on this post.\n\nGenerally, the idea is that the rotated rectangle must share at least one edge with the polygon. Thus, it suffices to try out finitely many rectangles. Some tricks from linear algebra allow to construct the corresponding rotations and rectangles elegantly.\n\n\n\n\n\noverapproximate(P::AbstractSparsePolynomialZonotope{N}, ::Type{<:VPolytope}) where {N}\n\nOverapproximate a sparse polynomial zonotope with a polytope in vertex representation.\n\nInput\n\nP         – sparse polynomial zonotope\nVPolytope – target type\n\nOutput\n\nA VPolytope.\n\nAlgorithm\n\nThis method implements Kochdumper [Koc22], Proposition 3.1.15. The idea is to split P into a linear and nonlinear part (such that P = P₁ ⊕ P₂). The nonlinear part is enclosed by a zonotope. Then we combine the vertices of both sets and finally apply a convex-hull algorithm.\n\n\n\n\n\noverapproximate(S::LazySet, ::Type{<:Interval})\n\nReturn the overapproximation of a set with an interval.\n\nInput\n\nS        – one-dimensional set\nInterval – target type\n\nOutput\n\nAn interval.\n\nAlgorithm\n\nWe use the extrema function.\n\n\n\n\n\noverapproximate(cap::Intersection, ::Type{<:Interval})\n\nReturn the overapproximation of a lazy intersection with an interval.\n\nInput\n\ncap      – one-dimensional intersection\nInterval – target type\n\nOutput\n\nAn interval.\n\nAlgorithm\n\nThe algorithm recursively overapproximates the two intersected sets with intervals and then intersects these. (Note that this fails if the sets are unbounded.)\n\nFor convex sets this algorithm is precise.\n\n\n\n\n\noverapproximate(cap::IntersectionArray, ::Type{<:Interval})\n\nReturn the overapproximation of an intersection array with an interval.\n\nInput\n\ncap      – one-dimensional intersection array\nInterval – target type\n\nOutput\n\nAn interval.\n\nAlgorithm\n\nThe algorithm recursively overapproximates the intersected sets with intervals and then intersects these. (Note that this fails if the sets are unbounded.)\n\nFor convex sets this algorithm is precise.\n\n\n\n\n\noverapproximate(Z::AbstractZonotope, ::Type{<:Zonotope}, r::Real)\n\nReduce the order of a zonotopic set.\n\nInput\n\nZ        – zonotopic set\nZonotope – target set type\nr        – desired order\n\nOutput\n\nA new zonotope with r generators, if possible.\n\nAlgorithm\n\nThis method falls back to reduce_order with the default algorithm.\n\n\n\n\n\noverapproximate(X::ConvexHull{N, <:AbstractZonotope, <:AbstractZonotope},\n                ::Type{<:Zonotope}) where {N}\n\nOverapproximate the convex hull of two zonotopic sets.\n\nInput\n\nX         – convex hull of two zonotopic sets\nZonotope  – target set type\nalgorithm – (optional; default: \"mean\") choice of algorithm; possible                values are \"mean\" and \"join\"\n\nOutput\n\nA zonotope Z such that X  Z.\n\nAlgorithm\n\nThe algorithm can be controlled by the parameter algorithm. Note that the results of the two implemented algorithms are generally incomparable.\n\n'mean' method\n\nIf algorithm == \"mean\", we choose the method proposed in Girard [Gir05]. The convex hull of two zonotopic sets Z₁ and Z₂ of the same order, which we write\n\nZ_j = c^(j) g^(j)_1  g^(j)_p\n\nfor j = 1 2, can be overapproximated as follows:\n\nCH(Z_1 Z_2)  frac12c^(1)+c^(2) g^(1)_1+g^(2)_1 \ng^(1)_p+g^(2)_p c^(1)-c^(2) g^(1)_1-g^(2)_1  g^(1)_p-g^(2)_p\n\nIf the zonotope order is not the same, this algorithm calls reduce_order to reduce the order to the minimum of the arguments.\n\nIt should be noted that the output zonotope is not necessarily the minimal enclosing zonotope, which is in general expensive to obtain in high dimensions. This is further investigated in Guibas et al. [GNZ03].\n\n'join' method\n\nIf algorithm == \"join\", we choose the method proposed in Ghorbal et al. [GGP09], Definition 1. The convex hull X of two zonotopic sets Z₁ and Z₂ is overapproximated by a zonotope Z₃ such that the box approximation of X is identical with the box approximation of Z₃. Let (X) denote the box approximation of X. The center of Z₃ is the center of (X).\n\nThe generator construction consists of two phases. In the first phase, we construct generators g as a combination of one generator from Z₁, say, g₁, with another generator from Z₂, say, g₂. The entry of g in the i-th dimension is given as\n\n    gi = argmin_min(g₁i g₂i)  x  max(g₁i g₂i) x\n\nIf g is the zero vector, it can be omitted.\n\nIn the second phase, we construct another generator for each dimension. These generators are scaled unit vectors. The following formula defines the sum of all those generators.\n\n    sup((X)) - c - _g g\n\nwhere c is the center of the new zonotope and the gs are the generators constructed in the first phase.\n\n\n\n\n\noverapproximate(P::SimpleSparsePolynomialZonotope, ::Type{<:Zonotope})\n\nOverapproximate a simple sparse polynomial zonotope with a zonotope.\n\nInput\n\nP         – simple sparse polynomial zonotope\nZonotope  – target set type\n\nOutput\n\nA zonotope.\n\n\n\n\n\noverapproximate(P::SimpleSparsePolynomialZonotope, ::Type{<:Zonotope},\n                dom::IntervalBox)\n\nOverapproximate a simple sparse polynomial zonotope over the parameter domain dom with a zonotope.\n\nInput\n\nP         – simple sparse polynomial zonotope\nZonotope  – target set type\ndom       – parameter domain, which should be a subset of [-1, 1]^q,                where q = nparams(P)\n\nOutput\n\nA zonotope.\n\n\n\n\n\noverapproximate(P::SparsePolynomialZonotope, ::Type{<:Zonotope})\n\nOverapproximate a sparse polynomial zonotope with a zonotope.\n\nInput\n\nP        – sparse polynomial zonotope\nZonotope – target set type\n\nOutput\n\nA zonotope.\n\n\n\n\n\noverapproximate(P::DensePolynomialZonotope, ::Type{<:Zonotope})\n\nOverapproximate a polynomial zonotope with a zonotope.\n\nInput\n\nP        – polynomial zonotope\nZonotope – target set type\n\nOutput\n\nA zonotope.\n\nAlgorithm\n\nThis method implements Althoff [Alt13], Proposition 1.\n\n\n\n\n\noverapproximate(X::LazySet, ZT::Type{<:Zonotope},\n                dir::Union{AbstractDirections, Type{<:AbstractDirections}};\n                [algorithm]=\"vrep\", kwargs...)\n\nOverapproximate a set with a zonotope.\n\nInput\n\nX         – set\nZonotope  – target set type\ndir       – directions used for the generators\nalgorithm – (optional, default: \"vrep\") algorithm used to compute the                overapproximation\nkwargs    – further algorithm-specific options\n\nOutput\n\nA zonotope that overapproximates X and uses at most the generator directions provided in dir (redundant directions will be ignored).\n\nNotes\n\nTwo algorithms are available:\n\n\"vrep\" – Overapproximate a polytopic set with a zonotope of minimal total generator sum using only generators in the given directions. Under this constraint, the zonotope has the minimal sum of generator vectors. See the docstring of _overapproximate_zonotope_vrep for further details.\n\"cpa\" – Overapproximate a polytopic set with a zonotope using a Cartesian decomposition into two-dimensional blocks. See the docstring of _overapproximate_zonotope_cpa for further details.\n\n\n\n\n\noverapproximate(r::Rectification{N, <:AbstractZonotope},\n                ::Type{<:Zonotope}) where {N}\n\nOverapproximate the rectification of a zonotopic set with a zonotope.\n\nInput\n\nr        – lazy rectification of a zonotopic set\nZonotope – target set type\n\nOutput\n\nA zonotope overapproximation of the set obtained by rectifying Z.\n\nAlgorithm\n\nThis method implements Singh et al. [SGM+18], Theorem 3.1.\n\n\n\n\n\noverapproximate(CHA::ConvexHullArray{N, <:AbstractZonotope},\n                ::Type{<:Zonotope}) where {N}\n\nOverapproximate the convex hull of a list of zonotopic sets with a zonotope.\n\nInput\n\nCHA      – convex hull array of zonotopic sets\nZonotope – target set type\n\nOutput\n\nA zonotope overapproximation of the convex hull array of zonotopic sets.\n\nAlgorithm\n\nThis method iteratively applies the overapproximation algorithm to the convex hull of two zonotopic sets from the given array of zonotopic sets.\n\n\n\n\n\noverapproximate(QM::QuadraticMap{N, <:AbstractZonotope},\n                ::Type{<:Zonotope}) where {N}\n\nOverapproximate a quadratic map of a zonotopic set with a zonotope.\n\nInput\n\nQM       – quadratic map of a zonotopic set\nZonotope – target set type\n\nOutput\n\nA zonotope overapproximating the quadratic map of a zonotopic set.\n\nNotes\n\nMathematically, a quadratic map of a zonotope with matrices Q is defined as:\n\n    Z_Q = right λ mid λ_i = x^T Q^(i) xi = 1  nx  Z left\n\nAlgorithm\n\nThis method implements Althoff and Krogh [AK12], Lemma 1.\n\n\n\n\n\noverapproximate(X::Intersection{N, <:AbstractZonotope, <:Hyperplane},\n                ::Type{<:Zonotope})\n\nOverapproximate the intersection of a zonotopic set and a hyperplane with a zonotope.\n\nInput\n\nX        – intersection of a zonotopic set and a hyperplane\nZonotope – target set type\n\nOutput\n\nA zonotope overapproximating the intersection.\n\nAlgorithm\n\nThis method implements Maı̈ga et al. [MRTC14], Algorithm 3.\n\n\n\n\n\noverapproximate(lm::LinearMap{N, <:CartesianProductArray},\n                ::Type{<:CartesianProductArray{N, S}}\n               ) where {N, S<:LazySet}\n\nDecompose a lazy linear map of a Cartesian product array while keeping the original block structure.\n\nInput\n\nlm                    – lazy linear map of Cartesian product array\nCartesianProductArray – target set type\n\nOutput\n\nA CartesianProductArray representing the decomposed linear map.\n\n\n\n\n\noverapproximate(lm::LinearMap{N, <:CartesianProductArray},\n                ::Type{<:CartesianProductArray},\n                dir::Type{<:AbstractDirections}) where {N}\n\nDecompose a lazy linear map of a Cartesian product array with template directions while keeping the original block structure.\n\nInput\n\nlm                    – lazy linear map of a Cartesian product array\nCartesianProductArray – target set type\ndir                   – template directions for overapproximation\n\nOutput\n\nA CartesianProductArray representing the decomposed linear map.\n\n\n\n\n\noverapproximate(lm::LinearMap{N, <:CartesianProductArray},\n                ::Type{<:CartesianProductArray},\n                set_type::Type{<:LazySet}) where {N}\n\nDecompose a lazy linear map of a Cartesian product array with a given set type while keeping the original block structure.\n\nInput\n\nlm                    – lazy linear map of a Cartesian product array\nCartesianProductArray – target set type\nset_type              – set type for overapproximation\n\nOutput\n\nA CartesianProductArray representing the decomposed linear map.\n\n\n\n\n\noverapproximate(rm::ResetMap{N, <:CartesianProductArray},\n                ::Type{<:CartesianProductArray}, oa) where {N}\n\nOverapproximate a reset map (that only resets to zero) of a Cartesian product with a new Cartesian product.\n\nInput\n\nrm                    – reset map\nCartesianProductArray – target set type\noa                    – overapproximation option\n\nOutput\n\nA Cartesian product with the same block structure.\n\nNotes\n\nThis implementation currently only supports resets to zero.\n\nAlgorithm\n\nWe convert the ResetMap into a LinearMap and then call the corresponding overapproximate method.\n\n\n\n\n\noverapproximate(cap::Intersection{N,\n                                  <:CartesianProductArray,\n                                  <:AbstractPolyhedron},\n                ::Type{<:CartesianProductArray}, oa) where {N}\n\nOverapproximate the intersection of a Cartesian product of a finite number of sets and a polyhedron with a new Cartesian product.\n\nInput\n\ncap                   – lazy intersection of a Cartesian product array and                            a polyhedron\nCartesianProductArray – target set type\noa                    – overapproximation option\n\nOutput\n\nA CartesianProductArray that overapproximates the intersection of cpa and P.\n\nAlgorithm\n\nThe intersection only needs to be computed in the blocks of cpa that are constrained in P. Hence we first collect those constrained blocks in a lower-dimensional Cartesian product array and then convert to an HPolytope X. Then we take the intersection of X and the projection of Y onto the corresponding dimensions. (This projection is purely syntactic and exact.) Finally we decompose the result again and plug together the unaffected old blocks and the newly computed blocks. The result is a CartesianProductArray with the same block structure as in X.\n\n\n\n\n\noverapproximate(vTM::Vector{TaylorModel1{T, S}}, ::Type{<:Zonotope};\n                [remove_redundant_generators]::Bool=true\n                [normalize]::Bool=true) where {T, S}\n\nOverapproximate a Taylor model in one variable with a zonotope.\n\nInput\n\nvTM       – vector of TaylorModel1\nZonotope  –  target set type\nremove_redundant_generators – (optional; default: true) flag to remove                                  redundant generators of the resulting zonotope\nnormalize – (optional; default: true) flag to skip the normalization of                the Taylor models\n\nOutput\n\nA zonotope that overapproximates the range of the given Taylor model.\n\nExamples\n\nIf the polynomials are linear, this method exactly transforms to a zonotope. The nonlinear case necessarily introduces overapproximation error. Consider the linear case first:\n\njulia> using LazySets, TaylorModels\n\njulia> const IA = IntervalArithmetic;\n\njulia> I = IA.interval(-0.5, 0.5) # interval remainder\n[-0.5, 0.5]\n\njulia> x₀ = IA.interval(0.0) # expansion point\n[0, 0]\n\njulia> D = IA.interval(-3.0, 1.0)\n[-3, 1]\n\njulia> p1 = Taylor1([2.0, 1.0], 2) # define a linear polynomial\n 2.0 + 1.0 t + 𝒪(t³)\n\njulia> p2 = Taylor1([0.9, 3.0], 2) # define another linear polynomial\n 0.9 + 3.0 t + 𝒪(t³)\n\njulia> vTM = [TaylorModel1(pi, I, x₀, D) for pi in [p1, p2]]\n2-element Vector{TaylorModel1{Float64, Float64}}:\n  2.0 + 1.0 t + [-0.5, 0.5]\n  0.9 + 3.0 t + [-0.5, 0.5]\n\nHere, vTM is a Taylor model vector, since each component is a Taylor model in one variable (TaylorModel1). Using overapproximate(vTM, Zonotope) we can compute its associated zonotope in generator representation:\n\njulia> Z = overapproximate(vTM, Zonotope);\n\njulia> center(Z)\n2-element Vector{Float64}:\n  1.0\n -2.1\n\njulia> Matrix(genmat(Z))\n2×3 Matrix{Float64}:\n 2.0  0.5  0.0\n 6.0  0.0  0.5\n\nNote how the generators of this zonotope mainly consist of two pieces: one comes from the linear part of the polynomials, and another one corresponds to the interval remainder. This conversion gives the same upper and lower bounds as the range evaluation using interval arithmetic:\n\njulia> X = box_approximation(Z)\nHyperrectangle{Float64, Vector{Float64}, Vector{Float64}}([1.0, -2.1], [2.5, 6.5])\n\njulia> Y = evaluate(vTM[1], vTM[1].dom) × evaluate(vTM[2], vTM[2].dom)\n[-1.5, 3.5] × [-8.60001, 4.40001]\n\njulia> H = convert(Hyperrectangle, Y) # this IntervalBox is the same as X\nHyperrectangle{Float64, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}([1.0, -2.1000000000000005], [2.5, 6.500000000000001])\n\nHowever, the zonotope returns better results if we want to approximate the Taylor model because it is not axis-aligned:\n\njulia> d = [-0.35, 0.93];\n\njulia> ρ(d, Z) < ρ(d, X)\ntrue\n\nThis method also works if the polynomials are non-linear; for example suppose that we add a third polynomial with a quadratic term:\n\njulia> p3 = Taylor1([0.9, 3.0, 1.0], 3)\n 0.9 + 3.0 t + 1.0 t² + 𝒪(t⁴)\n\njulia> vTM = [TaylorModel1(pi, I, x₀, D) for pi in [p1, p2, p3]]\n3-element Vector{TaylorModel1{Float64, Float64}}:\n           2.0 + 1.0 t + [-0.5, 0.5]\n           0.9 + 3.0 t + [-0.5, 0.5]\n  0.9 + 3.0 t + 1.0 t² + [-0.5, 0.5]\n\njulia> Z = overapproximate(vTM, Zonotope);\n\njulia> center(Z)\n3-element Vector{Float64}:\n  1.0\n -2.1\n  2.4\n\njulia> Matrix(genmat(Z))\n3×4 Matrix{Float64}:\n 2.0  0.5  0.0  0.0\n 6.0  0.0  0.5  0.0\n 6.0  0.0  0.0  5.0\n\nThe last generator corresponds to the addition of the interval remainder and the box overapproximation of the nonlinear part of p3 over the domain.\n\nAlgorithm\n\nLet textvTM = (p I) be a vector of m Taylor models, where I is the interval remainder in ℝ^m. Let p_lin (resp. p_nonlin) correspond to the linear (resp. nonlinear) part of each scalar polynomial.\n\nThe range of textvTM can be enclosed by a zonotope with center c and matrix of generators G, Z = c G, by performing a conservative linearization of textvTM:\n\n    vTM = (p I) = (p_lin  p_nonlin  I + textInt(p_nonlin))\n\nThis algorithm proceeds in two steps:\n\n1- Conservatively linearize textvTM as above and compute a box    overapproximation of the nonlinear part. 2- Transform the linear Taylor model to a zonotope exactly through variable    normalization onto the symmetric intervals -1 1.\n\n\n\n\n\noverapproximate(vTM::Vector{TaylorModelN{N, T, S}}, ::Type{<:Zonotope};\n                [remove_redundant_generators]::Bool=true\n                [normalize]::Bool=true) where {N, T, S}\n\nOverapproximate a multivariate Taylor model with a zonotope.\n\nInput\n\nvTM       – vector of TaylorModelN\nZonotope  – target set type\nremove_redundant_generators – (optional; default: true) flag to remove                                  redundant generators of the resulting zonotope\nnormalize – (optional; default: true) flag to skip the normalization of                the Taylor models\n\nOutput\n\nA zonotope that overapproximates the range of the given Taylor model.\n\nExamples\n\nConsider a vector of two 2-dimensional Taylor models of order 2 and 4, respectively.\n\njulia> using LazySets, TaylorModels\n\njulia> const IA = IntervalArithmetic;\n\njulia> x₁, x₂ = set_variables(Float64, [\"x₁\", \"x₂\"], order=8)\n2-element Vector{TaylorN{Float64}}:\n  1.0 x₁ + 𝒪(‖x‖⁹)\n  1.0 x₂ + 𝒪(‖x‖⁹)\n\njulia> x₀ = IA.IntervalBox(0..0, 2) # expansion point\n[0, 0]²\n\njulia> Dx₁ = IA.interval(0.0, 3.0) # domain for x₁\n[0, 3]\n\njulia> Dx₂ = IA.interval(-1.0, 1.0) # domain for x₂\n[-1, 1]\n\njulia> D = Dx₁ × Dx₂ # take the Cartesian product of the domain on each variable\n[0, 3] × [-1, 1]\n\njulia> r = IA.interval(-0.5, 0.5) # interval remainder\n[-0.5, 0.5]\n\njulia> p1 = 1 + x₁^2 - x₂\n 1.0 - 1.0 x₂ + 1.0 x₁² + 𝒪(‖x‖⁹)\n\njulia> p2 = x₂^3 + 3x₁^4 + x₁ + 1\n 1.0 + 1.0 x₁ + 1.0 x₂³ + 3.0 x₁⁴ + 𝒪(‖x‖⁹)\n\njulia> vTM = [TaylorModelN(pi, r, x₀, D) for pi in [p1, p2]]\n2-element Vector{TaylorModelN{2, Float64, Float64}}:\n            1.0 - 1.0 x₂ + 1.0 x₁² + [-0.5, 0.5]\n  1.0 + 1.0 x₁ + 1.0 x₂³ + 3.0 x₁⁴ + [-0.5, 0.5]\n\njulia> Z = overapproximate(vTM, Zonotope);\n\njulia> center(Z)\n2-element Vector{Float64}:\n   5.5\n 124.0\n\njulia> Matrix(genmat(Z))\n2×2 Matrix{Float64}:\n   0.0  -6.0\n 124.5   0.0\n\nAlgorithm\n\nWe refer to the algorithm description for the univariate case.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/overapproximate/#LazySets.Approximations._overapproximate_zonotope_vrep","page":"Overapproximation","title":"LazySets.Approximations._overapproximate_zonotope_vrep","text":"_overapproximate_zonotope_vrep(X::LazySet{N},\n                               dir::AbstractDirections;\n                               solver=default_lp_solver(N)) where {N}\n\nOverapproximate a polytopic set with a zonotope of minimal total generator sum using only generators in the given directions.\n\nInput\n\nX      – polytopic set\ndir    – directions used for the generators\nsolver – (optional, default: default_lp_solver(N)) the backend used to             solve the linear program\n\nOutput\n\nA zonotope that overapproximates X and uses at most the directions provided in dir (redundant directions will be ignored). Under this constraint, the zonotope has the minimal sum of generator vectors.\n\nNotes\n\nThe algorithm only requires one representative of each generator direction and their additive inverse (e.g., only one of [1, 0] and [-1, 0]) and assumes that the directions are normalized. We preprocess the directions in that respect.\n\nAlgorithm\n\nWe solve a linear program parametric in the vertices v_j of X and the directions d_k in dir presented in Section 4.2 in Guibas et al. [GNZ03], adapting the notation to the one used in this library.\n\n    min _k=1^l α_k \n    st \n    c + _k=1^l b_kj * d_k = v_j quad  j \n    -α_k  b_kj  α_k quad  k j \n    α_k  0 quad  k\n\nThe resulting zonotope has center c and generators α_k · d_k.\n\nNote that the first type of side constraints is vector-based and that the nonnegativity constraints (last type) are not stated explicitly in [GNZ03].\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/overapproximate/#LazySets.Approximations._overapproximate_zonotope_cpa","page":"Overapproximation","title":"LazySets.Approximations._overapproximate_zonotope_cpa","text":"_overapproximate_zonotope_cpa(X::LazySet, dir::Type{<:AbstractDirections})\n\nOverapproximate a polytopic set with a zonotope using Cartesian decomposition.\n\nInput\n\nX   – polytopic set\ndir – directions used for the generators\n\nOutput\n\nA zonotope that overapproximates X.\n\nNotes\n\nThe algorithm decomposes X into 2D sets and overapproximates those sets with zonotopes, and finally converts the Cartesian product of the sets to a zonotope.\n\nAlgorithm\n\nThe implementation is based on Guernic [Gue09], Section 8.2.4.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractPolynomialZonotope/","page":"Polynomial zonotope sets (AbstractPolynomialZonotope)","title":"Polynomial zonotope sets (AbstractPolynomialZonotope)","text":"Pages = [\"AbstractPolynomialZonotope.md\"]\nDepth = 3","category":"page"},{"location":"lib/interfaces/AbstractPolynomialZonotope/#def_AbstractPolynomialZonotope","page":"Polynomial zonotope sets (AbstractPolynomialZonotope)","title":"Polynomial zonotope sets (AbstractPolynomialZonotope)","text":"","category":"section"},{"location":"lib/interfaces/AbstractPolynomialZonotope/#LazySets.AbstractPolynomialZonotope","page":"Polynomial zonotope sets (AbstractPolynomialZonotope)","title":"LazySets.AbstractPolynomialZonotope","text":"AbstractPolynomialZonotope{N} <: LazySet{N}\n\nAbstract type for polynomial zonotope sets.\n\nNotes\n\nSee DensePolynomialZonotope for a standard implementation of this interface.\n\nPolynomial zonotopes are in general non-convex. They are always bounded.\n\nEvery concrete AbstractPolynomialZonotope must define the following functions:\n\ncenter(::AbstractPolynomialZonotope) – return the center\npolynomial_order(::AbstractPolynomialZonotope) – return the polynomial order\nngens_dep – return the number of dependent generators\nngens_indep – return the number of independent generators\n\nThe subtypes of AbstractPolynomialZonotope (including abstract interfaces):\n\njulia> subtypes(AbstractPolynomialZonotope)\n2-element Vector{Any}:\n AbstractSparsePolynomialZonotope\n DensePolynomialZonotope\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/AbstractPolynomialZonotope/","page":"Polynomial zonotope sets (AbstractPolynomialZonotope)","title":"Polynomial zonotope sets (AbstractPolynomialZonotope)","text":"This interface requires to implement the following functions:","category":"page"},{"location":"lib/interfaces/AbstractPolynomialZonotope/#LazySets.API.center-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractPolynomialZonotope","page":"Polynomial zonotope sets (AbstractPolynomialZonotope)","title":"LazySets.API.center","text":"center(X::LazySet)\n\nCompute the center of a centrally symmetric set.\n\nInput\n\nX – centrally symmetric set\n\nOutput\n\nA vector with the center, or midpoint, of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolynomialZonotope/#LazySets.ngens_dep-Tuple{AbstractPolynomialZonotope}","page":"Polynomial zonotope sets (AbstractPolynomialZonotope)","title":"LazySets.ngens_dep","text":"ngens_dep(P::AbstractPolynomialZonotope)\n\nDetermine the number of dependent generators of a polynomial zonotope.\n\nInput\n\nP – polynomial zonotope\n\nOutput\n\nA nonnegative integer representing the number of dependent generators.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolynomialZonotope/#LazySets.ngens_indep-Tuple{AbstractPolynomialZonotope}","page":"Polynomial zonotope sets (AbstractPolynomialZonotope)","title":"LazySets.ngens_indep","text":"ngens_indep(P::AbstractPolynomialZonotope)\n\nDetermine the number of independent generators of a polynomial zonotope.\n\nInput\n\nP – polynomial zonotope\n\nOutput\n\nA nonnegative integer representing the number of independent generators.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolynomialZonotope/#LazySets.polynomial_order-Tuple{AbstractPolynomialZonotope}","page":"Polynomial zonotope sets (AbstractPolynomialZonotope)","title":"LazySets.polynomial_order","text":"polynomial_order(P::AbstractPolynomialZonotope)\n\nDetermine the polynomial order of a polynomial zonotope.\n\nInput\n\nP – polynomial zonotope\n\nOutput\n\nA nonnegative integer representing the polynomial order.\n\nNotes\n\nThe polynomial order is the maximum sum of all monomials' parameter exponents.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolynomialZonotope/","page":"Polynomial zonotope sets (AbstractPolynomialZonotope)","title":"Polynomial zonotope sets (AbstractPolynomialZonotope)","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/AbstractPolynomialZonotope/#LazySets.ngens-Tuple{AbstractPolynomialZonotope}","page":"Polynomial zonotope sets (AbstractPolynomialZonotope)","title":"LazySets.ngens","text":"ngens(P::AbstractPolynomialZonotope)\n\nReturn the number of generators of a polynomial zonotope.\n\nInput\n\nP – polynomial zonotope\n\nOutput\n\nThe total number of generators of P.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolynomialZonotope/#LazySets.order-Tuple{AbstractPolynomialZonotope}","page":"Polynomial zonotope sets (AbstractPolynomialZonotope)","title":"LazySets.order","text":"order(P::AbstractPolynomialZonotope)\n\nReturn the order of a polynomial zonotope.\n\nInput\n\nP – polynomial zonotope\n\nOutput\n\nThe order, defined as the quotient between the total number of generators and the ambient dimension, as a Rational number.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolynomialZonotope/","page":"Polynomial zonotope sets (AbstractPolynomialZonotope)","title":"Polynomial zonotope sets (AbstractPolynomialZonotope)","text":"Undocumented implementations:","category":"page"},{"location":"lib/interfaces/AbstractPolynomialZonotope/","page":"Polynomial zonotope sets (AbstractPolynomialZonotope)","title":"Polynomial zonotope sets (AbstractPolynomialZonotope)","text":"center\ndim\nisboundedtype\nisempty\nisuniversal","category":"page"},{"location":"lib/interfaces/AbstractPolynomialZonotope/","page":"Polynomial zonotope sets (AbstractPolynomialZonotope)","title":"Polynomial zonotope sets (AbstractPolynomialZonotope)","text":"Inherited from LazySet:","category":"page"},{"location":"lib/interfaces/AbstractPolynomialZonotope/","page":"Polynomial zonotope sets (AbstractPolynomialZonotope)","title":"Polynomial zonotope sets (AbstractPolynomialZonotope)","text":"an_element\narea\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nextrema\nextrema\nhigh\nhigh\nisbounded\nisoperation\nispolyhedral\nlow\nlow\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nlinear_map\nproject\nsample\nscale\nρ\ntranslate\ncartesian_product\nconvex_hull\nexact_sum\n≈\nisdisjoint\n==\nisequivalent\n⊂\n⊆\nminkowski_difference\nminkowski_sum","category":"page"},{"location":"lib/interfaces/AbstractPolynomialZonotope/#Implementations","page":"Polynomial zonotope sets (AbstractPolynomialZonotope)","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/AbstractPolynomialZonotope/","page":"Polynomial zonotope sets (AbstractPolynomialZonotope)","title":"Polynomial zonotope sets (AbstractPolynomialZonotope)","text":"Dense polynomial zonotope (DensePolynomialZonotope)","category":"page"},{"location":"man/decompose_example/#Decomposing-an-Affine-Map","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"","category":"section"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"In this section we present an illustrative example of the decomposed image of a linear map.","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Pages = [\"decompose_example.md\"]\nDepth = 3","category":"page"},{"location":"man/decompose_example/#Preliminaries:-Polygon,-Linear-Map,-and-Plotting","page":"Decomposing an Affine Map","title":"Preliminaries: Polygon, Linear Map, and Plotting","text":"","category":"section"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Consider the matrix-valued function Φ(θ) = beginpmatrix cos (θ)  -sin (θ)  sin (θ)  cos (θ) endpmatrix, θ  π π.","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"using LazySets, LazySets.Approximations, Plots\n\nΦ(theta) = [cos(theta) -sin(theta); sin(theta) cos(theta)]","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Now define an arbitrary convex polygon with five vertices with operatornameCH denoting the convex hull operation,","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"mathcalX = operatornameCHbig( (1 05) (11 02) (14 03) (17 05) (14 08) big)","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"This set can be defined as:","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"X = VPolygon([[1.0, 0.5], [1.1, 0.2], [1.4, 0.3], [1.7, 0.5], [1.4, 0.8]])","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"note: Note\nYou can as well define the convex hull of the one element sets (singletons) viaC = CHArray([Singleton([1.0, 0.5]), Singleton([1.1, 0.2]), Singleton([1.4, 0.3]), Singleton([1.7, 0.5]), Singleton([1.4, 0.8])])Observe that C is just a lazy convex hull, whereas X is a polygon in vertex representation.","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Applying the linear map Φ(π4)  mathcalX, we get a new polygon mathcalX which is the counter-clockwise turn of mathcalX by θ triangleq 45. In this package the linear map is not computed explicitly but only wrapped in a LinearMap instance.","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Xp = Φ(pi/4) * X\n\ntypeof(Xp)","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Let us plot the two polygons, mathcalX in green and mathcalX in blue.","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"example = plot(X, color=\"green\")\n\nplot!(example, Xp, 1e-2, color=\"blue\")","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Note that we have passed 1e-2 as additional argument for the LinearMap set (mathcalX) because by default such a set is just plotted as its box (or hyperrectangle) approximation. The value 1e-2 is the precision up to which the set is (over-)approximated with a polygon, which in this case is sufficient to obtain the actual set again. If such value is not specified, it defaults to 1e-3.","category":"page"},{"location":"man/decompose_example/#Cartesian-Decomposition","page":"Decomposing an Affine Map","title":"Cartesian Decomposition","text":"","category":"section"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Next we want to decompose mathcalX into a Cartesian product of intervals. That is, we project it to the x-axis and y-axis and then compose these intervals again: hatmathcalX = hatmathcalX_1  hatmathcalX_2.","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Xhat = overapproximate(X)  # approximation of X with an axis-aligned polygon\n\nplot!(example, Xhat, color=\"gray\", alpha=0.3)","category":"page"},{"location":"man/decompose_example/#Decomposed-Image-of-a-Linear-Map","page":"Decomposing an Affine Map","title":"Decomposed Image of a Linear Map","text":"","category":"section"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Now let us compute the linear map for the box approximation, and let us call it mathcalY = Φ(π4)  hatmathcalX. This will be a diamond-like shape (the box turned by 45°).","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Y = Φ(pi/4) * Xhat\n\nplot!(example, Y, color=\"yellow\", alpha=0.3)","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"However, we want our approximation be again a Cartesian product of intervals, so we have to overapproximate this diamond-like shape again: hatmathcalY = hatmathcalX = hatmathcalX_1  hatmathcalX_2","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Xhatp = overapproximate(Y)\n\nplot!(example, Xhatp, color=\"gray\", alpha=0.3)","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"As we can see, the resulting box hatmathcalX is not a tight overapproximation of mathcalX. We can, however, gain precision by reducing the angle by which we turn the set, e.g., making two smaller turns. Why not try it out?","category":"page"},{"location":"#LazySets.jl","page":"Home","title":"LazySets.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LazySets.jl is a Julia package for calculus with convex sets.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The aim is to provide a scalable library for solving complex set-based problems, such as those encountered in differential inclusions or reachability analysis techniques in the domain of formal verification. Typically, one is confronted with a set-based recurrence with a given initial set and/or input sets, and for visualization purposes the final result has to be obtained through an adequate projection onto low-dimensions. This library implements types to construct set formulas and methods to efficiently and accurately approximate the projection in low-dimensions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In this package we describe convex sets lazily (i.e., symbolically). This way we provide an exact but abstract representation, in principle for any common convex set class or operation between sets. Concrete information is obtained through evaluating the set in specific directions. More precisely, each concrete subtype mathcalX of the abstract type LazySet exports a method to calculate its support vector σ(d mathcalX) in a given (arbitrary) direction d  ℝ^n. Representing sets exactly but lazily has the advantage of being able to perform only the required operations on-demand.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For very long sequences of computations (e.g., set-based recurrences with tens of thousands of elements), it is useful to combine both lazy and concrete representations such as polyhedral approximations. All this is easy to do with LazySets. Moreover, we provide a specialized module for handling Cartesian decomposition of two-dimensional projections. The projection can be taken to the desired precision using an iterative refinement method.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let mathcalX_0 subset ℝ^1000 be the Euclidean ball of center (1  1) and radius 01 in dimension n=1000. Given a real matrix A  ℝ^1000  1000, suppose that we are interested in the equation","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathcalY = CH(e^A δ mathcalX_0  δ BmathcalU mathcalX_0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where CH is the convex hull operator,  denotes Minkowski sum, mathcalU is a ball in the infinity norm centered at zero and radius 12, and B is a linear map of the appropriate dimensions. This equation typically arises in the study of discrete approximation models for reachability of continuous systems, see for example Frehse et al. [FGD+11].","category":"page"},{"location":"","page":"Home","title":"Home","text":"For concreteness, we take A to be a random matrix with probability 1 of any entry being nonzero. Suppose that the input set mathcalU is two-dimensional, and that the linear map B is random. Finally, let δ = 0.1. Using LazySets, we can define this problem as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using LazySets, SparseArrays\n\njulia> A = sprandn(1000, 1000, 0.01);\n\njulia> δ = 0.1;\n\njulia> X0 = Ball2(ones(1000), 0.1);\n\njulia> B = randn(1000, 2);\n\njulia> U = BallInf(zeros(2), 1.2);","category":"page"},{"location":"","page":"Home","title":"Home","text":"The @time macro shows that building mathcalY with LazySets is instantaneous.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Y = CH(SparseMatrixExp(A * δ) * X0 + δ * B * U, X0);","category":"page"},{"location":"","page":"Home","title":"Home","text":"By asking for the (parameter-free) type of Y, we see that it is a lazy convex hull:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> LazySets.basetype(Y)\nConvexHull","category":"page"},{"location":"","page":"Home","title":"Home","text":"The full type includes type parameters for the types of the arguments:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> typeof(Y)\nConvexHull{Float64, MinkowskiSum{Float64, ExponentialMap{Float64, Ball2{Float64, Vector{Float64}}}, LinearMap{Float64, BallInf{Float64, Vector{Float64}}, Float64, Matrix{Float64}}}, Ball2{Float64, Vector{Float64}}}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now suppose that we are interested in observing the projection of mathcalY onto the variables number 1 and 500. First we define the 21000 projection matrix and apply it to mathcalY as a linear map (i.e., from the left). Second, we use the overapproximate method:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> proj_mat = [[1. zeros(1, 999)]; [zeros(1, 499) 1. zeros(1, 500)]];\n\njulia> res = Approximations.overapproximate(proj_mat * Y);","category":"page"},{"location":"","page":"Home","title":"Home","text":"We have calculated a box overapproximation of the exact projection onto the (x_1 x_500) plane. Notice that it takes about 0.064 seconds for the whole operation, allocating less than 10MB of RAM. Let us note that if the set operations were done explicitly, this would be much (!) slower. For instance, already the explicit computation of the matrix exponential would have cost 10x more, and allocated around 300MB. For even higher n, an evaluation will probably run out of RAM. But this is doable with LazySets because the action of the matrix exponential on the set is only evaluated along the directions of interest. Similar comments apply to the Minkowski sum above.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can visualize the result using plot, as shown below (left-most plot).","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: assets/example_ch.png)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the second and third plots, we have used a refined method that allows to specify a prescribed accuracy for the projection (in terms of the Hausdorff distance). It can be passed as a second argument to overapproximate. For the theoretical background, see the section on Polyhedral Approximations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Error tol. time (s) memory (MB)\n∞ (no refinement) 0.022 5.27\n1e-1 0.051 7.91\n1e-3 0.17 30.3","category":"page"},{"location":"","page":"Home","title":"Home","text":"This table shows the runtime and memory consumption for different error tolerances, and the results are shown in three plots of above, from left to right. When passing to a smaller tolerance, the corners connecting edges are more \"rounded\", at the expense of computational resources, since more support vectors have to be evaluated.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The core functionality of LazySets is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lazy (i.e., symbolic) types for several classes of convex sets such as balls in different norms, polygons in constraint or vertex representation, zonotopes, special types such as lines and linear constraints, hyperrectangles, and high-dimensional polyhedra.\nLazy implementations for most commonly used set operations, e.g., Minkowski sum, Cartesian product, convex hull and interval hull approximations, and linear and exponential maps.","category":"page"},{"location":"","page":"Home","title":"Home","text":"On top of the previous basic type representations and operations, LazySets can be used to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Efficiently evaluate the support vector of nested lazy sets.\nCartesian decomposition of lazy sets using two-dimensional projections.\nFast overapproximation of an exact set using a polyhedral approximation, to the desired accuracy.\nExtensive visualization capabilities through the Plots.jl framework.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/getting_started.md\",\n    \"man/polyhedral_approximations.md\",\n    \"man/decompose_example.md\",\n    \"man/fast_2d_LPs.md\",\n    \"man/iterative_refinement.md\",\n    \"man/interval_hulls.md\",\n    \"man/convex_hulls.md\",\n    \"man/set_operations.md\",\n    \"man/reach_zonotopes.md\",\n    \"man/reach_zonotopes_hybrid.md\",\n    \"man/concrete_polyhedra.md\",\n    \"man/parallel_approximations.md\",\n    \"man/lazy_intersections.md\"\n]\nDepth = 2","category":"page"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/interfaces.md\",\n    \"lib/sets/Hyperrectangle.md\",\n    \"lib/sets/BallInf.md\",\n    \"lib/sets/Interval.md\",\n    \"lib/sets/Singleton.md\",\n    \"lib/sets/ZeroSet.md\",\n    \"lib/sets/HalfSpace.md\",\n    \"lib/sets/HPolyhedron.md\",\n    \"lib/sets/Hyperplane.md\",\n    \"lib/sets/Line2D.md\",\n    \"lib/sets/Line.md\",\n    \"lib/sets/Universe.md\",\n    \"lib/sets/HParallelotope.md\",\n    \"lib/sets/HPolytope.md\",\n    \"lib/sets/VPolytope.md\",\n    \"lib/sets/HPolygon.md\",\n    \"lib/sets/HPolygonOpt.md\",\n    \"lib/sets/VPolygon.md\",\n    \"lib/sets/Zonotope.md\",\n    \"lib/sets/LineSegment.md\",\n    \"lib/sets/Ball1.md\",\n    \"lib/sets/EmptySet.md\",\n    \"lib/sets/Ball2.md\",\n    \"lib/sets/Ellipsoid.md\",\n    \"lib/sets/Ballp.md\",\n    \"lib/sets/DensePolynomialZonotope.md\",\n    \"lib/lazy_operations/Bloating.md\",\n    \"lib/lazy_operations/CartesianProduct.md\",\n    \"lib/lazy_operations/ConvexHull.md\",\n    \"lib/lazy_operations/Intersection.md\",\n    \"lib/lazy_operations/MinkowskiSum.md\",\n    \"lib/lazy_operations/LinearMap.md\",\n    \"lib/lazy_operations/ExponentialMap.md\",\n    \"lib/lazy_operations/ResetMap.md\",\n    \"lib/lazy_operations/Translation.md\",\n    \"lib/lazy_operations/AffineMap.md\",\n    \"lib/lazy_operations/SymmetricIntervalHull.md\",\n    \"lib/lazy_operations/UnionSet.md\",\n    \"lib/lazy_operations/Complement.md\",\n    \"lib/lazy_operations/Rectification.md\",\n    \"lib/comparisons.md\",\n    \"lib/conversion.md\",\n    \"lib/binary_functions.md\",\n    \"lib/approximations.md\",\n    \"lib/utils.md\",\n    \"lib/parallel.md\"\n]\nDepth = 2","category":"page"},{"location":"lib/sets/EmptySet/#def_EmptySet","page":"EmptySet","title":"Empty set (EmptySet)","text":"","category":"section"},{"location":"lib/sets/EmptySet/#LazySets.EmptySetModule.EmptySet","page":"EmptySet","title":"LazySets.EmptySetModule.EmptySet","text":"EmptySet{N} <: ConvexSet{N}\n\nType that represents the empty set, i.e., the set with no elements.\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/EmptySet/#LazySets.EmptySetModule.∅","page":"EmptySet","title":"LazySets.EmptySetModule.∅","text":"∅\n\nAlias for EmptySet{Float64}.\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/EmptySet/#Conversion","page":"EmptySet","title":"Conversion","text":"","category":"section"},{"location":"lib/sets/EmptySet/","page":"EmptySet","title":"EmptySet","text":"convert(::Type{EmptySet}, ::LazySet)","category":"page"},{"location":"lib/sets/EmptySet/#Operations","page":"EmptySet","title":"Operations","text":"","category":"section"},{"location":"lib/sets/EmptySet/#LazySets.chebyshev_center_radius-Tuple{EmptySet}","page":"EmptySet","title":"LazySets.chebyshev_center_radius","text":"chebyshev_center_radius(∅::EmptySet; [kwargs]...)\n\nCompute a Chebyshev center and the corresponding radius of an empty set.\n\nInput\n\n∅      – empty set\nkwargs – further keyword arguments (ignored)\n\nOutput\n\nAn error.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/#LazySets.API.complement-Tuple{LazySets.API.LazySet}-lib-sets-EmptySet","page":"EmptySet","title":"LazySets.API.complement","text":"complement(X::LazySet)\n\nCompute the complement of a set.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the complement of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/#LazySets.API.complement-Tuple{EmptySet}","page":"EmptySet","title":"LazySets.API.complement","text":"Extended help\n\ncomplement(∅::EmptySet)\n\nOutput\n\nThe Universe of the same dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/#Base.rand-Tuple{Type{<:LazySets.API.LazySet}}-lib-sets-EmptySet","page":"EmptySet","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/#Base.rand-Tuple{Type{EmptySet}}","page":"EmptySet","title":"Base.rand","text":"Extended help\n\nrand(::Type{EmptySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nOutput\n\nThe (unique) empty set of the given numeric type and dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/#LazySets.plot_recipe-Union{Tuple{EmptySet{N}}, Tuple{N}, Tuple{EmptySet{N}, Any}} where N","page":"EmptySet","title":"LazySets.plot_recipe","text":"plot_recipe(∅::EmptySet{N}, [ε]=zero(N)) where {N}\n\nConvert an empty set to a sequence of points for plotting. In the special case of an empty set, the sequence is empty.\n\nInput\n\n∅ – empty set\nε – (optional, default: 0) ignored, used for dispatch\n\nOutput\n\nAn empty array.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/","page":"EmptySet","title":"EmptySet","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/EmptySet/","page":"EmptySet","title":"EmptySet","text":"an_element\narea","category":"page"},{"location":"lib/sets/EmptySet/","page":"EmptySet","title":"EmptySet","text":"constrained_dimensions","category":"page"},{"location":"lib/sets/EmptySet/","page":"EmptySet","title":"EmptySet","text":"convex_hull\ncopy(::EmptySet)\ndiameter\ndim\nhigh\nhigh\nisbounded\nisboundedtype\nisempty\nisoperationtype\nisuniversal\nlow\nlow\nnorm\nradius\nrationalize\nrectify\nreflect\nvertices_list\nvertices\nvolume\ndistance\nexponential_map\n∈\nis_interior_point\nlinear_map\npermute\nproject\nsample\nscale\nscale!\nρ\nσ\ntranslate\ntranslate!\ncartesian_product\nconvex_hull\ndifference\ndistance\nintersection\n≈\nisdisjoint\n⊆\nlinear_combination\nminkowski_difference\nminkowski_sum","category":"page"},{"location":"lib/sets/EmptySet/","page":"EmptySet","title":"EmptySet","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/EmptySet/","page":"EmptySet","title":"EmptySet","text":"concretize\neltype\neltype\nextrema\nextrema\nisoperation\nispolyhedral\nsingleton_list\naffine_map\nexact_sum\n==\nisequivalent\n⊂","category":"page"},{"location":"lib/sets/EmptySet/","page":"EmptySet","title":"EmptySet","text":"Inherited from LazySet but does not apply:","category":"page"},{"location":"lib/sets/EmptySet/","page":"EmptySet","title":"EmptySet","text":"polyhedron\ntosimplehrep\ntriangulate\ntriangulate_faces","category":"page"},{"location":"lib/sets/EmptySet/","page":"EmptySet","title":"EmptySet","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/EmptySet/","page":"EmptySet","title":"EmptySet","text":"isconvextype","category":"page"},{"location":"lib/sets/ZeroSet/#def_ZeroSet","page":"ZeroSet","title":"Origin (ZeroSet)","text":"","category":"section"},{"location":"lib/sets/ZeroSet/#LazySets.ZeroSetModule.ZeroSet","page":"ZeroSet","title":"LazySets.ZeroSetModule.ZeroSet","text":"ZeroSet{N} <: AbstractSingleton{N}\n\nType that represents the zero set, i.e., the set that only contains the origin.\n\nFields\n\ndim – the ambient dimension of the set\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/ZeroSet/#Operations","page":"ZeroSet","title":"Operations","text":"","category":"section"},{"location":"lib/sets/ZeroSet/#LazySets.element-Tuple{ZeroSet}","page":"ZeroSet","title":"LazySets.element","text":"element(Z::ZeroSet)\n\nReturn the element of a zero set.\n\nInput\n\nZ – zero set\n\nOutput\n\nThe element of the zero set, i.e., a zero vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/ZeroSet/#LazySets.element-Tuple{ZeroSet, Int64}","page":"ZeroSet","title":"LazySets.element","text":"element(Z::ZeroSet, i::Int)\n\nReturn the i-th entry of the element of a zero set.\n\nInput\n\nZ – zero set\ni – dimension\n\nOutput\n\nThe i-th entry of the element of the zero set, i.e., 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/ZeroSet/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-ZeroSet","page":"ZeroSet","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/ZeroSet/#Base.rand-Tuple{Type{ZeroSet}}","page":"ZeroSet","title":"Base.rand","text":"Extended help\n\nrand(::Type{ZeroSet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nOutput\n\nThe (only) zero set of the given numeric type and dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"copy(::Type{ZeroSet})\ndim\nreflect\nrectify\n∈\nisoperationtype\nlinear_map\nscale\nscale!\nρ\ntranslate\nminkowski_sum","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"complement\nconcretize\nconstraints\nconvex_hull\ndiameter\neltype\neltype\nisoperation\npolyhedron\nrationalize\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\naffine_map\nexponential_map\nis_interior_point\nsample\nconvex_hull\n≈\n==\n⊂","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"ispolyhedral","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"isbounded\nisboundedtype","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"an_element\nisempty\nisuniversal","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"order\nremove_redundant_generators\ntogrep\nreduce_order\nsplit\nsplit","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"Inherited from AbstractHyperrectangle:","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"area\nextrema\nextrema\nisflat\nnorm\nradius\nvolume\nproject\ndifference","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"Inherited from AbstractSingleton:","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"center\ncenter\nchebyshev_center_radius\nconstraints_list\ngenerators\ngenmat\nhigh\nhigh\nlow\nlow\nngens\nradius_hyperrectangle\nradius_hyperrectangle\nvertices\nvertices\nvertices_list\nσ\ncartesian_product\ndistance\nintersection\nisdisjoint\nisequivalent\n⊆","category":"page"},{"location":"man/iterative_refinement/#Iterative-Refinement","page":"Iterative Refinement","title":"Iterative Refinement","text":"","category":"section"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"This section of the manual describes an approximation method for an arbitrary two-dimensional convex set S and a given error bound ε using support vectors. The basic idea is to add new supporting directions whenever the approximation error is still bigger than ε.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Pages = [\"iterative_refinement.md\"]\nDepth = 3","category":"page"},{"location":"man/iterative_refinement/#Local-approximations","page":"Iterative Refinement","title":"Local approximations","text":"","category":"section"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"The polygonal approximation of an arbitrary lazy convex set S is represented by a list of local approximations or refinements. More precisely, a local approximation is a triple (p_1 p_2 q), where:","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"p_1 and p_2 belong to S\nthe segments (p_1 q) and (p_2 q) belong to support lines of S","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Since S is assumed to be convex, the segment (p_1 p_2) is inside S. Taking each support line (p_1 q) of a given list of local approximations of S, we can build a polygon in constraint representation that overapproximates S.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"The type LocalApproximation{N} implements a local approximation; it is parametric in the numeric type N, and also contains additional information regarding the quality of the approximation: The refinable field is a boolean that is true whenever the approximation can be improved, and err is an upper bound on the exact Hausdorff distance of the approximation with respect to the exact set S.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Given the unit ball in the 2-norm, below we plot the local approximation along the East and North directions.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"using Plots, LazySets, LazySets.Approximations\n\nb = Ball2(zeros(2), 1.)\n\nplot(b, 1e-3, aspectratio=1, alpha=0.3, legend=false)\n\nplot!(Singleton([1.0, 0.0]), annotations=(1.1, 0.1, text(\"p1\")), color=\"green\")\nplot!(Singleton([0.0, 1.0]), annotations=(0.1, 1.1, text(\"p2\")), color=\"green\")\nplot!(Singleton([1.0, 1.0]), annotations=(1.09, 1.1, text(\"q\")))\nplot!(Singleton([0.0, 0.0]), annotations=(0.1, 0.0, text(\"0\")), color=\"green\")\nplot!(annotations=(1.4, 0.1, text(\"d1\")))\nplot!(annotations=(0.1, 1.4, text(\"d2\")))\nplot!(annotations=(0.75, 0.8, text(\"ndir\")))\n\nplot!(x->x, x->1., -0.8, 1.3, line=1, color=\"black\", linestyle=:dash)\nplot!(x->1., x->x, -0.8, 1.3, line=1, color=\"black\", linestyle=:dash)\nplot!(x->x+1, x->0., 0.0, 0.4, line=1, color=\"red\", linestyle=:solid, arrow=true)\nplot!(x->0., x->x+1, 0.0, 0.4, line=1, color=\"red\", linestyle=:solid, arrow=true)\nplot!(x->-x, x->x+1, -1.2, .2, line=1., color=\"black\", linestyle=:dashdot)\nplot!(x->x+.6, x->x+.6, -.1, .08, line=1, color=\"red\", linestyle=:solid, arrow=true)","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"We can instantiate and append this approximation to a fresh PolygonalOverapproximation object, which is a type that wraps a set and a list of LocalApproximations. The approximation is refinable, since it can be \"split\" along ndir, where ndir is the direction normal to the line (p_1 p_2) (shown dash-dotted in the figure), providing two approximations which are closer to the given set in Hausdorff distance.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"using LazySets.Approximations: PolygonalOverapproximation, addapproximation!\n\nΩ = PolygonalOverapproximation(b)\np1, d1, p2, d2 = [1.0, 0.0], [1.0, 0.0], [0.0, 1.0], [0.0, 1.0]\napprox_EAST_NORTH = addapproximation!(Ω, p1, d1, p2, d2)\n\napprox_EAST_NORTH.refinable","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"The associated error is sqrt2-10414213, which is the distance between the point q and the intersection between the line (0 q) and the circle. Actually this point corresponds to the support vector of the set b along ndir.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"approx_EAST_NORTH.err","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"The refined approximation is computed next.","category":"page"},{"location":"man/iterative_refinement/#Refinement","page":"Iterative Refinement","title":"Refinement","text":"","category":"section"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Basically, the refinement step consists of splitting the local approximation (p_1 p_2 q) into two local approximations (p_1 s q) and (s p_2 q), where s is the support vector of S along ndir.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"To illustrate this, first let's add the remaining three approximations to Ω along the canonical directions, to build a box overapproximation of b.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"using LazySets.Approximations: refine, tohrep\n\nplot(b, 1e-3, aspectratio=1, alpha=0.3)\n\n# initialize box directions\nDIR_EAST, DIR_NORTH, DIR_WEST, DIR_SOUTH = [1., 0.], [0., 1.], [-1., 0.], [0., -1.]\npE, pN, pW, pS = σ(DIR_EAST, b), σ(DIR_NORTH, b), σ(DIR_WEST, b), σ(DIR_SOUTH, b)\n\nΩ = PolygonalOverapproximation(b)\naddapproximation!(Ω, pS, DIR_SOUTH, pE, DIR_EAST)\naddapproximation!(Ω, pW, DIR_WEST, pS, DIR_SOUTH)\naddapproximation!(Ω, pN, DIR_NORTH, pW, DIR_WEST)\naddapproximation!(Ω, pE, DIR_EAST, pN, DIR_NORTH)\n\nplot!(tohrep(Ω), alpha=0.2, color=\"orange\")","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Next we refine the first approximation of the list.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"approx = pop!(Ω.approx_stack)\n(r1, r2) = refine(approx, Ω.S)\npush!(Ω.approx_stack, r2)\npush!(Ω.approx_stack, r1)\n\nplot(b, 1e-3, aspectratio=1, alpha=0.3)\nplot!(tohrep(Ω), alpha=0.2, color=\"orange\")","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"We call r1 and r2 the right and left approximations respectively, since they are saved in counter-clockwise order. We can check that the first two approximations are still refinable.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Ω.approx_stack[end].refinable,  Ω.approx_stack[end-1].refinable","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Hence, we can make again a refinement of that approximation.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"approx = pop!(Ω.approx_stack)\n(r1, r2) = refine(approx, Ω.S)\npush!(Ω.approx_stack, r2)\npush!(Ω.approx_stack, r1)\n\nplot(b, 1e-3, aspectratio=1, alpha=0.3)\nplot!(tohrep(Ω), alpha=0.2, color=\"orange\")","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"The criterion for an approximation being refinable is that we can properly define a normal direction ndir. This boils down to checking for the following \"degenerate\" cases:","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"p_1 and p_2 overlap.\np_1 and q overlap.\np_2 and q overlap.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Moreover, we include the condition approx_error > TOL where TOL is the floating point epsilon in the given numerical precision.","category":"page"},{"location":"man/iterative_refinement/#Algorithm","page":"Iterative Refinement","title":"Algorithm","text":"","category":"section"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Having presented the individual steps, we give the pseudocode of the iterative refinement algorithm, see overapproximate_hausdorff(S, ε).","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"The algorithm consists of the following steps:","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Initialization. The approximation is initialized with box directions, i.e. it starts with four LocalApproximation objects. Let i=1.\nRefinement loop. If the local approximation at index i has an error greater than the threshold ε, then refine. Otherwise, increment i <- i+1.\nRedundancy check. Insert the refined right approximation at position i, and check whether the left approximation is redundant or not with respect to the one at position i+1. Checking for redundancy amounts to checking for overlap of both p1 and q. Then, either substitute at i+1 or insert (keeping the approximation at i+1) depending on the redundancy check.\nStopping criterion. Terminate if the index i exceeds the current length of the approximations list; otherwise continue with step 2.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Observe that the algorithm finishes when all approximations are such that their associated error is smaller than ε, hence the Hausdorff distance between S and its polygonal overapproximation is no greater than ε.","category":"page"},{"location":"man/iterative_refinement/#Example","page":"Iterative Refinement","title":"Example","text":"","category":"section"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"As a final example consider the iterative refinement of the ball b for different values of the approximation threshold ε.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"using LazySets.Approximations: overapproximate_hausdorff\n\np0 = plot(b, 1e-6, aspectratio=1)\np1 = plot!(p0, overapproximate(b, 1.), alpha=0.4, aspectratio=1)\n\np0 = plot(b, 1e-6, aspectratio=1)\np2 = plot!(p0, overapproximate(b, 0.1), alpha=0.4, aspectratio=1)\n\np0 = plot(b, 1e-6, aspectratio=1)\np3 = plot!(p0, overapproximate(b, 0.01), alpha=0.4, aspectratio=1)\n\nplot(p1, p2, p3, layout=(1, 3))","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Meanwhile, the number of constraints of the polygonal overapproximation increases, in this example by a power of 2 when the error is divided by a factor 10.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"h = ε ->  length(overapproximate_hausdorff(b, ε).constraints)\nh(1.), h(0.1), h(0.01)","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"note: Note\nActually, the plotting function for an arbitrary convex LazySet, plot(...) (called recipe in the context of Plots.jl), receives a numeric argument ε and the routine itself calls overapproximate. However, some sets such as abstract polygons have their own plotting recipe and hence do not require the error threshold, since they are plotted exactly as the convex hull of their vertices.","category":"page"},{"location":"lib/sets/DensePolynomialZonotope/#def_DensePolynomialZonotope","page":"DensePolynomialZonotope","title":"Polynomial zonotope (DensePolynomialZonotope)","text":"","category":"section"},{"location":"lib/sets/DensePolynomialZonotope/#LazySets.DensePolynomialZonotopeModule.DensePolynomialZonotope","page":"DensePolynomialZonotope","title":"LazySets.DensePolynomialZonotopeModule.DensePolynomialZonotope","text":"DensePolynomialZonotope{N, VT, VMT, MT} <: AbstractPolynomialZonotope{N}\n\nType that represents a polynomial zonotope.\n\nFields\n\nc  – starting point\nE  – matrix of multi-indexed generators such that all indices have the         same value\nF  – matrix of multi-indexed generators such that not all indices have         the same value\nG  – matrix of single-indexed generators\n\nNotes\n\nPolynomial zonotopes were introduced in Althoff [Alt13] and have been applied as non-convex set representation to the reachability problem of nonlinear ODEs.\n\nMathematically, a polynomial zonotope is defined as the tuple (c E F G), where:\n\nc  ℝ^n is the starting point (in some particular cases it corresponds to the center of a usual zonotope),\nE = E^1  E^η is an n  p  η matrix with column blocks\n\nE^i = f^(i 1 1  1)  f^(i p p  p) qquad i = 1 η\n\ncalled the matrix of multi-indexed generators with equal indices, where each f^(i k_1 k_2  k_i) is an n-vector,\n\nF = F^2  F^η is a matrix with column-blocks\n\nF^i = f^(i 1 1  1 2) f^(i 1 1  1 3)  f^(i 1 1  1 p) \nf^(i 1 1  2 2) f^(i 1 1  2 3)  f^(i 1 1  2 p) \nf^(i 1 1  3 3)  qquad i = 1 η\n\ncalled the matrix of multi-indexed generators with unequal indices (or, more accurately, not-all-equal indices), where each f^(i k_1 k_2  k_i) is an n-vector,\n\nG = G^1  G^q is an n  q matrix with columns\n\nG^i = g^(i) qquad i = 1 q\n\ncalled the matrix of single-indexed generators, where each g^(i) is an n-vector.\n\nThe polynomial zonotope (c E F G) defines the set:\n\nleft c + _j=1^p β_j f^(1 j) + _j=1^p _k=j^p β_j β_k f^(2 j k) + \n+  + _j=1^p _k=j^p  _m=ℓ^p β_j β_k  β_m f^(η j k  m) + \n+ _i=1^q γ_i g^(i) qquad β_i γ_i  -1 1 right\n\nwhere the number of factors in the final product, β_j β_k  β_m, corresponds to the polynomial order η.\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/DensePolynomialZonotope/#Operations","page":"DensePolynomialZonotope","title":"Operations","text":"","category":"section"},{"location":"lib/sets/DensePolynomialZonotope/#LazySets.ngens_dep-Tuple{DensePolynomialZonotope}","page":"DensePolynomialZonotope","title":"LazySets.ngens_dep","text":"ngens_dep(P::DensePolynomialZonotope)\n\nReturn the number of dependent generators of a polynomial zonotope.\n\nInput\n\nP – polynomial zonotope\n\nOutput\n\nThe number of dependent generators of P.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/DensePolynomialZonotope/#LazySets.ngens_indep-Tuple{DensePolynomialZonotope}","page":"DensePolynomialZonotope","title":"LazySets.ngens_indep","text":"ngens_indep(P::DensePolynomialZonotope)\n\nReturn the number of independent generators of a polynomial zonotope.\n\nInput\n\nP – polynomial zonotope\n\nOutput\n\nThe number of independent generators of P.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/DensePolynomialZonotope/#LazySets.polynomial_order-Tuple{DensePolynomialZonotope}","page":"DensePolynomialZonotope","title":"LazySets.polynomial_order","text":"polynomial_order(P::DensePolynomialZonotope)\n\nPolynomial order of a polynomial zonotope.\n\nInput\n\nP – polynomial zonotope\n\nOutput\n\nThe polynomial order, defined as the maximal power of the scale factors β_i. It is usually denoted η.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/DensePolynomialZonotope/","page":"DensePolynomialZonotope","title":"DensePolynomialZonotope","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/DensePolynomialZonotope/","page":"DensePolynomialZonotope","title":"DensePolynomialZonotope","text":"center\nisoperationtype\nlinear_map\nscale\nscale!","category":"page"},{"location":"lib/sets/DensePolynomialZonotope/","page":"DensePolynomialZonotope","title":"DensePolynomialZonotope","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/DensePolynomialZonotope/","page":"DensePolynomialZonotope","title":"DensePolynomialZonotope","text":"an_element\narea\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nextrema\nextrema\nhigh\nhigh\nisbounded\nisconvextype\nisoperation\nispolyhedral\nlow\nlow\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nproject\nsample\nρ\ntranslate\ncartesian_product\nconvex_hull\nexact_sum\n≈\nisdisjoint\n==\nisequivalent\n⊂\n⊆\nlinear_combination\nminkowski_difference\nminkowski_sum","category":"page"},{"location":"lib/sets/DensePolynomialZonotope/","page":"DensePolynomialZonotope","title":"DensePolynomialZonotope","text":"Inherited from AbstractPolynomialZonotope:","category":"page"},{"location":"lib/sets/DensePolynomialZonotope/","page":"DensePolynomialZonotope","title":"DensePolynomialZonotope","text":"center\ndim\nisboundedtype\nisempty\nisuniversal\nngens\norder","category":"page"},{"location":"about/#About","page":"About","title":"About","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"This page contains some general information about this project, and recommendations about contributing.","category":"page"},{"location":"about/","page":"About","title":"About","text":"Pages = [\"about.md\"]","category":"page"},{"location":"about/#Contributing","page":"About","title":"Contributing","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"If you like this package, consider contributing!","category":"page"},{"location":"about/","page":"About","title":"About","text":"Creating an issue in the LazySets GitHub issue tracker to report a bug, open a discussion about existing functionality, or suggesting new functionality is appreciated.","category":"page"},{"location":"about/","page":"About","title":"About","text":"If you have written code and would like it to be peer reviewed and added to the library, you can fork the repository and send a pull request (see below). Typical contributions include fixing a bug, adding a new feature or improving the documentation (either in source code or the online manual).","category":"page"},{"location":"about/","page":"About","title":"About","text":"You are also welcome to get in touch with us in the JuliaReach Zulip chat.","category":"page"},{"location":"about/","page":"About","title":"About","text":"Below we detail some general comments about contributing to this package. The JuliaReach Developer's Documentation describes coding guidelines; take a look when in doubt about the coding style that is expected for the code that is finally merged into the library.","category":"page"},{"location":"about/#Branches-and-pull-requests-(PR)","page":"About","title":"Branches and pull requests (PR)","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"We use a standard pull request policy: You work in a private branch and eventually add a pull request, which is then reviewed by other programmers and merged into the master branch.","category":"page"},{"location":"about/","page":"About","title":"About","text":"Each pull request should be pushed in a new branch with the name of the author followed by a descriptive name, e.g., mforets/my_feature. If the branch is associated to a previous discussion in one issue, we use the name of the issue for easier lookup, e.g., mforets/7.","category":"page"},{"location":"about/#Unit-testing-and-continuous-integration-(CI)","page":"About","title":"Unit testing and continuous integration (CI)","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"This project is synchronized with GitHub Actions such that each PR gets tested before merging (and the build is automatically triggered after each new commit). For the maintainability of this project, it is important to make all unit tests pass.","category":"page"},{"location":"about/","page":"About","title":"About","text":"To run the unit tests locally, you can do:","category":"page"},{"location":"about/","page":"About","title":"About","text":"julia> using Pkg\n\njulia> Pkg.test(\"MathematicalPredicates\")","category":"page"},{"location":"about/","page":"About","title":"About","text":"We also advise adding new unit tests when adding new features to ensure long-term support of your contributions.","category":"page"},{"location":"about/#Contributing-to-the-documentation","page":"About","title":"Contributing to the documentation","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"New functions and types should be documented according to the JuliaReach Developer's Documentation.","category":"page"},{"location":"about/","page":"About","title":"About","text":"You can view the source-code documentation from inside the REPL by typing ? followed by the name of the type or function. For example, the following command will print the documentation of the LazySet type:","category":"page"},{"location":"about/","page":"About","title":"About","text":"julia> ?LazySet","category":"page"},{"location":"about/","page":"About","title":"About","text":"The documentation you are currently reading is written in Markdown, and it relies on the package Documenter.jl to produce the HTML layout. The sources for creating this documentation are found in docs/src. You can easily include the documentation that you wrote for your functions or types there (see the source code or Documenter's guidefor examples).","category":"page"},{"location":"about/","page":"About","title":"About","text":"To generate the documentation locally, run make.jl, e.g., by executing the following command in the terminal:","category":"page"},{"location":"about/","page":"About","title":"About","text":"$ julia --color=yes docs/make.jl","category":"page"},{"location":"about/","page":"About","title":"About","text":"Note that this also runs all doctests which will take some time.","category":"page"},{"location":"about/#Related-projects","page":"About","title":"Related projects","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"The project 3PLIB is a Java Library developed by Frédéric Viry, and it is one of the previous works that led to the creation of LazySets.jl. 3PLIB is specialized to planar projections of convex polyhedra. It was initially created to embed this feature in Java applications, and also provides a backend for visualization of high-dimensional reach set approximations computed with SpaceEx.","category":"page"},{"location":"about/#Credits","page":"About","title":"Credits","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"Here we list the names of the maintainers of the LazySets.jl library, as well as past and present contributors (in alphabetic order).","category":"page"},{"location":"about/#Core-developers","page":"About","title":"Core developers","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"Marcelo Forets, Universidad de la República\nChristian Schilling, Aalborg University","category":"page"},{"location":"about/#Contributors","page":"About","title":"Contributors","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"Tomer Arnon, Stanford University\nLuca Ferranti, University of Vaasa\nDaniel Freire Caporale, Universidad de la República\nSebastián Guadalupe, Universidad de la República\nKostiantyn Potomkin, Australian National University\nFrédéric Viry, CERFACS, France\nUeli Wechsler, ETH Zurich","category":"page"},{"location":"about/#Acknowledgements","page":"About","title":"Acknowledgements","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"We are grateful to the following persons for enlightening discussions:","category":"page"},{"location":"about/","page":"About","title":"About","text":"Sergiy Bogomolov\nGoran Frehse","category":"page"},{"location":"lib/sets/Ball1/#def_Ball1","page":"Ball1","title":"Manhattan-norm ball (Ball1)","text":"","category":"section"},{"location":"lib/sets/Ball1/#LazySets.Ball1Module.Ball1","page":"Ball1","title":"LazySets.Ball1Module.Ball1","text":"Ball1{N, VN<:AbstractVector{N}} <: AbstractCentrallySymmetricPolytope{N}\n\nType that represents a ball in the 1-norm (also known as the Manhattan norm). The ball is also known as a cross-polytope.\n\nIt is defined as the set\n\nmathcalB_1^n(c r) =  x  ℝ^n  _i=1^n c_i - x_i  r \n\nwhere c  ℝ^n is its center and r  ℝ_+ its radius.\n\nFields\n\ncenter – center of the ball as a real vector\nradius – radius of the ball as a scalar ( 0)\n\nExamples\n\nThe unit ball in the 1-norm in the plane:\n\njulia> B = Ball1(zeros(2), 1.0)\nBall1{Float64, Vector{Float64}}([0.0, 0.0], 1.0)\njulia> dim(B)\n2\n\nWe evaluate the support vector in the North direction:\n\njulia> σ([0.0, 1.0], B)\n2-element Vector{Float64}:\n 0.0\n 1.0\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Ball1/#Operations","page":"Ball1","title":"Operations","text":"","category":"section"},{"location":"lib/sets/Ball1/#LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}-lib-sets-Ball1","page":"Ball1","title":"LazySets.API.constraints_list","text":"constraints_list(X::LazySet)\n\nCompute a list of linear constraints of a polyhedral set.\n\nInput\n\nX – polyhedral set\n\nOutput\n\nA list of the linear constraints of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/#LazySets.API.constraints_list-Tuple{Ball1}","page":"Ball1","title":"LazySets.API.constraints_list","text":"Extended help\n\nconstraints_list(P::Ball1)\n\nNotes\n\nIn n dimensions there are 2^n constraints (unless the radius is 0).\n\nAlgorithm\n\nThe constraints can be defined as d_i^T (x-c)  r for all d_i, where d_i is a vector with elements 1 or -1 in n dimensions. To span all possible d_i, the function Iterators.product is used.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-Ball1","page":"Ball1","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/#Base.rand-Tuple{Type{Ball1}}","page":"Ball1","title":"Base.rand","text":"Extended help\n\nrand(::Type{Ball1}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the radius is nonnegative.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/#LazySets.API.reflect-Tuple{LazySets.API.LazySet}-lib-sets-Ball1","page":"Ball1","title":"LazySets.API.reflect","text":"reflect(X::LazySet)\n\nCompute the reflection of a set in the origin.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the reflection -X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/#LazySets.API.reflect-Tuple{Ball1}","page":"Ball1","title":"LazySets.API.reflect","text":"Extended help\n\nreflect(B::Ball1)\n\nAlgorithm\n\nIf B has center c and radius r, then -B has center -c and radius r.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/#LazySets.API.vertices_list-Tuple{LazySets.API.LazySet}-lib-sets-Ball1","page":"Ball1","title":"LazySets.API.vertices_list","text":"vertices_list(X::LazySet)\n\nCompute a list of vertices of a polytopic set.\n\nInput\n\nX – polytopic set\n\nOutput\n\nA list of the vertices of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/#LazySets.API.vertices_list-Tuple{Ball1}","page":"Ball1","title":"LazySets.API.vertices_list","text":"Extended help\n\nvertices_list(B::Ball1)\n\nNotes\n\nIn n dimensions there are 2n vertices (unless the radius is 0).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-Ball1","page":"Ball1","title":"Base.:∈","text":"∈(x::AbstractVector, X::LazySet)\n\nCheck whether a point lies in a set.\n\nInput\n\nx – point/vector\nX – set\n\nOutput\n\ntrue iff x  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/#Base.:∈","page":"Ball1","title":"Base.:∈","text":"Extended help\n\n∈(x::AbstractVector, B::Ball1, [failfast]::Bool=false)\n\nInput\n\nx – point/vector\nB – ball in the 1-norm\nfailfast – (optional, default: false) optimization for negative answer\n\nNotes\n\nThe default behavior (failfast == false) is worst-case optimized, i.e., the implementation is optimistic and first computes (see below) the whole sum before comparing to the radius. In applications where the point is typically far away from the ball, the option failfast == true terminates faster.\n\nAlgorithm\n\nLet B be an n-dimensional ball in the 1-norm with radius r and let c_i and x_i be the ball's center and the vector x in dimension i, respectively. Then x  B iff _i=1^n c_i - x_i  r.\n\nExamples\n\njulia> B = Ball1([1.0, 1.0], 1.0);\n\njulia> [0.5, -0.5] ∈ B\nfalse\njulia> [0.5, 1.5] ∈ B\ntrue\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/Ball1/#LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-Ball1","page":"Ball1","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, X::LazySet)\n\nEvaluate the support function of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nThe evaluation of the support function of X in direction d.\n\nNotes\n\nA convenience alias support_function is also available.\n\nWe have the following identity based on the support vector σ:\n\n    ρ(d X) = d  σ(d X)\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/#LazySets.API.ρ-Tuple{AbstractVector, Ball1}","page":"Ball1","title":"LazySets.API.ρ","text":"Extended help\n\nρ(d::AbstractVector, B::Ball1)\n\nAlgorithm\n\nLet c and r be the center and radius of the ball B in the 1-norm, respectively. Then:\n\nρ(d B) = d c + r d_\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/#LazySets.API.translate!-Tuple{LazySets.API.LazySet, AbstractVector}-lib-sets-Ball1","page":"Ball1","title":"LazySets.API.translate!","text":"translate!(X::LazySet, v::AbstractVector)\n\nTranslate a set with a vector by modifying it.\n\nInput\n\nX – set\nv – vector\n\nOutput\n\nThe translated set representing X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/#LazySets.API.translate!-Tuple{Ball1, AbstractVector}","page":"Ball1","title":"LazySets.API.translate!","text":"Extended help\n\ntranslate!(B::Ball1, v::AbstractVector)\n\nAlgorithm\n\nWe add the vector to the center of the ball.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"center\nhigh\nhigh\nisoperationtype\nlow\nlow\nproject\nscale\nσ\nminkowski_sum","category":"page"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"ball_norm\nradius_ball","category":"page"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nnorm\npolyhedron\nradius\nrationalize\nrectify\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\n[linear_map](@ref linear_map(::AbstractMatrix, ::LazySet)\nsample\ntranslate\ncartesian_product\nconvex_hull\n≈\n==\nisequivalent\n⊂\nminkowski_difference","category":"page"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"ispolyhedral\nintersection\nisdisjoint\n⊆","category":"page"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"isbounded\nisboundedtype\nisoperation\nvolume","category":"page"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"an_element\ncenter\ndim\nextrema\nextrema\nisempty\nisuniversal","category":"page"},{"location":"lib/approximations/underapproximate/","page":"Underapproximation","title":"Underapproximation","text":"Pages = [\"underapproximate.md\"]\nDepth = 3","category":"page"},{"location":"lib/approximations/underapproximate/#Underapproximation","page":"Underapproximation","title":"Underapproximation","text":"","category":"section"},{"location":"lib/approximations/underapproximate/#LazySets.Approximations.underapproximate","page":"Underapproximation","title":"LazySets.Approximations.underapproximate","text":"underapproximate(X::S, dirs::AbstractDirections;\n                [apply_convex_hull]::Bool=false) where {N, S<:LazySet{N}}\n\nCompute the underapproximation of a convex set by sampling support vectors.\n\nInput\n\nX                 – convex set\ndirs              – directions\napply_convex_hull – (optional, default: false) if true, post-process                        the support vectors with a convex hull operation\n\nOutput\n\nThe VPolytope obtained by taking the convex hull of support vectors of X along the directions determined by dirs.\n\nNotes\n\nSince the support vectors are not always unique, this algorithm may return a strict underapproximation even if the set can be exactly approximated using the given template.\n\n\n\n\n\nunderapproximate(X::LazySet, ::Type{<:Hyperrectangle};\n                 solver=nothing) where {N}\n\nUnderapproximate a convex polygon with a hyperrectangle of maximal area.\n\nInput\n\nX              – convex polygon\nHyperrectangle – type for dispatch\nsolver         – (optional; default: nothing) nonlinear solver; if                     nothing, default_nln_solver(N) will be used\n\nOutput\n\nA hyperrectangle underapproximation with maximal area.\n\nNotes\n\nThe implementation only works for 2D sets, but the algorithm can be generalized.\n\nDue to numerical issues, the result may be slightly outside the set.\n\nAlgorithm\n\nThe algorithm is taken from Behroozi [Beh19], Theorem 17 and solves a convex program (in fact a linear program with nonlinear objective). (The objective is modified to an equivalent version due to solver issues.)\n\n\n\n\n\nunderapproximate(X::LazySet, ::Type{<:Ball2})\n\nCompute the largest inscribed Euclidean ball in a set X.\n\nInput\n\nX     – set\nBall2 – target type\n\nOutput\n\nA largest Ball2 contained in X.\n\nAlgorithm\n\nWe use chebyshev_center_radius(X).\n\n\n\n\n\nunderapproximate(P::AbstractPolyhedron{N}, ::Type{Ellipsoid};\n                 backend=default_sdp_solver(),\n                 interior_point::AbstractVector{N}=chebyshev_center_radius(P)[1]\n                ) where {N<:Real}\n\nUnderapproximate a polyhedral set by the maximum-volume ellipsoid.\n\nInput\n\nP         – polyhedral set\nEllipsoid – type for dispatch\nbackend   – (optional, default: default_sdp_solver()) backend to solve                the semi-definite program\ninterior_point – (optional, default: chebyshev_center_radius(P)[1]) an                     interior point of the ellipsoid (needed for the algorithm:                     see below for details)\n\nOutput\n\nAn ellipsoid E such that E  P. E has maximal volume if P is bounded (no such guarantee is given in directions where P is unbounded).\n\nNotes\n\nThe maximum-volume ellipsoid is also called Löwner-John ellipsoid.\n\nThe algorithm requires to specify a point in the interior of the ellipsoid which can be specified with the argument interior_point. If no such point is known (i.e., interior_point == nothing), the implementation will compute the Chebyshev center (see chebyshev_center_radius).\n\nNote that the Chebyshev center will be computed using the default LP solver and not the passed SDP solver backend (because it is not guaranteed that backend supports LPs). If a custom LP solver should be used, the Chebyshev center needs to be computed and passed manually.\n\nAlgorithm\n\nWe use the package SetProg.jl to encode the problem directly.\n\nAn algorithm is described here.\n\n\n\n\n\n","category":"function"},{"location":"man/fast_2d_LPs/#Fast-2D-LPs","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"","category":"section"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"In this section we explain the implementation of the support vector for the case of convex polygons.","category":"page"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"Pages = [\"fast_2d_LPs.md\"]\nDepth = 3","category":"page"},{"location":"man/fast_2d_LPs/#Introduction","page":"Fast 2D LPs","title":"Introduction","text":"","category":"section"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"Since vectors in the plane can be ordered by the angle with respect to the positive real axis, we can efficiently evaluate the support vector of a polygon in constraint representation by comparing normal directions, provided that its edges are ordered.","category":"page"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"This is illustrated in the following picture.","category":"page"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"(Image: ../assets/intuition2dlp.png)","category":"page"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"If the normal directions of the polygon are ordered, the support vector in any direction always lies between two consecutive edges, a_i+1 preceq ell preceq a_i. Here we use the symbol preceq to compare directions, where the increasing direction is counter-clockwise.","category":"page"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"The following lemma provides an algorithm to find the support vector.","category":"page"},{"location":"man/fast_2d_LPs/#Lemma","page":"Fast 2D LPs","title":"Lemma","text":"","category":"section"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"Let mathcalX be a polygon described by m linear constraints a_i^T x leq b_i, ordered by the normal vectors (a_i), i.e., a_i preceq a_i+1 for all i  1m, where we identify a_m+1 with a_1. Let ell  ℝ^2  mathbf0_2. Then there exists i  1m such that a_i preceq ell preceq a_i+1 and every optimal solution barx of the linear program rho_mathcalX(ell) = max ell^T x  x  mathcalX satisfies barx  x  a_i^T x leq b_i  x  a_i+1^T x leq b_i+1","category":"page"},{"location":"man/fast_2d_LPs/#Algorithm","page":"Fast 2D LPs","title":"Algorithm","text":"","category":"section"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"First define a <= b as the comparison of directions using polar angles, with 0 being the direction (1, 0).","category":"page"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"Now assume that the constraints in a polytope mathcalX are given as a_i x + b_i.","category":"page"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"The following pseudocode explains how to find barx.","category":"page"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"σ(d, X):\n    let i be the smallest index such that a_{i-1} <= d and a_i > d\n    return the vertex at the intersection of constraints i and i-1","category":"page"},{"location":"lib/lazy_operations/AffineMap/#def_AffineMap","page":"AffineMap","title":"Affine map (AffineMap)","text":"","category":"section"},{"location":"lib/lazy_operations/AffineMap/#LazySets.AffineMap","page":"AffineMap","title":"LazySets.AffineMap","text":"AffineMap{N, S<:LazySet{N}, NM, MAT<:AbstractMatrix{NM},\n          VN<:AbstractVector{NM}} <: AbstractAffineMap{N, S}\n\nType that represents an affine transformation MX  v of a set X, i.e., the set\n\nY =  y  ℝ^n  y = Mx + vqquad x  X \n\nIf X is n-dimensional, then M should be an m  n matrix and v should be an m-dimensional vector.\n\nFields\n\nM – matrix\nX – set\nv – translation vector\n\nThe fields' getter functions are matrix, set and vector, respectively.\n\nNotes\n\nAn affine map is the composition of a linear map and a translation. This type is parametric in the coefficients of the linear map, NM, which may be different from the numeric type of the wrapped set, N. However, the numeric type of the translation vector should be NM.\n\nAn affine map preserves convexity: if X is convex, then any affine map of X is convex as well.\n\nExamples\n\nFor the examples we create a 32 matrix, a two-dimensional unit square, and a three-dimensional vector. Then we combine them in an AffineMap.\n\njulia> A = [1 2; 1 3; 1 4]; X = BallInf([0, 0], 1); b2 = [1, 2]; b3 = [1, 2, 3];\n\njulia> AffineMap(A, X, b3)\nAffineMap{Int64, BallInf{Int64, Vector{Int64}}, Int64, Matrix{Int64}, Vector{Int64}}([1 2; 1 3; 1 4], BallInf{Int64, Vector{Int64}}([0, 0], 1), [1, 2, 3])\n\nFor convenience, A does not need to be a matrix; we also allow to use UniformScalings resp. scalars (interpreted as a scaling, i.e., a scaled identity matrix). Scaling by 1 is ignored and simplified to a pure Translation.\n\njulia> using LinearAlgebra\n\njulia> am = AffineMap(2I, X, b2)\nAffineMap{Int64, BallInf{Int64, Vector{Int64}}, Int64, Diagonal{Int64, Vector{Int64}}, Vector{Int64}}([2 0; 0 2], BallInf{Int64, Vector{Int64}}([0, 0], 1), [1, 2])\n\njulia> AffineMap(2, X, b2) == am\ntrue\n\njulia> AffineMap(1, X, b2)\nTranslation{Int64, BallInf{Int64, Vector{Int64}}, Vector{Int64}}(BallInf{Int64, Vector{Int64}}([0, 0], 1), [1, 2])\n\nApplying a linear map to an AffineMap object combines the two maps into a new AffineMap instance. Again we can make use of the conversion for convenience.\n\njulia> B = [2 0; 0 2]; am2 = B * am\nAffineMap{Int64, BallInf{Int64, Vector{Int64}}, Int64, Matrix{Int64}, Vector{Int64}}([4 0; 0 4], BallInf{Int64, Vector{Int64}}([0, 0], 1), [2, 4])\n\njulia> 2 * am == am2\ntrue\n\nThe application of an AffineMap to a ZeroSet or an EmptySet is simplified automatically.\n\njulia> AffineMap(A, ZeroSet{Int}(2), b3)\nSingleton{Int64, Vector{Int64}}([1, 2, 3])\n\njulia> AffineMap(A, EmptySet{Int}(2), b3)\nEmptySet{Int64}(2)\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/AffineMap/","page":"AffineMap","title":"AffineMap","text":"Inherited from AbstractAffineMap:","category":"page"},{"location":"lib/lazy_operations/AffineMap/","page":"AffineMap","title":"AffineMap","text":"dim\nσ\nρ\nan_element\nisempty\nisbounded\n∈\nvertices_list\nconstraints_list\nlinear_map","category":"page"},{"location":"lib/lazy_operations/AffineMap/","page":"AffineMap","title":"AffineMap","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/AffineMap/","page":"AffineMap","title":"AffineMap","text":"singleton_list\nreflect","category":"page"},{"location":"lib/concrete_binary_operations/minkowski_difference/","page":"Minkowski Difference","title":"Minkowski Difference","text":"Pages = [\"minkowski_difference.md\"]\nDepth = 3","category":"page"},{"location":"lib/concrete_binary_operations/minkowski_difference/#Minkowski-Difference","page":"Minkowski Difference","title":"Minkowski Difference","text":"","category":"section"},{"location":"lib/concrete_binary_operations/minkowski_difference/#LazySets.API.minkowski_difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-concrete_binary_operations-minkowski_difference","page":"Minkowski Difference","title":"LazySets.API.minkowski_difference","text":"minkowski_difference(X::LazySet, Y::LazySet)\n\nCompute the Minkowski difference of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the Minkowski difference X  Y.\n\nNotes\n\nThe Minkowski difference of two sets X and Y is defined as\n\n    X  Y = z mid z  Y  X\n\nThe convenience alias pontryagin_difference is also available.\n\nThere is some inconsistency in the literature regarding the naming conventions. In this library, both Minkowski difference and Pontryagin difference refer to the geometric difference of two sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/minkowski_difference/","page":"Minkowski Difference","title":"Minkowski Difference","text":"Currently, there are no specialized docstrings for this function.","category":"page"},{"location":"lib/approximations/overview/","page":"Overview","title":"Overview","text":"Pages = [\"overview.md\"]\nDepth = 3","category":"page"},{"location":"lib/approximations/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"lib/approximations/overview/","page":"Overview","title":"Overview","text":"This section of the manual describes the Cartesian decomposition algorithms and the approximation of high-dimensional convex sets using projections.","category":"page"},{"location":"lib/approximations/overview/#LazySets.Approximations","page":"Overview","title":"LazySets.Approximations","text":"Module Approximations.jl – polygonal approximation of sets.\n\n\n\n\n\n","category":"module"},{"location":"man/reach_zonotopes_hybrid/#A-Hybrid-Reachability-Algorithm-Using-Zonotopes","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm Using Zonotopes","text":"","category":"section"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"Pages = [\"reach_zonotopes_hybrid.md\"]\nDepth = 3","category":"page"},{"location":"man/reach_zonotopes_hybrid/#Introduction","page":"A Hybrid Reachability Algorithm","title":"Introduction","text":"","category":"section"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"In this section we present an algorithm implemented using LazySets that computes the reach sets of a hybrid system of linear ordinary differential equations (ODE). This algorithm is an extension of the one presented in A Reachability Algorithm Using Zonotopes.","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"We consider a simple case here where modes do not have invariants and transitions do not have updates. In set-based analysis like ours, it may make sense to take a transition as soon as one state in the current set of states can take it. Note that this is not equivalent to must semantics of hybrid automata (also called urgent transitions), which is defined on single trajectories. We also offer the usual may transitions interpretation.","category":"page"},{"location":"man/reach_zonotopes_hybrid/#Hybrid-algorithm","page":"A Hybrid Reachability Algorithm","title":"Hybrid algorithm","text":"","category":"section"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"The hybrid algorithm maintains a queue of triples (m X t) where m is a mode, X is a set of states, and t is a time point. For each element in the queue the algorithm calls the Continuous algorithm to compute the reachable states in the current mode m, starting in the current states X at time t. The result is a flowpipe, i.e., a sequence of sets of states. For each of those sets we check intersection with the guards of m's outgoing transitions. Depending on the transition semantics, we add the discrete successors to the queue and continue with the next iteration until the queue is empty.","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"using Plots, LazySets, LinearAlgebra\n\nfunction reach_hybrid(As, Ts, init, δ, μ, T, max_order, instant_transitions)\n    # initialize queue with initial mode and states at time t=0\n    queue = Vector{Tuple{LazySet,Int,Float64}}(undef, 1)\n    queue[1] = (init[1], init[2], 0.0)\n\n    res = Tuple{LazySet, Int}[]\n    while !isempty(queue)\n        init, loc, t = pop!(queue)\n        println(\"currently in location $loc at time $t\")\n        R = reach_continuous(As[loc], init, δ, μ, T-t, max_order)\n        found_transition = false\n        for i in 1:(length(R)-1)\n            S = R[i]\n            push!(res, (S, loc))\n            for (guard, tgt_loc) in Ts[loc]\n                if !isdisjoint(S, guard)\n                    new_t = t + δ * i\n                    push!(queue, (S, tgt_loc, new_t))\n                    found_transition = true\n                    println(\"transition $loc -> $tgt_loc at time $new_t\")\n                end\n            end\n            if instant_transitions && found_transition\n                break\n            end\n        end\n        if !instant_transitions || !found_transition && length(R) > 0\n            push!(res, (R[end], loc))\n        end\n    end\n    return res\nend\nnothing # hide","category":"page"},{"location":"man/reach_zonotopes_hybrid/#Continuous-algorithm","page":"A Hybrid Reachability Algorithm","title":"Continuous algorithm","text":"","category":"section"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"This is basically the same implementation as outlined in the section A Reachability Algorithm Using Zonotopes, only that this time we use concrete operations on zonotopes.","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"function reach_continuous(A, X0, δ, μ, T, max_order)\n    # bloating factors\n    Anorm = norm(A, Inf)\n    α = (exp(δ*Anorm) - 1 - δ*Anorm)/norm(X0, Inf)\n    β = (exp(δ*Anorm) - 1)*μ/Anorm\n\n    # discretized system\n    n = size(A, 1)\n    ϕ = exp(δ*A)\n    N = floor(Int, T/δ)\n\n    # preallocate array\n    R = Vector{Zonotope}(undef, N)\n    if N == 0\n        return R\n    end\n\n    # initial reach set in the time interval [0, δ]\n    ϕp = (I+ϕ)/2\n    ϕm = (I-ϕ)/2\n    c = X0.center\n    gens = hcat(ϕp * X0.generators, ϕm * c, ϕm * X0.generators)\n    R[1] = minkowski_sum(Zonotope(ϕp * c, gens),\n                         Zonotope(zeros(n), Matrix((α + β)*I, n, n)))\n    if order(R[1]) > max_order\n        R[1] = reduce_order(R[1], max_order)\n    end\n\n    # set recurrence for [δ, 2δ], ..., [(N-1)δ, Nδ]\n    ballβ = Zonotope(zeros(n), Matrix(β*I, n, n))\n    for i in 2:N\n        R[i] = minkowski_sum(linear_map(ϕ, R[i-1]), ballβ)\n        if order(R[i]) > max_order\n            R[i] = reduce_order(R[i], max_order)\n        end\n    end\n    return R\nend\nnothing # hide","category":"page"},{"location":"man/reach_zonotopes_hybrid/#Plotting-results","page":"A Hybrid Reachability Algorithm","title":"Plotting results","text":"","category":"section"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"For illustration purposes it is helpful to plot the flowpipes in different colors, depending on the current mode. The following function does that for 2-mode models.","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"function plot_res(res)\n    p = plot()\n    for i in eachindex(res)\n        if res[i][2] == 1\n            c = \"blue\"\n        elseif res[i][2] == 2\n            c = \"red\"\n        end\n        plot!(p, reduce_order(res[i][1], 2), color=c, alpha=0.1)\n    end\n    return p\nend\nnothing # hide","category":"page"},{"location":"man/reach_zonotopes_hybrid/#Example","page":"A Hybrid Reachability Algorithm","title":"Example","text":"","category":"section"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"We consider an extension of the example presented by Girard [Gir05] to a hybrid system with two modes ell_i, i = 1 2, with initial states 09 11  -01 01 and uncertain inputs from a set u with mu =  u _ = 0001.","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"The dynamics matrices A_i are defined as follows:","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"\tA_1 = beginpmatrix -1  -4  4  -1 endpmatrix qquad A_2 = beginpmatrix 1  4  -4  -1 endpmatrix","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"We add a transition t_i from mode ell_i to ell_3-i with a hyperplane guard g_i:","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"\tg_1 triangleq x_1 = -05 qquad g_2 triangleq x_2 = -03","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"LazySets offers an order reduction function for zonotopes, which we used here with an upper bound of 10 generators. We plot the reachable states for the time interval 0 4 and time step δ = 001.","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"    # dynamics\n    A1 = [-1 -4; 4 -1]\n    A2 = [1 4; -4 -1]\n    As = [A1, A2]\n\n    # transitions\n    t1 = [(Hyperplane([1., 0.], -0.5), 2)]\n    t2 = [(Hyperplane([0., 1.], -0.3), 1)]\n    Ts = [t1, t2]\n\n    # initial condition\n    X0 = Zonotope([1.0, 0.0], Matrix(0.1*I, 2, 2))\n    init_loc = 1\n    init = (X0, init_loc)\n\n    # input uncertainty\n    μ = 0.001\n\n    # discretization step\n    δ = 0.01\n\n    # time bound\n    T = 4.\n\n    # maximum order of zonotopes\n    max_order = 10\n\n    # take transitions only the first time they are enabled?\n    instant_transitions = true\n\n    # run analysis\n    res = reach_hybrid(As, Ts, init, δ, μ, T, max_order, instant_transitions)\n\n    # plot result\n    plot_res(res)","category":"page"},{"location":"lib/concrete_binary_operations/issubset/","page":"Subset Check","title":"Subset Check","text":"Pages = [\"issubset.md\"]\nDepth = 3","category":"page"},{"location":"lib/concrete_binary_operations/issubset/#Subset-Check","page":"Subset Check","title":"Subset Check","text":"","category":"section"},{"location":"lib/concrete_binary_operations/issubset/","page":"Subset Check","title":"Subset Check","text":"The function ⊆ checks whether a set is a subset of another set. It can optionally produce a witness if the subset relation does not hold. The operator can be used in infix notation (X ⊆ Y).","category":"page"},{"location":"lib/concrete_binary_operations/issubset/","page":"Subset Check","title":"Subset Check","text":"note: Note\nissubset can be used as an alternative name to ⊆.","category":"page"},{"location":"lib/concrete_binary_operations/issubset/#Examples","page":"Subset Check","title":"Examples","text":"","category":"section"},{"location":"lib/concrete_binary_operations/issubset/","page":"Subset Check","title":"Subset Check","text":"We use the following four sets for illustration.","category":"page"},{"location":"lib/concrete_binary_operations/issubset/","page":"Subset Check","title":"Subset Check","text":"using LazySets, LazySets.Approximations, Plots\nB1 = Ball1(-ones(2), 1.)\nB2 = Ball2(ones(2), 1.)\nBI = BallInf(zeros(2), 1.)\nH = Hyperrectangle(ones(2), ones(2))\nsets = [B1, B2, BI, H]\n\nfunction plot_sets(sets)\n    for S in sets\n        println(S)\n        plot!(S, 1e-2, fillalpha=0.1)\n    end\nend\n\nfunction plot_points(points, prefix)\n    for i in eachindex(points)\n        p = points[i]\n        num_occur = length(findfirst(x -> x == p, points[1:i]))\n        x = p[1]\n        y = p[2]\n        if num_occur == 1\n            x += 0.15\n        elseif num_occur == 2\n            y += 0.15\n        elseif num_occur == 3\n            x -= 0.15\n        else\n            y -= 0.15\n        end\n        plot!(Singleton(p))\n        plot!(annotations=(x, y, text(\"$(prefix)$(i)\")))\n    end\nend\n\nplot1 = plot()\nplot_sets(sets)\nplot1","category":"page"},{"location":"lib/concrete_binary_operations/issubset/","page":"Subset Check","title":"Subset Check","text":"println(B1 ⊆ B2)\nw1 = ⊆(B1, B2, true)[2]\nprintln(B1 ⊆ BI)\nw2 = ⊆(B1, BI, true)[2]\nprintln(B1 ⊆ H)\nw3 = ⊆(B1, H, true)[2]\n# 'B2 ⊆ B1' is not supported yet\n# w11 = ⊆(B2, B1, true)[2]\nprintln(B2 ⊆ BI)\nw4 = ⊆(B2, BI, true)[2]\nprintln(B2 ⊆ H)\nprintln(BI ⊆ B1)\nw5 = ⊆(BI, B1, true)[2]\nprintln(BI ⊆ B2)\nw6 = ⊆(BI, B2, true)[2]\nprintln(BI ⊆ H)\nw7 = ⊆(BI, H, true)[2]\nprintln(H ⊆ B1)\nw8 = ⊆(H, B1, true)[2]\nprintln(H ⊆ B2)\nw9 = ⊆(H, B2, true)[2]\nprintln(H ⊆ BI)\nw10 = ⊆(H, BI, true)[2];","category":"page"},{"location":"lib/concrete_binary_operations/issubset/","page":"Subset Check","title":"Subset Check","text":"witnesses = [w1, w2, w3, w4, w5, w6, w7, w8, w9, w10]\n\nplot1 = plot()\nplot_sets(sets)\nplot_points(witnesses, \"w\")\nplot1","category":"page"},{"location":"lib/concrete_binary_operations/issubset/#Methods","page":"Subset Check","title":"Methods","text":"","category":"section"},{"location":"lib/concrete_binary_operations/issubset/#Base.:⊆-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-concrete_binary_operations-issubset","page":"Subset Check","title":"Base.:⊆","text":"⊆(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nCheck whether a set is a subset of another set, and optionally compute a witness.\n\nInput\n\nX       – set\nY       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X  Y\nIf the witness option is activated:\n(true, []) iff X  Y\n(false, v) iff X  Y for some v  X  Y\n\nNotes\n\nThe convenience alias issubset is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/issubset/#Base.:⊆","page":"Subset Check","title":"Base.:⊆","text":"Extended help\n\n⊆(S::LazySet, H::AbstractHyperrectangle, [witness]::Bool=false)\n\nAlgorithm\n\nS  H iff operatornameihull(S)  H, where  operatornameihull is the interval-hull operator.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/issubset/#Base.:⊆-2","page":"Subset Check","title":"Base.:⊆","text":"Extended help\n\n⊆(X::LazySet, Y::LazySet, witness::Bool=false)\n\nAlgorithm\n\nThe default implementation assumes that Y is polyhedral, i.e., that constraints_list(Y) is available, and checks inclusion of X in every constraint of Y.\n\n\n\n\n\nExtended help\n\n⊆(S::LazySet, H::AbstractHyperrectangle, [witness]::Bool=false)\n\nAlgorithm\n\nS  H iff operatornameihull(S)  H, where  operatornameihull is the interval-hull operator.\n\n\n\n\n\nExtended help\n\n⊆(P::AbstractPolytope, S::LazySet, [witness]::Bool=false;\n  [algorithm]=\"constraints\")\n\nInput\n\nalgorithm – (optional, default: \"constraints\") algorithm for the                inclusion check; available options are:\n\"constraints\", using the list of constraints of S (requires that S is polyhedral) and support-function evaluations of S\n\"vertices\", using the list of vertices of P and membership evaluations of S\n\nNotes\n\nS is assumed to be convex, which is asserted via isconvextype.\n\nAlgorithm\n\n\"vertices\":\n\nSince S is convex, P  S iff v  S for all vertices v of P.\n\n\n\n\n\n⊆(X::LazySet, P::AbstractPolyhedron, [witness]::Bool=false)\n\nCheck whether a convex set is contained in a polyhedral set, and if not, optionally compute a witness.\n\nInput\n\nX – inner convex set\nP – outer polyhedral set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff X  P\nIf witness option is activated:\n(true, []) iff X  P\n(false, v) iff X  P and v  P  X\n\nAlgorithm\n\nSince X is convex, we can compare the support function of X and P in each direction of the constraints of P.\n\nFor witness generation, we use a support vector in the first direction where the above check fails.\n\nSee Wetzlinger et al. [WKBA23], Proposition 7.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/issubset/#Base.:⊆-Tuple{AbstractZonotope, AbstractHyperrectangle}","page":"Subset Check","title":"Base.:⊆","text":"Extended help\n\n⊆(X::LazySet, Y::LazySet, witness::Bool=false)\n\nAlgorithm\n\nThe default implementation assumes that Y is polyhedral, i.e., that constraints_list(Y) is available, and checks inclusion of X in every constraint of Y.\n\n\n\n\n\nExtended help\n\n⊆(S::LazySet, H::AbstractHyperrectangle, [witness]::Bool=false)\n\nAlgorithm\n\nS  H iff operatornameihull(S)  H, where  operatornameihull is the interval-hull operator.\n\n\n\n\n\nExtended help\n\n⊆(P::AbstractPolytope, S::LazySet, [witness]::Bool=false;\n  [algorithm]=\"constraints\")\n\nInput\n\nalgorithm – (optional, default: \"constraints\") algorithm for the                inclusion check; available options are:\n\"constraints\", using the list of constraints of S (requires that S is polyhedral) and support-function evaluations of S\n\"vertices\", using the list of vertices of P and membership evaluations of S\n\nNotes\n\nS is assumed to be convex, which is asserted via isconvextype.\n\nAlgorithm\n\n\"vertices\":\n\nSince S is convex, P  S iff v  S for all vertices v of P.\n\n\n\n\n\n⊆(X::LazySet, P::AbstractPolyhedron, [witness]::Bool=false)\n\nCheck whether a convex set is contained in a polyhedral set, and if not, optionally compute a witness.\n\nInput\n\nX – inner convex set\nP – outer polyhedral set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff X  P\nIf witness option is activated:\n(true, []) iff X  P\n(false, v) iff X  P and v  P  X\n\nAlgorithm\n\nSince X is convex, we can compare the support function of X and P in each direction of the constraints of P.\n\nFor witness generation, we use a support vector in the first direction where the above check fails.\n\nSee Wetzlinger et al. [WKBA23], Proposition 7.\n\n\n\n\n\nExtended help\n\n⊆(Z::AbstractZonotope, H::AbstractHyperrectangle, [witness]::Bool=false)\n\nAlgorithm\n\nThe algorithm is based on Mitchell et al. [MBB19], Lemma 3.1.\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/issubset/#Base.:⊆-3","page":"Subset Check","title":"Base.:⊆","text":"⊆(X::LazySet, P::AbstractPolyhedron, [witness]::Bool=false)\n\nCheck whether a convex set is contained in a polyhedral set, and if not, optionally compute a witness.\n\nInput\n\nX – inner convex set\nP – outer polyhedral set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff X  P\nIf witness option is activated:\n(true, []) iff X  P\n(false, v) iff X  P and v  P  X\n\nAlgorithm\n\nSince X is convex, we can compare the support function of X and P in each direction of the constraints of P.\n\nFor witness generation, we use a support vector in the first direction where the above check fails.\n\nSee Wetzlinger et al. [WKBA23], Proposition 7.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/issubset/#Base.:⊆-4","page":"Subset Check","title":"Base.:⊆","text":"Extended help\n\n⊆(X::LazySet, Y::LazySet, witness::Bool=false)\n\nAlgorithm\n\nThe default implementation assumes that Y is polyhedral, i.e., that constraints_list(Y) is available, and checks inclusion of X in every constraint of Y.\n\n\n\n\n\nExtended help\n\n⊆(S::LazySet, H::AbstractHyperrectangle, [witness]::Bool=false)\n\nAlgorithm\n\nS  H iff operatornameihull(S)  H, where  operatornameihull is the interval-hull operator.\n\n\n\n\n\nExtended help\n\n⊆(H1::AbstractHyperrectangle, H2::AbstractHyperrectangle,\n  [witness]::Bool=false)\n\nAlgorithm\n\nH1  H2 iff c_1 + r_1  c_2 + r_2  c_1 - r_1  c_2 - r_2 iff r_1 - r_2  c_1 - c_2  -(r_1 - r_2), where  is taken component-wise.\n\n\n\n\n\nExtended help\n\n⊆(P::AbstractPolytope, S::LazySet, [witness]::Bool=false;\n  [algorithm]=\"constraints\")\n\nInput\n\nalgorithm – (optional, default: \"constraints\") algorithm for the                inclusion check; available options are:\n\"constraints\", using the list of constraints of S (requires that S is polyhedral) and support-function evaluations of S\n\"vertices\", using the list of vertices of P and membership evaluations of S\n\nNotes\n\nS is assumed to be convex, which is asserted via isconvextype.\n\nAlgorithm\n\n\"vertices\":\n\nSince S is convex, P  S iff v  S for all vertices v of P.\n\n\n\n\n\n⊆(X::LazySet, P::AbstractPolyhedron, [witness]::Bool=false)\n\nCheck whether a convex set is contained in a polyhedral set, and if not, optionally compute a witness.\n\nInput\n\nX – inner convex set\nP – outer polyhedral set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff X  P\nIf witness option is activated:\n(true, []) iff X  P\n(false, v) iff X  P and v  P  X\n\nAlgorithm\n\nSince X is convex, we can compare the support function of X and P in each direction of the constraints of P.\n\nFor witness generation, we use a support vector in the first direction where the above check fails.\n\nSee Wetzlinger et al. [WKBA23], Proposition 7.\n\n\n\n\n\nExtended help\n\n⊆(Z::AbstractZonotope, H::AbstractHyperrectangle, [witness]::Bool=false)\n\nAlgorithm\n\nThe algorithm is based on Mitchell et al. [MBB19], Lemma 3.1.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/issubset/#Base.:⊆-5","page":"Subset Check","title":"Base.:⊆","text":"Extended help\n\n⊆(L::LineSegment, S::LazySet, witness::Bool=false)\n\nAlgorithm\n\nSince S is convex, L  S iff p  S and q  S, where p q are the end points of L.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/issubset/#Base.:⊆-6","page":"Subset Check","title":"Base.:⊆","text":"Extended help\n\n⊆(X::LazySet, Y::LazySet, witness::Bool=false)\n\nAlgorithm\n\nThe default implementation assumes that Y is polyhedral, i.e., that constraints_list(Y) is available, and checks inclusion of X in every constraint of Y.\n\n\n\n\n\nExtended help\n\n⊆(S::LazySet, H::AbstractHyperrectangle, [witness]::Bool=false)\n\nAlgorithm\n\nS  H iff operatornameihull(S)  H, where  operatornameihull is the interval-hull operator.\n\n\n\n\n\nExtended help\n\n⊆(P::AbstractPolytope, S::LazySet, [witness]::Bool=false;\n  [algorithm]=\"constraints\")\n\nInput\n\nalgorithm – (optional, default: \"constraints\") algorithm for the                inclusion check; available options are:\n\"constraints\", using the list of constraints of S (requires that S is polyhedral) and support-function evaluations of S\n\"vertices\", using the list of vertices of P and membership evaluations of S\n\nNotes\n\nS is assumed to be convex, which is asserted via isconvextype.\n\nAlgorithm\n\n\"vertices\":\n\nSince S is convex, P  S iff v  S for all vertices v of P.\n\n\n\n\n\n⊆(X::LazySet, P::AbstractPolyhedron, [witness]::Bool=false)\n\nCheck whether a convex set is contained in a polyhedral set, and if not, optionally compute a witness.\n\nInput\n\nX – inner convex set\nP – outer polyhedral set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff X  P\nIf witness option is activated:\n(true, []) iff X  P\n(false, v) iff X  P and v  P  X\n\nAlgorithm\n\nSince X is convex, we can compare the support function of X and P in each direction of the constraints of P.\n\nFor witness generation, we use a support vector in the first direction where the above check fails.\n\nSee Wetzlinger et al. [WKBA23], Proposition 7.\n\n\n\n\n\nExtended help\n\n⊆(L::LineSegment, S::LazySet, witness::Bool=false)\n\nAlgorithm\n\nSince S is convex, L  S iff p  S and q  S, where p q are the end points of L.\n\n\n\n\n\nExtended help\n\n⊆(Z::AbstractZonotope, H::AbstractHyperrectangle, [witness]::Bool=false)\n\nAlgorithm\n\nThe algorithm is based on Mitchell et al. [MBB19], Lemma 3.1.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/issubset/#Base.:⊆-7","page":"Subset Check","title":"Base.:⊆","text":"⊆(X::Interval, U::UnionSet, [witness]::Bool=false)\n\nCheck whether an interval is contained in the union of two convex sets.\n\nInput\n\nX – inner interval\nU – outer union of two convex sets\n\nOutput\n\ntrue iff X ⊆ U.\n\nNotes\n\nThis implementation assumes that U is a union of one-dimensional convex sets. Since these are equivalent to intervals, we convert to Intervals.\n\nAlgorithm\n\nLet U = Y  Z where Y and Z are intervals and assume that the lower bound of Y is to the left of Z. If the lower bound of X is to the left of Y, we have a counterexample. Otherwise we compute the set difference W = X  Y and check whether W  Z holds.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/issubset/#Base.:⊆-8","page":"Subset Check","title":"Base.:⊆","text":"Extended help\n\n⊆(X::LazySet, ∅::EmptySet, [witness]::Bool=false)\n\nAlgorithm\n\nWe rely on isempty(X) for the emptiness check and on an_element(X) for witness production.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/issubset/#Base.:⊆-9","page":"Subset Check","title":"Base.:⊆","text":"Extended help\n\n⊆(U::UnionSet, X::LazySet, [witness]::Bool=false)\n\nNotes\n\nThis implementation assumes that the sets in the union U are convex.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/issubset/#Base.:⊆-10","page":"Subset Check","title":"Base.:⊆","text":"Extended help\n\n⊆(U::UnionSetArray, X::LazySet, [witness]::Bool=false)\n\nNotes\n\nThis implementation assumes that the sets in the union U are convex.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/issubset/#Base.:⊆-11","page":"Subset Check","title":"Base.:⊆","text":"Extended help\n\n⊆(U::Universe, X::LazySet, [witness]::Bool=false)\n\nAlgorithm\n\nWe fall back to isuniversal(X).\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/issubset/#Base.:⊆-12","page":"Subset Check","title":"Base.:⊆","text":"Extended help\n\n⊆(X::LazySet, C::Complement, [witness]::Bool=false)\n\nAlgorithm\n\nWe fall back to isdisjoint(X, C.X), which can be justified as follows.\n\n    X  Y^C  X  Y = \n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/issubset/#Base.:⊆-13","page":"Subset Check","title":"Base.:⊆","text":"Extended help\n\n⊆(X::CartesianProduct, Y::CartesianProduct, [witness]::Bool=false;\n  check_block_equality::Bool=true)\n\nInput\n\ncheck_block_equality – (optional, default: true) flag for checking that                           the block structure of the two sets is identical\n\nNotes\n\nThis algorithm requires that the two Cartesian products share the same block structure. If check_block_equality is activated, we check this property and, if it does not hold, we use a fallback implementation based on conversion to constraint representation (assuming that the sets are polyhedral).\n\nAlgorithm\n\nWe check inclusion for each block of the Cartesian products.\n\nFor witness production, we obtain a witness in one of the blocks. We then construct a high-dimensional witness by obtaining any point in the other blocks (using an_element) and concatenating these (lower-dimensional) points.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/issubset/#Base.:⊆-14","page":"Subset Check","title":"Base.:⊆","text":"Extended help\n\n⊆(X::CartesianProductArray, Y::CartesianProductArray, [witness]::Bool=false;\n  check_block_equality::Bool=true)\n\nInput\n\ncheck_block_equality – (optional, default: true) flag for checking that                            the block structure of the two sets is identical\n\nNotes\n\nThis algorithm requires that the two Cartesian products share the same block structure. If check_block_equality is activated, we check this property and, if it does not hold, we use a fallback implementation based on conversion to constraint representation (assuming that the sets are polyhedral).\n\nAlgorithm\n\nWe check inclusion for each block of the Cartesian products.\n\nFor witness production, we obtain a witness in one of the blocks. We then construct a high-dimensional witness by obtaining any point in the other blocks (using an_element) and concatenating these (lower-dimensional) points.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/issubset/#Base.:⊆-15","page":"Subset Check","title":"Base.:⊆","text":"Extended help\n\n⊆(Z::AbstractZonotope, H::AbstractHyperrectangle, [witness]::Bool=false)\n\nAlgorithm\n\nThe algorithm is based on Mitchell et al. [MBB19], Lemma 3.1.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/issubset/#Base.:⊆-16","page":"Subset Check","title":"Base.:⊆","text":"Extended help\n\n⊆(X::LazySet{N}, U::UnionSetArray, witness::Bool=false;\n  filter_redundant_sets::Bool=true) where {N}\n\nInput\n\nfilter_redundant_sets – (optional, default: true) ignore sets in U that              do not intersect with X\n\nAlgorithm\n\nThis implementation is general and successively removes parts from X that are covered by the sets in the union U using the difference function. For the resulting subsets, this implementation relies on the methods isdisjoint, ⊆, and intersection.\n\nAs a preprocessing, this implementation checks if X is contained in any of the sets in U.\n\nThe filter_redundant_sets option controls whether sets in U that do not intersect with X should be ignored.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/issubset/#Strict-subset-check","page":"Subset Check","title":"Strict subset check","text":"","category":"section"},{"location":"lib/concrete_binary_operations/issubset/#LazySets.API.:⊂-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-concrete_binary_operations-issubset","page":"Subset Check","title":"LazySets.API.:⊂","text":"⊂(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nCheck whether a set is a strict subset of another set, and optionally compute a witness.\n\nInput\n\nX       – set\nY       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X  Y\nIf the witness option is activated:\n(true, v) iff X  Y for some v  Y  X\n(false, []) iff X  Y does not hold\n\nNotes\n\nStrict inclusion is sometimes written as ⊊. The following identity holds:\n\n    X  Y  X  Y  Y  X\n\nAlgorithm\n\nThe default implementation first checks inclusion of X in Y and then checks noninclusion of Y in X:\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/issubset/#LazySets.API.:⊂-Tuple{LazySet, LazySet}","page":"Subset Check","title":"LazySets.API.:⊂","text":"Extended help\n\n⊂(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nAlgorithm\n\nThe default implementation first checks inclusion of X in Y and then checks noninclusion of Y in X:\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractBallp/","page":"Balls in the p-norm (AbstractBallp)","title":"Balls in the p-norm (AbstractBallp)","text":"Pages = [\"AbstractBallp.md\"]\nDepth = 3","category":"page"},{"location":"lib/interfaces/AbstractBallp/#def_AbstractBallp","page":"Balls in the p-norm (AbstractBallp)","title":"Balls in the p-norm (AbstractBallp)","text":"","category":"section"},{"location":"lib/interfaces/AbstractBallp/","page":"Balls in the p-norm (AbstractBallp)","title":"Balls in the p-norm (AbstractBallp)","text":"A ball is a centrally-symmetric set with a characteristic p-norm.","category":"page"},{"location":"lib/interfaces/AbstractBallp/#LazySets.AbstractBallp","page":"Balls in the p-norm (AbstractBallp)","title":"LazySets.AbstractBallp","text":"AbstractBallp{N} <: AbstractCentrallySymmetric{N}\n\nAbstract type for p-norm balls.\n\nNotes\n\nSee Ballp for a standard implementation of this interface.\n\nEvery concrete AbstractBallp must define the following methods:\n\nball_norm(::AbstractBallp) – return the characteristic norm\nradius_ball(::AbstractBallp) – return the ball radius\n\nThe subtypes of AbstractBallp:\n\njulia> subtypes(AbstractBallp)\n2-element Vector{Any}:\n Ball2\n Ballp\n\nThere are two further set types implementing the AbstractBallp interface, but they also implement other interfaces and hence cannot be subtypes: Ball1 and BallInf.\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/AbstractBallp/","page":"Balls in the p-norm (AbstractBallp)","title":"Balls in the p-norm (AbstractBallp)","text":"This interface requires to implement the following functions:","category":"page"},{"location":"lib/interfaces/AbstractBallp/#LazySets.ball_norm-Tuple{AbstractBallp}","page":"Balls in the p-norm (AbstractBallp)","title":"LazySets.ball_norm","text":"ball_norm(B::AbstractBallp)\n\nDetermine the norm (p) of a p-norm ball.\n\nInput\n\nB – p-norm ball\n\nOutput\n\nA number representing the norm.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractBallp/#LazySets.radius_ball-Tuple{AbstractBallp}","page":"Balls in the p-norm (AbstractBallp)","title":"LazySets.radius_ball","text":"radius_ball(B::AbstractBallp)\n\nCompute the radius of a p-norm ball.\n\nInput\n\nB – p-norm ball\n\nOutput\n\nA number representing the radius.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractBallp/","page":"Balls in the p-norm (AbstractBallp)","title":"Balls in the p-norm (AbstractBallp)","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/AbstractBallp/#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractBallp","page":"Balls in the p-norm (AbstractBallp)","title":"Base.:∈","text":"∈(x::AbstractVector, X::LazySet)\n\nCheck whether a point lies in a set.\n\nInput\n\nx – point/vector\nX – set\n\nOutput\n\ntrue iff x  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractBallp/#Base.:∈-Tuple{AbstractVector, AbstractBallp}","page":"Balls in the p-norm (AbstractBallp)","title":"Base.:∈","text":"Extended help\n\n∈(x::AbstractVector, B::AbstractBallp)\n\nNotes\n\nThis implementation is worst-case optimized, i.e., it is optimistic and first computes (see below) the whole sum before comparing to the radius. In applications where the point is typically far away from the ball, a fail-fast implementation with interleaved comparisons could be more efficient.\n\nAlgorithm\n\nLet B be an n-dimensional ball in the p-norm with radius r and let c_i and x_i be the ball's center and the vector x in dimension i, respectively. Then x  B iff left( _i=1^n c_i - x_i^p right)^1p  r.\n\nExamples\n\njulia> B = Ballp(1.5, [1.0, 1.0], 1.)\nBallp{Float64, Vector{Float64}}(1.5, [1.0, 1.0], 1.0)\n\njulia> [0.5, -0.5] ∈ B\nfalse\n\njulia> [0.5, 1.5] ∈ B\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractBallp/#LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractBallp","page":"Balls in the p-norm (AbstractBallp)","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, X::LazySet)\n\nEvaluate the support function of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nThe evaluation of the support function of X in direction d.\n\nNotes\n\nA convenience alias support_function is also available.\n\nWe have the following identity based on the support vector σ:\n\n    ρ(d X) = d  σ(d X)\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractBallp/#LazySets.API.ρ-Tuple{AbstractVector, AbstractBallp}","page":"Balls in the p-norm (AbstractBallp)","title":"LazySets.API.ρ","text":"Extended help\n\nρ(d::AbstractVector, B::AbstractBallp)\n\nAlgorithm\n\nLet c and r be the center and radius of the ball B in the p-norm, respectively, and let q = fracpp-1. Then:\n\nρ(d B) = d c + r d_q\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractBallp/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractBallp","page":"Balls in the p-norm (AbstractBallp)","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractBallp/#LazySets.API.σ-Tuple{AbstractVector, AbstractBallp}","page":"Balls in the p-norm (AbstractBallp)","title":"LazySets.API.σ","text":"Extended help\n\nσ(d::AbstractVector, B::AbstractBallp)\n\nAlgorithm\n\nThe support vector of the unit ball in the p-norm along direction d is:\n\nσ(d mathcalB_p^n(0 1)) = dfractildevtildev_q\n\nwhere tildev_i = fracd_i^qd_i if d_i  0 and tildev_i = 0 otherwise, for all i=1n, and q is the conjugate number of p. By the affine transformation x = rtildex + c, one obtains that the support vector of mathcalB_p^n(c r) is\n\nσ(d mathcalB_p^n(c r)) = dfracvv_q\n\nwhere v_i = c_i + rfracd_i^qd_i if d_i  0 and v_i = 0 otherwise, for all i = 1  n.\n\nIf the direction has norm zero, the center of the ball is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractBallp/","page":"Balls in the p-norm (AbstractBallp)","title":"Balls in the p-norm (AbstractBallp)","text":"Undocumented implementations:","category":"page"},{"location":"lib/interfaces/AbstractBallp/","page":"Balls in the p-norm (AbstractBallp)","title":"Balls in the p-norm (AbstractBallp)","text":"high\nhigh\nlow\nlow\nvolume","category":"page"},{"location":"lib/interfaces/AbstractBallp/","page":"Balls in the p-norm (AbstractBallp)","title":"Balls in the p-norm (AbstractBallp)","text":"Inherited from LazySet:","category":"page"},{"location":"lib/interfaces/AbstractBallp/","page":"Balls in the p-norm (AbstractBallp)","title":"Balls in the p-norm (AbstractBallp)","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisoperation\nispolyhedral\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nlinear_map\nproject\nsample\nscale\ntranslate\ncartesian_product\nconvex_hull\nexact_sum\n≈\nisdisjoint\n==\nisequivalent\n⊂\n⊆\nminkowski_difference\nminkowski_sum","category":"page"},{"location":"lib/interfaces/AbstractBallp/","page":"Balls in the p-norm (AbstractBallp)","title":"Balls in the p-norm (AbstractBallp)","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/interfaces/AbstractBallp/","page":"Balls in the p-norm (AbstractBallp)","title":"Balls in the p-norm (AbstractBallp)","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/interfaces/AbstractBallp/","page":"Balls in the p-norm (AbstractBallp)","title":"Balls in the p-norm (AbstractBallp)","text":"Inherited from AbstractCentrallySymmetric:","category":"page"},{"location":"lib/interfaces/AbstractBallp/","page":"Balls in the p-norm (AbstractBallp)","title":"Balls in the p-norm (AbstractBallp)","text":"an_element\ncenter\ncenter\ndim\nextrema\nextrema\nisbounded\nisboundedtype\nisempty\nisuniversal","category":"page"},{"location":"lib/interfaces/AbstractBallp/#Implementations","page":"Balls in the p-norm (AbstractBallp)","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/AbstractBallp/","page":"Balls in the p-norm (AbstractBallp)","title":"Balls in the p-norm (AbstractBallp)","text":"Ball1\nBall2\nBallInf\nBallp","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"Pages = [\"AbstractHyperrectangle.md\"]\nDepth = 3","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/#def_AbstractHyperrectangle","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"","category":"section"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"A hyperrectangle is a special centrally symmetric polytope with axis-aligned facets.","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.AbstractHyperrectangle","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.AbstractHyperrectangle","text":"AbstractHyperrectangle{N} <: AbstractZonotope{N}\n\nAbstract type for hyperrectangular sets.\n\nNotes\n\nSee Hyperrectangle for a standard implementation of this interface.\n\nEvery concrete AbstractHyperrectangle must define the following functions:\n\nradius_hyperrectangle(::AbstractHyperrectangle) – return the   hyperrectangle's radius, which is a full-dimensional vector\n\nAmong other functions, the following functions are then automatically defined:\n\nisflat(::AbstractHyperrectangle) – check whether the hyperrectangle's   radius is zero in some dimension\nradius_hyperrectangle(::AbstractHyperrectangle, i::Int) – return the   hyperrectangle's radius in the i-th dimension\n\nEvery hyperrectangular set is also a zonotopic set; see AbstractZonotope.\n\nThe subtypes of AbstractHyperrectangle (including abstract interfaces):\n\njulia> subtypes(AbstractHyperrectangle)\n5-element Vector{Any}:\n AbstractSingleton\n BallInf\n Hyperrectangle\n Interval\n SymmetricIntervalHull\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"This interface requires to implement the following function:","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.radius_hyperrectangle-Tuple{AbstractHyperrectangle}","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(H::AbstractHyperrectangle)\n\nReturn the hyperrectangle radius of a hyperrectangular set.\n\nInput\n\nH – hyperrectangular set\n\nOutput\n\nThe hyperrectangle radius of H, which is a full-dimensional vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractHyperrectangle","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.constraints_list","text":"constraints_list(X::LazySet)\n\nCompute a list of linear constraints of a polyhedral set.\n\nInput\n\nX – polyhedral set\n\nOutput\n\nA list of the linear constraints of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.constraints_list-Tuple{AbstractHyperrectangle}","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.constraints_list","text":"Extended help\n\nconstraints_list(H::AbstractHyperrectangle)\n\nOutput\n\nA list of 2n linear constraints, where n is the dimension of H.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.isflat-Tuple{AbstractHyperrectangle}","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.isflat","text":"isflat(H::AbstractHyperrectangle)\n\nCheck whether a hyperrectangular set is flat, i.e., whether its radius is zero in some dimension.\n\nInput\n\nH – hyperrectangular set\n\nOutput\n\ntrue iff the hyperrectangular set is flat.\n\nNotes\n\nFor robustness with respect to floating-point inputs, this function relies on the result of isapproxzero when applied to the radius in some dimension. Hence this function depends on the absolute zero tolerance ABSZTOL.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.ngens-Tuple{AbstractZonotope}-lib-interfaces-AbstractHyperrectangle","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.ngens","text":"ngens(Z::AbstractZonotope)\n\nReturn the number of generators of a zonotopic set.\n\nInput\n\nZ – zonotopic set\n\nOutput\n\nAn integer representing the number of generators.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.ngens-Tuple{AbstractHyperrectangle}","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.ngens","text":"Extended help\n\nngens(H::AbstractHyperrectangle)\n\nAlgorithm\n\nA hyperrectangular set has one generator for each non-flat dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LinearAlgebra.norm-lib-interfaces-AbstractHyperrectangle","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LinearAlgebra.norm","text":"norm(X::LazySet, [p]::Real=Inf)\n\nReturn the norm of a set.\n\nInput\n\nX – set\np – (optional, default: Inf) norm\n\nOutput\n\nA real number representing the norm.\n\nNotes\n\nThe norm of a set is the norm of the enclosing ball (of the given p-norm) of minimal volume that is centered in the origin.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractHyperrectangle/#LinearAlgebra.norm","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LinearAlgebra.norm","text":"Extended help\n\nnorm(H::AbstractHyperrectangle, [p]::Real=Inf)\n\nAlgorithm\n\nRecall that the norm is defined as\n\n X  = max_x  X  x _p = max_x  textvertices(X)  x _p\n\nThe last equality holds because the optimum of a convex function over a polytope is attained at one of its vertices.\n\nThis implementation uses the fact that the maximum is attained in the vertex c + textdiag(textsign(c)) r for any p-norm. Hence it suffices to take the p-norm of this particular vertex. This statement is proved below. Note that, in particular, there is no need to compute the p-norm for each vertex, which can be very expensive.\n\nIf X is a hyperrectangle and the n-dimensional vectors center and radius of the hyperrectangle are denoted c and r respectively, then reasoning on the 2^n vertices we have that:\n\nmax_x  textvertices(X)  x _p = max_α_1  α_n  -1 1 (c_1 + α_1 r_1^p +  + c_n + α_n r_n^p)^1p\n\nThe function x  x^p, p  0, is monotonically increasing and thus the maximum of each term c_i + α_i r_i^p is given by c_i + textsign(c_i) r_i^p for each i. Hence, x^* = textargmax_x  X  x _p is the vertex c + textdiag(textsign(c)) r.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.radius-lib-interfaces-AbstractHyperrectangle","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.radius","text":"radius(X::LazySet, [p]::Real=Inf)\n\nReturn the radius of a set.\n\nInput\n\nX – set\np – (optional, default: Inf) norm\n\nOutput\n\nA real number representing the radius.\n\nNotes\n\nThe radius of a set is the radius of the enclosing ball (of the given p-norm) of minimal volume.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.radius","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.radius","text":"Extended help\n\nradius(H::AbstractHyperrectangle, [p]::Real=Inf)\n\nNotes\n\nThe result is defined as the radius of the enclosing ball of the given p-norm of minimal volume with the same center. It is the same for all corners of a hyperrectangular set.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.radius_hyperrectangle-Tuple{AbstractHyperrectangle, Int64}","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(H::AbstractHyperrectangle, i::Int)\n\nReturn the hyperrectangle radius of a hyperrectangular set in a given dimension.\n\nInput\n\nH – hyperrectangular set\ni – dimension\n\nOutput\n\nThe hyperrectangle radius of H in dimension i.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#ReachabilityBase.Arrays.rectify-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractHyperrectangle","page":"Hyperrectangles (AbstractHyperrectangle)","title":"ReachabilityBase.Arrays.rectify","text":"rectify(X::LazySet)\n\nCompute the rectification of a set.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the rectification of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#ReachabilityBase.Arrays.rectify-Tuple{AbstractHyperrectangle}","page":"Hyperrectangles (AbstractHyperrectangle)","title":"ReachabilityBase.Arrays.rectify","text":"Extended help\n\nrectify(H::AbstractHyperrectangle)\n\nOutput\n\nA Hyperrectangle.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.reflect-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractHyperrectangle","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.reflect","text":"reflect(X::LazySet)\n\nCompute the reflection of a set in the origin.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the reflection -X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.reflect-Tuple{AbstractHyperrectangle}","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.reflect","text":"Extended help\n\nreflect(H::AbstractHyperrectangle)\n\nOutput\n\nA Hyperrectangle.\n\nAlgorithm\n\nIf H has center c and radius r, then -H has center -c and radius r.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.vertices_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractHyperrectangle","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.vertices_list","text":"vertices_list(X::LazySet)\n\nCompute a list of vertices of a polytopic set.\n\nInput\n\nX – polytopic set\n\nOutput\n\nA list of the vertices of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.vertices_list-Tuple{AbstractHyperrectangle}","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.vertices_list","text":"Extended help\n\nvertices_list(H::AbstractHyperrectangle; kwargs...)\n\nNotes\n\nZeros in the radius are correctly handled, i.e., the result does not contain any duplicate vertices.\n\nAlgorithm\n\nFirst we identify the dimensions where H is flat, i.e., its radius is zero. We also compute the number of vertices that we have to create.\n\nNext we create the vertices. We do this by enumerating all vectors v of length n (the dimension of H) with entries -1/0/1 and construct the corresponding vertex as follows:\n\n    textvertex(v)(i) = begincases c(i) + r(i)  v(i) = 1 \n                                          c(i)  v(i) = 0 \n                                          c(i) - r(i)  v(i) = -1 endcases\n\nFor enumerating the vectors v, we modify the current v from left to right by changing entries -1 to 1, skipping entries 0, and stopping at the first entry 1 (but changing it to -1). This way we only need to change the vertex in those dimensions where v has changed, which usually is a smaller number than n.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.volume-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractHyperrectangle","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.volume","text":"volume(X::LazySet)\n\nCompute the volume, or Lebesgue measure, of a set.\n\nInput\n\nX – set\n\nOutput\n\nA real number representing the Lebesgue measure of X.\n\nNotes\n\nThe Lebesgue measure has the following common special cases:\n\nIn 1D, it coincides with the length.\nIn 2D, it coincides with the area (see also area).\nIn 3D, it coincides with the volume.\n\nIn higher dimensions, it is also known as the hypervolume or simply volume.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.volume-Tuple{AbstractHyperrectangle}","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.volume","text":"Extended help\n\nvolume(H::AbstractHyperrectangle)\n\nAlgorithm\n\nThe volume of the n-dimensional hyperrectangle H with radius vector r is 2ⁿ ᵢ rᵢ where rᵢ denotes the i-th component of r.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractHyperrectangle","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Base.:∈","text":"∈(x::AbstractVector, X::LazySet)\n\nCheck whether a point lies in a set.\n\nInput\n\nx – point/vector\nX – set\n\nOutput\n\ntrue iff x  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#Base.:∈-Tuple{AbstractVector, AbstractHyperrectangle}","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Base.:∈","text":"Extended help\n\n∈(x::AbstractVector, H::AbstractHyperrectangle)\n\nAlgorithm\n\nLet H be an n-dimensional hyperrectangular set, c_i and r_i be the center and radius, and x_i be the vector x in dimension i, respectively. Then x  H iff c_i - x_i  r_i for all i=1n.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#Base.split-Tuple{AbstractHyperrectangle, AbstractVector{Int64}}","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Base.split","text":"split(H::AbstractHyperrectangle, num_blocks::AbstractVector{Int})\n\nPartition a hyperrectangular set into uniform sub-hyperrectangles.\n\nInput\n\nH          – hyperrectangular set\nnum_blocks – number of blocks in the partition for each dimension\n\nOutput\n\nA list of Hyperrectangles.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractHyperrectangle","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.σ-Tuple{AbstractVector, AbstractHyperrectangle}","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.σ","text":"Extended help\n\nσ(d::AbstractVector, H::AbstractHyperrectangle)\n\nNotes\n\nIf the direction vector is zero in dimension i, the result will have the center's coordinate in that dimension. For instance, for the two-dimensional infinity-norm ball, if the direction points to the right, the result is the vector [1, 0] in the middle of the right-hand facet.\n\nIf the direction has norm zero, the result can be any point in H. The default implementation returns the center of H.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-AbstractHyperrectangle","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.difference","text":"difference(X::LazySet, Y::LazySet)\n\nCompute the set difference of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the difference X  Y.\n\nNotes\n\nThe set difference is defined as:\n\n    X  Y = x mid x  X text and  x  Y \n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.difference-Tuple{AbstractHyperrectangle, AbstractHyperrectangle}","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.difference","text":"Extended help\n\ndifference(X::AbstractHyperrectangle, Y::AbstractHyperrectangle)\n\nOutput\n\nA UnionSetArray consisting of the union of hyperrectangles. Note that this union is in general not convex.\n\nAlgorithm\n\nThis implementation uses IntervalArithmetic.setdiff.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.intersection-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-AbstractHyperrectangle","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.intersection","text":"intersection(X::LazySet, Y::LazySet)\n\nCompute the intersection of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the intersection X  Y.\n\nNotes\n\nThe intersection of two sets X and Y is defined as\n\n    X  Y = x mid x  X text and  x  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.intersection-Tuple{AbstractHyperrectangle, AbstractHyperrectangle}","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.intersection","text":"intersection(H1::AbstractHyperrectangle, H2::AbstractHyperrectangle)\n\nCompute the intersection of two hyperrectangular sets.\n\nInput\n\nH1 – hyperrectangular set\nH2 – hyperrectangular set\n\nOutput\n\nIf the hyperrectangular sets do not intersect, the result is the empty set. Otherwise the result is the hyperrectangle that describes the intersection.\n\nAlgorithm\n\nIn each isolated direction i we compute the rightmost left border and the leftmost right border of the hyperrectangular sets. If these borders contradict, then the intersection is empty. Otherwise the resulting hyperrectangle uses these borders in each dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#Base.isdisjoint-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-AbstractHyperrectangle","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Base.isdisjoint","text":"isdisjoint(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nCheck whether two sets are disjoint (i.e., do not intersect), and optionally compute a witness.\n\nInput\n\nX       – set\nY       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X  Y = \nIf the witness option is activated:\n(true, []) iff X  Y = \n(false, v) iff X  Y   for some v  X  Y\n\nNotes\n\nThe convenience alias is_intersection_empty is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#Base.isdisjoint","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Base.isdisjoint","text":"Extended help\n\nisdisjoint(H1::AbstractHyperrectangle, H2::AbstractHyperrectangle,\n           [witness]::Bool=false)\n\nAlgorithm\n\nH1  H2   iff c_2 - c_1  r_1 + r_2, where  is taken component-wise.\n\nA witness is computed by starting in one center and moving toward the other center for as long as the minimum of the radius and the center distance. In other words, the witness is the point in H1 that is closest to the center of H2.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractHyperrectangle/#Base.:⊆-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-AbstractHyperrectangle","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Base.:⊆","text":"⊆(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nCheck whether a set is a subset of another set, and optionally compute a witness.\n\nInput\n\nX       – set\nY       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X  Y\nIf the witness option is activated:\n(true, []) iff X  Y\n(false, v) iff X  Y for some v  X  Y\n\nNotes\n\nThe convenience alias issubset is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#Base.:⊆","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Base.:⊆","text":"Extended help\n\n⊆(H1::AbstractHyperrectangle, H2::AbstractHyperrectangle,\n  [witness]::Bool=false)\n\nAlgorithm\n\nH1  H2 iff c_1 + r_1  c_2 + r_2  c_1 - r_1  c_2 - r_2 iff r_1 - r_2  c_1 - c_2  -(r_1 - r_2), where  is taken component-wise.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.minkowski_difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-AbstractHyperrectangle","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.minkowski_difference","text":"minkowski_difference(X::LazySet, Y::LazySet)\n\nCompute the Minkowski difference of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the Minkowski difference X  Y.\n\nNotes\n\nThe Minkowski difference of two sets X and Y is defined as\n\n    X  Y = z mid z  Y  X\n\nThe convenience alias pontryagin_difference is also available.\n\nThere is some inconsistency in the literature regarding the naming conventions. In this library, both Minkowski difference and Pontryagin difference refer to the geometric difference of two sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.minkowski_difference-Tuple{AbstractHyperrectangle, AbstractHyperrectangle}","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.minkowski_difference","text":"Extended help\n\nminkowski_difference(H1::AbstractHyperrectangle, H2::AbstractHyperrectangle)\n\nOutput\n\nA Hyperrectangle, or an EmptySet if the difference is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.minkowski_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-AbstractHyperrectangle","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.minkowski_sum","text":"minkowski_sum(X::LazySet, Y::LazySet)\n\nCompute the Minkowski sum of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the Minkowski sum X  Y.\n\nNotes\n\nThe Minkowski sum of two sets X and Y is defined as\n\n    X  Y = x + y mid x  X y  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.API.minkowski_sum-Tuple{AbstractHyperrectangle, AbstractHyperrectangle}","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.API.minkowski_sum","text":"Extended help\n\nminkowski_sum(H1::AbstractHyperrectangle, H2::AbstractHyperrectangle)\n\nAlgorithm\n\nThe resulting hyperrectangle is obtained by summing up the centers and radii.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"Undocumented implementations:","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"area\nextrema\nextrema","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"generators\ngenmat","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"high\nhigh\nlow\nlow\ndistance\nproject\nρ\ncartesian_product\ndistance","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"Inherited from LazySet:","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"chebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisoperation\npolyhedron\nrationalize\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nsample\nscale\ntranslate\nconvex_hull\nexact_sum\n≈\n==\nisequivalent\n⊂","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"ispolyhedral","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"isbounded\nisboundedtype","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"an_element\ncenter\ndim\nisempty\nisuniversal","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"order\nremove_redundant_generators\ntogrep\nlinear_map\nreduce_order\nsplit\nsplit","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/#Convenience-functions","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Convenience functions","text":"","category":"section"},{"location":"lib/interfaces/AbstractHyperrectangle/#LazySets.□-Tuple{Any, Any}","page":"Hyperrectangles (AbstractHyperrectangle)","title":"LazySets.□","text":"□(c, r)\n\nConvenience constructor of Hyperrectangles or BallInfs depending on the type of r.\n\nInput\n\nc – center\nr – radius (either a vector for Hyperrectangle or a number for BallInf)\n\nOutput\n\nA Hyperrectangles or BallInfs depending on the type of r.\n\nNotes\n\nThe function symbol can be typed via \\square<tab>.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractHyperrectangle/#Implementations","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"Concrete set representations:","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"Hyperrectangle\nInfinity-norm ball (BallInf)\nInterval","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"Lazy set operations:","category":"page"},{"location":"lib/interfaces/AbstractHyperrectangle/","page":"Hyperrectangles (AbstractHyperrectangle)","title":"Hyperrectangles (AbstractHyperrectangle)","text":"Symmetric interval hull (SymmetricIntervalHull)","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetric/","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"Centrally symmetric sets (AbstractCentrallySymmetric)","text":"Pages = [\"AbstractCentrallySymmetric.md\"]\nDepth = 3","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetric/#def_AbstractCentrallySymmetric","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"Centrally symmetric sets (AbstractCentrallySymmetric)","text":"","category":"section"},{"location":"lib/interfaces/AbstractCentrallySymmetric/","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"Centrally symmetric sets (AbstractCentrallySymmetric)","text":"Centrally symmetric convex sets such as balls of different norms are characterized by a center. Note that there is a special interface combination Centrally symmetric polytope.","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetric/#LazySets.AbstractCentrallySymmetric","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"LazySets.AbstractCentrallySymmetric","text":"AbstractCentrallySymmetric{N} <: ConvexSet{N}\n\nAbstract type for centrally symmetric compact convex sets.\n\nNotes\n\nEvery concrete AbstractCentrallySymmetric must define the following function:\n\ncenter(::AbstractCentrallySymmetric) – return the center point\n\nThe subtypes of AbstractCentrallySymmetric:\n\njulia> subtypes(AbstractCentrallySymmetric)\n2-element Vector{Any}:\n AbstractBallp\n Ellipsoid\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/AbstractCentrallySymmetric/","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"Centrally symmetric sets (AbstractCentrallySymmetric)","text":"This interface requires to implement the following function:","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetric/#LazySets.API.center-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractCentrallySymmetric","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"LazySets.API.center","text":"center(X::LazySet)\n\nCompute the center of a centrally symmetric set.\n\nInput\n\nX – centrally symmetric set\n\nOutput\n\nA vector with the center, or midpoint, of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractCentrallySymmetric/","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"Centrally symmetric sets (AbstractCentrallySymmetric)","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetric/#LazySets.API.an_element-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractCentrallySymmetric","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"LazySets.API.an_element","text":"an_element(X::LazySet)\n\nReturn some element of a nonempty set.\n\nInput\n\nX – set\n\nOutput\n\nAn element of X unless X is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractCentrallySymmetric/#LazySets.API.an_element-Tuple{AbstractCentrallySymmetric}","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"LazySets.API.an_element","text":"Extended help\n\nan_element(S::AbstractCentrallySymmetric)\n\nOutput\n\nThe center of the centrally symmetric set.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractCentrallySymmetric/#Base.extrema-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractCentrallySymmetric","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"Base.extrema","text":"extrema(X::LazySet)\n\nCompute the lowest and highest coordinate of a set in each dimension.\n\nInput\n\nX – set\n\nOutput\n\nTwo vectors with the lowest and highest coordinates of X in each dimension.\n\nNotes\n\nSee also extrema(X::LazySet, i::Int).\n\nThe result is equivalent to (low(X), high(X)), but sometimes it can be computed more efficiently.\n\nThe resulting points are the lowest and highest corners of the box approximation, so they are not necessarily contained in X.\n\nAlgorithm\n\nThe default implementation computes the extrema via low and high.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractCentrallySymmetric/#Base.extrema-Tuple{AbstractCentrallySymmetric}","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"Base.extrema","text":"Extended help\n\nextrema(S::AbstractCentrallySymmetric)\n\nNotes\n\nThe result is equivalent to (low(S), high(S)).\n\nAlgorithm\n\nWe compute high(S) and then compute the lowest coordinates with the help of center(S) (which is assumed to be cheaper to obtain).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractCentrallySymmetric/#Base.extrema-Tuple{LazySets.API.LazySet, Int64}-lib-interfaces-AbstractCentrallySymmetric","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"Base.extrema","text":"extrema(X::LazySet, i::Int)\n\nCompute the lowest and highest coordinate of a set in a given dimension.\n\nInput\n\nX – set\ni – dimension\n\nOutput\n\nTwo real numbers representing the lowest and highest coordinate of the set in the given dimension.\n\nNotes\n\nThe result is equivalent to (low(X, i), high(X, i)), but sometimes it can be computed more efficiently.\n\nThe resulting values are the lower and upper ends of the projection.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractCentrallySymmetric/#Base.extrema-Tuple{AbstractCentrallySymmetric, Int64}","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"Base.extrema","text":"Extended help\n\nextrema(S::AbstractCentrallySymmetric, i::Int)\n\nNotes\n\nThe result is equivalent to (low(S, i), high(S, i)).\n\nAlgorithm\n\nWe compute high(S, i) and then compute the lowest coordinates with the help of center(S, i) (which is assumed to be cheaper to obtain).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractCentrallySymmetric/#LazySets.API.isuniversal-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractCentrallySymmetric","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"LazySets.API.isuniversal","text":"isuniversal(X::LazySet, witness::Bool=false)\n\nCheck whether a set is universal.\n\nInput\n\nX       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X = ℝ^n\nIf the witness option is activated:\n(true, []) iff X = ℝ^n\n(false, v) iff X  ℝ^n for some v  X\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractCentrallySymmetric/#LazySets.API.isuniversal","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"LazySets.API.isuniversal","text":"Extended help\n\nisuniversal(S::AbstractCentrallySymmetric, [witness]::Bool=false)\n\nAlgorithm\n\nA witness is obtained by computing the support vector in direction d = [1, 0, …, 0] and adding d on top.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractCentrallySymmetric/","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"Centrally symmetric sets (AbstractCentrallySymmetric)","text":"Undocumented implementations:","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetric/","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"Centrally symmetric sets (AbstractCentrallySymmetric)","text":"center\ndim\nisbounded\nisboundedtype\nisempty","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetric/","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"Centrally symmetric sets (AbstractCentrallySymmetric)","text":"Inherited from LazySet:","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetric/","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"Centrally symmetric sets (AbstractCentrallySymmetric)","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nhigh\nhigh\nisoperation\nispolyhedral\nlow\nlow\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nlinear_map\nproject\nsample\nscale\nρ\ntranslate\ncartesian_product\nconvex_hull\nexact_sum\n≈\nisdisjoint\n==\nisequivalent\n⊂\n⊆\nminkowski_difference\nminkowski_sum","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetric/","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"Centrally symmetric sets (AbstractCentrallySymmetric)","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetric/","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"Centrally symmetric sets (AbstractCentrallySymmetric)","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/interfaces/AbstractCentrallySymmetric/#Convenience-functions","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"Convenience functions","text":"","category":"section"},{"location":"lib/interfaces/AbstractCentrallySymmetric/#LazySets.○-Tuple{Any, Any}","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"LazySets.○","text":"○(c, a)\n\nConvenience constructor of Ellipsoids or Ball2s depending on the type of a.\n\nInput\n\nc – center\na – additional parameter (either a shape matrix for Ellipsoid or a radius        for Ball2)\n\nOutput\n\nA Ellipsoids or Ball2s depending on the type of a.\n\nNotes\n\n\"○\" can be typed by \\bigcirc<tab>.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractCentrallySymmetric/#Implementations","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/AbstractCentrallySymmetric/","page":"Centrally symmetric sets (AbstractCentrallySymmetric)","title":"Centrally symmetric sets (AbstractCentrallySymmetric)","text":"Euclidean-norm ball (Ball2)\nEllipsoid\np-norm ball (Ballp)","category":"page"},{"location":"lib/sets/HParallelotope/#def_HParallelotope","page":"HParallelotope","title":"HParallelotope","text":"","category":"section"},{"location":"lib/sets/HParallelotope/#LazySets.HParallelotopeModule.HParallelotope","page":"HParallelotope","title":"LazySets.HParallelotopeModule.HParallelotope","text":"HParallelotope{N, VN<:AbstractVector{N}, MN<:AbstractMatrix{N}} <: AbstractZonotope{N}\n\nType that represents a parallelotope in constraint form.\n\nFields\n\ndirections – square matrix where each row is the direction of two parallel                 constraints\noffset     – vector where each element is the offset of the corresponding                 constraint\n\nNotes\n\nParallelotopes are centrally symmetric convex polytopes in ℝ^n having 2n pairwise parallel constraints. Every parallelotope is a zonotope. As such, parallelotopes can be represented in constraint form or in generator form. The HParallelotope type represents parallelotopes in constraint form.\n\nLet D  ℝ^n  n be a matrix and let c  ℝ^2n be a vector. The parallelotope P  ℝ^n generated by the directions matrix D and the offset vector c is given by the set of points x  ℝ^n such that:\n\n    D_i  x  c_itext  and   -D_i  x  c_n+i\n\nfor i = 1  n. Here D_i represents the i-th row of D and c_i the i-th component of c.\n\nNote that, although representing a zonotopic set, an HParallelotope can be empty or unbounded if the constraints are unsuitably chosen. This may cause problems with default methods because the library assumes that zonotopic sets are non-empty and bounded. Thus such instances are considered illegal. The default constructor thus checks these conditions, which can be deactivated by passing the argument check_consistency=false.\n\nFor details as well as applications of parallelotopes in reachability analysis we refer to Dreossi et al. [DDP17] and Dreossi et al. [DDP16]. For conversions between set representations we refer to Althoff et al. [ASB10].\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/HParallelotope/#Conversion","page":"HParallelotope","title":"Conversion","text":"","category":"section"},{"location":"lib/sets/HParallelotope/#Base.convert-Tuple{Type{HParallelotope}, AbstractZonotope}","page":"HParallelotope","title":"Base.convert","text":"convert(::Type{HParallelotope}, Z::AbstractZonotope)\n\nConvert a zonotopic set of order one to a parallelotope in constraint representation.\n\nInput\n\nHParallelotope – target type\nZ              – zonotopic set of order one\n\nOutput\n\nA parallelotope in constraint representation.\n\nNotes\n\nThis function requires that the list of constraints of Z are obtained in the particular order returned from the constraints_list function of a Zonotope. Hence it first converts Z to a Zonotope.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HParallelotope/#Operations","page":"HParallelotope","title":"Operations","text":"","category":"section"},{"location":"lib/sets/HParallelotope/#LazySets.HParallelotopeModule.base_vertex-Tuple{HParallelotope}","page":"HParallelotope","title":"LazySets.HParallelotopeModule.base_vertex","text":"base_vertex(P::HParallelotope)\n\nCompute the base vertex of a parallelotope in constraint representation.\n\nInput\n\nP – parallelotope in constraint representation\n\nOutput\n\nThe base vertex of P.\n\nAlgorithm\n\nIntuitively, the base vertex is the point from which we get the relative positions of all the other points. The base vertex can be computed as the solution of the n-dimensional linear system D_i x = c_n+i for i = 1  n, see Dreossi et al. [DDP17], Section 3.2.1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HParallelotope/#LazySets.API.center-Tuple{LazySets.API.LazySet}-lib-sets-HParallelotope","page":"HParallelotope","title":"LazySets.API.center","text":"center(X::LazySet)\n\nCompute the center of a centrally symmetric set.\n\nInput\n\nX – centrally symmetric set\n\nOutput\n\nA vector with the center, or midpoint, of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HParallelotope/#LazySets.API.center-Tuple{HParallelotope}","page":"HParallelotope","title":"LazySets.API.center","text":"Extended help\n\ncenter(P::HParallelotope)\n\nAlgorithm\n\nLet P be a parallelotope with base vertex q and list of extremal vertices with respect to q given by the set v_i for i = 1  n. Then the center is located at\n\n    c = q + _i=1^n fracv_i - q2 = q (1 - frac2) + fracs2\n\nwhere s = _i=1^n v_i is the sum of extremal vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HParallelotope/#LazySets.HParallelotopeModule.directions-Tuple{HParallelotope}","page":"HParallelotope","title":"LazySets.HParallelotopeModule.directions","text":"directions(P::HParallelotope)\n\nReturn the directions matrix of a parallelotope in constraint representation.\n\nInput\n\nP – parallelotope in constraint representation\n\nOutput\n\nA matrix where each row represents a direction of the parallelotope. The negated directions -D_i are implicit (see HParallelotope for details).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HParallelotope/#LazySets.HParallelotopeModule.extremal_vertices-Union{Tuple{HParallelotope{N, VN, MN} where MN<:AbstractMatrix{N}}, Tuple{VN}, Tuple{N}} where {N, VN}","page":"HParallelotope","title":"LazySets.HParallelotopeModule.extremal_vertices","text":"extremal_vertices(P::HParallelotope{N, VN}) where {N, VN}\n\nCompute the extremal vertices with respect to the base vertex of a parallelotope in constraint representation.\n\nInput\n\nP – parallelotope in constraint representation\n\nOutput\n\nThe list of vertices connected to the base vertex of P.\n\nNotes\n\nLet P be a parallelotope in constraint representation with directions matrix D and offset vector c. The extremal vertices of P with respect to its base vertex q are those vertices of P that have an edge in common with q.\n\nAlgorithm\n\nThe extremal vertices can be computed as the solution of the n-dimensional linear systems of equations D x = v_i where for each i = 1  n, v_i = -c_n+1  c_i  -c_2n.\n\nWe refer to Dreossi et al. [DDP17], Section 3.2.1 for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HParallelotope/#LazySets.genmat-Tuple{AbstractZonotope}-lib-sets-HParallelotope","page":"HParallelotope","title":"LazySets.genmat","text":"genmat(Z::AbstractZonotope)\n\nReturn a generator matrix of a zonotopic set.\n\nInput\n\nZ – zonotopic set\n\nOutput\n\nA generator matrix of Z.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HParallelotope/#LazySets.genmat-Tuple{HParallelotope}","page":"HParallelotope","title":"LazySets.genmat","text":"Extended help\n\ngenmat(P::HParallelotope)\n\nAlgorithm\n\nLet P be a parallelotope with base vertex q and list of extremal vertices with respect to q given by the set v_i for i = 1  n. Then, the i-th generator of P, represented as the i-th column vector G i, is given by:\n\n    G i = fracv_i - q2\n\nfor i = 1  n.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HParallelotope/#LazySets.HParallelotopeModule.offset-Tuple{HParallelotope}","page":"HParallelotope","title":"LazySets.HParallelotopeModule.offset","text":"offset(P::HParallelotope)\n\nReturn the offsets of a parallelotope in constraint representation.\n\nInput\n\nP – parallelotope in constraint representation\n\nOutput\n\nA vector with the 2n offsets of the parallelotope, where n is the dimension of P.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HParallelotope/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-HParallelotope","page":"HParallelotope","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HParallelotope/#Base.rand-Tuple{Type{HParallelotope}}","page":"HParallelotope","title":"Base.rand","text":"Extended help\n\nrand(::Type{HParallelotope}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1.\n\nThe directions matrix and offset vector are created randomly. On average there is a good chance that this resulting set is empty. We then modify the offset to ensure non-emptiness.\n\nThere is a chance that the resulting set represents an unbounded set. This implementation checks for that case and then samples a new set.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HParallelotope/#LazySets.API.volume-Tuple{LazySets.API.LazySet}-lib-sets-HParallelotope","page":"HParallelotope","title":"LazySets.API.volume","text":"volume(X::LazySet)\n\nCompute the volume, or Lebesgue measure, of a set.\n\nInput\n\nX – set\n\nOutput\n\nA real number representing the Lebesgue measure of X.\n\nNotes\n\nThe Lebesgue measure has the following common special cases:\n\nIn 1D, it coincides with the length.\nIn 2D, it coincides with the area (see also area).\nIn 3D, it coincides with the volume.\n\nIn higher dimensions, it is also known as the hypervolume or simply volume.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HParallelotope/#LazySets.API.volume-Tuple{HParallelotope}","page":"HParallelotope","title":"LazySets.API.volume","text":"Extended help\n\nvolume(P::HParallelotope)\n\nAlgorithm\n\nThe volume of an n-dimensional parallelotope P is 2^n  det(G), where G is the generator matrix of P. This can be seen as follows: The generator matrix transforms the n-dimensional hypercube 0 1^n to a parallelotope of volume det(G). Since the representation of a parallelotope instead transforms the hypercube -1 1^n, this result has to be doubled for each dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HParallelotope/","page":"HParallelotope","title":"HParallelotope","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/HParallelotope/","page":"HParallelotope","title":"HParallelotope","text":"constraints_list\ndim","category":"page"},{"location":"lib/sets/HParallelotope/","page":"HParallelotope","title":"HParallelotope","text":"generators","category":"page"},{"location":"lib/sets/HParallelotope/","page":"HParallelotope","title":"HParallelotope","text":"isoperationtype","category":"page"},{"location":"lib/sets/HParallelotope/","page":"HParallelotope","title":"HParallelotope","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/HParallelotope/","page":"HParallelotope","title":"HParallelotope","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nsample\nscale\nscale!\ntranslate\ntranslate!\nconvex_hull\nexact_sum\n≈\n==\nisequivalent\n⊂","category":"page"},{"location":"lib/sets/HParallelotope/","page":"HParallelotope","title":"HParallelotope","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/HParallelotope/","page":"HParallelotope","title":"HParallelotope","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/HParallelotope/","page":"HParallelotope","title":"HParallelotope","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/HParallelotope/","page":"HParallelotope","title":"HParallelotope","text":"high\nhigh\nispolyhedral\nlow\nlow\nintersection","category":"page"},{"location":"lib/sets/HParallelotope/","page":"HParallelotope","title":"HParallelotope","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/HParallelotope/","page":"HParallelotope","title":"HParallelotope","text":"isbounded\nisboundedtype","category":"page"},{"location":"lib/sets/HParallelotope/","page":"HParallelotope","title":"HParallelotope","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/sets/HParallelotope/","page":"HParallelotope","title":"HParallelotope","text":"an_element\ncenter\nextrema\nextrema\nisempty\nisuniversal","category":"page"},{"location":"lib/sets/HParallelotope/","page":"HParallelotope","title":"HParallelotope","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/sets/HParallelotope/","page":"HParallelotope","title":"HParallelotope","text":"ngens\norder\nreflect\nremove_redundant_generators\ntogrep\nvertices_list\nlinear_map\n∈\nproject\nreduce_order\nsplit\nsplit\nρ\nσ\ncartesian_product\nisdisjoint\n⊆\nminkowski_difference\nminkowski_sum","category":"page"},{"location":"man/lazy_intersections/#Lazy-Intersections","page":"Lazy Intersections","title":"Lazy Intersections","text":"","category":"section"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"In this section we illustrate the use of lazy intersection in LazySets. We will use the ellipsoid set type.","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"Pages = [\"lazy_intersections.md\"]\nDepth = 3","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"An ellipsoid E can be created by giving its center c and its shape matrix Q, which should be positive definite, i.e. its eigenvalues must be positive. Mathematically, it is the set","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"    E =  x  ℝ^n  (x-c)Q^-1(x-c)  1","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"Let's make two rotated ellipsoids and plot them in the same pair of axes.","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"using Plots, LazySets\n\nE₁ = Ellipsoid(zeros(2), [1 0; 0 2.])\nE₂ = Ellipsoid(ones(2), [2 0; 0 1.])\n\npell = plot(E₁, aspectratio=1)\npell = plot!(pell, E₂)","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"note: Note\nThe accuracy to which this set is plotted can be controlled by passing a numerical argument as in plot(E₁, 1e-3, aspectratio=1). Here, 1e-3 stands for an upper-bound on the error, measured in terms of the Hausdorff distance between the ellipsoid and the polygonal overapproximation which is actually computed for display.","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"Now let's take the lazy intersection of the ellipses:","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"Z = E₁ ∩ E₂\ntypeof(Z)","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"On the other hand, the concrete intersection of sets, called intersection in LazySets, is not yet available for ellipsoids:","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"hasmethod(intersection, Tuple{typeof(E₁), typeof(E₂)})","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"So how can we work with the intersection of the ellipsoids?","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"One way is to overapproximate them by polygons (or polytopes in higher dims) and then take their intersection, because this function is defined, whose return type is again a HPolytope:","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"hasmethod(intersection, Tuple{HPolytope{Float64}, HPolytope{Float64}})","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"import LazySets.Approximations.overapproximate\n\n# the parameter epsilon controls the accuracy of the iterative refinement,\n# with respect to the Hausdorff distance\nH₁(ε) = overapproximate(E₁, HPolygon, ε)\nH₂(ε) = overapproximate(E₂, HPolygon, ε)\n\n# using the concrete hpolytope-hpolytope intersection here\nHint(ε) = intersection(convert.(HPolytope, [H₁(ε), H₂(ε)])...);","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"pell = plot(E₁, aspectratio=1)\npell = plot!(pell, E₂)\npεsmaller = plot!(pell, convert(HPolygon, Hint(0.5)), alpha=.4)\n\npell = plot(E₁, aspectratio=1)\npell = plot!(pell, E₂)\npεbigger = plot!(pell, convert(HPolygon, Hint(0.05)), alpha=.4)\n\nplot(pεsmaller, pεbigger, layout=(1, 2))","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"Note how dividing the ε threshold by 10 makes the polygonal overapproximation of the intersection tighter.","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"Yet another approach is to directly query the directions of the lazy intersection E₁ ∩ E₂. We can overapproximate using template directions, such as a box, an octagon, or other.","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"The idea behind the template overapproximation method is to use the property that the support function of the intersection of two convex sets is upper bounded by the min of the support function of each set. We can see in the following experiments that the resulting set is quite tight.","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"using Polyhedra\n\n# overapproximate the lazy intersection using a box\nXbox = overapproximate(E₁ ∩ E₂, BoxDirections(2))\n\n# overapproximate the lazy intersection using octagonal directions\nXoct = overapproximate(E₁ ∩ E₂, OctDirections(2))\n\npell = plot(E₁, aspectratio=1)\npell = plot!(pell, E₂)\npbox = plot!(pell, Xbox, alpha=.4)\n\npell = plot(E₁, aspectratio=1)\npell = plot!(pell, E₂)\npoct = plot!(pell, Xoct, alpha=.4)\n\nplot(pbox, poct, layout=(1, 2))","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"Using support function evaluations over a set of fixed directions is in general more efficient than iterative refinement, but the drawback is that one does not have control on the overapproximation error. Moreover, iterative refinement is currently only available in two dimensions, but overapproximation with template directions can be used in any dimension.","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"Let's time it!","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"We can work with higher dimensional ellipsoids as well:","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"using LinearAlgebra\n\n# a random ellipsoid in n-dimensions\nfunction rand_ellipsoid(n)\n    A = rand(n,n)\n    Q = (A+transpose(A))/2 + n * I\n    Ellipsoid(rand(n), Q)\nend\n\nfor n in [2, 5, 10]\n    println(\"\\nn = $n\\n\")\n    global E₁, E₂ = rand_ellipsoid(n), rand_ellipsoid(n)\n\n    # overapproximate the lazy intersection using an n-dimensional box\n    @time overapproximate(E₁ ∩ E₂, BoxDirections(n))\n\n    # overapproximate the lazy intersection using octagonal directions in R^n\n    @time overapproximate(E₁ ∩ E₂, OctDirections(n))\nend;","category":"page"},{"location":"man/optional_dependencies/#Optional-Features","page":"Optional Features","title":"Optional Features","text":"","category":"section"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"This section summarizes each optional dependency and the features available when used together with LazySets.jl. Internally, optional dependencies in Julia are handled with the package Requires.jl.","category":"page"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"Pages = [\"optional_dependencies.md\"]","category":"page"},{"location":"man/optional_dependencies/#Installing-all-dependencies","page":"Optional Features","title":"Installing all dependencies","text":"","category":"section"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"Use the following command to install all optional dependencies. Installing all optional dependencies is required if you want to run the full test suite and build the documentation locally.","category":"page"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"julia> import Pkg; Pkg.add([\"CDDLib\",\n                            \"Distributions\",\n                            \"Documenter\",\n                            \"Expokit\",\n                            \"ExponentialUtilities\",\n                            \"IntervalMatrices\",\n                            \"Makie\",\n                            \"Optim\",\n                            \"Polyhedra\",\n                            \"RecipesBase\",\n                            \"StaticArrays\",\n                            \"Symbolics\",\n                            \"TaylorModels\"])","category":"page"},{"location":"man/optional_dependencies/#Documentation","page":"Optional Features","title":"Documentation","text":"","category":"section"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"To build the project's documentation locally you need to install Documenter.jl.","category":"page"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"Dependency Features\nDocumenter Building the package's documentation.\nLaTeXStrings Input and display of LaTeX equation strings, used in plots.","category":"page"},{"location":"man/optional_dependencies/#Exponential-backends","page":"Optional Features","title":"Exponential backends","text":"","category":"section"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"Exponential backends are used to compute the action of matrix exponentials over sets lazily, e.g. rho(d e^A delta X) for A large and sparse.","category":"page"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"Dependency Features\nExponentialUtilities Utility functions for exponential integrators from the SciML scientific machine learning ecosystem.\nExpokit Julia implementation of EXPOKIT routines.","category":"page"},{"location":"man/optional_dependencies/#Interval-methods","page":"Optional Features","title":"Interval methods","text":"","category":"section"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"For validated numerics, we build upon the Julia ecosystem JuliaIntervals. The package IntervalArithmetic.jl, which is a hard dependency of LazySets, implements rigorous floating-point calculations using interval arithmetic in Julia and is the basis for the implementation of Interval. There are other interval packages that can also be used in conjunction with LazySets and provide additional functionality.","category":"page"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"The package IntervalLinearAlgebra is not an optional dependency of LazySets, but these packages can be used in conjunction to compute solution sets of interval linear systems.","category":"page"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"Dependency Features\nIntervalConstraintProgramming Conservative polyhedral approximation of a region defined implicitly via nonlinear constraints.\nIntervalMatrices Set operations that involve matrices whose coefficients are intervals.\nTaylorModels Taylor expansion of functions with rigorous interval remainder.","category":"page"},{"location":"man/optional_dependencies/#Optimization-algorithms","page":"Optional Features","title":"Optimization algorithms","text":"","category":"section"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"Some computations require use of external numerical optimization solvers. The modeling language JuMP is loaded by default, together with the GLPK solver for linear programs (LPs). Other solvers can be loaded on-demand, even commercial ones, provided that you have the appropriate license. See JuMP's documentation page on supported solvers for further details.","category":"page"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"For other uses, such as line search methods to compute the support function of lazy intersections of certain sets, Optim can be optionally loaded.","category":"page"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"Dependency Features\nOptim Optimization package in pure Julia.","category":"page"},{"location":"man/optional_dependencies/#Polyhedral-computations","page":"Optional Features","title":"Polyhedral computations","text":"","category":"section"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"The optional package Polyhedra.jl is required whenever you want to work with concrete polyhedra representations in dimension higher than 2, e.g. to solve the vertex enumeration problem (converting from constraint to vertex representation of a polytope). While Polyhedra implements its own default backend, it is also possible to load external ones, such as cdd through CDDLib.jl. For a list of available polyhedra backends, see the website of the JuliaPolyhedra ecosystem.","category":"page"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"Dependency Features\nPolyhedra Concrete polyhedra library.\nCDDLib Polyhedral computations backend.","category":"page"},{"location":"man/optional_dependencies/#Random-sampling-and-triangulation","page":"Optional Features","title":"Random sampling and triangulation","text":"","category":"section"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"Dependency Features\nDistributions Random sampling.\nMiniQhull Voronoi-Delaunay triangulation of LazySets types.","category":"page"},{"location":"man/optional_dependencies/#Special-array-types","page":"Optional Features","title":"Special array types","text":"","category":"section"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"Dependency Features\nStaticArrays Statically defined arrays.","category":"page"},{"location":"man/optional_dependencies/#Symbolic-utilities","page":"Optional Features","title":"Symbolic utilities","text":"","category":"section"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"Dependency Features\nSymbolics Create sets using symbolic expressions.","category":"page"},{"location":"man/optional_dependencies/#Visualization","page":"Optional Features","title":"Visualization","text":"","category":"section"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"As in other Julia packages, the user has to manually install and load the package Plots in order to produce visual results. As a plotting backend we recommend using GR, which is the default backend and is automatically installed together with Plots.","category":"page"},{"location":"man/optional_dependencies/","page":"Optional Features","title":"Optional Features","text":"Dependency Features\nMakie Mainly for 3D and interactive plots.\nPlots Mainly 2D plots.","category":"page"},{"location":"lib/parallel/#Parallel","page":"Parallel","title":"Parallel","text":"","category":"section"},{"location":"lib/parallel/","page":"Parallel","title":"Parallel","text":"This section of the manual describes the parallel implementation of some algorithms in the LazySets library. These algorithms are implemented in the LazySets.Parallel module.","category":"page"},{"location":"lib/parallel/","page":"Parallel","title":"Parallel","text":"Pages = [\"parallel.md\"]\nDepth = 3","category":"page"},{"location":"lib/parallel/#LazySets.Parallel","page":"Parallel","title":"LazySets.Parallel","text":"Module Parallel.jl – LazySets algorithms that are parallelized.\n\n\n\n\n\n","category":"module"},{"location":"lib/parallel/#Box-approximations","page":"Parallel","title":"Box approximations","text":"","category":"section"},{"location":"lib/parallel/#LazySets.Parallel.box_approximation","page":"Parallel","title":"LazySets.Parallel.box_approximation","text":"box_approximation(S::LazySet{N}) where {N}\n\nOverapproximation a set by a tight hyperrectangle using a parallel implementation.\n\nInput\n\nS – set\n\nOutput\n\nA tight hyperrectangle.\n\nAlgorithm\n\nThe center of the hyperrectangle is obtained by averaging the support function of the given set in the canonical directions, and the lengths of the sides can be recovered from the distance among support functions in the same directions.\n\n\n\n\n\n","category":"function"},{"location":"lib/parallel/#LazySets.Parallel.box_approximation_symmetric","page":"Parallel","title":"LazySets.Parallel.box_approximation_symmetric","text":"box_approximation_symmetric(S::LazySet{N}) where {N}\n\nOverapproximate a set by a tight hyperrectangle centered in the origin, using a parallel implementation.\n\nInput\n\nS – set\n\nOutput\n\nA tight hyperrectangle centered in the origin.\n\nAlgorithm\n\nThe center of the box is the origin, and the radius is obtained by computing the maximum value of the support function evaluated at the canonical directions.\n\n\n\n\n\n","category":"function"},{"location":"lib/parallel/#LazySets.Parallel.box_approximation_helper_parallel","page":"Parallel","title":"LazySets.Parallel.box_approximation_helper_parallel","text":"box_approximation_helper_parallel(S::LazySet{N}) where {N}\n\nParallel implementation for the common code of box_approximation and box_approximation_symmetric.\n\nInput\n\nS – set\n\nOutput\n\nA tuple containing the data that is needed to construct a tightly overapproximating hyperrectangle.\n\nc – center\nr – radius\n\nAlgorithm\n\nThe center of the hyperrectangle is obtained by averaging the support function of the given set in the canonical directions. The lengths of the sides can be recovered from the distance among support functions in the same directions.\n\nThe same load is distributed among all available workers, see distribute_task!.\n\n\n\n\n\n","category":"function"},{"location":"lib/parallel/#LazySets.Parallel.process_chunk!","page":"Parallel","title":"LazySets.Parallel.process_chunk!","text":"process_chunk!(S::LazySet{N}, irange::UnitRange{Int},\n               c::SharedVector{N}, r::SharedVector{N}) where {N}\n\nKernel to process a given chunk.\n\nInput\n\nc      – shared vector with the center of the hyperrectangle\nr      – shared vector with the center of the hyperrectangle\nS      – set\nirange – indices range of the given worker\n\nAlgorithm\n\nThe center of the hyperrectangle is obtained by averaging the support function of the given set in the canonical directions. The lengths of the sides can be recovered from the distance among support functions in the same directions.\n\nThe load for each worker is passed through the irange argument. By default, the same load is distributed among all available workers. For details see distribute_task!.\n\n\n\n\n\n","category":"function"},{"location":"lib/parallel/#Distributed-functions","page":"Parallel","title":"Distributed functions","text":"","category":"section"},{"location":"lib/parallel/#LazySets.Parallel.assign_chunk!","page":"Parallel","title":"LazySets.Parallel.assign_chunk!","text":"assign_chunk!(X::LazySet, v::SharedVector...)\n\nReturn the function that assigns the work for each process.\n\nInput\n\nX – set\nv – shared vectors\n\nOutput\n\nThe function process_chunk! that equally distributes the load for each worker.\n\nNotes\n\nThis function is a wrapper around a problem-specific process_chunk! function.\n\nUse this function to distribute a given task acting on a set X and a pool v of shared vectors. The tasks are equally distributed among the processes.\n\nSee also distribute_task!.\n\n\n\n\n\n","category":"function"},{"location":"lib/parallel/#LazySets.Parallel.distribute_task!","page":"Parallel","title":"LazySets.Parallel.distribute_task!","text":"distribute_task!(X::LazySet, v::SharedVector...)\n\nDistribute the assignment of each chunk among the available processes.\n\nInput\n\nX – set\nv – shared vectors\n\nOutput\n\nNothing.\n\nNotes\n\nUse this function to distribute a given task acting on a set X and a pool v of shared vectors.\n\nThe task for each processor is distributed through remotecall_wait using a function assign_chunk! that should be defined elsewhere. The vectors v contain one or more shared vectors in which the values of the task are written.\n\n\n\n\n\n","category":"function"},{"location":"lib/parallel/#LazySets.Parallel._prange","page":"Parallel","title":"LazySets.Parallel._prange","text":"_prange(v::SharedVector)\n\nReturns the indices assigned to a process.\n\nInput\n\nv – shared vector\n\nOutput\n\nThe indices assigned to each process.\n\nNotes\n\nThe indices are assigned such that the vector is equally distributed among the processes. If the worker is not assigned a piece, the unit range 1:0 is returned.\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/ExponentialMap/#Exponential-map","page":"ExponentialMap","title":"Exponential map","text":"","category":"section"},{"location":"lib/lazy_operations/ExponentialMap/#def_ExponentialMap","page":"ExponentialMap","title":"Exponential map (ExponentialMap)","text":"","category":"section"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.ExponentialMap","page":"ExponentialMap","title":"LazySets.ExponentialMap","text":"ExponentialMap{N, S<:LazySet{N}} <: AbstractAffineMap{N, S}\n\nType that represents the action of an exponential map on a set.\n\nFields\n\nspmexp – sparse matrix exponential\nX      – set\n\nNotes\n\nThe exponential map preserves convexity: if X is convex, then any exponential map of X is convex as well.\n\nExamples\n\nThe ExponentialMap type is overloaded to the usual times (*) operator when the linear map is a lazy matrix exponential. For instance:\n\njulia> using SparseArrays\n\njulia> A = sprandn(100, 100, 0.1);\n\njulia> E = SparseMatrixExp(A);\n\njulia> B = BallInf(zeros(100), 1.);\n\njulia> M = E * B;  # represents the set: exp(A) * B\n\njulia> M isa ExponentialMap\ntrue\n\njulia> dim(M)\n100\n\nThe application of an ExponentialMap to a ZeroSet or an EmptySet is simplified automatically.\n\njulia> E * ZeroSet(100)\nZeroSet{Float64}(100)\n\njulia> E * EmptySet(100)\n∅(100)\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.API.dim-Tuple{ExponentialMap}","page":"ExponentialMap","title":"LazySets.API.dim","text":"dim(em::ExponentialMap)\n\nReturn the dimension of an exponential map.\n\nInput\n\nem – exponential map\n\nOutput\n\nThe ambient dimension of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.API.ρ-Tuple{AbstractVector, ExponentialMap}","page":"ExponentialMap","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, em::ExponentialMap;\n  [backend]=get_exponential_backend())\n\nEvaluate the support function of the exponential map.\n\nInput\n\nd       – direction\nem      – exponential map\nbackend – (optional; default: get_exponential_backend()) exponentiation              backend\n\nOutput\n\nThe evaluation of the support function in the given direction.\n\nNotes\n\nIf E = exp(M)X, where M is a matrix and X is a set, it follows that ρ(d E) = ρ(exp(M)^T d X) for any direction d.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.API.σ-Tuple{AbstractVector, ExponentialMap}","page":"ExponentialMap","title":"LazySets.API.σ","text":"σ(d::AbstractVector, em::ExponentialMap;\n  [backend]=get_exponential_backend())\n\nReturn a support vector of an exponential map.\n\nInput\n\nd       – direction\nem      – exponential map\nbackend – (optional; default: get_exponential_backend()) exponentiation              backend\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\nNotes\n\nIf E = exp(M)X, where M is a matrix and X is a set, it follows that σ(d E) = exp(M)σ(exp(M)^T d X) for any direction d.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#Base.:∈-Tuple{AbstractVector, ExponentialMap}","page":"ExponentialMap","title":"Base.:∈","text":"∈(x::AbstractVector, em::ExponentialMap;\n  [backend]=get_exponential_backend())\n\nCheck whether a given point is contained in an exponential map of a set.\n\nInput\n\nx       – point/vector\nem      – exponential map of a set\nbackend – (optional; default: get_exponential_backend()) exponentiation              backend\n\nOutput\n\ntrue iff x  em.\n\nAlgorithm\n\nThis implementation exploits that x  exp(M)X iff exp(-M)x  X. This follows from exp(-M)exp(M) = I for any M.\n\nExamples\n\njulia> using SparseArrays\n\njulia> em = ExponentialMap(\n        SparseMatrixExp(sparse([1, 2], [1, 2], [2.0, 1.0], 2, 2)),\n        BallInf([1., 1.], 1.));\n\njulia> [-1.0, 1.0] ∈ em\nfalse\njulia> [1.0, 1.0] ∈ em\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.API.isbounded-Tuple{ExponentialMap}","page":"ExponentialMap","title":"LazySets.API.isbounded","text":"isbounded(em::ExponentialMap)\n\nCheck whether an exponential map is bounded.\n\nInput\n\nem – exponential map\n\nOutput\n\ntrue iff the exponential map is bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.API.vertices_list-Tuple{ExponentialMap}","page":"ExponentialMap","title":"LazySets.API.vertices_list","text":"vertices_list(em::ExponentialMap; [backend]=get_exponential_backend())\n\nReturn the list of vertices of a (polytopic) exponential map.\n\nInput\n\nem      – polytopic exponential map\nbackend – (optional; default: get_exponential_backend()) exponentiation              backend\n\nOutput\n\nA list of vertices.\n\nAlgorithm\n\nWe assume that the underlying set X is polytopic. Then the result is just the exponential map applied to the vertices of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"norm\nradius\ndiameter\nsingleton_list\nreflect","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"Inherited from AbstractAffineMap:","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"an_element\nisempty\nconstraints_list\nlinear_map","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/#Sparse-matrix-exponential","page":"ExponentialMap","title":"Sparse matrix exponential","text":"","category":"section"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.SparseMatrixExp","page":"ExponentialMap","title":"LazySets.SparseMatrixExp","text":"SparseMatrixExp{N}\n\nType that represents the matrix exponential, exp(M), of a sparse matrix.\n\nFields\n\nM – sparse square matrix\n\nExamples\n\nTake for example a random sparse matrix of dimensions 100  100 and with occupation probability 01:\n\njulia> using SparseArrays\n\njulia> A = sprandn(100, 100, 0.1);\n\njulia> using ExponentialUtilities\n\njulia> E = SparseMatrixExp(A);\n\njulia> size(E)\n(100, 100)\n\nHere E is a lazy representation of exp(A). To compute with E, use get_row and get_column resp. get_rows and get_columns. These functions return row and column vectors (or matrices). For example:\n\njulia> get_row(E, 10);  # compute E[10, :]\n\njulia> get_column(E, 10);  # compute E[:, 10]\n\njulia> get_rows(E, [10]);  # same as get_row(E, 10), but yields a 1x100 matrix\n\njulia> get_columns(E, [10]);  # same as get_column(E, 10), but yields a 100x1 matrix\n\nNotes\n\nThis type is provided for use with large and sparse matrices. The evaluation of the exponential matrix action over vectors relies on external packages such as ExponentialUtilities or Expokit. Hence, you will have to install and load such an optional dependency to have access to the functionality of SparseMatrixExp.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/ExponentialMap/#Base.:*-Tuple{SparseMatrixExp, LazySet}","page":"ExponentialMap","title":"Base.:*","text":"    *(spmexp::SparseMatrixExp, X::LazySet)\n\nAlias to create an ExponentialMap object.\n\nInput\n\nspmexp – sparse matrix exponential\nX      – set\n\nOutput\n\nThe exponential map of the set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.get_row-Tuple{SparseMatrixExp, Int64}","page":"ExponentialMap","title":"LazySets.get_row","text":"get_row(spmexp::SparseMatrixExp{N}, i::Int;\n        [backend]=get_exponential_backend()) where {N}\n\nCompute a single row of a sparse matrix exponential.\n\nInput\n\nspmexp  – sparse matrix exponential\ni       – row index\nbackend – (optional; default: get_exponential_backend()) exponentiation              backend\n\nOutput\n\nA row vector corresponding to the ith row of the matrix exponential.\n\nNotes\n\nThis implementation uses Julia's transpose function to create the result. The result is of type Transpose; in Julia versions older than v0.7, the result was of type RowVector.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.get_rows-Tuple{SparseMatrixExp, AbstractArray{Int64}}","page":"ExponentialMap","title":"LazySets.get_rows","text":"get_rows(spmexp::SparseMatrixExp{N}, I::AbstractArray;\n           [backend]=get_exponential_backend()) where {N}\n\nCompute multiple rows of a sparse matrix exponential.\n\nInput\n\nspmexp  – sparse matrix exponential\nI       – list of row indices\nbackend – (optional; default: get_exponential_backend()) exponentiation              backend\n\nOutput\n\nA transposed matrix with one (transposed) column vector for each entry in I.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.get_column-Tuple{SparseMatrixExp, Int64}","page":"ExponentialMap","title":"LazySets.get_column","text":"get_column(spmexp::SparseMatrixExp{N}, j::Int;\n           [backend]=get_exponential_backend()) where {N}\n\nCompute a single column of a sparse matrix exponential.\n\nInput\n\nspmexp  – sparse matrix exponential\nj       – column index\nbackend – (optional; default: get_exponential_backend()) exponentiation              backend\n\nOutput\n\nA column vector corresponding to the jth column of the matrix exponential.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.get_columns-Tuple{SparseMatrixExp, AbstractArray{Int64}}","page":"ExponentialMap","title":"LazySets.get_columns","text":"get_columns(spmexp::SparseMatrixExp{N}, J::AbstractArray;\n           [backend]=get_exponential_backend()) where {N}\n\nCompute multiple columns of a sparse matrix exponential.\n\nInput\n\nspmexp  – sparse matrix exponential\nJ       – list of column indices\nbackend – (optional; default: get_exponential_backend()) exponentiation              backend\n\nOutput\n\nA matrix with one column vector for each entry in J.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#def_ExponentialProjectionMap","page":"ExponentialMap","title":"Exponential projection map (ExponentialProjectionMap)","text":"","category":"section"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.ExponentialProjectionMap","page":"ExponentialMap","title":"LazySets.ExponentialProjectionMap","text":"ExponentialProjectionMap{N, S<:LazySet{N}} <: AbstractAffineMap{N, S}\n\nType that represents the application of a projection of a sparse matrix exponential to a set.\n\nFields\n\nspmexp – projection of a sparse matrix exponential\nX      – set\n\nNotes\n\nThe exponential projection preserves convexity: if X is convex, then any exponential projection of X is convex as well.\n\nExamples\n\nWe use a random sparse projection matrix of dimensions 6  6 with occupation probability 05 and apply it to the 2D unit ball in the infinity norm:\n\njulia> using SparseArrays\n\njulia> R = sparse([5, 6], [1, 2], [1.0, 1.0]);\n\njulia> L = sparse([1, 2], [1, 2], [1.0, 1.0], 2, 6);\n\njulia> using ExponentialUtilities\n\njulia> A = sprandn(6, 6, 0.5);\n\njulia> E = SparseMatrixExp(A);\n\njulia> M = ProjectionSparseMatrixExp(L, E, R);\n\njulia> B = BallInf(zeros(2), 1.0);\n\njulia> X = ExponentialProjectionMap(M, B);\n\njulia> dim(X)\n2\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.API.dim-Tuple{ExponentialProjectionMap}","page":"ExponentialMap","title":"LazySets.API.dim","text":"dim(eprojmap::ExponentialProjectionMap)\n\nReturn the dimension of a projection of an exponential map.\n\nInput\n\neprojmap – projection of an exponential map\n\nOutput\n\nThe ambient dimension of the projection of an exponential map.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.API.σ-Tuple{AbstractVector, ExponentialProjectionMap}","page":"ExponentialMap","title":"LazySets.API.σ","text":"σ(d::AbstractVector, eprojmap::ExponentialProjectionMap;\n  [backend]=get_exponential_backend())\n\nReturn a support vector of a projection of an exponential map.\n\nInput\n\nd        – direction\neprojmap – projection of an exponential map\nbackend  – (optional; default: get_exponential_backend()) exponentiation               backend\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\nNotes\n\nIf S = (LMR)X, where L and R are matrices, M is a matrix exponential, and X is a set, it follows that σ(d S) = LMRσ(R^TM^TL^Td X) for any direction d.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.API.ρ-Tuple{AbstractVector, ExponentialProjectionMap}","page":"ExponentialMap","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, eprojmap::ExponentialProjectionMap;\n  [backend]=get_exponential_backend())\n\nEvaluate the support function of a projection of an exponential map.\n\nInput\n\nd        – direction\neprojmap – projection of an exponential map\nbackend  – (optional; default: get_exponential_backend()) exponentiation               backend\n\nOutput\n\nEvaluation of the support function in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\nNotes\n\nIf S = (LMR)X, where L and R are matrices, M is a matrix exponential, and X is a set, it follows that ρ(d S) = ρ(R^TM^TL^Td X) for any direction d.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.API.isbounded-Tuple{ExponentialProjectionMap}","page":"ExponentialMap","title":"LazySets.API.isbounded","text":"isbounded(eprojmap::ExponentialProjectionMap)\n\nCheck whether a projection of an exponential map is bounded.\n\nInput\n\neprojmap – projection of an exponential map\n\nOutput\n\ntrue iff the projection of an exponential map is bounded.\n\nAlgorithm\n\nWe first check if the left or right projection matrix is zero or the wrapped set is bounded. Otherwise, we check boundedness via LazySets._isbounded_unit_dimensions.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"norm\nradius\ndiameter\nsingleton_list\nreflect","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"Inherited from AbstractAffineMap:","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"an_element\nisempty\n∈\nvertices_list\nconstraints_list\nlinear_map","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/#Projection-of-a-sparse-matrix-exponential","page":"ExponentialMap","title":"Projection of a sparse matrix exponential","text":"","category":"section"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.ProjectionSparseMatrixExp","page":"ExponentialMap","title":"LazySets.ProjectionSparseMatrixExp","text":"ProjectionSparseMatrixExp{N, MN1<:AbstractSparseMatrix{N},\n                             MN2<:AbstractSparseMatrix{N},\n                             MN3<:AbstractSparseMatrix{N}}\n\nType that represents the projection of a sparse matrix exponential, i.e., Lexp(M)R for a given sparse matrix M.\n\nFields\n\nL – left multiplication matrix\nE – sparse matrix exponential\nR – right multiplication matrix\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/ExponentialMap/#Base.:*-Tuple{ProjectionSparseMatrixExp, LazySet}","page":"ExponentialMap","title":"Base.:*","text":"    *(projspmexp::ProjectionSparseMatrixExp, X::LazySet)\n\nAlias to create an ExponentialProjectionMap object.\n\nInput\n\nprojspmexp – projection of a sparse matrix exponential\nX          – set\n\nOutput\n\nThe application of the projection of a sparse matrix exponential to the set.\n\n\n\n\n\n","category":"method"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"M. Althoff. Reachability analysis of nonlinear systems using conservative polynomialization                   and non-convex sets. In: Hybrid Systems: Computation and Control (HSCC), edited by C. Belta and F. Ivancic (ACM, 2013); pp. 173–182.\n\n\n\nM. Althoff. On Computing the Minkowski Difference of Zonotopes. CoRR abs/1512.02794 (2015), arXiv:1512.02794.\n\n\n\nM. Althoff and B. H. Krogh. Avoiding geometric intersection operations in reachability analysis                   of hybrid systems. In: Hybrid Systems: Computation and Control (HSCC), edited by T. Dang and I. M. Mitchell (ACM, 2012); pp. 45–54.\n\n\n\nM. Althoff, O. Stursberg and M. Buss. Reachability analysis of nonlinear systems with uncertain parameters                   using conservative linearization. In: Conference on Decision and Control (CDC) (IEEE, 2008); pp. 4042–4048.\n\n\n\nM. Althoff, O. Stursberg and M. Buss. Computing reachable sets of hybrid systems using a combination of zonotopes and polytopes. Nonlinear Analysis: Hybrid Systems 4, 233–249 (2010).\n\n\n\nS. Bak and P. S. Duggirala. Simulation-Equivalent Reachability of Large Linear Systems with Inputs. In: Computer Aided Verification (CAV), Vol. 10426 of LNCS, edited by R. Majumdar and V. Kuncak (Springer, 2017); pp. 401–420.\n\n\n\nM. Behroozi. Largest Inscribed Rectangles in Geometric Convex Sets. CoRR abs/1905.13246 (2019), arXiv:1905.13246.\n\n\n\nC. Combastel. A state bounding observer based on zonotopes. In: European Control Conference (ECC) (IEEE, 2003); pp. 2589–2594.\n\n\n\nT. Dreossi, T. Dang and C. Piazza. Parallelotope Bundles for Polynomial Reachability. In: Hybrid Systems: Computation and Control (HSCC), edited by A. Abate and G. Fainekos (ACM, 2016); pp. 297–306.\n\n\n\nT. Dreossi, T. Dang and C. Piazza. Reachability computation for polynomial dynamical systems. Formal Methods in System Design 50, 1–38 (2017).\n\n\n\nP. S. Duggirala and M. Viswanathan. Parsimonious, Simulation Based Verification of Linear Systems. In: Computer Aided Verification (CAV), Vol. 9779 of LNCS, edited by S. Chaudhuri and A. Farzan (Springer, 2016); pp. 477–494.\n\n\n\nG. Frehse, C. L. Guernic, A. Donzé, S. Cotton, R. Ray, O. Lebeltel, R. Ripado, A. Girard, T. Dang and O. Maler. SpaceEx: Scalable Verification of Hybrid Systems. In: Computer Aided Verification (CAV), Vol. 6806 of LNCS, edited by G. Gopalakrishnan and S. Qadeer (Springer, 2011); pp. 379–395.\n\n\n\nG. Frehse and R. Ray. Flowpipe-Guard Intersection for Reachability Computations with Support                   Functions. In: Analysis and Design of Hybrid Systems (ADHS), Vol. 45 no. 9 of IFAC Proceedings Volumes, edited by M. Heemels and B. D. Schutter (Elsevier, 2012); pp. 94–101.\n\n\n\nK. Ghorbal, E. Goubault and S. Putot. The Zonotope Abstract Domain Taylor1+. In: Computer Aided Verification (CAV), Vol. 5643 of LNCS, edited by A. Bouajjani and O. Maler (Springer, 2009); pp. 627–633.\n\n\n\nA. Girard. Reachability of Uncertain Linear Systems Using Zonotopes. In: Hybrid Systems: Computation and Control (HSCC), Vol. 3414 of LNCS, edited by M. Morari and L. Thiele (Springer, 2005); pp. 291–305.\n\n\n\nR. Goldman. Intersection of Two Lines in Three-Space. In: Graphics Gems, edited by A. S. Glassner (Academic Press, 1990); pp. 304–304.\n\n\n\nC. L. Guernic. Reachability Analysis of Hybrid Systems with Linear Continuous Dynamics. Ph.D. Thesis, Joseph Fourier University, Grenoble, France (2009).\n\n\n\nL. J. Guibas, A. T. Nguyen and L. Zhang. Zonotopes as bounding volumes. In: Symposium on Discrete Algorithms (SODA) (ACM/SIAM, 2003); pp. 803–812.\n\n\n\nG. K. Kamenev. An algorithm for approximating polyhedra. Computational Mathematics and Mathematical Physics 36, 533–544 (1996).\n\n\n\nN. Kochdumper. Extensions of Polynomial Zonotopes and their Application to Verification                   of Cyber-Physical Systems. Ph.D. Thesis, Technical University of Munich, Germany (2022).\n\n\n\nN. Kochdumper and M. Althoff. Sparse Polynomial Zonotopes: A Novel Set Representation for Reachability                   Analysis. Transactions on Automatic Control 66, 4043–4058 (2021).\n\n\n\nI. Kolmanovsky and E. G. Gilbert. Theory and computation of disturbance invariant sets for discrete-time linear systems. Mathematical Problems in Engineering 4, 317–367 (1998).\n\n\n\nA.-K. Kopetzki, B. Schürmann and M. Althoff. Methods for order reduction of zonotopes. In: Conference on Decision and Control (CDC) (IEEE, 2017); pp. 5626–5633.\n\n\n\nM. Kvasnica. Minkowski addition of convex polytopes (2005).\n\n\n\nA. V. Lotov and A. I. Pospelov. The modified method of refined bounds for polyhedral approximation of convex polytopes. Computational Mathematics and Mathematical Physics 48, 933–941 (2008).\n\n\n\nO. L. Mangasarian. Nonlinear programming (SIAM, 1994).\n\n\n\nM. Maı̈ga, N. Ramdani, L. Travé-Massuyès and C. Combastel. A CSP Versus a Zonotope-Based Method for Solving Guard Set Intersection                   in Nonlinear Hybrid Reachability. Mathematics in Computer Science 8, 407–423 (2014).\n\n\n\nI. M. Mitchell, J. Budzis and A. Bolyachevets. Invariant, viability and discriminating kernel under-approximation                   via zonotope scaling: poster abstract. In: Hybrid Systems: Computation and Control (HSCC), edited by N. Ozay and P. Prabhakar (ACM, 2019); pp. 268–269.\n\n\n\nM. E. Muller. A Note on a Method for Generating Points Uniformly on N-Dimensional                   Spheres. Communications of the ACM 2, 19–20 (1959).\n\n\n\nJ. O’Rourke. Computational geometry in C (Cambridge University Press, 1998).\n\n\n\nR. T. Rockafellar and R. J.-B. Wets. Variational Analysis. Vol. 317 of Grundlehren der mathematischen Wissenschaften (Springer, 1998).\n\n\n\nD. B. Rubin. The Bayesian bootstrap. The annals of statistics, 130–134 (1981).\n\n\n\nJ. K. Scott, D. M. Raimondo, G. R. Marseglia and R. D. Braatz. Constrained zonotopes: A new tool for set-based estimation and fault detection. Automatica 69, 126–136 (2016).\n\n\n\nG. Singh, T. Gehr, M. Mirman, M. Püschel and M. T. Vechev. Fast and Effective Robustness Certification. In: Advances in Neural Information Processing Systems (NeurIPS), edited by S. Bengio, H. M. Wallach, H. Larochelle, K. Grauman, N. Cesa-Bianchi and R. Garnett (2018); pp. 10825–10836.\n\n\n\nP. Valtr. Probability that n Random Points are in Convex Position. Discrete & Computational Geometry 13, 637–643 (1995).\n\n\n\nM. Wetzlinger, N. Kochdumper, S. Bak and M. Althoff. Fully Automated Verification of Linear Systems Using Inner and Outer                   Approximations of Reachable Sets. Transactions on Automatic Control 68, 7771–7786 (2023).\n\n\n\nX. Yang and J. K. Scott. A comparison of zonotope order reduction techniques. Automatica 95, 378–384 (2018).\n\n\n\n","category":"page"},{"location":"lib/sets/LineSegment/#def_LineSegment","page":"LineSegment","title":"Line segment (LineSegment)","text":"","category":"section"},{"location":"lib/sets/LineSegment/#LazySets.LineSegmentModule.LineSegment","page":"LineSegment","title":"LazySets.LineSegmentModule.LineSegment","text":"LineSegment{N, VN<:AbstractVector{N}} <: AbstractZonotope{N}\n\nType that represents a line segment in 2D between two points p and q.\n\nFields\n\np – first point\nq – second point\n\nExamples\n\nA line segment along the x = y diagonal:\n\njulia> s = LineSegment([0., 0], [1., 1.])\nLineSegment{Float64, Vector{Float64}}([0.0, 0.0], [1.0, 1.0])\n\njulia> dim(s)\n2\n\nUse plot(s) to plot the extreme points of s and the line segment joining them. If it is desired to remove the endpoints, pass the options markershape=:none and seriestype=:shape.\n\nMembership is checked with ∈ (in):\n\njulia> [0., 0] ∈ s && [.25, .25] ∈ s && [1., 1] ∈ s && [.5, .25] ∉ s\ntrue\n\nWe can check whether the intersection with another line segment is empty, and optionally compute a witness (which is the unique common point in this case):\n\njulia> sn = LineSegment([1., 0], [0., 1.])\nLineSegment{Float64, Vector{Float64}}([1.0, 0.0], [0.0, 1.0])\n\njulia> isdisjoint(s, sn)\nfalse\n\njulia> isdisjoint(s, sn, true)\n(false, [0.5, 0.5])\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/LineSegment/#LazySets.API.an_element-Tuple{LazySets.API.LazySet}-lib-sets-LineSegment","page":"LineSegment","title":"LazySets.API.an_element","text":"an_element(X::LazySet)\n\nReturn some element of a nonempty set.\n\nInput\n\nX – set\n\nOutput\n\nAn element of X unless X is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.API.an_element-Tuple{LineSegment}","page":"LineSegment","title":"LazySets.API.an_element","text":"Extended help\n\nan_element(L::LineSegment)\n\nAlgorithm\n\nThe output is the first vertex of the line segment.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}-lib-sets-LineSegment","page":"LineSegment","title":"LazySets.API.constraints_list","text":"constraints_list(X::LazySet)\n\nCompute a list of linear constraints of a polyhedral set.\n\nInput\n\nX – polyhedral set\n\nOutput\n\nA list of the linear constraints of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.API.constraints_list-Tuple{LineSegment}","page":"LineSegment","title":"LazySets.API.constraints_list","text":"Extended help\n\nconstraints_list(L::LineSegment)\n\nAlgorithm\n\nL is defined by 4 constraints. In this algorithm, the first two constraints are returned by halfspace_right and halfspace_left, and the other two are obtained by considering a vector parallel to the line segment passing through one of the vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.generators-Tuple{LineSegment}","page":"LineSegment","title":"LazySets.generators","text":"generators(L::LineSegment)\n\nReturn an iterator over the (single) generator of a 2D line segment.\n\nInput\n\nL – 2D line segment\n\nOutput\n\nAn iterator over the generator of L, if any.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.genmat-Tuple{LineSegment}","page":"LineSegment","title":"LazySets.genmat","text":"genmat(L::LineSegment)\n\nReturn the generator matrix of a 2D line segment.\n\nInput\n\nL – 2D line segment\n\nOutput\n\nA matrix with at most one column representing the generator of L.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.HalfSpaceModule.halfspace_left-Tuple{LineSegment}","page":"LineSegment","title":"LazySets.HalfSpaceModule.halfspace_left","text":"halfspace_left(L::LineSegment)\n\nReturn a half-space describing the 'left' of a two-dimensional 2D line segment through two points.\n\nInput\n\nL – 2D line segment\n\nOutput\n\nThe half-space whose boundary goes through the two points p and q and which describes the left-hand side of the directed line segment pq.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.HalfSpaceModule.halfspace_right-Tuple{LineSegment}","page":"LineSegment","title":"LazySets.HalfSpaceModule.halfspace_right","text":"halfspace_right(L::LineSegment)\n\nReturn a half-space describing the 'right' of a two-dimensional 2D line segment through two points.\n\nInput\n\nL – 2D line segment\n\nOutput\n\nThe half-space whose boundary goes through the two points p and q and which describes the right-hand side of the directed line segment pq.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.ngens-Tuple{LineSegment}","page":"LineSegment","title":"LazySets.ngens","text":"ngens(L::LineSegment)\n\nReturn the number of generators of a 2D line segment.\n\nInput\n\nL – 2D line segment\n\nOutput\n\nThe number of generators.\n\nAlgorithm\n\nA line segment has either one generator, or zero generators if it is a degenerated line segment of length zero.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-LineSegment","page":"LineSegment","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#Base.rand-Tuple{Type{LineSegment}}","page":"LineSegment","title":"Base.rand","text":"Extended help\n\nrand(::Type{LineSegment}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-LineSegment","page":"LineSegment","title":"Base.:∈","text":"∈(x::AbstractVector, X::LazySet)\n\nCheck whether a point lies in a set.\n\nInput\n\nx – point/vector\nX – set\n\nOutput\n\ntrue iff x  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#Base.:∈-Tuple{AbstractVector, LineSegment}","page":"LineSegment","title":"Base.:∈","text":"Extended help\n\n∈(x::AbstractVector, L::LineSegment)\n\nAlgorithm\n\nLet L = (p q) be the line segment with extreme points p and q, and let x be the given point.\n\nA necessary condition for x  (p q) is that the three points are aligned, thus their cross product should be zero.\nIt remains to check that x belongs to the box approximation of L. This amounts to comparing each coordinate with those of the extremes p and q.\n\nNotes\n\nThe algorithm is inspired from here.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-LineSegment","page":"LineSegment","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.API.σ-Tuple{AbstractVector, LineSegment}","page":"LineSegment","title":"LazySets.API.σ","text":"Extended help\n\nσ(d::AbstractVector, L::LineSegment)\n\nAlgorithm\n\nIf the angle between the vector q - p and d is bigger than 90° and less than 270° (measured in counter-clockwise order), the result is p, otherwise it is q. If the angle is exactly 90° or 270°, or if the direction has norm zero, this implementation returns q.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.API.translate-Tuple{LazySets.API.LazySet, AbstractVector}-lib-sets-LineSegment","page":"LineSegment","title":"LazySets.API.translate","text":"translate(X::LazySet, v::AbstractVector)\n\nCompute the translation of a set with a vector.\n\nInput\n\nX – set\nv – vector\n\nOutput\n\nA set representing X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.API.translate-Tuple{LineSegment, AbstractVector}","page":"LineSegment","title":"LazySets.API.translate","text":"Extended help\n\ntranslate(L::LineSegment, v::AbstractVector)\n\nAlgorithm\n\nWe add the vector to both defining points of the line segment.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.API.intersection-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-sets-LineSegment","page":"LineSegment","title":"LazySets.API.intersection","text":"intersection(X::LazySet, Y::LazySet)\n\nCompute the intersection of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the intersection X  Y.\n\nNotes\n\nThe intersection of two sets X and Y is defined as\n\n    X  Y = x mid x  X text and  x  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.API.intersection-Tuple{LineSegment, LineSegment}","page":"LineSegment","title":"LazySets.API.intersection","text":"Extended help\n\nintersection(LS1::LineSegment, LS2::LineSegment)\n\nOutput\n\nA Singleton, a LineSegment, or an EmptySet depending on the result of the intersection.\n\nNotes\n\nIf the line segments cross, or are parallel and have a single point in common, that point is returned.\nIf the line segments are parallel and have a line segment in common, that segment is returned.\nOtherwise, there is no intersection and the empty set is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#Base.isdisjoint","page":"LineSegment","title":"Base.isdisjoint","text":"Extended help\n\nisdisjoint(L1::LineSegment, L2::LineSegment, [witness]::Bool=false)\n\nAlgorithm\n\nThe algorithm is inspired from here, which itself is the special 2D case of a 3D algorithm from Goldman [Gol90].\n\nWe first check if the two line segments are parallel, and if so, if they are collinear. In the latter case, we check membership of any of the end points in the other line segment. Otherwise the lines are not parallel, so we can solve an equation of the intersection point, if it exists.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"center\ndim\nisoperationtype\nvertices_list\nscale\nscale!\nρ","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nsample\nconvex_hull\n≈\n==\nisequivalent\n⊂","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"high\nhigh\nispolyhedral\nlow\nlow","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"isbounded\nisboundedtype\nvolume","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"center\nextrema\nextrema\nisempty\nisuniversal","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"order\nreflect\nremove_redundant_generators\ntogrep\nlinear_map\nproject\nreduce_order\nsplit\nsplit\ncartesian_product\nminkowski_difference\nminkowski_sum","category":"page"},{"location":"lib/sets/Tetrahedron/#def_Tetrahedron","page":"Tetrahedron","title":"Tetrahedron","text":"","category":"section"},{"location":"lib/sets/Tetrahedron/#LazySets.TetrahedronModule.Tetrahedron","page":"Tetrahedron","title":"LazySets.TetrahedronModule.Tetrahedron","text":"Tetrahedron{N, VN<:AbstractVector{N}, VT<:AbstractVector{VN}} <: AbstractPolytope{N}\n\nType that represents a (3-dimensional) tetrahedron in vertex representation.\n\nFields\n\nvertices – list of vertices\n\nExamples\n\nA tetrahedron can be constructed by passing the list of vertices. The following builds the tetrahedron with edge length 2 from the wikipedia page Tetrahedron:\n\njulia> vertices = [[1, 0, -1/sqrt(2)], [-1, 0, -1/sqrt(2)], [0, 1, 1/sqrt(2)], [0, -1, 1/sqrt(2)]];\n\njulia> T = Tetrahedron(vertices);\n\njulia> dim(T)\n3\n\njulia> zeros(3) ∈ T\ntrue\n\njulia> σ(ones(3), T)\n3-element Vector{Float64}:\n 0.0\n 1.0\n 0.7071067811865475\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Tetrahedron/#Operations","page":"Tetrahedron","title":"Operations","text":"","category":"section"},{"location":"lib/sets/Tetrahedron/#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-Tetrahedron","page":"Tetrahedron","title":"Base.:∈","text":"∈(x::AbstractVector, X::LazySet)\n\nCheck whether a point lies in a set.\n\nInput\n\nx – point/vector\nX – set\n\nOutput\n\ntrue iff x  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Tetrahedron/#Base.:∈-Tuple{AbstractVector, Tetrahedron}","page":"Tetrahedron","title":"Base.:∈","text":"Extended help\n\n∈(x::AbstractVector, T::Tetrahedron)\n\nAlgorithm\n\nFor each plane of the tetrahedron, we check if the point x is on the same side as the remaining vertex. We need to check this for each plane.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Tetrahedron/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-Tetrahedron","page":"Tetrahedron","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Tetrahedron/#LazySets.API.σ-Tuple{AbstractVector, Tetrahedron}","page":"Tetrahedron","title":"LazySets.API.σ","text":"Extended help\n\nσ(d::AbstractVector, T::Tetrahedron)\n\nAlgorithm\n\nThis method falls back to the VPolytope implementation.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Tetrahedron/","page":"Tetrahedron","title":"Tetrahedron","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/Tetrahedron/","page":"Tetrahedron","title":"Tetrahedron","text":"constraints_list\ndim\nisoperationtype\nrand","category":"page"},{"location":"lib/sets/Tetrahedron/","page":"Tetrahedron","title":"Tetrahedron","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Tetrahedron/","page":"Tetrahedron","title":"Tetrahedron","text":"complement\narea\nchebyshev_center_radius\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nlinear_map\nsample\nscale\nρ\ntranslate\ncartesian_product\nconvex_hull\nexact_sum\n≈\n==\nisequivalent\n⊂\nminkowski_difference","category":"page"},{"location":"lib/sets/Tetrahedron/","page":"Tetrahedron","title":"Tetrahedron","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/Tetrahedron/","page":"Tetrahedron","title":"Tetrahedron","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/Tetrahedron/","page":"Tetrahedron","title":"Tetrahedron","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/Tetrahedron/","page":"Tetrahedron","title":"Tetrahedron","text":"an_element\nextrema\nextrema\nhigh\nhigh\nlow\nlow\nvertices_list\nproject\nintersection\nisdisjoint","category":"page"},{"location":"lib/sets/Tetrahedron/","page":"Tetrahedron","title":"Tetrahedron","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/Tetrahedron/","page":"Tetrahedron","title":"Tetrahedron","text":"isbounded\nisboundedtype\nisempty\nispolyhedral\nisuniversal\nvolume\n⊆\nminkowski_sum","category":"page"},{"location":"lib/concrete_binary_operations/intersection/","page":"Intersection of two sets","title":"Intersection of two sets","text":"Pages = [\"intersection.md\"]\nDepth = 3","category":"page"},{"location":"lib/concrete_binary_operations/intersection/#Intersection-of-two-sets","page":"Intersection of two sets","title":"Intersection of two sets","text":"","category":"section"},{"location":"lib/concrete_binary_operations/intersection/#LazySets.API.intersection-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-concrete_binary_operations-intersection","page":"Intersection of two sets","title":"LazySets.API.intersection","text":"intersection(X::LazySet, Y::LazySet)\n\nCompute the intersection of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the intersection X  Y.\n\nNotes\n\nThe intersection of two sets X and Y is defined as\n\n    X  Y = x mid x  X text and  x  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/intersection/#LazySets.API.intersection-Tuple{Interval, HalfSpace}","page":"Intersection of two sets","title":"LazySets.API.intersection","text":"intersection(X::Interval, hs::HalfSpace)\n\nCompute the intersection of an interval and a half-space.\n\nInput\n\nX  – interval\nhs – half-space\n\nOutput\n\nIf the sets do not intersect, the result is the empty set. If the interval is fully contained in the half-space, the result is the original interval. Otherwise the result is the interval that describes the intersection.\n\nAlgorithm\n\nWe first handle the special case that the normal vector a of hs is close to zero. Then we distinguish the cases that hs is a lower or an upper bound.\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/intersection/#LazySets.API.intersection-Tuple{Interval, LazySet}","page":"Intersection of two sets","title":"LazySets.API.intersection","text":"intersection(X::Interval, Y::LazySet)\n\nCompute the intersection of an interval and a convex set.\n\nInput\n\nX – interval\nY – convex set\n\nOutput\n\nIf the sets do not intersect, the result is the empty set. Otherwise the result is the interval that describes the intersection, which may be of type Singleton if the intersection is very small.\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/intersection/#LazySets.API.intersection-Tuple{AbstractHPolygon, AbstractHPolygon}","page":"Intersection of two sets","title":"LazySets.API.intersection","text":"intersection(P1::AbstractHPolygon, P2::AbstractHPolygon; [prune]::Bool=true)\n\nCompute the intersection of two polygons in constraint representation.\n\nInput\n\nP1    – polygon in constraint representation\nP2    – polygon in constraint representation\nprune – (optional, default: true) flag for removing redundant constraints\n\nOutput\n\nIf the polygons do not intersect, the result is the empty set. Otherwise the result is the polygon that describes the intersection.\n\nAlgorithm\n\nWe just combine the constraints of both polygons. To obtain a linear-time algorithm, we interleave the constraints. If there are two constraints with the same normal vector, we choose the tighter one.\n\nRedundancy of constraints is checked with remove_redundant_constraints!(::AbstractHPolygon).\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/intersection/#LazySets.API.intersection-Tuple{Union{VPolygon, VPolytope}, Union{VPolygon, VPolytope}}","page":"Intersection of two sets","title":"LazySets.API.intersection","text":"intersection(P1::Union{VPolygon, VPolytope}, P2::Union{VPolygon, VPolytope};\n             [backend]=nothing, [prunefunc]=nothing)\n\nCompute the intersection of two polytopes in vertex representation.\n\nInput\n\nP1        – polytope in vertex representation\nP2        – polytope in vertex representation\nbackend   – (optional, default: nothing) the backend for polyhedral                computations\nprunefunc – (optional, default: nothing) function to prune the vertices                of the result\n\nOutput\n\nA VPolytope.\n\nNotes\n\nIf prunefunc is nothing, this implementation sets it to (X -> removevredundancy!(X; tol=_ztol(eltype(P1)))).\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/intersection/#LazySets.API.intersection-Tuple{UnionSet, LazySet}","page":"Intersection of two sets","title":"LazySets.API.intersection","text":"Extended help\n\nintersection(cup::UnionSet, X::LazySet)\n\nOutput\n\nThe union of the pairwise intersections, expressed as a UnionSet. If one of those sets is empty, only the other set is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/intersection/#LazySets.API.intersection-Tuple{AbstractPolyhedron, ResetMap}","page":"Intersection of two sets","title":"LazySets.API.intersection","text":"Extended help\n\nintersection(P::AbstractPolyhedron, rm::ResetMap)\n\nNotes\n\nThis method assumes that rm is polyhedral, i.e., has a constraints_list method defined.\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/intersection/#LazySets.API.intersection-Tuple{CartesianProductArray, CartesianProductArray}","page":"Intersection of two sets","title":"LazySets.API.intersection","text":"    intersection(X::CartesianProductArray, Y::CartesianProductArray)\n\nCompute the intersection between Cartesian products of a finite number of sets with identical decomposition.\n\nInput\n\nX – Cartesian product of a finite number of sets\nY – Cartesian product of a finite number of sets\n\nOutput\n\nThe decomposed set that represents the concrete intersection of X and Y.\n\nAlgorithm\n\nThis algorithm intersects the corresponding blocks of the sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/intersection/#LazySets.API.intersection-Tuple{CartesianProductArray, AbstractPolyhedron}","page":"Intersection of two sets","title":"LazySets.API.intersection","text":"intersection(cpa::Union{CartesianProduct,CartesianProductArray},\n             P::AbstractPolyhedron)\n\nCompute the intersection of a Cartesian product of a finite number of polyhedral sets with a polyhedron.\n\nInput\n\ncpa – Cartesian product of a finite number of polyhedral sets\nP   – polyhedron\n\nOutput\n\nA Cartesian product of a finite number of polyhedral sets. See the Algorithm section below for details about the structure.\n\nNotes\n\nThe restriction to polyhedral sets in cpa only applies to the blocks that are actually intersected with P (see the Algorithm section below for details). All other blocks are not considered by the intersection and remain identical.\n\nAlgorithm\n\nThe underlying idea of the algorithm is to exploit the unconstrained dimensions of P. Without loss of generality, assume that cpa has the structure X  Y  Z such that only the dimensions of Y are constrained in P. By denoting a suitable projection of P to the dimensions of Y with P_Y, we have the following equivalence:\n\n    (X  Y  Z)  P = X  (Y  P_Y)  Z\n\nNote that Y may still consist of many blocks. However, due to the structural restriction of a Cartesian product, we cannot break down this set further even if P_Y is still unconstrained in some dimensions of blocks in Y. This would require a restructuring of the dimensions. Consider this example:\n\n    Y = 0 1  1 2  2 3\n    P_Y = x₁ + x₃  2\n    Y  P_Y = 0  x₁  1  x₂  2  2  x₃  x₁ + x₃  2\n\nEven though the constraints of dimension x₂ are decoupled from the rest, due to the last constraint, the Cartesian product cannot be broken down further. In particular, the result Y  P_Y is a polyhedron in this implementation.\n\nNow we explain the implementation of the above idea. We first identify the dimensions in which P is constrained. Then we identify the block dimensions of X  Y  Z such that Y has minimal dimension. Finally, we convert Y to a polyhedron and intersect it with a suitable projection of P.\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/intersection/#LazySets.API.intersection-Union{Tuple{N}, Tuple{AbstractZonotope{N}, HalfSpace{N, VN} where VN<:AbstractVector{N}}} where N","page":"Intersection of two sets","title":"LazySets.API.intersection","text":"intersection(Z::AbstractZonotope{N}, H::HalfSpace{N};\n             [backend]=default_lp_solver(N), [prune]::Bool=true) where {N}\n\nCompute the intersection between a zonotopic set and a half-space.\n\nInput\n\nZ       – zonotopic set\nH       – half-space\nbackend – (optional, default: default_lp_solver(N)) the LP solver used              for the removal of redundant constraints\nprune   – (optional, default: true) flag for removing redundant              constraints\n\nOutput\n\nIf the sets do not intersect, the output is the empty set. If the zonotopic set is fully contained in the half-space, the zonotopic set is returned. Otherwise, the output is the concrete intersection between Z and H.\n\nAlgorithm\n\nFirst there is a disjointness test. If that is negative, there is an inclusion test. If that is negative, then the concrete intersection is computed.\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/intersection/#LazySets.intersection!-Tuple{Star, HalfSpace}","page":"Intersection of two sets","title":"LazySets.intersection!","text":"intersection!(X::Star, H::HalfSpace)\n\nCompute the intersection between a star set and a half-space, in-place.\n\nInput\n\nX – star set\nH – half-space\n\nOutput\n\nThe modified star set.\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/intersection/#LazySets._bound_intersect_2D-Tuple{Zonotope, Line2D}","page":"Intersection of two sets","title":"LazySets._bound_intersect_2D","text":"_bound_intersect_2D(Z::Zonotope, L::Line2D)\n\nEvaluate the support function in the direction [0, 1] of the intersection between the given zonotope and line.\n\nInput\n\nZ – zonotope\nL – vertical 2D line\n\nOutput\n\nThe support function in the direction [0, 1] of the intersection between the given zonotope and line.\n\nNotes\n\nThe algorithm assumes that the given line is vertical and that the intersection between the given sets is not empty.\n\nAlgorithm\n\nThis function implements Guernic [Gue09], Algorithm 8.2.\n\n\n\n\n\n","category":"method"},{"location":"lib/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"lib/utils/#Array-set-types","page":"Utilities","title":"Array set types","text":"","category":"section"},{"location":"lib/utils/#LazySets.flatten","page":"Utilities","title":"LazySets.flatten","text":"flatten(X::LazySets.AbstractArraySet)\n\nFlatten an array set, i.e., resolve potential nestings.\n\nExamples\n\njulia> E1 = EmptySet(1); E2 = EmptySet(2); E3 = EmptySet(3);\n\njulia> X = MinkowskiSumArray([E1, MinkowskiSumArray([E2, E2])])\nMinkowskiSumArray{Float64, LazySet{Float64}}(LazySet{Float64}[∅(1), MinkowskiSumArray{Float64, ∅}(∅[∅(2), ∅(2)])])\n\njulia> flatten(X)\nMinkowskiSumArray{Float64, ∅}(∅[∅(1), ∅(2), ∅(2)])\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.neutral","page":"Utilities","title":"LazySets.neutral","text":"neutral(T::Type{<:LazySet})\n\nGet the neutral set type for a lazy binary operation, if any.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.absorbing","page":"Utilities","title":"LazySets.absorbing","text":"absorbing(T::Type{<:LazySet})\n\nGet the absorbing set type for a lazy binary operation, if any.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#Internal-helper-macros","page":"Utilities","title":"Internal helper macros","text":"","category":"section"},{"location":"lib/utils/#LazySets.@neutral","page":"Utilities","title":"LazySets.@neutral","text":"@neutral(SET, NEUT)\n\nCreate methods to make a lazy set operation commutative with a given neutral-element set type.\n\nInput\n\nSET  – set type of lazy operation\nNEUT – set type of neutral element\n\nOutput\n\nNothing.\n\nNotes\n\nThis macro generates four functions (possibly two more if @absorbing has been used in advance, and possibly two or four more if @declare_array_version has been used in advance).\n\nExamples\n\n@neutral(MinkowskiSum, N) creates at least the following methods:\n\nneutral(::MinkowskiSum) = N\nMinkowskiSum(X, N) = X\nMinkowskiSum(N, X) = X\nMinkowskiSum(N, N) = N\n\n\n\n\n\n","category":"macro"},{"location":"lib/utils/#LazySets.@absorbing","page":"Utilities","title":"LazySets.@absorbing","text":"@absorbing(SET, ABS)\n\nCreate methods to make a lazy set operation commutative with a given absorbing-element set type.\n\nInput\n\nSET – set type of lazy operation\nABS – set type of absorbing element\n\nOutput\n\nNothing.\n\nNotes\n\nThis macro generates four functions (possibly two more if @neutral has been used in advance, and possibly two or four more if @declare_array_version has been used in advance).\n\nExamples\n\n@absorbing(MinkowskiSum, A) creates at least the following methods:\n\nabsorbing(::MinkowskiSum) = A\nMinkowskiSum(X, A) = A\nMinkowskiSum(A, X) = A\nMinkowskiSum(A, A) = A\n\n\n\n\n\n","category":"macro"},{"location":"lib/utils/#LazySets.@neutral_absorbing","page":"Utilities","title":"LazySets.@neutral_absorbing","text":"@neutral_absorbing(SET, NEUT, ABS)\n\nCreate two methods to avoid method ambiguities for a lazy set operation with respect to neutral-element and absorbing-element set types.\n\nInput\n\nSET  – set type of lazy operation\nNEUT – set type of neutral element\nABS  – set type of absorbing element\n\nOutput\n\nA quoted expression containing the function definitions.\n\nNotes\n\nThis macro is used internally in other macros.\n\nExamples\n\n@neutral_absorbing(MinkowskiSum, N, A) creates the following methods as quoted expressions:\n\nMinkowskiSum(N, A) = A\nMinkowskiSum(A, N) = A\n\n\n\n\n\n","category":"macro"},{"location":"lib/utils/#LazySets.@declare_binary_operation","page":"Utilities","title":"LazySets.@declare_binary_operation","text":"@declare_binary_operation(SET)\n\nCreate common methods for binary set operations.\n\nInput\n\nSET – set type of the lazy operation\n\nOutput\n\nNothing.\n\nNotes\n\nThis macro generates seven methods. See the example below.\n\nExamples\n\n@declare_binary_operation(MinkowskiSum) creates the following methods:\n\niterate(::MinkowskiSum)\nlength(::MinkowskiSum)\ngetindex(::MinkowskiSum, ::Int)\ngetindex(::MinkowskiSum, ::AbstractVector{Int})\nlastindex(::MinkowskiSum)\narray(::MinkowskiSum)\nis_array_constructor(::Type{MinkowskiSum})\n\n\n\n\n\n","category":"macro"},{"location":"lib/utils/#LazySets.@declare_array_version","page":"Utilities","title":"LazySets.@declare_array_version","text":"@declare_array_version(SET, SETARR)\n\nCreate methods to connect a lazy set operation with its array set type.\n\nInput\n\nSET    – set type of lazy operation\nSETARR – set type of array version\n\nOutput\n\nNothing.\n\nNotes\n\nThis macro generates six methods (and possibly up to eight more if @neutral/@absorbing has been used in advance for the base and/or array set type). See the example below.\n\nExamples\n\n@declare_array_version(MinkowskiSum, MinkowskiSumArray) creates at least the following methods:\n\narray_constructor(::Type{MinkowskiSum}) = MinkowskiSumArray\nbinary_constructor(::Type{MinkowskiSumArray}) = MinkowskiSum\nis_array_constructor(::Type{MinkowskiSumArray}) = true\nMinkowskiSum!(X, Y)\nMinkowskiSum!(X, arr)\nMinkowskiSum!(arr, X)\nMinkowskiSum!(arr1, arr2)\n\n\n\n\n\n","category":"macro"},{"location":"lib/utils/#LazySets.@array_neutral","page":"Utilities","title":"LazySets.@array_neutral","text":"@array_neutral(FUN, NEUT, SETARR)\n\nCreate two methods to avoid method ambiguities for a lazy set operation with respect to the neutral-element set type and the array set type.\n\nInput\n\nFUN     – function name\nNEUT    – set type of neutral element\nSETARR  – set type of array version\n\nOutput\n\nA quoted expression containing the function definitions.\n\nExamples\n\n@array_neutral(MinkowskiSum, N, ARR) creates the following methods as quoted expressions:\n\nMinkowskiSum(N, ARR) = ARR\nMinkowskiSum(ARR, N) = ARR\n\n\n\n\n\n","category":"macro"},{"location":"lib/utils/#LazySets.@array_absorbing","page":"Utilities","title":"LazySets.@array_absorbing","text":"@array_absorbing(FUN, ABS, SETARR)\n\nCreate two methods to avoid method ambiguities for a lazy set operation with respect to the absorbing-element set type and the array set type.\n\nInput\n\nFUN     – function name\nABS     – set type of absorbing element\nSETARR  – set type of array version\n\nOutput\n\nA quoted expression containing the function definitions.\n\nExamples\n\n@array_absorbing(MinkowskiSum, ABS, ARR) creates the following methods as quoted expressions:\n\nMinkowskiSum(ABS, ARR) = ABS\nMinkowskiSum(ARR, ABS) = ABS\n\n\n\n\n\n","category":"macro"},{"location":"lib/utils/#Types","page":"Utilities","title":"Types","text":"","category":"section"},{"location":"lib/utils/#LazySets.CachedPair","page":"Utilities","title":"LazySets.CachedPair","text":"CachedPair{N}\n\nA mutable pair of an index and a vector.\n\nFields\n\nidx – index\nvec – vector\n\n\n\n\n\n","category":"type"},{"location":"lib/utils/#Inspection-of-set-interfaces","page":"Utilities","title":"Inspection of set interfaces","text":"","category":"section"},{"location":"lib/utils/#LazySets.implementing_sets","page":"Utilities","title":"LazySets.implementing_sets","text":"implementing_sets(op::Function;\n                  signature::Tuple{Vector{Type}, Int}=(Type[], 1),\n                  type_args=Float64, binary::Bool=false)\n\nCompute a dictionary containing information about availability of (unary or binary) concrete set operations.\n\nInput\n\nop        – set operation (respectively its Function object)\nsignature – (optional, default: Type[]) the type signature of the                function without the LazySet type(s) (see also the index                option and the Examples section below)\nindex     – (optional, default: 1) index of the set type in the signature                in the unary case (see the binary option)\ntype_args – (optional, default: Float64) type arguments added to the                LazySet(s) when searching for available methods; valid                inputs are a type or nothing, and in the unary case (see the                binary option) it can also be a list of types\nbinary    – (optional, default: false) flag indicating whether op is a                binary function (true) or a unary function (false)\n\nOutput\n\nA dictionary with three keys each mapping to a list:\n\n\"available\" – This list contains all set types such that there exists an                  implementation of op.\n\"missing\"   – This list contains all set types such that there does not                  exist an implementation of op. Note that this is the                  complement of the \"available\" list.\n\"specific\"  – This list contains all set types such that there exists a                  type-specific implementation. Note that those set types also                  occur in the \"available\" list.\n\nIn the unary case, the lists contain set types. In the binary case, the lists contain pairs of set types.\n\nExamples\n\nshape_matrix is only available for ellipsoids.\n\njulia> using LazySets: implementing_sets\n\njulia> dict = implementing_sets(shape_matrix);\n\njulia> dict[\"available\"]\n1-element Vector{Type}:\n Ellipsoid\n\nEvery convex set type implements the function σ.\n\njulia> dict = implementing_sets(σ; signature=Type[AbstractVector], index=2);\n\njulia> dict[\"missing\"]\n5-element Vector{Type}:\n Complement\n DensePolynomialZonotope\n QuadraticMap\n SimpleSparsePolynomialZonotope\n SparsePolynomialZonotope\n\nSome operations are not available for sets with rational numbers.\n\njulia> N = Rational{Int};\n\njulia> dict = implementing_sets(σ; signature=Type[AbstractVector{N}], index=2, type_args=N);\n\njulia> Ball2 ∈ dict[\"missing\"]\ntrue\n\nFor binary functions, the dictionary contains pairs of set types. This check takes several seconds because it considers all possible set-type combinations.\n\njulia> dict = LazySets.implementing_sets(convex_hull; binary=true);\n\njulia> (HPolytope, HPolytope) ∈ dict[\"available\"]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#Polyhedra","page":"Utilities","title":"Polyhedra","text":"","category":"section"},{"location":"lib/utils/#LazySets.isfeasible","page":"Utilities","title":"LazySets.isfeasible","text":"isfeasible(A::AbstractMatrix, b::AbstractVector, [witness]::Bool=false;\n           [solver]=nothing)\n\nCheck for feasibility of linear constraints given in matrix-vector form.\n\nInput\n\nA       – constraints matrix\nb       – constraints vector\nwitness – (optional; default: false) flag for witness production\nsolver  – (optional; default: nothing) LP solver\n\nOutput\n\nIf witness is false, the result is a Bool.\n\nIf witness is true, the result is a pair (res, w) where res is a Bool and w is a witness point/vector.\n\nAlgorithm\n\nThis implementation solves the corresponding feasibility linear program.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#File-formats","page":"Utilities","title":"File formats","text":"","category":"section"},{"location":"lib/utils/#LazySets.read_gen-Tuple{String}","page":"Utilities","title":"LazySets.read_gen","text":"read_gen(filename::String)\n\nRead a sequence of polygons stored in vertex representation (gen format).\n\nInput\n\nfilename – path of the file containing the polygons\n\nOutput\n\nA list of polygons in vertex representation.\n\nNotes\n\nThe x and y coordinates of each vertex should be separated by an empty space and polygons are separated by empty lines (even the last polygon). For example:\n\n1.01 1.01\n0.99 1.01\n0.99 0.99\n1.01 0.99\n\n0.908463 1.31047\n0.873089 1.31047\n0.873089 1.28452\n0.908463 1.28452\n\n\n\nThis is parsed as\n\n2-element Array{VPolygon{Float64, Vector{Float64}},1}:\n VPolygon{Float64, Vector{Float64}}([[1.01, 1.01], [0.99, 1.01], [0.99, 0.99], [1.01, 0.99]])\n VPolygon{Float64, Vector{Float64}}([[0.908463, 1.31047], [0.873089, 1.31047], [0.873089, 1.28452], [0.908463, 1.28452]])\n\n\n\n\n\n","category":"method"},{"location":"lib/utils/#Sampling","page":"Utilities","title":"Sampling","text":"","category":"section"},{"location":"lib/utils/#LazySets._sample_unit_nsphere_muller!","page":"Utilities","title":"LazySets._sample_unit_nsphere_muller!","text":"_sample_unit_nsphere_muller!(D::Vector{Vector{N}}, n::Int, p::Int;\n                             [rng]::AbstractRNG=GLOBAL_RNG,\n                             [seed]::Union{Int, Nothing}=nothing) where {N}\n\nDraw samples from a uniform distribution on an n-dimensional unit sphere using Muller's method.\n\nInput\n\nD    – output, vector of points\nn    – dimension of the sphere\np    – number of random samples\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nThe modified vector D.\n\nAlgorithm\n\nThis function implements Muller's method of normalized Gaussians Muller [Mul59] to uniformly sample over the n-dimensional sphere S^n (which is the bounding surface of the n-dimensional unit ball).\n\nGiven n canonical Gaussian random variables Z₁ Z₂  Z_n, the distribution of the vectors\n\ndfrac1αleft(z₁ z₂  z_nright)^T\n\nwhere α = sqrtz₁² + z₂² +  + z_n², is uniform over S^n.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.API.sample","page":"Utilities","title":"LazySets.API.sample","text":"sample(X::LazySet, [m]::Int=1;\n       [rng]::AbstractRNG=GLOBAL_RNG,\n       [seed]::Union{Int,Nothing}=nothing)\n\nCompute random samples from a set.\n\nInput\n\nX    – set\nm    – (optional; default: 1) number of random samples\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA vector of m elements in X if X is nonempty, and an error otherwise.\n\n\n\n\n\nExtended help\n\nsample(B::Ball2, [nsamples]::Int;\n       [rng]::AbstractRNG=GLOBAL_RNG,\n       [seed]::Union{Int, Nothing}=nothing)\n\nAlgorithm\n\nRandom sampling with uniform distribution in B is computed using Muller's method of normalized Gaussians. This method requires the package Distributions. See _sample_unit_nball_muller! for implementation details.\n\n\n\n\n\nsample(X::LazySet{N}, num_samples::Int;\n       [sampler]=_default_sampler(X),\n       [rng]::AbstractRNG=GLOBAL_RNG,\n       [seed]::Union{Int, Nothing}=nothing,\n       [include_vertices]=false,\n       [VN]=Vector{N}) where {N}\n\nRandom sampling of an arbitrary set X.\n\nInput\n\nX           – set to be sampled\nnum_samples – number of random samples\nsampler     – (optional, default: _default_sampler(X)) the sampler used;                  falls back to CombinedSampler\nrng         – (optional, default: GLOBAL_RNG) random number generator\nseed        – (optional, default: nothing) seed for reseeding\ninclude_vertices – (optional, default: false) option to include the                  vertices of X\nVN          – (optional, default: Vector{N}) vector type of the sampled                  points\n\nOutput\n\nA vector of num_samples vectors. If num_samples is not passed, the result is just one sample (not wrapped in a vector).\n\nAlgorithm\n\nSee the documentation of the respective Sampler.\n\nNotes\n\nIf include_vertices == true, we include all vertices computed with vertices. Alternatively if a number k is passed, we plot the first k vertices returned by vertices(X).\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.AbstractSampler","page":"Utilities","title":"LazySets.AbstractSampler","text":"AbstractSampler\n\nAbstract type for defining new sampling methods.\n\nNotes\n\nAll subtypes should implement a sample!(D, X, ::Method) method where the first argument is the output (vector of vectors), the second argument is the set to be sampled, and the third argument is the sampler instance.\n\n\n\n\n\n","category":"type"},{"location":"lib/utils/#LazySets.CombinedSampler","page":"Utilities","title":"LazySets.CombinedSampler","text":"CombinedSampler <: AbstractSampler\n\nType used for sampling arbitrary sets by trying different sampling strategies.\n\nAlgorithm\n\nThe algorithm is to first try a RejectionSampler 10 times. If that fails, it tries a RandomWalkSampler.\n\n\n\n\n\n","category":"type"},{"location":"lib/utils/#LazySets.FaceSampler","page":"Utilities","title":"LazySets.FaceSampler","text":"FaceSampler <: AbstractSampler\n\nType used for sampling from the k-faces of a set.\n\nFields\n\ndim – dimension of the faces to be sampled; a negative number is          interpreted as n - dim where n is the dimension of the set\n\nNotes\n\nFor a three-dimensional polytope, the following face dimensions exist:\n\n3-face – the polytope itself\n2-faces – 2-dimensional polygonal faces\n1-faces – 1-dimensional edges\n0-faces – 0-dimensional vertices\n\nFor more information see Wikipedia.\n\nAlgorithm\n\nCurrently only hyperrectangles are supported. For each point to be sampled, we randomly split the integers 1 .. n into two subgroups of size k and n-k respectively. For the i-th coordinate in the first group, we sample in the interval low(H, i) .. high(H, i). For the i-th coordinate in the second group, we randomly pick either low(H, i) or high(H, i).\n\n\n\n\n\n","category":"type"},{"location":"lib/utils/#LazySets.HalfSpaceSampler","page":"Utilities","title":"LazySets.HalfSpaceSampler","text":"HalfSpaceSampler{D} <: AbstractSampler\n\nType used for sampling from a half-space.\n\nFields\n\ndistribution – (optional, default: nothing) distribution from which                   samples are drawn\n\nNotes\n\nIf distribution is nothing (default), the sampling algorithm uses a DefaultUniform over 0 1^n.\n\n\n\n\n\n","category":"type"},{"location":"lib/utils/#LazySets.HyperplaneSampler","page":"Utilities","title":"LazySets.HyperplaneSampler","text":"HyperplaneSampler{D} <: AbstractSampler\n\nType used for sampling from a hyperplane.\n\nFields\n\ndistribution – (optional, default: nothing) distribution from which                   samples are drawn\n\nNotes\n\nIf distribution is nothing (default), the sampling algorithm uses a DefaultUniform over 0 1^n.\n\n\n\n\n\n","category":"type"},{"location":"lib/utils/#LazySets.SingletonSampler","page":"Utilities","title":"LazySets.SingletonSampler","text":"SingletonSampler <: AbstractSampler\n\nType used for sampling from a singleton.\n\n\n\n\n\n","category":"type"},{"location":"lib/utils/#LazySets.RejectionSampler","page":"Utilities","title":"LazySets.RejectionSampler","text":"RejectionSampler{D} <: AbstractSampler\n\nType used for rejection sampling of a bounded set X.\n\nFields\n\ndistribution – (optional, default: DefaultUniform) distribution from                   which the sample is drawn\ntight        – (optional, default: false) set to true if the support of                   the distribution is known to coincide with the set X\nmaxiter      – (optional, default: Inf) maximum number of iterations                   before giving up\n\nAlgorithm\n\nDraw a sample x from a given distribution of a box-overapproximation of the original set X in all n dimensions. The function rejects a drawn sample x and redraws as long as the sample is not contained in the original set X, i.e., while x  X.\n\nNotes\n\nThe maxiter parameter is useful when sampling from sets that are small compared to their box approximation, e.g., flat sets, for which the probability of sampling from within the set is close to zero.\n\n\n\n\n\n","category":"type"},{"location":"lib/utils/#LazySets.RandomWalkSampler","page":"Utilities","title":"LazySets.RandomWalkSampler","text":"RandomWalkSampler <: AbstractSampler\n\nType used for sampling from a convex polytope using its vertex representation. This is especially useful if rejection sampling does not work because the polytope is flat.\n\nFields\n\nvariant – (optional, default: true) choice of a variant (see below)\n\nNotes\n\nThe sampling is not uniform - points in the center of the polytope are more likely to be sampled.\n\nThe set to be sampled from must provide its vertices via vertices_list.\n\nAlgorithm\n\nChoose a random convex combination of the vertices of a convex polytope X.\n\nIf variant == false, we proceed as follows. Let V = v_i_i denote the set of vertices of X. Then any point p  ℝ^n of the convex polytope X is a convex combination of its vertices, i.e., p = _i v_i α_i for some (non-negative) coefficients α_i_i that add up to 1. The algorithm chooses a random convex combination (the α_i). To produce this combination, we apply the finite-difference operator on a sorted uniform sample over 0 1; the method can be found in Rubin [Rub81] and this StackExchange post.\n\nIf variant == true, we start from a random vertex and then repeatedly walk toward a random vertex inside the polytope.\n\n\n\n\n\n","category":"type"},{"location":"lib/utils/#LazySets.PolynomialZonotopeSampler","page":"Utilities","title":"LazySets.PolynomialZonotopeSampler","text":"PolynomialZonotopeSampler{D} <: AbstractSampler\n\nType used for sampling from polynomial zonotopes.\n\nFields\n\ndistribution – (optional, default: nothing) distribution from which                   samples are drawn\n\nNotes\n\nIf distribution is nothing (default), the sampling algorithm uses a DefaultUniform over -1 1^n.\n\n\n\n\n\n","category":"type"},{"location":"lib/utils/#LazySets.UniverseSampler","page":"Utilities","title":"LazySets.UniverseSampler","text":"UniverseSampler{D} <: AbstractSampler\n\nType used for sampling from universal sets.\n\nFields\n\ndistribution – (optional, default: nothing) distribution from which                   samples are drawn\n\nNotes\n\nIf distribution is nothing (default), the sampling algorithm uses a DefaultUniform over -100 100^n.\n\n\n\n\n\n","category":"type"},{"location":"lib/utils/#Symbolics","page":"Utilities","title":"Symbolics","text":"","category":"section"},{"location":"lib/utils/#LazySets._vec","page":"Utilities","title":"LazySets._vec","text":"_vec(vars)\n\nTransform a tuple of operations into one vector of operations.\n\nInput\n\nvars – tuple where each element is either variable-like (Num) or a           vector of variables (Vector{Num})\n\nOutput\n\nA vector of Operation obtained by concatenating each tuple component.\n\nExamples\n\njulia> using Symbolics\n\njulia> vars = @variables x[1:2] y\n2-element Vector{Any}:\n  x[1:2]\n y\n\njulia> LazySets._vec(vars)\n3-element Vector{Num}:\n x[1]\n x[2]\n    y\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#SymEngine","page":"Utilities","title":"SymEngine","text":"","category":"section"},{"location":"lib/utils/#SymEngine.free_symbols","page":"Utilities","title":"SymEngine.free_symbols","text":"free_symbols(expr::Expr, set_type::Type{LazySet})\n\nReturn the free symbols in an expression that represents a given set type.\n\nInput\n\nexpr – symbolic expression\n\nOutput\n\nA list of symbols, in the form of SymEngine Basic objects.\n\nExamples\n\njulia> using LazySets: free_symbols\n\njulia> free_symbols(:(x1 <= -0.03), HalfSpace)\n1-element Vector{SymEngine.Basic}:\n x1\n\njulia> free_symbols(:(x1 + x2 <= 2*x4 + 6), HalfSpace)\n3-element Vector{SymEngine.Basic}:\n x2\n x1\n x4\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets._is_linear_combination","page":"Utilities","title":"LazySets._is_linear_combination","text":"islinear_combination(L::Basic)\n\nDetermine whether the expression L is a linear combination of its symbols.\n\nInput\n\nL – expression\n\nOutput\n\ntrue if L is a linear combination or false otherwise.\n\nExamples\n\njulia> using LazySets: _is_linear_combination\n\njulia> _is_linear_combination(:(2*x1 - 4))\ntrue\n\njulia> _is_linear_combination(:(6.1 - 5.3*f - 0.1*g))\ntrue\n\njulia> _is_linear_combination(:(2*x1^2))\nfalse\n\njulia> _is_linear_combination(:(x1^2 - 4*x2 + x3 + 2))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#Functions-for-numbers","page":"Utilities","title":"Functions for numbers","text":"","category":"section"},{"location":"lib/utils/#LazySets.sign_cadlag","page":"Utilities","title":"LazySets.sign_cadlag","text":"sign_cadlag(x::Real)\n\nThis function works like the sign function but is 1 for input 0.\n\nInput\n\nx – real scalar\n\nOutput\n\n1 if x  0, -1 otherwise.\n\nNotes\n\nThis is the sign function right-continuous at zero (see càdlàg function). It can be used with vector-valued arguments via the dot operator.\n\nExamples\n\njulia> LazySets.sign_cadlag.([-0.6, 1.3, 0.0])\n3-element Vector{Float64}:\n -1.0\n  1.0\n  1.0\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#Other-functions","page":"Utilities","title":"Other functions","text":"","category":"section"},{"location":"lib/utils/#LazySets.binary_search_constraints","page":"Utilities","title":"LazySets.binary_search_constraints","text":"binary_search_constraints(d::AbstractVector{N},\n                          constraints::Vector{<:HalfSpace{N}};\n                          [start_index]::Int=div(length(constraints)+1, 2),\n                          [choose_lower]::Bool=false) where {N}\n\nPerform a binary search in the constraints.\n\nInput\n\nd            – direction\nconstraints  – constraints\nstart_index  – (optional, default: div(length(constraints)+1, 2)) start                   index\nchoose_lower – (optional, default: false) flag for choosing the lower                   index (see the 'Output' section)\n\nOutput\n\nIn the default setting, the result is the smallest index k such that d ⪯ constraints[k].a, or length(constraints)+1 if no such k exists. If the choose_lower flag is set, the result is the largest index k such that constraints[k].a < d, which is equivalent to being k-1 in the normal setting.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.get_constrained_lowdimset","page":"Utilities","title":"LazySets.get_constrained_lowdimset","text":"get_constrained_lowdimset(cpa::CartesianProductArray{N, S},\n                          P::AbstractPolyhedron{N}) where {N, S}\n\nPreprocessing step for the intersection between a Cartesian product of a finite number of sets and a polyhedron.\n\nInput\n\ncpa – Cartesian product of a finite number of sets\nP   – polyhedron\n\nOutput\n\nA four-tuple of:\n\na low-dimensional CartesianProductArray in the constrained dimensions of the original set cpa\nthe variables in the constrained blocks,\nthe original block structure of the low-dimensional sets,\nthe list of the constrained blocks.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.get_radius!","page":"Utilities","title":"LazySets.get_radius!","text":"get_radius!(sih::SymmetricIntervalHull, i::Int)\n\nCompute the radius of the symmetric interval hull of a set in a given dimension.\n\nInput\n\nsih – symmetric interval hull of a set\ni   – dimension in which the radius should be computed\n\nOutput\n\nThe radius of the symmetric interval hull of a set in a given dimension.\n\nAlgorithm\n\nWe ask for the extrema of the underlying set in dimension i.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.HalfSpaceModule.is_tighter_same_dir_2D","page":"Utilities","title":"LazySets.HalfSpaceModule.is_tighter_same_dir_2D","text":"is_tighter_same_dir_2D(c1::HalfSpace,\n                       c2::HalfSpace;\n                       [strict]::Bool=false)\n\nCheck if the first of two two-dimensional constraints with equivalent normal direction is tighter.\n\nInput\n\nc1     – first linear constraint\nc2     – second linear constraint\nstrict – (optional; default: false) check for strictly tighter             constraints?\n\nOutput\n\ntrue iff the first constraint is tighter.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets._leq_trig","page":"Utilities","title":"LazySets._leq_trig","text":"_leq_trig(u::AbstractVector{N}, v::AbstractVector{N}) where {N<:AbstractFloat}\n\nCompare two 2D vectors by their direction.\n\nInput\n\nu –  first 2D direction\nv –  second 2D direction\n\nOutput\n\ntrue iff arg(u) 2π  arg(v) 2π.\n\nNotes\n\nThe argument is measured in counter-clockwise fashion, with the 0 being the direction (1, 0).\n\nAlgorithm\n\nThe implementation uses the arctangent function with sign, atan, which for two arguments implements the atan2 function.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.same_block_structure","page":"Utilities","title":"LazySets.same_block_structure","text":"same_block_structure(x::AbstractVector{S1}, y::AbstractVector{S2}\n                    ) where {S1<:LazySet, S2<:LazySet}\n\nCheck whether two vectors of sets have the same block structure, i.e., the i-th entry in the vectors have the same dimension.\n\nInput\n\nx – first vector\ny – second vector\n\nOutput\n\ntrue iff the vectors have the same block structure.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.HyperplaneModule._σ_hyperplane_halfspace","page":"Utilities","title":"LazySets.HyperplaneModule._σ_hyperplane_halfspace","text":"    _σ_hyperplane_halfspace(d::AbstractVector, a, b;\n                            [error_unbounded]::Bool=true,\n                            [halfspace]::Bool=false)\n\nReturn a support vector of a hyperplane ax = b in direction d.\n\nInput\n\nd         – direction\na         – normal direction\nb         – constraint\nerror_unbounded – (optional, default: true) true if an error should be                thrown whenever the set is unbounded in the given direction\nhalfspace – (optional, default: false) true if the support vector                should be computed for a half-space\n\nOutput\n\nA pair (v, f) where v is a vector and f is a Boolean flag.\n\nThe flag f is false in one of the following cases:\n\nThe direction has norm zero.\nThe direction is (a multiple of) the hyperplane's normal direction.\nThe direction is (a multiple of) the opposite of the hyperplane's normal\n\ndirection and halfspace is false. In all these cases, v is any point on the hyperplane.\n\nOtherwise, the flag f is true, the set is unbounded in the given direction, and v is any vector.\n\nIf error_unbounded is true and the set is unbounded in the given direction, this function throws an error instead of returning.\n\nNotes\n\nFor correctness, consider the weak duality of LPs: If the primal is unbounded, then the dual is infeasible. Since there is only a single constraint, the feasible set of the dual problem is a  y == d, y  0 (with objective function b  y). It is easy to see that this problem is infeasible whenever a is not parallel to d.\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/Intersection/#Intersection","page":"Intersection","title":"Intersection","text":"","category":"section"},{"location":"lib/lazy_operations/Intersection/#def_Intersection","page":"Intersection","title":"Binary intersection (Intersection)","text":"","category":"section"},{"location":"lib/lazy_operations/Intersection/#LazySets.Intersection","page":"Intersection","title":"LazySets.Intersection","text":"Intersection{N, S1<:LazySet{N}, S2<:LazySet{N}} <: LazySet{N}\n\nType that represents the intersection of two sets.\n\nFields\n\nX     – set\nY     – set\ncache – internal cache for avoiding recomputation; see            IntersectionCache\n\nNotes\n\nIf the arguments of the lazy intersection are half-spaces, the set is simplified to a polyhedron in constraint representation (HPolyhedron).\n\nThe intersection preserves convexity: if the set arguments are convex, then their intersection is convex as well.\n\nExamples\n\nCreate an expression Z that lazily represents the intersection of two squares X and Y:\n\njulia> X, Y = BallInf([0.0, 0.0], 0.5), BallInf([1.0, 0.0], 0.75);\n\njulia> Z = X ∩ Y;\n\njulia> typeof(Z)\nIntersection{Float64, BallInf{Float64, Vector{Float64}}, BallInf{Float64, Vector{Float64}}}\n\njulia> dim(Z)\n2\n\nWe can check if the intersection is empty with isempty:\n\njulia> isempty(Z)\nfalse\n\nDo not confuse Intersection with the concrete operation, which is computed with the lowercase intersection function:\n\njulia> W = intersection(X, Y)\nHyperrectangle{Float64, Vector{Float64}, Vector{Float64}}([0.375, 0.0], [0.125, 0.5])\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/Intersection/#Base.:∩-Tuple{LazySet, LazySet}","page":"Intersection","title":"Base.:∩","text":"∩(X::LazySet, Y::LazySet)\n\nAlias for the lazy intersection.\n\nNotes\n\nThe function symbol can be typed via \\cap<tab>.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.API.dim-Tuple{Intersection}","page":"Intersection","title":"LazySets.API.dim","text":"dim(cap::Intersection)\n\nReturn the dimension of an intersection of two sets.\n\nInput\n\ncap – intersection of two sets\n\nOutput\n\nThe ambient dimension of the intersection of two sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.API.ρ-Tuple{AbstractVector, Intersection}","page":"Intersection","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, cap::Intersection)\n\nReturn an upper bound on the support function of the intersection of two sets in a given direction.\n\nInput\n\nd   – direction\ncap – intersection of two sets\n\nOutput\n\nAn upper bound on the support function in the given direction.\n\nAlgorithm\n\nThe support function of an intersection of X and Y is upper-bounded by the minimum of the support-function evaluations for X and Y.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.API.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractVector, Intersection{N, S1, S2}}} where {N, S1<:LazySet, S2<:Union{HalfSpace, Hyperplane, Line2D}}","page":"Intersection","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, cap::Intersection{N, S1, S2};\n  algorithm::String=\"line_search\", kwargs...\n ) where {N, S1<:LazySet,\n             S2<:Union{HalfSpace, Hyperplane, Line2D}}\n\nEvaluate the support function of the intersection of a compact set and a half-space/hyperplane/line in a given direction.\n\nInput\n\nd         – direction\ncap       – lazy intersection of a compact set and a half-space/hyperplane/                line\nalgorithm – (optional, default: \"line_search\"): the algorithm to                calculate the support function; valid options are:\n\"line_search\" – solve the associated univariate optimization problem                    using a line-search method (either Brent or the                    Golden Section method)\n\"projection\"  – only valid for intersection with a hyperplane/line;                    evaluate the support function by reducing the problem                    to the 2D intersection of a rank-2 linear                    transformation of the given compact set in the plane                    generated by the given direction d and the                    hyperplane's normal vector n\n\"simple\"      – take the min of the support-function evaluation                    of each operand\n\nOutput\n\nThe scalar value of the support function of the set cap in the given direction.\n\nNotes\n\nIt is assumed that the first set of the intersection (cap.X) is compact.\n\nAny additional number of arguments to the algorithm backend can be passed as keyword arguments.\n\nAlgorithm\n\nThe algorithms are based on solving the associated optimization problem\n\nmin_λ  D_h ρ(ℓ - λa X) + λb\n\nwhere D_h =  λ  λ  0  if H is a half-space or D_h =  λ  λ  ℝ  if H is a hyperplane.\n\nFor additional information we refer to Frehse and Ray [FR12], Guernic [Gue09] and Rockafellar and Wets [RW98]\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.API.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractVector, Intersection{N, S1, S2}}} where {N, S1<:LazySet, S2<:AbstractPolyhedron}","page":"Intersection","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, cap::Intersection{N, S1, S2};\n  kwargs...) where {N, S1<:LazySet, S2<:AbstractPolyhedron}\n\nReturn an upper bound on the support function of the intersection between a compact set and a polyhedron along a given direction.\n\nInput\n\nd      – direction\ncap    – intersection of a compact set and a polyhedron\nkwargs – additional arguments that are passed to the support-function             algorithm\n\nOutput\n\nAn upper bound of the support function of the given intersection.\n\nAlgorithm\n\nThe idea is to solve the univariate optimization problem ρ(di, X ∩ Hi) for each half-space in the polyhedron and then take the minimum. This gives an overapproximation of the exact support value.\n\nThis algorithm is inspired from Frehse and Ray [FR12].\n\nNotes\n\nThis method relies on the constraints_list of the polyhedron.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.API.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractVector, Intersection{N, S1, S2}}} where {N, S1<:AbstractPolyhedron, S2<:AbstractPolyhedron}","page":"Intersection","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, cap::Intersection{N, S1, S2}; kwargs...\n ) where {N, S1<:AbstractPolyhedron, S2<:AbstractPolyhedron}\n\nEvaluate the support function of the intersection between two polyhedral sets.\n\nInput\n\nd      – direction\ncap    – intersection of two polyhedral sets\nkwargs – additional arguments that are passed to the support-function             algorithm\n\nOutput\n\nThe evaluation of the support function in the given direction.\n\nAlgorithm\n\nWe combine the constraints of the two polyhedra to a new HPolyhedron, for which we then evaluate the support function.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.API.σ-Tuple{AbstractVector, Intersection}","page":"Intersection","title":"LazySets.API.σ","text":"σ(d::AbstractVector, cap::Intersection)\n\nReturn a support vector of an intersection of two sets in a given direction.\n\nInput\n\nd   – direction\ncap – intersection of two sets\n\nOutput\n\nA support vector in the given direction.\n\nAlgorithm\n\nWe compute the concrete intersection, which may be expensive.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.API.isbounded-Tuple{Intersection}","page":"Intersection","title":"LazySets.API.isbounded","text":"isbounded(cap::Intersection)\n\nCheck whether an intersection of two sets is bounded.\n\nInput\n\ncap – intersection of two sets\n\nOutput\n\ntrue iff the intersection is bounded.\n\nAlgorithm\n\nWe first check if any of the wrapped sets is bounded. Otherwise we check boundedness via LazySets._isbounded_unit_dimensions.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#Base.isempty-Tuple{Intersection}","page":"Intersection","title":"Base.isempty","text":"isempty(cap::Intersection)\n\nCheck whether the intersection of two sets is empty.\n\nInput\n\ncap – intersection of two sets\n\nOutput\n\ntrue iff the intersection is empty.\n\nNotes\n\nThe result will be cached, so a second query will be fast.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#Base.:∈-Tuple{AbstractVector, Intersection}","page":"Intersection","title":"Base.:∈","text":"∈(x::AbstractVector, cap::Intersection)\n\nCheck whether a given point is contained in the intersection of two sets.\n\nInput\n\nx   – point/vector\ncap – intersection of two sets\n\nOutput\n\ntrue iff x  cap.\n\nAlgorithm\n\nA point x is in the intersection iff it is in each set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.API.constraints_list-Tuple{Intersection}","page":"Intersection","title":"LazySets.API.constraints_list","text":"constraints_list(cap::Intersection)\n\nReturn a list of constraints of an intersection of two (polyhedral) sets.\n\nInput\n\ncap – intersection of two (polyhedral) sets\n\nOutput\n\nA list of constraints of the intersection.\n\nNotes\n\nWe assume that the underlying sets are polyhedral, i.e., offer a method constraints_list.\n\nAlgorithm\n\nWe create the polyhedron by taking the intersection of the constraints_lists of the sets and remove redundant constraints.\n\nThis function ignores the boolean output from the in-place remove_redundant_constraints!, which may inform the user that the constraints are infeasible. In that case, the list of constraints at the moment when the infeasibility was detected is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.API.vertices_list-Tuple{Intersection}","page":"Intersection","title":"LazySets.API.vertices_list","text":"vertices_list(cap::Intersection)\n\nReturn a list of vertices of a lazy intersection of two (polyhedral) sets.\n\nInput\n\ncap – intersection of two (polyhedral) sets\n\nOutput\n\nA list containing the vertices of the lazy intersection of two sets.\n\nNotes\n\nWe assume that the underlying sets are polyhedral and that the intersection is bounded.\n\nAlgorithm\n\nWe compute the concrete intersection using intersection and then take the vertices of that representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.isempty_known-Tuple{Intersection}","page":"Intersection","title":"LazySets.isempty_known","text":"isempty_known(cap::Intersection)\n\nAsk whether the status of emptiness is known.\n\nInput\n\ncap – intersection of two sets\n\nOutput\n\ntrue iff the emptiness status is known. In this case, isempty(cap) can be used to obtain the status in constant time.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.set_isempty!-Tuple{Intersection, Bool}","page":"Intersection","title":"LazySets.set_isempty!","text":"set_isempty!(cap::Intersection, isempty::Bool)\n\nSet the status of emptiness in the cache.\n\nInput\n\ncap     – intersection of two sets\nisempty – new status of emptiness\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.swap-Tuple{Intersection}","page":"Intersection","title":"LazySets.swap","text":"swap(cap::Intersection)\n\nReturn a new Intersection object with the arguments swapped.\n\nInput\n\ncap – intersection of two sets\n\nOutput\n\nA new Intersection object with the arguments swapped. The old cache is shared between the old and new objects.\n\nNotes\n\nThe advantage of using this function instead of manually swapping the arguments is that the cache is shared.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.use_precise_ρ","page":"Intersection","title":"LazySets.use_precise_ρ","text":"use_precise_ρ(cap::Intersection)\n\nCheck whether a precise algorithm for computing ρ shall be applied.\n\nInput\n\ncap – intersection of two sets\n\nOutput\n\ntrue if a precise algorithm shall be applied.\n\nNotes\n\nThe default implementation always returns true.\n\nIf the result is false, a coarse approximation of the support function is returned.\n\nThis function can be overwritten by the user to control the policy.\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/Intersection/#LazySets._line_search","page":"Intersection","title":"LazySets._line_search","text":"_line_search(ℓ, X, H::Union{<:HalfSpace, <:Hyperplane, <:Line2D}; [kwargs...])\n\nGiven a convex set X and a half-space H = x a^T x  b  or a hyperplane/line H = x a^T x = b , calculate:\n\nmin_λ  D_h ρ(ℓ - λa X) + λb\n\nwhere D_h =  λ  λ  0  if H is a half-space or D_h =  λ  λ  ℝ  if H is a hyperplane.\n\nInput\n\nℓ – direction\nX – convex set\nH – half-space or hyperplane or line\n\nOutput\n\nThe tuple (fmin, λmin), where fmin is the minimum value of the function f(λ) = ρ(ℓ - λa) + λb over the feasible set λ  0, and λmin is the minimizer.\n\nNotes\n\nThis function requires the Optim package, and relies on the univariate optimization interface Optim.optimize(...).\n\nAdditional arguments to the optimize backend can be passed as keyword arguments. The default method is Optim.Brent().\n\nExamples\n\njulia> X = Ball1(zeros(2), 1.0);\n\njulia> H = HalfSpace([-1.0, 0.0], -1.0);  # x >= 1\n\njulia> using Optim\n\njulia> using LazySets: _line_search\n\njulia> v = _line_search([1.0, 0.0], X, H);  # uses Brent's method by default\n\njulia> v[1]\n1.0\n\nWe can specify the upper bound in Brent's method:\n\njulia> v = _line_search([1.0, 0.0], X, H, upper=1e3);\n\njulia> v[1]\n1.0\n\nInstead of Brent's method we can use the Golden Section method:\n\njulia> v = _line_search([1.0, 0.0], X, H, upper=1e3, method=GoldenSection());\n\njulia> v[1]\n1.0\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/Intersection/#LazySets._projection","page":"Intersection","title":"LazySets._projection","text":"_projection(ℓ, X::LazySet, H::Union{Hyperplane, Line2D};\n            [lazy_linear_map]=false,\n            [lazy_2d_intersection]=true,\n            [algorithm_2d_intersection]=nothing,\n            [kwargs...])\n\nGiven a convex set X and a hyperplane H = x n  x = γ , calculate the support function of the intersection between the rank-2 projection Π_nℓ X and the line Lγ = (x y) x = γ .\n\nInput\n\nℓ                    – direction\nX                    – convex set\nH                    – hyperplane\nlazy_linear_map      – (optional, default: false) flag to perform the                           projection lazily or concretely\nlazy_2d_intersection – (optional, default: true) flag to perform the 2D                           intersection between the projected set and the line                           lazily or concretely\nalgorithm_2d_intersection – (optional, default: nothing) if given, fixes                                the support-function algorithm used for the                                intersection in 2D; otherwise the default is                                used\n\nOutput\n\nThe evaluation of the support function of X  H along direction ℓ.\n\nAlgorithm\n\nThis projection method is based on Prop. 8.2, [1, page 103].\n\nIn the original algorithm, Guernic [Gue09], Section 8.2, the linear map is performed concretely and the intersection is performed lazily (these are the default options in this algorithm, but here the four combinations are available). If the set X is a zonotope, its concrete projection is again a zonotope (sometimes called \"zonogon\"). The intersection between this zonogon and the line can be taken efficiently in a lazy way (see [Gue09, Section 8.2.2]), if one uses dispatch on ρ(y_dir, Sℓ⋂Lγ; kwargs...) given that Sℓ is itself a zonotope.\n\nNotes\n\nThis function depends on the calculation of the support function of another set in two dimensions. Obviously one does not want to use algorithm=\"projection\" again for this second calculation. The option algorithm_2d_intersection is used for that: if not given, the default support-function algorithm is used (e.g., \"line_search\"). You can still pass additional arguments to the \"line_search\" backend through the kwargs arguments.\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/Intersection/#LazySets.API.linear_map-Tuple{AbstractMatrix, Intersection}","page":"Intersection","title":"LazySets.API.linear_map","text":"linear_map(M::AbstractMatrix, cap::Intersection)\n\nReturn the concrete linear map of an intersection of two sets.\n\nInput\n\nM   – matrix\ncap – intersection of two sets\n\nOutput\n\nThe set obtained by applying the given linear map to the intersection.\n\nAlgorithm\n\nThis method computes the concrete intersection.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.plot_recipe-Union{Tuple{Intersection{N, S1, S2} where {S1<:LazySet{N}, S2<:LazySet{N}}}, Tuple{N}, Tuple{Intersection{N, S1, S2} where {S1<:LazySet{N}, S2<:LazySet{N}}, N}, Tuple{Intersection{N, S1, S2} where {S1<:LazySet{N}, S2<:LazySet{N}}, N, Int64}} where N","page":"Intersection","title":"LazySets.plot_recipe","text":"plot_recipe(cap::Intersection{N}, [ε]::N=-one(N),\n            [Nφ]::Int=PLOT_POLAR_DIRECTIONS) where {N}\n\nConvert an intersection of two sets to a pair (x, y) of points for plotting.\n\nInput\n\ncap – intersection of two sets\nε   – (optional, default 0) ignored, used for dispatch\nNφ  – (optional, default: PLOT_POLAR_DIRECTIONS) number of polar          directions used in the template overapproximation\n\nOutput\n\nA pair (x, y) of points that can be plotted.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol, Any}, Intersection{N, S1, S2} where {S1<:LazySet{N}, S2<:LazySet{N}}}, Tuple{AbstractDict{Symbol, Any}, Intersection{N, S1, S2} where {S1<:LazySet{N}, S2<:LazySet{N}}, Real}, Tuple{AbstractDict{Symbol, Any}, Intersection{N, S1, S2} where {S1<:LazySet{N}, S2<:LazySet{N}}, Real, Int64}} where N","page":"Intersection","title":"RecipesBase.apply_recipe","text":"plot_intersection(cap::Intersection{N}, [ε]::Real=zero(N),\n                  [Nφ]::Int=PLOT_POLAR_DIRECTIONS) where {N}\n\nPlot a lazy intersection.\n\nInput\n\ncap  – lazy intersection\nε    – (optional, default 0) ignored, used for dispatch\nNφ   – (optional, default: PLOT_POLAR_DIRECTIONS) number of polar           directions used in the template overapproximation\n\nNotes\n\nThis function is separated from the main LazySet plot recipe because iterative refinement is not available for lazy intersections (since it uses the support vector (but see #1187)).\n\nAlso note that if the set is a nested intersection, you may have to manually overapproximate this set before plotting (see overapproximate for details).\n\nExamples\n\njulia> X = Ball2(zeros(2), 1.) ∩ Ball2(ones(2), 1.5);  # lazy intersection\n\njulia> plot(X)\n\nYou can specify the accuracy of the overapproximation of the lazy intersection by passing an explicit value for Nφ, which stands for the number of polar directions used in the overapproximation. This number can also be passed to the plot function directly.\n\njulia> plot(overapproximate(X, PolarDirections(100)))\n\njulia> plot(X, 0.0, 100)  # equivalent to the above line\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/","page":"Intersection","title":"Intersection","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/Intersection/","page":"Intersection","title":"Intersection","text":"norm\nradius\ndiameter\n[an_element](@ref an_element(::LazySet)\nsingleton_list\nreflect","category":"page"},{"location":"lib/lazy_operations/Intersection/#Intersection-cache","page":"Intersection","title":"Intersection cache","text":"","category":"section"},{"location":"lib/lazy_operations/Intersection/#LazySets.IntersectionCache","page":"Intersection","title":"LazySets.IntersectionCache","text":"IntersectionCache\n\nContainer for information cached by a lazy Intersection object.\n\nFields\n\nisempty – is the intersection empty? There are three possible states,              encoded as Int8 values -1, 0, 1:\n-1 - it is currently unknown whether the intersection is empty\n0 - intersection is not empty\n1 - intersection is empty\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/Intersection/#def_IntersectionArray","page":"Intersection","title":"n-ary intersection (IntersectionArray)","text":"","category":"section"},{"location":"lib/lazy_operations/Intersection/#LazySets.IntersectionArray","page":"Intersection","title":"LazySets.IntersectionArray","text":"IntersectionArray{N, S<:LazySet{N}} <: LazySet{N}\n\nType that represents the intersection of a finite number of sets.\n\nFields\n\narray – array of sets\n\nNotes\n\nThis type assumes that the dimensions of all elements match.\n\nThe EmptySet is the absorbing element for IntersectionArray.\n\nThe intersection preserves convexity: if the set arguments are convex, then their intersection is convex as well.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/Intersection/#LazySets.Intersection!","page":"Intersection","title":"LazySets.Intersection!","text":"Intersection!(X, Y)\n\nConvenience function to compute the lazy intersection and modify IntersectionArrays in-place.\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/Intersection/#Base.:∩-Tuple{LazySet, Vararg{LazySet}}","page":"Intersection","title":"Base.:∩","text":"∩(X::LazySet, Xs::LazySet...)\n∩(Xs::Vector{<:LazySet})\n\nAlias for the n-ary lazy intersection.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.API.dim-Tuple{IntersectionArray}","page":"Intersection","title":"LazySets.API.dim","text":"dim(ia::IntersectionArray)\n\nReturn the dimension of an intersection of a finite number of sets.\n\nInput\n\nia – intersection of a finite number of sets\n\nOutput\n\nThe ambient dimension of the intersection of a finite number of sets, or 0 if there is no set in the array.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.API.σ-Tuple{AbstractVector, IntersectionArray}","page":"Intersection","title":"LazySets.API.σ","text":"σ(d::AbstractVector, ia::IntersectionArray)\n\nReturn a support vector of an intersection of a finite number of sets in a given direction.\n\nInput\n\nd  – direction\nia – intersection of a finite number of sets\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the individual sets.\n\nAlgorithm\n\nThis implementation computes the concrete intersection, which can be expensive.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.API.isbounded-Tuple{IntersectionArray}","page":"Intersection","title":"LazySets.API.isbounded","text":"isbounded(ia::IntersectionArray)\n\nCheck whether an intersection of a finite number of sets is bounded.\n\nInput\n\nia – intersection of a finite number of sets\n\nOutput\n\ntrue iff the intersection is bounded.\n\nAlgorithm\n\nWe first check if any of the wrapped sets is bounded. Otherwise we check boundedness via LazySets._isbounded_unit_dimensions.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#Base.:∈-Tuple{AbstractVector, IntersectionArray}","page":"Intersection","title":"Base.:∈","text":"∈(x::AbstractVector, ia::IntersectionArray)\n\nCheck whether a given point is contained in an intersection of a finite number of sets.\n\nInput\n\nx  – point/vector\nia – intersection of a finite number of sets\n\nOutput\n\ntrue iff x  ia.\n\nAlgorithm\n\nA point x is in the intersection iff it is in each set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.array-Tuple{IntersectionArray}","page":"Intersection","title":"LazySets.array","text":"array(ia::IntersectionArray)\n\nReturn the array of an intersection of a finite number of sets.\n\nInput\n\nia – intersection of a finite number of sets\n\nOutput\n\nThe array of an intersection of a finite number of sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.API.constraints_list-Tuple{IntersectionArray}","page":"Intersection","title":"LazySets.API.constraints_list","text":"constraints_list(ia::IntersectionArray)\n\nReturn the list of constraints of an intersection of a finite number of (polyhedral) sets.\n\nInput\n\nia – intersection of a finite number of (polyhedral) sets\n\nOutput\n\nThe list of constraints of the intersection.\n\nNotes\n\nWe assume that the underlying sets are polyhedral, i.e., offer a method constraints_list.\n\nAlgorithm\n\nWe create the polyhedron from the constraints_lists of the sets and remove redundant constraints.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/","page":"Intersection","title":"Intersection","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/Intersection/","page":"Intersection","title":"Intersection","text":"norm\nradius\ndiameter\n[an_element](@ref an_element(::LazySet)\nsingleton_list\nreflect","category":"page"},{"location":"lib/concrete_binary_operations/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"Pages = [\"convex_hull.md\"]\nDepth = 3","category":"page"},{"location":"lib/concrete_binary_operations/convex_hull/#Convex-Hull","page":"Convex Hull","title":"Convex Hull","text":"","category":"section"},{"location":"lib/concrete_binary_operations/convex_hull/#LazySets.API.convex_hull-Tuple{Vector{<:AbstractVector}}","page":"Convex Hull","title":"LazySets.API.convex_hull","text":"convex_hull(points::Vector{<:AbstractVector}; [algorithm]=nothing,\n            [backend]=nothing, [solver]=nothing)\n\nCompute the convex hull of a list of points.\n\nInput\n\npoints    – list of points\nalgorithm – (optional, default: nothing) the convex-hull algorithm; see                below for valid options\nbackend   – (optional, default: nothing) polyhedral computation backend                for higher-dimensional point sets\nsolver    – (optional, default: nothing) the linear-programming solver                used in the backend\n\nOutput\n\nThe convex hull as a list of points.\n\nAlgorithm\n\nA pre-processing step treats the cases with up to two points for one dimension and up to four points for two dimensions. For more points in one resp. two dimensions, we use more general algorithms.\n\nFor the one-dimensional case, we return the minimum and maximum points, in that order.\n\nThe two-dimensional case is handled with a planar convex-hull algorithm. The following algorithms are available:\n\n\"monotone_chain\"        – compute the convex hull of points in the plane                              using Andrew's monotone-chain method\n\"monotone_chain_sorted\" – the same as \"monotone_chain\" but assuming that                              the points are already sorted in                              counter-clockwise fashion\n\nSee the reference docstring of each of those algorithms for details.\n\nThe higher-dimensional case is treated using the concrete polyhedra library Polyhedra, which gives access to libraries such as CDDLib and ConvexHull.jl. These libraries can be chosen via the backend argument.\n\nNotes\n\nFor the in-place version use convex_hull!(::Vector{<:AbstractVector}).\n\nExamples\n\nCompute the convex hull of a random set of points:\n\njulia> points = [randn(2) for i in 1:30]; # 30 random points in 2D\n\njulia> hull = convex_hull(points);\n\njulia> typeof(hull)\nVector{Vector{Float64}} (alias for Array{Array{Float64, 1}, 1})\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/convex_hull/#LazySets.convex_hull!-Tuple{Vector{<:AbstractVector}}","page":"Convex Hull","title":"LazySets.convex_hull!","text":"convex_hull!(points::Vector{<:AbstractVector}; [algorithm]=nothing,\n             [backend]=nothing, [solver]=nothing)\n\nCompute the convex hull of a list of points in-place.\n\nInput\n\npoints    – list of points (modified in-place)\nalgorithm – (optional, default: nothing) the convex-hull algorithm; see                below for valid options\nbackend   – (optional, default: nothing) polyhedral computation backend                for higher-dimensional point sets\nsolver    – (optional, default: nothing) the linear-programming solver                used in the backend\n\nNotes\n\nSee convex_hull(::Vector{<:AbstractVector}) for more details.\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/convex_hull/#LazySets.monotone_chain!","page":"Convex Hull","title":"LazySets.monotone_chain!","text":"monotone_chain!(points::Vector{VN}; sort::Bool=true\n               ) where {N, VN<:AbstractVector{N}}\n\nCompute the convex hull of a list of points in the plane using Andrew's monotone-chain method.\n\nInput\n\npoints – list of 2D vectors; will be sorted in-place inside this method\nsort   – (optional, default: true) flag for sorting the vertices             lexicographically; sortedness is required for correctness\n\nOutput\n\nList of vectors containing the 2D coordinates of the corner points of the convex hull.\n\nNotes\n\nFor large sets of points, it is convenient to use static vectors to get maximum performance. For information on how to convert usual vectors into static vectors, see the type SVector provided by the StaticArrays package.\n\nAlgorithm\n\nThis method implements Andrew's monotone-chain convex hull algorithm to construct the convex hull of a set of n points in the plane in O(n log n) time. For further details see Monotone chain\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/MinkowskiSum/#Minkowski-sum","page":"MinkowskiSum","title":"Minkowski sum","text":"","category":"section"},{"location":"lib/lazy_operations/MinkowskiSum/#def_MinkowskiSum","page":"MinkowskiSum","title":"Binary Minkowski sum (MinkowskiSum)","text":"","category":"section"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.MinkowskiSum","page":"MinkowskiSum","title":"LazySets.MinkowskiSum","text":"MinkowskiSum{N, S1<:LazySet{N}, S2<:LazySet{N}} <: LazySet{N}\n\nType that represents the Minkowski sum of two sets, i.e., the set\n\nX  Y = x + y  x  X y  Y\n\nFields\n\nX – set\nY – set\n\nNotes\n\nThe ZeroSet is the neutral element and the EmptySet is the absorbing element for MinkowskiSum.\n\nThe Minkowski sum preserves convexity: if the set arguments are convex, then their Minkowski sum is convex as well.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.:⊕-Tuple{LazySet, LazySet}","page":"MinkowskiSum","title":"LazySets.:⊕","text":"⊕(X::LazySet, Y::LazySet)\n\nAlias for the Minkowski sum.\n\nNotes\n\nThe function symbol can be typed via \\oplus<tab>.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#Base.:+-Tuple{LazySet, LazySet}","page":"MinkowskiSum","title":"Base.:+","text":"+(X::LazySet, Y::LazySet)\n\nAlias for the Minkowski sum.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.swap-Tuple{MinkowskiSum}","page":"MinkowskiSum","title":"LazySets.swap","text":"swap(ms::MinkowskiSum)\n\nReturn a new MinkowskiSum object with the arguments swapped.\n\nInput\n\nms – Minkowski sum of two sets\n\nOutput\n\nA new MinkowskiSum object with the arguments swapped.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.API.dim-Tuple{MinkowskiSum}","page":"MinkowskiSum","title":"LazySets.API.dim","text":"dim(ms::MinkowskiSum)\n\nReturn the dimension of a Minkowski sum of two sets.\n\nInput\n\nms – Minkowski sum of two sets\n\nOutput\n\nThe ambient dimension of the Minkowski sum of two sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.API.ρ-Tuple{AbstractVector, MinkowskiSum}","page":"MinkowskiSum","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, ms::MinkowskiSum)\n\nEvaluate the support function of a Minkowski sum of two sets.\n\nInput\n\nd  – direction\nms – Minkowski sum of two sets\n\nOutput\n\nThe evaluation of the support function in the given direction.\n\nAlgorithm\n\nThe support function in direction d of the Minkowski sum of two sets X and Y is the sum of the support functions of X and Y in direction d.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.API.σ-Tuple{AbstractVector, MinkowskiSum}","page":"MinkowskiSum","title":"LazySets.API.σ","text":"σ(d::AbstractVector, ms::MinkowskiSum)\n\nReturn a support vector of a Minkowski sum of two sets.\n\nInput\n\nd  – direction\nms – Minkowski sum of two sets\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.\n\nAlgorithm\n\nA valid support vector in direction d of the Minkowski sum of two sets X and Y is the sum of the support vectors of X and Y in direction d.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.API.isbounded-Tuple{MinkowskiSum}","page":"MinkowskiSum","title":"LazySets.API.isbounded","text":"isbounded(ms::MinkowskiSum)\n\nCheck whether a Minkowski sum of two sets is bounded.\n\nInput\n\nms – Minkowski sum of two sets\n\nOutput\n\ntrue iff both wrapped sets are bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#Base.isempty-Tuple{MinkowskiSum}","page":"MinkowskiSum","title":"Base.isempty","text":"isempty(ms::MinkowskiSum)\n\nCheck whether a Minkowski sum of two sets is empty.\n\nInput\n\nms – Minkowski sum of two sets\n\nOutput\n\ntrue iff any of the wrapped sets are empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.API.center-Tuple{MinkowskiSum}","page":"MinkowskiSum","title":"LazySets.API.center","text":"center(ms::MinkowskiSum)\n\nReturn the center of a Minkowski sum of two centrally-symmetric sets.\n\nInput\n\nms – Minkowski sum of two centrally-symmetric sets\n\nOutput\n\nThe center of the Minkowski sum.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.API.constraints_list-Tuple{MinkowskiSum}","page":"MinkowskiSum","title":"LazySets.API.constraints_list","text":"constraints_list(ms::MinkowskiSum)\n\nReturn a list of constraints of the Minkowski sum of two polyhedral sets.\n\nInput\n\nms – Minkowski sum of two polyhedral sets\n\nOutput\n\nThe list of constraints of the Minkowski sum.\n\nAlgorithm\n\nWe compute a concrete set representation via minkowski_sum and call constraints_list on the result.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#Base.:∈-Union{Tuple{N}, Tuple{AbstractVector, MinkowskiSum{N, var\"#s45\", S2} where {var\"#s45\"<:AbstractSingleton, S2<:LazySet{N}}}} where N","page":"MinkowskiSum","title":"Base.:∈","text":"∈(x::AbstractVector, ms::MinkowskiSum{N,<:AbstractSingleton}) where {N}\n\nCheck whether a given point is contained in the Minkowski sum of a singleton and another set.\n\nInput\n\nx  – point/vector\nms – Minkowski sum of a singleton and another set\n\nOutput\n\ntrue iff x  ms.\n\nAlgorithm\n\nNote that x  (S  P), where S = s  is a singleton set and P is a set, if and only if (x-s)  P.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.API.vertices_list-Tuple{MinkowskiSum}","page":"MinkowskiSum","title":"LazySets.API.vertices_list","text":"vertices_list(ms::MinkowskiSum)\n\nReturn a list of vertices for the Minkowski sum of two sets.\n\nInput\n\nms – Minkowski sum of two sets\n\nOutput\n\nA list of vertices of the Minkowski sum of two sets.\n\nAlgorithm\n\nWe compute the concrete Minkowski sum (via minkowski_sum) and call vertices_list on the result.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/","page":"MinkowskiSum","title":"MinkowskiSum","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/MinkowskiSum/","page":"MinkowskiSum","title":"MinkowskiSum","text":"norm\nradius\ndiameter\n[an_element](@ref an_element(::LazySet)\nsingleton_list\nreflect","category":"page"},{"location":"lib/lazy_operations/MinkowskiSum/#def_MinkowskiSumArray","page":"MinkowskiSum","title":"n-ary Minkowski sum (MinkowskiSumArray)","text":"","category":"section"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.MinkowskiSumArray","page":"MinkowskiSum","title":"LazySets.MinkowskiSumArray","text":"MinkowskiSumArray{N, S<:LazySet{N}} <: LazySet{N}\n\nType that represents the Minkowski sum of a finite number of sets.\n\nFields\n\narray – array of sets\n\nNotes\n\nThis type assumes that the dimensions of all elements match.\n\nThe ZeroSet is the neutral element and the EmptySet is the absorbing element for MinkowskiSumArray.\n\nThe Minkowski sum preserves convexity: if the set arguments are convex, then their Minkowski sum is convex as well.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.MinkowskiSum!","page":"MinkowskiSum","title":"LazySets.MinkowskiSum!","text":"MinkowskiSum!(X, Y)\n\nConvenience function to compute the lazy Minkowski sum and modify MinkowskiSumArrays in-place.\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.:⊕-Tuple{LazySet, Vararg{LazySet}}","page":"MinkowskiSum","title":"LazySets.:⊕","text":"⊕(X::LazySet, Xs::LazySet...)\n⊕(Xs::Vector{<:LazySet})\n\nAlias for the n-ary Minkowski sum.\n\nNotes\n\nThe function symbol can be typed via \\oplus<tab>.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#Base.:+-Tuple{LazySet, Vararg{LazySet}}","page":"MinkowskiSum","title":"Base.:+","text":"+(X::LazySet, Xs::LazySet...)\n+(Xs::Vector{<:LazySet})\n\nAlias for the n-ary Minkowski sum.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.API.dim-Tuple{MinkowskiSumArray}","page":"MinkowskiSum","title":"LazySets.API.dim","text":"dim(msa::MinkowskiSumArray)\n\nReturn the dimension of a Minkowski sum of a finite number of sets.\n\nInput\n\nmsa – Minkowski sum of a finite number of sets\n\nOutput\n\nThe ambient dimension of the Minkowski sum of a finite number of sets, or 0 if there is no set in the array.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.API.ρ-Tuple{AbstractVector, MinkowskiSumArray}","page":"MinkowskiSum","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, msa::MinkowskiSumArray)\n\nEvaluate the support function of a Minkowski sum of a finite number of sets in a given direction.\n\nInput\n\nd   – direction\nmsa – Minkowski sum of a finite number of sets\n\nOutput\n\nThe evaluation of the support function in the given direction.\n\nAlgorithm\n\nThe support function of the Minkowski sum of multiple sets evaluations to the sum of the support-function evaluations of each set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.API.σ-Tuple{AbstractVector, MinkowskiSumArray}","page":"MinkowskiSum","title":"LazySets.API.σ","text":"σ(d::AbstractVector, msa::MinkowskiSumArray)\n\nReturn a support vector of a Minkowski sum of a finite number of sets in a given direction.\n\nInput\n\nd   – direction\nmsa – Minkowski sum of a finite number of sets\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.API.isbounded-Tuple{MinkowskiSumArray}","page":"MinkowskiSum","title":"LazySets.API.isbounded","text":"isbounded(msa::MinkowskiSumArray)\n\nCheck whether a Minkowski sum of a finite number of sets is bounded.\n\nInput\n\nmsa – Minkowski sum of a finite number of sets\n\nOutput\n\ntrue iff all wrapped sets are bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#Base.isempty-Tuple{MinkowskiSumArray}","page":"MinkowskiSum","title":"Base.isempty","text":"isempty(msa::MinkowskiSumArray)\n\nCheck whether a Minkowski sum of a finite number of sets is empty.\n\nInput\n\nmsa – Minkowski sum of a finite number of sets\n\nOutput\n\ntrue iff any of the wrapped sets is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.array-Tuple{MinkowskiSumArray}","page":"MinkowskiSum","title":"LazySets.array","text":"array(msa::MinkowskiSumArray)\n\nReturn the array of a Minkowski sum of a finite number of sets.\n\nInput\n\nmsa – Minkowski sum of a finite number of sets\n\nOutput\n\nThe array of a Minkowski sum of a finite number of sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.API.center-Tuple{MinkowskiSumArray}","page":"MinkowskiSum","title":"LazySets.API.center","text":"center(msa::MinkowskiSumArray)\n\nReturn the center of a Minkowski sum of a finite number of centrally-symmetric sets.\n\nInput\n\nmsa – Minkowski sum of a finite number of centrally-symmetric sets\n\nOutput\n\nThe center of the set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/","page":"MinkowskiSum","title":"MinkowskiSum","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/MinkowskiSum/","page":"MinkowskiSum","title":"MinkowskiSum","text":"norm\nradius\ndiameter\n[an_element](@ref an_element(::LazySet)\nsingleton_list\nreflect","category":"page"},{"location":"lib/lazy_operations/MinkowskiSum/#def_CachedMinkowskiSumArray","page":"MinkowskiSum","title":"n-ary Minkowski sum with cache (CachedMinkowskiSumArray)","text":"","category":"section"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.CachedMinkowskiSumArray","page":"MinkowskiSum","title":"LazySets.CachedMinkowskiSumArray","text":"CachedMinkowskiSumArray{N, S<:LazySet{N}} <: LazySet{N}\n\nType that represents the Minkowski sum of a finite number of sets. Support vector queries are cached.\n\nFields\n\narray – array of sets\ncache – cache for results of support-vector queries\n\nNotes\n\nThis type assumes that the dimensions of all sets in the array match.\n\nThe ZeroSet is the neutral element and the EmptySet is the absorbing element for CachedMinkowskiSumArray.\n\nThe cache (field cache) is implemented as a dictionary whose keys are direction vectors and whose values are pairs (k, s) where k is the number of elements in the array array when the support vector was evaluated last time, and s is the support vector that was obtained. Thus this type assumes that array is not modified except by adding new sets at the end.\n\nThe Minkowski sum preserves convexity: if all sets are convex, then their Minkowski sum is convex as well.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.API.dim-Tuple{CachedMinkowskiSumArray}","page":"MinkowskiSum","title":"LazySets.API.dim","text":"dim(cms::CachedMinkowskiSumArray)\n\nReturn the dimension of a cached Minkowski sum.\n\nInput\n\ncms – cached Minkowski sum\n\nOutput\n\nThe ambient dimension of the cached Minkowski sum, or 0 if there is no set in the array.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.API.σ-Tuple{AbstractVector, CachedMinkowskiSumArray}","page":"MinkowskiSum","title":"LazySets.API.σ","text":"σ(d::AbstractVector, cms::CachedMinkowskiSumArray)\n\nReturn a support vector of a cached Minkowski sum in a given direction.\n\nInput\n\nd   – direction\ncms – cached Minkowski sum\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.\n\nNotes\n\nThe result is cached, i.e., any further query with the same direction runs in constant time. When sets are added to the cached Minkowski sum, the query is only performed for the new sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.API.isbounded-Tuple{CachedMinkowskiSumArray}","page":"MinkowskiSum","title":"LazySets.API.isbounded","text":"isbounded(cms::CachedMinkowskiSumArray)\n\nCheck whether a cached Minkowski sum is bounded.\n\nInput\n\ncms – cached Minkowski sum\n\nOutput\n\ntrue iff all wrapped sets are bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#Base.isempty-Tuple{CachedMinkowskiSumArray}","page":"MinkowskiSum","title":"Base.isempty","text":"isempty(cms::CachedMinkowskiSumArray)\n\nCheck whether a cached Minkowski sum array is empty.\n\nInput\n\ncms – cached Minkowski sum\n\nOutput\n\ntrue iff any of the wrapped sets are empty.\n\nNotes\n\nForgotten sets cannot be checked anymore. Normally they should not have been empty because otherwise the support-vector query would have crashed before. In that case, the cached Minkowski sum should not be used further.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.array-Tuple{CachedMinkowskiSumArray}","page":"MinkowskiSum","title":"LazySets.array","text":"array(cms::CachedMinkowskiSumArray)\n\nReturn the array of a cached Minkowski sum.\n\nInput\n\ncms – cached Minkowski sum\n\nOutput\n\nThe array of a cached Minkowski sum.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.forget_sets!-Tuple{CachedMinkowskiSumArray}","page":"MinkowskiSum","title":"LazySets.forget_sets!","text":"forget_sets!(cms::CachedMinkowskiSumArray)\n\nTell a cached Minkowski sum to forget the stored sets (but not the support vectors). Only those sets are forgotten for which a support vector has been computed in each of the cached directions.\n\nInput\n\ncms – cached Minkowski sum\n\nOutput\n\nThe number of sets that have been forgotten.\n\nNotes\n\nThis function should only be used under the assertion that no new directions are queried in the future; otherwise such support-vector results will be incorrect.\n\nThis implementation is optimistic and first tries to remove all sets. However, it also checks that for all cached directions the support vector has been computed before. If it finds that this is not the case, the implementation identifies the biggest index k such that the above holds for the k oldest sets, and then it only removes these. See the example below.\n\nExamples\n\njulia> x1 = BallInf(ones(3), 3.); x2 = Ball1(ones(3), 5.);\n\njulia> cms1 = CachedMinkowskiSumArray(2); cms2 = CachedMinkowskiSumArray(2);\n\njulia> d = ones(3);\n\njulia> a1 = array(cms1); a2 = array(cms2);\n\njulia> push!(a1, x1); push!(a2, x1);\n\njulia> σ(d, cms1); σ(d, cms2);\n\njulia> push!(a1, x2); push!(a2, x2);\n\njulia> σ(d, cms1);\n\njulia> idx1 = forget_sets!(cms1) # support vector was computed for both sets\n2\n\njulia> idx1 = forget_sets!(cms2) # support vector was only computed for first set\n1\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/","page":"MinkowskiSum","title":"MinkowskiSum","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/MinkowskiSum/","page":"MinkowskiSum","title":"MinkowskiSum","text":"norm\nradius\ndiameter\nan_element\nsingleton_list\nreflect","category":"page"},{"location":"lib/concrete_binary_operations/distance/","page":"Distance","title":"Distance","text":"Pages = [\"distance.md\"]\nDepth = 3","category":"page"},{"location":"lib/concrete_binary_operations/distance/#Distance","page":"Distance","title":"Distance","text":"","category":"section"},{"location":"lib/concrete_binary_operations/distance/#ReachabilityBase.Arrays.distance-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-concrete_binary_operations-distance","page":"Distance","title":"ReachabilityBase.Arrays.distance","text":"distance(X::LazySet, Y::LazySet; [p]::Real=2)\n\nCompute the standard distance (induced by the p-norm) between two sets.\n\nInput\n\nX – set\nY – set\np – (optional; default: 2) value of the p-norm\n\nOutput\n\nA real number representing the distance between X and Y.\n\nNotes\n\nThe standard distance is zero if the sets intersect, and infinite if one of the sets is empty. Otherwise, it is the p-norm of the shortest line segment between any pair of points. Formally,\n\n    inf_x  X y  Y  d(x y) \n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/distance/","page":"Distance","title":"Distance","text":"Currently, there are no specialized docstrings for this function.","category":"page"},{"location":"lib/lazy_operations/Complement/#def_Complement","page":"Complement","title":"Complement","text":"","category":"section"},{"location":"lib/lazy_operations/Complement/","page":"Complement","title":"Complement","text":"The concrete complement can be computed with the function complement (with a lower-case \"c\").","category":"page"},{"location":"lib/lazy_operations/Complement/#LazySets.Complement","page":"Complement","title":"LazySets.Complement","text":"Complement{N, S<:LazySet{N}} <: LazySet{N}\n\nType that represents the complement of a set, i.e., the set\n\nY = y  ℝ^n  y  X\n\nThe complement is often denoted with the C superscript, as in Y = X^C.\n\nFields\n\nX – set\n\nNotes\n\nIf X is empty, the universe, or a half-space, its complement is convex.\n\nSince X is assumed to be closed, unless X is empty or the universe, its complement is open (i.e., not closed). In this library, all sets are closed, so the set is usually not represented exactly at the boundary.\n\nThe complement of the complement is the original set again.\n\nExamples\n\njulia> B = BallInf(zeros(2), 1.);\n\njulia> C = Complement(B)\nComplement{Float64, BallInf{Float64, Vector{Float64}}}(BallInf{Float64, Vector{Float64}}([0.0, 0.0], 1.0))\n\njulia> Complement(C)\nBallInf{Float64, Vector{Float64}}([0.0, 0.0], 1.0)\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/Complement/#LazySets.API.dim-Tuple{Complement}","page":"Complement","title":"LazySets.API.dim","text":"dim(C::Complement)\n\nReturn the dimension of the complement of a set.\n\nInput\n\nC – complement of a set\n\nOutput\n\nThe ambient dimension of the complement of a set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Complement/#Base.:∈-Tuple{AbstractVector, Complement}","page":"Complement","title":"Base.:∈","text":"∈(x::AbstractVector, C::Complement)\n\nCheck whether a given point is contained in the complement of a set.\n\nInput\n\nx – point/vector\nC – complement of a set\n\nOutput\n\ntrue iff the vector is contained in the complement.\n\nAlgorithm\n\n    x  X^C  x  X\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Complement/#Base.isempty-Tuple{Complement}","page":"Complement","title":"Base.isempty","text":"isempty(C::Complement)\n\nCheck whether the complement of a set is empty.\n\nInput\n\nC – complement of a set\n\nOutput\n\nfalse unless the original set is universal.\n\nAlgorithm\n\nWe use the isuniversal function.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Complement/#LazySets.API.constraints_list-Tuple{Complement}","page":"Complement","title":"LazySets.API.constraints_list","text":"constraints_list(C::Complement)\n\nReturn the list of constraints of the complement of a set.\n\nInput\n\nC – complement of a set\n\nOutput\n\nA vector of linear constraints.\n\nNotes\n\nThe method requires that the list of constraints of the complemented set can be obtained. Then, each constraint is complemented and returned in the output vector. The set union of this array corresponds to the concrete set complement.\n\n\n\n\n\n","category":"method"},{"location":"man/tour/#A-Tour-of-LazySets","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"","category":"section"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"LazySets is a library for set-based computations in Euclidean space. The library offers both concrete and lazy set representations, where the latter stands for the ability to delay set computations until they are needed. The choice of the programming language Julia and the accompanying documentation allow researchers to easily translate set-based algorithms from mathematics to software in a platform-independent way, while achieving runtime performance that is comparable to statically compiled languages. Combining lazy operations in high dimensions and explicit computations in low dimensions, LazySets can be applied to solve complex, large-scale problems. The library can handle the most common operations between sets, including Minkowski sum, Cartesian product, convex hull, intersection and union.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"The purpose of this section is to give a high-level overview of the library and several examples to illustrate basic functionality. Further sections delve into more advanced uses.","category":"page"},{"location":"man/tour/#Creating-sets","page":"A Tour of LazySets","title":"Creating sets","text":"","category":"section"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Sets can be created using the constructor for each set type. Here we define the two-dimensional half-space","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"H =  (x y)  ℝ^2  x  y =  (x y)  ℝ^2  x - y  0","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"using LazySets\n\nH = HalfSpace([1.0, -1.0], 0.0)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"The first argument is the normal vector to the half-space and the second argument the displacement, written in the standard form ax  b. We can define the same set using symbolic variables with the help of the Julia package Symbolics.jl:","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"using Symbolics\n\nvar = @variables x y\n\nH′ = HalfSpace(x ≤ y, var)  # for `′`, type H\\prime<tab>","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"We can use LazySets to check that H and H′ represent the same sets (mathematically the set equivalence H = H corresponds to a double inclusion check H  H  H  H):","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"isequivalent(H, H′)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"High-dimensional sets can be conveniently defined using array notation. Here we create the nine-dimensional half-space","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"H9 = left x  ℝ^9  _i=1^9 i x_i  10 right","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"var = @variables x[1:9]\n\nexpr = sum(i*x[i] for i in 1:9) ≤ 10.0\nH9 = HalfSpace(expr, var)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Next we ask LazySets to create two intervals 0 1 and 2 3 and then take their Cartesian product.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"A = Interval(0, 1)\nB = Interval(2, 3)\n\nC = A × B","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"In LazySets, intervals are implemented as thin wrappers around those available in IntervalArithmetic.jl. Use the convert function to represent the set as a Hyperrectangle, which is a dedicated set type that represents a hyperrectangle with a center and a radius vector:","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"H = convert(Hyperrectangle, C)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"IntervalArithmetic.jl represents multi-dimensional intervals with the type IntervalBox, to which we can also convert:","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"using IntervalArithmetic\n\nHbox = convert(IntervalBox, H)\n\ntypeof(Hbox)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Hyperrectangles are a special subclass of zonotopes.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Z = convert(Zonotope, C)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"There are many other set representations available in this library. They are introduced in further sections below.","category":"page"},{"location":"man/tour/#Operating-with-sets","page":"A Tour of LazySets","title":"Operating with sets","text":"","category":"section"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"The result of intersecting two or more half-spaces is a polyhedron:","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"var = @variables x y\n\nH1 = HalfSpace(y ≥ x, var)\nH2 = HalfSpace(y ≥ -x, var)\n\nP = H1 ∩ H2  # for `∩`, type `\\cap<tab>`","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Naturally, LazySets can plot the resulting set using the Plots.jl library:","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"using Plots\n\nplot(H1, lab=\"H1\")\nplot!(H2, lab=\"H2\")\nplot!(P, lab=\"P = H1 ∩ H2\", linewidth=2.0, linestyle=:dash)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"A polyhedron consists of a finite intersection of half-spaces, which are also called linear constraints:","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"constraints_list(P)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"The intersection of P with the triangle R with vertices","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"(-10 -10) (10 -10) (00 10) can be constructed with:","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"R = VPolygon([[-1.0, -1.0], [1.0, -1.0], [0.0, 1.0]])\n\nQ = P ∩ R","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"plot!(Q, lab=\"Q = P ∩ R\")\nplot!(R, lab=\"R\", linestyle=:dashdot, alpha=.2)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"The resulting set Q is a lazy (binary) intersection: by design, all operations in LazySets are lazy by default. Concrete operations can be performed by calling corresponding lower-case functions:","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Q = intersection(P, R)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Alternatively, we can use the concretize function to transform a lazy set representation into a suitable concrete set representation.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"concretize(P ∩ R)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"The result is an HPolytope (instead of an HPolyhedron), since polytopes are special cases of bounded polyhedra.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"isbounded(P)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"isbounded(Q)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"LazySets can compute various useful operations. For example, it can compute the area of a two-dimensional bounded set:","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"area(Q)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"When using rational numbers instead of floating-point numbers, we get an exact value for the area:","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"area(rationalize(Q))","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"The vertices can be retrieved using vertices_list,","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"vertices_list(Q)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"or in iterator-fashion with vertices:","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"vertices(Q)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"The constraint representation of Q is obtained similarly.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"constraints_list(Q)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"The constraint iterator is called with constraints.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"constraints(Q)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"The Minkowski sum of two sets can be computed using ⊕ (type \\oplus<tab>) (or alternatively just + for convenience):","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"# ball in the 2-norm of given center and radius\nB = Ball2([0.8, 1.0], 0.3)\n\nE = Q ⊕ B","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Approximating and plotting such sets relies on techniques based on the support function, discussed at length in other sections of this manual.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"plot(E, lab=\"E = Q ⊕ B\", legend=:bottomright)\nplot!(Q, lab=\"Q\")\nplot!(B, lab=\"B\", ratio=1., xlims=(-0.5, 1.5))","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Linear and affine maps are defined combining the * and + operators.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"M = [0 1; 1 0.]\nb = [0.5, -0.5]\n\nX = M * E + b","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"The set X, and in general, the composition of sets and operations, is again a set (in this case an operation).","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"isoperation(X)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Therefore, all set operations (and plotting) still work in the same way.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"plot!(X, lab=\"X = M*E + b\", legend=:topright)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Convex hulls can be computed with convex_hull (concrete), ConvexHull (lazy, binary), or ConvexHullArray (lazy, n-ary).","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"C = ConvexHullArray([E, Q, X])\n\nplot!(C, c=:grey, lab=\"C = CH(E, Q, X)\")","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"The Cartesian product of sets is defined with × (type \\times<tab>) (or alternatively just * for convenience).","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"X = Interval(0, 1) × Ball1([1.0, 2.0, 3.0], 1.0) × Interval(2, 4)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Set unions are defined with ∪ (type \\cup<tab>).","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Y = Ball2([1.0, 2.0, 3.0], 1.0) × LineSegment([0.0, 0.0], [1.0, 1.0])\n\nU = X ∪ Y","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"There are other set operations not mentioned in this section. See the remaining sections of this manual for further examples.","category":"page"},{"location":"man/tour/#Exploring-the-type-hierarchy","page":"A Tour of LazySets","title":"Exploring the type hierarchy","text":"","category":"section"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Every set type in the library inherits from the parametric abstract type LazySet{N}, where N is a parameter for the numeric type (typically, double-precision floating point numbers, Float64). This way one can easily choose between, e.g., floating point (Float64) and exact (Rational) precision with no additional performance penalty: At runtime, Julia uses multiple dispatch on N and JIT-compiles into type-specific code.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Since the LazySets type hierarchy is rather involved, a way to visualize it is to use AbstractTrees.jl. The package provides several utilities for working with tree-like data structures. The function print_tree provides a very detailed answer.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"using AbstractTrees\n\nAbstractTrees.children(x::Type) = LazySets.subtypes(x, false)\n\nprint_tree(LazySet)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Since the list does not fit into the default size, some types are hidden. LazySets has several set interfaces whose names start with Abstract. Visualizing the subtypes of a specific set interface can be done similarly. Consider the class of zonotopic sets, AbstractZonotope, which are those that can be represented as","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Z = left x  ℝ^n  x = c + _i=1^p ξ_i g_i ξ_i  -1 1  i = 1 p right","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"where c  ℝ^n is called the center and the vectors g_i_i=1^p, g_i  ℝ^n, are called the generators.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"print_tree(AbstractZonotope)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"All the sets belonging to the abstract zonotope interface have in common that they can be characterized by a center and a generator matrix (equivalently, as the finite Minkowski sum of line segments, or as the image of a unit infinity-norm ball in ℝ^n by an affine transformation). Hence, new set types implementing a few interface functions can make use of all the available functionality that are implemented by generic algorithms working at the interface level.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Last but not least, we remark that one of the key design choices of LazySets (which, admittedly, may be confusing at first) is that both set representations and set operations subtype LazySet. In other words, an \"operation between sets\" and \"a set\" are on the same footing in terms of belonging to the same type hierarchy. One of the advantages of these two mathematical concepts to be \"just types\" is to conveniently compose representations and operations (existing and user-created ones).","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"An overview of only the set operations can be obtained like so:","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"filter(isoperationtype, LazySets.subtypes(LazySet, true))","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"The total amount of available representations is larger (if we had used subtypes(LazySet), that would only show the direct subtypes of LazySet).","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"length(LazySets.subtypes(LazySet, true))","category":"page"},{"location":"man/tour/#Random-sampling-and-splitting","page":"A Tour of LazySets","title":"Random sampling and splitting","text":"","category":"section"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Another useful operation is to perform random sampling from a given set.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"# returns a vector of samples (vectors)\nS = sample(Q, 300, include_vertices=true)\n\nplot(Q, lab=\"Q\")\n\n# transform into a vector of singletons (for plotting)\nplot!(Singleton.(S), lab=\"S\", c=:magenta)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Set membership is computed with the ∈ operator (type \\in<tab>):","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"all(s -> s ∈ Q, S)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Below we show a straightforward way to enclose Q with smaller, simpler sets (hyperrectangles in this case).","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"# compute an enclosing hyperrectangle\nQbox = overapproximate(Q, Hyperrectangle)\n\n# split it into 6 pieces horizontally and 10 pieces vertically\nBs = split(Qbox, [6, 10])\n\n# find all the boxes that intersect Q\nidx = findall(Bi -> !isdisjoint(Bi, Q), Bs)\n\nplot(Bs[idx])\nplot!(Q, lab=\"Q\")\nplot!(Singleton.(S), lab=\"S\", c=:magenta)","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"With a bit of extra work we can also split the set into non axis-aligned parallelotopes:","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"# compute an enclosing zonotope\nZ = overapproximate(Q, Zonotope, OctDirections)\n\n# reduce to order 1\nP = overapproximate(Z, HParallelotope)\n\n# split along the first (resp. second) generator three (resp. four) times\nZs = split(convert(Zonotope, P), [1, 2], [3, 4])\n\n# find all the zonotopes that intersect Q\nidx = findall(Zi -> !isdisjoint(Zi, Q), Zs)\n\nplot(Zs[idx])\nplot!(Q, lab=\"Q\")\nplot!(Singleton.(S), lab=\"S\", c=:magenta)","category":"page"},{"location":"man/tour/#Polyhedral-approximations","page":"A Tour of LazySets","title":"Polyhedral approximations","text":"","category":"section"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"In this library we mainly consider representations of closed convex sets in the usual sense from convex geometry: A set is closed if it contains all its limit points. A set S is convex if for any m points v_j  S and m non-negative numbers λ_j that sum up to 1 we have that _j=1^m λ_j v_j  S as well. Alternatively, a closed convex set is an intersection of (possibly infinitely many) closed half-spaces.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"One of the central functions are support_function(d, X) (with the alias ρ(d, X) (type \\rho<tab>)) and support_vector (with the alias σ (type \\sigma<tab>)). The support function of a set X along direction d  ℝ^n corresponds to the (signed) distance of the maximum element in X along direction d. The support vector is a (among possibly infinitely many) maximizer of the support function.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"The support function also characterizes the half-space that tightly covers a set in a given direction. Hence it can be used to obtain a polyhedral (over-)approximation of any set. This topic is further covered in other sections of the manual.","category":"page"},{"location":"man/tour/#Specialization","page":"A Tour of LazySets","title":"Specialization","text":"","category":"section"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"One of the key features of LazySets is specialization. On a more technical level, the library aims at a high level of optimization to get the best possible performance given the following two restrictions: the set type and the set dimension.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"The submodule LazySets.Arrays exports the \"one-hot vector\" SingleEntryVector that can be used, e.g., to represent polyhedra with axis-aligned half-spaces as information on the type. If H is a (non-flat) 100-dimensional hyperrectangle, it has 2^100 vertices. Computing the support function of M*X for any square matrix M along the canonical direction e_{50} = [0, …, 0, 1, 0, …, 0] takes around 10us on a modern computer.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"using LazySets.Arrays: SingleEntryVector\n\nusing BenchmarkTools\n\nd = SingleEntryVector(50, 100, 1.0)\nM = rand(100, 100)  # a random 100×100 matrix\nH = rand(Hyperrectangle, dim=100)  # a random 100-dimensional hyperrectangle\n\nout = @benchmark ρ($d, $M * $H)\nout","category":"page"},{"location":"man/tour/#The-Lazy-paradigm","page":"A Tour of LazySets","title":"The Lazy paradigm","text":"","category":"section"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"For the several set representations, such as polyhedra in constraint and in vertex representation, ellipsoids, balls in different norms, and specific classes of polyhedra (such as intervals, zonotopes, or hyperrectangles), LazySets implements specialized methods for many set operations. Applications that use LazySets can explore different approaches with minimal changes in their code. Conversion between set representations as well as overapproximation and underapproximation functionality are available.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Set operations can be performed in two possible (complementary) ways: concretely or lazily. A concrete operation returns a set of a dedicated type (such as Hyperrectangle). A lazy operation simply returns a wrapper object representing the result of the operation between the given sets. For instance, consider the transformation with a linear map, i.e., the set Y = y  y = Ax textrm for some  x  X. In LazySets, linear_map(A, X) returns a concrete set representation of Y. The algorithm that is actually used, as well as the type of Y, depend on the types of its arguments (this is the multiple dispatch paradigm) and the dimension of X.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"For example, if X is a polygon in vertex representation (VPolygon), then linear_map(M, X) applies M to each vertex of X. However, if X is a 30-dimensional polyhedron in half-space representation (HPolyhedron), then the half-space representation is used if M is invertible – if not, and if MX does not fall into any special case, the vertex representation has to be computed. For polyhedra manipulation we use the library Polyhedra.jl (the cost of converting between representations increases exponentially with the dimension, so computing with concrete polyhedra is usually avoided in high dimensions). Observe that if we are interested in P(MX) for some projection matrix P, that operation can be performed efficiently using the support function, i.e., without actually computing MX. On the other hand, there are special cases of polyhedra for which concrete operations can be performed efficiently. For instance, if X is a hyperrectangle (or a zonotope), the resulting set is a zonotope and the computation is efficient.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"To give an example of lazy operations, LinearMap(A, X), or simply A * X, computes the lazy linear map, which is just a new object that wraps the computation of the linear map until it is actually needed. In other words, LinearMap(A, X) can be used to reason about the linear map even if computing the result is expensive (e.g., if X is high-dimensional), since this command just builds an object representing the linear map of A and X. In LazySets, Unicode symbols such as A * X, X ⊕ Y, X ⊖ Y, X × Y, all default to lazy operations by design. Unicode is written using the LaTeX macro of the symbol followed by the TAB key, such as \\oplus<tab> for the (lazy) Minkowski sum ⊕.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Finally, one can combine lazy set operations to build lazy expressions that represent several operations between sets, such as Q = (Z ⊕ A*X) × T. By means of the basic tools of (convex) geometry, useful information about Q can be obtained without actually computing the linear map, Minkowski sum and Cartesian product in the above computation. For example, if the computation only involves querying information about Q in a restricted number of directions, as it is often the case in applications, the lazy approach can be realized very efficiently!","category":"page"},{"location":"man/tour/#How-to-contribute","page":"A Tour of LazySets","title":"How to contribute","text":"","category":"section"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Development happens on github. New contributors should follow the links provided in the About section of this documentation.","category":"page"},{"location":"man/tour/#How-to-cite","page":"A Tour of LazySets","title":"How to cite","text":"","category":"section"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"When citing LazySets.jl, please use the entry in CITATION.bib.","category":"page"},{"location":"man/tour/","page":"A Tour of LazySets","title":"A Tour of LazySets","text":"Further publications using LazySets can be found in the Publications section of the README. If you would like to list your work, feel free to create a pull request.","category":"page"},{"location":"lib/sets/Ballp/#def_Ballp","page":"Ballp","title":"p-norm ball (Ballp)","text":"","category":"section"},{"location":"lib/sets/Ballp/#LazySets.BallpModule.Ballp","page":"Ballp","title":"LazySets.BallpModule.Ballp","text":"Ballp{N<:AbstractFloat, VN<:AbstractVector{N}} <: AbstractBallp{N}\n\nType that represents a ball in the p-norm, for 1  p  .\n\nIt is defined as the set\n\nmathcalB_p^n(c r) =  x  ℝ^n   x - c _p  r \n\nwhere c  ℝ^n is its center and r  ℝ_+ its radius. Here   _p for 1  p   denotes the vector p-norm, defined as  x _p = left( limits_i=1^n x_i^p right)^1p for any x  ℝ^n.\n\nFields\n\np      – norm as a real scalar\ncenter – center of the ball as a real vector\nradius – radius of the ball as a scalar ( 0)\n\nNotes\n\nThe special cases p=1, p=2 and p= fall back to the specialized types Ball1, Ball2 and BallInf, respectively.\n\nExamples\n\nA five-dimensional ball in the p=32 norm centered at the origin of radius 0.5:\n\njulia> B = Ballp(3/2, zeros(5), 0.5)\nBallp{Float64, Vector{Float64}}(1.5, [0.0, 0.0, 0.0, 0.0, 0.0], 0.5)\n\njulia> dim(B)\n5\n\nWe evaluate the support vector in direction 125:\n\njulia> σ([1.0, 2, 3, 4, 5], B)\n5-element Vector{Float64}:\n 0.013516004434607558\n 0.05406401773843023\n 0.12164403991146802\n 0.21625607095372093\n 0.33790011086518895\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Ballp/#Operations","page":"Ballp","title":"Operations","text":"","category":"section"},{"location":"lib/sets/Ballp/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-Ballp","page":"Ballp","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ballp/#Base.rand-Tuple{Type{Ballp}}","page":"Ballp","title":"Base.rand","text":"Extended help\n\nrand(::Type{Ballp}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nAlgorithm\n\nThe center and radius are normally distributed with mean 0 and standard deviation 1. Additionally, the radius is nonnegative. The p-norm is a normally distributed number ≥ 1 with mean 1 and standard deviation 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ballp/#LazySets.API.reflect-Tuple{LazySets.API.LazySet}-lib-sets-Ballp","page":"Ballp","title":"LazySets.API.reflect","text":"reflect(X::LazySet)\n\nCompute the reflection of a set in the origin.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the reflection -X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ballp/#LazySets.API.reflect-Tuple{Ballp}","page":"Ballp","title":"LazySets.API.reflect","text":"Extended help\n\nreflect(B::Ballp)\n\nAlgorithm\n\nIf B has center c and radius r, then -B has center -c and radius r. The norm remains the same.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ballp/#LazySets.API.translate!-Tuple{LazySets.API.LazySet, AbstractVector}-lib-sets-Ballp","page":"Ballp","title":"LazySets.API.translate!","text":"translate!(X::LazySet, v::AbstractVector)\n\nTranslate a set with a vector by modifying it.\n\nInput\n\nX – set\nv – vector\n\nOutput\n\nThe translated set representing X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ballp/#LazySets.API.translate!-Tuple{Ballp, AbstractVector}","page":"Ballp","title":"LazySets.API.translate!","text":"Extended help\n\ntranslate!(B::Ballp, v::AbstractVector)\n\nAlgorithm\n\nWe add the vector to the center of the ball.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ballp/","page":"Ballp","title":"Ballp","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/Ballp/","page":"Ballp","title":"Ballp","text":"center\nisoperationtype\nproject\nscale","category":"page"},{"location":"lib/sets/Ballp/","page":"Ballp","title":"Ballp","text":"ball_norm\nradius_ball","category":"page"},{"location":"lib/sets/Ballp/","page":"Ballp","title":"Ballp","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Ballp/","page":"Ballp","title":"Ballp","text":"chebyshev_center_radius\nconcretize\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nhigh\nlow\nispolyhedral\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nis_interior_point\nsample\ntosimplehrep\ntranslate\ntriangulate\ntriangulate_faces\nconvex_hull\n≈\n==\nisequivalent","category":"page"},{"location":"lib/sets/Ballp/","page":"Ballp","title":"Ballp","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/Ballp/","page":"Ballp","title":"Ballp","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/Ballp/","page":"Ballp","title":"Ballp","text":"Inherited from AbstractCentrallySymmetric:","category":"page"},{"location":"lib/sets/Ballp/","page":"Ballp","title":"Ballp","text":"an_element\ncenter\ndim\nextrema\nextrema\nisbounded\nisboundedtype\nisempty\nisuniversal","category":"page"},{"location":"lib/sets/Ballp/","page":"Ballp","title":"Ballp","text":"Inherited from AbstractBallp:","category":"page"},{"location":"lib/sets/Ballp/","page":"Ballp","title":"Ballp","text":"low\nhigh\n∈\nρ\nσ\nminkowski_sum","category":"page"},{"location":"lib/lazy_operations/Rectification/#def_Rectification","page":"Rectification","title":"Rectification","text":"","category":"section"},{"location":"lib/lazy_operations/Rectification/#LazySets.Rectification","page":"Rectification","title":"LazySets.Rectification","text":"Rectification{N, S<:LazySet{N}} <: LazySet{N}\n\nType that represents the rectification of a set.\n\nFields\n\nX     – set\ncache – storage of information computed before\n\nNotes\n\nGiven a vector v = (v_1  v_n), its rectification is defined as textrectify(v) = (v_1  v_n) such that v_i = max(v_i 0) for each i = 1  n.\n\nThe extension to a set X is defined elementwise:\n\n    textrectify(X) = textrectify(x) mid x  X\n\nThe rectification of a convex set X is not necessarily convex.\n\nIt can be expressed exactly as the union of the intersection of X with the nonnegative orthant and the projection of the intersection of X with each other orthant. This can be seen as follows.\n\nFirst we observe that rectification distributes with union.\n\n    textrectify(X_1    X_m) = _j textrectify(X_j)\n\nNext we express X as the union of the intersection of X with each orthant O.\n\n    X = _j (X  O_j)\n\nThus we have\n\n    textrectify(X) = textrectify((X  O_1)    (X  O_m)) = _j textrectify(X  O_j)\n\nClearly, textrectify(X  O_j) = X if O_j is the nonnegative orthant.\n\nFor example, consider a two-dimensional case and call the orthants O_1  O_4 in clockwise fashion, starting with the nonnegative orthant. We conclude that\n\n    textrectify(X) = (X  O_1)  textrectify(X  O_2)  textrectify(X  O_3)  textrectify(X  O_4)\n\nThe rectification of the intersection in the nonpositive orthant, textrectify(X  O_3), is either the empty set or the singleton containing the origin. The rectification of X  O_2 and X  O_4 both result in flat 1-dimensional line segments on the corresponding hyperplane of O_1.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/Rectification/#LazySets.set-Tuple{Rectification}","page":"Rectification","title":"LazySets.set","text":"set(R::Rectification)\n\nReturn the original set of a rectification.\n\nInput\n\nR – rectification\n\nOutput\n\nThe original set of the rectification.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#LazySets.API.dim-Tuple{Rectification}","page":"Rectification","title":"LazySets.API.dim","text":"dim(R::Rectification)\n\nReturn the dimension of a rectification.\n\nInput\n\nR – rectification\n\nOutput\n\nThe ambient dimension of the rectification.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#LazySets.API.σ-Tuple{AbstractVector, Rectification}","page":"Rectification","title":"LazySets.API.σ","text":"σ(d::AbstractVector, R::Rectification)\n\nReturn a support vector of a rectification.\n\nInput\n\nd – direction\nR – rectification\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#LazySets.API.σ-Union{Tuple{N}, Tuple{AbstractVector, Rectification{N, <:AbstractHyperrectangle}}} where N","page":"Rectification","title":"LazySets.API.σ","text":"σ(d::AbstractVector, R::Rectification{N, <:AbstractHyperrectangle}) where {N}\n\nReturn a support vector of the rectification of a hyperrectangular set.\n\nInput\n\nd – direction\nR – rectification of a hyperrectangular set\n\nOutput\n\nA support vector in the given direction.\n\nAlgorithm\n\nLet R() be the rectification of a vector respectively a set, and let H be a hyperrectangle. Then σ_R(H)(d) = R(σ_H(d)).\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#LazySets.API.σ-Union{Tuple{N}, Tuple{AbstractVector, Rectification{N, <:CartesianProduct}}} where N","page":"Rectification","title":"LazySets.API.σ","text":"σ(d::AbstractVector, R::Rectification{N, <:CartesianProduct}) where {N}\n\nReturn a support vector of the rectification of a Cartesian product of two sets.\n\nInput\n\nd – direction\nR – rectification of a Cartesian product of two sets\n\nOutput\n\nA support vector in the given direction.\n\nNotes\n\nNote that this implementation creates new Rectification objects that do not get preserved. Hence a second support-vector query does not benefit from the computations in the first query. For this use case another implementation should be added.\n\nAlgorithm\n\nRectification distributes with the Cartesian product. Let R() be the rectification of a set. We can just query a support vector for R(X) and R(Y) recursively: σ_R(X  Y)(d) = σ_R(X)(d_X)  σ_R(Y)(d_Y), where x  y concatenates vectors x and y.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#LazySets.API.σ-Union{Tuple{N}, Tuple{AbstractVector, Rectification{N, <:CartesianProductArray}}} where N","page":"Rectification","title":"LazySets.API.σ","text":"σ(d::AbstractVector,\n  R::Rectification{N, <:CartesianProductArray}) where {N}\n\nReturn a support vector of the rectification of a Cartesian product of a finite number of sets.\n\nInput\n\nd – direction\nR – rectification of a Cartesian product of a finite number of sets\n\nOutput\n\nA support vector in the given direction.\n\nNotes\n\nNote that this implementation creates new Rectification objects that do not get preserved. Hence a second support-vector query does not benefit from the computations in the first query. For this use case another implementation should be added.\n\nAlgorithm\n\nRectification distributes with the Cartesian product. Let R() be the rectification of a set. We can just query a support vector for each subspace recursively: σ_R(X_1    X_m)(d) = σ_R(X_1)(d_X_1)    σ_R(X_m)(d_X_m), where x  y concatenates vectors x and y.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#LazySets.API.ρ-Tuple{AbstractVector, Rectification}","page":"Rectification","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, R::Rectification)\n\nEvaluate the support function of a rectification in a given direction.\n\nInput\n\nd – direction\nR – rectification\n\nOutput\n\nThe support value of the rectification in the given direction.\n\nAlgorithm\n\nWe use different procedures for different types of input sets. If the wrapped set has a suitable structure for which we can efficiently compute the support vector, we fall back to the evaluation of the support function by means of the support vector. Otherwise we compute the union of projections to obtain a precise result (see to_union_of_projections), and then compute the support function for this union. (The union is cached internally, so subsequent queries are more efficient.)\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#LazySets.API.an_element-Tuple{Rectification}","page":"Rectification","title":"LazySets.API.an_element","text":"an_element(R::Rectification)\n\nReturn some element of a rectification.\n\nInput\n\nR – rectification\n\nOutput\n\nAn element in the rectification. The implementation relies on the an_element function of the wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#Base.:∈-Tuple{AbstractVector, Rectification}","page":"Rectification","title":"Base.:∈","text":"∈(x::AbstractVector, R::Rectification)\n\nCheck whether a given point is contained in a rectification.\n\nInput\n\nx – point/vector\nR – rectification\n\nOutput\n\ntrue iff x  R.\n\nAlgorithm\n\nWe first scan for negative entries in the vector. If there are any, the vector is not contained in the rectification.\n\nNext we ask a membership query in the wrapped set. If the answer is positive, the vector is contained in the rectification. (This holds because negative entries have been ruled out before.)\n\nOtherwise, we scan for zero entries in the vector. If there are none, membership reduces to membership in the wrapped set, and so the answer is negative.\n\nFinally, if there are zero entries in the vector and the vector is not contained in the wrapped set, we give up and throw an error.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#Base.isempty-Tuple{Rectification}","page":"Rectification","title":"Base.isempty","text":"isempty(R::Rectification)\n\nCheck whether a rectification is empty.\n\nInput\n\nR – rectification\n\nOutput\n\ntrue iff the wrapped set is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#LazySets.API.isbounded-Tuple{Rectification}","page":"Rectification","title":"LazySets.API.isbounded","text":"isbounded(R::Rectification)\n\nCheck whether a rectification is bounded.\n\nInput\n\nR – rectification\n\nOutput\n\ntrue iff the rectification is bounded.\n\nAlgorithm\n\nLet X be the set wrapped by rectification R. We first check whether X is bounded (because then R is bounded). Otherwise, we check unboundedness of X in direction (1 1  1), which is sufficient for unboundedness of R; this step is not necessary but rather a heuristics. Otherwise, we check boundedness of X in every positive unit direction, which is sufficient and necessary for boundedness of R.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#LazySets.to_union_of_projections","page":"Rectification","title":"LazySets.to_union_of_projections","text":"to_union_of_projections(R::Rectification,\n                        [concrete_intersection]::Bool=false) where\n\nCompute an equivalent union of projections from a rectification.\n\nInput\n\nR                     – rectification\nconcrete_intersection – (optional, default: false) option to compute                            all intersections concretely or lazily\nfilter_empty_sets     – (optional, default: true) option to filter out                            empty sets in the union\n\nAlgorithm\n\nLet X be the set wrapped by the rectification R. We compute a union of sets that represents the rectification of X precisely. The sets are lazy projections, potentially of intersections.\n\nWe first identify those dimensions where X is negative, using one call to low per dimension, and collect the dimensions in the index set I_textneg. For each element in I_textneg we will later apply a projection to zero.\n\nNext we identify those dimensions from I_textneg where X is also positive, using another high query in each dimension, and collect the dimensions in the index set I_textmix. Let us call the remaining dimensions (I_textneg  I_textmix) I_textnonpos. For each dimension in j  I_textmix we will apply an intersection with axis-aligned polyhedra. In particular, we distinguish two cases using half-spaces x_j  0 and x_j  0, and then compute all possible combinations to intersect, using one half-space per dimension j  I_textmix.\n\nNext we project the intersections in all dimensions from i  I_textmix such that we used the half-space x_i  0 in their computation, and in all dimensions j  I_textnonpos irrespective of the half-space used.\n\nFinally, we take the union of the resulting sets.\n\nOutput\n\nThe result can be one of three cases depending on the wrapped set X, namely\n\nthe set X if X is contained in the positive quadrant,\na LinearMap (projection) of X if for each dimension, X is only either positive or negative, or\na UnionSetArray of LinearMaps (projections) otherwise.\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/Rectification/","page":"Rectification","title":"Rectification","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/Rectification/","page":"Rectification","title":"Rectification","text":"singleton_list","category":"page"},{"location":"lib/lazy_operations/Rectification/#Rectification-cache","page":"Rectification","title":"Rectification cache","text":"","category":"section"},{"location":"lib/lazy_operations/Rectification/#LazySets.RectificationCache","page":"Rectification","title":"LazySets.RectificationCache","text":"RectificationCache{N}\n\nStruct that is used as a cache for Rectifications.\n\nFields\n\nset                – set represented by the rectification (can be nothing                         if not computed yet)\nuse_support_vector – flag indicating whether to use support-vector                         computations for the cached set\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/LinearMap/#def_LinearMap","page":"LinearMap","title":"Linear map (LinearMap)","text":"","category":"section"},{"location":"lib/lazy_operations/LinearMap/#LazySets.LinearMap","page":"LinearMap","title":"LazySets.LinearMap","text":"LinearMap{N, S<:LazySet{N}, NM, MAT<:AbstractMatrix{NM}}\n    <: AbstractAffineMap{N, S}\n\nType that represents a linear transformation MX of a set X.\n\nFields\n\nM – matrix/linear map\nX – set\n\nNotes\n\nThis type is parametric in the elements of the linear map, NM, which is independent of the numeric type of the wrapped set (N). Typically NM = N, but there may be exceptions, e.g., if NM is an interval that holds numbers of type N, where N is a floating point number type such as Float64.\n\nThe linear map preserves convexity: if X is convex, then any linear map of X is convex as well.\n\nExamples\n\nFor the examples we create a 32 matrix and a two-dimensional unit square.\n\njulia> M = [1 2; 1 3; 1 4]; X = BallInf([0, 0], 1);\n\nThe function * can be used as an alias to construct a LinearMap object.\n\njulia> lm = LinearMap(M, X)\nLinearMap{Int64, BallInf{Int64, Vector{Int64}}, Int64, Matrix{Int64}}([1 2; 1 3; 1 4], BallInf{Int64, Vector{Int64}}([0, 0], 1))\n\njulia> lm2 = M * X\nLinearMap{Int64, BallInf{Int64, Vector{Int64}}, Int64, Matrix{Int64}}([1 2; 1 3; 1 4], BallInf{Int64, Vector{Int64}}([0, 0], 1))\n\njulia> lm == lm2\ntrue\n\nFor convenience, M does not need to be a matrix; we also allow to use vectors (interpreted as an n1 matrix) and UniformScalings resp. scalars (interpreted as a scaling, i.e., a scaled identity matrix). Scaling by 1 is ignored.\n\njulia> using LinearAlgebra: I\n\njulia> Y = BallInf([0], 1);  # one-dimensional interval\n\njulia> [2, 3] * Y\nLinearMap{Int64, BallInf{Int64, Vector{Int64}}, Int64, Matrix{Int64}}([2; 3;;], BallInf{Int64, Vector{Int64}}([0], 1))\n\njulia> lm3 = 2 * X\nLinearMap{Int64, BallInf{Int64, Vector{Int64}}, Int64, SparseArrays.SparseMatrixCSC{Int64, Int64}}(sparse([1, 2], [1, 2], [2, 2], 2, 2), BallInf{Int64, Vector{Int64}}([0, 0], 1))\n\njulia> 2I * X == lm3\ntrue\n\njulia> 1I * X == X\ntrue\n\nApplying a linear map to a LinearMap object combines the two maps into a single LinearMap instance. Again we can make use of the conversion for convenience.\n\njulia> B = transpose(M); B * lm\nLinearMap{Int64, BallInf{Int64, Vector{Int64}}, Int64, Matrix{Int64}}([3 9; 9 29], BallInf{Int64, Vector{Int64}}([0, 0], 1))\n\njulia> B = [3, 4, 5]; B * lm\nLinearMap{Int64, BallInf{Int64, Vector{Int64}}, Int64, Matrix{Int64}}([12 38], BallInf{Int64, Vector{Int64}}([0, 0], 1))\n\njulia> B = 2; B * lm\nLinearMap{Int64, BallInf{Int64, Vector{Int64}}, Int64, Matrix{Int64}}([2 4; 2 6; 2 8], BallInf{Int64, Vector{Int64}}([0, 0], 1))\n\nThe application of a LinearMap to a ZeroSet or an EmptySet is simplified automatically.\n\njulia> M * ZeroSet{Int}(2)\nZeroSet{Int64}(3)\n\njulia> M * EmptySet{Int}(2)\nEmptySet{Int64}(3)\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/LinearMap/#Base.:*-Tuple{Union{Real, LinearAlgebra.UniformScaling, AbstractMatrix, AbstractVector}, LazySet}","page":"LinearMap","title":"Base.:*","text":"    *(M::Union{AbstractMatrix, UniformScaling, AbstractVector, Real},\n      X::LazySet)\n\nAlias to create a LinearMap object.\n\nInput\n\nM – linear map\nX – set\n\nOutput\n\nA lazy linear map, i.e., a LinearMap instance.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/LinearMap/#LazySets.API.dim-Tuple{LinearMap}","page":"LinearMap","title":"LazySets.API.dim","text":"dim(lm::LinearMap)\n\nReturn the dimension of a linear map.\n\nInput\n\nlm – linear map\n\nOutput\n\nThe ambient dimension of the linear map.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/LinearMap/#LazySets.API.ρ-Tuple{AbstractVector, LinearMap}","page":"LinearMap","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, lm::LinearMap; kwargs...)\n\nEvaluate the support function of the linear map.\n\nInput\n\nd      – direction\nlm     – linear map\nkwargs – additional arguments that are passed to the support function             algorithm\n\nOutput\n\nThe evaluation of the support function in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\nNotes\n\nIf L = MS, where M is a matrix and S is a set, it follows that ρ(d L) = ρ(M^T d S) for any direction d.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/LinearMap/#LazySets.API.σ-Tuple{AbstractVector, LinearMap}","page":"LinearMap","title":"LazySets.API.σ","text":"σ(d::AbstractVector, lm::LinearMap)\n\nReturn a support vector of the linear map.\n\nInput\n\nd  – direction\nlm – linear map\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\nNotes\n\nIf L = MS, where M is a matrix and S is a set, it follows that σ(d L) = Mσ(M^T d S) for any direction d.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/LinearMap/#Base.:∈-Tuple{AbstractVector, LinearMap}","page":"LinearMap","title":"Base.:∈","text":"∈(x::AbstractVector, lm::LinearMap)\n\nCheck whether a given point is contained in a linear map.\n\nInput\n\nx  – point/vector\nlm – linear map\n\nOutput\n\ntrue iff x  lm.\n\nAlgorithm\n\nNote that x  MS iff M^-1x  S. This implementation does not explicitly invert the matrix: instead of M^-1x it computes M  x. Hence it also works for non-square matrices.\n\nExamples\n\njulia> lm = LinearMap([2.0 0.0; 0.0 1.0], BallInf([1., 1.], 1.));\n\njulia> [5.0, 1.0] ∈ lm\nfalse\njulia> [3.0, 1.0] ∈ lm\ntrue\n\nAn example with non-square matrix:\n\njulia> B = BallInf(zeros(4), 1.);\n\njulia> M = [1. 0 0 0; 0 1 0 0]/2;\n\njulia> [0.5, 0.5] ∈ M*B\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/LinearMap/#LazySets.API.an_element-Tuple{LinearMap}","page":"LinearMap","title":"LazySets.API.an_element","text":"an_element(lm::LinearMap)\n\nReturn some element of a linear map.\n\nInput\n\nlm – linear map\n\nOutput\n\nAn element in the linear map. It relies on the an_element function of the wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/LinearMap/#LazySets.API.vertices_list-Tuple{LinearMap}","page":"LinearMap","title":"LazySets.API.vertices_list","text":"vertices_list(lm::LinearMap; prune::Bool=true)\n\nReturn the list of vertices of a (polytopic) linear map.\n\nInput\n\nlm    – linear map\nprune – (optional, default: true) if true, we remove redundant vertices\n\nOutput\n\nA list of vertices.\n\nAlgorithm\n\nWe assume that the underlying set X is polytopic and compute the vertices of X. The result is just the linear map applied to each vertex.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/LinearMap/#LazySets.API.constraints_list-Tuple{LinearMap}","page":"LinearMap","title":"LazySets.API.constraints_list","text":"constraints_list(lm::LinearMap)\n\nReturn the list of constraints of a (polyhedral) linear map.\n\nInput\n\nlm – linear map\n\nOutput\n\nThe list of constraints of the linear map.\n\nNotes\n\nWe assume that the underlying set X is polyhedral, i.e., offers a method constraints_list(X).\n\nAlgorithm\n\nWe fall back to a concrete set representation by applying linear_map.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/LinearMap/#LazySets.API.linear_map-Tuple{AbstractMatrix, LinearMap}","page":"LinearMap","title":"LazySets.API.linear_map","text":"linear_map(M::AbstractMatrix, lm::LinearMap)\n\nReturn the linear map of a lazy linear map.\n\nInput\n\nM  – matrix\nlm – linear map\n\nOutput\n\nA set representing the linear map.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/LinearMap/#LazySets.API.project","page":"LinearMap","title":"LazySets.API.project","text":"project(S::LazySet, block::AbstractVector{Int}, set_type::Type{<:LinearMap},\n        [n]::Int=dim(S); [kwargs...])\n\nProject a high-dimensional set to a given block by using a lazy linear map.\n\nInput\n\nS         – set\nblock     – block structure - a vector with the dimensions of interest\nLinearMap – used for dispatch\nn         – (optional, default: dim(S)) ambient dimension of the set S\n\nOutput\n\nA lazy LinearMap representing the projection of the set S to block block.\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/LinearMap/","page":"LinearMap","title":"LinearMap","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/LinearMap/","page":"LinearMap","title":"LinearMap","text":"norm\nradius\ndiameter\nsingleton_list\nreflect","category":"page"},{"location":"lib/lazy_operations/LinearMap/","page":"LinearMap","title":"LinearMap","text":"Inherited from AbstractAffineMap:","category":"page"},{"location":"lib/lazy_operations/LinearMap/","page":"LinearMap","title":"LinearMap","text":"isempty\nisbounded","category":"page"},{"location":"lib/lazy_operations/LinearMap/","page":"LinearMap","title":"LinearMap","text":"The lazy projection of a set can be conveniently constructed using Projection.","category":"page"},{"location":"lib/lazy_operations/LinearMap/#LazySets.Projection","page":"LinearMap","title":"LazySets.Projection","text":"Projection(X::LazySet{N}, variables::AbstractVector{Int}) where {N}\n\nReturn a lazy projection of a set.\n\nInput\n\nX         – set\nvariables – variables of interest\n\nOutput\n\nA lazy LinearMap that corresponds to projecting X along the given variables variables.\n\nExamples\n\nThe projection of a three-dimensional cube into the first two coordinates:\n\njulia> B = BallInf([1.0, 2, 3], 1.0)\nBallInf{Float64, Vector{Float64}}([1.0, 2.0, 3.0], 1.0)\n\njulia> Bproj = Projection(B, [1, 2])\nLinearMap{Float64, BallInf{Float64, Vector{Float64}}, Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}}(sparse([1, 2], [1, 2], [1.0, 1.0], 2, 3), BallInf{Float64, Vector{Float64}}([1.0, 2.0, 3.0], 1.0))\n\njulia> isequivalent(Bproj, BallInf([1.0, 2], 1.0))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/HPolygonOpt/#def_HPolygonOpt","page":"HPolygonOpt","title":"Polygon in optimized constraint representation (HPolygonOpt)","text":"","category":"section"},{"location":"lib/sets/HPolygonOpt/#LazySets.HPolygonOpt","page":"HPolygonOpt","title":"LazySets.HPolygonOpt","text":"HPolygonOpt{N, VN<:AbstractVector{N}} <: AbstractHPolygon{N}\n\nType that represents a convex polygon in constraint representation whose edges are sorted in counter-clockwise fashion with respect to their normal directions. This implementation is a refined version of HPolygon.\n\nFields\n\nconstraints – list of linear constraints, sorted by the normal direction in                  counter-clockwise fashion\nind         – index in the list of constraints to begin the search to                  evaluate the support vector/function\n\nNotes\n\nFurther constructor arguments:\n\nsort_constraints  – (optional, default: true) flag for sorting the                        constraints (being sorted is a running assumption of                        this type)\ncheck_boundedness – (optional, default: false) flag for checking if the                        constraints make the polygon bounded; (boundedness is a                        running assumption of this type)\nprune             – (optional, default: true) flag for removing redundant                        constraints\n\nThis structure is optimized to evaluate the support vector/function with a large sequence of directions that are close to each other. The strategy is to have an index that can be used to warm-start the search for optimal values in the support-vector computation.\n\nThe option sort_constraints can be used to deactivate automatic sorting of constraints in counter-clockwise fashion, which is an invariant of this type. Alternatively, one can construct an HPolygonOpt with empty constraints list, which can then be filled iteratively using addconstraint!.\n\nSimilarly, the option prune can be used to deactivate automatic pruning of redundant constraints.\n\nAnother type assumption is that the polygon is bounded. The option check_boundedness can be used to assert this. This option is deactivated by default because we explicitly want to allow the iterative addition of the constraints, and hence one has to initially construct an empty list of constraints (which represents an unbounded set). The user has to make sure that the HPolygonOpt is not used before the constraints actually describe a bounded set.\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/HPolygonOpt/#LazySets.API.σ-Tuple{AbstractVector, HPolygonOpt}","page":"HPolygonOpt","title":"LazySets.API.σ","text":"σ(d::AbstractVector, P::HPolygonOpt;\n  [linear_search]::Bool=(length(P.constraints) < 10))\n\nReturn a support vector of an optimized polygon in a given direction.\n\nInput\n\nd             – direction\nP             – optimized polygon in constraint representation\nlinear_search – (optional, default: see below) flag for controlling whether                    to perform a linear search or a binary search\n\nOutput\n\nThe support vector in the given direction. The result is always one of the vertices; in particular, if the direction has norm zero, any vertex is returned.\n\nAlgorithm\n\nComparison of directions is performed using polar angles; see the definition of ⪯ for two-dimensional vectors.\n\nFor polygons with 10 or more constraints we use a binary search by default.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolygonOpt/#LazySets.API.translate-Tuple{HPolygonOpt, AbstractVector}","page":"HPolygonOpt","title":"LazySets.API.translate","text":"translate(P::HPolygonOpt, v::AbstractVector; share::Bool=false)\n\nTranslate (i.e., shift) an optimized polygon in constraint representation by a given vector.\n\nInput\n\nP     – optimized polygon in constraint representation\nv     – translation vector\nshare – (optional, default: false) flag for sharing unmodified parts of            the original set representation\n\nOutput\n\nA translated optimized polygon in constraint representation.\n\nNotes\n\nThe normal vectors of the constraints (vector a in a⋅x ≤ b) are shared with the original constraints if share == true.\n\nAlgorithm\n\nWe translate every constraint.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolygonOpt/","page":"HPolygonOpt","title":"HPolygonOpt","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/HPolygonOpt/","page":"HPolygonOpt","title":"HPolygonOpt","text":"norm\nradius\ndiameter\nsingleton_list\nreflect","category":"page"},{"location":"lib/sets/HPolygonOpt/","page":"HPolygonOpt","title":"HPolygonOpt","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/HPolygonOpt/","page":"HPolygonOpt","title":"HPolygonOpt","text":"isempty\nisuniversal","category":"page"},{"location":"lib/sets/HPolygonOpt/","page":"HPolygonOpt","title":"HPolygonOpt","text":"Inherited from AbstractPolygon:","category":"page"},{"location":"lib/sets/HPolygonOpt/","page":"HPolygonOpt","title":"HPolygonOpt","text":"dim\nvolume","category":"page"},{"location":"lib/sets/HPolygonOpt/","page":"HPolygonOpt","title":"HPolygonOpt","text":"Inherited from AbstractHPolygon:","category":"page"},{"location":"lib/sets/HPolygonOpt/","page":"HPolygonOpt","title":"HPolygonOpt","text":"an_element\n∈\nvertices_list\ntohrep\ntovrep\nnormalize\nisbounded\naddconstraint!\nremove_redundant_constraints!\nconstraints_list","category":"page"},{"location":"lib/sets/HPolygon/#def_HPolygon","page":"HPolygon","title":"Polygon in constraint representation (HPolygon)","text":"","category":"section"},{"location":"lib/sets/HPolygon/#LazySets.HPolygonModule.HPolygon","page":"HPolygon","title":"LazySets.HPolygonModule.HPolygon","text":"HPolygon{N, VN<:AbstractVector{N}} <: AbstractHPolygon{N}\n\nType that represents a convex polygon in constraint representation whose edges are sorted in counter-clockwise fashion with respect to their normal directions.\n\nFields\n\nconstraints – list of linear constraints, sorted by the normal direction in                  counter-clockwise fashion\n\nNotes\n\nFurther constructor arguments:\n\nsort_constraints  – (optional, default: true) flag for sorting the                        constraints (being sorted is a running assumption of                        this type)\ncheck_boundedness – (optional, default: false) flag for checking if the                        constraints make the polygon bounded; (boundedness is a                        running assumption of this type)\nprune             – (optional, default: true) flag for removing redundant                        constraints\n\nThe option sort_constraints can be used to deactivate automatic sorting of constraints in counter-clockwise fashion, which is an invariant of this type. Alternatively, one can construct an HPolygon with empty constraints list, which can then be filled iteratively using addconstraint!.\n\nSimilarly, the option prune can be used to deactivate automatic pruning of redundant constraints.\n\nAnother type assumption is that the polygon is bounded. The option check_boundedness can be used to assert this. This option is deactivated by default because we explicitly want to allow the iterative addition of the constraints, and hence one has to initially construct an empty list of constraints (which represents an unbounded set). The user has to make sure that the HPolygon is not used before the constraints actually describe a bounded set.\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/HPolygon/#Operations","page":"HPolygon","title":"Operations","text":"","category":"section"},{"location":"lib/sets/HPolygon/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-HPolygon","page":"HPolygon","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolygon/#LazySets.API.σ-Tuple{AbstractVector, HPolygon}","page":"HPolygon","title":"LazySets.API.σ","text":"Extended help\n\nσ(d::AbstractVector, P::HPolygon;\n  [linear_search]::Bool=(length(P.constraints) < 10))\n\nInput\n\nlinear_search – (optional, default: see below) flag for controlling whether                    to perform a linear search or a binary search\n\nOutput\n\nThe result is always one of the vertices; in particular, if the direction has norm zero, any vertex is returned.\n\nAlgorithm\n\nComparison of directions is performed using polar angles; see the definition of ⪯ for two-dimensional vectors.\n\nFor polygons with 10 or more constraints we use a binary search by default.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolygon/#LazySets.API.translate-Tuple{LazySets.API.LazySet, AbstractVector}-lib-sets-HPolygon","page":"HPolygon","title":"LazySets.API.translate","text":"translate(X::LazySet, v::AbstractVector)\n\nCompute the translation of a set with a vector.\n\nInput\n\nX – set\nv – vector\n\nOutput\n\nA set representing X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolygon/#LazySets.API.translate-Tuple{HPolygon, AbstractVector}","page":"HPolygon","title":"LazySets.API.translate","text":"Extended help\n\ntranslate(v::AbstractVector, P::HPolygon; [share]::Bool=false)\n\nInput\n\nshare – (optional, default: false) flag for sharing unmodified parts of            the original set representation\n\nNotes\n\nThe normal vectors of the constraints (vector a in a⋅x ≤ b) are shared with the original constraints if share == true.\n\nAlgorithm\n\nWe translate every constraint.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"isoperationtype","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nlinear_map\nsample\nscale\nρ\ncartesian_product\nconvex_hull\nexact_sum\n≈\n==\nisequivalent\n⊂\nminkowski_difference","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"extrema\nextrema\nhigh\nhigh\nispolyhedral\nlow\nlow\nproject\nisdisjoint","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"isempty\nisuniversal\nisboundedtype\n⊆\nminkowski_sum","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"Inherited from AbstractPolygon:","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"dim\nvolume","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"Inherited from AbstractHPolygon:","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"an_element\nconstraints_list\nisbounded\nnormalize\nrand\nremove_redundant_constraints!\ntohrep\ntovrep\nvertices_list\naddconstraint!\n∈\nintersection","category":"page"},{"location":"lib/sets/Line2D/#def_Line2D","page":"Line2D","title":"Line2D","text":"","category":"section"},{"location":"lib/sets/Line2D/#LazySets.Line2DModule.Line2D","page":"Line2D","title":"LazySets.Line2DModule.Line2D","text":"Line2D{N, VN<:AbstractVector{N}} <: AbstractPolyhedron{N}\n\nType that represents a line in 2D of the form ax = b (i.e., a special case of a Hyperplane).\n\nFields\n\na – normal direction (non-zero)\nb – constraint\n\nExamples\n\nThe line y = -x + 1:\n\njulia> Line2D([1., 1.], 1.)\nLine2D{Float64, Vector{Float64}}([1.0, 1.0], 1.0)\n\nThe alternative constructor takes two 2D points (AbstractVectors) p and q and creates a canonical line from p to q. See the algorithm section below for details.\n\njulia> Line2D([1., 1.], [2., 2])\nLine2D{Float64, Vector{Float64}}([-1.0, 1.0], 0.0)\n\nAlgorithm\n\nGiven two points p = (x₁ y₁) and q = (x₂ y₂), the line that passes through these points is\n\nℓy - y₁ = dfrac(y₂ - y₁)(x₂ - x₁)  (x-x₁)\n\nThe particular case x₂ = x₁ defines a line parallel to the y-axis (vertical line).\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Line2D/#Operations","page":"Line2D","title":"Operations","text":"","category":"section"},{"location":"lib/sets/Line2D/#LazySets.API.an_element-Tuple{LazySets.API.LazySet}-lib-sets-Line2D","page":"Line2D","title":"LazySets.API.an_element","text":"an_element(X::LazySet)\n\nReturn some element of a nonempty set.\n\nInput\n\nX – set\n\nOutput\n\nAn element of X unless X is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#LazySets.API.an_element-Tuple{Line2D}","page":"Line2D","title":"LazySets.API.an_element","text":"Extended help\n\nan_element(L::Line2D)\n\nAlgorithm\n\nThe algorithm is a 2D specialization of the Hyperplane algorithm.\n\nIf the b value of the line is zero, the result is the origin. Otherwise the result is some x = (x_1 x_2)ᵀ such that ax = b. We first find out the dimension i in which a = (a_1 a_2)ᵀ is nonzero and then choose x_i = fracba_i and x_3-i = 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#LazySets.constrained_dimensions-Tuple{Line2D}","page":"Line2D","title":"LazySets.constrained_dimensions","text":"constrained_dimensions(L::Line2D)\n\nReturn the indices in which a 2D line is constrained.\n\nInput\n\nL – 2D line\n\nOutput\n\nA vector of ascending indices i such that the line is constrained in dimension i.\n\nExamples\n\nA line with constraint x_i = 0 (i  1 2) is only constrained in dimension i.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#LazySets.API.isuniversal-lib-sets-Line2D","page":"Line2D","title":"LazySets.API.isuniversal","text":"isuniversal(X::LazySet, witness::Bool=false)\n\nCheck whether a set is universal.\n\nInput\n\nX       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X = ℝ^n\nIf the witness option is activated:\n(true, []) iff X = ℝ^n\n(false, v) iff X  ℝ^n for some v  X\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/Line2D/#LazySets.API.isuniversal","page":"Line2D","title":"LazySets.API.isuniversal","text":"Extended help\n\nisuniversal(L::Line2D, [witness]::Bool=false)\n\nAlgorithm\n\nWitness production falls back to isuniversal(::Hyperplane).\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/Line2D/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-Line2D","page":"Line2D","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#Base.rand-Tuple{Type{Line2D}}","page":"Line2D","title":"Base.rand","text":"Extended help\n\nrand(::Type{Line2D}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the constraint a is nonzero.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-Line2D","page":"Line2D","title":"Base.:∈","text":"∈(x::AbstractVector, X::LazySet)\n\nCheck whether a point lies in a set.\n\nInput\n\nx – point/vector\nX – set\n\nOutput\n\ntrue iff x  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#Base.:∈-Tuple{AbstractVector, Line2D}","page":"Line2D","title":"Base.:∈","text":"Extended help\n\n∈(x::AbstractVector, L::Line2D)\n\nAlgorithm\n\nThe point x belongs to the line if and only if ax = b holds.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#LazySets.API.project-Tuple{AbstractVector, Line2D}","page":"Line2D","title":"LazySets.API.project","text":"project(x::AbstractVector, L::Line2D)\n\nProject a point onto a 2D line.\n\nInput\n\nx – point/vector\nL – 2D line\n\nOutput\n\nThe projection of x onto L.\n\nAlgorithm\n\nThe projection of x onto a line of the form ax = b is\n\n    x - dfraca (ax - b)a²\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#LazySets.API.translate-Tuple{LazySets.API.LazySet, AbstractVector}-lib-sets-Line2D","page":"Line2D","title":"LazySets.API.translate","text":"translate(X::LazySet, v::AbstractVector)\n\nCompute the translation of a set with a vector.\n\nInput\n\nX – set\nv – vector\n\nOutput\n\nA set representing X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#LazySets.API.translate-Tuple{Line2D, AbstractVector}","page":"Line2D","title":"LazySets.API.translate","text":"Extended help\n\ntranslate(L::Line2D, v::AbstractVector; [share]::Bool=false)\n\nNotes\n\nThe normal vector of the line (vector a in a⋅x = b) is shared with the original line if share == true.\n\nAlgorithm\n\nA line ax = b is transformed to the line ax = b + av. In other words, we add the dot product av to b.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#LazySets.API.intersection-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-sets-Line2D","page":"Line2D","title":"LazySets.API.intersection","text":"intersection(X::LazySet, Y::LazySet)\n\nCompute the intersection of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the intersection X  Y.\n\nNotes\n\nThe intersection of two sets X and Y is defined as\n\n    X  Y = x mid x  X text and  x  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#LazySets.API.intersection-Tuple{Line2D, Line2D}","page":"Line2D","title":"LazySets.API.intersection","text":"Extended help\n\nintersection(L1::Line2D, L2::Line2D)\n\nOutput\n\nThree outcomes are possible:\n\nIf the lines are identical, the result is the first line.\nIf the lines are parallel and not identical, the result is the empty set.\nOtherwise the result is the set with the unique intersection point.\n\nAlgorithm\n\nWe first check whether the lines are parallel. If not, we use Cramer's rule to compute the intersection point.\n\nExamples\n\nThe line y = x intersected with the line y = -x + 1 respectively with itself:\n\njulia> intersection(Line2D([-1.0, 1], 0.0), Line2D([1.0, 1], 1.0))\nSingleton{Float64, Vector{Float64}}([0.5, 0.5])\n\njulia> intersection(Line2D([1.0, 1], 1.0), Line2D([1.0, 1], 1.0))\nLine2D{Float64, Vector{Float64}}([1.0, 1.0], 1.0)\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/","page":"Line2D","title":"Line2D","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/Line2D/","page":"Line2D","title":"Line2D","text":"constraints_list\ndim\nisbounded\nisempty\nisoperationtype\nproject\nσ\nisdisjoint","category":"page"},{"location":"lib/sets/Line2D/","page":"Line2D","title":"Line2D","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Line2D/","page":"Line2D","title":"Line2D","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisboundedtype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\nvolume\naffine_map\nexponential_map\nis_interior_point\nlinear_map\nsample\nscale\nρ\ntranslate!\ncartesian_product\nconvex_hull\nexact_sum\n≈\n==\nisequivalent\n⊂\nminkowski_difference","category":"page"},{"location":"lib/sets/Line2D/","page":"Line2D","title":"Line2D","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/Line2D/","page":"Line2D","title":"Line2D","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/Line2D/","page":"Line2D","title":"Line2D","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/Line2D/","page":"Line2D","title":"Line2D","text":"extrema\nextrema\nhigh\nhigh\nispolyhedral\nlow\nlow\nvertices_list\n⊆\nminkowski_sum","category":"page"},{"location":"lib/sets/VPolytope/#def_VPolytope","page":"VPolytope","title":"Polytope in vertex representation (VPolytope)","text":"","category":"section"},{"location":"lib/sets/VPolytope/#LazySets.VPolytopeModule.VPolytope","page":"VPolytope","title":"LazySets.VPolytopeModule.VPolytope","text":"VPolytope{N, VN<:AbstractVector{N}, VT<:AbstractVector{VN}} <: AbstractPolytope{N}\n\nType that represents a convex polytope in vertex representation.\n\nFields\n\nvertices – list of vertices\n\nExamples\n\nA polytope in vertex representation can be constructed by passing the list of vertices. For example, we can build the tetrahedron:\n\njulia> P = VPolytope([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]]);\n\njulia> P.vertices\n4-element Vector{Vector{Int64}}:\n [0, 0, 0]\n [1, 0, 0]\n [0, 1, 0]\n [0, 0, 1]\n\nAlternatively, a VPolytope can be constructed passing a matrix of vertices, where each column represents a vertex:\n\njulia> M = [0 0 0; 1 0 0; 0 1 0; 0 0 1]'\n3×4 adjoint(::Matrix{Int64}) with eltype Int64:\n 0  1  0  0\n 0  0  1  0\n 0  0  0  1\n\njulia> P = VPolytope(M);\n\njulia> P.vertices\n4-element Vector{Vector{Int64}}:\n [0, 0, 0]\n [1, 0, 0]\n [0, 1, 0]\n [0, 0, 1]\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/VPolytope/#Conversion","page":"VPolytope","title":"Conversion","text":"","category":"section"},{"location":"lib/sets/VPolytope/#Base.convert-Tuple{Type{VPolytope}, LazySet}","page":"VPolytope","title":"Base.convert","text":"convert(::Type{VPolytope}, X::LazySet; [prune]::Bool=true)\n\nConvert a polytopic set to a polytope in vertex representation.\n\nInput\n\nVPolytope – target type\nX         – polytopic set\nprune     – (optional, default: true) option to remove redundant vertices\n\nOutput\n\nThe given set represented as a polytope in vertex representation.\n\nAlgorithm\n\nThis method uses vertices_list. Use the option prune to select whether to remove redundant vertices before constructing the polytope.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/","page":"VPolytope","title":"VPolytope","text":"convert(::Type{VPolytope}, ::Polyhedra.VRep)","category":"page"},{"location":"lib/sets/VPolytope/#Operations","page":"VPolytope","title":"Operations","text":"","category":"section"},{"location":"lib/sets/VPolytope/#LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}-lib-sets-VPolytope","page":"VPolytope","title":"LazySets.API.constraints_list","text":"constraints_list(X::LazySet)\n\nCompute a list of linear constraints of a polyhedral set.\n\nInput\n\nX – polyhedral set\n\nOutput\n\nA list of the linear constraints of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.API.constraints_list-Tuple{VPolytope}","page":"VPolytope","title":"LazySets.API.constraints_list","text":"constraints_list(P::VPolytope)\n\nAlgorithm\n\nFor one- and two-dimensional sets, we respectively convert to an Interval or a VPolytope and call the corresponding constraints_list function. For higher-dimensional sets, we use tohrep to compute the constraint representation and call the corresponding constraints_list function.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.API.dim-Tuple{LazySets.API.LazySet}-lib-sets-VPolytope","page":"VPolytope","title":"LazySets.API.dim","text":"dim(X::LazySet)\n\nCompute the ambient dimension of a set.\n\nInput\n\nX – set\n\nOutput\n\nThe ambient dimension of the set.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.API.dim-Tuple{VPolytope}","page":"VPolytope","title":"LazySets.API.dim","text":"dim(P::VPolytope)\n\nOutput\n\nIf P is empty, the result is -1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#Polyhedra.polyhedron-Tuple{VPolytope}","page":"VPolytope","title":"Polyhedra.polyhedron","text":"polyhedron(P::VPolytope;\n           [backend]=default_polyhedra_backend(P),\n           [relative_dimension]=nothing)\n\nReturn a VRep polyhedron from Polyhedra.jl given a polytope in vertex representation.\n\nInput\n\nP       – polytope in vertex representation\nbackend – (optional, default: default_polyhedra_backend(P)) the              backend for polyhedral computations; see Polyhedra's              documentation for further              information\nrelative_dimension – (default, optional: nothing) an integer representing                         the (relative) dimension of the polytope; this                         argument is mandatory if the polytope is empty\n\nOutput\n\nA VRep polyhedron.\n\nNotes\n\nThe relative dimension (or just dimension) refers to the dimension of the set relative to itself, independently of the ambient dimension. For example, a point has (relative) dimension zero, and a line segment has (relative) dimension one.\n\nIn this library, dim always returns the ambient dimension of the set, such that a line segment in two dimensions has dimension two. However, Polyhedra.dim will assign a dimension equal to one to a line segment because it uses a different convention.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-VPolytope","page":"VPolytope","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#Base.rand-Tuple{Type{VPolytope}}","page":"VPolytope","title":"Base.rand","text":"Extended help\n\nrand(::Type{VPolytope}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing,\n     [num_vertices]::Int=-1)\n\nInput\n\nnum_vertices – (optional, default: -1) upper bound on the number of                   vertices of the polytope (see comment below)\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1.\n\nThe number of vertices can be controlled with the argument num_vertices. For a negative value we choose a random number in the range dim:5*dim (except if dim == 1, in which case we choose in the range 1:2).\n\nNote that this implementation does not guarantee that the vertices are not redundant, and hence the result may have fewer vertices than specified in num_vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.remove_redundant_vertices-Tuple{VPolytope}","page":"VPolytope","title":"LazySets.remove_redundant_vertices","text":"remove_redundant_vertices(P::VPolytope; [backend]=nothing, [solver]=nothing)\n\nReturn the polytope obtained by removing the redundant vertices of the given polytope in vertex representation.\n\nInput\n\nP       – polytope in vertex representation\nbackend – (optional, default: nothing) the backend for polyhedral              computations; see default_polyhedra_backend(P) or              Polyhedra's documentation              for further information\nsolver  – (optional, default: nothing) the linear programming              solver used in the backend, if needed; see              default_lp_solver_polyhedra(N)\n\nOutput\n\nA new polytope such that its vertices are the convex hull of the given polytope.\n\nNotes\n\nThe optimization problem associated to removing redundant vertices is handled by Polyhedra. If the polyhedral computations backend requires an LP solver, but it has not been specified, we use default_lp_solver_polyhedra(N) to define such solver. Otherwise, the redundancy-removal function of the polyhedral backend is used.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.tohrep-Tuple{VPolytope}","page":"VPolytope","title":"LazySets.tohrep","text":"tohrep(P::VPolytope; [backend]=default_polyhedra_backend(P))\n\nTransform a polytope in vertex representation to a polytope in constraint representation.\n\nInput\n\nP       – polytope in vertex representation\nbackend – (optional, default: default_polyhedra_backend(P)) the              backend for polyhedral computations; see Polyhedra's              documentation for further              information\n\nOutput\n\nA HPolytope as the constraint representation of P.\n\nNotes\n\nThe conversion may not preserve the numeric type (e.g., with N == Float32) depending on the backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.tovrep-Tuple{VPolytope}","page":"VPolytope","title":"LazySets.tovrep","text":"tovrep(P::VPolytope)\n\nReturn a vertex representation of the given polytope in vertex representation (no-op).\n\nInput\n\nP – polytope in vertex representation\n\nOutput\n\nThe same polytope instance.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.API.linear_map-Tuple{AbstractMatrix, LazySets.API.LazySet}-lib-sets-VPolytope","page":"VPolytope","title":"LazySets.API.linear_map","text":"linear_map(M::AbstractMatrix, X::LazySet)\n\nCompute the linear map M  X.\n\nInput\n\nM – matrix\nX – set\n\nOutput\n\nA set representing the linear map M  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.API.linear_map-Tuple{AbstractMatrix, VPolytope}","page":"VPolytope","title":"LazySets.API.linear_map","text":"Extended help\n\nlinear_map(M::AbstractMatrix, P::VPolytope; [apply_convex_hull]::Bool=false)\n\nInput\n\napply_convex_hull – (optional, default: false) flag for applying a convex                        hull to eliminate redundant vertices\n\nAlgorithm\n\nThe linear map M is applied to each vertex of the given set P, obtaining a polytope in vertex representation. The output type is again a VPolytope.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-VPolytope","page":"VPolytope","title":"Base.:∈","text":"∈(x::AbstractVector, X::LazySet)\n\nCheck whether a point lies in a set.\n\nInput\n\nx – point/vector\nX – set\n\nOutput\n\ntrue iff x  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#Base.:∈-Union{Tuple{N}, Tuple{AbstractVector{N}, VPolytope{N, VN, VT} where {VN<:AbstractVector{N}, VT<:AbstractVector{VN}}}} where N","page":"VPolytope","title":"Base.:∈","text":"Extended help\n\n∈(x::AbstractVector{N}, P::VPolytope{N};\n  solver=default_lp_solver(N)) where {N}\n\nInput\n\nsolver – (optional, default: default_lp_solver(N)) the backend used to             solve the linear program\n\nAlgorithm\n\nWe check, using linear programming, the definition of a convex polytope that a point is in the set if and only if it is a convex combination of the vertices.\n\nLet v_j be the m vertices of P. Then we solve the following m-dimensional linear program.\n\nmax 0 text st \n_i=1^n _j=1^m λ_j v_ji = xi\n _j=1^m λ_j = 1\n _j=1^m λ_j  0\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-VPolytope","page":"VPolytope","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.API.σ-Tuple{AbstractVector, VPolytope}","page":"VPolytope","title":"LazySets.API.σ","text":"Extended help\n\nσ(d::AbstractVector, P::VPolytope)\n\nAlgorithm\n\nA support vector maximizes the support function. For a polytope, the support function is always maximized in some vertex. Hence it is sufficient to check all vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.API.cartesian_product-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-sets-VPolytope","page":"VPolytope","title":"LazySets.API.cartesian_product","text":"cartesian_product(X::LazySet, Y::LazySet)\n\nCompute the Cartesian product of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the Cartesian product X  Y.\n\nNotes\n\nThe Cartesian product of two sets X and Y is defined as\n\n    X  Y = x y mid x  X y  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.API.cartesian_product-Tuple{VPolytope, VPolytope}","page":"VPolytope","title":"LazySets.API.cartesian_product","text":"Extended help\n\ncartesian_product(P1::VPolytope, P2::VPolytope; [backend]=nothing)\n\nInput\n\nbackend – (optional, default: nothing) backend for polyhedral computation\n\nNotes\n\nFor further information on the supported backends see Polyhedra's documentation.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.API.convex_hull-Tuple{VPolytope, VPolytope}","page":"VPolytope","title":"LazySets.API.convex_hull","text":"convex_hull(P1::VPolytope, P2::VPolytope; [backend]=nothing)\n\nCompute the convex hull of two polytopes in vertex representation.\n\nInput\n\nP1      – polytope in vertex representation\nP2      – polytope in vertex representation\nbackend – (optional, default: nothing) the polyhedral computation backend\n\nOutput\n\nThe VPolytope obtained by the concrete convex hull of P1 and P2.\n\nNotes\n\nThis function takes the union of the vertices of each polytope and then relies on a concrete convex-hull algorithm.\n\nThe implementation relies on the polyhedral backend, which can be specified using the backend keyword argument.\n\nFor performance reasons, it is suggested to use the CDDLib.Library() backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.API.intersection-Tuple{Union{VPolygon, VPolytope}, Union{VPolygon, VPolytope}}-lib-sets-VPolytope","page":"VPolytope","title":"LazySets.API.intersection","text":"intersection(P1::Union{VPolygon, VPolytope}, P2::Union{VPolygon, VPolytope};\n             [backend]=nothing, [prunefunc]=nothing)\n\nCompute the intersection of two polytopes in vertex representation.\n\nInput\n\nP1        – polytope in vertex representation\nP2        – polytope in vertex representation\nbackend   – (optional, default: nothing) the backend for polyhedral                computations\nprunefunc – (optional, default: nothing) function to prune the vertices                of the result\n\nOutput\n\nA VPolytope.\n\nNotes\n\nIf prunefunc is nothing, this implementation sets it to (X -> removevredundancy!(X; tol=_ztol(eltype(P1)))).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.API.minkowski_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-sets-VPolytope","page":"VPolytope","title":"LazySets.API.minkowski_sum","text":"minkowski_sum(X::LazySet, Y::LazySet)\n\nCompute the Minkowski sum of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the Minkowski sum X  Y.\n\nNotes\n\nThe Minkowski sum of two sets X and Y is defined as\n\n    X  Y = x + y mid x  X y  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.API.minkowski_sum-Tuple{VPolytope, VPolytope}","page":"VPolytope","title":"LazySets.API.minkowski_sum","text":"Extended help\n\nminkowski_sum(P1::VPolytope, P2::VPolytope;\n              [apply_convex_hull]=true,\n              [backend]=nothing,\n              [solver]=nothing)\n\nInput\n\napply_convex_hull – (optional, default: true) if true, post-process the                        pairwise sums using a convex-hull algorithm\nbackend           – (optional, default: nothing) the backend for                        polyhedral computations used to post-process with a                        convex hull; see default_polyhedra_backend(P1)\nsolver            – (optional, default: nothing) the backend used to                        solve the linear program; see                        default_lp_solver_polyhedra(N)\n\nAlgorithm\n\nThe resulting polytope in vertex representation consists of the vertices corresponding to the convex hull of the sum of all possible sums of vertices of P1 and P2.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/","page":"VPolytope","title":"VPolytope","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/VPolytope/","page":"VPolytope","title":"VPolytope","text":"extrema\nextrema\nhigh\nhigh\nisoperationtype\nlow\nlow\nvertices_list\npermute\nproject\nreflect\nscale\nscale!\nρ\ntranslate\ntranslate!","category":"page"},{"location":"lib/sets/VPolytope/","page":"VPolytope","title":"VPolytope","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/VPolytope/","page":"VPolytope","title":"VPolytope","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nsample\nexact_sum\n≈\n==\nisequivalent\n⊂\nminkowski_difference","category":"page"},{"location":"lib/sets/VPolytope/","page":"VPolytope","title":"VPolytope","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/VPolytope/","page":"VPolytope","title":"VPolytope","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/VPolytope/","page":"VPolytope","title":"VPolytope","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/VPolytope/","page":"VPolytope","title":"VPolytope","text":"an_element\nispolyhedral\nisdisjoint","category":"page"},{"location":"lib/sets/VPolytope/","page":"VPolytope","title":"VPolytope","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/VPolytope/","page":"VPolytope","title":"VPolytope","text":"isbounded\nisboundedtype\nisempty\nisuniversal\nvolume\n⊆","category":"page"},{"location":"lib/sets/HPolyhedron/#def_HPolyhedron","page":"HPolyhedron","title":"Polyhedron in constraint representation (HPolyhedron)","text":"","category":"section"},{"location":"lib/sets/HPolyhedron/#LazySets.HPolyhedronModule.HPolyhedron","page":"HPolyhedron","title":"LazySets.HPolyhedronModule.HPolyhedron","text":"HPolyhedron{N, VN<:AbstractVector{N}} <: AbstractPolyhedron{N}\n\nType that represents a convex polyhedron in constraint representation, that is, a finite intersection of half-spaces,\n\nP = _i = 1^m H_i\n\nwhere each H_i = x  ℝ^n  a_i^T x  b_i  is a half-space, a_i  ℝ^n is the normal vector of the i-th half-space and b_i is the displacement. The set P may or may not be bounded (see also HPolytope, which assumes boundedness).\n\nFields\n\nconstraints – vector of linear constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/HPolyhedron/#Conversion","page":"HPolyhedron","title":"Conversion","text":"","category":"section"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"convert(::Type{HPolyhedron}, ::LazySet)\nconvert(::Type{HPolyhedron}, ::Polyhedra.HRep)","category":"page"},{"location":"lib/sets/HPolyhedron/#Operations","page":"HPolyhedron","title":"Operations","text":"","category":"section"},{"location":"lib/sets/HPolyhedron/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-HPolyhedron","page":"HPolyhedron","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#Base.rand-Tuple{Type{HPolyhedron}}","page":"HPolyhedron","title":"Base.rand","text":"Extended help\n\nrand(::Type{HPolyhedron}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nAlgorithm\n\nWe first create a random polytope and then for each constraint randomly (50%) decide whether to include it.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"The following methods are shared between HPolytope and HPolyhedron.","category":"page"},{"location":"lib/sets/HPolyhedron/#LazySets.API.dim-Tuple{LazySets.API.LazySet}-lib-sets-HPolyhedron","page":"HPolyhedron","title":"LazySets.API.dim","text":"dim(X::LazySet)\n\nCompute the ambient dimension of a set.\n\nInput\n\nX – set\n\nOutput\n\nThe ambient dimension of the set.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.API.dim-Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}} where N}","page":"HPolyhedron","title":"LazySets.API.dim","text":"Extended help\n\ndim(P::HPoly)\n\nOutput\n\nIf P has no constraints, the result is -1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LinearAlgebra.normalize-Union{Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}}}, Tuple{N}, Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}}, Real}} where N","page":"HPolyhedron","title":"LinearAlgebra.normalize","text":"normalize(P::HPoly{N}, p::Real=N(2)) where {N}\n\nNormalize a polyhedron in constraint representation.\n\nInput\n\nP – polyhedron in constraint representation\np – (optional, default: 2) norm\n\nOutput\n\nA new polyhedron in constraint representation whose normal directions a_i are normalized, i.e., such that a_i_p = 1 holds.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.remove_redundant_constraints-Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}} where N}","page":"HPolyhedron","title":"LazySets.remove_redundant_constraints","text":"remove_redundant_constraints(P::HPoly{N}; [backend]=nothing) where {N}\n\nRemove the redundant constraints in a polyhedron in constraint representation.\n\nInput\n\nP       – polyhedron\nbackend – (optional, default: nothing) the backend used to solve the              linear program\n\nOutput\n\nA polyhedron equivalent to P but with no redundant constraints, or an empty set if P is detected to be empty, which may happen if the constraints are infeasible.\n\nNotes\n\nIf backend is nothing, it defaults to default_lp_solver(N).\n\nAlgorithm\n\nSee remove_redundant_constraints!(::AbstractVector{<:HalfSpace}) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.remove_redundant_constraints!-Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}} where N}","page":"HPolyhedron","title":"LazySets.remove_redundant_constraints!","text":"remove_redundant_constraints!(P::HPoly{N}; [backend]=nothing) where {N}\n\nRemove the redundant constraints of a polyhedron in constraint representation; the polyhedron is updated in-place.\n\nInput\n\nP       – polyhedron\nbackend – (optional, default: nothing) the backend used to solve the              linear program\n\nOutput\n\ntrue if the method was successful and the polyhedron P is modified by removing its redundant constraints, and false if P is detected to be empty, which may happen if the constraints are infeasible.\n\nNotes\n\nIf backend is nothing, it defaults to default_lp_solver(N).\n\nAlgorithm\n\nSee remove_redundant_constraints!(::AbstractVector{<:HalfSpace}) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.tohrep-Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}} where N}","page":"HPolyhedron","title":"LazySets.tohrep","text":"tohrep(P::HPoly)\n\nReturn a constraint representation of the given polyhedron in constraint representation (no-op).\n\nInput\n\nP – polyhedron in constraint representation\n\nOutput\n\nThe same polyhedron instance.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.tovrep-Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}} where N}","page":"HPolyhedron","title":"LazySets.tovrep","text":"tovrep(P::HPoly; [backend]=default_polyhedra_backend(P))\n\nTransform a polytope in constraint representation to a polytope in vertex representation.\n\nInput\n\nP       – polytope in constraint representation\nbackend – (optional, default: default_polyhedra_backend(P)) the              backend for polyhedral computations\n\nOutput\n\nA VPolytope which is a vertex representation of the given polytope in constraint representation.\n\nNotes\n\nThe conversion may not preserve the numeric type (e.g., with N == Float32) depending on the backend. For further information on the supported backends see Polyhedra's documentation.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.addconstraint!-Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}} where N, HalfSpace}","page":"HPolyhedron","title":"LazySets.addconstraint!","text":"addconstraint!(P::HPoly, constraint::HalfSpace)\n\nAdd a linear constraint to a polyhedron in constraint representation.\n\nInput\n\nP          – polyhedron in constraint representation\nconstraint – linear constraint to add\n\nNotes\n\nIt is left to the user to guarantee that the dimension of all linear constraints is the same.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-HPolyhedron","page":"HPolyhedron","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, X::LazySet)\n\nEvaluate the support function of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nThe evaluation of the support function of X in direction d.\n\nNotes\n\nA convenience alias support_function is also available.\n\nWe have the following identity based on the support vector σ:\n\n    ρ(d X) = d  σ(d X)\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.API.ρ-Union{Tuple{N}, Tuple{M}, Tuple{AbstractVector{M}, Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}}}} where {M, N}","page":"HPolyhedron","title":"LazySets.API.ρ","text":"Extended help\n\nρ(d::AbstractVector{M}, P::HPoly{N};\n  solver=default_lp_solver(M, N)) where {M, N}\n\nInput\n\nsolver – (optional, default: default_lp_solver(M, N)) the backend used to             solve the linear program\n\nOutput\n\nIf P is unbounded in the given direction, there are two cases:\n\nIf P is an HPolytope, we throw an error.\nIf P is an HPolyedron, the result is Inf.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-HPolyhedron","page":"HPolyhedron","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.API.σ-Union{Tuple{N}, Tuple{M}, Tuple{AbstractVector{M}, Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}}}} where {M, N}","page":"HPolyhedron","title":"LazySets.API.σ","text":"Extended help\n\nσ(d::AbstractVector{M}, P::HPoly{N};\n  solver=default_lp_solver(M, N) where {M, N}\n\nInput\n\nsolver – (optional, default: default_lp_solver(M, N)) the backend used to             solve the linear program\n\nOutput\n\nIf P is unbounded in the given direction, there are two cases:\n\nIf P is an HPolytope, we throw an error.\nIf P is an HPolyedron, the result contains ±Inf entries.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.API.translate-Tuple{LazySets.API.LazySet, AbstractVector}-lib-sets-HPolyhedron","page":"HPolyhedron","title":"LazySets.API.translate","text":"translate(X::LazySet, v::AbstractVector)\n\nCompute the translation of a set with a vector.\n\nInput\n\nX – set\nv – vector\n\nOutput\n\nA set representing X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.API.translate-Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}} where N, AbstractVector}","page":"HPolyhedron","title":"LazySets.API.translate","text":"Extended help\n\ntranslate(P::HPoly, v::AbstractVector; [share]::Bool=false)\n\nInput\n\nshare – (optional, default: false) flag for sharing unmodified parts of            the original set representation\n\nNotes\n\nThe normal vectors of the constraints (vector a in a⋅x ≤ b) are shared with the original constraints if share == true.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.API.convex_hull-Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}} where N, Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}} where N}","page":"HPolyhedron","title":"LazySets.API.convex_hull","text":"convex_hull(P1::HPoly, P2::HPoly;\n           [backend]=default_polyhedra_backend(P1))\n\nCompute the convex hull of the set union of two polyhedra in constraint representation.\n\nInput\n\nP1      – polyhedron\nP2      – polyhedron\nbackend – (optional, default: default_polyhedra_backend(P1)) the              backend for polyhedral computations\n\nOutput\n\nThe HPolyhedron (resp. HPolytope) obtained by the concrete convex hull of P1 and P2.\n\nNotes\n\nFor performance reasons, it is suggested to use the CDDLib.Library() backend for the convex_hull.\n\nFor further information on the supported backends see Polyhedra's documentation.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"constraints_list\nisempty","category":"page"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"ishyperplanar(::HPolyhedron)","category":"page"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"isoperationtype\npermute\nminkowski_sum","category":"page"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisboundedtype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\nvolume\naffine_map\nexponential_map\nis_interior_point\nlinear_map\nsample\nscale\ncartesian_product\ndifference\nexact_sum\n≈\n==\nisequivalent\n⊂\nminkowski_difference","category":"page"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"an_element\nconstrained_dimensions\nextrema\nextrema\nhigh\nhigh\nisbounded\nispolyhedral\nisuniversal\nlow\nlow\nvertices_list\n∈\nproject\nintersection\nisdisjoint\n⊆\nminkowski_sum","category":"page"},{"location":"lib/interfaces/AbstractPolyhedron/","page":"Polyhedra (AbstractPolyhedron)","title":"Polyhedra (AbstractPolyhedron)","text":"Pages = [\"AbstractPolyhedron.md\"]\nDepth = 3","category":"page"},{"location":"lib/interfaces/AbstractPolyhedron/#def_AbstractPolyhedron","page":"Polyhedra (AbstractPolyhedron)","title":"Polyhedra (AbstractPolyhedron)","text":"","category":"section"},{"location":"lib/interfaces/AbstractPolyhedron/","page":"Polyhedra (AbstractPolyhedron)","title":"Polyhedra (AbstractPolyhedron)","text":"A polyhedron has finitely many facets (H-representation) and is not necessarily bounded.","category":"page"},{"location":"lib/interfaces/AbstractPolyhedron/#LazySets.AbstractPolyhedron","page":"Polyhedra (AbstractPolyhedron)","title":"LazySets.AbstractPolyhedron","text":"AbstractPolyhedron{N} <: ConvexSet{N}\n\nAbstract type for closed convex polyhedral sets.\n\nNotes\n\nSee HPolyhedron for a standard implementation of this interface.\n\nEvery concrete AbstractPolyhedron must define the following functions:\n\nconstraints_list(::AbstractPolyhedron) – return a list of all facet constraints\n\nPolyhedra are defined as the intersection of a finite number of closed half-spaces. As such, polyhedra are closed and convex but not necessarily bounded. Bounded polyhedra are called polytopes (see AbstractPolytope).\n\nThe subtypes of AbstractPolyhedron (including abstract interfaces):\n\njulia> subtypes(AbstractPolyhedron)\n8-element Vector{Any}:\n AbstractPolytope\n HPolyhedron\n HalfSpace\n Hyperplane\n Line\n Line2D\n Star\n Universe\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/AbstractPolyhedron/","page":"Polyhedra (AbstractPolyhedron)","title":"Polyhedra (AbstractPolyhedron)","text":"This interface requires to implement the following function:","category":"page"},{"location":"lib/interfaces/AbstractPolyhedron/#LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractPolyhedron","page":"Polyhedra (AbstractPolyhedron)","title":"LazySets.API.constraints_list","text":"constraints_list(X::LazySet)\n\nCompute a list of linear constraints of a polyhedral set.\n\nInput\n\nX – polyhedral set\n\nOutput\n\nA list of the linear constraints of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolyhedron/","page":"Polyhedra (AbstractPolyhedron)","title":"Polyhedra (AbstractPolyhedron)","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/AbstractPolyhedron/#LazySets.API.an_element-Tuple{AbstractPolyhedron}","page":"Polyhedra (AbstractPolyhedron)","title":"LazySets.API.an_element","text":"an_element(P::AbstractPolyhedron; [solver]=default_lp_solver(eltype(P)))\n\nReturn some element of a polyhedron.\n\nInput\n\nP       – polyhedron\nsolver  – (optional, default: default_lp_solver(N)) LP solver\n\nOutput\n\nAn element of the polyhedron, or an error if the polyhedron is empty.\n\nAlgorithm\n\nAn element is obtained by solving a feasibility linear program.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolyhedron/#LazySets.constrained_dimensions-Tuple{AbstractPolyhedron}","page":"Polyhedra (AbstractPolyhedron)","title":"LazySets.constrained_dimensions","text":"constrained_dimensions(P::AbstractPolyhedron)\n\nReturn the indices in which a polyhedron is constrained.\n\nInput\n\nP – polyhedron\n\nOutput\n\nA vector of ascending indices i such that the polyhedron is constrained in dimension i.\n\nExamples\n\nA 2D polyhedron with constraint x1  0 is constrained in dimension 1 only.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolyhedron/#LazySets.API.isbounded-Tuple{AbstractPolyhedron}","page":"Polyhedra (AbstractPolyhedron)","title":"LazySets.API.isbounded","text":"isbounded(P::AbstractPolyhedron; [solver]=default_lp_solver(eltype(P)))\n\nCheck whether a polyhedron is bounded.\n\nInput\n\nP       – polyhedron\nsolver  – (optional, default: default_lp_solver(N)) the backend used              to solve the linear program\n\nOutput\n\ntrue iff the polyhedron is bounded\n\nAlgorithm\n\nWe first check if the polyhedron has more than dim(P) constraints, which is a necessary condition for boundedness.\n\nIf so, we check boundedness via _isbounded_stiemke.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolyhedron/#LazySets.API.isuniversal-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractPolyhedron","page":"Polyhedra (AbstractPolyhedron)","title":"LazySets.API.isuniversal","text":"isuniversal(X::LazySet, witness::Bool=false)\n\nCheck whether a set is universal.\n\nInput\n\nX       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X = ℝ^n\nIf the witness option is activated:\n(true, []) iff X = ℝ^n\n(false, v) iff X  ℝ^n for some v  X\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolyhedron/#LazySets.API.isuniversal","page":"Polyhedra (AbstractPolyhedron)","title":"LazySets.API.isuniversal","text":"Extended help\n\nisuniversal(P::AbstractPolyhedron, [witness]::Bool=false)\n\nAlgorithm\n\nP is universal iff it has no constraints.\n\nA witness is produced using isuniversal(H) where H is the first linear constraint of P.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractPolyhedron/#LazySets.API.vertices_list-Tuple{AbstractPolyhedron}","page":"Polyhedra (AbstractPolyhedron)","title":"LazySets.API.vertices_list","text":"vertices_list(P::AbstractPolyhedron; check_boundedness::Bool=true)\n\nReturn the list of vertices of a polyhedron in constraint representation.\n\nInput\n\nP                 – polyhedron in constraint representation\ncheck_boundedness – (optional, default: true) if true, check whether                        the polyhedron is bounded\n\nOutput\n\nThe list of vertices of P, or an error if P is unbounded.\n\nNotes\n\nThis function throws an error if the polyhedron is unbounded. Otherwise, the polyhedron is converted to an HPolytope and its list of vertices is computed.\n\nExamples\n\njulia> P = HPolyhedron([HalfSpace([1.0, 0.0], 1.0),\n                        HalfSpace([0.0, 1.0], 1.0),\n                        HalfSpace([-1.0, 0.0], 1.0),\n                        HalfSpace([0.0, -1.0], 1.0)]);\n\njulia> length(vertices_list(P))\n4\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolyhedron/#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractPolyhedron","page":"Polyhedra (AbstractPolyhedron)","title":"Base.:∈","text":"∈(x::AbstractVector, X::LazySet)\n\nCheck whether a point lies in a set.\n\nInput\n\nx – point/vector\nX – set\n\nOutput\n\ntrue iff x  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolyhedron/#Base.:∈-Tuple{AbstractVector, AbstractPolyhedron}","page":"Polyhedra (AbstractPolyhedron)","title":"Base.:∈","text":"Extended help\n\n∈(x::AbstractVector, P::AbstractPolyhedron)\n\nAlgorithm\n\nThis implementation checks if the point lies inside each defining half-space.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolyhedron/#LazySets.API.project-Tuple{AbstractPolyhedron, AbstractVector{Int64}}","page":"Polyhedra (AbstractPolyhedron)","title":"LazySets.API.project","text":"project(P::AbstractPolyhedron, block::AbstractVector{Int}; [kwargs...])\n\nConcrete projection of a polyhedral set.\n\nInput\n\nP     – set\nblock – block structure, a vector with the dimensions of interest\n\nOutput\n\nA polyhedron representing the projection of P on the dimensions specified by block. If P was bounded, the result is an HPolytope; otherwise the result is an HPolyhedron. Note that there are more specific methods for specific input types, which give a different output type; e.g., projecting a Ball1 results in a Ball1.\n\nAlgorithm\n\nWe first try to exploit the special case where each of the constraints of P and block are compatible, which is one of the two cases described below. Let c be a constraint of P and let D_c and D_b be the set of dimensions in which c resp. block are constrained.\nIf D_c  D_b, then one can project the normal vector of c.\nIf D_c  D_b = , then the constraint becomes redundant.\nIn the general case, we compute the concrete linear map of the projection matrix associated to the given block structure.\n\nExamples\n\nConsider the four-dimensional cross-polytope (unit ball in the 1-norm):\n\njulia> P = convert(HPolytope, Ball1(zeros(4), 1.0));\n\nAll dimensions are constrained, and computing the (trivial) projection on the whole space behaves as expected:\n\njulia> constrained_dimensions(P)\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> project(P, [1, 2, 3, 4]) == P\ntrue\n\nEach constraint of the cross polytope is constrained in all dimensions.\n\nNow let us take a ball in the infinity norm and remove some constraints:\n\njulia> B = BallInf(zeros(4), 1.0);\n\njulia> c = constraints_list(B)[1:2]\n2-element Vector{HalfSpace{Float64, ReachabilityBase.Arrays.SingleEntryVector{Float64}}}:\n HalfSpace{Float64, ReachabilityBase.Arrays.SingleEntryVector{Float64}}([1.0, 0.0, 0.0, 0.0], 1.0)\n HalfSpace{Float64, ReachabilityBase.Arrays.SingleEntryVector{Float64}}([0.0, 1.0, 0.0, 0.0], 1.0)\n\njulia> P = HPolyhedron(c);\n\njulia> constrained_dimensions(P)\n2-element Vector{Int64}:\n 1\n 2\n\nFinally, we take the concrete projection onto variables 1 and 2:\n\njulia> project(P, [1, 2]) |> constraints_list\n2-element Vector{HalfSpace{Float64, Vector{Float64}}}:\n HalfSpace{Float64, Vector{Float64}}([1.0, 0.0], 1.0)\n HalfSpace{Float64, Vector{Float64}}([0.0, 1.0], 1.0)\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolyhedron/#LazySets.API.intersection-Union{Tuple{N}, Tuple{AbstractPolyhedron{N}, AbstractPolyhedron{N}}} where N","page":"Polyhedra (AbstractPolyhedron)","title":"LazySets.API.intersection","text":"intersection(P1::AbstractPolyhedron{N}, P2::AbstractPolyhedron{N};\n             [backend]=default_lp_solver(N), [prune]::Bool=true) where {N}\n\nCompute the intersection of two polyhedra.\n\nInput\n\nP1      – polyhedron\nP2      – polyhedron\nbackend – (optional, default: default_lp_solver(N)) the LP solver used              for the removal of redundant constraints; see the Notes section              below for details\nprune   – (optional, default: true) flag for removing redundant              constraints\n\nOutput\n\nAn HPolyhedron resulting from the intersection of P1 and P2, with the redundant constraints removed, or an empty set if the intersection is empty. If one of the arguments is a polytope, the result is an HPolytope instead.\n\nNotes\n\nThe default value of the solver backend is default_lp_solver(N) and it is used to run a feasiblity LP to remove the redundant constraints of the intersection.\n\nIf you want to use the Polyhedra library, pass an appropriate backend. For example, use default_polyhedra_backend(P) for the default Polyhedra library, or use CDDLib.Library() for the CDD library.\n\nThere are some shortcomings of the removal of constraints using the default Polyhedra library; see e.g. #1038 and Polyhedra#146. It is safer to check for emptiness of intersection before calling this function in those cases.\n\nAlgorithm\n\nThis implementation unifies the constraints of the two sets obtained from the constraints_list method.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolyhedron/#LazySets.API.minkowski_sum-Tuple{AbstractPolyhedron, AbstractPolyhedron}","page":"Polyhedra (AbstractPolyhedron)","title":"LazySets.API.minkowski_sum","text":"minkowski_sum(P::AbstractPolyhedron, Q::AbstractPolyhedron;\n              [backend]=nothing, [algorithm]=nothing, [prune]=true)\n\nCompute the Minkowski sum of two polyhedra in constraint representation.\n\nInput\n\nP         – polyhedron in constraint representation\nQ         – polyhedron in constraint representation\nbackend   – (optional, default: nothing) polyhedral computations backend\nalgorithm – (optional, default: nothing) algorithm to eliminate                variables; available options are Polyhedra.FourierMotzkin,                Polyhedra.BlockElimination, and Polyhedra.ProjectGenerators\nprune     – (optional, default: true) if true, apply a post-processing                to remove redundant constraints\n\nOutput\n\nA polyhedron in H-representation that corresponds to the Minkowski sum of P and Q.\n\nAlgorithm\n\nThis function implements the concrete Minkowski sum by projection and variable elimination as detailed in Kvasnica [Kva05]. The idea is that if we write P and Q in simple H-representation, that is, P = x  ℝ^n  Ax  b  and Q = x  ℝ^n  Cx  d , then their Minkowski sum can be seen as the projection onto the first n-dimensional coordinates of the polyhedron:\n\n    beginpmatrix 0  A  C  -C endpmatrix binomxy  binombd\n\nThis is seen by noting that P  Q corresponds to the set of points x  ℝ^n such that x = y + z with Ay  b and Cz  d; hence it follows that Ay  b and C(x-y)  d, and the inequality above follows by considering the 2n-dimensional space binomxy. The reduction from 2n to n variables is performed using an elimination algorithm as described next.\n\nThe elimination of variables depends on the polyhedra library Polyhedra, which itself uses CDDLib for variable elimination. The available algorithms are:\n\nPolyhedra.FourierMotzkin    – projection by computing the H-representation                                  and applying the Fourier-Motzkin elimination                                  algorithm to it\nPolyhedra.BlockElimination  – projection by computing the H-representation                                  and applying the block elimination algorithm                                  to it\nPolyhedra.ProjectGenerators – projection by computing the V-representation\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolyhedron/#LazySets._isbounded_stiemke","page":"Polyhedra (AbstractPolyhedron)","title":"LazySets._isbounded_stiemke","text":"_isbounded_stiemke(constraints::AbstractVector{<:HalfSpace{N}};\n                   solver=default_lp_solver(N),\n                   check_nonempty::Bool=true) where {N}\n\nCheck whether a list of constraints is bounded using Stiemke's theorem of alternatives.\n\nInput\n\nconstraints    – list of constraints\nbackend        – (optional, default: default_lp_solver(N)) the backend                     used to solve the linear program\ncheck_nonempty – (optional, default: true) if true, check the                     precondition to this algorithm that P is non-empty\n\nOutput\n\ntrue iff the list of constraints is bounded.\n\nNotes\n\nThe list of constraints represents a polyhedron.\n\nThe algorithm calls isempty to check whether the polyhedron is empty. This computation can be avoided using the check_nonempty flag.\n\nAlgorithm\n\nThe algorithm is based on Stiemke's theorem of alternatives, see, e.g., Mangasarian [Man94].\n\nLet the polyhedron P be given in constraint form Ax  b. We assume that the polyhedron is non-empty.\n\nProposition 1. If ker(A)0, then P is unbounded.\n\nProposition 2. Assume that ker(A)=0 and P is non-empty. Then P is bounded if and only if the following linear program admits a feasible solution: miny_1 subject to A^Ty=0 and y1.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractPolyhedron/#LazySets._linear_map_polyhedron","page":"Polyhedra (AbstractPolyhedron)","title":"LazySets._linear_map_polyhedron","text":"_linear_map_polyhedron(M::AbstractMatrix,\n                       P::LazySet;\n                       [algorithm]::Union{String, Nothing}=nothing,\n                       [check_invertibility]::Bool=true,\n                       [cond_tol]::Number=DEFAULT_COND_TOL,\n                       [inverse]::Union{AbstractMatrix{N}, Nothing}=nothing,\n                       [backend]=nothing,\n                       [elimination_method]=nothing)\n\nConcrete linear map of a polyhedral set.\n\nInput\n\nM         – matrix\nP         – polyhedral set\nalgorithm – (optional; default: nothing) algorithm to be used; for the                description see the Algorithm section below; possible choices                are:\n\"inverse\", alias: \"inv\"\n\"inverse_right\", alias: \"inv_right\"\n\"elimination\", alias: \"elim\"\n\"lift\"\n\"vrep\"\n\"vrep_chull\"\ncheck_invertibility – (optional, default: true) if true check whether                          the given matrix M is invertible; set to false                          only if you know that M is invertible\ncond_tol  – (optional; default: DEFAULT_COND_TOL) tolerance of matrix                condition (used to check whether the matrix is invertible)\ninverse   – (optional; default: nothing) matrix inverse M⁻¹; use this                option if you have already computed the inverse matrix of M\nbackend   – (optional: default: nothing) polyhedra backend\nelimination_method  – (optional: default: nothing) elimination method for                          the \"elimination\" algorithm\n\nOutput\n\nThe type of the result is \"as close as possible\" to the the type of P. Let (m, n) be the size of M, where m ≠ n is allowed for rectangular maps.\n\nTo fix the type of the output to something different than the default value, consider post-processing the result of this function with a call to a suitable convert method.\n\nIn particular, the output depends on the type of P, on m, and the algorithm that was used:\n\nIf the vertex-based approach was used:\nIf P is a VPolygon and m = 2 then the output is a VPolygon.\nIf P is a VPolytope then the output is a VPolytope.\nOtherwise the output is an Interval if m = 1, a VPolygon if m = 2, and a VPolytope in other cases.\nIf the invertibility criterion was used:\nThe types of HalfSpace, Hyperplane, Line2D, and subtypes of AbstractHPolygon are preserved.\nIf P is an AbstractPolytope, then the output is an Interval if m = 1, an HPolygon if m = 2, and an HPolytope in other cases.\nOtherwise the output is an HPolyhedron.\n\nNotes\n\nSince the different linear-map algorithms work at the level of constraints, this method uses dispatch on two stages: once the algorithm has been defined, first the helper methods _linear_map_hrep_helper (resp. _linear_map_vrep) are invoked, which dispatch on the set type. Then, each helper method calls the concrete implementation of _linear_map_hrep, which dispatches on the algorithm, and returns a list of constraints.\n\nTo simplify working with different algorithms and options, the types <: AbstractLinearMapAlgorithm are used. These types are singleton type or types that carry only the key data for the given algorithm, such as the matrix inverse or the polyhedra backend.\n\nNew subtypes of the AbstractPolyhedron interface may define their own helper methods _linear_map_vrep (respectively _linear_map_hrep_helper) for special handling of the constraints returned by the implementations of _linear_map_hrep; otherwise the fallback implementation for AbstractPolyhedron is used, which instantiates an HPolyhedron.\n\nAlgorithm\n\nThis method mainly implements several approaches for the linear map: inverse, right inverse, transformation to vertex representation, variable elimination, and variable lifting. Depending on the properties of M and P, one algorithm may be preferable over the other. Details on the algorithms are given in the following subsections.\n\nOtherwise, if the algorithm argument is not specified, a default option is chosen based on heuristics on the types and values of M and P:\n\nIf the \"inverse\" algorithm applies, it is used.\nOtherwise, if the \"inverse_right\" algorithm applies, it is used.\nOtherwise, if the \"lift\" algorithm applies, it is used.\nOtherwise, the \"elimination\" algorithm is used.\n\nNote that the algorithms \"inverse\" and \"inverse_right\" do not require the external library Polyhedra. However, the fallback method \"elimination\" requires Polyhedra as well as the library CDDLib.\n\nThe optional keyword arguments inverse and check_invertibility modify the default behavior:\n\nIf an inverse matrix is passed in inverse, the given algorithm is applied, and if none is given, either \"inverse\" or \"inverse_right\" is applied (in that order of preference).\nIf check_invertibility is set to false, the given algorithm is applied, and if none is given, either \"inverse\" or \"inverse_right\" is applied (in that order of preference).\n\nInverse\n\nThis algorithm is invoked with the keyword argument algorithm=\"inverse\" (or algorithm=\"inv\"). The algorithm requires that M is invertible, square, and dense. If you know a priori that M is invertible, set the flag check_invertibility=false, such that no extra checks are done. Otherwise, we check the sufficient condition that the condition number of M is not too high. The threshold for the condition number can be modified from its default value, DEFAULT_COND_TOL, by passing a custom cond_tol.\n\nThe algorithm is described next. Assuming that the matrix M is invertible (which we check via a sufficient condition,), y = M x implies x = textinv(M) y and we can transform the polyhedron A x  b to the polyhedron A textinv(M) y  b.\n\nIf the dense condition on M is not satisfied, there are two suggested workarounds: either transform to a dense matrix, i.e., calling linear_map with Matrix(M), or use the \"inverse_right\" algorithm, which does not compute the inverse matrix explicitly, but uses a polyalgorithm; see the documentation of ? for details.\n\nInverse-right\n\nThis algorithm is invoked with the keyword argument algorithm=\"inverse_right\" (or algorithm=\"inv_right\"). This algorithm applies to square and invertible matrices M. The idea is essentially the same as for the \"inverse\" algorithm; the difference is that in \"inverse\" the full matrix inverse is computed, and in \"inverse_right\" only the left division on the normal vectors is used. In particular, \"inverse_right\" is good as a workaround when M is sparse (since the inv function is not available for sparse matrices).\n\nElimination\n\nThis algorithm is invoked with the keyword argument algorithm = \"elimination\" (or algorithm = \"elim\"). The algorithm applies to any matrix M (invertible or not), and any polyhedron P (bounded or not).\n\nThe idea is described next. If P : Ax <= b and y = Mx denote the polyhedron and the linear map, respectively, we consider the vector z = [y, x], write the given equalities and the inequalities, and then eliminate the last x variables (there are length(x) in total) using a call to Polyhedra.eliminate to a backend library that can do variable elimination (typically CDDLib with the BlockElimination() algorithm). In this way we have eliminated the \"old\" variables x and kept the \"new\" or transformed variables \"y\".\n\nThe default elimination method is block elimination. For possible options we refer to the documentation of Polyhedra, projection/elimination.\n\nLift\n\nThis algorithm is invoked with the keyword argument algorithm=\"lift\". The algorithm applies if M is rectangular of size m × n with m > n and full rank (i.e., of rank n).\n\nThe idea is to embed the polyhedron into the m-dimensional space by appending zeros, i.e. extending all constraints of P to m dimensions, and constraining the last m - n dimensions to 0. The resulting matrix is extended to an invertible m × m matrix, and the algorithm using the inverse of the linear map is applied. For technical details of extending M to a higher-dimensional invertible matrix, see ReachabilityBase.Arrays.extend.\n\nVertex representation\n\nThis algorithm is invoked with the keyword argument algorithm=\"vrep\" (or algorithm=\"vrep_chull\"). If the polyhedron is bounded, the idea is to convert it to its vertex representation and apply the linear map to each vertex.\n\nThe returned set is a polytope in vertex representation. Note that conversion of the result back to half-space representation is not computed by default, since this may be costly. If you use this algorithm and still want to convert back to half-space representation, apply tohrep to the result of this method.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractPolyhedron/","page":"Polyhedra (AbstractPolyhedron)","title":"Polyhedra (AbstractPolyhedron)","text":"Undocumented implementations:","category":"page"},{"location":"lib/interfaces/AbstractPolyhedron/","page":"Polyhedra (AbstractPolyhedron)","title":"Polyhedra (AbstractPolyhedron)","text":"extrema\nextrema\nhigh\nhigh\nispolyhedral\nlow\nlow\nisdisjoint","category":"page"},{"location":"lib/interfaces/AbstractPolyhedron/","page":"Polyhedra (AbstractPolyhedron)","title":"Polyhedra (AbstractPolyhedron)","text":"Inherited from LazySet:","category":"page"},{"location":"lib/interfaces/AbstractPolyhedron/","page":"Polyhedra (AbstractPolyhedron)","title":"Polyhedra (AbstractPolyhedron)","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisboundedtype\nisempty\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nlinear_map\nsample\nscale\nρ\ntranslate\ncartesian_product\nconvex_hull\nexact_sum\n≈\n==\nisequivalent\n⊂\n⊆\nminkowski_difference","category":"page"},{"location":"lib/interfaces/AbstractPolyhedron/","page":"Polyhedra (AbstractPolyhedron)","title":"Polyhedra (AbstractPolyhedron)","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/interfaces/AbstractPolyhedron/","page":"Polyhedra (AbstractPolyhedron)","title":"Polyhedra (AbstractPolyhedron)","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/interfaces/AbstractPolyhedron/","page":"Polyhedra (AbstractPolyhedron)","title":"Polyhedra (AbstractPolyhedron)","text":"Some common functions implemented by several subtypes:","category":"page"},{"location":"lib/interfaces/AbstractPolyhedron/#LazySets.addconstraint!-Tuple{AbstractPolyhedron, HalfSpace}","page":"Polyhedra (AbstractPolyhedron)","title":"LazySets.addconstraint!","text":"addconstraint!(P::AbstractPolyhedron, constraint::HalfSpace)\n\nAdd a linear constraint to a set in constraint representation in-place.\n\nInput\n\nP          – set in constraint representation\nconstraint – linear constraint to add\n\nNotes\n\nIt is left to the user to guarantee that the dimension of all linear constraints is the same.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolyhedron/#LazySets.ishyperplanar-Tuple{AbstractPolyhedron}","page":"Polyhedra (AbstractPolyhedron)","title":"LazySets.ishyperplanar","text":"ishyperplanar(P::AbstractPolyhedron)\n\nDetermine whether a polyhedron is equivalent to a hyperplane.\n\nInput\n\nP – polyhedron\n\nOutput\n\ntrue iff P is hyperplanar, i.e., consists of two linear constraints ax  b and -ax  -b.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolyhedron/","page":"Polyhedra (AbstractPolyhedron)","title":"Polyhedra (AbstractPolyhedron)","text":"Plotting polyhedra is available too:","category":"page"},{"location":"lib/interfaces/AbstractPolyhedron/#LazySets.plot_recipe-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}, Tuple{AbstractPolyhedron{N}, Any}} where N","page":"Polyhedra (AbstractPolyhedron)","title":"LazySets.plot_recipe","text":"plot_recipe(P::AbstractPolyhedron{N}, [ε]=zero(N)) where {N}\n\nConvert a (bounded) polyhedron to a pair (x, y) of points for plotting.\n\nInput\n\nP – bounded polyhedron\nε – (optional, default: 0) ignored, used for dispatch\n\nOutput\n\nA pair (x, y) of points that can be plotted, where x is the vector of x-coordinates and y is the vector of y-coordinates.\n\nAlgorithm\n\nWe first assert that P is bounded (i.e., that P is a polytope).\n\nOne-dimensional polytopes are converted to an Interval. Three-dimensional or higher-dimensional polytopes are not supported.\n\nFor two-dimensional polytopes (i.e., polygons) we compute their set of vertices using vertices_list and then plot the convex hull of these vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolyhedron/#Implementations","page":"Polyhedra (AbstractPolyhedron)","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/AbstractPolyhedron/","page":"Polyhedra (AbstractPolyhedron)","title":"Polyhedra (AbstractPolyhedron)","text":"Half-space (HalfSpace)\nPolyhedron in constraint representation (HPolyhedron)\nHyperplane\nLine2D\nLine\nUniverse\nStar","category":"page"},{"location":"man/interval_hulls/#Interval-Hulls","page":"Interval Hulls","title":"Interval Hulls","text":"","category":"section"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"In this section we illustrate the interval hull operators as well as several plotting functionalities.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"Pages = [\"interval_hulls.md\"]\nDepth = 3","category":"page"},{"location":"man/interval_hulls/#Balls-and-Singletons","page":"Interval Hulls","title":"Balls and Singletons","text":"","category":"section"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"Consider a ball in the 2-norm. By default, the coefficients of this set are 64-bit floating point numbers. Other numeric types (such as lower precision floating point, or rational) can be defined with the proper argument types in the Ball2 constructor.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"using Plots, LazySets\n\nX = Ball2(ones(2), 0.5)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"To plot a lazy set, we use the plot function. By design, lazy sets plots overapproximate with box directions only. To have a sharp definition of the borders, use the accuracy as a second argument.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"plot(X, 1e-3, aspectratio=1)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"To add plots to the same pair of axes we use plot!. Let's add some points of the set which are farthest in some given directions. Single points can be plotted using the Singleton type. In the third line of code we plot the center of the ball picking a custom cross marker.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"plot!(Singleton(σ([1., 0], X)))\nplot!(Singleton(σ([1., 1], X)))\nplot!(Singleton(X.center), markershape=:x)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"note: Note\nTo see the list of available plot keyword arguments, use the plotattr([attr]) function, where attr is the symbol :Plot, :Series, :Axis or :Subplot.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"For the remainder of this section we define another ball in the 2-norm and its convex hull with X.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"Y = Ball2([-3,-.5], 0.8)\nZ = CH(X, Y)\n\nplot(X, 1e-3, aspectratio=1)\nplot!(Y, 1e-3)\nplot!(Z, 1e-3, alpha=0.2)","category":"page"},{"location":"man/interval_hulls/#Ballinf-approximation","page":"Interval Hulls","title":"Ballinf approximation","text":"","category":"section"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"A simple overapproximation with a BallInf is obtained with the ballinf_approximation function, from the Approximations module. It overapproximates a convex set by a tight ball in the infinity norm by evaluating the support vector in the canonical directions.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"import LazySets.Approximations.ballinf_approximation\n\nplot(X, 1e-3, aspectratio=1)\nplot!(Y, 1e-3)\nplot!(Z, 1e-3, alpha=0.2)\n\nBapprox = ballinf_approximation(Z)\n\nplot!(Bapprox, alpha=0.1)\nplot!(Singleton(Bapprox.center), markershape=:x)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"Bapprox.center, Bapprox.radius","category":"page"},{"location":"man/interval_hulls/#Interval-hull-approximation","page":"Interval Hulls","title":"Interval hull approximation","text":"","category":"section"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"If we want to have different lengths for each dimension, instead of the ballinf_approximation, we can use the approximation with a hyperrectangle through the interval_hull function.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"import LazySets.Approximations.interval_hull\n\nplot(X, 1e-3, aspectratio=1)\nplot!(Y, 1e-3)\nplot!(Z, 1e-3, alpha=0.2)\n\nHapprox = interval_hull(Z)\n\nplot!(Happrox, alpha=0.1)\nplot!(Singleton(Happrox.center), markershape=:x)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"Happrox.center, Happrox.radius","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"note: Note\nThe interval_hull function is an alias for the box_approximation function. The nomenclature for approximation functions is *_approximation_*. To see a list of all approximation functions, either search in the docs or type names(LazySets.Approximations).","category":"page"},{"location":"man/interval_hulls/#Symmetric-interval-hull","page":"Interval Hulls","title":"Symmetric interval hull","text":"","category":"section"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"Contrary to the previous approximations, the symmetric interval hull is centered around the origin. It is defined in the Approximations module as well.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"import LazySets.Approximations.symmetric_interval_hull\nusing SparseArrays\n\nplot(X, 1e-3, aspectratio=1)\nplot!(Y, 1e-3)\nplot!(Z, 1e-3, alpha=0.2)\n\nS = symmetric_interval_hull(Z)\nplot!(S, alpha=0.2)\nplot!(Singleton(S.center), markershape=:x)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"S.center, S.radius","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"We can get the list of vertices using the vertices_list function:","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"vertices_list(S)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"For instance, compute the support vector in the south-east direction:","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"σ([1., -1.], S)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"It is also possible to pass a sparse vector as direction, and the result is a sparse vector:","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"σ(sparsevec([1., -1.]), S)","category":"page"},{"location":"man/interval_hulls/#Norm,-radius-and-diameter","page":"Interval Hulls","title":"Norm, radius and diameter","text":"","category":"section"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"In this part we illustrate some functions to obtain metric properties of sets, applied to the sets X, Y and Z defined previously, in the infinity norm. These functions apply generally to any LazySet. For some types, specialized methods are triggered automatically through multiple-dispatch.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"The norm of a convex set is the norm of the enclosing ball (of the given norm) of minimal volume. For instance:","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"import LazySets.Approximations: norm, radius, diameter\n\nnorm(X), norm(Y), norm(Z)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"The radius of a convex set. It is the radius of the enclosing ball (of the given norm) of minimal volume with the same center. In the previous example,","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"radius(X), radius(Y), radius(Z)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"Finally, it is sometimes convenient to ask directly the diameter of the set, defined as twice the radius:","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"diameter(X), diameter(Y), diameter(Z)","category":"page"},{"location":"lib/sets/HalfSpace/#def_HalfSpace","page":"HalfSpace","title":"Half-space (HalfSpace)","text":"","category":"section"},{"location":"lib/sets/HalfSpace/#LazySets.HalfSpaceModule.HalfSpace","page":"HalfSpace","title":"LazySets.HalfSpaceModule.HalfSpace","text":"HalfSpace{N, VN<:AbstractVector{N}} <: AbstractPolyhedron{N}\n\nType that represents a (closed) half-space of the form ax  b.\n\nFields\n\na – normal direction (non-zero)\nb – constraint\n\nExamples\n\nThe half-space x + 2y - z  3:\n\njulia> HalfSpace([1, 2, -1.], 3.)\nHalfSpace{Float64, Vector{Float64}}([1.0, 2.0, -1.0], 3.0)\n\nTo represent the set y  0 in the plane, we can rearrange the expression as 0x - y  0:\n\njulia> HalfSpace([0, -1.], 0.)\nHalfSpace{Float64, Vector{Float64}}([0.0, -1.0], 0.0)\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/HalfSpace/#LazySets.HalfSpaceModule.LinearConstraint","page":"HalfSpace","title":"LazySets.HalfSpaceModule.LinearConstraint","text":"LinearConstraint\n\nAlias for HalfSpace\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/HalfSpace/#Conversion","page":"HalfSpace","title":"Conversion","text":"","category":"section"},{"location":"lib/sets/HalfSpace/","page":"HalfSpace","title":"HalfSpace","text":"convert(::Type{HalfSpace{N,Vector{N}}}, hs::HalfSpace{N,<:AbstractVector{N}}) where {N}","category":"page"},{"location":"lib/sets/HalfSpace/","page":"HalfSpace","title":"HalfSpace","text":"The following method requires the SymEngine package.","category":"page"},{"location":"lib/sets/HalfSpace/#Base.convert-Union{Tuple{N}, Tuple{Type{HalfSpace{N, VN} where VN<:AbstractVector{N}}, Expr}} where N","page":"HalfSpace","title":"Base.convert","text":"convert(::Type{HalfSpace{N}}, expr::Expr; vars::Vector{Basic}=Basic[]) where {N}\n\nReturn a LazySet.HalfSpace given a symbolic expression that represents a half-space.\n\nInput\n\nexpr – a symbolic expression\nvars – (optional, default: nothing): set of variables with respect to which the           gradient is taken; if empty, we take the free symbols in the given expression\n\nOutput\n\nA HalfSpace, in the form ax <= b.\n\nExamples\n\njulia> convert(HalfSpace, :(x1 <= -0.03))\nHalfSpace{Float64, Vector{Float64}}([1.0], -0.03)\n\njulia> convert(HalfSpace, :(x1 < -0.03))\nHalfSpace{Float64, Vector{Float64}}([1.0], -0.03)\n\njulia> convert(HalfSpace, :(x1 > -0.03))\nHalfSpace{Float64, Vector{Float64}}([-1.0], 0.03)\n\njulia> convert(HalfSpace, :(x1 >= -0.03))\nHalfSpace{Float64, Vector{Float64}}([-1.0], 0.03)\n\njulia> convert(HalfSpace, :(x1 + x2 <= 2*x4 + 6))\nHalfSpace{Float64, Vector{Float64}}([1.0, 1.0, -2.0], 6.0)\n\nYou can also specify the set of \"ambient\" variables, even if not all of them appear:\n\njulia> using SymEngine: Basic\n\njulia> convert(HalfSpace, :(x1 + x2 <= 2*x4 + 6), vars=Basic[:x1, :x2, :x3, :x4])\nHalfSpace{Float64, Vector{Float64}}([1.0, 1.0, 0.0, -2.0], 6.0)\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#Operations","page":"HalfSpace","title":"Operations","text":"","category":"section"},{"location":"lib/sets/HalfSpace/#LazySets.API.an_element-Tuple{LazySets.API.LazySet}-lib-sets-HalfSpace","page":"HalfSpace","title":"LazySets.API.an_element","text":"an_element(X::LazySet)\n\nReturn some element of a nonempty set.\n\nInput\n\nX – set\n\nOutput\n\nAn element of X unless X is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.API.an_element-Tuple{HalfSpace}","page":"HalfSpace","title":"LazySets.API.an_element","text":"Extended help\n\nan_element(hs::HalfSpace)\n\nOutput\n\nThis method returns an element on the defining hyperplane.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.API.complement-Tuple{LazySets.API.LazySet}-lib-sets-HalfSpace","page":"HalfSpace","title":"LazySets.API.complement","text":"complement(X::LazySet)\n\nCompute the complement of a set.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the complement of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.API.complement-Tuple{HalfSpace}","page":"HalfSpace","title":"LazySets.API.complement","text":"Extended help\n\ncomplement(H::HalfSpace)\n\nAlgorithm\n\nThe result is the complementary half-space to H. If H  a x   b, then this method returns the half-space H  a x   b. (Note that complementarity is understood in a relaxed sense, since the intersection of H and H is non-empty).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.constrained_dimensions-Tuple{HalfSpace}","page":"HalfSpace","title":"LazySets.constrained_dimensions","text":"constrained_dimensions(hs::HalfSpace)\n\nReturn the indices in which a half-space is constrained.\n\nInput\n\nhs – half-space\n\nOutput\n\nA vector of ascending indices i such that the half-space is constrained in dimension i.\n\nExamples\n\nA 2D half-space with constraint x_1  0 is only constrained in dimension 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.API.constraints_list-Tuple{AbstractMatrix, AbstractVector}","page":"HalfSpace","title":"LazySets.API.constraints_list","text":"constraints_list(A::AbstractMatrix{N}, b::AbstractVector)\n\nConvert a matrix-vector representation to a linear-constraint representation.\n\nInput\n\nA – matrix\nb – vector\n\nOutput\n\nA list of linear constraints.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.isfeasible","page":"HalfSpace","title":"LazySets.isfeasible","text":"isfeasible(constraints::AbstractVector{<:HalfSpace}, [witness]::Bool=false;\n           [solver]=nothing)\n\nCheck for feasibility of a list of linear constraints.\n\nInput\n\nconstraints – list of linear constraints\nwitness     – (optional; default: false) flag for witness production\nsolver      – (optional; default: nothing) LP solver\n\nOutput\n\nIf witness is false, the result is a Bool.\n\nIf witness is true, the result is a pair (res, w) where res is a Bool and w is a witness point/vector.\n\nAlgorithm\n\nThis implementation converts the constraints to matrix-vector form via tosimplehrep and then calls isfeasible on the result.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/HalfSpace/#LazySets.API.isuniversal-lib-sets-HalfSpace","page":"HalfSpace","title":"LazySets.API.isuniversal","text":"isuniversal(X::LazySet, witness::Bool=false)\n\nCheck whether a set is universal.\n\nInput\n\nX       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X = ℝ^n\nIf the witness option is activated:\n(true, []) iff X = ℝ^n\n(false, v) iff X  ℝ^n for some v  X\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/HalfSpace/#LazySets.API.isuniversal","page":"HalfSpace","title":"LazySets.API.isuniversal","text":"Extended help\n\nisuniversal(hs::HalfSpace, [witness]::Bool=false)\n\nAlgorithm\n\nWitness production falls back to an_element(::Hyperplane).\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/HalfSpace/#LinearAlgebra.normalize-Union{Tuple{HalfSpace{N, VN} where VN<:AbstractVector{N}}, Tuple{N}, Tuple{HalfSpace{N, VN} where VN<:AbstractVector{N}, Real}} where N","page":"HalfSpace","title":"LinearAlgebra.normalize","text":"normalize(hs::HalfSpace{N}, p::Real=N(2)) where {N}\n\nNormalize a half-space.\n\nInput\n\nhs – half-space\np  – (optional, default: 2) norm\n\nOutput\n\nA new half-space whose normal direction a is normalized, i.e., such that a_p = 1 holds.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-HalfSpace","page":"HalfSpace","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#Base.rand-Tuple{Type{HalfSpace}}","page":"HalfSpace","title":"Base.rand","text":"Extended help\n\nrand(::Type{HalfSpace}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the constraint a is nonzero.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.remove_redundant_constraints-Tuple{AbstractVector{<:HalfSpace}}","page":"HalfSpace","title":"LazySets.remove_redundant_constraints","text":"remove_redundant_constraints(constraints::AbstractVector{<:HalfSpace}; backend=nothing)\n\nRemove the redundant constraints of a given list of linear constraints.\n\nInput\n\nconstraints – list of constraints\nbackend     – (optional, default: nothing) the backend used to solve the                  linear program\n\nOutput\n\nThe list of constraints with the redundant ones removed, or an empty list if the constraints are infeasible.\n\nNotes\n\nIf backend is nothing, it defaults to default_lp_solver(N).\n\nAlgorithm\n\nSee [remove_redundant_constraints!(::AbstractVector{<:HalfSpace})](@ref) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.remove_redundant_constraints!-Tuple{AbstractVector{<:HalfSpace}}","page":"HalfSpace","title":"LazySets.remove_redundant_constraints!","text":"remove_redundant_constraints!(constraints::AbstractVector{<:HalfSpace}; [backend]=nothing)\n\nRemove the redundant constraints of a given list of linear constraints; the list is updated in-place.\n\nInput\n\nconstraints – list of constraints\nbackend     – (optional, default: nothing) the backend used to solve the                  linear program\n\nOutput\n\ntrue if the removal was successful and the list of constraints constraints is modified by removing the redundant constraints, and false only if the constraints are infeasible.\n\nNotes\n\nNote that the result may be true even if the constraints are infeasible. For example, x  0  x  1 will return true without removing any constraint. To check if the constraints are infeasible, use isempty(HPolyhedron(constraints)).\n\nIf backend is nothing, it defaults to default_lp_solver(N).\n\nAlgorithm\n\nIf there are m constraints in n dimensions, this function checks one by one if each of the m constraints is implied by the remaining ones.\n\nTo check if the k-th constraint is redundant, an LP is formulated using the constraints that have not yet been removed. If, at an intermediate step, it is detected that a subgroup of the constraints is infeasible, this function returns false. If the calculation finished successfully, this function returns true.\n\nFor details, see Fukuda's Polyhedra FAQ.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.tosimplehrep-Tuple{AbstractVector{<:HalfSpace}}","page":"HalfSpace","title":"LazySets.tosimplehrep","text":"tosimplehrep(constraints::AbstractVector{<:HalfSpace}; [n]::Int=0)\n\nReturn the simple H-representation Ax  b from a list of linear constraints.\n\nInput\n\nconstraints – a list of linear constraints\nn           – (optional; default: 0) dimension of the constraints\n\nOutput\n\nThe tuple (A, b) where A is the matrix of normal directions and b is the vector of offsets.\n\nNotes\n\nThe parameter n can be used to create a matrix with no constraints but a non-zero dimension. If n ≤ 0, this method takes the dimension of the first constraint.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-HalfSpace","page":"HalfSpace","title":"Base.:∈","text":"∈(x::AbstractVector, X::LazySet)\n\nCheck whether a point lies in a set.\n\nInput\n\nx – point/vector\nX – set\n\nOutput\n\ntrue iff x  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#Base.:∈-Tuple{AbstractVector, HalfSpace}","page":"HalfSpace","title":"Base.:∈","text":"Extended help\n\n∈(x::AbstractVector, hs::HalfSpace)\n\nAlgorithm\n\nThis implementation checks whether x satisfies ax  b.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.API.project-Tuple{LazySets.API.LazySet, AbstractVector{Int64}}-lib-sets-HalfSpace","page":"HalfSpace","title":"LazySets.API.project","text":"project(X::LazySet, block::AbstractVector{Int})\n\nProject a set to a given block by using a concrete linear map.\n\nInput\n\nX       – set\nblock   – block structure - a vector with the dimensions of interest\n\nOutput\n\nA set representing the projection of X to block block.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.API.project-Tuple{HalfSpace, AbstractVector{Int64}}","page":"HalfSpace","title":"LazySets.API.project","text":"Extended help\n\nproject(H::HalfSpace, block::AbstractVector{Int}; [kwargs...])\n\nAlgorithm\n\nIf the unconstrained dimensions of H are a subset of the block variables, the projection is applied to the normal direction of H. Otherwise, the projection results in the universal set.\n\nThe latter can be seen as follows. Without loss of generality consider projecting out a single and constrained dimension xₖ (projecting out multiple dimensions can be modeled by repeatedly projecting out one dimension). We can write the projection as an existentially quantified linear constraint:\n\n    xₖ a₁x₁ +  + aₖxₖ +  + aₙxₙ  b\n\nSince aₖ  0, there is always a value for xₖ that satisfies the constraint for any valuation of the other variables.\n\nExamples\n\nConsider the half-space x + y + 0z  1, whose ambient dimension is 3. The (trivial) projection in the three dimensions using the block of variables [1, 2, 3] is:\n\njulia> H = HalfSpace([1.0, 1.0, 0.0], 1.0)\nHalfSpace{Float64, Vector{Float64}}([1.0, 1.0, 0.0], 1.0)\n\njulia> project(H, [1, 2, 3])\nHalfSpace{Float64, Vector{Float64}}([1.0, 1.0, 0.0], 1.0)\n\nProjecting along dimensions 1 and 2 only:\n\njulia> project(H, [1, 2])\nHalfSpace{Float64, Vector{Float64}}([1.0, 1.0], 1.0)\n\nFor convenience, one can use project(H, constrained_dimensions(H)) to return the half-space projected on the dimensions where it is constrained:\n\njulia> project(H, constrained_dimensions(H))\nHalfSpace{Float64, Vector{Float64}}([1.0, 1.0], 1.0)\n\nIf a constrained dimension is projected, we get the universal set of the dimension corresponding to the projection.\n\njulia> project(H, [1, 3])\nUniverse{Float64}(2)\n\njulia> project(H, [1])\nUniverse{Float64}(1)\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-HalfSpace","page":"HalfSpace","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, X::LazySet)\n\nEvaluate the support function of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nThe evaluation of the support function of X in direction d.\n\nNotes\n\nA convenience alias support_function is also available.\n\nWe have the following identity based on the support vector σ:\n\n    ρ(d X) = d  σ(d X)\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.API.ρ-Tuple{AbstractVector, HalfSpace}","page":"HalfSpace","title":"LazySets.API.ρ","text":"Extended help\n\nρ(d::AbstractVector, hs::HalfSpace)\n\nOutput\n\nUnless the direction is (a multiple of) the normal direction of the half-space, the result is Inf.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-HalfSpace","page":"HalfSpace","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.API.σ-Tuple{AbstractVector, HalfSpace}","page":"HalfSpace","title":"LazySets.API.σ","text":"Extended help\n\nσ(d::AbstractVector, hs::HalfSpace)\n\nOutput\n\nThe support vector in the given direction, which is only defined in the following two cases:\n\nThe direction has norm zero.\nThe direction is (a multiple of) the normal direction of the half-space.\n\nIn both cases the result is any point on the boundary (the defining hyperplane). Otherwise this function throws an error.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.API.translate-Tuple{LazySets.API.LazySet, AbstractVector}-lib-sets-HalfSpace","page":"HalfSpace","title":"LazySets.API.translate","text":"translate(X::LazySet, v::AbstractVector)\n\nCompute the translation of a set with a vector.\n\nInput\n\nX – set\nv – vector\n\nOutput\n\nA set representing X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.API.translate-Tuple{HalfSpace, AbstractVector}","page":"HalfSpace","title":"LazySets.API.translate","text":"Extended help\n\ntranslate(hs::HalfSpace, v::AbstractVector; [share]::Bool=false)\n\nNotes\n\nThe normal vector of the half-space (vector a in a⋅x ≤ b) is shared with the original half-space if share == true.\n\nAlgorithm\n\nA half-space ax  b is transformed to the half-space ax  b + av. In other words, we add the dot product av to b.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.HalfSpaceModule.iscomplement-Tuple{HalfSpace, HalfSpace}","page":"HalfSpace","title":"LazySets.HalfSpaceModule.iscomplement","text":"iscomplement(H1::HalfSpace, H2::HalfSpace)\n\nCheck if two half-spaces complement each other.\n\nInput\n\nH1 – half-space\nH2 – half-space\n\nOutput\n\ntrue iff H1 and H2 are complementary, i.e., have opposite normal directions and identical boundaries (defining hyperplanes).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#Base.isdisjoint-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-sets-HalfSpace","page":"HalfSpace","title":"Base.isdisjoint","text":"isdisjoint(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nCheck whether two sets are disjoint (i.e., do not intersect), and optionally compute a witness.\n\nInput\n\nX       – set\nY       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X  Y = \nIf the witness option is activated:\n(true, []) iff X  Y = \n(false, v) iff X  Y   for some v  X  Y\n\nNotes\n\nThe convenience alias is_intersection_empty is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#Base.isdisjoint","page":"HalfSpace","title":"Base.isdisjoint","text":"Extended help\n\nisdisjoint(H1::HalfSpace, H2::HalfSpace, [witness]::Bool=false)\n\nAlgorithm\n\nTwo half-spaces do not intersect if and only if their normal vectors point in the opposite direction and there is a gap between the two defining hyperplanes.\n\nThe latter can be checked as follows: Let H1  a_1x = b_1 and H2  a_2x = b_2. Then we already know that a_2 = -ka_1 for some positive scaling factor k. Let x_1 be a point on the defining hyperplane of H1. We construct a line segment from x_1 to the point x_2 on the defining hyperplane of hs_2 by shooting a ray from x_1 with direction a_1. Thus we look for a factor s such that (x_1 + sa_1)a_2 = b_2. This gives us s = (b_2 - x_1a_2)  (-k a_1a_1). The gap exists if and only if s is positive.\n\nIf the normal vectors do not point in opposite directions, then the defining hyperplanes intersect and we can produce a witness as follows. All points x in this intersection satisfy a_1x = b_1 and a_2x = b_2. Thus we have (a_1 + a_2)x = b_1+b_2. We now find a dimension where a_1 + a_2 is non-zero, say, i. Then the result is a vector with one non-zero entry in dimension i, defined as 0  0 (b_1 + b_2)(a_1i + a_2i) 0  0. Such a dimension i always exists.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/HalfSpace/#LazySets.HalfSpaceModule.halfspace_left-Tuple{AbstractVector, AbstractVector}","page":"HalfSpace","title":"LazySets.HalfSpaceModule.halfspace_left","text":"halfspace_left(p::AbstractVector, q::AbstractVector)\n\nReturn a half-space describing the 'left' of a two-dimensional line segment through two points.\n\nInput\n\np – first point\nq – second point\n\nOutput\n\nThe half-space whose boundary goes through the two points p and q and which describes the left-hand side of the directed line segment pq.\n\nAlgorithm\n\nThe half-space ax  b is calculated as a = [dy, -dx], where d = (dx dy) denotes the line segment pq, i.e., vecd = vecp - vecq, and b = dot(p, a).\n\nExamples\n\nThe left half-space of the \"east\" and \"west\" directions in two-dimensions are the upper and lower half-spaces:\n\njulia> using LazySets: halfspace_left\n\njulia> halfspace_left([0.0, 0.0], [1.0, 0.0])\nHalfSpace{Float64, Vector{Float64}}([0.0, -1.0], 0.0)\n\njulia> halfspace_left([0.0, 0.0], [-1.0, 0.0])\nHalfSpace{Float64, Vector{Float64}}([0.0, 1.0], 0.0)\n\nWe create a box from the sequence of line segments that describe its edges:\n\njulia> H1 = halfspace_left([-1.0, -1.0], [1.0, -1.0]);\n\njulia> H2 = halfspace_left([1.0, -1.0], [1.0, 1.0]);\n\njulia> H3 = halfspace_left([1.0, 1.0], [-1.0, 1.0]);\n\njulia> H4 = halfspace_left([-1.0, 1.0], [-1.0, -1.0]);\n\njulia> H = HPolygon([H1, H2, H3, H4]);\n\njulia> B = BallInf([0.0, 0.0], 1.0);\n\njulia> B ⊆ H && H ⊆ B\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.HalfSpaceModule.halfspace_right-Tuple{AbstractVector, AbstractVector}","page":"HalfSpace","title":"LazySets.HalfSpaceModule.halfspace_right","text":"halfspace_right(p::AbstractVector, q::AbstractVector)\n\nReturn a half-space describing the 'right' of a two-dimensional line segment through two points.\n\nInput\n\np – first point\nq – second point\n\nOutput\n\nThe half-space whose boundary goes through the two points p and q and which describes the right-hand side of the directed line segment pq.\n\nAlgorithm\n\nSee the documentation of halfspace_left.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets._ishalfspace","page":"HalfSpace","title":"LazySets._ishalfspace","text":"_ishalfspace(expr::Expr)\n\nDetermine whether the given expression corresponds to a half-space.\n\nInput\n\nexpr – a symbolic expression\n\nOutput\n\ntrue if expr corresponds to a half-space or false otherwise.\n\nExamples\n\njulia> using LazySets: _ishalfspace\n\njulia> all(_ishalfspace.([:(x1 <= 0), :(x1 < 0), :(x1 > 0), :(x1 >= 0)]))\ntrue\n\njulia> _ishalfspace(:(x1 = 0))\nfalse\n\njulia> _ishalfspace(:(2*x1 <= 4))\ntrue\n\njulia> _ishalfspace(:(6.1 <= 5.3*f - 0.1*g))\ntrue\n\njulia> _ishalfspace(:(2*x1^2 <= 4))\nfalse\n\njulia> _ishalfspace(:(x1^2 > 4*x2 - x3))\nfalse\n\njulia> _ishalfspace(:(x1 > 4*x2 - x3))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/HalfSpace/","page":"HalfSpace","title":"HalfSpace","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/HalfSpace/","page":"HalfSpace","title":"HalfSpace","text":"constraints_list\ndim\nisbounded\nisempty\nisoperationtype\ndistance\npermute","category":"page"},{"location":"lib/sets/HalfSpace/","page":"HalfSpace","title":"HalfSpace","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/HalfSpace/","page":"HalfSpace","title":"HalfSpace","text":"area\nchebyshev_center_radius\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisboundedtype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nlinear_map\nsample\nscale\ncartesian_product\nconvex_hull\ndifference\ndistance\nexact_sum\n≈\n==\nisequivalent\n⊂\nminkowski_difference","category":"page"},{"location":"lib/sets/HalfSpace/","page":"HalfSpace","title":"HalfSpace","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/HalfSpace/","page":"HalfSpace","title":"HalfSpace","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/HalfSpace/","page":"HalfSpace","title":"HalfSpace","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/HalfSpace/","page":"HalfSpace","title":"HalfSpace","text":"extrema\nextrema\nhigh\nhigh\nispolyhedral\nlow\nlow\nvertices_list\nintersection\n⊆\nminkowski_sum","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/#def_SymmetricIntervalHull","page":"SymmetricIntervalHull","title":"Symmetric interval hull (SymmetricIntervalHull)","text":"","category":"section"},{"location":"lib/lazy_operations/SymmetricIntervalHull/#LazySets.SymmetricIntervalHull","page":"SymmetricIntervalHull","title":"LazySets.SymmetricIntervalHull","text":"SymmetricIntervalHull{N, S<:LazySet{N}} <: AbstractHyperrectangle{N}\n\nType that represents the symmetric interval hull of a compact set.\n\nFields\n\nX     – compact set\ncache – partial storage of already computed bounds, organized as mapping            from the dimension to the bound value\n\nNotes\n\nThe symmetric interval hull can be computed with 2n support-function queries (of unit vectors), where n is the dimension of the wrapped set (i.e., two queries per dimension). When asking for the support vector (or support function) in a direction d, one needs 2k such queries, where k is the number of non-zero entries in d.\n\nHowever, if one asks for many support vectors (or support-function evaluations) in a loop, the number of computations may exceed 2n. To be most efficient in such cases, this type stores the intermediately computed bounds in the cache field.\n\nThe set X must be bounded. The flag check_boundedness (which defaults to true) can be used to elide the boundedness check in the inner constructor. Misuse of this flag can result in incorrect behavior.\n\nThe symmetric interval hull of a set is a hyperrectangle centered in the origin, which in particular is convex.\n\nAn alias for this function is ⊡.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/SymmetricIntervalHull/#LazySets.:⊡","page":"SymmetricIntervalHull","title":"LazySets.:⊡","text":"⊡\n\nAlias for SymmetricIntervalHull.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/SymmetricIntervalHull/#LazySets.API.dim-Tuple{SymmetricIntervalHull}","page":"SymmetricIntervalHull","title":"LazySets.API.dim","text":"dim(sih::SymmetricIntervalHull)\n\nReturn the dimension of the symmetric interval hull of a set.\n\nInput\n\nsih – symmetric interval hull of a set\n\nOutput\n\nThe ambient dimension of the symmetric interval hull of a set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/SymmetricIntervalHull/#LazySets.API.σ-Tuple{AbstractVector, SymmetricIntervalHull}","page":"SymmetricIntervalHull","title":"LazySets.API.σ","text":"σ(d::AbstractVector, sih::SymmetricIntervalHull)\n\nReturn a support vector of the symmetric interval hull of a set in a given direction.\n\nInput\n\nd   – direction\nsih – symmetric interval hull of a set\n\nOutput\n\nA support vector of the symmetric interval hull of a set in the given direction. If the direction has norm zero, the origin is returned.\n\nAlgorithm\n\nFor each non-zero entry in d we need to either look up the bound (if it has been computed before) or compute it, in which case we store it for future queries.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/SymmetricIntervalHull/#LazySets.API.center-Tuple{SymmetricIntervalHull, Int64}","page":"SymmetricIntervalHull","title":"LazySets.API.center","text":"center(sih::SymmetricIntervalHull, i::Int)\n\nReturn the center along a given dimension of the symmetric interval hull of a set.\n\nInput\n\nsih – symmetric interval hull of a set\ni   – dimension of interest\n\nOutput\n\nThe center along a given dimension of the symmetric interval hull of a set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/SymmetricIntervalHull/#LazySets.API.center-Tuple{SymmetricIntervalHull}","page":"SymmetricIntervalHull","title":"LazySets.API.center","text":"center(sih::SymmetricIntervalHull)\n\nReturn the center of the symmetric interval hull of a set.\n\nInput\n\nsih – symmetric interval hull of a set\n\nOutput\n\nThe origin.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/SymmetricIntervalHull/#LazySets.radius_hyperrectangle-Tuple{SymmetricIntervalHull}","page":"SymmetricIntervalHull","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(sih::SymmetricIntervalHull)\n\nReturn the box radius of the symmetric interval hull of a set in every dimension.\n\nInput\n\nsih – symmetric interval hull of a set\n\nOutput\n\nThe box radius of the symmetric interval hull of a set.\n\nNotes\n\nThis function computes the symmetric interval hull explicitly.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/SymmetricIntervalHull/#LazySets.radius_hyperrectangle-Tuple{SymmetricIntervalHull, Int64}","page":"SymmetricIntervalHull","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(sih::SymmetricIntervalHull, i::Int)\n\nReturn the box radius of the symmetric interval hull of a set in a given dimension.\n\nInput\n\nsih – symmetric interval hull of a set\ni   – dimension of interest\n\nOutput\n\nThe radius in the given dimension.\n\nNotes\n\nIf the radius was computed before, this is just a look-up. Otherwise it is computed.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"diameter\nsingleton_list","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"isbounded","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"isempty\nan_element","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"ngens\nlinear_map\norder\ntogrep\ntranslate","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"Inherited from AbstractHyperrectangle:","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"ρ\nσ\n∈\nnorm\nradius\nconstraints_list\nvertices_list\nhigh\nlow\ngenerators\ngenmat\nreflect","category":"page"},{"location":"lib/interfaces/AbstractAffineMap/","page":"Affine maps (AbstractAffineMap)","title":"Affine maps (AbstractAffineMap)","text":"Pages = [\"AbstractAffineMap.md\"]\nDepth = 3","category":"page"},{"location":"lib/interfaces/AbstractAffineMap/#def_AbstractAffineMap","page":"Affine maps (AbstractAffineMap)","title":"Affine maps (AbstractAffineMap)","text":"","category":"section"},{"location":"lib/interfaces/AbstractAffineMap/","page":"Affine maps (AbstractAffineMap)","title":"Affine maps (AbstractAffineMap)","text":"An affine map consists of a linear map and a translation.","category":"page"},{"location":"lib/interfaces/AbstractAffineMap/#LazySets.AbstractAffineMap","page":"Affine maps (AbstractAffineMap)","title":"LazySets.AbstractAffineMap","text":"AbstractAffineMap{N, S<:LazySet{N}} <: LazySet{N}\n\nAbstract type for affine maps.\n\nNotes\n\nSee AffineMap for a standard implementation of this interface.\n\nEvery concrete AbstractAffineMap must define the following methods:\n\nmatrix(::AbstractAffineMap) – return the linear map\nvector(::AbstractAffineMap) – return the affine translation vector\nset(::AbstractAffineMap) – return the set that the map is applied to\n\nThe subtypes of AbstractAffineMap:\n\njulia> subtypes(AbstractAffineMap)\n7-element Vector{Any}:\n AffineMap\n ExponentialMap\n ExponentialProjectionMap\n InverseLinearMap\n LinearMap\n ResetMap\n Translation\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/AbstractAffineMap/","page":"Affine maps (AbstractAffineMap)","title":"Affine maps (AbstractAffineMap)","text":"This interface requires to implement the following functions:","category":"page"},{"location":"lib/interfaces/AbstractAffineMap/#LazySets.matrix-Tuple{AbstractAffineMap}","page":"Affine maps (AbstractAffineMap)","title":"LazySets.matrix","text":"matrix(X::AbstractAffineMap)\n\nReturn the matrix of an affine map.\n\nInput\n\nX – affine map\n\nOutput\n\nThe matrix of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/#LazySets.vector-Tuple{AbstractAffineMap}","page":"Affine maps (AbstractAffineMap)","title":"LazySets.vector","text":"vector(X::AbstractAffineMap)\n\nReturn the vector of an affine map.\n\nInput\n\nX – affine map\n\nOutput\n\nThe vector of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/#LazySets.set-Tuple{AbstractAffineMap}","page":"Affine maps (AbstractAffineMap)","title":"LazySets.set","text":"set(X::AbstractAffineMap)\n\nReturn the set of an affine map.\n\nInput\n\nX – affine map\n\nOutput\n\nThe set of X before applying the map.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/","page":"Affine maps (AbstractAffineMap)","title":"Affine maps (AbstractAffineMap)","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/AbstractAffineMap/#LazySets.API.an_element-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap","page":"Affine maps (AbstractAffineMap)","title":"LazySets.API.an_element","text":"an_element(X::LazySet)\n\nReturn some element of a nonempty set.\n\nInput\n\nX – set\n\nOutput\n\nAn element of X unless X is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/#LazySets.API.an_element-Tuple{AbstractAffineMap}","page":"Affine maps (AbstractAffineMap)","title":"LazySets.API.an_element","text":"Extended help\n\nAlgorithm\n\nThe implementation relies on the an_element method of the wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/#LazySets.API.center-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap","page":"Affine maps (AbstractAffineMap)","title":"LazySets.API.center","text":"center(X::LazySet)\n\nCompute the center of a centrally symmetric set.\n\nInput\n\nX – centrally symmetric set\n\nOutput\n\nA vector with the center, or midpoint, of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/#LazySets.API.center-Tuple{AbstractAffineMap}","page":"Affine maps (AbstractAffineMap)","title":"LazySets.API.center","text":"Extended help\n\ncenter(am::AbstractAffineMap)\n\nAlgorithm\n\nThe implementation relies on the center method of the wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/#LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap","page":"Affine maps (AbstractAffineMap)","title":"LazySets.API.constraints_list","text":"constraints_list(X::LazySet)\n\nCompute a list of linear constraints of a polyhedral set.\n\nInput\n\nX – polyhedral set\n\nOutput\n\nA list of the linear constraints of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/#LazySets.API.constraints_list-Tuple{AbstractAffineMap}","page":"Affine maps (AbstractAffineMap)","title":"LazySets.API.constraints_list","text":"Extended help\n\nconstraints_list(am::AbstractAffineMap)\n\nNotes\n\nWe assume that the underlying set X is polyhedral, i.e., offers a method constraints_list(X).\n\nAlgorithm\n\nThis implementation uses the constraints_list method to compute the list of constraints of the translation of a lazy LinearMap.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/#LazySets.API.isbounded-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap","page":"Affine maps (AbstractAffineMap)","title":"LazySets.API.isbounded","text":"isbounded(X::LazySet)\n\nCheck whether a set is bounded.\n\nInput\n\nX – set\n\nOutput\n\ntrue iff the set is bounded.\n\nNotes\n\nSee also isboundedtype(::Type{<:LazySet}).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/#LazySets.API.isbounded-Tuple{AbstractAffineMap}","page":"Affine maps (AbstractAffineMap)","title":"LazySets.API.isbounded","text":"Extended help\n\nisbounded(am::AbstractAffineMap; cond_tol::Number=DEFAULT_COND_TOL)\n\nInput\n\ncond_tol – (optional) tolerance of matrix condition (used to check whether               the matrix is invertible)\n\nAlgorithm\n\nWe first check if the matrix is zero or the wrapped set is bounded. If not, we perform a sufficient check whether the matrix is invertible. If the matrix is invertible, then the map being bounded is equivalent to the wrapped set being bounded, and hence the map is unbounded. Otherwise, we check boundedness via _isbounded_unit_dimensions.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/#Base.isempty-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap","page":"Affine maps (AbstractAffineMap)","title":"Base.isempty","text":"isempty(X::LazySet, witness::Bool=false)\n\nCheck whether a set is empty.\n\nInput\n\nX       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X = \nIf the witness option is activated:\n(true, []) iff X = \n(false, v) iff X   for some v  X\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/#Base.isempty-Tuple{AbstractAffineMap}","page":"Affine maps (AbstractAffineMap)","title":"Base.isempty","text":"Extended help\n\nisempty(am::AbstractAffineMap)\n\nAlgorithm\n\nThe result is true iff the wrapped set is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap","page":"Affine maps (AbstractAffineMap)","title":"Base.:∈","text":"∈(x::AbstractVector, X::LazySet)\n\nCheck whether a point lies in a set.\n\nInput\n\nx – point/vector\nX – set\n\nOutput\n\ntrue iff x  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/#Base.:∈-Tuple{AbstractVector, AbstractAffineMap}","page":"Affine maps (AbstractAffineMap)","title":"Base.:∈","text":"Extended help\n\n∈(x::AbstractVector, am::AbstractAffineMap)\n\nAlgorithm\n\nObserve that x  MS  v iff M^-1(x - v)  S. This implementation does not explicitly invert the matrix, which is why it also works for non-square matrices.\n\nExamples\n\njulia> am = AffineMap([2.0 0.0; 0.0 1.0], BallInf([1., 1.], 1.), [-1.0, -1.0]);\n\njulia> [5.0, 1.0] ∈ am\nfalse\n\njulia> [3.0, 1.0] ∈ am\ntrue\n\nAn example with a non-square matrix:\n\njulia> B = BallInf(zeros(4), 1.);\n\njulia> M = [1. 0 0 0; 0 1 0 0]/2;\n\njulia> [0.5, 0.5] ∈ M*B\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/#LazySets.API.vertices_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap","page":"Affine maps (AbstractAffineMap)","title":"LazySets.API.vertices_list","text":"vertices_list(X::LazySet)\n\nCompute a list of vertices of a polytopic set.\n\nInput\n\nX – polytopic set\n\nOutput\n\nA list of the vertices of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/#LazySets.API.vertices_list-Tuple{AbstractAffineMap}","page":"Affine maps (AbstractAffineMap)","title":"LazySets.API.vertices_list","text":"Extended help\n\nvertices_list(am::AbstractAffineMap; [apply_convex_hull]::Bool=true)\n\nInput\n\napply_convex_hull – (optional, default: true) if true, apply the convex                        hull operation to the list of vertices transformed by                        the affine map\n\nAlgorithm\n\nThis implementation computes all vertices of X, then transforms them through the affine map, i.e., x ↦ M*x + v for each vertex x of X. By default, the convex-hull operation is taken before returning this list. For dimensions three or higher, this operation relies on the functionality through the concrete polyhedra library Polyhedra.jl.\n\nIf you are not interested in taking the convex hull of the resulting vertices under the affine map, pass apply_convex_hull=false as a keyword argument.\n\nNote that we assume that the underlying set X is polytopic, either concretely or lazily, i.e., the function vertices_list should be applicable.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/#LazySets.API.volume-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap","page":"Affine maps (AbstractAffineMap)","title":"LazySets.API.volume","text":"volume(X::LazySet)\n\nCompute the volume, or Lebesgue measure, of a set.\n\nInput\n\nX – set\n\nOutput\n\nA real number representing the Lebesgue measure of X.\n\nNotes\n\nThe Lebesgue measure has the following common special cases:\n\nIn 1D, it coincides with the length.\nIn 2D, it coincides with the area (see also area).\nIn 3D, it coincides with the volume.\n\nIn higher dimensions, it is also known as the hypervolume or simply volume.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/#LazySets.API.volume-Tuple{AbstractAffineMap}","page":"Affine maps (AbstractAffineMap)","title":"LazySets.API.volume","text":"Extended help\n\nvolume(am::AbstractAffineMap)\n\nNotes\n\nThis implementation requires a dimension-preserving map (i.e., a square matrix).\n\nAlgorithm\n\nA square linear map scales the volume of any set by its absolute determinant. A translation does not affect the volume. Thus, the volume of M * X + {v} is |det(M)| * volume(X).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractAffineMap/","page":"Affine maps (AbstractAffineMap)","title":"Affine maps (AbstractAffineMap)","text":"Undocumented implementations:","category":"page"},{"location":"lib/interfaces/AbstractAffineMap/","page":"Affine maps (AbstractAffineMap)","title":"Affine maps (AbstractAffineMap)","text":"dim\nisconvextype\nisoperationtype\nispolyhedral\nlinear_map\nρ\nσ","category":"page"},{"location":"lib/interfaces/AbstractAffineMap/","page":"Affine maps (AbstractAffineMap)","title":"Affine maps (AbstractAffineMap)","text":"Inherited from LazySet:","category":"page"},{"location":"lib/interfaces/AbstractAffineMap/","page":"Affine maps (AbstractAffineMap)","title":"Affine maps (AbstractAffineMap)","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nextrema\nextrema\nhigh\nhigh\nisboundedtype\nisoperation\nlow\nlow\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nproject\nsample\nscale\ntranslate\ncartesian_product\nconvex_hull\nexact_sum\n≈\nisdisjoint\n==\nisequivalent\n⊂\n⊆\nlinear_combination\nminkowski_difference\nminkowski_sum","category":"page"},{"location":"lib/interfaces/AbstractAffineMap/#Implementations","page":"Affine maps (AbstractAffineMap)","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/AbstractAffineMap/","page":"Affine maps (AbstractAffineMap)","title":"Affine maps (AbstractAffineMap)","text":"Affine map (AffineMap)\nExponential map (ExponentialMap)\nLinear map (LinearMap)\nReset map (ResetMap)\nTranslation","category":"page"},{"location":"lib/sets/HPolytope/#def_HPolytope","page":"HPolytope","title":"Polytope in constraint representation (HPolytope)","text":"","category":"section"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"Convex polytopes are bounded polyhedra. The type HPolytope represents polytopes. While identical to HPolyhedron in its representation, HPolytope instances are assumed to be bounded.","category":"page"},{"location":"lib/sets/HPolytope/#LazySets.HPolytopeModule.HPolytope","page":"HPolytope","title":"LazySets.HPolytopeModule.HPolytope","text":"HPolytope{N, VN<:AbstractVector{N}} <: AbstractPolytope{N}\n\nType that represents a convex polytope in constraint representation, i.e., a bounded set characterized by a finite intersection of half-spaces,\n\nP = _i = 1^m H_i\n\nwhere each H_i = x  ℝ^n  a_i^T x  b_i  is a half-space, a_i  ℝ^n is the normal vector of the i-th half-space and b_i is the displacement. It is assumed that P is bounded (see also LazySets.HPolyhedron, which does not make such an assumption).\n\nFields\n\nconstraints       – vector of linear constraints\ncheck_boundedness – (optional, default: false) flag for checking if the                        constraints make the polytope bounded; (boundedness is                        a running assumption for this type)\n\nNotes\n\nA polytope is a bounded polyhedron.\n\nBoundedness is a running assumption for this type. For performance reasons, boundedness is not checked in the constructor by default. We also exploit this assumption, so a boundedness check may not return the answer you would expect.\n\njulia> P = HPolytope([HalfSpace([1.0], 1.0)]);  # x <= 1\n\njulia> isbounded(P)  # uses the type assumption and does not actually check\ntrue\n\njulia> isbounded(P, false)  # performs a real boundedness check\nfalse\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/HPolytope/#Conversion","page":"HPolytope","title":"Conversion","text":"","category":"section"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"convert(::Type{HPolytope}, ::LazySet)\nconvert(::Type{HPolytope}, ::Polyhedra.HRep)","category":"page"},{"location":"lib/sets/HPolytope/#Operations","page":"HPolytope","title":"Operations","text":"","category":"section"},{"location":"lib/sets/HPolytope/#LazySets.API.isbounded","page":"HPolytope","title":"LazySets.API.isbounded","text":"isbounded(P::HPolytope, [use_type_assumption]::Bool=true)\n\nDetermine whether a polytope in constraint representation is bounded.\n\nInput\n\nP                   – polytope in constraint representation\nuse_type_assumption – (optional, default: true) flag for ignoring the                          type assumption that polytopes are bounded\n\nOutput\n\ntrue if use_type_assumption is activated. Otherwise, true iff P is bounded.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/HPolytope/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-HPolytope","page":"HPolytope","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/#Base.rand-Tuple{Type{HPolytope}}","page":"HPolytope","title":"Base.rand","text":"Extended help\n\nrand(::Type{HPolytope}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nInput\n\nnum_vertices – (optional, default: -1) upper bound on the number of                   vertices of the polytope (see comment below)\n\nAlgorithm\n\nIf num_vertices == 0, we create a fixed infeasible polytope (corresponding to the EmptySet).\n\nIf num_vertices == 1, we create a random Singleton and convert it.\n\nIf dim == 1, we create a random Interval and convert it.\n\nIf dim == 2, we create a random VPolygon and convert it.\n\nOtherwise, we create a random VPolytope and convert it (hence also the argument num_vertices). See rand(::Type{VPolytope}).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/#LazySets.API.vertices_list-Tuple{HPolytope}","page":"HPolytope","title":"LazySets.API.vertices_list","text":"vertices_list(P::HPolytope; [backend]=nothing, [prune]::Bool=true)\n\nReturn a list of the vertices of a polytope in constraint representation.\n\nInput\n\nP       – polytope in constraint representation\nbackend – (optional, default: nothing) the backend for polyhedral              computations\nprune   – (optional, default: true) flag to remove redundant vertices\n\nOutput\n\nA list of the vertices.\n\nAlgorithm\n\nIf the polytope is one-dimensional (resp. two-dimensional), it is converted to an interval (resp. polygon in constraint representation) and then the respective optimized vertices_list implementation is used.\n\nIt is possible to use the Polyhedra backend in the one- and two-dimensional case as well by passing a backend.\n\nIf the polytope is not two-dimensional, the concrete polyhedra-manipulation library Polyhedra is used. The actual computation is performed by a given backend; for the default backend used in LazySets see default_polyhedra_backend(P). For further information on the supported backends see Polyhedra's documentation.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"The following functionality is shared with HPolyhedron.","category":"page"},{"location":"lib/sets/HPolytope/#LazySets.API.dim-Tuple{LazySets.API.LazySet}-lib-sets-HPolytope","page":"HPolytope","title":"LazySets.API.dim","text":"dim(X::LazySet)\n\nCompute the ambient dimension of a set.\n\nInput\n\nX – set\n\nOutput\n\nThe ambient dimension of the set.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/#LazySets.API.dim-Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}} where N}-lib-sets-HPolytope","page":"HPolytope","title":"LazySets.API.dim","text":"Extended help\n\ndim(P::HPoly)\n\nOutput\n\nIf P has no constraints, the result is -1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/#LinearAlgebra.normalize-Union{Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}}}, Tuple{N}, Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}}, Real}} where N-lib-sets-HPolytope","page":"HPolytope","title":"LinearAlgebra.normalize","text":"normalize(P::HPoly{N}, p::Real=N(2)) where {N}\n\nNormalize a polyhedron in constraint representation.\n\nInput\n\nP – polyhedron in constraint representation\np – (optional, default: 2) norm\n\nOutput\n\nA new polyhedron in constraint representation whose normal directions a_i are normalized, i.e., such that a_i_p = 1 holds.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/#LazySets.remove_redundant_constraints-Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}} where N}-lib-sets-HPolytope","page":"HPolytope","title":"LazySets.remove_redundant_constraints","text":"remove_redundant_constraints(P::HPoly{N}; [backend]=nothing) where {N}\n\nRemove the redundant constraints in a polyhedron in constraint representation.\n\nInput\n\nP       – polyhedron\nbackend – (optional, default: nothing) the backend used to solve the              linear program\n\nOutput\n\nA polyhedron equivalent to P but with no redundant constraints, or an empty set if P is detected to be empty, which may happen if the constraints are infeasible.\n\nNotes\n\nIf backend is nothing, it defaults to default_lp_solver(N).\n\nAlgorithm\n\nSee remove_redundant_constraints!(::AbstractVector{<:HalfSpace}) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/#LazySets.remove_redundant_constraints!-Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}} where N}-lib-sets-HPolytope","page":"HPolytope","title":"LazySets.remove_redundant_constraints!","text":"remove_redundant_constraints!(P::HPoly{N}; [backend]=nothing) where {N}\n\nRemove the redundant constraints of a polyhedron in constraint representation; the polyhedron is updated in-place.\n\nInput\n\nP       – polyhedron\nbackend – (optional, default: nothing) the backend used to solve the              linear program\n\nOutput\n\ntrue if the method was successful and the polyhedron P is modified by removing its redundant constraints, and false if P is detected to be empty, which may happen if the constraints are infeasible.\n\nNotes\n\nIf backend is nothing, it defaults to default_lp_solver(N).\n\nAlgorithm\n\nSee remove_redundant_constraints!(::AbstractVector{<:HalfSpace}) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/#LazySets.tohrep-Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}} where N}-lib-sets-HPolytope","page":"HPolytope","title":"LazySets.tohrep","text":"tohrep(P::HPoly)\n\nReturn a constraint representation of the given polyhedron in constraint representation (no-op).\n\nInput\n\nP – polyhedron in constraint representation\n\nOutput\n\nThe same polyhedron instance.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/#LazySets.tovrep-Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}} where N}-lib-sets-HPolytope","page":"HPolytope","title":"LazySets.tovrep","text":"tovrep(P::HPoly; [backend]=default_polyhedra_backend(P))\n\nTransform a polytope in constraint representation to a polytope in vertex representation.\n\nInput\n\nP       – polytope in constraint representation\nbackend – (optional, default: default_polyhedra_backend(P)) the              backend for polyhedral computations\n\nOutput\n\nA VPolytope which is a vertex representation of the given polytope in constraint representation.\n\nNotes\n\nThe conversion may not preserve the numeric type (e.g., with N == Float32) depending on the backend. For further information on the supported backends see Polyhedra's documentation.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/#LazySets.addconstraint!-Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}} where N, HalfSpace}-lib-sets-HPolytope","page":"HPolytope","title":"LazySets.addconstraint!","text":"addconstraint!(P::HPoly, constraint::HalfSpace)\n\nAdd a linear constraint to a polyhedron in constraint representation.\n\nInput\n\nP          – polyhedron in constraint representation\nconstraint – linear constraint to add\n\nNotes\n\nIt is left to the user to guarantee that the dimension of all linear constraints is the same.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/#LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-HPolytope","page":"HPolytope","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, X::LazySet)\n\nEvaluate the support function of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nThe evaluation of the support function of X in direction d.\n\nNotes\n\nA convenience alias support_function is also available.\n\nWe have the following identity based on the support vector σ:\n\n    ρ(d X) = d  σ(d X)\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/#LazySets.API.ρ-Union{Tuple{N}, Tuple{M}, Tuple{AbstractVector{M}, Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}}}} where {M, N}-lib-sets-HPolytope","page":"HPolytope","title":"LazySets.API.ρ","text":"Extended help\n\nρ(d::AbstractVector{M}, P::HPoly{N};\n  solver=default_lp_solver(M, N)) where {M, N}\n\nInput\n\nsolver – (optional, default: default_lp_solver(M, N)) the backend used to             solve the linear program\n\nOutput\n\nIf P is unbounded in the given direction, there are two cases:\n\nIf P is an HPolytope, we throw an error.\nIf P is an HPolyedron, the result is Inf.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-HPolytope","page":"HPolytope","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/#LazySets.API.σ-Union{Tuple{N}, Tuple{M}, Tuple{AbstractVector{M}, Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}}}} where {M, N}-lib-sets-HPolytope","page":"HPolytope","title":"LazySets.API.σ","text":"Extended help\n\nσ(d::AbstractVector{M}, P::HPoly{N};\n  solver=default_lp_solver(M, N) where {M, N}\n\nInput\n\nsolver – (optional, default: default_lp_solver(M, N)) the backend used to             solve the linear program\n\nOutput\n\nIf P is unbounded in the given direction, there are two cases:\n\nIf P is an HPolytope, we throw an error.\nIf P is an HPolyedron, the result contains ±Inf entries.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/#LazySets.API.translate-Tuple{LazySets.API.LazySet, AbstractVector}-lib-sets-HPolytope","page":"HPolytope","title":"LazySets.API.translate","text":"translate(X::LazySet, v::AbstractVector)\n\nCompute the translation of a set with a vector.\n\nInput\n\nX – set\nv – vector\n\nOutput\n\nA set representing X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/#LazySets.API.translate-Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}} where N, AbstractVector}-lib-sets-HPolytope","page":"HPolytope","title":"LazySets.API.translate","text":"Extended help\n\ntranslate(P::HPoly, v::AbstractVector; [share]::Bool=false)\n\nInput\n\nshare – (optional, default: false) flag for sharing unmodified parts of            the original set representation\n\nNotes\n\nThe normal vectors of the constraints (vector a in a⋅x ≤ b) are shared with the original constraints if share == true.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/#LazySets.API.convex_hull-Tuple{Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}} where N, Union{HPolyhedron{N, VN} where VN<:AbstractVector{N}, HPolytope{N, VN} where VN<:AbstractVector{N}} where N}-lib-sets-HPolytope","page":"HPolytope","title":"LazySets.API.convex_hull","text":"convex_hull(P1::HPoly, P2::HPoly;\n           [backend]=default_polyhedra_backend(P1))\n\nCompute the convex hull of the set union of two polyhedra in constraint representation.\n\nInput\n\nP1      – polyhedron\nP2      – polyhedron\nbackend – (optional, default: default_polyhedra_backend(P1)) the              backend for polyhedral computations\n\nOutput\n\nThe HPolyhedron (resp. HPolytope) obtained by the concrete convex hull of P1 and P2.\n\nNotes\n\nFor performance reasons, it is suggested to use the CDDLib.Library() backend for the convex_hull.\n\nFor further information on the supported backends see Polyhedra's documentation.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"constraints_list\nisempty\nisoperationtype\npermute\nminkowski_sum","category":"page"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nlinear_map\nsample\nscale\ncartesian_product\nexact_sum\n≈\n==\nisequivalent\n⊂\nminkowski_difference","category":"page"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"an_element\nextrema\nextrema\nhigh\nhigh\nispolyhedral\nlow\nlow\n∈\nproject\nintersection\nisdisjoint","category":"page"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"isboundedtype\nisuniversal\nvolume\n⊆","category":"page"},{"location":"lib/interfaces/AbstractPolygon/","page":"Polygons (AbstractPolygon)","title":"Polygons (AbstractPolygon)","text":"Pages = [\"AbstractPolygon.md\"]\nDepth = 3","category":"page"},{"location":"lib/interfaces/AbstractPolygon/#def_AbstractPolygon","page":"Polygons (AbstractPolygon)","title":"Polygons (AbstractPolygon)","text":"","category":"section"},{"location":"lib/interfaces/AbstractPolygon/","page":"Polygons (AbstractPolygon)","title":"Polygons (AbstractPolygon)","text":"A polygon is a two-dimensional polytope.","category":"page"},{"location":"lib/interfaces/AbstractPolygon/#LazySets.AbstractPolygon","page":"Polygons (AbstractPolygon)","title":"LazySets.AbstractPolygon","text":"AbstractPolygon{N} <: AbstractPolytope{N}\n\nAbstract type for convex polygons (i.e., two-dimensional polytopes).\n\nNotes\n\nSee VPolygon for a standard implementation of this interface.\n\nThe subtypes of AbstractPolygon (including abstract interfaces):\n\njulia> subtypes(AbstractPolygon)\n2-element Vector{Any}:\n AbstractHPolygon\n VPolygon\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/AbstractPolygon/","page":"Polygons (AbstractPolygon)","title":"Polygons (AbstractPolygon)","text":"This interface defines the following functions (undocumented):","category":"page"},{"location":"lib/interfaces/AbstractPolygon/","page":"Polygons (AbstractPolygon)","title":"Polygons (AbstractPolygon)","text":"dim\nvolume\nintersection","category":"page"},{"location":"lib/interfaces/AbstractPolygon/","page":"Polygons (AbstractPolygon)","title":"Polygons (AbstractPolygon)","text":"Inherited from LazySet:","category":"page"},{"location":"lib/interfaces/AbstractPolygon/","page":"Polygons (AbstractPolygon)","title":"Polygons (AbstractPolygon)","text":"area\ncenter\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nlinear_map\nsample\nscale\nρ\ntranslate\ncartesian_product\nconvex_hull\nexact_sum\n≈\n==\nisequivalent\n⊂\nminkowski_difference","category":"page"},{"location":"lib/interfaces/AbstractPolygon/","page":"Polygons (AbstractPolygon)","title":"Polygons (AbstractPolygon)","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/interfaces/AbstractPolygon/","page":"Polygons (AbstractPolygon)","title":"Polygons (AbstractPolygon)","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/interfaces/AbstractPolygon/","page":"Polygons (AbstractPolygon)","title":"Polygons (AbstractPolygon)","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/interfaces/AbstractPolygon/","page":"Polygons (AbstractPolygon)","title":"Polygons (AbstractPolygon)","text":"an_element\nextrema\nextrema\nhigh\nhigh\nispolyhedral\nlow\nlow\n∈\nproject\nisdisjoint","category":"page"},{"location":"lib/interfaces/AbstractPolygon/","page":"Polygons (AbstractPolygon)","title":"Polygons (AbstractPolygon)","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/interfaces/AbstractPolygon/","page":"Polygons (AbstractPolygon)","title":"Polygons (AbstractPolygon)","text":"isbounded\nisboundedtype\nisempty\nisuniversal\n⊆\nminkowski_sum","category":"page"},{"location":"lib/interfaces/AbstractPolygon/","page":"Polygons (AbstractPolygon)","title":"Polygons (AbstractPolygon)","text":"The following helper functions are used for sorting directions:","category":"page"},{"location":"lib/interfaces/AbstractPolygon/#LazySets.jump2pi","page":"Polygons (AbstractPolygon)","title":"LazySets.jump2pi","text":"jump2pi(x::N) where {N<:AbstractFloat}\n\nReturn x + 2π if x is negative, otherwise return x.\n\nInput\n\nx – real scalar\n\nOutput\n\nx + 2π if x is negative, x otherwise.\n\nExamples\n\njulia> using LazySets: jump2pi\n\njulia> jump2pi(0.0)\n0.0\n\njulia> jump2pi(-0.5)\n5.783185307179586\n\njulia> jump2pi(0.5)\n0.5\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/AbstractPolygon/#LazySets.:⪯-Tuple{AbstractVector, AbstractVector}","page":"Polygons (AbstractPolygon)","title":"LazySets.:⪯","text":"⪯(u::AbstractVector, v::AbstractVector)\n\nCompare two 2D vectors by their direction.\n\nInput\n\nu – first 2D direction\nv – second 2D direction\n\nOutput\n\ntrue iff arg(u) 2π  arg(v) 2π.\n\nNotes\n\nThe argument is measured in counter-clockwise fashion, with the 0 being the direction (1, 0).\n\nAlgorithm\n\nThe implementation checks the quadrant of each direction, and compares directions using the right-hand rule. In particular, this method does not use the arctangent.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolygon/#LazySets._leq_trig-Union{Tuple{N}, Tuple{AbstractVector{N}, AbstractVector{N}}} where N<:AbstractFloat","page":"Polygons (AbstractPolygon)","title":"LazySets._leq_trig","text":"_leq_trig(u::AbstractVector{N}, v::AbstractVector{N}) where {N<:AbstractFloat}\n\nCompare two 2D vectors by their direction.\n\nInput\n\nu –  first 2D direction\nv –  second 2D direction\n\nOutput\n\ntrue iff arg(u) 2π  arg(v) 2π.\n\nNotes\n\nThe argument is measured in counter-clockwise fashion, with the 0 being the direction (1, 0).\n\nAlgorithm\n\nThe implementation uses the arctangent function with sign, atan, which for two arguments implements the atan2 function.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolygon/#LazySets.quadrant-Tuple{AbstractVector}","page":"Polygons (AbstractPolygon)","title":"LazySets.quadrant","text":"quadrant(w::AbstractVector)\n\nCompute the quadrant where the direction w belongs.\n\nInput\n\nw –  direction\n\nOutput\n\nAn integer from 0 to 3, with the following convention:\n\n     ^\n   1 | 0\n  ---+-->\n   2 | 3\n\nAlgorithm\n\nThe idea is to encode the following logic function: 11  0 01  1 00  2 10  3, according to the convention above.\n\nThis function is inspired from AGPX's answer in: Sort points in clockwise order?\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/AbstractPolygon/#Implementations","page":"Polygons (AbstractPolygon)","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/AbstractPolygon/","page":"Polygons (AbstractPolygon)","title":"Polygons (AbstractPolygon)","text":"Polygon in vertex representation (VPolygon)","category":"page"},{"location":"lib/sets/Hyperplane/#def_Hyperplane","page":"Hyperplane","title":"Hyperplane","text":"","category":"section"},{"location":"lib/sets/Hyperplane/#LazySets.HyperplaneModule.Hyperplane","page":"Hyperplane","title":"LazySets.HyperplaneModule.Hyperplane","text":"Hyperplane{N, VN<:AbstractVector{N}} <: AbstractPolyhedron{N}\n\nType that represents a hyperplane of the form ax = b.\n\nFields\n\na – normal direction (non-zero)\nb – constraint\n\nExamples\n\nThe plane y = 0:\n\njulia> Hyperplane([0, 1.], 0.)\nHyperplane{Float64, Vector{Float64}}([0.0, 1.0], 0.0)\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Hyperplane/#Conversion","page":"Hyperplane","title":"Conversion","text":"","category":"section"},{"location":"lib/sets/Hyperplane/","page":"Hyperplane","title":"Hyperplane","text":"The following method requires the SymEngine package.","category":"page"},{"location":"lib/sets/Hyperplane/#Base.convert-Union{Tuple{N}, Tuple{Type{Hyperplane{N, VN} where VN<:AbstractVector{N}}, Expr}} where N","page":"Hyperplane","title":"Base.convert","text":"convert(::Type{Hyperplane{N}}, expr::Expr; vars=Vector{Basic}=Basic[]) where {N}\n\nReturn a LazySet.Hyperplane given a symbolic expression that represents a hyperplane.\n\nInput\n\nexpr – a symbolic expression\nvars – (optional, default: Basic[]): set of variables with respect to which the           gradient is taken; if empty, we take the free symbols in the given expression\n\nOutput\n\nA Hyperplane, in the form ax = b.\n\nExamples\n\njulia> convert(Hyperplane, :(x1 = -0.03))\nHyperplane{Float64, Vector{Float64}}([1.0], -0.03)\n\njulia> convert(Hyperplane, :(x1 + 0.03 = 0))\nHyperplane{Float64, Vector{Float64}}([1.0], -0.03)\n\njulia> convert(Hyperplane, :(x1 + x2 = 2*x4 + 6))\nHyperplane{Float64, Vector{Float64}}([1.0, 1.0, -2.0], 6.0)\n\nYou can also specify the set of \"ambient\" variables in the hyperplane, even if not all of them appear:\n\njulia> using SymEngine: Basic\n\njulia> convert(Hyperplane, :(x1 + x2 = 2*x4 + 6), vars=Basic[:x1, :x2, :x3, :x4])\nHyperplane{Float64, Vector{Float64}}([1.0, 1.0, 0.0, -2.0], 6.0)\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#Operations","page":"Hyperplane","title":"Operations","text":"","category":"section"},{"location":"lib/sets/Hyperplane/#LazySets.API.an_element-Tuple{LazySets.API.LazySet}-lib-sets-Hyperplane","page":"Hyperplane","title":"LazySets.API.an_element","text":"an_element(X::LazySet)\n\nReturn some element of a nonempty set.\n\nInput\n\nX – set\n\nOutput\n\nAn element of X unless X is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.API.an_element-Tuple{Hyperplane}","page":"Hyperplane","title":"LazySets.API.an_element","text":"Extended help\n\nan_element(H::Hyperplane)\n\nAlgorithm\n\nWe compute a point on the hyperplane ax = b as follows:\n\nWe first find a nonzero entry of a in dimension, say, i.\nWe set xi = b  ai.\nWe set xj = 0 for all j  i.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.constrained_dimensions-Tuple{Hyperplane}","page":"Hyperplane","title":"LazySets.constrained_dimensions","text":"constrained_dimensions(H::Hyperplane)\n\nReturn the dimensions in which a hyperplane is constrained.\n\nInput\n\nH – hyperplane\n\nOutput\n\nA vector of ascending indices i such that the hyperplane is constrained in dimension i.\n\nExamples\n\nA 2D hyperplane with constraint x_1 = 0 is constrained in dimension 1 only.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.API.isbounded-Tuple{LazySets.API.LazySet}-lib-sets-Hyperplane","page":"Hyperplane","title":"LazySets.API.isbounded","text":"isbounded(X::LazySet)\n\nCheck whether a set is bounded.\n\nInput\n\nX – set\n\nOutput\n\ntrue iff the set is bounded.\n\nNotes\n\nSee also isboundedtype(::Type{<:LazySet}).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.API.isbounded-Tuple{Hyperplane}","page":"Hyperplane","title":"LazySets.API.isbounded","text":"Extended help\n\nisbounded(H::Hyperplane)\n\nAlgorithm\n\nThe result is true iff H is one-dimensional.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.API.isuniversal-Tuple{LazySets.API.LazySet}-lib-sets-Hyperplane","page":"Hyperplane","title":"LazySets.API.isuniversal","text":"isuniversal(X::LazySet, witness::Bool=false)\n\nCheck whether a set is universal.\n\nInput\n\nX       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X = ℝ^n\nIf the witness option is activated:\n(true, []) iff X = ℝ^n\n(false, v) iff X  ℝ^n for some v  X\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.API.isuniversal","page":"Hyperplane","title":"LazySets.API.isuniversal","text":"Extended help\n\nisuniversal(H::Hyperplane, [witness]::Bool=false)\n\nAlgorithm\n\nA witness is produced by adding the normal vector to an element on the hyperplane.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/Hyperplane/#LinearAlgebra.normalize-Union{Tuple{Hyperplane{N, VN} where VN<:AbstractVector{N}}, Tuple{N}, Tuple{Hyperplane{N, VN} where VN<:AbstractVector{N}, Real}} where N","page":"Hyperplane","title":"LinearAlgebra.normalize","text":"normalize(H::Hyperplane{N}, p::Real=N(2)) where {N}\n\nNormalize a hyperplane.\n\nInput\n\nH – hyperplane\np – (optional, default: 2) norm\n\nOutput\n\nA new hyperplane whose normal direction a is normalized, i.e., such that a_p = 1 holds.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-Hyperplane","page":"Hyperplane","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#Base.rand-Tuple{Type{Hyperplane}}","page":"Hyperplane","title":"Base.rand","text":"Extended help\n\nrand(::Type{Hyperplane}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the constraint a is nonzero.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-Hyperplane","page":"Hyperplane","title":"Base.:∈","text":"∈(x::AbstractVector, X::LazySet)\n\nCheck whether a point lies in a set.\n\nInput\n\nx – point/vector\nX – set\n\nOutput\n\ntrue iff x  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#Base.:∈-Tuple{AbstractVector, Hyperplane}","page":"Hyperplane","title":"Base.:∈","text":"Extended help\n\n∈(x::AbstractVector, H::Hyperplane)\n\nAlgorithm\n\nWe just check whether x satisfies ax = b.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.API.project-Tuple{AbstractVector, Hyperplane}","page":"Hyperplane","title":"LazySets.API.project","text":"project(x::AbstractVector, H::Hyperplane)\n\nProject a point onto a hyperplane.\n\nInput\n\nx – point\nH – hyperplane\n\nOutput\n\nThe projection of x onto H.\n\nAlgorithm\n\nThe projection of x onto the hyperplane of the form ax = b is\n\n    x - dfraca (ax - b)a²\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.API.reflect-Tuple{AbstractVector, Hyperplane}","page":"Hyperplane","title":"LazySets.API.reflect","text":"reflect(x::AbstractVector, H::Hyperplane)\n\nReflect (mirror) a vector in a hyperplane.\n\nInput\n\nx – point/vector\nH – hyperplane\n\nOutput\n\nThe reflection of x in H.\n\nAlgorithm\n\nThe reflection of a point x in the hyperplane a  x = b is\n\n    x  2 fracx  a  ba  a a\n\nwhere u  v denotes the dot product.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-Hyperplane","page":"Hyperplane","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, X::LazySet)\n\nEvaluate the support function of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nThe evaluation of the support function of X in direction d.\n\nNotes\n\nA convenience alias support_function is also available.\n\nWe have the following identity based on the support vector σ:\n\n    ρ(d X) = d  σ(d X)\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.API.ρ-Tuple{AbstractVector, Hyperplane}","page":"Hyperplane","title":"LazySets.API.ρ","text":"Extended help\n\nρ(d::AbstractVector, H::Hyperplane)\n\nOutput\n\nIf the set is unbounded in the given direction, the result is Inf.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-Hyperplane","page":"Hyperplane","title":"LazySets.API.σ","text":"σ(d::AbstractVector, X::LazySet)\n\nCompute a support vector of a set in a given direction.\n\nInput\n\nd – direction\nX – set\n\nOutput\n\nA support vector of X in direction d.\n\nNotes\n\nA convenience alias support_vector is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.API.σ-Tuple{AbstractVector, Hyperplane}","page":"Hyperplane","title":"LazySets.API.σ","text":"Extended help\n\nσ(d::AbstractVector, H::Hyperplane)\n\nOutput\n\nA support vector in the given direction, which is only defined in the following two cases:\n\nThe direction has norm zero.\nThe direction is the hyperplane's normal direction or its opposite direction.\n\nIn all cases, any point on the hyperplane is a solution. Otherwise this function throws an error.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.API.translate-Tuple{LazySets.API.LazySet, AbstractVector}-lib-sets-Hyperplane","page":"Hyperplane","title":"LazySets.API.translate","text":"translate(X::LazySet, v::AbstractVector)\n\nCompute the translation of a set with a vector.\n\nInput\n\nX – set\nv – vector\n\nOutput\n\nA set representing X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.API.translate-Tuple{Hyperplane, AbstractVector}","page":"Hyperplane","title":"LazySets.API.translate","text":"Extended help\n\ntranslate(H::Hyperplane, v::AbstractVector; share::Bool=false)\n\nNotes\n\nThe normal vector of the hyperplane (vector a in ax = b) is shared with the original hyperplane if share == true.\n\nAlgorithm\n\nA hyperplane ax = b is transformed to the hyperplane ax = b + av. In other words, we add the dot product av to b.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets._ishyperplanar","page":"Hyperplane","title":"LazySets._ishyperplanar","text":"_ishyperplanar(expr::Expr)\n\nDetermine whether the given expression corresponds to a hyperplane.\n\nInput\n\nexpr – a symbolic expression\n\nOutput\n\ntrue if expr corresponds to a half-space or false otherwise.\n\nExamples\n\njulia> using LazySets: _ishyperplanar\n\njulia> _ishyperplanar(:(x1 = 0))\ntrue\n\njulia> _ishyperplanar(:(x1 <= 0))\nfalse\n\njulia> _ishyperplanar(:(2*x1 = 4))\ntrue\n\njulia> _ishyperplanar(:(6.1 = 5.3*f - 0.1*g))\ntrue\n\njulia> _ishyperplanar(:(2*x1^2 = 4))\nfalse\n\njulia> _ishyperplanar(:(x1^2 = 4*x2 - x3))\nfalse\n\njulia> _ishyperplanar(:(x1 = 4*x2 - x3))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/Hyperplane/","page":"Hyperplane","title":"Hyperplane","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/Hyperplane/","page":"Hyperplane","title":"Hyperplane","text":"constraints_list\ndim\nisempty\nisoperationtype\ndistance\nproject\nisdisjoint","category":"page"},{"location":"lib/sets/Hyperplane/","page":"Hyperplane","title":"Hyperplane","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Hyperplane/","page":"Hyperplane","title":"Hyperplane","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisboundedtype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nlinear_map\nsample\nscale\ncartesian_product\nconvex_hull\nexact_sum\n≈\n==\nisequivalent\n⊂\nminkowski_difference","category":"page"},{"location":"lib/sets/Hyperplane/","page":"Hyperplane","title":"Hyperplane","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/Hyperplane/","page":"Hyperplane","title":"Hyperplane","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/Hyperplane/","page":"Hyperplane","title":"Hyperplane","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/Hyperplane/","page":"Hyperplane","title":"Hyperplane","text":"extrema\nextrema\nhigh\nhigh\nispolyhedral\nlow\nlow\nvertices_list\nintersection\n⊆\nminkowski_sum","category":"page"},{"location":"lib/sets/Singleton/#def_Singleton","page":"Singleton","title":"Singleton","text":"","category":"section"},{"location":"lib/sets/Singleton/#LazySets.SingletonModule.Singleton","page":"Singleton","title":"LazySets.SingletonModule.Singleton","text":"Singleton{N, VN<:AbstractVector{N}} <: AbstractSingleton{N}\n\nType that represents a singleton, that is, a set with a single element.\n\nFields\n\nelement – the only element of the set\n\nExamples\n\njulia> Singleton([1.0, 2.0])\nSingleton{Float64, Vector{Float64}}([1.0, 2.0])\n\njulia> Singleton(1.0, 2.0)  # convenience constructor from numbers\nSingleton{Float64, Vector{Float64}}([1.0, 2.0])\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Singleton/#Operations","page":"Singleton","title":"Operations","text":"","category":"section"},{"location":"lib/sets/Singleton/#LazySets.element-Tuple{Singleton}","page":"Singleton","title":"LazySets.element","text":"element(S::Singleton)\n\nReturn the element of a singleton.\n\nInput\n\nS – singleton\n\nOutput\n\nThe element of the singleton.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Singleton/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-Singleton","page":"Singleton","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Singleton/#Base.rand-Tuple{Type{Singleton}}","page":"Singleton","title":"Base.rand","text":"rand(::Type{Singleton}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nAlgorithm\n\nThe element is a normally distributed vector with entries of mean 0 and standard deviation 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Singleton/#LazySets.singleton_list-Tuple{LazySet}-lib-sets-Singleton","page":"Singleton","title":"LazySets.singleton_list","text":"singleton_list(P::LazySet)\n\nReturn the vertices of a polytopic set as a list of singletons.\n\nInput\n\nP – polytopic set\n\nOutput\n\nA list of the vertices of P as Singletons.\n\nNotes\n\nThis function relies on vertices_list, which raises an error if the set is not polytopic (e.g., unbounded).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Singleton/#LazySets.singleton_list-Tuple{Singleton}","page":"Singleton","title":"LazySets.singleton_list","text":"singleton_list(S::Singleton)\n\nReturn the vertices of a singleton as a list of singletons.\n\nInput\n\nS – singleton\n\nOutput\n\nThe list of vertices of S, as Singleton.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Singleton/#LazySets.API.translate!-Tuple{LazySets.API.LazySet, AbstractVector}-lib-sets-Singleton","page":"Singleton","title":"LazySets.API.translate!","text":"translate!(X::LazySet, v::AbstractVector)\n\nTranslate a set with a vector by modifying it.\n\nInput\n\nX – set\nv – vector\n\nOutput\n\nThe translated set representing X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Singleton/#LazySets.API.translate!-Tuple{Singleton, AbstractVector}","page":"Singleton","title":"LazySets.API.translate!","text":"Extended help\n\ntranslate!(S::Singleton, v::AbstractVector)\n\nAlgorithm\n\nWe add the vector to the point in the singleton.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"isoperationtype\nrectify\nlinear_map\npermute\nproject\nscale\nscale!","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"complement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisoperation\npolyhedron\nrationalize\ntosimplehrep\ntriangulate\ntriangulate_faces\naffine_map\nexponential_map\nis_interior_point\nsample\ntranslate\nconvex_hull\n≈\n==\n⊂","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"ispolyhedral","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"isbounded\nisboundedtype","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"an_element\ndim\nisempty\nisuniversal","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"order\nremove_redundant_generators\ntogrep\nreduce_order\nsplit\nsplit","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"Inherited from AbstractHyperrectangle:","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"area\nextrema\nextrema\nisflat\nnorm\nradius\nvolume\ndifference","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"Inherited from AbstractSingleton:","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"center\ncenter\nchebyshev_center_radius\nconstraints_list\ngenerators\ngenmat\nhigh\nhigh\nlow\nlow\nngens\nradius_hyperrectangle\nradius_hyperrectangle\nreflect\nvertices\nvertices_list\n∈\nρ\nσ\ncartesian_product\ndistance\nintersection\nisdisjoint\nisequivalent\n⊆\nminkowski_difference\nminkowski_sum","category":"page"},{"location":"lib/sets/Hyperrectangle/#def_Hyperrectangle","page":"Hyperrectangle","title":"Hyperrectangle","text":"","category":"section"},{"location":"lib/sets/Hyperrectangle/#LazySets.HyperrectangleModule.Hyperrectangle","page":"Hyperrectangle","title":"LazySets.HyperrectangleModule.Hyperrectangle","text":"Hyperrectangle{N, VNC<:AbstractVector{N}, VNR<:AbstractVector{N}\n              } <: AbstractHyperrectangle{N}\n\nType that represents a hyperrectangle.\n\nA hyperrectangle is the Cartesian product of one-dimensional intervals.\n\nFields\n\ncenter – center of the hyperrectangle as a real vector\nradius – radius of the hyperrectangle as a real vector, i.e., half of its             width along each coordinate direction\n\nExamples\n\nThe Hyperrectangle type stores a vector representing the center and another vector representing the radius. The default constructor Hyperrectangle(c, r) receives the center and radius, in that order. For instance,\n\njulia> c = [-1.0, 1.0];\n\njulia> r = [2.0, 1.0];\n\njulia> H = Hyperrectangle(c, r)\nHyperrectangle{Float64, Vector{Float64}, Vector{Float64}}([-1.0, 1.0], [2.0, 1.0])\n\nThe above instance represents the hyperrectangle with the following vertices:\n\njulia> vertices_list(H)\n4-element Vector{Vector{Float64}}:\n [1.0, 2.0]\n [-3.0, 2.0]\n [1.0, 0.0]\n [-3.0, 0.0]\n\nThe getter functions for the center and the radius are center and radius_hyperrectangle (since radius corresponds to the radius of the enclosing ball of minimal volume):\n\njulia> center(H)\n2-element Vector{Float64}:\n -1.0\n  1.0\n\njulia> radius_hyperrectangle(H)\n2-element Vector{Float64}:\n 2.0\n 1.0\n\nThere is also a constructor from lower and upper bounds with keyword arguments high and low. The following construction results in the same hyperrectangle as in the previous paragraph:\n\njulia> l = [-3.0, 0.0];\n\njulia> h = [1.0, 2.0];\n\njulia> Hyperrectangle(low=l, high=h)\nHyperrectangle{Float64, Vector{Float64}, Vector{Float64}}([-1.0, 1.0], [2.0, 1.0])\n\nBy default, the constructor checks that that radius of the hyperrectangle is nonnegative. To suppress this check, use the check_bounds optional flag in the constructor. Note that if check_bounds is set to false, the behavior of a set with contradictory bounds is undefined.\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Hyperrectangle/#Conversion","page":"Hyperrectangle","title":"Conversion","text":"","category":"section"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"convert(::Type{Hyperrectangle}, ::AbstractHyperrectangle)\nconvert(::Type{Hyperrectangle}, ::IA.IntervalBox)\nconvert(::Type{IA.IntervalBox}, ::AbstractHyperrectangle)","category":"page"},{"location":"lib/sets/Hyperrectangle/#Operations","page":"Hyperrectangle","title":"Operations","text":"","category":"section"},{"location":"lib/sets/Hyperrectangle/#LazySets.radius_hyperrectangle-Tuple{Hyperrectangle}","page":"Hyperrectangle","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(H::Hyperrectangle)\n\nReturn the box radius of a hyperrectangle in every dimension.\n\nInput\n\nH – hyperrectangle\n\nOutput\n\nThe box radius of the hyperrectangle.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperrectangle/#LazySets.radius_hyperrectangle-Tuple{Hyperrectangle, Int64}","page":"Hyperrectangle","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(H::Hyperrectangle, i::Int)\n\nReturn the box radius of a hyperrectangle in a given dimension.\n\nInput\n\nH – hyperrectangle\ni – dimension of interest\n\nOutput\n\nThe box radius in the given dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperrectangle/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-Hyperrectangle","page":"Hyperrectangle","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperrectangle/#Base.rand-Tuple{Type{Hyperrectangle}}","page":"Hyperrectangle","title":"Base.rand","text":"Extended help\n\nrand(::Type{Hyperrectangle}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the radius is nonnegative.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperrectangle/#LazySets.API.translate-Tuple{LazySets.API.LazySet, AbstractVector}-lib-sets-Hyperrectangle","page":"Hyperrectangle","title":"LazySets.API.translate","text":"translate(X::LazySet, v::AbstractVector)\n\nCompute the translation of a set with a vector.\n\nInput\n\nX – set\nv – vector\n\nOutput\n\nA set representing X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperrectangle/#LazySets.API.translate-Tuple{Hyperrectangle, AbstractVector}","page":"Hyperrectangle","title":"LazySets.API.translate","text":"Extended help\n\ntranslate(H::Hyperrectangle, v::AbstractVector; [share]::Bool=false)\n\nInput\n\nH     – hyperrectangle\nv     – translation vector\nshare – (optional, default: false) flag for sharing unmodified parts of            the original set representation\n\nNotes\n\nThe radius vector is shared with the original hyperrectangle if share == true.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"center","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"genmat","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"isoperationtype\npermute\nscale\nscale!\nρ\nσ\ntranslate!","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"chebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisoperation\npolyhedron\nrationalize\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nsample\nconvex_hull\nexact_sum\n≈\n==\nisequivalent\n⊂","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"ispolyhedral","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"isbounded\nisboundedtype","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"an_element\ncenter\ndim\nisempty\nisuniversal","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"order\nremove_redundant_generators\ntogrep\nlinear_map\nreduce_order\nsplit\nsplit","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"Inherited from AbstractHyperrectangle:","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"area\nconstraints_list\nextrema\nextrema\ngenerators\ngenmat\nhigh\nhigh\nisflat\nlow\nlow\nngens\nnorm\nradius\nrectify\nreflect\nvertices_list\nvolume\ndistance\n∈\nproject\nsplit\nρ\nσ\ncartesian_product\ndifference\ndistance\nintersection\nisdisjoint\n⊆\nminkowski_difference\nminkowski_sum","category":"page"},{"location":"lib/sets/Zonotope/#def_Zonotope","page":"Zonotope","title":"Zonotope","text":"","category":"section"},{"location":"lib/sets/Zonotope/#LazySets.ZonotopeModule.Zonotope","page":"Zonotope","title":"LazySets.ZonotopeModule.Zonotope","text":"Zonotope{N, VN<:AbstractVector{N}, MN<:AbstractMatrix{N}} <: AbstractZonotope{N}\n\nType that represents a zonotope.\n\nFields\n\ncenter     – center of the zonotope\ngenerators – matrix; each column is a generator of the zonotope\n\nNotes\n\nMathematically, a zonotope is defined as the set\n\nZ = left x  ℝ^n  x = c + _i=1^p ξ_i g_i ξ_i  -1 1  i = 1 p right\n\nwhere c  ℝ^n is its center and g_i_i=1^p, g_i  ℝ^n, is the set of generators. This characterization defines a zonotope as the finite Minkowski sum of line segments. Zonotopes can be equivalently described as the image of a unit infinity-norm ball in ℝ^n by an affine transformation.\n\nZonotopes can be constructed in two different ways: either passing the generators as a matrix, where each column represents a generator, or passing a list of vectors, where each vector represents a generator. Below we illustrate both ways.\n\nExamples\n\nA two-dimensional zonotope with given center and matrix of generators:\n\njulia> Z = Zonotope([1.0, 0.0], [0.1 0.0; 0.0 0.1])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.0, 0.0], [0.1 0.0; 0.0 0.1])\n\njulia> dim(Z)\n2\n\njulia> center(Z)\n2-element Vector{Float64}:\n 1.0\n 0.0\n\njulia> genmat(Z)\n2×2 Matrix{Float64}:\n 0.1  0.0\n 0.0  0.1\n\nHere, the first vector in the Zonotope constructor corresponds to the center and each column of the second argument corresponds to a generator. The functions center and genmat respectively return the center and the generator matrix of a zonotope.\n\nWe can collect the vertices using vertices_list:\n\njulia> vertices_list(Z)\n4-element Vector{Vector{Float64}}:\n [1.1, 0.1]\n [0.9, 0.1]\n [0.9, -0.1]\n [1.1, -0.1]\n\nThe support vector along a given direction can be computed using σ (resp. the support function can be computed using ρ):\n\njulia> σ([1.0, 1.0], Z)\n2-element Vector{Float64}:\n 1.1\n 0.1\n\nZonotopes admit an alternative constructor that receives a list of vectors, each vector representing a generator:\n\njulia> Z = Zonotope(ones(2), [[1.0, 0.0], [0.0, 1.0], [1.0, 1.0]])\nZonotope{Float64, Vector{Float64}, Matrix{Float64}}([1.0, 1.0], [1.0 0.0 1.0; 0.0 1.0 1.0])\n\njulia> genmat(Z)\n2×3 Matrix{Float64}:\n 1.0  0.0  1.0\n 0.0  1.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Zonotope/#Conversion","page":"Zonotope","title":"Conversion","text":"","category":"section"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"convert(::Type{Zonotope}, ::AbstractZonotope)","category":"page"},{"location":"lib/sets/Zonotope/#Operations","page":"Zonotope","title":"Operations","text":"","category":"section"},{"location":"lib/sets/Zonotope/#LazySets.generators-Tuple{Zonotope}","page":"Zonotope","title":"LazySets.generators","text":"generators(Z::Zonotope)\n\nReturn an iterator over the generators of a zonotope.\n\nInput\n\nZ – zonotope\n\nOutput\n\nAn iterator over the generators of Z.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/#LazySets.genmat-Tuple{Zonotope}","page":"Zonotope","title":"LazySets.genmat","text":"genmat(Z::Zonotope)\n\nReturn the generator matrix of a zonotope.\n\nInput\n\nZ – zonotope\n\nOutput\n\nA matrix where each column represents one generator of the zonotope Z.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-Zonotope","page":"Zonotope","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/#Base.rand-Tuple{Type{Zonotope}}","page":"Zonotope","title":"Base.rand","text":"Extended help\n\nrand(::Type{Zonotope}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1.\n\nThe number of generators can be controlled with the argument num_generators. For a negative value we choose a random number in the range dim:2*dim (except if dim == 1, in which case we only create a single generator).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/#LazySets.remove_redundant_generators-Tuple{AbstractZonotope}-lib-sets-Zonotope","page":"Zonotope","title":"LazySets.remove_redundant_generators","text":"remove_redundant_generators(Z::AbstractZonotope)\n\nRemove all redundant (pairwise linearly dependent) generators of a zonotopic set.\n\nInput\n\nZ – zonotopic set\n\nOutput\n\nA new zonotope with fewer generators, or the same zonotopic set if no generator could be removed.\n\nAlgorithm\n\nBy default this implementation returns the input zonotopic set. Subtypes of AbstractZonotope whose generators can be removed have to define a new method.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/#LazySets.remove_redundant_generators-Tuple{Zonotope}","page":"Zonotope","title":"LazySets.remove_redundant_generators","text":"Extended help\n\nremove_redundant_generators(Z::Zonotope)\n\nAlgorithm\n\nFor each generator g_j that has not been checked yet, we find all other generators that are linearly dependent with g_j. Then we combine those generators into a single generator.\n\nFor one-dimensional zonotopes we use a more efficient implementation where we just take the absolute sum of all generators.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/#LazySets.ZonotopeModule.remove_zero_generators-Tuple{Zonotope}","page":"Zonotope","title":"LazySets.ZonotopeModule.remove_zero_generators","text":"remove_zero_generators(Z::Zonotope)\n\nReturn a new zonotope removing the generators that are zero.\n\nInput\n\nZ – zonotope\n\nOutput\n\nIf there are no zero generators, the result is the original zonotope Z. Otherwise the result is a new zonotope that has the center and generators as Z except for those generators that are zero.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/#LazySets.ZonotopeModule.linear_map!-Tuple{Zonotope, AbstractMatrix, Zonotope}","page":"Zonotope","title":"LazySets.ZonotopeModule.linear_map!","text":"linear_map!(Zout::Zonotope, M::AbstractMatrix, Z::Zonotope)\n\nCompute the concrete linear map of a zonotope, storing the result in Zout.\n\nInput\n\nZout – zonotope (output)\nM    – matrix\nZ    – zonotope\n\nOutput\n\nThe zonotope Zout, which is modified in-place.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/#LazySets.API.scale!-Tuple{Real, LazySets.API.LazySet}-lib-sets-Zonotope","page":"Zonotope","title":"LazySets.API.scale!","text":"scale!(α::Real, X::LazySet)\n\nScale a set by modifying it.\n\nInput\n\nα – scalar\nX – set\n\nOutput\n\nThe scaled set representing α  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/#LazySets.API.scale!-Tuple{Real, Zonotope}","page":"Zonotope","title":"LazySets.API.scale!","text":"Extended help\n\nscale!(α::Real, Z::Zonotope)\n\nAlgorithm\n\nThe result is obtained by applying the numerical scale to the center and generators.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"center\nhigh\nlow","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"ngens","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"isoperationtype","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"togrep","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"permute","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"reduce_order","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"scale","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"split\nsplit","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"translate!","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nsample\ntranslate\nconvex_hull\nexact_sum\n≈\n==\nisequivalent\n⊂","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"high\nispolyhedral\nlow\nintersection","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"isbounded\nvolume\nisboundedtype","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"an_element\ncenter\ndim\nextrema\nextrema\nisempty\nisuniversal","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"constraints_list\nconstraints_list\norder\nreflect\nvertices_list\n∈\nlinear_map\nproject\nρ\nσ\ncartesian_product\nisdisjoint\n⊆\nminkowski_difference\nminkowski_sum","category":"page"},{"location":"lib/lazy_operations/InverseLinearMap/#def_InverseLinearMap","page":"InverseLinearMap","title":"Inverse linear map (InverseLinearMap)","text":"","category":"section"},{"location":"lib/lazy_operations/InverseLinearMap/#LazySets.InverseLinearMap","page":"InverseLinearMap","title":"LazySets.InverseLinearMap","text":"InverseLinearMap{N, S<:LazySet{N}, NM, MAT<:AbstractMatrix{NM}}\n    <: AbstractAffineMap{N, S}\n\nGiven a linear transformation M, this type represents the linear transformation M¹X of a set X without actually computing M¹.\n\nFields\n\nM – matrix (typically invertible, which can be checked in the constructor)\nX – set\n\nNotes\n\nMany set operations avoid computing the inverse of the matrix.\n\nIn principle, the matrix does not have to be invertible (it can for instance be rectangular) for many set operations.\n\nThis type is parametric in the elements of the inverse linear map, NM, which is independent of the numeric type of the wrapped set (N). Typically NM = N, but there may be exceptions, e.g., if NM is an interval that holds numbers of type N, where N is a floating-point type such as Float64.\n\nExamples\n\nFor the examples we create a 33 matrix and a unit three-dimensional square.\n\njulia> A = [1 2 3; 2 3 1; 3 1 2];\n\njulia> X = BallInf([0, 0, 0], 1);\n\njulia> ilm = InverseLinearMap(A, X)\nInverseLinearMap{Int64, BallInf{Int64, Vector{Int64}}, Int64, Matrix{Int64}}([1 2 3; 2 3 1; 3 1 2], BallInf{Int64, Vector{Int64}}([0, 0, 0], 1))\n\nApplying an inverse linear map to a InverseLinearMap object combines the two maps into a single InverseLinearMap instance.\n\njulia> B = transpose(A); ilm2 = InverseLinearMap(B, ilm)\nInverseLinearMap{Int64, BallInf{Int64, Vector{Int64}}, Int64, Matrix{Int64}}([14 11 11; 11 14 11; 11 11 14], BallInf{Int64, Vector{Int64}}([0, 0, 0], 1))\n\njulia> ilm2.M == A*B\ntrue\n\nThe application of an InverseLinearMap to a ZeroSet or an EmptySet is simplified automatically.\n\njulia> InverseLinearMap(A, ZeroSet{Int}(3))\nZeroSet{Int64}(3)\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/InverseLinearMap/#LazySets.API.dim-Tuple{InverseLinearMap}","page":"InverseLinearMap","title":"LazySets.API.dim","text":"dim(ilm::InverseLinearMap)\n\nReturn the dimension of an inverse linear map.\n\nInput\n\nilm – inverse linear map\n\nOutput\n\nThe ambient dimension of the inverse linear map.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/InverseLinearMap/#LazySets.API.σ-Tuple{AbstractVector, InverseLinearMap}","page":"InverseLinearMap","title":"LazySets.API.σ","text":"σ(d::AbstractVector, ilm::InverseLinearMap)\n\nReturn a support vector of a inverse linear map.\n\nInput\n\nd   – direction\nilm – inverse linear map\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\nNotes\n\nIf L = M^-1X, where M is a matrix and X is a set, since (M^T)^{-1}=(M^{-1})^T, it follows that σ(d L) = M^-1σ((M^T)^-1 d X) for any direction d.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/InverseLinearMap/#LazySets.API.ρ-Tuple{AbstractVector, InverseLinearMap}","page":"InverseLinearMap","title":"LazySets.API.ρ","text":"ρ(d::AbstractVector, ilm::InverseLinearMap)\n\nEvaluate the support function of the inverse linear map.\n\nInput\n\nd      – direction\nilm    – inverse linear map\n\nOutput\n\nThe evaluation of the support function in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\nNotes\n\nIf L = M^-1X, where M is a matrix and X is a set, it follows that ρ(d L) = ρ((M^T)^-1 d X) for any direction d.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/InverseLinearMap/#Base.:∈-Tuple{AbstractVector, InverseLinearMap}","page":"InverseLinearMap","title":"Base.:∈","text":"∈(x::AbstractVector, ilm::InverseLinearMap)\n\nCheck whether a given point is contained in the inverse linear map of a set.\n\nInput\n\nx   – point/vector\nilm – inverse linear map of a set\n\nOutput\n\ntrue iff x  ilm.\n\nAlgorithm\n\nThis implementation does not explicitly invert the matrix since it uses the property x  M^-1X iff Mx  X.\n\nExamples\n\njulia> ilm = LinearMap([0.5 0.0; 0.0 -0.5], BallInf([0., 0.], 1.));\n\njulia> [1.0, 1.0] ∈ ilm\nfalse\n\njulia> [0.1, 0.1] ∈ ilm\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/InverseLinearMap/#LazySets.API.an_element-Tuple{InverseLinearMap}","page":"InverseLinearMap","title":"LazySets.API.an_element","text":"an_element(ilm::InverseLinearMap)\n\nReturn some element of an inverse linear map.\n\nInput\n\nilm – inverse linear map\n\nOutput\n\nAn element in the inverse linear map. It relies on the an_element function of the wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/InverseLinearMap/#LazySets.API.vertices_list-Tuple{InverseLinearMap}","page":"InverseLinearMap","title":"LazySets.API.vertices_list","text":"vertices_list(ilm::InverseLinearMap; prune::Bool=true)\n\nReturn the list of vertices of a (polyhedral) inverse linear map.\n\nInput\n\nilm   – inverse linear map\nprune – (optional, default: true) if true, remove redundant vertices\n\nOutput\n\nA list of vertices.\n\nAlgorithm\n\nWe assume that the underlying set X is polyhedral. Then the result is just the inverse linear map applied to the vertices of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/InverseLinearMap/#LazySets.API.constraints_list-Tuple{InverseLinearMap}","page":"InverseLinearMap","title":"LazySets.API.constraints_list","text":"constraints_list(ilm::InverseLinearMap)\n\nReturn a list of constraints of a (polyhedral) inverse linear map.\n\nInput\n\nilm – inverse linear map\n\nOutput\n\nA list of constraints of the inverse linear map.\n\nAlgorithm\n\nWe fall back to a concrete set representation and apply linear_map_inverse.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/InverseLinearMap/#LazySets.API.linear_map-Tuple{AbstractMatrix, InverseLinearMap}","page":"InverseLinearMap","title":"LazySets.API.linear_map","text":"linear_map(M::AbstractMatrix, ilm::InverseLinearMap)\n\nReturn the linear map of a lazy inverse linear map.\n\nInput\n\nM   – matrix\nilm – inverse linear map\n\nOutput\n\nThe set representing the linear map of the lazy inverse linear map of a set.\n\nNotes\n\nThis implementation is inefficient because it computes the concrete inverse of M, which is what InverseLinearMap is supposed to avoid.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/InverseLinearMap/","page":"InverseLinearMap","title":"InverseLinearMap","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/InverseLinearMap/","page":"InverseLinearMap","title":"InverseLinearMap","text":"norm\nradius\ndiameter\nsingleton_list\nreflect","category":"page"},{"location":"lib/lazy_operations/InverseLinearMap/","page":"InverseLinearMap","title":"InverseLinearMap","text":"Inherited from AbstractAffineMap:","category":"page"},{"location":"lib/lazy_operations/InverseLinearMap/","page":"InverseLinearMap","title":"InverseLinearMap","text":"isempty\nisbounded","category":"page"},{"location":"lib/concrete_binary_operations/isdisjoint/","page":"Check for Disjointness of Sets","title":"Check for Disjointness of Sets","text":"Pages = [\"isdisjoint.md\"]\nDepth = 3","category":"page"},{"location":"lib/concrete_binary_operations/isdisjoint/#Check-for-Disjointness-of-Sets","page":"Check for Disjointness of Sets","title":"Check for Disjointness of Sets","text":"","category":"section"},{"location":"lib/concrete_binary_operations/isdisjoint/","page":"Check for Disjointness of Sets","title":"Check for Disjointness of Sets","text":"The function isdisjoint checks whether the intersection of two sets is empty. It can optionally produce a witness if the intersection is nonempty.","category":"page"},{"location":"lib/concrete_binary_operations/isdisjoint/#Examples","page":"Check for Disjointness of Sets","title":"Examples","text":"","category":"section"},{"location":"lib/concrete_binary_operations/isdisjoint/","page":"Check for Disjointness of Sets","title":"Check for Disjointness of Sets","text":"We use the following four sets for illustration.","category":"page"},{"location":"lib/concrete_binary_operations/isdisjoint/","page":"Check for Disjointness of Sets","title":"Check for Disjointness of Sets","text":"using LazySets, LazySets.Approximations, Plots\nB1 = Ball1(-ones(2), 1.)\nB2 = Ball2(ones(2), 1.)\nBI = BallInf(zeros(2), 1.)\nH = Hyperrectangle(ones(2), ones(2))\nsets = [B1, B2, BI, H]\n\nfunction plot_sets(sets)\n    for S in sets\n        println(S)\n        plot!(S, 1e-2, fillalpha=0.1)\n    end\nend\n\nfunction plot_points(points, prefix)\n    for i in eachindex(points)\n        p = points[i]\n        num_occur = length(findfirst(x -> x == p, points[1:i]))\n        x = p[1]\n        y = p[2]\n        if num_occur == 1\n            x += 0.15\n        elseif num_occur == 2\n            y += 0.15\n        elseif num_occur == 3\n            x -= 0.15\n        else\n            y -= 0.15\n        end\n        plot!(Singleton(p))\n        plot!(annotations=(x, y, text(\"$(prefix)$(i)\")))\n    end\nend\n\nplot1 = plot()\nplot_sets(sets)\nplot1","category":"page"},{"location":"lib/concrete_binary_operations/isdisjoint/","page":"Check for Disjointness of Sets","title":"Check for Disjointness of Sets","text":"println(isdisjoint(BI, H))\nw1 = isdisjoint(BI, H, true)[2]\nprintln(isdisjoint(B1, BI))\nw2 = isdisjoint(B1, BI, true)[2]\nprintln(isdisjoint(B1, H))","category":"page"},{"location":"lib/concrete_binary_operations/isdisjoint/","page":"Check for Disjointness of Sets","title":"Check for Disjointness of Sets","text":"witnesses = [w1, w2]\n\nplot1 = plot()\nplot_sets(sets)\nplot_points(witnesses, \"w\")\nplot1","category":"page"},{"location":"lib/concrete_binary_operations/isdisjoint/#Methods","page":"Check for Disjointness of Sets","title":"Methods","text":"","category":"section"},{"location":"lib/concrete_binary_operations/isdisjoint/#Base.isdisjoint-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-concrete_binary_operations-isdisjoint","page":"Check for Disjointness of Sets","title":"Base.isdisjoint","text":"isdisjoint(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nCheck whether two sets are disjoint (i.e., do not intersect), and optionally compute a witness.\n\nInput\n\nX       – set\nY       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X  Y = \nIf the witness option is activated:\n(true, []) iff X  Y = \n(false, v) iff X  Y   for some v  X  Y\n\nNotes\n\nThe convenience alias is_intersection_empty is also available.\n\n\n\n\n\n","category":"method"},{"location":"lib/concrete_binary_operations/isdisjoint/#Base.isdisjoint","page":"Check for Disjointness of Sets","title":"Base.isdisjoint","text":"Extended help\n\nisdisjoint(X::LazySet, S::AbstractSingleton, [witness]::Bool=false)\n\nAlgorithm\n\nLet S = s. Then S  X =  iff s  X.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/isdisjoint/#Base.isdisjoint-2","page":"Check for Disjointness of Sets","title":"Base.isdisjoint","text":"Extended help\n\nisdisjoint(Z::AbstractZonotope, H::Hyperplane, [witness]::Bool=false)\n\nAlgorithm\n\nZ  H =  iff (b - ac)  left  _i=1^p ag_i right, where a, b are the hyperplane coefficients, c is the zonotope's center, and g_i are the zonotope's generators.\n\nFor witness production we fall back to a less efficient implementation for general sets as the first argument.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/isdisjoint/#Base.isdisjoint-3","page":"Check for Disjointness of Sets","title":"Base.isdisjoint","text":"Extended help\n\nisdisjoint(X::LazySet, hp::Hyperplane, [witness]::Bool=false)\n\nNotes\n\nThis implementation assumes that the set X is convex.\n\nAlgorithm\n\nA convex set intersects with a hyperplane iff the support function in the negative resp. positive direction of the hyperplane's normal vector a is to the left resp. right of the hyperplane's constraint b:\n\n-ρ(-a X)  b  ρ(a X)\n\nFor witness generation, we compute a line connecting the support vectors to the left and right, and then take the intersection of the line with the hyperplane. We follow this algorithm for the line-hyperplane intersection.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/isdisjoint/#Base.isdisjoint-4","page":"Check for Disjointness of Sets","title":"Base.isdisjoint","text":"Extended help\n\nisdisjoint(X::LazySet, hs::HalfSpace, [witness]::Bool=false)\n\nAlgorithm\n\nA set intersects with a half-space iff the support function in the negative direction of the half-space's normal vector a is less than the constraint b of the half-space: -ρ(-a X)  b.\n\nFor compact set X, we equivalently have that the support vector in the negative direction -a is contained in the half-space: σ(-a)  hs. The support vector is thus also a witness if the sets are not disjoint.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/isdisjoint/#Base.isdisjoint-5","page":"Check for Disjointness of Sets","title":"Base.isdisjoint","text":"Extended help\n\nisdisjoint(P::AbstractPolyhedron, X::LazySet, [witness]::Bool=false;\n           [solver]=nothing, [algorithm]=\"exact\")\n\nInput\n\nsolver    – (optional, default: nothing) the backend used to solve the                linear program\nalgorithm – (optional, default: \"exact\") algorithm keyword, one of:                * \"exact\" (exact, uses a feasibility LP)                *\"sufficient\" (sufficient, uses half-space checks)\n\nNotes\n\nFor algorithm == \"exact\", we assume that constraints_list(X) is defined. For algorithm == \"sufficient\", witness production is not supported.\n\nFor solver == nothing, we fall back to default_lp_solver(N).\n\nAlgorithm\n\nFor algorithm == \"exact\", see isempty(P::HPoly, ::Bool).\n\nFor algorithm == \"sufficient\", we rely on the intersection check between the set X and each constraint in P. This requires one support-function evaluation of X for each constraint of P. With this algorithm, the method may return false even in the case where the intersection is empty. On the other hand, if the algorithm returns true, then it is guaranteed that the intersection is empty.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/isdisjoint/#Base.isdisjoint-6","page":"Check for Disjointness of Sets","title":"Base.isdisjoint","text":"Extended help\n\nisdisjoint(C::Complement, X::LazySet, [witness]::Bool=false)\n\nAlgorithm\n\nWe fall back to X ⊆ C.X, which can be justified as follows:\n\n    X  Y^C =   X  Y\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/isdisjoint/#Base.isdisjoint-7","page":"Check for Disjointness of Sets","title":"Base.isdisjoint","text":"Extended help\n\nisdisjoint(cpa::CartesianProductArray, P::AbstractPolyhedron,\n           [witness]::Bool=false)\n\nNotes\n\nThis implementation assumes that the sets in the Cartesian product cpa are polyhedral.\n\ncpa     – Cartesian products of a finite number of polytopes\n\nAlgorithm\n\nWe first identify the blocks of cpa in which P is constrained. Then we project cpa to those blocks and convert the result to an HPolytope (or HPolyhedron if the set type is not known to be bounded) Q. Finally we determine whether Q and the projected P intersect.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/isdisjoint/#Base.isdisjoint-8","page":"Check for Disjointness of Sets","title":"Base.isdisjoint","text":"Extended help\n\nisdisjoint(X::CartesianProductArray, Y::CartesianProductArray,\n           [witness]::Bool=false)\n\nNotes\n\nThe implementation requires (and checks) that the Cartesian products have the same block structure.\n\nWitness production is currently not supported.\n\n\n\n\n\n","category":"function"},{"location":"lib/concrete_binary_operations/isdisjoint/#Base.isdisjoint-9","page":"Check for Disjointness of Sets","title":"Base.isdisjoint","text":"Extended help\n\nisdisjoint(cpa::CartesianProductArray, H::AbstractHyperrectangle,\n           [witness]::Bool=false)\n\nAlgorithm\n\nThe sets cpa and H are disjoint if and only if at least one block of cpa and the corresponding projection of H are disjoint. We perform these checks sequentially.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/Interval/#def_Interval","page":"Interval","title":"Interval","text":"","category":"section"},{"location":"lib/sets/Interval/#LazySets.IntervalModule.Interval","page":"Interval","title":"LazySets.IntervalModule.Interval","text":"Interval{N} <: AbstractHyperrectangle{N}\n\nType representing an interval on the real line. Mathematically, it is of the form\n\na b =  a  x  b   ℝ\n\nFields\n\ndat – data container for the given interval\n\nNotes\n\nThis type relies on the IntervalArithmetic.jl library for representation of intervals and arithmetic operations.\n\nExamples\n\nUnidimensional intervals are symbolic representations of a real closed interval.\n\nWe can create intervals in different ways. The simplest way is to pass a pair of numbers:\n\njulia> x = Interval(0.0, 1.0)\nInterval{Float64}([0, 1])\n\nA 2-vector is also possible:\n\njulia> x = Interval([0.0, 1.0])\nInterval{Float64}([0, 1])\n\nAn interval can also be constructed from an IntervalArithmetic.Interval. Note that if the package IntervalArithmetic is loaded in the current scope, you have to prepend the package names to Intervals since there is a name conflict otherwise.\n\njulia> using IntervalArithmetic\nWARNING: using IntervalArithmetic.Interval in module Main conflicts with an existing identifier.\n\njulia> x = LazySets.Interval(IntervalArithmetic.Interval(0.0, 1.0))\nInterval{Float64}([0, 1])\n\njulia> dim(x)\n1\n\njulia> center(x)\n1-element Vector{Float64}:\n 0.5\n\nThe usual pairwise arithmetic operators - and * are interpreted in the standard way known in interval arithmetic, so the results are Intervals. Note that + is generally used for the lazy Minkowksi sum in this library.\n\nIntervals of other numeric types can be created as well, e.g., a rational interval:\n\njulia> Interval(0//1, 2//1)\nInterval{Rational{Int64}}([0//1, 2//1])\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Interval/#Conversion","page":"Interval","title":"Conversion","text":"","category":"section"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"convert(::Type{Interval}, ::LazySet)\nconvert(::Type{IA.Interval}, ::LazySet)\nconvert(::Type{Interval}, ::IA.Interval)","category":"page"},{"location":"lib/sets/Interval/#Operations","page":"Interval","title":"Operations","text":"","category":"section"},{"location":"lib/sets/Interval/#LazySets.API.an_element-Tuple{LazySets.API.LazySet}-lib-sets-Interval","page":"Interval","title":"LazySets.API.an_element","text":"an_element(X::LazySet)\n\nReturn some element of a nonempty set.\n\nInput\n\nX – set\n\nOutput\n\nAn element of X unless X is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.API.an_element-Tuple{Interval}","page":"Interval","title":"LazySets.API.an_element","text":"Extended help\n\nan_element(X::Interval)\n\nAlgorithm\n\nReturn the left border (low(X)) of the interval.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.chebyshev_center_radius-Tuple{Interval}","page":"Interval","title":"LazySets.chebyshev_center_radius","text":"chebyshev_center_radius(X::Interval; [kwargs]...)\n\nCompute a Chebyshev center and the corresponding radius of an interval.\n\nInput\n\nX      – interval\nkwargs – further keyword arguments (ignored)\n\nOutput\n\nThe pair (c, r) where c is the Chebyshev center of X and r is the radius of the largest Euclidean ball with center c enclosed by X.\n\nNotes\n\nThe Chebyshev center of an interval is just the center of the interval.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.isflat-Tuple{Interval}","page":"Interval","title":"LazySets.isflat","text":"isflat(X::Interval)\n\nCheck whether an interval is flat, i.e., whether its extreme values coincide.\n\nInput\n\nX – interval\n\nOutput\n\ntrue if the interval is flat and false otherwise.\n\nNotes\n\nFor robustness with respect to floating-point inputs, this function relies on the result of isapproxzero when applied to the diameter of the interval. In other words, this function depends on the absolute zero tolerance ABSZTOL.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.ngens-Tuple{Interval}","page":"Interval","title":"LazySets.ngens","text":"ngens(X::Interval)\n\nReturn the number of generators of an interval.\n\nInput\n\nX – interval\n\nOutput\n\nThe number of generators.\n\nAlgorithm\n\nAn interval has either one generator, or zero generators if it is a degenerated interval of diameter zero.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.radius_hyperrectangle-Tuple{Interval}","page":"Interval","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(X::Interval)\n\nReturn the box radius of an interval in every dimension.\n\nInput\n\nX – interval\n\nOutput\n\nThe box radius of the interval (a one-dimensional vector).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.radius_hyperrectangle-Tuple{Interval, Int64}","page":"Interval","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(X::Interval, i::Int)\n\nReturn the box radius of an interval in a given dimension.\n\nInput\n\nX – interval\ni – dimension index (must be 1)\n\nOutput\n\nThe box radius in the given dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#Base.rand-Tuple{Type{<:LazySets.API.LazySet}}-lib-sets-Interval","page":"Interval","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#Base.rand-Tuple{Type{Interval}}","page":"Interval","title":"Base.rand","text":"Extended help\n\nrand(::Type{Interval}; [N]::Type{<:Real}=Float64, [dim]::Int=1,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nNotes\n\nAll numbers are normally distributed with mean 0 and standard deviation 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#ReachabilityBase.Arrays.rectify-Tuple{LazySets.API.LazySet}-lib-sets-Interval","page":"Interval","title":"ReachabilityBase.Arrays.rectify","text":"rectify(X::LazySet)\n\nCompute the rectification of a set.\n\nInput\n\nX – set\n\nOutput\n\nA set representing the rectification of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#ReachabilityBase.Arrays.rectify-Tuple{Interval}","page":"Interval","title":"ReachabilityBase.Arrays.rectify","text":"Extended help\n\nrectify(X::Interval)\n\nOutput\n\nAn Interval, even if it represents a singleton only containing the origin (which is the case if the original interval was nonpositive).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.API.vertices_list-Tuple{LazySets.API.LazySet}-lib-sets-Interval","page":"Interval","title":"LazySets.API.vertices_list","text":"vertices_list(X::LazySet)\n\nCompute a list of vertices of a polytopic set.\n\nInput\n\nX – polytopic set\n\nOutput\n\nA list of the vertices of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.API.vertices_list-Tuple{Interval}","page":"Interval","title":"LazySets.API.vertices_list","text":"Extended help\n\nvertices_list(X::Interval; kwargs...)\n\nOutput\n\nThe list of vertices of the interval, which are two one-dimensional vectors, or just one if the interval is degenerate (the endpoints match within the working tolerance).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.API.linear_map-Tuple{AbstractMatrix, LazySets.API.LazySet}-lib-sets-Interval","page":"Interval","title":"LazySets.API.linear_map","text":"linear_map(M::AbstractMatrix, X::LazySet)\n\nCompute the linear map M  X.\n\nInput\n\nM – matrix\nX – set\n\nOutput\n\nA set representing the linear map M  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.API.linear_map-Tuple{AbstractMatrix, Interval}","page":"Interval","title":"LazySets.API.linear_map","text":"Extended help\n\nlinear_map(M::AbstractMatrix, X::Interval)\n\nOutput\n\nEither an interval or a zonotope, depending on the leading dimension (i.e., the number of rows) of M:\n\nIf size(M, 1) == 1, the output is an Interval obtained by scaling X by the matrix M.\nIf size(M, 1) ≠ 1, the output is a Zonotope with center M * center(X) and the single generator M * g, where g = (high(X)-low(X))/2.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#Base.split-Tuple{Interval, AbstractVector{Int64}}","page":"Interval","title":"Base.split","text":"split(X::Interval, k)\n\nPartition an interval into k uniform sub-intervals.\n\nInput\n\nX – interval\nk – number of sub-intervals, possibly wrapped in a vector of length 1\n\nOutput\n\nA list of k Intervals.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.API.translate-Tuple{LazySets.API.LazySet, AbstractVector}-lib-sets-Interval","page":"Interval","title":"LazySets.API.translate","text":"translate(X::LazySet, v::AbstractVector)\n\nCompute the translation of a set with a vector.\n\nInput\n\nX – set\nv – vector\n\nOutput\n\nA set representing X + v.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.API.translate-Tuple{Interval, AbstractVector}","page":"Interval","title":"LazySets.API.translate","text":"Extended help\n\ntranslate(X::Interval, v::AbstractVector)\n\nNotes\n\nAn in-place version is not available because the IntervalArithmetic.Interval type is immutable.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.API.difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-sets-Interval","page":"Interval","title":"LazySets.API.difference","text":"difference(X::LazySet, Y::LazySet)\n\nCompute the set difference of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the difference X  Y.\n\nNotes\n\nThe set difference is defined as:\n\n    X  Y = x mid x  X text and  x  Y \n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.API.difference-Tuple{Interval, Interval}","page":"Interval","title":"LazySets.API.difference","text":"Extended help\n\ndifference(X::Interval, Y::Interval)\n\nOutput\n\nDepending on the position of the intervals, the output is one of the following:\n\nAn EmptySet.\nAn Interval.\nA UnionSet of two Interval sets.\n\nAlgorithm\n\nLet X = a b and Y = c d be intervals. Their set difference is X  Y = x x  X text and  x  Y  and, depending on their position, three different results may occur:\n\nIf X and Y do not overlap, i.e., if their intersection is empty, then the set difference is just X.\nOtherwise, let Z = X  Y  , then Z splits X into either one or two intervals. The latter case happens when the bounds of Y are strictly contained in X.\n\nTo check for strict inclusion, we assume that the inclusion is strict and then check whether the resulting intervals that cover X (one to its left and one to its right, let them be L and R), obtained by intersection with Y, are flat. Three cases may arise:\n\nIf both L and R are flat then X = Y and the result is the empty set.\nIf only L is flat, then the result is R, the remaining interval not covered by Y. Similarly, if only R is flat, then the result is L.\nFinally, if none of the intervals is flat, then Y is strictly contained in X and the set union of L and R is returned.\n\nExamples\n\njulia> X = Interval(0, 2); Y = Interval(1, 4); Z = Interval(2, 3);\n\njulia> difference(X, X)\n∅(1)\n\njulia> difference(X, Y)\nInterval{Float64}([0, 1])\n\njulia> difference(Y, Z)\nUnionSet{Float64, Interval{Float64}, Interval{Float64}}(Interval{Float64}([1, 2]), Interval{Float64}([3, 4]))\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#Base.isdisjoint-lib-sets-Interval","page":"Interval","title":"Base.isdisjoint","text":"isdisjoint(X::LazySet, Y::LazySet, [witness]::Bool=false)\n\nCheck whether two sets are disjoint (i.e., do not intersect), and optionally compute a witness.\n\nInput\n\nX       – set\nY       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X  Y = \nIf the witness option is activated:\n(true, []) iff X  Y = \n(false, v) iff X  Y   for some v  X  Y\n\nNotes\n\nThe convenience alias is_intersection_empty is also available.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/Interval/#Base.isdisjoint","page":"Interval","title":"Base.isdisjoint","text":"Extended help\n\nisdisjoint(I1::Interval, I2::Interval, [witness]::Bool=false)\n\nAlgorithm\n\nI1  I2 =  iff there is a gap between the left-most point of the second interval and the right-most point of the first interval, or vice-versa.\n\nA witness is computed by taking the maximum over the left-most points of each interval, which is guaranteed to belong to the intersection.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/Interval/#LazySets.API.minkowski_difference-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-sets-Interval","page":"Interval","title":"LazySets.API.minkowski_difference","text":"minkowski_difference(X::LazySet, Y::LazySet)\n\nCompute the Minkowski difference of two sets.\n\nInput\n\nX – set\nY – set\n\nOutput\n\nA set representing the Minkowski difference X  Y.\n\nNotes\n\nThe Minkowski difference of two sets X and Y is defined as\n\n    X  Y = z mid z  Y  X\n\nThe convenience alias pontryagin_difference is also available.\n\nThere is some inconsistency in the literature regarding the naming conventions. In this library, both Minkowski difference and Pontryagin difference refer to the geometric difference of two sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.API.minkowski_difference-Tuple{Interval, Interval}","page":"Interval","title":"LazySets.API.minkowski_difference","text":"Extended help\n\nminkowski_difference(I1::Interval, I2::Interval)\n\nOutput\n\nAn Interval, or an EmptySet if the difference is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.plot_recipe-Union{Tuple{Interval{N}}, Tuple{N}, Tuple{Interval{N}, Any}} where N","page":"Interval","title":"LazySets.plot_recipe","text":"plot_recipe(X::Interval{N}, [ε]=zero(N)) where {N}\n\nConvert an interval to a pair (x, y) of points for plotting.\n\nInput\n\nX – interval\nε – (optional, default: 0) ignored, used for dispatch\n\nOutput\n\nA pair (x, y) of two points that can be plotted.\n\nNotes\n\nWe consider the interval as a line segment with y coordinate equal to zero.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#Base.min-Tuple{Interval}","page":"Interval","title":"Base.min","text":"min(X::Interval)\n\nReturn the lower component of an interval.\n\nInput\n\nX – interval\n\nOutput\n\nThe lower (lo) component of the interval (a number).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#Base.max-Tuple{Interval}","page":"Interval","title":"Base.max","text":"max(X::Interval)\n\nReturn the higher or upper component of an interval.\n\nInput\n\nX – interval\n\nOutput\n\nThe higher (hi) component of the interval (a number).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"center\ncenter\ncomplement\nconstraints_list\ncopy(::Type{LazySet})\ndiameter\ndim\nextrema\nextrema\nhigh\nhigh\nisoperationtype\nlow\nlow\nnorm\nradius\nreflect\nvolume\naffine_map\nexponential_map\n∈\npermute\nproject\nscale\nρ\nσ\nconvex_hull\ndistance\nintersection\n≈\nisequivalent\n⊂\n⊆\nminkowski_sum","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"concretize\nconstraints\neltype\neltype\nisoperation\npolyhedron\nrationalize\nsingleton_list\ntosimplehrep\nvertices\nis_interior_point\nsample\n==","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"Inherited from LazySet but does not apply:","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"triangulate\ntriangulate_faces","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"ispolyhedral","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"isbounded\nisboundedtype","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"isempty\nisuniversal","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"order\ntogrep","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"Inherited from AbstractHyperrectangle:","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"generators\ngenmat\ncartesian_product","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"Some additional functionality is available for IntervalArithmetic.Intervals:","category":"page"},{"location":"lib/sets/Interval/#LazySets.fast_interval_pow-Tuple{IntervalArithmetic.Interval, Int64}","page":"Interval","title":"LazySets.fast_interval_pow","text":"fast_interval_pow(a::IntervalArithmetic.Interval, n::Int)\n\nCompute the nth power of an interval without using correct rounding.\n\nInput\n\na – interval (from IntervalArithmetic.jl)\nn – integer\n\nOutput\n\nA non-rigorous approximation of a^n.\n\nNotes\n\nFor a rigorous approximation with correct rounding, use a^n from IntervalArithmetic.jl.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line/#def_Line","page":"Line","title":"Line","text":"","category":"section"},{"location":"lib/sets/Line/#LazySets.LineModule.Line","page":"Line","title":"LazySets.LineModule.Line","text":"Line{N, VN<:AbstractVector{N}} <: AbstractPolyhedron{N}\n\nType that represents a line of the form\n\n    y  ℝ^n y = p + λd λ  ℝ\n\nwhere p is a point on the line and d is its direction vector (not necessarily normalized).\n\nFields\n\np – point on the line\nd – direction\n\nExamples\n\nThere are three constructors. The optional keyword argument normalize (default: false) can be used to normalize the direction of the resulting line to have norm 1 (w.r.t. the Euclidean norm).\n\nThe default constructor takes the fields p and d:\n\nThe line passing through the point -1 2 3 and parallel to the vector 3 0 -1:\n\njulia> Line([-1.0, 2, 3], [3.0, 0, -1])\nLine{Float64, Vector{Float64}}([-1.0, 2.0, 3.0], [3.0, 0.0, -1.0])\n\njulia> Line([-1.0, 2, 3], [3.0, 0, -1]; normalize=true)\nLine{Float64, Vector{Float64}}([-1.0, 2.0, 3.0], [0.9486832980505138, 0.0, -0.31622776601683794])\n\nThe second constructor takes two points, from and to, as keyword\n\narguments, and returns the line through them. See the algorithm section for details.\n\njulia> Line(from=[-1.0, 2, 3], to=[2.0, 2, 2])\nLine{Float64, Vector{Float64}}([-1.0, 2.0, 3.0], [3.0, 0.0, -1.0])\n\nThe third constructor resembles Line2D and only works for two-dimensional\n\nlines. It takes two inputs, a and b, and constructs the line such that a  x = b.\n\njulia> Line([2.0, 0], 1.)\nLine{Float64, Vector{Float64}}([0.5, 0.0], [0.0, 1.0])\n\nAlgorithm\n\nGiven two points p  ℝ^n and q  ℝ^n, the line that passes through these two points is L:{y ∈ ℝ^n: y = p + λ(q - p), λ ∈ ℝ}``.\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Line/#Operations","page":"Line","title":"Operations","text":"","category":"section"},{"location":"lib/sets/Line/#LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}-lib-sets-Line","page":"Line","title":"LazySets.API.constraints_list","text":"constraints_list(X::LazySet)\n\nCompute a list of linear constraints of a polyhedral set.\n\nInput\n\nX – polyhedral set\n\nOutput\n\nA list of the linear constraints of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line/#LazySets.API.constraints_list-Tuple{Line}","page":"Line","title":"LazySets.API.constraints_list","text":"Extended help\n\nconstraints_list(L::Line)\n\nOutput\n\nA list containing 2n-2 half-spaces whose intersection is L, where n is the ambient dimension of L.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line/#LazySets.LineModule.direction-Tuple{Line}","page":"Line","title":"LazySets.LineModule.direction","text":"direction(L::Line)\n\nReturn the direction of the line.\n\nInput\n\nL – line\n\nOutput\n\nThe direction of the line.\n\nNotes\n\nThe direction is not necessarily normalized. See normalize(::Line, ::Real) / normalize!(::Line, ::Real).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line/#LazySets.API.isuniversal-Tuple{LazySets.API.LazySet}-lib-sets-Line","page":"Line","title":"LazySets.API.isuniversal","text":"isuniversal(X::LazySet, witness::Bool=false)\n\nCheck whether a set is universal.\n\nInput\n\nX       – set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf the witness option is deactivated: true iff X = ℝ^n\nIf the witness option is activated:\n(true, []) iff X = ℝ^n\n(false, v) iff X  ℝ^n for some v  X\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line/#LazySets.API.isuniversal-Tuple{Line}","page":"Line","title":"LazySets.API.isuniversal","text":"Extended help\n\nisuniversal(L::Line; [witness::Bool]=false)\n\nAlgorithm\n\nIf witness is false, the result is true if the ambient dimension is one,\n\nand false otherwise.\n\nIf witness is true, the result is (true, []) if the ambient dimension is\n\none, and (false, v) where v  P otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line/#LinearAlgebra.normalize-Union{Tuple{Line{N, VN} where VN<:AbstractVector{N}}, Tuple{N}, Tuple{Line{N, VN} where VN<:AbstractVector{N}, Real}} where N","page":"Line","title":"LinearAlgebra.normalize","text":"normalize(L::Line{N}, p::Real=N(2)) where {N}\n\nNormalize the direction of a line.\n\nInput\n\nL – line\np – (optional, default: 2.0) vector p-norm used in the normalization\n\nOutput\n\nA line whose direction has unit norm w.r.t. the given p-norm.\n\nNotes\n\nSee also normalize!(::Line, ::Real) for the in-place version.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line/#LinearAlgebra.normalize!-Union{Tuple{Line{N, VN} where VN<:AbstractVector{N}}, Tuple{N}, Tuple{Line{N, VN} where VN<:AbstractVector{N}, Real}} where N","page":"Line","title":"LinearAlgebra.normalize!","text":"normalize!(L::Line{N}, p::Real=N(2)) where {N}\n\nNormalize the direction of a line storing the result in L.\n\nInput\n\nL – line\np – (optional, default: 2.0) vector p-norm used in the normalization\n\nOutput\n\nA line whose direction has unit norm w.r.t. the given p-norm.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line/#Base.rand-Tuple{Type{LazySets.API.LazySet}}-lib-sets-Line","page":"Line","title":"Base.rand","text":"rand(T::Type{<:LazySet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random set of the given set type.\n\nInput\n\nT    – set type\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random set of the given set type.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line/#Base.rand-Tuple{Type{Line}}","page":"Line","title":"Base.rand","text":"Extended help\n\nrand(::Type{Line}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line/#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-sets-Line","page":"Line","title":"Base.:∈","text":"∈(x::AbstractVector, X::LazySet)\n\nCheck whether a point lies in a set.\n\nInput\n\nx – point/vector\nX – set\n\nOutput\n\ntrue iff x  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line/#Base.:∈-Tuple{AbstractVector, Line}","page":"Line","title":"Base.:∈","text":"Extended help\n\n∈(x::AbstractVector, L::Line)\n\nAlgorithm\n\nThe point x belongs to the line L  p + λd if and only if x - p is proportional to the direction d.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line/#LazySets.API.linear_map-Tuple{AbstractMatrix, LazySets.API.LazySet}-lib-sets-Line","page":"Line","title":"LazySets.API.linear_map","text":"linear_map(M::AbstractMatrix, X::LazySet)\n\nCompute the linear map M  X.\n\nInput\n\nM – matrix\nX – set\n\nOutput\n\nA set representing the linear map M  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line/#LazySets.API.linear_map-Tuple{AbstractMatrix, Line}","page":"Line","title":"LazySets.API.linear_map","text":"Extended help\n\nlinear_map(M::AbstractMatrix, L::Line)\n\nOutput\n\nThe line obtained by applying the linear map, if that still results in a line, or a Singleton otherwise.\n\nAlgorithm\n\nWe apply the linear map to the point and direction of L. If the resulting direction is zero, the result is a singleton.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line/","page":"Line","title":"Line","text":"Undocumented implementations:","category":"page"},{"location":"lib/sets/Line/","page":"Line","title":"Line","text":"an_element\ndim\nisbounded\nisempty\nisoperationtype\ndistance\nproject\nρ\nσ\ntranslate!","category":"page"},{"location":"lib/sets/Line/","page":"Line","title":"Line","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Line/","page":"Line","title":"Line","text":"area\nchebyshev_center_radius\ncomplement\nconcretize\nconstraints\nconvex_hull\ncopy(::Type{LazySet})\ndiameter\neltype\neltype\nisboundedtype\nisoperation\nnorm\npolyhedron\nradius\nrationalize\nrectify\nreflect\nsingleton_list\ntosimplehrep\ntriangulate\ntriangulate_faces\nvertices\naffine_map\nexponential_map\nis_interior_point\nsample\nscale\ntranslate\ncartesian_product\nconvex_hull\nexact_sum\n≈\n==\nisequivalent\n⊂\nminkowski_difference","category":"page"},{"location":"lib/sets/Line/","page":"Line","title":"Line","text":"Inherited from ConvexSet:","category":"page"},{"location":"lib/sets/Line/","page":"Line","title":"Line","text":"isconvextype\nlinear_combination","category":"page"},{"location":"lib/sets/Line/","page":"Line","title":"Line","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/Line/","page":"Line","title":"Line","text":"extrema\nextrema\nhigh\nhigh\nispolyhedral\nlow\nlow\nvertices_list\nintersection\nisdisjoint\n⊆\nminkowski_sum","category":"page"},{"location":"man/unary_set_operations/#Unary-operations-on-sets","page":"Unary Operations on Sets","title":"Unary operations on sets","text":"","category":"section"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"In this section we show which typical set operations this library supports.","category":"page"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"Pages = [\"unary_set_operations.md\"]\nDepth = 3","category":"page"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"The following table lists all operations that take one set as argument in the columns. In the rows we list all set types, both the interfaces (where we abbreviate the Abstract prefix), the basic set types, and the lazy set operations, each sorted alphabetically. The table entries have the following meaning.","category":"page"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"\"x\" indicates that the operation is implemented for the respective set type.\n\"i\" indicates that the operation is inherited from a supertype.\n\"(·)\" indicates that the operation is partly implemented/inherited.","category":"page"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"type ↓ \\ operation → dim ρ σ an_element ∈ isempty isbounded linear_map translate norm radius diameter\nInterfaces            \nLazySet  x  x   x     x\nAPolytope  i  i  x x x    i\nACentrallySymmetric x i  x  x x     i\nACentrallySymmetricPolytope i i  i  x i i    i\nAPolygon x i  i  i i i    i\nAHyperrectangle i i x i x i i i  x x i\nAHPolygon i i  x x i i i    i\nASingleton i i x i x i i x  i i i\n            \nBasic set types            \nBall1 i i x i x i i i x   i\nBall2 i i x i x i i  x   i\nBallInf i i i i i i i i x i x i\nBallp i i x i x i i  x   i\nEllipsoid i x x i x i i  x   i\nEmptySet x i x x x x x  x x x x\nHalfSpace x x x x x x x  x   i\nHPolygon/HPolygonOpt i i x i i i i i x   i\nHPolyhedron x x x i x x x x x   i\nHPolytope x x x i x x i x x   i\nHyperplane x x x x x x x  x   i\nHyperrectangle i i i i i i i i x i i i\nInterval x i x x x i i i x i i i\nLine2D x i x x x x x  x   i\nLineSegment x i x x x i i i x   i\nSingleton i i i i i i i i x i i i\nUniverse x x x x x x x  x x x x\nVPolygon i i x x x i i x x   i\nVPolytope x i x i x i i x x   i\nZeroSet x i x i x i i x x i i i\nZonotope i x x i x i i x x   i\n            \nLazy set operation types            \nCartesianProduct x x x i x x x     i\nCartesianProductArray x x x i x x x     i\nConvexHull x x x i  x x     i\nConvexHullArray x x x i  x x     i\nExponentialMap x x x i x x x     i\nExponentialProjectionMap x i x i  x x     i\nIntersection x x  i x x x     i\nIntersectionArray x i  i x  x     i\nLinearMap x x x x x x x     i\nMinkowskiSum x x x i  x x     i\nMinkowskiSumArray x x x i  x x     i\nCachedMinkowskiSumArray x i x i  x x     i\nResetMap x x x x  x      i\nSymmetricIntervalHull x i x i i i i i  i i i\nTranslation x x x x x x  x    i\n            \nNon-convex operations            \nComplement x    x x      \nRectification x i (x) x x x x     \nUnionSet x x x x x x x     \nUnionSetArray x x x x x x x     ","category":"page"},{"location":"man/unary_set_operations/#Examples","page":"Unary Operations on Sets","title":"Examples","text":"","category":"section"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"We use the following four sets for illustration.","category":"page"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"using LazySets, LazySets.Approximations, Plots\nB1 = Ball1(-ones(2), 1.)\nB2 = Ball2(ones(2), 1.)\nBI = BallInf(zeros(2), 1.)\nH = Hyperrectangle(ones(2), ones(2))\nsets = [B1, B2, BI, H]\n\nfunction plot_sets(sets)\n    for S in sets\n        println(S)\n        plot!(S, 1e-2, fillalpha=0.1)\n    end\nend\n\nfunction plot_points(points, prefix)\n    for i in eachindex(points)\n        p = points[i]\n        num_occur = length(findfirst(x -> x == p, points[1:i]))\n        x = p[1]\n        y = p[2]\n        if num_occur == 1\n            x += 0.15\n        elseif num_occur == 2\n            y += 0.15\n        elseif num_occur == 3\n            x -= 0.15\n        else\n            y -= 0.15\n        end\n        plot!(Singleton(p))\n        plot!(annotations=(x, y, text(\"$(prefix)$(i)\")))\n    end\nend\n\nplot1 = plot()\nplot_sets(sets)\nplot1","category":"page"},{"location":"man/unary_set_operations/#dim","page":"Unary Operations on Sets","title":"dim","text":"","category":"section"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"This function returns the dimension of the set.","category":"page"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"dim(B1), dim(B2), dim(BI), dim(H)","category":"page"},{"location":"man/unary_set_operations/#ρ/σ","page":"Unary Operations on Sets","title":"ρ/σ","text":"","category":"section"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"These functions return the support function resp. the support vector of the set.","category":"page"},{"location":"man/unary_set_operations/#an_element","page":"Unary Operations on Sets","title":"an_element","text":"","category":"section"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"This function returns some element in the set. Consecutive calls to this function typically return the same element.","category":"page"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"an_element(B1), an_element(B2), an_element(BI), an_element(H)","category":"page"},{"location":"man/unary_set_operations/#","page":"Unary Operations on Sets","title":"∈","text":"","category":"section"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"This function checks containment of a given vector in the set. The operator can be used in infix notation (v ∈ S) and in inverse operand order (S ∋ v). Alias: in","category":"page"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"p1 = [1.5, 1.5]\np2 = [0.1, 0.1]\np3 = [-0.9, -0.8]\npoints = [p1, p2, p3]\n\nfor p in [p1, p2, p3]\n    println(\"$p ∈ (B1, B2, BI, H)? ($(p ∈ B1), $(p ∈ B2), $(p ∈ BI), $(p ∈ H))\")\nend","category":"page"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"plot1 = plot()\nplot_sets(sets)\nplot_points(points, \"p\")\nplot1","category":"page"},{"location":"man/unary_set_operations/#isempty","page":"Unary Operations on Sets","title":"isempty","text":"","category":"section"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"This function checks if the set is empty.","category":"page"},{"location":"man/unary_set_operations/#linear_map","page":"Unary Operations on Sets","title":"linear_map","text":"","category":"section"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"This function applies a concrete linear map to the set. The resulting set may be of a different type.","category":"page"},{"location":"man/unary_set_operations/#norm","page":"Unary Operations on Sets","title":"norm","text":"","category":"section"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"This function returns the norm of a set. It is defined as the norm of the enclosing ball (of the given norm) of minimal volume centered in the origin.","category":"page"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"# print 1-norm, 2-norm, and infinity norm (if available)\nprintln((\"-\", \"-\", norm(B1, Inf)))\nprintln((\"-\", \"-\", norm(B2, Inf)))\nprintln((norm(BI, 1), norm(BI, 2), norm(BI, Inf)))\nprintln((norm(H, 1), norm(H, 2), norm(H, Inf)))","category":"page"},{"location":"man/unary_set_operations/#radius","page":"Unary Operations on Sets","title":"radius","text":"","category":"section"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"This function returns the radius of a set. It is defined as the radius of the enclosing ball (of the given norm) of minimal volume with the same center.","category":"page"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"radius(B1), radius(B2), radius(BI), radius(H)","category":"page"},{"location":"man/unary_set_operations/#diameter","page":"Unary Operations on Sets","title":"diameter","text":"","category":"section"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"This function returns the diameter of a set. It is defined as the diameter of the enclosing ball (of the given norm) of minimal volume with the same center. The implementation is inherited for all set types if the norm is the infinity norm, in which case the result is defined as twice the radius.","category":"page"},{"location":"man/unary_set_operations/","page":"Unary Operations on Sets","title":"Unary Operations on Sets","text":"diameter(B1), diameter(B2), diameter(BI), diameter(H)","category":"page"}]
}
