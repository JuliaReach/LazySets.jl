<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Polyhedra (AbstractPolyhedron) · LazySets.jl</title><meta name="title" content="Polyhedra (AbstractPolyhedron) · LazySets.jl"/><meta property="og:title" content="Polyhedra (AbstractPolyhedron) · LazySets.jl"/><meta property="twitter:title" content="Polyhedra (AbstractPolyhedron) · LazySets.jl"/><meta name="description" content="Documentation for LazySets.jl."/><meta property="og:description" content="Documentation for LazySets.jl."/><meta property="twitter:description" content="Documentation for LazySets.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/aligned.css" rel="stylesheet" type="text/css"/><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">LazySets.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../../man/optional_dependencies/">Optional Features</a></li><li><a class="tocitem" href="../../../man/tour/">A Tour of LazySets</a></li><li><a class="tocitem" href="../../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../../man/unary_set_operations/">Unary Operations on Sets</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../API/">API</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox" checked/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Set Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../LazySet/">General sets (LazySet)</a></li><li><a class="tocitem" href="../ConvexSet/">Convex sets (ConvexSet)</a></li><li><a class="tocitem" href="../AbstractCentrallySymmetric/">Centrally symmetric sets (AbstractCentrallySymmetric)</a></li><li class="is-active"><a class="tocitem" href>Polyhedra (AbstractPolyhedron)</a><ul class="internal"><li><a class="tocitem" href="#Implementations"><span>Implementations</span></a></li></ul></li><li><a class="tocitem" href="../AbstractPolytope/">Polytopes (AbstractPolytope)</a></li><li><a class="tocitem" href="../AbstractPolygon/">Polygons (AbstractPolygon)</a></li><li><a class="tocitem" href="../AbstractHPolygon/">Polygons in constraint representation (AbstractHPolygon)</a></li><li><a class="tocitem" href="../AbstractCentrallySymmetricPolytope/">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a></li><li><a class="tocitem" href="../AbstractZonotope/">Zonotopes (AbstractZonotope)</a></li><li><a class="tocitem" href="../AbstractHyperrectangle/">Hyperrectangles (AbstractHyperrectangle)</a></li><li><a class="tocitem" href="../AbstractSingleton/">Singletons (AbstractSingleton)</a></li><li><a class="tocitem" href="../AbstractAffineMap/">Affine maps (AbstractAffineMap)</a></li><li><a class="tocitem" href="../AbstractPolynomialZonotope/">Polynomial zonotope sets (AbstractPolynomialZonotope)</a></li><li><a class="tocitem" href="../AbstractSparsePolynomialZonotope/">Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)</a></li><li><a class="tocitem" href="../AbstractBallp/">Balls in the p-norm (AbstractBallp)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../../sets/DensePolynomialZonotope/">DensePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../../sets/HParallelotope/">HParallelotope</a></li><li><a class="tocitem" href="../../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../../sets/Line/">Line</a></li><li><a class="tocitem" href="../../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../../sets/Polygon/">Polygon</a></li><li><a class="tocitem" href="../../sets/SimpleSparsePolynomialZonotope/">SimpleSparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/SparsePolynomialZonotope/">SparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../../sets/Star/">Star</a></li><li><a class="tocitem" href="../../sets/Tetrahedron/">Tetrahedron</a></li><li><a class="tocitem" href="../../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../../sets/Zonotope/">Zonotope</a></li><li><a class="tocitem" href="../../sets/ZonotopeMD/">ZonotopeMD</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lazy_operations/AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../../lazy_operations/Bloating/">Bloating</a></li><li><a class="tocitem" href="../../lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../../lazy_operations/Complement/">Complement</a></li><li><a class="tocitem" href="../../lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../../lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../../lazy_operations/Intersection/">Intersection</a></li><li><a class="tocitem" href="../../lazy_operations/LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../../lazy_operations/InverseLinearMap/">InverseLinearMap</a></li><li><a class="tocitem" href="../../lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../../lazy_operations/QuadraticMap/">QuadraticMap</a></li><li><a class="tocitem" href="../../lazy_operations/Rectification/">Rectification</a></li><li><a class="tocitem" href="../../lazy_operations/ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../../lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../../lazy_operations/Translation/">Translation</a></li><li><a class="tocitem" href="../../lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Concrete Binary Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../concrete_binary_operations/overview/">Binary set operations</a></li><li><a class="tocitem" href="../../concrete_binary_operations/cartesian_product/">Cartesian Product</a></li><li><a class="tocitem" href="../../concrete_binary_operations/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../concrete_binary_operations/difference/">Set difference</a></li><li><a class="tocitem" href="../../concrete_binary_operations/distance/">Distance</a></li><li><a class="tocitem" href="../../concrete_binary_operations/intersection/">Intersection of two sets</a></li><li><a class="tocitem" href="../../concrete_binary_operations/minkowski_sum/">Minkowski Sum</a></li><li><a class="tocitem" href="../../concrete_binary_operations/minkowski_difference/">Minkowski Difference</a></li><li><a class="tocitem" href="../../concrete_binary_operations/isdisjoint/">Check for Disjointness of Sets</a></li><li><a class="tocitem" href="../../concrete_binary_operations/issubset/">Subset Check</a></li></ul></li><li><a class="tocitem" href="../../conversion/">Conversions between set representations</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Approximations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../approximations/overview/">Overview</a></li><li><a class="tocitem" href="../../approximations/overapproximate/">Overapproximation</a></li><li><a class="tocitem" href="../../approximations/box_approximation/">Box Approximation</a></li><li><a class="tocitem" href="../../approximations/iterative_refinement/">Iterative refinement</a></li><li><a class="tocitem" href="../../approximations/template_directions/">Template directions</a></li><li><a class="tocitem" href="../../approximations/underapproximate/">Underapproximation</a></li><li><a class="tocitem" href="../../approximations/approximate/">Approximation</a></li><li><a class="tocitem" href="../../approximations/decompose/">Cartesian Decomposition</a></li><li><a class="tocitem" href="../../approximations/hausdorff_distance/">Hausdorff Distance</a></li></ul></li><li><a class="tocitem" href="../../utils/">Utilities</a></li><li><a class="tocitem" href="../../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li><a class="is-disabled">Set Interfaces</a></li><li class="is-active"><a href>Polyhedra (AbstractPolyhedron)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Polyhedra (AbstractPolyhedron)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/interfaces/AbstractPolyhedron.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#def_AbstractPolyhedron">Polyhedra (AbstractPolyhedron)</a></li><li class="no-marker"><ul><li><a href="#Implementations">Implementations</a></li></ul></li></ul><h1 id="def_AbstractPolyhedron"><a class="docs-heading-anchor" href="#def_AbstractPolyhedron">Polyhedra (AbstractPolyhedron)</a><a id="def_AbstractPolyhedron-1"></a><a class="docs-heading-anchor-permalink" href="#def_AbstractPolyhedron" title="Permalink"></a></h1><p>A polyhedron has finitely many facets (<em>H-representation</em>) and is not necessarily bounded.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.AbstractPolyhedron" href="#LazySets.AbstractPolyhedron"><code>LazySets.AbstractPolyhedron</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractPolyhedron{N} &lt;: ConvexSet{N}</code></pre><p>Abstract type for closed convex polyhedral sets.</p><p><strong>Notes</strong></p><p>See <a href="../../sets/HPolyhedron/#LazySets.HPolyhedronModule.HPolyhedron"><code>HPolyhedron</code></a> for a standard implementation of this interface.</p><p>Every concrete <code>AbstractPolyhedron</code> must define the following functions:</p><ul><li><code>constraints_list(::AbstractPolyhedron)</code> – return a list of all facet constraints</li></ul><p>Polyhedra are defined as the intersection of a finite number of closed half-spaces. As such, polyhedra are closed and convex but not necessarily bounded. Bounded polyhedra are called <em>polytopes</em> (see <a href="../AbstractPolytope/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>).</p><p>The subtypes of <code>AbstractPolyhedron</code> (including abstract interfaces):</p><pre><code class="language-julia-repl hljs">julia&gt; subtypes(AbstractPolyhedron)
8-element Vector{Any}:
 AbstractPolytope
 HPolyhedron
 HalfSpace
 Hyperplane
 Line
 Line2D
 Star
 Universe</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bbf2d11db4e4525b89ea0fa9f12b827e6dbd1737/src/Interfaces/AbstractPolyhedron.jl#L3-L35">source</a></section></article><p>This interface requires to implement the following function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractPolyhedron" href="#LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractPolyhedron"><code>LazySets.API.constraints_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">constraints_list(X::LazySet)</code></pre><p>Compute a list of linear constraints of a polyhedral set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – polyhedral set</li></ul><p><strong>Output</strong></p><p>A list of the linear constraints of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bbf2d11db4e4525b89ea0fa9f12b827e6dbd1737/src/API/Unary/constraints_list.jl#L1-L13">source</a></section></article><p>This interface defines the following functions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.an_element-Tuple{AbstractPolyhedron}" href="#LazySets.API.an_element-Tuple{AbstractPolyhedron}"><code>LazySets.API.an_element</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">an_element(P::AbstractPolyhedron; [solver]=default_lp_solver(eltype(P)))</code></pre><p>Return some element of a polyhedron.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polyhedron</li><li><code>solver</code>  – (optional, default: <code>default_lp_solver(N)</code>) LP solver</li></ul><p><strong>Output</strong></p><p>An element of the polyhedron, or an error if the polyhedron is empty.</p><p><strong>Algorithm</strong></p><p>An element is obtained by solving a feasibility linear program.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bbf2d11db4e4525b89ea0fa9f12b827e6dbd1737/src/Interfaces/AbstractPolyhedron_functions.jl#L625-L642">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.constrained_dimensions-Tuple{AbstractPolyhedron}" href="#LazySets.constrained_dimensions-Tuple{AbstractPolyhedron}"><code>LazySets.constrained_dimensions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">constrained_dimensions(P::AbstractPolyhedron)</code></pre><p>Return the indices in which a polyhedron is constrained.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polyhedron</li></ul><p><strong>Output</strong></p><p>A vector of ascending indices <code>i</code> such that the polyhedron is constrained in dimension <code>i</code>.</p><p><strong>Examples</strong></p><p>A 2D polyhedron with constraint <span>$x1 ≥ 0$</span> is constrained in dimension 1 only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bbf2d11db4e4525b89ea0fa9f12b827e6dbd1737/src/Interfaces/AbstractPolyhedron.jl#L41-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isbounded-Tuple{AbstractPolyhedron}" href="#LazySets.API.isbounded-Tuple{AbstractPolyhedron}"><code>LazySets.API.isbounded</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isbounded(P::AbstractPolyhedron; [solver]=default_lp_solver(eltype(P)))</code></pre><p>Check whether a polyhedron is bounded.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polyhedron</li><li><code>solver</code>  – (optional, default: <code>default_lp_solver(N)</code>) the backend used              to solve the linear program</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the polyhedron is bounded</p><p><strong>Algorithm</strong></p><p>We first check if the polyhedron has more than <code>dim(P)</code> constraints, which is a necessary condition for boundedness.</p><p>If so, we check boundedness via <code>_isbounded_stiemke</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bbf2d11db4e4525b89ea0fa9f12b827e6dbd1737/src/Interfaces/AbstractPolyhedron_functions.jl#L661-L682">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isuniversal-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractPolyhedron" href="#LazySets.API.isuniversal-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractPolyhedron"><code>LazySets.API.isuniversal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isuniversal(X::LazySet, witness::Bool=false)</code></pre><p>Check whether a set is universal.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If the <code>witness</code> option is deactivated: <code>true</code> iff <span>$X = ℝ^n$</span></li><li>If the <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X = ℝ^n$</span></li><li><code>(false, v)</code> iff <span>$X ≠ ℝ^n$</span> for some <span>$v ∉ X$</span></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bbf2d11db4e4525b89ea0fa9f12b827e6dbd1737/src/API/Unary/isuniversal.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isuniversal" href="#LazySets.API.isuniversal"><code>LazySets.API.isuniversal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">isuniversal(P::AbstractPolyhedron, [witness]::Bool=false)</code></pre><p><strong>Algorithm</strong></p><p><code>P</code> is universal iff it has no constraints.</p><p>A witness is produced using <code>isuniversal(H)</code> where <code>H</code> is the first linear constraint of <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bbf2d11db4e4525b89ea0fa9f12b827e6dbd1737/src/Interfaces/AbstractPolyhedron_functions.jl#L30-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.vertices_list-Tuple{AbstractPolyhedron}" href="#LazySets.API.vertices_list-Tuple{AbstractPolyhedron}"><code>LazySets.API.vertices_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertices_list(P::AbstractPolyhedron; check_boundedness::Bool=true)</code></pre><p>Return the list of vertices of a polyhedron in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>                 – polyhedron in constraint representation</li><li><code>check_boundedness</code> – (optional, default: <code>true</code>) if <code>true</code>, check whether                        the polyhedron is bounded</li></ul><p><strong>Output</strong></p><p>The list of vertices of <code>P</code>, or an error if <code>P</code> is unbounded.</p><p><strong>Notes</strong></p><p>This function throws an error if the polyhedron is unbounded. Otherwise, the polyhedron is converted to an <code>HPolytope</code> and its list of vertices is computed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = HPolyhedron([HalfSpace([1.0, 0.0], 1.0),
                        HalfSpace([0.0, 1.0], 1.0),
                        HalfSpace([-1.0, 0.0], 1.0),
                        HalfSpace([0.0, -1.0], 1.0)]);

julia&gt; length(vertices_list(P))
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bbf2d11db4e4525b89ea0fa9f12b827e6dbd1737/src/Interfaces/AbstractPolyhedron_functions.jl#L757-L788">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractPolyhedron" href="#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractPolyhedron"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∈(x::AbstractVector, X::LazySet)</code></pre><p>Check whether a point lies in a set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bbf2d11db4e4525b89ea0fa9f12b827e6dbd1737/src/API/Mixed/in.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:∈-Tuple{AbstractVector, AbstractPolyhedron}" href="#Base.:∈-Tuple{AbstractVector, AbstractPolyhedron}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">∈(x::AbstractVector, P::AbstractPolyhedron)</code></pre><p><strong>Algorithm</strong></p><p>This implementation checks if the point lies inside each defining half-space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bbf2d11db4e4525b89ea0fa9f12b827e6dbd1737/src/Interfaces/AbstractPolyhedron_functions.jl#L9-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.project-Tuple{AbstractPolyhedron, AbstractVector{Int64}}" href="#LazySets.API.project-Tuple{AbstractPolyhedron, AbstractVector{Int64}}"><code>LazySets.API.project</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">project(P::AbstractPolyhedron, block::AbstractVector{Int}; [kwargs...])</code></pre><p>Concrete projection of a polyhedral set.</p><p><strong>Input</strong></p><ul><li><code>P</code>     – set</li><li><code>block</code> – block structure, a vector with the dimensions of interest</li></ul><p><strong>Output</strong></p><p>A polyhedron representing the projection of <code>P</code> on the dimensions specified by <code>block</code>. If <code>P</code> was bounded, the result is an <code>HPolytope</code>; otherwise the result is an <code>HPolyhedron</code>. Note that there are more specific methods for specific input types, which give a different output type; e.g., projecting a <code>Ball1</code> results in a <code>Ball1</code>.</p><p><strong>Algorithm</strong></p><ul><li>We first try to exploit the special case where each of the constraints of <code>P</code> and <code>block</code> are <em>compatible</em>, which is one of the two cases described below. Let <code>c</code> be a constraint of <code>P</code> and let <span>$D_c$</span> and <span>$D_b$</span> be the set of dimensions in which <code>c</code> resp. <code>block</code> are constrained.<ul><li>If <span>$D_c ⊆ D_b$</span>, then one can project the normal vector of <code>c</code>.</li><li>If <span>$D_c ∩ D_b = ∅$</span>, then the constraint becomes redundant.</li></ul></li><li>In the general case, we compute the concrete linear map of the projection matrix associated to the given block structure.</li></ul><p><strong>Examples</strong></p><p>Consider the four-dimensional cross-polytope (unit ball in the 1-norm):</p><pre><code class="language-julia-repl hljs">julia&gt; P = convert(HPolytope, Ball1(zeros(4), 1.0));</code></pre><p>All dimensions are constrained, and computing the (trivial) projection on the whole space behaves as expected:</p><pre><code class="language-julia-repl hljs">julia&gt; constrained_dimensions(P)
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; project(P, [1, 2, 3, 4]) == P
true</code></pre><p>Each constraint of the cross polytope is constrained in all dimensions.</p><p>Now let us take a ball in the infinity norm and remove some constraints:</p><pre><code class="language-julia-repl hljs">julia&gt; B = BallInf(zeros(4), 1.0);

julia&gt; c = constraints_list(B)[1:2]
2-element Vector{HalfSpace{Float64, ReachabilityBase.Arrays.SingleEntryVector{Float64}}}:
 HalfSpace{Float64, ReachabilityBase.Arrays.SingleEntryVector{Float64}}([1.0, 0.0, 0.0, 0.0], 1.0)
 HalfSpace{Float64, ReachabilityBase.Arrays.SingleEntryVector{Float64}}([0.0, 1.0, 0.0, 0.0], 1.0)

julia&gt; P = HPolyhedron(c);

julia&gt; constrained_dimensions(P)
2-element Vector{Int64}:
 1
 2</code></pre><p>Finally, we take the concrete projection onto variables <code>1</code> and <code>2</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; project(P, [1, 2]) |&gt; constraints_list
2-element Vector{HalfSpace{Float64, Vector{Float64}}}:
 HalfSpace{Float64, Vector{Float64}}([1.0, 0.0], 1.0)
 HalfSpace{Float64, Vector{Float64}}([0.0, 1.0], 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bbf2d11db4e4525b89ea0fa9f12b827e6dbd1737/src/Interfaces/AbstractPolyhedron_functions.jl#L797-L877">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.intersection-Union{Tuple{N}, Tuple{AbstractPolyhedron{N}, AbstractPolyhedron{N}}} where N" href="#LazySets.API.intersection-Union{Tuple{N}, Tuple{AbstractPolyhedron{N}, AbstractPolyhedron{N}}} where N"><code>LazySets.API.intersection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intersection(P1::AbstractPolyhedron{N}, P2::AbstractPolyhedron{N};
             [backend]=default_lp_solver(N), [prune]::Bool=true) where {N}</code></pre><p>Compute the intersection of two polyhedra.</p><p><strong>Input</strong></p><ul><li><code>P1</code>      – polyhedron</li><li><code>P2</code>      – polyhedron</li><li><code>backend</code> – (optional, default: <code>default_lp_solver(N)</code>) the LP solver used              for the removal of redundant constraints; see the <em>Notes</em> section              below for details</li><li><code>prune</code>   – (optional, default: <code>true</code>) flag for removing redundant              constraints</li></ul><p><strong>Output</strong></p><p>An <code>HPolyhedron</code> resulting from the intersection of <code>P1</code> and <code>P2</code>, with the redundant constraints removed, or an empty set if the intersection is empty. If one of the arguments is a polytope, the result is an <code>HPolytope</code> instead.</p><p><strong>Notes</strong></p><p>The default value of the solver backend is <code>default_lp_solver(N)</code> and it is used to run a feasiblity LP to remove the redundant constraints of the intersection.</p><p>If you want to use the <code>Polyhedra</code> library, pass an appropriate backend. For example, use <code>default_polyhedra_backend(P)</code> for the default Polyhedra library, or use <code>CDDLib.Library()</code> for the CDD library.</p><p>There are some shortcomings of the removal of constraints using the default Polyhedra library; see e.g. #1038 and Polyhedra#146. It is safer to check for emptiness of intersection before calling this function in those cases.</p><p><strong>Algorithm</strong></p><p>This implementation unifies the constraints of the two sets obtained from the <code>constraints_list</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bbf2d11db4e4525b89ea0fa9f12b827e6dbd1737/src/ConcreteOperations/intersection.jl#L409-L448">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.minkowski_sum-Tuple{AbstractPolyhedron, AbstractPolyhedron}" href="#LazySets.API.minkowski_sum-Tuple{AbstractPolyhedron, AbstractPolyhedron}"><code>LazySets.API.minkowski_sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minkowski_sum(P::AbstractPolyhedron, Q::AbstractPolyhedron;
              [backend]=nothing, [algorithm]=nothing, [prune]=true)</code></pre><p>Compute the Minkowski sum of two polyhedra in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>         – polyhedron in constraint representation</li><li><code>Q</code>         – polyhedron in constraint representation</li><li><code>backend</code>   – (optional, default: <code>nothing</code>) polyhedral computations backend</li><li><code>algorithm</code> – (optional, default: <code>nothing</code>) algorithm to eliminate                variables; available options are <code>Polyhedra.FourierMotzkin</code>,                <code>Polyhedra.BlockElimination</code>, and <code>Polyhedra.ProjectGenerators</code></li><li><code>prune</code>     – (optional, default: <code>true</code>) if <code>true</code>, apply a post-processing                to remove redundant constraints</li></ul><p><strong>Output</strong></p><p>A polyhedron in H-representation that corresponds to the Minkowski sum of <code>P</code> and <code>Q</code>.</p><p><strong>Algorithm</strong></p><p>This function implements the concrete Minkowski sum by projection and variable elimination as detailed in <a href="../../../bibliography/#Kvasnica05">Kvasnica [Kva05]</a>. The idea is that if we write <span>$P$</span> and <span>$Q$</span> in <em>simple H-representation</em>, that is, <span>$P = \{x ∈ ℝ^n : Ax ≤ b \}$</span> and <span>$Q = \{x ∈ ℝ^n : Cx ≤ d \}$</span>, then their Minkowski sum can be seen as the projection onto the first <span>$n$</span>-dimensional coordinates of the polyhedron:</p><p class="math-container">\[    \begin{pmatrix} 0 &amp; A \ C &amp; -C \end{pmatrix} \binom{x}{y} ≤ \binom{b}{d}\]</p><p>This is seen by noting that <span>$P ⊕ Q$</span> corresponds to the set of points <span>$x ∈ ℝ^n$</span> such that <span>$x = y + z$</span> with <span>$Ay ≤ b$</span> and <span>$Cz ≤ d$</span>; hence it follows that <span>$Ay ≤ b$</span> and <span>$C(x-y) ≤ d$</span>, and the inequality above follows by considering the <span>$2n$</span>-dimensional space <span>$\binom{x}{y}$</span>. The reduction from <span>$2n$</span> to <span>$n$</span> variables is performed using an elimination algorithm as described next.</p><p>The elimination of variables depends on the polyhedra library <code>Polyhedra</code>, which itself uses <code>CDDLib</code> for variable elimination. The available algorithms are:</p><ul><li><p><code>Polyhedra.FourierMotzkin</code>    – projection by computing the H-representation                                  and applying the Fourier-Motzkin elimination                                  algorithm to it</p></li><li><p><code>Polyhedra.BlockElimination</code>  – projection by computing the H-representation                                  and applying the block elimination algorithm                                  to it</p></li><li><p><code>Polyhedra.ProjectGenerators</code> – projection by computing the V-representation</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bbf2d11db4e4525b89ea0fa9f12b827e6dbd1737/src/ConcreteOperations/minkowski_sum.jl#L54-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets._isbounded_stiemke" href="#LazySets._isbounded_stiemke"><code>LazySets._isbounded_stiemke</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_isbounded_stiemke(constraints::AbstractVector{&lt;:HalfSpace{N}};
                   solver=default_lp_solver(N),
                   check_nonempty::Bool=true) where {N}</code></pre><p>Check whether a list of constraints is bounded using Stiemke&#39;s theorem of alternatives.</p><p><strong>Input</strong></p><ul><li><code>constraints</code>    – list of constraints</li><li><code>backend</code>        – (optional, default: <code>default_lp_solver(N)</code>) the backend                     used to solve the linear program</li><li><code>check_nonempty</code> – (optional, default: <code>true</code>) if <code>true</code>, check the                     precondition to this algorithm that <code>P</code> is non-empty</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the list of constraints is bounded.</p><p><strong>Notes</strong></p><p>The list of constraints represents a polyhedron.</p><p>The algorithm calls <code>isempty</code> to check whether the polyhedron is empty. This computation can be avoided using the <code>check_nonempty</code> flag.</p><p><strong>Algorithm</strong></p><p>The algorithm is based on Stiemke&#39;s theorem of alternatives, see, e.g., <a href="../../../bibliography/#Mangasarian94">Mangasarian [Man94]</a>.</p><p>Let the polyhedron <span>$P$</span> be given in constraint form <span>$Ax ≤ b$</span>. We assume that the polyhedron is non-empty.</p><p>Proposition 1. If <span>$\ker(A)≠\{0\}$</span>, then <span>$P$</span> is unbounded.</p><p>Proposition 2. Assume that <span>$ker(A)={0}$</span> and <span>$P$</span> is non-empty. Then <span>$P$</span> is bounded if and only if the following linear program admits a feasible solution: <span>$\min∥y∥_1$</span> subject to <span>$A^Ty=0$</span> and <span>$y≥1$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bbf2d11db4e4525b89ea0fa9f12b827e6dbd1737/src/Interfaces/AbstractPolyhedron_functions.jl#L697-L736">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets._linear_map_polyhedron" href="#LazySets._linear_map_polyhedron"><code>LazySets._linear_map_polyhedron</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_linear_map_polyhedron(M::AbstractMatrix,
                       P::LazySet;
                       [algorithm]::Union{String, Nothing}=nothing,
                       [check_invertibility]::Bool=true,
                       [cond_tol]::Number=DEFAULT_COND_TOL,
                       [inverse]::Union{AbstractMatrix{N}, Nothing}=nothing,
                       [backend]=nothing,
                       [elimination_method]=nothing)</code></pre><p>Concrete linear map of a polyhedral set.</p><p><strong>Input</strong></p><ul><li><p><code>M</code>         – matrix</p></li><li><p><code>P</code>         – polyhedral set</p></li><li><p><code>algorithm</code> – (optional; default: <code>nothing</code>) algorithm to be used; for the                description see the Algorithm section below; possible choices                are:</p><ul><li><code>&quot;inverse&quot;</code>, alias: <code>&quot;inv&quot;</code></li><li><code>&quot;inverse_right&quot;</code>, alias: <code>&quot;inv_right&quot;</code></li><li><code>&quot;elimination&quot;</code>, alias: <code>&quot;elim&quot;</code></li><li><code>&quot;lift&quot;</code></li><li><code>&quot;vrep&quot;</code></li><li><code>&quot;vrep_chull&quot;</code></li></ul></li><li><p><code>check_invertibility</code> – (optional, default: <code>true</code>) if <code>true</code> check whether                          the given matrix <code>M</code> is invertible; set to <code>false</code>                          only if you know that <code>M</code> is invertible</p></li><li><p><code>cond_tol</code>  – (optional; default: <code>DEFAULT_COND_TOL</code>) tolerance of matrix                condition (used to check whether the matrix is invertible)</p></li><li><p><code>inverse</code>   – (optional; default: <code>nothing</code>) matrix inverse <code>M⁻¹</code>; use this                option if you have already computed the inverse matrix of <code>M</code></p></li><li><p><code>backend</code>   – (optional: default: <code>nothing</code>) polyhedra backend</p></li><li><p><code>elimination_method</code>  – (optional: default: <code>nothing</code>) elimination method for                          the <code>&quot;elimination&quot;</code> algorithm</p></li></ul><p><strong>Output</strong></p><p>The type of the result is &quot;as close as possible&quot; to the the type of <code>P</code>. Let <code>(m, n)</code> be the size of <code>M</code>, where <code>m ≠ n</code> is allowed for rectangular maps.</p><p>To fix the type of the output to something different than the default value, consider post-processing the result of this function with a call to a suitable <code>convert</code> method.</p><p>In particular, the output depends on the type of <code>P</code>, on <code>m</code>, and the algorithm that was used:</p><ul><li><p>If the vertex-based approach was used:</p><ul><li>If <code>P</code> is a <code>VPolygon</code> and <code>m = 2</code> then the output is a <code>VPolygon</code>.</li><li>If <code>P</code> is a <code>VPolytope</code> then the output is a <code>VPolytope</code>.</li><li>Otherwise the output is an <code>Interval</code> if <code>m = 1</code>, a <code>VPolygon</code> if <code>m = 2</code>, and a <code>VPolytope</code> in other cases.</li></ul></li><li><p>If the invertibility criterion was used:</p><ul><li>The types of <code>HalfSpace</code>, <code>Hyperplane</code>, <code>Line2D</code>, and subtypes of <code>AbstractHPolygon</code> are preserved.</li><li>If <code>P</code> is an <code>AbstractPolytope</code>, then the output is an <code>Interval</code> if <code>m = 1</code>, an <code>HPolygon</code> if <code>m = 2</code>, and an <code>HPolytope</code> in other cases.</li><li>Otherwise the output is an <code>HPolyhedron</code>.</li></ul></li></ul><p><strong>Notes</strong></p><p>Since the different linear-map algorithms work at the level of constraints, this method uses dispatch on two stages: once the algorithm has been defined, first the helper methods <code>_linear_map_hrep_helper</code> (resp. <code>_linear_map_vrep</code>) are invoked, which dispatch on the set type. Then, each helper method calls the concrete implementation of <code>_linear_map_hrep</code>, which dispatches on the algorithm, and returns a list of constraints.</p><p>To simplify working with different algorithms and options, the types <code>&lt;: AbstractLinearMapAlgorithm</code> are used. These types are singleton type or types that carry only the key data for the given algorithm, such as the matrix inverse or the polyhedra backend.</p><p>New subtypes of the <code>AbstractPolyhedron</code> interface may define their own helper methods <code>_linear_map_vrep</code> (respectively <code>_linear_map_hrep_helper</code>) for special handling of the constraints returned by the implementations of <code>_linear_map_hrep</code>; otherwise the fallback implementation for <code>AbstractPolyhedron</code> is used, which instantiates an <code>HPolyhedron</code>.</p><p><strong>Algorithm</strong></p><p>This method mainly implements several approaches for the linear map: inverse, right inverse, transformation to vertex representation, variable elimination, and variable lifting. Depending on the properties of <code>M</code> and <code>P</code>, one algorithm may be preferable over the other. Details on the algorithms are given in the following subsections.</p><p>Otherwise, if the algorithm argument is not specified, a default option is chosen based on heuristics on the types and values of <code>M</code> and <code>P</code>:</p><ul><li>If the <code>&quot;inverse&quot;</code> algorithm applies, it is used.</li><li>Otherwise, if the <code>&quot;inverse_right&quot;</code> algorithm applies, it is used.</li><li>Otherwise, if the <code>&quot;lift&quot;</code> algorithm applies, it is used.</li><li>Otherwise, the <code>&quot;elimination&quot;</code> algorithm is used.</li></ul><p>Note that the algorithms <code>&quot;inverse&quot;</code> and <code>&quot;inverse_right&quot;</code> do not require the external library <code>Polyhedra</code>. However, the fallback method <code>&quot;elimination&quot;</code> requires <code>Polyhedra</code> as well as the library <code>CDDLib</code>.</p><p>The optional keyword arguments <code>inverse</code> and <code>check_invertibility</code> modify the default behavior:</p><ul><li>If an inverse matrix is passed in <code>inverse</code>, the given algorithm is applied, and if none is given, either <code>&quot;inverse&quot;</code> or <code>&quot;inverse_right&quot;</code> is applied (in that order of preference).</li><li>If <code>check_invertibility</code> is set to <code>false</code>, the given algorithm is applied, and if none is given, either <code>&quot;inverse&quot;</code> or <code>&quot;inverse_right&quot;</code> is applied (in that order of preference).</li></ul><p><strong>Inverse</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm=&quot;inverse&quot;</code> (or <code>algorithm=&quot;inv&quot;</code>). The algorithm requires that <code>M</code> is invertible, square, and dense. If you know a priori that <code>M</code> is invertible, set the flag <code>check_invertibility=false</code>, such that no extra checks are done. Otherwise, we check the sufficient condition that the condition number of <code>M</code> is not too high. The threshold for the condition number can be modified from its default value, <code>DEFAULT_COND_TOL</code>, by passing a custom <code>cond_tol</code>.</p><p>The algorithm is described next. Assuming that the matrix <span>$M$</span> is invertible (which we check via a sufficient condition,), <span>$y = M x$</span> implies <span>$x = \text{inv}(M) y$</span> and we can transform the polyhedron <span>$A x ≤ b$</span> to the polyhedron <span>$A \text{inv}(M) y ≤ b$</span>.</p><p>If the dense condition on <code>M</code> is not satisfied, there are two suggested workarounds: either transform to a dense matrix, i.e., calling <code>linear_map</code> with <code>Matrix(M)</code>, or use the <code>&quot;inverse_right&quot;</code> algorithm, which does not compute the inverse matrix explicitly, but uses a polyalgorithm; see the documentation of <code>?</code> for details.</p><p><strong>Inverse-right</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm=&quot;inverse_right&quot;</code> (or <code>algorithm=&quot;inv_right&quot;</code>). This algorithm applies to square and invertible matrices <code>M</code>. The idea is essentially the same as for the <code>&quot;inverse&quot;</code> algorithm; the difference is that in <code>&quot;inverse&quot;</code> the full matrix inverse is computed, and in <code>&quot;inverse_right&quot;</code> only the left division on the normal vectors is used. In particular, <code>&quot;inverse_right&quot;</code> is good as a workaround when <code>M</code> is sparse (since the <code>inv</code> function is not available for sparse matrices).</p><p><strong>Elimination</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm = &quot;elimination&quot;</code> (or <code>algorithm = &quot;elim&quot;</code>). The algorithm applies to any matrix <code>M</code> (invertible or not), and any polyhedron <code>P</code> (bounded or not).</p><p>The idea is described next. If <code>P : Ax &lt;= b</code> and <code>y = Mx</code> denote the polyhedron and the linear map, respectively, we consider the vector <code>z = [y, x]</code>, write the given equalities and the inequalities, and then eliminate the last x variables (there are <code>length(x)</code> in total) using a call to <code>Polyhedra.eliminate</code> to a backend library that can do variable elimination (typically <code>CDDLib</code> with the <code>BlockElimination()</code> algorithm). In this way we have eliminated the &quot;old&quot; variables <code>x</code> and kept the &quot;new&quot; or transformed variables &quot;y&quot;.</p><p>The default elimination method is block elimination. For possible options we refer to the documentation of Polyhedra, <a href="https://juliapolyhedra.github.io/Polyhedra.jl/latest/projection/">projection/elimination</a>.</p><p><strong>Lift</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm=&quot;lift&quot;</code>. The algorithm applies if <code>M</code> is rectangular of size <code>m × n</code> with <code>m &gt; n</code> and full rank (i.e., of rank <code>n</code>).</p><p>The idea is to embed the polyhedron into the <code>m</code>-dimensional space by appending zeros, i.e. extending all constraints of <code>P</code> to <code>m</code> dimensions, and constraining the last <code>m - n</code> dimensions to <code>0</code>. The resulting matrix is extended to an invertible <code>m × m</code> matrix, and the algorithm using the inverse of the linear map is applied. For technical details of extending <code>M</code> to a higher-dimensional invertible matrix, see <code>ReachabilityBase.Arrays.extend</code>.</p><p><strong>Vertex representation</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm=&quot;vrep&quot;</code> (or <code>algorithm=&quot;vrep_chull&quot;</code>). If the polyhedron is bounded, the idea is to convert it to its vertex representation and apply the linear map to each vertex.</p><p>The returned set is a polytope in vertex representation. Note that conversion of the result back to half-space representation is not computed by default, since this may be costly. If you use this algorithm and still want to convert back to half-space representation, apply <code>tohrep</code> to the result of this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bbf2d11db4e4525b89ea0fa9f12b827e6dbd1737/src/Interfaces/AbstractPolyhedron_functions.jl#L163-L350">source</a></section></article><p>Undocumented implementations:</p><ul><li><a href="../../API/#Base.extrema-Tuple{LazySets.API.LazySet}"><code>extrema</code></a></li><li><a href="../../API/#Base.extrema-Tuple{LazySets.API.LazySet, Int64}"><code>extrema</code></a></li><li><a href="../../API/#LazySets.API.high-Tuple{LazySets.API.LazySet}"><code>high</code></a></li><li><a href="../../API/#LazySets.API.high-Tuple{LazySets.API.LazySet, Int64}"><code>high</code></a></li><li><a href="../../API/#LazySets.API.ispolyhedral-Tuple{LazySets.API.LazySet}"><code>ispolyhedral</code></a></li><li><a href="../../API/#LazySets.API.low-Tuple{LazySets.API.LazySet}"><code>low</code></a></li><li><a href="../../API/#LazySets.API.low-Tuple{LazySets.API.LazySet, Int64}"><code>low</code></a></li><li><a href="../../API/#Base.isdisjoint-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>isdisjoint</code></a></li></ul><p>Inherited from <a href="../LazySet/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../LazySet/#LazySets.API.area-Tuple{LazySet}"><code>area</code></a></li><li><a href="../LazySet/#LazySets.chebyshev_center_radius-Tuple{LazySet}"><code>chebyshev_center_radius</code></a></li><li><a href="../LazySet/#LazySets.API.complement-Tuple{LazySet}"><code>complement</code></a></li><li><a href="../LazySet/#LazySets.API.concretize-Tuple{LazySet}"><code>concretize</code></a></li><li><a href="../LazySet/#LazySets.API.constraints-Tuple{LazySet}"><code>constraints</code></a></li><li><a href="../LazySet/#LazySets.API.convex_hull-Tuple{LazySet}"><code>convex_hull</code></a></li><li><code>copy(::Type{LazySet})</code></li><li><a href="../LazySet/#LazySets.API.diameter"><code>diameter</code></a></li><li><a href="../LazySet/#Base.eltype-Tuple{Type{&lt;:LazySet}}"><code>eltype</code></a></li><li><a href="../LazySet/#Base.eltype-Tuple{LazySet}"><code>eltype</code></a></li><li><a href="../../API/#LazySets.API.isboundedtype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>isboundedtype</code></a></li><li><a href="../../API/#Base.isempty"><code>isempty</code></a></li><li><a href="../LazySet/#LazySets.API.isoperation-Tuple{LazySet}"><code>isoperation</code></a></li><li><a href="../LazySet/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../LazySet/#Polyhedra.polyhedron-Tuple{LazySet}"><code>polyhedron</code></a></li><li><a href="../LazySet/#LazySets.API.radius"><code>radius</code></a></li><li><a href="../LazySet/#Base.rationalize-Union{Tuple{T}, Tuple{Type{T}, LazySet{&lt;:AbstractFloat}, Real}} where T&lt;:Integer"><code>rationalize</code></a></li><li><a href="../../API/#ReachabilityBase.Arrays.rectify-Tuple{LazySets.API.LazySet}"><code>rectify</code></a></li><li><a href="../LazySet/#LazySets.API.reflect-Tuple{LazySet}"><code>reflect</code></a></li><li><a href="../LazySet/#LazySets.singleton_list-Tuple{LazySet}"><code>singleton_list</code></a></li><li><a href="../LazySet/#LazySets.tosimplehrep-Tuple{LazySet}"><code>tosimplehrep</code></a></li><li><a href="../LazySet/#LazySets.triangulate-Tuple{LazySet}"><code>triangulate</code></a></li><li><a href="../LazySet/#LazySets.triangulate_faces-Tuple{LazySet}"><code>triangulate_faces</code></a></li><li><a href="../LazySet/#LazySets.API.vertices-Tuple{LazySet}"><code>vertices</code></a></li><li><a href="../LazySet/#LazySets.API.affine_map-Tuple{Any, LazySet, AbstractVector}"><code>affine_map</code></a></li><li><a href="../LazySet/#LazySets.API.exponential_map-Tuple{AbstractMatrix, LazySet}"><code>exponential_map</code></a></li><li><a href="../../API/#LazySets.API.is_interior_point-Tuple{AbstractVector, LazySets.API.LazySet}"><code>is_interior_point</code></a></li><li><a href="../LazySet/#LazySets.API.linear_map-Tuple{AbstractMatrix, LazySet}"><code>linear_map</code></a></li><li><a href="../../utils/#LazySets.API.sample"><code>sample</code></a></li><li><a href="../LazySet/#LazySets.API.scale-Tuple{Real, LazySet}"><code>scale</code></a></li><li><a href="../LazySet/#LazySets.API.ρ-Tuple{AbstractVector, LazySet}"><code>ρ</code></a></li><li><a href="../LazySet/#LazySets.API.translate-Tuple{LazySet, AbstractVector}"><code>translate</code></a></li><li><a href="../LazySet/#LazySets.API.cartesian_product-Tuple{LazySet, LazySet}"><code>cartesian_product</code></a></li><li><a href="../LazySet/#LazySets.API.convex_hull-Tuple{LazySet, LazySet}"><code>convex_hull</code></a></li><li><a href="../../API/#LazySets.API.exact_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>exact_sum</code></a></li><li><a href="../LazySet/#Base.:≈-Tuple{LazySet, LazySet}"><code>≈</code></a></li><li><a href="../LazySet/#Base.:==-Tuple{LazySet, LazySet}"><code>==</code></a></li><li><a href="../LazySet/#LazySets.API.isequivalent-Tuple{LazySet, LazySet}"><code>isequivalent</code></a></li><li><a href="../../concrete_binary_operations/issubset/#LazySets.API.:⊂-Tuple{LazySet, LazySet}"><code>⊂</code></a></li><li><a href="../../API/#Base.:⊆-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>⊆</code></a></li><li><a href="../LazySet/#LazySets.API.minkowski_difference-Tuple{LazySet, LazySet}"><code>minkowski_difference</code></a></li></ul><p>Inherited from <a href="../ConvexSet/#LazySets.ConvexSet"><code>ConvexSet</code></a>:</p><ul><li><a href="../../API/#LazySets.API.isconvextype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>isconvextype</code></a></li><li><a href="../../API/#LazySets.API.linear_combination-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>linear_combination</code></a></li></ul><p>Some common functions implemented by several subtypes:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.addconstraint!-Tuple{AbstractPolyhedron, HalfSpace}" href="#LazySets.addconstraint!-Tuple{AbstractPolyhedron, HalfSpace}"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addconstraint!(P::AbstractPolyhedron, constraint::HalfSpace)</code></pre><p>Add a linear constraint to a set in constraint representation in-place.</p><p><strong>Input</strong></p><ul><li><code>P</code>          – set in constraint representation</li><li><code>constraint</code> – linear constraint to add</li></ul><p><strong>Notes</strong></p><p>It is left to the user to guarantee that the dimension of all linear constraints is the same.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bbf2d11db4e4525b89ea0fa9f12b827e6dbd1737/src/Interfaces/AbstractPolyhedron_functions.jl#L955-L969">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.ishyperplanar-Tuple{AbstractPolyhedron}" href="#LazySets.ishyperplanar-Tuple{AbstractPolyhedron}"><code>LazySets.ishyperplanar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ishyperplanar(P::AbstractPolyhedron)</code></pre><p>Determine whether a polyhedron is equivalent to a hyperplane.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polyhedron</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>P</code> is hyperplanar, i.e., consists of two linear constraints <span>$a·x ≤ b$</span> and <span>$-a·x ≤ -b$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bbf2d11db4e4525b89ea0fa9f12b827e6dbd1737/src/Interfaces/AbstractPolyhedron_functions.jl#L972-L985">source</a></section></article><p>Plotting polyhedra is available too:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.plot_recipe-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}, Tuple{AbstractPolyhedron{N}, Any}} where N" href="#LazySets.plot_recipe-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}, Tuple{AbstractPolyhedron{N}, Any}} where N"><code>LazySets.plot_recipe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_recipe(P::AbstractPolyhedron{N}, [ε]=zero(N)) where {N}</code></pre><p>Convert a (bounded) polyhedron to a pair <code>(x, y)</code> of points for plotting.</p><p><strong>Input</strong></p><ul><li><code>P</code> – bounded polyhedron</li><li><code>ε</code> – (optional, default: <code>0</code>) ignored, used for dispatch</li></ul><p><strong>Output</strong></p><p>A pair <code>(x, y)</code> of points that can be plotted, where <code>x</code> is the vector of x-coordinates and <code>y</code> is the vector of y-coordinates.</p><p><strong>Algorithm</strong></p><p>We first assert that <code>P</code> is bounded (i.e., that <code>P</code> is a polytope).</p><p>One-dimensional polytopes are converted to an <code>Interval</code>. Three-dimensional or higher-dimensional polytopes are not supported.</p><p>For two-dimensional polytopes (i.e., polygons) we compute their set of vertices using <code>vertices_list</code> and then plot the convex hull of these vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bbf2d11db4e4525b89ea0fa9f12b827e6dbd1737/src/Interfaces/AbstractPolyhedron_functions.jl#L560-L584">source</a></section></article><h2 id="Implementations"><a class="docs-heading-anchor" href="#Implementations">Implementations</a><a id="Implementations-1"></a><a class="docs-heading-anchor-permalink" href="#Implementations" title="Permalink"></a></h2><ul><li><a href="../../sets/HalfSpace/#def_HalfSpace">Half-space (HalfSpace)</a></li><li><a href="../../sets/HPolyhedron/#def_HPolyhedron">Polyhedron in constraint representation (HPolyhedron)</a></li><li><a href="../../sets/Hyperplane/#def_Hyperplane">Hyperplane</a></li><li><a href="../../sets/Line2D/#def_Line2D">Line2D</a></li><li><a href="../../sets/Line/#def_Line">Line</a></li><li><a href="../../sets/Universe/#def_Universe">Universe</a></li><li><a href="../../sets/Star/#def_Star">Star</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../AbstractCentrallySymmetric/">« Centrally symmetric sets (AbstractCentrallySymmetric)</a><a class="docs-footer-nextpage" href="../AbstractPolytope/">Polytopes (AbstractPolytope) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Tuesday 8 July 2025 04:35">Tuesday 8 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
