<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Affine maps (AbstractAffineMap) · LazySets.jl</title><meta name="title" content="Affine maps (AbstractAffineMap) · LazySets.jl"/><meta property="og:title" content="Affine maps (AbstractAffineMap) · LazySets.jl"/><meta property="twitter:title" content="Affine maps (AbstractAffineMap) · LazySets.jl"/><meta name="description" content="Documentation for LazySets.jl."/><meta property="og:description" content="Documentation for LazySets.jl."/><meta property="twitter:description" content="Documentation for LazySets.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/aligned.css" rel="stylesheet" type="text/css"/><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">LazySets.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../../man/optional_dependencies/">Optional Features</a></li><li><a class="tocitem" href="../../../man/tour/">A Tour of LazySets</a></li><li><a class="tocitem" href="../../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../../man/unary_set_operations/">Unary Operations on Sets</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../API/">API</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox" checked/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Set Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../LazySet/">General sets (LazySet)</a></li><li><a class="tocitem" href="../ConvexSet/">Convex sets (ConvexSet)</a></li><li><a class="tocitem" href="../AbstractCentrallySymmetric/">Centrally symmetric sets (AbstractCentrallySymmetric)</a></li><li><a class="tocitem" href="../AbstractPolyhedron/">Polyhedra (AbstractPolyhedron)</a></li><li><a class="tocitem" href="../AbstractPolytope/">Polytopes (AbstractPolytope)</a></li><li><a class="tocitem" href="../AbstractPolygon/">Polygons (AbstractPolygon)</a></li><li><a class="tocitem" href="../AbstractHPolygon/">Polygons in constraint representation (AbstractHPolygon)</a></li><li><a class="tocitem" href="../AbstractCentrallySymmetricPolytope/">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a></li><li><a class="tocitem" href="../AbstractZonotope/">Zonotopes (AbstractZonotope)</a></li><li><a class="tocitem" href="../AbstractHyperrectangle/">Hyperrectangles (AbstractHyperrectangle)</a></li><li><a class="tocitem" href="../AbstractSingleton/">Singletons (AbstractSingleton)</a></li><li class="is-active"><a class="tocitem" href>Affine maps (AbstractAffineMap)</a><ul class="internal"><li><a class="tocitem" href="#Implementations"><span>Implementations</span></a></li></ul></li><li><a class="tocitem" href="../AbstractPolynomialZonotope/">Polynomial zonotope sets (AbstractPolynomialZonotope)</a></li><li><a class="tocitem" href="../AbstractSparsePolynomialZonotope/">Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)</a></li><li><a class="tocitem" href="../AbstractBallp/">Balls in the p-norm (AbstractBallp)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../../sets/DensePolynomialZonotope/">DensePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../../sets/HParallelotope/">HParallelotope</a></li><li><a class="tocitem" href="../../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../../sets/Line/">Line</a></li><li><a class="tocitem" href="../../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../../sets/Polygon/">Polygon</a></li><li><a class="tocitem" href="../../sets/SimpleSparsePolynomialZonotope/">SimpleSparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/SparsePolynomialZonotope/">SparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../../sets/Star/">Star</a></li><li><a class="tocitem" href="../../sets/Tetrahedron/">Tetrahedron</a></li><li><a class="tocitem" href="../../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../../sets/Zonotope/">Zonotope</a></li><li><a class="tocitem" href="../../sets/ZonotopeMD/">ZonotopeMD</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lazy_operations/AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../../lazy_operations/Bloating/">Bloating</a></li><li><a class="tocitem" href="../../lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../../lazy_operations/Complement/">Complement</a></li><li><a class="tocitem" href="../../lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../../lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../../lazy_operations/Intersection/">Intersection</a></li><li><a class="tocitem" href="../../lazy_operations/LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../../lazy_operations/InverseLinearMap/">InverseLinearMap</a></li><li><a class="tocitem" href="../../lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../../lazy_operations/QuadraticMap/">QuadraticMap</a></li><li><a class="tocitem" href="../../lazy_operations/Rectification/">Rectification</a></li><li><a class="tocitem" href="../../lazy_operations/ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../../lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../../lazy_operations/Translation/">Translation</a></li><li><a class="tocitem" href="../../lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Concrete Binary Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../concrete_binary_operations/overview/">Binary set operations</a></li><li><a class="tocitem" href="../../concrete_binary_operations/cartesian_product/">Cartesian Product</a></li><li><a class="tocitem" href="../../concrete_binary_operations/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../concrete_binary_operations/difference/">Set difference</a></li><li><a class="tocitem" href="../../concrete_binary_operations/distance/">Distance</a></li><li><a class="tocitem" href="../../concrete_binary_operations/intersection/">Intersection of two sets</a></li><li><a class="tocitem" href="../../concrete_binary_operations/minkowski_sum/">Minkowski Sum</a></li><li><a class="tocitem" href="../../concrete_binary_operations/minkowski_difference/">Minkowski Difference</a></li><li><a class="tocitem" href="../../concrete_binary_operations/isdisjoint/">Check for Disjointness of Sets</a></li><li><a class="tocitem" href="../../concrete_binary_operations/issubset/">Subset Check</a></li></ul></li><li><a class="tocitem" href="../../conversion/">Conversions between set representations</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Approximations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../approximations/overview/">Overview</a></li><li><a class="tocitem" href="../../approximations/overapproximate/">Overapproximation</a></li><li><a class="tocitem" href="../../approximations/box_approximation/">Box Approximation</a></li><li><a class="tocitem" href="../../approximations/iterative_refinement/">Iterative refinement</a></li><li><a class="tocitem" href="../../approximations/template_directions/">Template directions</a></li><li><a class="tocitem" href="../../approximations/underapproximate/">Underapproximation</a></li><li><a class="tocitem" href="../../approximations/approximate/">Approximation</a></li><li><a class="tocitem" href="../../approximations/decompose/">Cartesian Decomposition</a></li><li><a class="tocitem" href="../../approximations/hausdorff_distance/">Hausdorff Distance</a></li></ul></li><li><a class="tocitem" href="../../utils/">Utilities</a></li><li><a class="tocitem" href="../../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li><a class="is-disabled">Set Interfaces</a></li><li class="is-active"><a href>Affine maps (AbstractAffineMap)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Affine maps (AbstractAffineMap)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/interfaces/AbstractAffineMap.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#def_AbstractAffineMap">Affine maps (AbstractAffineMap)</a></li><li class="no-marker"><ul><li><a href="#Implementations">Implementations</a></li></ul></li></ul><h1 id="def_AbstractAffineMap"><a class="docs-heading-anchor" href="#def_AbstractAffineMap">Affine maps (AbstractAffineMap)</a><a id="def_AbstractAffineMap-1"></a><a class="docs-heading-anchor-permalink" href="#def_AbstractAffineMap" title="Permalink"></a></h1><p>An affine map consists of a linear map and a translation.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.AbstractAffineMap" href="#LazySets.AbstractAffineMap"><code>LazySets.AbstractAffineMap</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractAffineMap{N, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Abstract type for affine maps.</p><p><strong>Notes</strong></p><p>See <a href="../../lazy_operations/AffineMap/#LazySets.AffineMap"><code>AffineMap</code></a> for a standard implementation of this interface.</p><p>Every concrete <code>AbstractAffineMap</code> must define the following methods:</p><ul><li><code>matrix(::AbstractAffineMap)</code> – return the linear map</li><li><code>vector(::AbstractAffineMap)</code> – return the affine translation vector</li><li><code>set(::AbstractAffineMap)</code> – return the set that the map is applied to</li></ul><p>The subtypes of <code>AbstractAffineMap</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; subtypes(AbstractAffineMap)
7-element Vector{Any}:
 AffineMap
 ExponentialMap
 ExponentialProjectionMap
 InverseLinearMap
 LinearMap
 ResetMap
 Translation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/Interfaces/AbstractAffineMap.jl#L4-L32">source</a></section></article><p>This interface requires to implement the following functions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.matrix-Tuple{AbstractAffineMap}" href="#LazySets.matrix-Tuple{AbstractAffineMap}"><code>LazySets.matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matrix(X::AbstractAffineMap)</code></pre><p>Return the matrix of an affine map.</p><p><strong>Input</strong></p><ul><li><code>X</code> – affine map</li></ul><p><strong>Output</strong></p><p>The matrix of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/Interfaces/AbstractAffineMap.jl#L35-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.vector-Tuple{AbstractAffineMap}" href="#LazySets.vector-Tuple{AbstractAffineMap}"><code>LazySets.vector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vector(X::AbstractAffineMap)</code></pre><p>Return the vector of an affine map.</p><p><strong>Input</strong></p><ul><li><code>X</code> – affine map</li></ul><p><strong>Output</strong></p><p>The vector of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/Interfaces/AbstractAffineMap.jl#L50-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.set-Tuple{AbstractAffineMap}" href="#LazySets.set-Tuple{AbstractAffineMap}"><code>LazySets.set</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set(X::AbstractAffineMap)</code></pre><p>Return the set of an affine map.</p><p><strong>Input</strong></p><ul><li><code>X</code> – affine map</li></ul><p><strong>Output</strong></p><p>The set of <code>X</code> before applying the map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/Interfaces/AbstractAffineMap.jl#L65-L77">source</a></section></article><p>This interface defines the following functions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.an_element-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap" href="#LazySets.API.an_element-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap"><code>LazySets.API.an_element</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">an_element(X::LazySet)</code></pre><p>Return some element of a nonempty set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>An element of <code>X</code> unless <code>X</code> is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/API/Unary/an_element.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.an_element-Tuple{AbstractAffineMap}" href="#LazySets.API.an_element-Tuple{AbstractAffineMap}"><code>LazySets.API.an_element</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><p><strong>Algorithm</strong></p><p>The implementation relies on the <code>an_element</code> method of the wrapped set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/Interfaces/AbstractAffineMap.jl#L99-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.center-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap" href="#LazySets.API.center-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap"><code>LazySets.API.center</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">center(X::LazySet)</code></pre><p>Compute the center of a centrally symmetric set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p>A vector with the center, or midpoint, of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/API/Unary/center.jl#L17-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.center-Tuple{AbstractAffineMap}" href="#LazySets.API.center-Tuple{AbstractAffineMap}"><code>LazySets.API.center</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">center(am::AbstractAffineMap)</code></pre><p><strong>Algorithm</strong></p><p>The implementation relies on the <code>center</code> method of the wrapped set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/Interfaces/AbstractAffineMap.jl#L194-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap" href="#LazySets.API.constraints_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap"><code>LazySets.API.constraints_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">constraints_list(X::LazySet)</code></pre><p>Compute a list of linear constraints of a polyhedral set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – polyhedral set</li></ul><p><strong>Output</strong></p><p>A list of the linear constraints of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/API/Unary/constraints_list.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.constraints_list-Tuple{AbstractAffineMap}" href="#LazySets.API.constraints_list-Tuple{AbstractAffineMap}"><code>LazySets.API.constraints_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">constraints_list(am::AbstractAffineMap)</code></pre><p><strong>Notes</strong></p><p>We assume that the underlying set <code>X</code> is polyhedral, i.e., offers a method <code>constraints_list(X)</code>.</p><p><strong>Algorithm</strong></p><p>This implementation uses the <code>constraints_list</code> method to compute the list of constraints of the translation of a lazy <a href="../../lazy_operations/LinearMap/#LazySets.LinearMap"><code>LinearMap</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/Interfaces/AbstractAffineMap.jl#L250-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isbounded-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap" href="#LazySets.API.isbounded-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap"><code>LazySets.API.isbounded</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isbounded(X::LazySet)</code></pre><p>Check whether a set is bounded.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set is bounded.</p><p><strong>Notes</strong></p><p>See also <a href="../../API/#LazySets.API.isboundedtype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>isboundedtype(::Type{&lt;:LazySet})</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/API/Unary/isbounded.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isbounded-Tuple{AbstractAffineMap}" href="#LazySets.API.isbounded-Tuple{AbstractAffineMap}"><code>LazySets.API.isbounded</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">isbounded(am::AbstractAffineMap; cond_tol::Number=DEFAULT_COND_TOL)</code></pre><p><strong>Input</strong></p><ul><li><code>cond_tol</code> – (optional) tolerance of matrix condition (used to check whether               the matrix is invertible)</li></ul><p><strong>Algorithm</strong></p><p>We first check if the matrix is zero or the wrapped set is bounded. If not, we perform a sufficient check whether the matrix is invertible. If the matrix is invertible, then the map being bounded is equivalent to the wrapped set being bounded, and hence the map is unbounded. Otherwise, we check boundedness via <a href="../LazySet/#LazySets._isbounded_unit_dimensions-Tuple{LazySet}"><code>_isbounded_unit_dimensions</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/Interfaces/AbstractAffineMap.jl#L123-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isempty-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap" href="#Base.isempty-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isempty(X::LazySet, witness::Bool=false)</code></pre><p>Check whether a set is empty.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If the <code>witness</code> option is deactivated: <code>true</code> iff <span>$X = ∅$</span></li><li>If the <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X = ∅$</span></li><li><code>(false, v)</code> iff <span>$X ≠ ∅$</span> for some <span>$v ∈ X$</span></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/API/Unary/isempty.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isempty-Tuple{AbstractAffineMap}" href="#Base.isempty-Tuple{AbstractAffineMap}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">isempty(am::AbstractAffineMap)</code></pre><p><strong>Algorithm</strong></p><p>The result is <code>true</code> iff the wrapped set is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/Interfaces/AbstractAffineMap.jl#L110-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap" href="#Base.:∈-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∈(x::AbstractVector, X::LazySet)</code></pre><p>Check whether a point lies in a set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/API/Mixed/in.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:∈-Tuple{AbstractVector, AbstractAffineMap}" href="#Base.:∈-Tuple{AbstractVector, AbstractAffineMap}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">∈(x::AbstractVector, am::AbstractAffineMap)</code></pre><p><strong>Algorithm</strong></p><p>Observe that <span>$x ∈ M⋅S ⊕ v$</span> iff <span>$M^{-1}⋅(x - v) ∈ S$</span>. This implementation does not explicitly invert the matrix, which is why it also works for non-square matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; am = AffineMap([2.0 0.0; 0.0 1.0], BallInf([1., 1.], 1.), [-1.0, -1.0]);

julia&gt; [5.0, 1.0] ∈ am
false

julia&gt; [3.0, 1.0] ∈ am
true</code></pre><p>An example with a non-square matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; B = BallInf(zeros(4), 1.);

julia&gt; M = [1. 0 0 0; 0 1 0 0]/2;

julia&gt; [0.5, 0.5] ∈ M*B
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/Interfaces/AbstractAffineMap.jl#L152-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.vertices_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap" href="#LazySets.API.vertices_list-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap"><code>LazySets.API.vertices_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertices_list(X::LazySet)</code></pre><p>Compute a list of vertices of a polytopic set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – polytopic set</li></ul><p><strong>Output</strong></p><p>A list of the vertices of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/API/Unary/vertices_list.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.vertices_list-Tuple{AbstractAffineMap}" href="#LazySets.API.vertices_list-Tuple{AbstractAffineMap}"><code>LazySets.API.vertices_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">vertices_list(am::AbstractAffineMap; [apply_convex_hull]::Bool=true)</code></pre><p><strong>Input</strong></p><ul><li><code>apply_convex_hull</code> – (optional, default: <code>true</code>) if <code>true</code>, apply the convex                        hull operation to the list of vertices transformed by                        the affine map</li></ul><p><strong>Algorithm</strong></p><p>This implementation computes all vertices of <code>X</code>, then transforms them through the affine map, i.e., <code>x ↦ M*x + v</code> for each vertex <code>x</code> of <code>X</code>. By default, the convex-hull operation is taken before returning this list. For dimensions three or higher, this operation relies on the functionality through the concrete polyhedra library <code>Polyhedra.jl</code>.</p><p>If you are not interested in taking the convex hull of the resulting vertices under the affine map, pass <code>apply_convex_hull=false</code> as a keyword argument.</p><p>Note that we assume that the underlying set <code>X</code> is polytopic, either concretely or lazily, i.e., the function <code>vertices_list</code> should be applicable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/Interfaces/AbstractAffineMap.jl#L207-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.volume-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap" href="#LazySets.API.volume-Tuple{LazySets.API.LazySet}-lib-interfaces-AbstractAffineMap"><code>LazySets.API.volume</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">volume(X::LazySet)</code></pre><p>Compute the volume, or Lebesgue measure, of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A real number representing the Lebesgue measure of <code>X</code>.</p><p><strong>Notes</strong></p><p>The <a href="https://en.wikipedia.org/wiki/Lebesgue_measure">Lebesgue measure</a> has the following common special cases:</p><ul><li>In 1D, it coincides with the <em>length</em>.</li><li>In 2D, it coincides with the <em>area</em> (see also <a href="../../API/#LazySets.API.area-Tuple{LazySets.API.LazySet}"><code>area</code></a>).</li><li>In 3D, it coincides with the <em>volume</em>.</li></ul><p>In higher dimensions, it is also known as the <em>hypervolume</em> or simply <em>volume</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/API/Unary/volume.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.volume-Tuple{AbstractAffineMap}" href="#LazySets.API.volume-Tuple{AbstractAffineMap}"><code>LazySets.API.volume</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">volume(am::AbstractAffineMap)</code></pre><p><strong>Notes</strong></p><p>This implementation requires a dimension-preserving map (i.e., a square matrix).</p><p><strong>Algorithm</strong></p><p>A square linear map scales the volume of any set by its absolute determinant. A translation does not affect the volume. Thus, the volume of <code>M * X + {v}</code> is <code>|det(M)| * volume(X)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/935018722edf9af5351efd0821ba1a1fd344688f/src/Interfaces/AbstractAffineMap.jl#L274-L288">source</a></section></article><p>Undocumented implementations:</p><ul><li><a href="../../API/#LazySets.API.dim-Tuple{LazySets.API.LazySet}"><code>dim</code></a></li><li><a href="../../API/#LazySets.API.isconvextype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>isconvextype</code></a></li><li><a href="../../API/#LazySets.API.isoperationtype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>isoperationtype</code></a></li><li><a href="../../API/#LazySets.API.ispolyhedral-Tuple{LazySets.API.LazySet}"><code>ispolyhedral</code></a></li><li><a href="../../API/#LazySets.API.linear_map-Tuple{AbstractMatrix, LazySets.API.LazySet}"><code>linear_map</code></a></li><li><a href="../../API/#LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}"><code>ρ</code></a></li><li><a href="../../API/#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}"><code>σ</code></a></li></ul><p>Inherited from <a href="../LazySet/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../LazySet/#LazySets.API.area-Tuple{LazySet}"><code>area</code></a></li><li><a href="../LazySet/#LazySets.chebyshev_center_radius-Tuple{LazySet}"><code>chebyshev_center_radius</code></a></li><li><a href="../LazySet/#LazySets.API.complement-Tuple{LazySet}"><code>complement</code></a></li><li><a href="../LazySet/#LazySets.API.concretize-Tuple{LazySet}"><code>concretize</code></a></li><li><a href="../LazySet/#LazySets.API.constraints-Tuple{LazySet}"><code>constraints</code></a></li><li><a href="../LazySet/#LazySets.API.convex_hull-Tuple{LazySet}"><code>convex_hull</code></a></li><li><code>copy(::Type{LazySet})</code></li><li><a href="../LazySet/#LazySets.API.diameter"><code>diameter</code></a></li><li><a href="../LazySet/#Base.eltype-Tuple{Type{&lt;:LazySet}}"><code>eltype</code></a></li><li><a href="../LazySet/#Base.eltype-Tuple{LazySet}"><code>eltype</code></a></li><li><a href="../LazySet/#Base.extrema-Tuple{LazySet}"><code>extrema</code></a></li><li><a href="../LazySet/#Base.extrema-Tuple{LazySet, Int64}"><code>extrema</code></a></li><li><a href="../LazySet/#LazySets.API.high-Tuple{LazySet}"><code>high</code></a></li><li><a href="../../API/#LazySets.API.high-Tuple{LazySets.API.LazySet, Int64}"><code>high</code></a></li><li><a href="../../API/#LazySets.API.isboundedtype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>isboundedtype</code></a></li><li><a href="../LazySet/#LazySets.API.isoperation-Tuple{LazySet}"><code>isoperation</code></a></li><li><a href="../LazySet/#LazySets.API.low-Tuple{LazySet}"><code>low</code></a></li><li><a href="../../API/#LazySets.API.low-Tuple{LazySets.API.LazySet, Int64}"><code>low</code></a></li><li><a href="../LazySet/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../LazySet/#Polyhedra.polyhedron-Tuple{LazySet}"><code>polyhedron</code></a></li><li><a href="../LazySet/#LazySets.API.radius"><code>radius</code></a></li><li><a href="../LazySet/#Base.rationalize-Union{Tuple{T}, Tuple{Type{T}, LazySet{&lt;:AbstractFloat}, Real}} where T&lt;:Integer"><code>rationalize</code></a></li><li><a href="../../API/#ReachabilityBase.Arrays.rectify-Tuple{LazySets.API.LazySet}"><code>rectify</code></a></li><li><a href="../LazySet/#LazySets.API.reflect-Tuple{LazySet}"><code>reflect</code></a></li><li><a href="../LazySet/#LazySets.singleton_list-Tuple{LazySet}"><code>singleton_list</code></a></li><li><a href="../LazySet/#LazySets.tosimplehrep-Tuple{LazySet}"><code>tosimplehrep</code></a></li><li><a href="../LazySet/#LazySets.triangulate-Tuple{LazySet}"><code>triangulate</code></a></li><li><a href="../LazySet/#LazySets.triangulate_faces-Tuple{LazySet}"><code>triangulate_faces</code></a></li><li><a href="../LazySet/#LazySets.API.vertices-Tuple{LazySet}"><code>vertices</code></a></li><li><a href="../LazySet/#LazySets.API.affine_map-Tuple{Any, LazySet, AbstractVector}"><code>affine_map</code></a></li><li><a href="../LazySet/#LazySets.API.exponential_map-Tuple{AbstractMatrix, LazySet}"><code>exponential_map</code></a></li><li><a href="../../API/#LazySets.API.is_interior_point-Tuple{AbstractVector, LazySets.API.LazySet}"><code>is_interior_point</code></a></li><li><a href="../../API/#LazySets.API.project-Tuple{LazySets.API.LazySet, AbstractVector{Int64}}"><code>project</code></a></li><li><a href="../../utils/#LazySets.API.sample"><code>sample</code></a></li><li><a href="../LazySet/#LazySets.API.scale-Tuple{Real, LazySet}"><code>scale</code></a></li><li><a href="../LazySet/#LazySets.API.translate-Tuple{LazySet, AbstractVector}"><code>translate</code></a></li><li><a href="../LazySet/#LazySets.API.cartesian_product-Tuple{LazySet, LazySet}"><code>cartesian_product</code></a></li><li><a href="../LazySet/#LazySets.API.convex_hull-Tuple{LazySet, LazySet}"><code>convex_hull</code></a></li><li><a href="../../API/#LazySets.API.exact_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>exact_sum</code></a></li><li><a href="../LazySet/#Base.:≈-Tuple{LazySet, LazySet}"><code>≈</code></a></li><li><a href="../../API/#Base.isdisjoint-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>isdisjoint</code></a></li><li><a href="../LazySet/#Base.:==-Tuple{LazySet, LazySet}"><code>==</code></a></li><li><a href="../LazySet/#LazySets.API.isequivalent-Tuple{LazySet, LazySet}"><code>isequivalent</code></a></li><li><a href="../../concrete_binary_operations/issubset/#LazySets.API.:⊂-Tuple{LazySet, LazySet}"><code>⊂</code></a></li><li><a href="../../API/#Base.:⊆-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>⊆</code></a></li><li><a href="../../API/#LazySets.API.linear_combination-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>linear_combination</code></a></li><li><a href="../LazySet/#LazySets.API.minkowski_difference-Tuple{LazySet, LazySet}"><code>minkowski_difference</code></a></li><li><a href="../LazySet/#LazySets.API.minkowski_sum-Tuple{LazySet, LazySet}"><code>minkowski_sum</code></a></li></ul><h2 id="Implementations"><a class="docs-heading-anchor" href="#Implementations">Implementations</a><a id="Implementations-1"></a><a class="docs-heading-anchor-permalink" href="#Implementations" title="Permalink"></a></h2><ul><li><a href="../../lazy_operations/AffineMap/#def_AffineMap">Affine map (AffineMap)</a></li><li><a href="../../lazy_operations/ExponentialMap/#def_ExponentialMap">Exponential map (ExponentialMap)</a></li><li><a href="../../lazy_operations/LinearMap/#def_LinearMap">Linear map (LinearMap)</a></li><li><a href="../../lazy_operations/ResetMap/#def_ResetMap">Reset map (ResetMap)</a></li><li><a href="../../lazy_operations/Translation/#def_Translation">Translation</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../AbstractSingleton/">« Singletons (AbstractSingleton)</a><a class="docs-footer-nextpage" href="../AbstractPolynomialZonotope/">Polynomial zonotope sets (AbstractPolynomialZonotope) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Tuesday 8 July 2025 04:42">Tuesday 8 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
