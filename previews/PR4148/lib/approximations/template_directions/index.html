<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Template directions · LazySets.jl</title><meta name="title" content="Template directions · LazySets.jl"/><meta property="og:title" content="Template directions · LazySets.jl"/><meta property="twitter:title" content="Template directions · LazySets.jl"/><meta name="description" content="Documentation for LazySets.jl."/><meta property="og:description" content="Documentation for LazySets.jl."/><meta property="twitter:description" content="Documentation for LazySets.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/aligned.css" rel="stylesheet" type="text/css"/><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">LazySets.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../../man/optional_dependencies/">Optional Features</a></li><li><a class="tocitem" href="../../../man/tour/">A Tour of LazySets</a></li><li><a class="tocitem" href="../../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../../man/unary_set_operations/">Unary Operations on Sets</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../API/">API</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Set Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../interfaces/overview/">Overview</a></li><li><a class="tocitem" href="../../interfaces/LazySet/">General sets (LazySet)</a></li><li><a class="tocitem" href="../../interfaces/ConvexSet/">Convex sets (ConvexSet)</a></li><li><a class="tocitem" href="../../interfaces/AbstractCentrallySymmetric/">Centrally symmetric sets (AbstractCentrallySymmetric)</a></li><li><a class="tocitem" href="../../interfaces/AbstractPolyhedron/">Polyhedra (AbstractPolyhedron)</a></li><li><a class="tocitem" href="../../interfaces/AbstractPolytope/">Polytopes (AbstractPolytope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractPolygon/">Polygons (AbstractPolygon)</a></li><li><a class="tocitem" href="../../interfaces/AbstractHPolygon/">Polygons in constraint representation (AbstractHPolygon)</a></li><li><a class="tocitem" href="../../interfaces/AbstractCentrallySymmetricPolytope/">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractZonotope/">Zonotopes (AbstractZonotope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractHyperrectangle/">Hyperrectangles (AbstractHyperrectangle)</a></li><li><a class="tocitem" href="../../interfaces/AbstractSingleton/">Singletons (AbstractSingleton)</a></li><li><a class="tocitem" href="../../interfaces/AbstractAffineMap/">Affine maps (AbstractAffineMap)</a></li><li><a class="tocitem" href="../../interfaces/AbstractPolynomialZonotope/">Polynomial zonotope sets (AbstractPolynomialZonotope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractSparsePolynomialZonotope/">Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractBallp/">Balls in the p-norm (AbstractBallp)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../../sets/DensePolynomialZonotope/">DensePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../../sets/HParallelotope/">HParallelotope</a></li><li><a class="tocitem" href="../../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../../sets/Line/">Line</a></li><li><a class="tocitem" href="../../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../../sets/Polygon/">Polygon</a></li><li><a class="tocitem" href="../../sets/SimpleSparsePolynomialZonotope/">SimpleSparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/SparsePolynomialZonotope/">SparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../../sets/Star/">Star</a></li><li><a class="tocitem" href="../../sets/Tetrahedron/">Tetrahedron</a></li><li><a class="tocitem" href="../../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../../sets/Zonotope/">Zonotope</a></li><li><a class="tocitem" href="../../sets/ZonotopeMD/">ZonotopeMD</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lazy_operations/AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../../lazy_operations/Bloating/">Bloating</a></li><li><a class="tocitem" href="../../lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../../lazy_operations/Complement/">Complement</a></li><li><a class="tocitem" href="../../lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../../lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../../lazy_operations/Intersection/">Intersection</a></li><li><a class="tocitem" href="../../lazy_operations/LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../../lazy_operations/InverseLinearMap/">InverseLinearMap</a></li><li><a class="tocitem" href="../../lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../../lazy_operations/QuadraticMap/">QuadraticMap</a></li><li><a class="tocitem" href="../../lazy_operations/Rectification/">Rectification</a></li><li><a class="tocitem" href="../../lazy_operations/ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../../lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../../lazy_operations/Translation/">Translation</a></li><li><a class="tocitem" href="../../lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Concrete Binary Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../concrete_binary_operations/overview/">Binary set operations</a></li><li><a class="tocitem" href="../../concrete_binary_operations/cartesian_product/">Cartesian Product</a></li><li><a class="tocitem" href="../../concrete_binary_operations/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../concrete_binary_operations/difference/">Set difference</a></li><li><a class="tocitem" href="../../concrete_binary_operations/distance/">Distance</a></li><li><a class="tocitem" href="../../concrete_binary_operations/intersection/">Intersection of two sets</a></li><li><a class="tocitem" href="../../concrete_binary_operations/minkowski_sum/">Minkowski Sum</a></li><li><a class="tocitem" href="../../concrete_binary_operations/minkowski_difference/">Minkowski Difference</a></li><li><a class="tocitem" href="../../concrete_binary_operations/isdisjoint/">Check for Disjointness of Sets</a></li><li><a class="tocitem" href="../../concrete_binary_operations/issubset/">Subset Check</a></li></ul></li><li><a class="tocitem" href="../../conversion/">Conversions between set representations</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox" checked/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Approximations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../overapproximate/">Overapproximation</a></li><li><a class="tocitem" href="../box_approximation/">Box Approximation</a></li><li><a class="tocitem" href="../iterative_refinement/">Iterative refinement</a></li><li class="is-active"><a class="tocitem" href>Template directions</a></li><li><a class="tocitem" href="../underapproximate/">Underapproximation</a></li><li><a class="tocitem" href="../approximate/">Approximation</a></li><li><a class="tocitem" href="../decompose/">Cartesian Decomposition</a></li><li><a class="tocitem" href="../hausdorff_distance/">Hausdorff Distance</a></li><li><a class="tocitem" href="../overapproximate_norm/">Norm Overapproximation</a></li><li><a class="tocitem" href="../overapproximate_expmap/">Overapproximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">MatrixSets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../matrixsets/MatrixZonotope/">MatrixZonotope</a></li></ul></li><li><a class="tocitem" href="../../utils/">Utilities</a></li><li><a class="tocitem" href="../../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li><a class="is-disabled">Approximations</a></li><li class="is-active"><a href>Template directions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Template directions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/approximations/template_directions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#Template-directions">Template directions</a></li></ul><h1 id="Template-directions"><a class="docs-heading-anchor" href="#Template-directions">Template directions</a><a id="Template-directions-1"></a><a class="docs-heading-anchor-permalink" href="#Template-directions" title="Permalink"></a></h1><p>See also <a href="../overapproximate/#LazySets.Approximations.overapproximate"><code>overapproximate(X::LazySet, dir::AbstractDirections)</code></a>.</p><article><details class="docstring" open="true"><summary id="LazySets.Approximations.AbstractDirections"><a class="docstring-binding" href="#LazySets.Approximations.AbstractDirections"><code>LazySets.Approximations.AbstractDirections</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractDirections{N, VN}</code></pre><p>Abstract type for representations of direction vectors.</p><p><strong>Notes</strong></p><p>This type is parameterized by <code>N</code> and <code>VN</code>, where:</p><ul><li><code>N</code> stands for the numeric type</li><li><code>VN</code> stands for the vector type with coefficients of type <code>N</code></li></ul><p>Each implementing subtype is an iterator over a set of directions. For that they implement the standard iterator methods from <code>Base</code>, namely <code>Base.length</code> (returns the number of directions) and <code>Base.iterate</code>. Moreover, the following methods should be implemented:</p><ul><li><code>dim</code>    – return the ambient dimension of the vectors</li><li><code>eltype</code> – return the type of each vector</li></ul><p>Optionally, subtypes may implement:</p><ul><li><code>isbounding</code>   – (defaults to <code>false</code>) return <code>true</code> if an overapproximation                   with the direction vectors results in a bounded set, given a                   bounded input set, and <code>false</code> otherwise</li><li><code>isnormalized</code> – (defaults to <code>false</code>) is <code>true</code> if each direction vector has                   norm one w.r.t. the usual vector 2-norm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a6c8134409f3968342f8110c90f5f6c867e3dd08/src/Approximations/template_directions.jl#L4-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.Approximations.isbounding"><a class="docstring-binding" href="#LazySets.Approximations.isbounding"><code>LazySets.Approximations.isbounding</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isbounding(ad::AbstractDirections)
isbounding(ad::Type{&lt;:AbstractDirections})</code></pre><p>Check whether an overapproximation with a set of direction vectors results in a bounded set, given a bounded input set.</p><p><strong>Input</strong></p><ul><li><code>ad</code> – direction vectors or a subtype of <code>AbstractDirections</code></li></ul><p><strong>Output</strong></p><p>Given a bounded set <span>$X$</span>, we can construct an outer polyhedral approximation of <span>$X$</span> by using the direction vectors <code>ad</code> as normal vectors of the facets. If this function returns <code>true</code>, then the result is again guaranteed to be a bounded set (i.e., a polytope). Note that the result does not depend on the specific shape of <span>$X$</span>, as long as <span>$X$</span> is bounded.</p><p><strong>Notes</strong></p><p>By default, this function returns <code>false</code> in order to be conservative. Custom subtypes of <code>AbstractDirections</code> should hence add a method for this function.</p><p>The function can be applied to an instance of an <code>AbstractDirections</code> subtype or to the subtype itself. By default, the check on the instance falls back to the check on the subtype.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a6c8134409f3968342f8110c90f5f6c867e3dd08/src/Approximations/template_directions.jl#L49-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.Approximations.isnormalized"><a class="docstring-binding" href="#LazySets.Approximations.isnormalized"><code>LazySets.Approximations.isnormalized</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isnormalized(ad::AbstractDirections)
isnormalized(ad::Type{&lt;:AbstractDirections})</code></pre><p>Check whether the given direction vectors are normalized with respect to the 2-norm.</p><p><strong>Input</strong></p><ul><li><code>ad</code> – direction vectors or a subtype of <code>AbstractDirections</code></li></ul><p><strong>Output</strong></p><p><code>true</code> if the 2-norm of each element in <code>ad</code> is one and <code>false</code> otherwise.</p><p><strong>Notes</strong></p><p>By default, this function returns <code>false</code> in order to be conservative. Custom subtypes of <code>AbstractDirections</code> should hence add a method for this function.</p><p>The function can be applied to an instance of an <code>AbstractDirections</code> subtype or to the subtype itself. By default, the check on the instance falls back to the check on the subtype.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a6c8134409f3968342f8110c90f5f6c867e3dd08/src/Approximations/template_directions.jl#L85-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.API.project-Tuple{LazySet, AbstractVector{Int64}, Type{&lt;:LazySets.Approximations.AbstractDirections}}"><a class="docstring-binding" href="#LazySets.API.project-Tuple{LazySet, AbstractVector{Int64}, Type{&lt;:LazySets.Approximations.AbstractDirections}}"><code>LazySets.API.project</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">project(S::LazySet,
        block::AbstractVector{Int},
        directions::Type{&lt;:AbstractDirections},
        [n]::Int;
        [kwargs...]
       )</code></pre><p>Project a high-dimensional set to a given block using direction vectors.</p><p><strong>Input</strong></p><ul><li><code>S</code>          – set</li><li><code>block</code>      – block structure - a vector with the dimensions of interest</li><li><code>directions</code> – direction vectors</li><li><code>n</code>          – (optional, default: <code>dim(S)</code>) ambient dimension of the set <code>S</code></li></ul><p><strong>Output</strong></p><p>The polyhedral overapproximation of the projection of <code>S</code> in the given directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a6c8134409f3968342f8110c90f5f6c867e3dd08/src/Approximations/template_directions.jl#L116-L137">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.Approximations.BoxDirections"><a class="docstring-binding" href="#LazySets.Approximations.BoxDirections"><code>LazySets.Approximations.BoxDirections</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BoxDirections{N, VN} &lt;: AbstractDirections{N, VN}</code></pre><p>Box directions representation.</p><p><strong>Fields</strong></p><ul><li><code>n</code> – dimension</li></ul><p><strong>Notes</strong></p><p>Box directions can be seen as the vectors where only one entry is ±1, and all other entries are 0. In dimension <span>$n$</span>, there are <span>$2n$</span> such directions.</p><p>The default vector representation used in this template is a <code>ReachabilityBase.Arrays.SingleEntryVector</code>, although other implementations can be used such as a regular <code>Vector</code> and a <code>SparseVector</code>.</p><p><strong>Examples</strong></p><p>The template can be constructed by passing the dimension. For example, in dimension two:</p><pre><code class="language-julia-repl hljs">julia&gt; dirs = BoxDirections(2)
BoxDirections{Float64, ReachabilityBase.Arrays.SingleEntryVector{Float64}}(2)

julia&gt; length(dirs)
4</code></pre><p>By default, each direction is represented as a <code>SingleEntryVector</code>, i.e., a vector with only one non-zero element,</p><pre><code class="language-julia-repl hljs">julia&gt; eltype(dirs)
ReachabilityBase.Arrays.SingleEntryVector{Float64}</code></pre><p>In two dimensions, the directions defined by <code>BoxDirections</code> are normal to the facets of a box.</p><pre><code class="language-julia-repl hljs">julia&gt; collect(dirs)
4-element Vector{ReachabilityBase.Arrays.SingleEntryVector{Float64}}:
 [1.0, 0.0]
 [0.0, 1.0]
 [0.0, -1.0]
 [-1.0, 0.0]</code></pre><p>The numeric type can be specified as well:</p><pre><code class="language-julia-repl hljs">julia&gt; dirs = BoxDirections{Rational{Int}}(10)
BoxDirections{Rational{Int64}, ReachabilityBase.Arrays.SingleEntryVector{Rational{Int64}}}(10)

julia&gt; length(dirs)
20</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a6c8134409f3968342f8110c90f5f6c867e3dd08/src/Approximations/template_directions.jl#L147-L206">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.Approximations.DiagDirections"><a class="docstring-binding" href="#LazySets.Approximations.DiagDirections"><code>LazySets.Approximations.DiagDirections</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DiagDirections{N, VN} &lt;: AbstractDirections{N, VN}</code></pre><p>Diagonal directions representation.</p><p><strong>Fields</strong></p><ul><li><code>n</code> – dimension</li></ul><p><strong>Notes</strong></p><p>Diagonal directions are vectors where all entries are ±1. In dimension <span>$n$</span>, there are in total <span>$2^n$</span> such directions.</p><p><strong>Examples</strong></p><p>The template can be constructed by passing the dimension. For example, in dimension two:</p><pre><code class="language-julia-repl hljs">julia&gt; dirs = DiagDirections(2)
DiagDirections{Float64, Vector{Float64}}(2)

julia&gt; length(dirs) # number of directions
4</code></pre><p>By default, each direction is represented as a regular <code>Vector</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; eltype(dirs)
Vector{Float64} (alias for Array{Float64, 1})</code></pre><p>In two dimensions, the directions defined by <code>DiagDirections</code> are normal to the facets of a ball in the 1-norm.</p><pre><code class="language-julia-repl hljs">julia&gt; collect(dirs)
4-element Vector{Vector{Float64}}:
 [1.0, 1.0]
 [-1.0, 1.0]
 [1.0, -1.0]
 [-1.0, -1.0]</code></pre><p>The numeric type can be specified as well:</p><pre><code class="language-julia-repl hljs">julia&gt; dirs = DiagDirections{Rational{Int}}(10)
DiagDirections{Rational{Int64}, Vector{Rational{Int64}}}(10)

julia&gt; length(dirs)
1024</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a6c8134409f3968342f8110c90f5f6c867e3dd08/src/Approximations/template_directions.jl#L408-L461">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.Approximations.OctDirections"><a class="docstring-binding" href="#LazySets.Approximations.OctDirections"><code>LazySets.Approximations.OctDirections</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OctDirections{N, VN} &lt;: AbstractDirections{N, VN}</code></pre><p>Octagon directions representation.</p><p><strong>Fields</strong></p><ul><li><code>n</code> – dimension</li></ul><p><strong>Notes</strong></p><p>Octagon directions consist of all vectors that are zero almost everywhere except in two dimensions <span>$i$</span>, <span>$j$</span> (possibly <span>$i = j$</span>) where it is <span>$±1$</span>. In dimension <span>$n$</span>, there are <span>$2n^2$</span> such directions.</p><p><strong>Examples</strong></p><p>The template can be constructed by passing the dimension. For example, in dimension two:</p><pre><code class="language-julia-repl hljs">julia&gt; dirs = OctDirections(2)
OctDirections{Float64, SparseArrays.SparseVector{Float64, Int64}}(2)

julia&gt; length(dirs) # number of directions
8</code></pre><p>By default, the directions are represented as sparse vectors:</p><pre><code class="language-julia-repl hljs">julia&gt; eltype(dirs)
SparseArrays.SparseVector{Float64, Int64}</code></pre><p>In two dimensions, the directions are normal to the facets of an octagon.</p><pre><code class="language-julia-repl hljs">julia&gt; first(dirs)
2-element SparseArrays.SparseVector{Float64, Int64} with 2 stored entries:
  [1]  =  1.0
  [2]  =  1.0

julia&gt; Vector.(collect(dirs))
8-element Vector{Vector{Float64}}:
 [1.0, 1.0]
 [1.0, -1.0]
 [-1.0, 1.0]
 [-1.0, -1.0]
 [1.0, 0.0]
 [0.0, 1.0]
 [0.0, -1.0]
 [-1.0, 0.0]</code></pre><p>The numeric type can be specified as well:</p><pre><code class="language-julia-repl hljs">julia&gt; dirs = OctDirections{Rational{Int}}(10)
OctDirections{Rational{Int64}, SparseArrays.SparseVector{Rational{Int64}, Int64}}(10)

julia&gt; length(dirs)
200</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a6c8134409f3968342f8110c90f5f6c867e3dd08/src/Approximations/template_directions.jl#L259-L321">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.Approximations.BoxDiagDirections"><a class="docstring-binding" href="#LazySets.Approximations.BoxDiagDirections"><code>LazySets.Approximations.BoxDiagDirections</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BoxDiagDirections{N, VN} &lt;: AbstractDirections{N, VN}</code></pre><p>Box-diagonal directions representation.</p><p><strong>Fields</strong></p><ul><li><code>n</code> – dimension</li></ul><p><strong>Notes</strong></p><p>Box-diagonal directions can be seen as the union of diagonal directions (all entries are ±1) and box directions (one entry is ±1, all other entries are 0). The iterator first enumerates all diagonal directions and then all box directions. In dimension <span>$n$</span>, there are in total <span>$2^n + 2n$</span> such directions (exception: for <span>$n = 1$</span>, there are <span>$2$</span> directions).</p><p><strong>Examples</strong></p><p>The template can be constructed by passing the dimension. For example, in two dimensions:</p><pre><code class="language-julia-repl hljs">julia&gt; dirs = BoxDiagDirections(2)
BoxDiagDirections{Float64, Vector{Float64}}(2)

julia&gt; length(dirs) # number of directions
8</code></pre><p>By default, each direction is represented as a regular vector:</p><pre><code class="language-julia-repl hljs">julia&gt; eltype(dirs)
Vector{Float64} (alias for Array{Float64, 1})</code></pre><p>In two dimensions, the directions are normal to the facets of an octagon, i.e., the template coincides with <a href="#LazySets.Approximations.OctDirections"><code>OctDirections</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; collect(dirs)
8-element Vector{Vector{Float64}}:
 [1.0, 1.0]
 [-1.0, 1.0]
 [1.0, -1.0]
 [-1.0, -1.0]
 [1.0, 0.0]
 [0.0, 1.0]
 [0.0, -1.0]
 [-1.0, 0.0]</code></pre><p>The numeric type can be specified as well:</p><pre><code class="language-julia-repl hljs">julia&gt; dirs = BoxDiagDirections{Rational{Int}}(10)
BoxDiagDirections{Rational{Int64}, Vector{Rational{Int64}}}(10)

julia&gt; length(dirs)
1044</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a6c8134409f3968342f8110c90f5f6c867e3dd08/src/Approximations/template_directions.jl#L501-L561">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.Approximations.PolarDirections"><a class="docstring-binding" href="#LazySets.Approximations.PolarDirections"><code>LazySets.Approximations.PolarDirections</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PolarDirections{N&lt;:AbstractFloat, VN&lt;:AbstractVector{N}} &lt;: AbstractDirections{N, VN}</code></pre><p>Polar directions representation.</p><p><strong>Fields</strong></p><ul><li><code>Nφ</code>         – length of the partition of the polar angle</li><li><code>directions</code> – list of computed directions</li></ul><p><strong>Notes</strong></p><p>The <code>PolarDirections</code> constructor computes a sample of the unit sphere in <span>$ℝ^2$</span>, which is parameterized by the polar angle <span>$φ ∈ Dφ := [0, 2π]$</span>; see the Wikipedia entry on the <a href="https://en.wikipedia.org/wiki/Polar_coordinate_system">polar coordinate system</a> for details. The resulting directions are stored in <code>directions</code>.</p><p>The integer argument <span>$Nφ$</span> defines how many samples of <span>$Dφ$</span> are taken. The Cartesian components of each direction are obtained with</p><p class="math-container">\[[cos(φᵢ), sin(φᵢ)].\]</p><p><strong>Examples</strong></p><p>The integer passed as an argument is used to discretize <span>$φ$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; pd = PolarDirections(2);

julia&gt; pd.directions
2-element Vector{Vector{Float64}}:
 [1.0, 0.0]
 [-1.0, 1.2246467991473532e-16]

julia&gt; length(pd)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a6c8134409f3968342f8110c90f5f6c867e3dd08/src/Approximations/template_directions.jl#L618-L658">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.Approximations.SphericalDirections"><a class="docstring-binding" href="#LazySets.Approximations.SphericalDirections"><code>LazySets.Approximations.SphericalDirections</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SphericalDirections{N&lt;:AbstractFloat, VN&lt;:AbstractVector{N}} &lt;: AbstractDirections{N, VN}</code></pre><p>Spherical directions representation.</p><p><strong>Fields</strong></p><ul><li><code>Nθ</code>         – length of the partition of the azimuthal angle</li><li><code>Nφ</code>         – length of the partition of the polar angle</li><li><code>directions</code> – list of computed directions</li></ul><p><strong>Notes</strong></p><p>The <code>SphericalDirections</code> constructor provides a sample of the unit sphere in <span>$ℝ^3$</span>, which is parameterized by the azimuthal and polar angles <span>$θ ∈ Dθ := [0, π]$</span> and <span>$φ ∈ Dφ := [0, 2π]$</span> respectively; see the Wikipedia entry on the <a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system">spherical coordinate system</a> for details.</p><p>The integer arguments <span>$Nθ$</span> and <span>$Nφ$</span> define how many samples along the domains <span>$Dθ$</span> and <span>$Dφ$</span> are respectively taken. The Cartesian components of each direction are obtained with</p><p class="math-container">\[[sin(θᵢ)*cos(φᵢ), sin(θᵢ)*sin(φᵢ), cos(θᵢ)].\]</p><p>The north and south poles are treated separately so that those points are not considered more than once.</p><p><strong>Examples</strong></p><p>The template can be built in different ways. If you pass only one integer, the same value is used to discretize both <span>$θ$</span> and <span>$φ$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; sd = SphericalDirections(3);

julia&gt; sd.Nθ, sd.Nφ
(3, 3)

julia&gt; length(sd)
4</code></pre><p>Pass two integers to control the discretization in <span>$θ$</span> and in <span>$φ$</span> separately:</p><pre><code class="language-julia-repl hljs">julia&gt; sd = SphericalDirections(4, 5);

julia&gt; length(sd)
10

julia&gt; sd = SphericalDirections(4, 8);

julia&gt; length(sd)
16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a6c8134409f3968342f8110c90f5f6c867e3dd08/src/Approximations/template_directions.jl#L697-L757">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LazySets.Approximations.CustomDirections"><a class="docstring-binding" href="#LazySets.Approximations.CustomDirections"><code>LazySets.Approximations.CustomDirections</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CustomDirections{N, VN&lt;:AbstractVector{N}} &lt;: AbstractDirections{N, VN}</code></pre><p>User-defined direction vectors.</p><p><strong>Fields</strong></p><ul><li><code>directions</code>          – list of direction vectors</li><li><code>n</code>                   – (optional; default: computed from <code>directions</code>)                          dimension</li><li><code>check_boundedness</code>   – (optional; default: <code>true</code>) flag to check boundedness</li><li><code>check_normalization</code> – (optional; default: <code>true</code>) flag to check whether all                          directions are normalized</li></ul><p><strong>Notes</strong></p><p>This struct is a wrapper for a list of user-defined directions. There are fields for the list of directions, their dimension, and (boolean) cache fields for the boundedness and normalization properties. The latter are checked by default upon construction.</p><p>To check boundedness, we construct the polyhedron with constraints <span>$d·x &lt;= 1$</span> for each direction <span>$d$</span> and check if this set is bounded. (Note that the bound <span>$1$</span> is arbitrary and that this set may be empty, which however implies boundedness.)</p><p>The dimension will also be determined automatically, unless the empty vector is passed (in which case the optional argument <code>n</code> needs to be specified).</p><p><strong>Examples</strong></p><p>Create a template with box directions in dimension two:</p><pre><code class="language-julia-repl hljs">julia&gt; dirs = CustomDirections([[1.0, 0.0], [-1.0, 0.0], [0.0, 1.0], [0.0, -1.0]]);

julia&gt; dirs.directions
4-element Vector{Vector{Float64}}:
 [1.0, 0.0]
 [-1.0, 0.0]
 [0.0, 1.0]
 [0.0, -1.0]

julia&gt; isbounding(dirs)
true

julia&gt; LazySets.Approximations.isnormalized(dirs)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a6c8134409f3968342f8110c90f5f6c867e3dd08/src/Approximations/template_directions.jl#L813-L862">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../iterative_refinement/">« Iterative refinement</a><a class="docs-footer-nextpage" href="../underapproximate/">Underapproximation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 4 January 2026 09:37">Sunday 4 January 2026</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
