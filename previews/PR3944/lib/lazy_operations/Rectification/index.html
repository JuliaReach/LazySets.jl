<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rectification · LazySets.jl</title><meta name="title" content="Rectification · LazySets.jl"/><meta property="og:title" content="Rectification · LazySets.jl"/><meta property="twitter:title" content="Rectification · LazySets.jl"/><meta name="description" content="Documentation for LazySets.jl."/><meta property="og:description" content="Documentation for LazySets.jl."/><meta property="twitter:description" content="Documentation for LazySets.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/aligned.css" rel="stylesheet" type="text/css"/><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">LazySets.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../../man/optional_dependencies/">Optional Features</a></li><li><a class="tocitem" href="../../../man/tour/">A Tour of LazySets</a></li><li><a class="tocitem" href="../../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../../man/unary_set_operations/">Unary Operations on Sets</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../API/">API</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Set Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../interfaces/overview/">Overview</a></li><li><a class="tocitem" href="../../interfaces/LazySet/">General sets (LazySet)</a></li><li><a class="tocitem" href="../../interfaces/ConvexSet/">Convex sets (ConvexSet)</a></li><li><a class="tocitem" href="../../interfaces/AbstractCentrallySymmetric/">Centrally symmetric sets (AbstractCentrallySymmetric)</a></li><li><a class="tocitem" href="../../interfaces/AbstractPolyhedron/">Polyhedra (AbstractPolyhedron)</a></li><li><a class="tocitem" href="../../interfaces/AbstractPolytope/">Polytopes (AbstractPolytope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractPolygon/">Polygons (AbstractPolygon)</a></li><li><a class="tocitem" href="../../interfaces/AbstractHPolygon/">Polygons in constraint representation (AbstractHPolygon)</a></li><li><a class="tocitem" href="../../interfaces/AbstractCentrallySymmetricPolytope/">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractZonotope/">Zonotopes (AbstractZonotope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractHyperrectangle/">Hyperrectangles (AbstractHyperrectangle)</a></li><li><a class="tocitem" href="../../interfaces/AbstractSingleton/">Singletons (AbstractSingleton)</a></li><li><a class="tocitem" href="../../interfaces/AbstractAffineMap/">Affine maps (AbstractAffineMap)</a></li><li><a class="tocitem" href="../../interfaces/AbstractPolynomialZonotope/">Polynomial zonotope sets (AbstractPolynomialZonotope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractSparsePolynomialZonotope/">Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)</a></li><li><a class="tocitem" href="../../interfaces/AbstractBallp/">Balls in the p-norm (AbstractBallp)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">MatrixSets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../matrixsets/MatrixZonotope/">MatrixZonotope</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../../sets/DensePolynomialZonotope/">DensePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../../sets/HParallelotope/">HParallelotope</a></li><li><a class="tocitem" href="../../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../../sets/Line/">Line</a></li><li><a class="tocitem" href="../../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../../sets/Polygon/">Polygon</a></li><li><a class="tocitem" href="../../sets/SimpleSparsePolynomialZonotope/">SimpleSparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/SparsePolynomialZonotope/">SparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../../sets/Star/">Star</a></li><li><a class="tocitem" href="../../sets/Tetrahedron/">Tetrahedron</a></li><li><a class="tocitem" href="../../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../../sets/Zonotope/">Zonotope</a></li><li><a class="tocitem" href="../../sets/ZonotopeMD/">ZonotopeMD</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox" checked/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../Bloating/">Bloating</a></li><li><a class="tocitem" href="../CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../Complement/">Complement</a></li><li><a class="tocitem" href="../ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../Intersection/">Intersection</a></li><li><a class="tocitem" href="../LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../InverseLinearMap/">InverseLinearMap</a></li><li><a class="tocitem" href="../MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../QuadraticMap/">QuadraticMap</a></li><li class="is-active"><a class="tocitem" href>Rectification</a><ul class="internal"><li><a class="tocitem" href="#Rectification-cache"><span>Rectification cache</span></a></li></ul></li><li><a class="tocitem" href="../ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../Translation/">Translation</a></li><li><a class="tocitem" href="../UnionSet/">UnionSet</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-6" type="checkbox"/><label class="tocitem" for="menuitem-3-6"><span class="docs-label">Concrete Binary Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../concrete_binary_operations/overview/">Binary set operations</a></li><li><a class="tocitem" href="../../concrete_binary_operations/cartesian_product/">Cartesian Product</a></li><li><a class="tocitem" href="../../concrete_binary_operations/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../concrete_binary_operations/difference/">Set difference</a></li><li><a class="tocitem" href="../../concrete_binary_operations/distance/">Distance</a></li><li><a class="tocitem" href="../../concrete_binary_operations/intersection/">Intersection of two sets</a></li><li><a class="tocitem" href="../../concrete_binary_operations/minkowski_sum/">Minkowski Sum</a></li><li><a class="tocitem" href="../../concrete_binary_operations/minkowski_difference/">Minkowski Difference</a></li><li><a class="tocitem" href="../../concrete_binary_operations/isdisjoint/">Check for Disjointness of Sets</a></li><li><a class="tocitem" href="../../concrete_binary_operations/issubset/">Subset Check</a></li></ul></li><li><a class="tocitem" href="../../conversion/">Conversions between set representations</a></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">Approximations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../approximations/overview/">Overview</a></li><li><a class="tocitem" href="../../approximations/overapproximate/">Overapproximation</a></li><li><a class="tocitem" href="../../approximations/box_approximation/">Box Approximation</a></li><li><a class="tocitem" href="../../approximations/iterative_refinement/">Iterative refinement</a></li><li><a class="tocitem" href="../../approximations/template_directions/">Template directions</a></li><li><a class="tocitem" href="../../approximations/underapproximate/">Underapproximation</a></li><li><a class="tocitem" href="../../approximations/approximate/">Approximation</a></li><li><a class="tocitem" href="../../approximations/decompose/">Cartesian Decomposition</a></li><li><a class="tocitem" href="../../approximations/hausdorff_distance/">Hausdorff Distance</a></li><li><a class="tocitem" href="../../approximations/overapproximate_norm/">Norm Overapproximation</a></li></ul></li><li><a class="tocitem" href="../../utils/">Utilities</a></li><li><a class="tocitem" href="../../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li><a class="is-disabled">Lazy Operations</a></li><li class="is-active"><a href>Rectification</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Rectification</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/lazy_operations/Rectification.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="def_Rectification"><a class="docs-heading-anchor" href="#def_Rectification">Rectification</a><a id="def_Rectification-1"></a><a class="docs-heading-anchor-permalink" href="#def_Rectification" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.Rectification" href="#LazySets.Rectification"><code>LazySets.Rectification</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rectification{N, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the rectification of a set.</p><p><strong>Fields</strong></p><ul><li><code>X</code>     – set</li><li><code>cache</code> – storage of information computed before</li></ul><p><strong>Notes</strong></p><p>Given a vector <span>$v = (v_1, …, v_n)$</span>, its rectification is defined as <span>$\text{rectify}(v) = (v_1&#39;, …, v_n&#39;)$</span> such that <span>$v_i&#39; = \max(v_i, 0)$</span> for each <span>$i = 1, …, n$</span>.</p><p>The extension to a set <span>$X$</span> is defined elementwise:</p><p class="math-container">\[    \text{rectify}(X) = \{\text{rectify}(x) \mid x ∈ X\}\]</p><p>The rectification of a convex set <span>$X$</span> is not necessarily convex.</p><p>It can be expressed exactly as the union of the intersection of <span>$X$</span> with the nonnegative orthant and the projection of the intersection of <span>$X$</span> with each other orthant. This can be seen as follows.</p><p>First we observe that rectification distributes with union.</p><p class="math-container">\[    \text{rectify}(X_1 ∪ … ∪ X_m) = ⋃_j \text{rectify}(X_j)\]</p><p>Next we express <span>$X$</span> as the union of the intersection of <span>$X$</span> with each orthant <span>$O$</span>.</p><p class="math-container">\[    X = ⋃_j (X ∩ O_j)\]</p><p>Thus we have</p><p class="math-container">\[    \text{rectify}(X) = \text{rectify}((X ∩ O_1) ∪ … ∪ (X ∩ O_m)) = ⋃_j \text{rectify}(X ∩ O_j).\]</p><p>Clearly, <span>$\text{rectify}(X ∩ O_j) = X$</span> if <span>$O_j$</span> is the nonnegative orthant.</p><p>For example, consider a two-dimensional case and call the orthants <span>$O_1, …, O_4$</span> in clockwise fashion, starting with the nonnegative orthant. We conclude that</p><p class="math-container">\[    \text{rectify}(X) = (X ∩ O_1) ∪ \text{rectify}(X ∩ O_2) ∪ \text{rectify}(X ∩ O_3) ∪ \text{rectify}(X ∩ O_4).\]</p><p>The rectification of the intersection in the nonpositive orthant, <span>$\text{rectify}(X ∩ O_3)$</span>, is either the empty set or the singleton containing the origin. The rectification of <span>$X ∩ O_2$</span> and <span>$X ∩ O_4$</span> both result in flat <span>$1$</span>-dimensional line segments on the corresponding hyperplane of <span>$O_1$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/4a96dd29ff3228694555e14fdee3cc5b2a3a3517/src/LazyOperations/Rectification.jl#L26-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.set-Tuple{Rectification}" href="#LazySets.set-Tuple{Rectification}"><code>LazySets.set</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set(R::Rectification)</code></pre><p>Return the original set of a rectification.</p><p><strong>Input</strong></p><ul><li><code>R</code> – rectification</li></ul><p><strong>Output</strong></p><p>The original set of the rectification.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/4a96dd29ff3228694555e14fdee3cc5b2a3a3517/src/LazyOperations/Rectification.jl#L123-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.dim-Tuple{Rectification}" href="#LazySets.API.dim-Tuple{Rectification}"><code>LazySets.API.dim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dim(R::Rectification)</code></pre><p>Return the dimension of a rectification.</p><p><strong>Input</strong></p><ul><li><code>R</code> – rectification</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the rectification.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/4a96dd29ff3228694555e14fdee3cc5b2a3a3517/src/LazyOperations/Rectification.jl#L140-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.σ-Tuple{AbstractVector, Rectification}" href="#LazySets.API.σ-Tuple{AbstractVector, Rectification}"><code>LazySets.API.σ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, R::Rectification)</code></pre><p>Return a support vector of a rectification.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>R</code> – rectification</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/4a96dd29ff3228694555e14fdee3cc5b2a3a3517/src/LazyOperations/Rectification.jl#L157-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.σ-Union{Tuple{N}, Tuple{AbstractVector, Rectification{N, &lt;:AbstractHyperrectangle}}} where N" href="#LazySets.API.σ-Union{Tuple{N}, Tuple{AbstractVector, Rectification{N, &lt;:AbstractHyperrectangle}}} where N"><code>LazySets.API.σ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, R::Rectification{N, &lt;:AbstractHyperrectangle}) where {N}</code></pre><p>Return a support vector of the rectification of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>R</code> – rectification of a hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>Let <span>$R(·)$</span> be the rectification of a vector respectively a set, and let <span>$H$</span> be a hyperrectangle. Then <span>$σ_{R(H)}(d) = R(σ_{H}(d))$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/4a96dd29ff3228694555e14fdee3cc5b2a3a3517/src/LazyOperations/Rectification.jl#L177-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.σ-Union{Tuple{N}, Tuple{AbstractVector, Rectification{N, &lt;:CartesianProduct}}} where N" href="#LazySets.API.σ-Union{Tuple{N}, Tuple{AbstractVector, Rectification{N, &lt;:CartesianProduct}}} where N"><code>LazySets.API.σ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, R::Rectification{N, &lt;:CartesianProduct}) where {N}</code></pre><p>Return a support vector of the rectification of a Cartesian product of two sets.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>R</code> – rectification of a Cartesian product of two sets</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction.</p><p><strong>Notes</strong></p><p>Note that this implementation creates new <code>Rectification</code> objects that do not get preserved. Hence a second support-vector query does not benefit from the computations in the first query. For this use case another implementation should be added.</p><p><strong>Algorithm</strong></p><p>Rectification distributes with the Cartesian product. Let <span>$R(·)$</span> be the rectification of a set. We can just query a support vector for <span>$R(X)$</span> and <span>$R(Y)$</span> recursively: <span>$σ_{R(X × Y)}(d) = σ_{R(X)}(d_X) × σ_{R(Y)}(d_Y)$</span>, where <span>$x × y$</span> concatenates vectors <span>$x$</span> and <span>$y$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/4a96dd29ff3228694555e14fdee3cc5b2a3a3517/src/LazyOperations/Rectification.jl#L200-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.σ-Union{Tuple{N}, Tuple{AbstractVector, Rectification{N, &lt;:CartesianProductArray}}} where N" href="#LazySets.API.σ-Union{Tuple{N}, Tuple{AbstractVector, Rectification{N, &lt;:CartesianProductArray}}} where N"><code>LazySets.API.σ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector,
  R::Rectification{N, &lt;:CartesianProductArray}) where {N}</code></pre><p>Return a support vector of the rectification of a Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>R</code> – rectification of a Cartesian product of a finite number of sets</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction.</p><p><strong>Notes</strong></p><p>Note that this implementation creates new <code>Rectification</code> objects that do not get preserved. Hence a second support-vector query does not benefit from the computations in the first query. For this use case another implementation should be added.</p><p><strong>Algorithm</strong></p><p>Rectification distributes with the Cartesian product. Let <span>$R(·)$</span> be the rectification of a set. We can just query a support vector for each subspace recursively: <span>$σ_{R(X_1 × ⋯ × X_m)}(d) = σ_{R(X_1)}(d_{X_1}) × ⋯ × σ_{R(X_m)}(d_{X_m})$</span>, where <span>$x × y$</span> concatenates vectors <span>$x$</span> and <span>$y$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/4a96dd29ff3228694555e14fdee3cc5b2a3a3517/src/LazyOperations/Rectification.jl#L236-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.ρ-Tuple{AbstractVector, Rectification}" href="#LazySets.API.ρ-Tuple{AbstractVector, Rectification}"><code>LazySets.API.ρ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, R::Rectification)</code></pre><p>Evaluate the support function of a rectification in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>R</code> – rectification</li></ul><p><strong>Output</strong></p><p>The support value of the rectification in the given direction.</p><p><strong>Algorithm</strong></p><p>We use different procedures for different types of input sets. If the wrapped set has a suitable structure for which we can efficiently compute the support vector, we fall back to the evaluation of the support function by means of the support vector. Otherwise we compute the union of projections to obtain a precise result (see <a href="#LazySets.to_union_of_projections"><code>to_union_of_projections</code></a>), and then compute the support function for this union. (The union is cached internally, so subsequent queries are more efficient.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/4a96dd29ff3228694555e14fdee3cc5b2a3a3517/src/LazyOperations/Rectification.jl#L280-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.an_element-Tuple{Rectification}" href="#LazySets.API.an_element-Tuple{Rectification}"><code>LazySets.API.an_element</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">an_element(R::Rectification)</code></pre><p>Return some element of a rectification.</p><p><strong>Input</strong></p><ul><li><code>R</code> – rectification</li></ul><p><strong>Output</strong></p><p>An element in the rectification. The implementation relies on the <code>an_element</code> function of the wrapped set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/4a96dd29ff3228694555e14fdee3cc5b2a3a3517/src/LazyOperations/Rectification.jl#L314-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:∈-Tuple{AbstractVector, Rectification}" href="#Base.:∈-Tuple{AbstractVector, Rectification}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∈(x::AbstractVector, R::Rectification)</code></pre><p>Check whether a given point is contained in a rectification.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>R</code> – rectification</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ R$</span>.</p><p><strong>Algorithm</strong></p><p>We first scan for negative entries in the vector. If there are any, the vector is not contained in the rectification.</p><p>Next we ask a membership query in the wrapped set. If the answer is positive, the vector is contained in the rectification. (This holds because negative entries have been ruled out before.)</p><p>Otherwise, we scan for zero entries in the vector. If there are none, membership reduces to membership in the wrapped set, and so the answer is negative.</p><p>Finally, if there are zero entries in the vector and the vector is not contained in the wrapped set, we give up and throw an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/4a96dd29ff3228694555e14fdee3cc5b2a3a3517/src/LazyOperations/Rectification.jl#L332-L361">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isempty-Tuple{Rectification}" href="#Base.isempty-Tuple{Rectification}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isempty(R::Rectification)</code></pre><p>Check whether a rectification is empty.</p><p><strong>Input</strong></p><ul><li><code>R</code> – rectification</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/4a96dd29ff3228694555e14fdee3cc5b2a3a3517/src/LazyOperations/Rectification.jl#L384-L396">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isbounded-Tuple{Rectification}" href="#LazySets.API.isbounded-Tuple{Rectification}"><code>LazySets.API.isbounded</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isbounded(R::Rectification)</code></pre><p>Check whether a rectification is bounded.</p><p><strong>Input</strong></p><ul><li><code>R</code> – rectification</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the rectification is bounded.</p><p><strong>Algorithm</strong></p><p>Let <span>$X$</span> be the set wrapped by rectification <span>$R$</span>. We first check whether <span>$X$</span> is bounded (because then <span>$R$</span> is bounded). Otherwise, we check unboundedness of <span>$X$</span> in direction <span>$(1, 1, …, 1)$</span>, which is sufficient for unboundedness of <span>$R$</span>; this step is not necessary but rather a heuristics. Otherwise, we check boundedness of <span>$X$</span> in every positive unit direction, which is sufficient and necessary for boundedness of <span>$R$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/4a96dd29ff3228694555e14fdee3cc5b2a3a3517/src/LazyOperations/Rectification.jl#L401-L423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.to_union_of_projections" href="#LazySets.to_union_of_projections"><code>LazySets.to_union_of_projections</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_union_of_projections(R::Rectification,
                        [concrete_intersection]::Bool=false) where</code></pre><p>Compute an equivalent union of projections from a rectification.</p><p><strong>Input</strong></p><ul><li><code>R</code>                     – rectification</li><li><code>concrete_intersection</code> – (optional, default: <code>false</code>) option to compute                            all intersections concretely or lazily</li><li><code>filter_empty_sets</code>     – (optional, default: <code>true</code>) option to filter out                            empty sets in the union</li></ul><p><strong>Algorithm</strong></p><p>Let <span>$X$</span> be the set wrapped by the rectification <span>$R$</span>. We compute a union of sets that represents the rectification of <span>$X$</span> precisely. The sets are lazy projections, potentially of intersections.</p><p>We first identify those dimensions where <span>$X$</span> is negative, using one call to <code>low</code> per dimension, and collect the dimensions in the index set <span>$I_\text{neg}$</span>. For each element in <span>$I_\text{neg}$</span> we will later apply a projection to zero.</p><p>Next we identify those dimensions from <span>$I_\text{neg}$</span> where <span>$X$</span> is also positive, using another <code>high</code> query in each dimension, and collect the dimensions in the index set <span>$I_\text{mix}$</span>. Let us call the remaining dimensions (<span>$I_\text{neg} ∖ I_\text{mix}$</span>) <span>$I_\text{nonpos}$</span>. For each dimension in <span>$j ∈ I_\text{mix}$</span> we will apply an intersection with axis-aligned polyhedra. In particular, we distinguish two cases using half-spaces <span>$x_j ≤ 0$</span> and <span>$x_j ≥ 0$</span>, and then compute all possible combinations to intersect, using one half-space per dimension <span>$j ∈ I_\text{mix}$</span>.</p><p>Next we project the intersections in all dimensions from <span>$i ∈ I_\text{mix}$</span> such that we used the half-space <span>$x_i ≤ 0$</span> in their computation, and in all dimensions <span>$j ∈ I_\text{nonpos}$</span> irrespective of the half-space used.</p><p>Finally, we take the union of the resulting sets.</p><p><strong>Output</strong></p><p>The result can be one of three cases depending on the wrapped set <span>$X$</span>, namely</p><ul><li>the set <span>$X$</span> if <span>$X$</span> is contained in the positive quadrant,</li><li>a <code>LinearMap</code> (projection) of <span>$X$</span> if for each dimension, <span>$X$</span> is only either positive or negative, or</li><li>a <code>UnionSetArray</code> of <code>LinearMap</code>s (projections) otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/4a96dd29ff3228694555e14fdee3cc5b2a3a3517/src/LazyOperations/Rectification.jl#L450-L499">source</a></section></article><p>Inherited from <a href="../../interfaces/LazySet/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../../interfaces/LazySet/#LazySets.singleton_list-Tuple{LazySet}"><code>singleton_list</code></a></li></ul><h2 id="Rectification-cache"><a class="docs-heading-anchor" href="#Rectification-cache">Rectification cache</a><a id="Rectification-cache-1"></a><a class="docs-heading-anchor-permalink" href="#Rectification-cache" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.RectificationCache" href="#LazySets.RectificationCache"><code>LazySets.RectificationCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RectificationCache{N}</code></pre><p>Struct that is used as a cache for <a href="#LazySets.Rectification"><code>Rectification</code></a>s.</p><p><strong>Fields</strong></p><ul><li><code>set</code>                – set represented by the rectification (can be <code>nothing</code>                         if not computed yet)</li><li><code>use_support_vector</code> – flag indicating whether to use support-vector                         computations for the cached set</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/4a96dd29ff3228694555e14fdee3cc5b2a3a3517/src/LazyOperations/Rectification.jl#L3-L14">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../QuadraticMap/">« QuadraticMap</a><a class="docs-footer-nextpage" href="../ResetMap/">ResetMap »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 13 July 2025 04:52">Sunday 13 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
