<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>General sets (LazySet) · LazySets.jl</title><meta name="title" content="General sets (LazySet) · LazySets.jl"/><meta property="og:title" content="General sets (LazySet) · LazySets.jl"/><meta property="twitter:title" content="General sets (LazySet) · LazySets.jl"/><meta name="description" content="Documentation for LazySets.jl."/><meta property="og:description" content="Documentation for LazySets.jl."/><meta property="twitter:description" content="Documentation for LazySets.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/aligned.css" rel="stylesheet" type="text/css"/><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">LazySets.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../../man/optional_dependencies/">Optional Features</a></li><li><a class="tocitem" href="../../../man/tour/">A Tour of LazySets</a></li><li><a class="tocitem" href="../../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../../man/unary_set_operations/">Unary Operations on Sets</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../API/">API</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox" checked/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Set Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li class="is-active"><a class="tocitem" href>General sets (LazySet)</a><ul class="internal"><li><a class="tocitem" href="#Support-vector-and-support-function"><span>Support vector and support function</span></a></li><li><a class="tocitem" href="#Globally-defined-set-functions-and-default-implementations"><span>Globally defined set functions and default implementations</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#Aliases-for-set-types"><span>Aliases for set types</span></a></li><li><a class="tocitem" href="#Implementations"><span>Implementations</span></a></li></ul></li><li><a class="tocitem" href="../ConvexSet/">Convex sets (ConvexSet)</a></li><li><a class="tocitem" href="../AbstractCentrallySymmetric/">Centrally symmetric sets (AbstractCentrallySymmetric)</a></li><li><a class="tocitem" href="../AbstractPolyhedron/">Polyhedra (AbstractPolyhedron)</a></li><li><a class="tocitem" href="../AbstractPolytope/">Polytopes (AbstractPolytope)</a></li><li><a class="tocitem" href="../AbstractPolygon/">Polygons (AbstractPolygon)</a></li><li><a class="tocitem" href="../AbstractHPolygon/">Polygons in constraint representation (AbstractHPolygon)</a></li><li><a class="tocitem" href="../AbstractCentrallySymmetricPolytope/">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a></li><li><a class="tocitem" href="../AbstractZonotope/">Zonotopes (AbstractZonotope)</a></li><li><a class="tocitem" href="../AbstractHyperrectangle/">Hyperrectangles (AbstractHyperrectangle)</a></li><li><a class="tocitem" href="../AbstractSingleton/">Singletons (AbstractSingleton)</a></li><li><a class="tocitem" href="../AbstractAffineMap/">Affine maps (AbstractAffineMap)</a></li><li><a class="tocitem" href="../AbstractPolynomialZonotope/">Polynomial zonotope sets (AbstractPolynomialZonotope)</a></li><li><a class="tocitem" href="../AbstractSparsePolynomialZonotope/">Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)</a></li><li><a class="tocitem" href="../AbstractBallp/">Balls in the p-norm (AbstractBallp)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../../sets/DensePolynomialZonotope/">DensePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../../sets/HParallelotope/">HParallelotope</a></li><li><a class="tocitem" href="../../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../../sets/Line/">Line</a></li><li><a class="tocitem" href="../../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../../sets/Polygon/">Polygon</a></li><li><a class="tocitem" href="../../sets/SimpleSparsePolynomialZonotope/">SimpleSparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/SparsePolynomialZonotope/">SparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../../sets/Star/">Star</a></li><li><a class="tocitem" href="../../sets/Tetrahedron/">Tetrahedron</a></li><li><a class="tocitem" href="../../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../../sets/Zonotope/">Zonotope</a></li><li><a class="tocitem" href="../../sets/ZonotopeMD/">ZonotopeMD</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lazy_operations/AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../../lazy_operations/Bloating/">Bloating</a></li><li><a class="tocitem" href="../../lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../../lazy_operations/Complement/">Complement</a></li><li><a class="tocitem" href="../../lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../../lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../../lazy_operations/Intersection/">Intersection</a></li><li><a class="tocitem" href="../../lazy_operations/LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../../lazy_operations/InverseLinearMap/">InverseLinearMap</a></li><li><a class="tocitem" href="../../lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../../lazy_operations/QuadraticMap/">QuadraticMap</a></li><li><a class="tocitem" href="../../lazy_operations/Rectification/">Rectification</a></li><li><a class="tocitem" href="../../lazy_operations/ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../../lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../../lazy_operations/Translation/">Translation</a></li><li><a class="tocitem" href="../../lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Concrete Binary Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../concrete_binary_operations/overview/">Binary set operations</a></li><li><a class="tocitem" href="../../concrete_binary_operations/cartesian_product/">Cartesian Product</a></li><li><a class="tocitem" href="../../concrete_binary_operations/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../concrete_binary_operations/difference/">Set difference</a></li><li><a class="tocitem" href="../../concrete_binary_operations/distance/">Distance</a></li><li><a class="tocitem" href="../../concrete_binary_operations/intersection/">Intersection of two sets</a></li><li><a class="tocitem" href="../../concrete_binary_operations/minkowski_sum/">Minkowski Sum</a></li><li><a class="tocitem" href="../../concrete_binary_operations/minkowski_difference/">Minkowski Difference</a></li><li><a class="tocitem" href="../../concrete_binary_operations/isdisjoint/">Check for Disjointness of Sets</a></li><li><a class="tocitem" href="../../concrete_binary_operations/issubset/">Subset Check</a></li></ul></li><li><a class="tocitem" href="../../conversion/">Conversions between set representations</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Approximations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../approximations/overview/">Overview</a></li><li><a class="tocitem" href="../../approximations/overapproximate/">Overapproximation</a></li><li><a class="tocitem" href="../../approximations/box_approximation/">Box Approximation</a></li><li><a class="tocitem" href="../../approximations/iterative_refinement/">Iterative refinement</a></li><li><a class="tocitem" href="../../approximations/template_directions/">Template directions</a></li><li><a class="tocitem" href="../../approximations/underapproximate/">Underapproximation</a></li><li><a class="tocitem" href="../../approximations/approximate/">Approximation</a></li><li><a class="tocitem" href="../../approximations/decompose/">Cartesian Decomposition</a></li><li><a class="tocitem" href="../../approximations/hausdorff_distance/">Hausdorff Distance</a></li><li><a class="tocitem" href="../../approximations/overapproximate_norm/">Norm Overapproximation</a></li><li><a class="tocitem" href="../../approximations/overapproximate_expmap/">Overapproximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">MatrixSets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../matrixsets/MatrixZonotope/">MatrixZonotope</a></li></ul></li><li><a class="tocitem" href="../../utils/">Utilities</a></li><li><a class="tocitem" href="../../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li><a class="is-disabled">Set Interfaces</a></li><li class="is-active"><a href>General sets (LazySet)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>General sets (LazySet)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/interfaces/LazySet.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#def_LazySet">General sets (LazySet)</a></li><li class="no-marker"><ul><li><a href="#Support-vector-and-support-function">Support vector and support function</a></li><li><a href="#Globally-defined-set-functions-and-default-implementations">Globally defined set functions and default implementations</a></li><li><a href="#Plotting">Plotting</a></li><li><a href="#Aliases-for-set-types">Aliases for set types</a></li><li><a href="#Implementations">Implementations</a></li></ul></li></ul><h1 id="def_LazySet"><a class="docs-heading-anchor" href="#def_LazySet">General sets (LazySet)</a><a id="def_LazySet-1"></a><a class="docs-heading-anchor-permalink" href="#def_LazySet" title="Permalink"></a></h1><p>Every set type in this library is a subtype of the abstract type <code>LazySet</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.LazySet" href="#LazySets.LazySet"><code>LazySets.LazySet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LazySet{N}</code></pre><p>Abstract type for the set types in LazySets.</p><p><strong>Notes</strong></p><p><code>LazySet</code> types should be parameterized with a type <code>N</code>, typically <code>N&lt;:Real</code>, for using different numeric types.</p><p>Every <code>LazySet</code> must implement the following function:</p><ul><li><code>dim(X::LazySet)</code> – the ambient dimension of <code>X</code></li></ul><p>While not strictly required, it is useful to implement the following function:</p><ul><li><code>σ(d::AbstractVector, X::LazySet)</code> – the support vector of <code>X</code> in a given   direction <code>d</code></li></ul><p>Implementing the function</p><ul><li><code>ρ(d::AbstractVector, X::LazySet)</code> – the support function of <code>X</code> in a given   direction <code>d</code></li></ul><p>is optional because there is a fallback implementation relying on <code>σ</code>. However, for potentially unbounded sets (which includes most lazy set types) this fallback cannot be used and an explicit implementation should be provided.</p><p>The subtypes of <code>LazySet</code> (including abstract interfaces):</p><pre><code class="language-julia-repl hljs">julia&gt; subtypes(LazySet, false)
17-element Vector{Any}:
 AbstractAffineMap
 AbstractPolynomialZonotope
 Bloating
 CachedMinkowskiSumArray
 CartesianProduct
 CartesianProductArray
 Complement
 ConvexSet
 Intersection
 IntersectionArray
 MinkowskiSum
 MinkowskiSumArray
 Polygon
 QuadraticMap
 Rectification
 UnionSet
 UnionSetArray</code></pre><p>If we only consider <em>concrete</em> subtypes, then:</p><pre><code class="language-julia-repl hljs">julia&gt; concrete_subtypes = subtypes(LazySet, true);

julia&gt; length(concrete_subtypes)
54

julia&gt; println.(concrete_subtypes);
AffineMap
Ball1
Ball2
BallInf
Ballp
Bloating
CachedMinkowskiSumArray
CartesianProduct
CartesianProductArray
Complement
ConvexHull
ConvexHullArray
DensePolynomialZonotope
Ellipsoid
EmptySet
ExponentialMap
ExponentialProjectionMap
HParallelotope
HPolygon
HPolygonOpt
HPolyhedron
HPolytope
HalfSpace
Hyperplane
Hyperrectangle
Intersection
IntersectionArray
Interval
InverseLinearMap
Line
Line2D
LineSegment
LinearMap
MinkowskiSum
MinkowskiSumArray
Polygon
QuadraticMap
Rectification
ResetMap
SimpleSparsePolynomialZonotope
Singleton
SparsePolynomialZonotope
Star
SymmetricIntervalHull
Tetrahedron
Translation
UnionSet
UnionSetArray
Universe
VPolygon
VPolytope
ZeroSet
Zonotope
ZonotopeMD</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet.jl#L3-L119">source</a></section></article><p>This interface requires to implement the following function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.dim-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.dim-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.dim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dim(X::LazySet)</code></pre><p>Compute the ambient dimension of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/dim.jl#L1-L13">source</a></section></article><h2 id="Support-vector-and-support-function"><a class="docs-heading-anchor" href="#Support-vector-and-support-function">Support vector and support function</a><a id="Support-vector-and-support-function-1"></a><a class="docs-heading-anchor-permalink" href="#Support-vector-and-support-function" title="Permalink"></a></h2><p>Most <code>LazySet</code> types (particularly convex ones) define a function <code>σ</code> to compute the support vector. The support function, <code>ρ</code>, can optionally be defined; otherwise, a fallback definition based on <code>σ</code> is used.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.σ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.σ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">σ(d::AbstractVector, X::LazySet)</code></pre><p>Compute a support vector of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A support vector of <code>X</code> in direction <code>d</code>.</p><p><strong>Notes</strong></p><p>The convenience alias <code>support_vector</code> is also available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Mixed/support_vector.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.ρ-Tuple{AbstractVector, LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.ρ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ρ(d::AbstractVector, X::LazySet)</code></pre><p>Evaluate the support function of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>The evaluation of the support function of <code>X</code> in direction <code>d</code>.</p><p><strong>Notes</strong></p><p>The convenience alias <code>support_function</code> is also available.</p><p>We have the following identity based on the support vector <span>$σ$</span>:</p><p class="math-container">\[    ρ(d, X) = d ⋅ σ(d, X)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Mixed/support_function.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.ρ-Tuple{AbstractVector, LazySet}" href="#LazySets.API.ρ-Tuple{AbstractVector, LazySet}"><code>LazySets.API.ρ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">ρ(d::AbstractVector, X::LazySet)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation computes a support vector via <code>σ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L356-L364">source</a></section></article><h2 id="Globally-defined-set-functions-and-default-implementations"><a class="docs-heading-anchor" href="#Globally-defined-set-functions-and-default-implementations">Globally defined set functions and default implementations</a><a id="Globally-defined-set-functions-and-default-implementations-1"></a><a class="docs-heading-anchor-permalink" href="#Globally-defined-set-functions-and-default-implementations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.an_element-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.an_element-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.an_element</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">an_element(X::LazySet)</code></pre><p>Return some element of a nonempty set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>An element of <code>X</code> unless <code>X</code> is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/an_element.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.an_element-Tuple{LazySet}" href="#LazySets.API.an_element-Tuple{LazySet}"><code>LazySets.API.an_element</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">an_element(X::LazySet)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation computes a support vector along direction <span>$[1, 0, …, 0]$</span>. This may fail for unbounded sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L553-L562">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.area-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.area-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.area</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">area(X::LazySet)</code></pre><p>Compute the area of a two-dimensional set, respectively the surface area of a three-dimensional set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – two- or three-dimensional set</li></ul><p><strong>Output</strong></p><p>A number representing the (surface) area of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/area.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.area-Tuple{LazySet}" href="#LazySets.API.area-Tuple{LazySet}"><code>LazySets.API.area</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">area(X::LazySet)</code></pre><p><strong>Notes</strong></p><p>This algorithm is applicable to any two-dimensional polytopic set <code>X</code> whose list of vertices can be computed via <code>vertices_list</code>.</p><p><strong>Algorithm</strong></p><p>Let <code>m</code> be the number of vertices of <code>X</code>. We consider the following instances:</p><ul><li><code>m = 0, 1, 2</code>: the output is zero.</li><li><code>m = 3</code>: the triangle case is solved using the Shoelace formula with 3 points.</li><li><code>m = 4</code>: the quadrilateral case is solved by the factored version of the          Shoelace formula with 4 points.</li></ul><p>Otherwise, the general Shoelace formula is used; for details see the <a href="https://en.wikipedia.org/wiki/Shoelace_formula">Wikipedia page</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L794-L815">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.chebyshev_center_radius-Tuple{LazySet}" href="#LazySets.chebyshev_center_radius-Tuple{LazySet}"><code>LazySets.chebyshev_center_radius</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chebyshev_center_radius(P::LazySet;
                        [backend]=default_polyhedra_backend(P),
                        [solver]=default_lp_solver_polyhedra(eltype(P); presolve=true))</code></pre><p>Compute a <a href="https://en.wikipedia.org/wiki/Chebyshev_center">Chebyshev center</a> and the corresponding radius of a polytopic set.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polytopic set</li><li><code>backend</code> – (optional; default: <code>default_polyhedra_backend(P)</code>) the backend              for polyhedral computations</li><li><code>solver</code>  – (optional; default:              <code>default_lp_solver_polyhedra(N; presolve=true)</code>) the LP solver              passed to <code>Polyhedra</code></li></ul><p><strong>Output</strong></p><p>The pair <code>(c, r)</code> where <code>c</code> is a Chebyshev center of <code>P</code> and <code>r</code> is the radius of the largest Euclidean ball with center <code>c</code> enclosed by <code>P</code>.</p><p><strong>Notes</strong></p><p>The Chebyshev center is the center of a largest Euclidean ball enclosed by <code>P</code>. In general, the center of such a ball is not unique, but the radius is.</p><p><strong>Algorithm</strong></p><p>We call <code>Polyhedra.chebyshevcenter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L1197-L1227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.complement-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.complement-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.complement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">complement(X::LazySet)</code></pre><p>Compute the complement of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the complement of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/complement.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.complement-Tuple{LazySet}" href="#LazySets.API.complement-Tuple{LazySet}"><code>LazySets.API.complement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">complement(X::LazySet)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation assumes that <code>X</code> is polyhedral and returns a <code>UnionSetArray</code> of <code>HalfSpace</code>s, i.e., the output is the union of the linear constraints which are obtained by complementing each constraint of <code>X</code>. For any pair of sets <span>$(X, Y)$</span> we have the identity <span>$(X ∩ Y)^C = X^C ∪ Y^C$</span>. We can apply this identity for each constraint that defines a polyhedral set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L980-L992">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.concretize-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.concretize-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.concretize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">concretize(X::LazySet)</code></pre><p>Construct a concrete representation of a (possibly lazy) set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A concrete representation of <code>X</code> (as far as possible).</p><p><strong>Notes</strong></p><p>Since not every lazy set has a concrete set representation in this library, the result may still be partially lazy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/concretize.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.concretize-Tuple{LazySet}" href="#LazySets.API.concretize-Tuple{LazySet}"><code>LazySets.API.concretize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">concretize(X::LazySet)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation returns <code>X</code>. All relevant lazy set types should override this behavior, typically by recursively calling <code>concretize</code> on the set arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L903-L913">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.constraints-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.constraints-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.constraints</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">constraints(X::LazySet)</code></pre><p>Construct an iterator over the constraints of a polyhedral set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – polyhedral set</li></ul><p><strong>Output</strong></p><p>An iterator over the constraints of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/constraints.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.constraints-Tuple{LazySet}" href="#LazySets.API.constraints-Tuple{LazySet}"><code>LazySets.API.constraints</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">constraints(X::LazySet)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation computes all constraints via <code>constraints_list</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L921-L929">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.convex_hull-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.convex_hull-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.convex_hull</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convex_hull(X::LazySet)</code></pre><p>Compute the convex hull of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the convex hull of <code>X</code>.</p><p><strong>Notes</strong></p><p>The convex hull of a set <span>$X$</span> is defined as</p><p class="math-container">\[    \{λx + (1-λ)y \mid x, y ∈ X, λ ∈ [0, 1]\}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/convex_hull.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.convex_hull-Tuple{LazySet}" href="#LazySets.API.convex_hull-Tuple{LazySet}"><code>LazySets.API.convex_hull</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">convex_hull(X::LazySet; kwargs...)</code></pre><p><strong>Output</strong></p><p>The set <code>X</code> itself if its type indicates that it is convex, or a new set with the list of the vertices describing the convex hull.</p><p><strong>Algorithm</strong></p><p>For non-convex sets, this method relies on the <code>vertices_list</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L306-L319">source</a></section></article><p><code>copy(::Type{LazySet})</code></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.triangulate-Tuple{LazySet}" href="#LazySets.triangulate-Tuple{LazySet}"><code>LazySets.triangulate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">triangulate(X::LazySet; [algorithm]::String=&quot;delaunay&quot;, [kwargs]...)</code></pre><p>Compute a triangulation of the given polytopic set.</p><p><strong>Input</strong></p><ul><li><code>X</code>         – polytopic set</li><li><code>algorithm</code> – (optional; default: <code>delaunay</code>) string to choose the                type of triangulation</li><li><code>kwargs</code>    – further keyword arguments passed to the algorithm</li></ul><p><strong>Output</strong></p><p>A union of polytopes in vertex representation.</p><p><strong>Algorithm</strong></p><p>The algorithm is selected with the argument <code>algorithm</code>.</p><ul><li><code>&quot;delaunay&quot;</code>: This algorithm computes a Delaunay triangulation.</li></ul><p>This algorithm can receive another optional argument <code>compute_triangles_3d</code>, a Boolean flag that defaults to <code>false</code>. It is used to compute the 2D triangulation of a 3D set if <code>true</code>.</p><p>The implementation requires the package <a href="https://github.com/gridap/MiniQhull.jl">MiniQhull.jl</a>, which uses the library <a href="http://www.qhull.org/">Qhull</a>.</p><p>The algorithm works in arbitrary dimension and requires that the list of vertices of <code>X</code> can be obtained.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L10-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.diameter-lib-interfaces-LazySet" href="#LazySets.API.diameter-lib-interfaces-LazySet"><code>LazySets.API.diameter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diameter(X::LazySet, [p]::Real=Inf)</code></pre><p>Return the diameter of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p><p><strong>Notes</strong></p><p>The diameter of a set is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/diameter.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.diameter" href="#LazySets.API.diameter"><code>LazySets.API.diameter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">diameter(X::LazySet, [p]::Real=Inf)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation applies the function <code>radius</code> and doubles the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L498-L506">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eltype-Tuple{Type{&lt;:LazySets.API.LazySet}}-lib-interfaces-LazySet" href="#Base.eltype-Tuple{Type{&lt;:LazySets.API.LazySet}}-lib-interfaces-LazySet"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eltype(T::Type{&lt;:LazySet})</code></pre><p>Determine the numeric type of a set type.</p><p><strong>Input</strong></p><ul><li><code>T</code> – set type</li></ul><p><strong>Output</strong></p><p>The numeric type of <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/eltype.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eltype-Tuple{Type{&lt;:LazySet}}" href="#Base.eltype-Tuple{Type{&lt;:LazySet}}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">eltype(::Type{&lt;:LazySet{N}}) where {N}</code></pre><p><strong>Algorithm</strong></p><p>The default implementation assumes that the first type parameter is the numeric type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L332-L341">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">eltype(::LazySet{N}) where {N}</code></pre><p><strong>Algorithm</strong></p><p>The default implementation assumes that the first type parameter is the numeric type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L344-L353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eltype-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet" href="#Base.eltype-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eltype(X::LazySet)</code></pre><p>Determine the numeric type of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>The numeric type of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/eltype.jl#L16-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eltype-Tuple{LazySet}" href="#Base.eltype-Tuple{LazySet}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">eltype(::Type{&lt;:LazySet{N}}) where {N}</code></pre><p><strong>Algorithm</strong></p><p>The default implementation assumes that the first type parameter is the numeric type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L332-L341">source</a></section><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">eltype(::LazySet{N}) where {N}</code></pre><p><strong>Algorithm</strong></p><p>The default implementation assumes that the first type parameter is the numeric type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L344-L353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.extrema-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet" href="#Base.extrema-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet"><code>Base.extrema</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extrema(X::LazySet)</code></pre><p>Compute the lowest and highest coordinate of a set in each dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>Two vectors with the lowest and highest coordinates of <code>X</code> in each dimension.</p><p><strong>Notes</strong></p><p>See also <a href="../../API/#Base.extrema-Tuple{LazySets.API.LazySet, Int64}"><code>extrema(X::LazySet, i::Int)</code></a>.</p><p>The result is equivalent to <code>(low(X), high(X))</code>, but sometimes it can be computed more efficiently.</p><p>The resulting points are the lowest and highest corners of the box approximation, so they are not necessarily contained in <code>X</code>.</p><p><strong>Algorithm</strong></p><p>The default implementation computes the extrema via <code>low</code> and <code>high</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/extrema.jl#L25-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.extrema-Tuple{LazySet}" href="#Base.extrema-Tuple{LazySet}"><code>Base.extrema</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">extrema(X::LazySet)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation computes the extrema via <code>low</code> and <code>high</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L240-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.extrema-Tuple{LazySets.API.LazySet, Int64}-lib-interfaces-LazySet" href="#Base.extrema-Tuple{LazySets.API.LazySet, Int64}-lib-interfaces-LazySet"><code>Base.extrema</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extrema(X::LazySet, i::Int)</code></pre><p>Compute the lowest and highest coordinate of a set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>i</code> – dimension</li></ul><p><strong>Output</strong></p><p>Two real numbers representing the lowest and highest coordinate of the set in the given dimension.</p><p><strong>Notes</strong></p><p>The result is equivalent to <code>(low(X, i), high(X, i))</code>, but sometimes it can be computed more efficiently.</p><p>The resulting values are the lower and upper ends of the projection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/extrema.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.extrema-Tuple{LazySet, Int64}" href="#Base.extrema-Tuple{LazySet, Int64}"><code>Base.extrema</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">extrema(X::LazySet, i::Int)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation computes the extrema via <code>low</code> and <code>high</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L201-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.high-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.high-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.high</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">high(X::LazySet)</code></pre><p>Compute the highest coordinate of a set in each dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A vector with the highest coordinate of the set in each dimension.</p><p><strong>Notes</strong></p><p>See also <code>high(X::LazySet, i::Int)</code>.</p><p>The result is the uppermost corner of the box approximation, so it is not necessarily contained in <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/high.jl#L22-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.high-Tuple{LazySet}" href="#LazySets.API.high-Tuple{LazySet}"><code>LazySets.API.high</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">high(X::LazySet)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation applies <code>high</code> in each dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L177-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isbounded-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.isbounded-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.isbounded</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isbounded(X::LazySet)</code></pre><p>Check whether a set is bounded.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set is bounded.</p><p><strong>Notes</strong></p><p>See also <a href="../../API/#LazySets.API.isboundedtype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>isboundedtype(::Type{&lt;:LazySet})</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/isbounded.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isbounded-Tuple{LazySet}" href="#LazySets.API.isbounded-Tuple{LazySet}"><code>LazySets.API.isbounded</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">isbounded(X::LazySet; [algorithm]=&quot;support_function&quot;)</code></pre><p><strong>Input</strong></p><ul><li><code>algorithm</code> – (optional, default: <code>&quot;support_function&quot;</code>) algorithm choice,                possible options are <code>&quot;support_function&quot;</code> and <code>&quot;stiemke&quot;</code></li></ul><p><strong>Algorithm</strong></p><p>See the documentation of <code>_isbounded_unit_dimensions</code> or <code>_isbounded_stiemke</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L389-L403">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets._isbounded_unit_dimensions-Tuple{LazySet}" href="#LazySets._isbounded_unit_dimensions-Tuple{LazySet}"><code>LazySets._isbounded_unit_dimensions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_isbounded_unit_dimensions(X::LazySet)</code></pre><p>Check whether a set is bounded in each unit dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set is bounded in each unit dimension.</p><p><strong>Algorithm</strong></p><p>This function asks for upper and lower bounds in each ambient dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L414-L430">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isboundedtype-Tuple{Type{&lt;:LazySets.API.LazySet}}-lib-interfaces-LazySet" href="#LazySets.API.isboundedtype-Tuple{Type{&lt;:LazySets.API.LazySet}}-lib-interfaces-LazySet"><code>LazySets.API.isboundedtype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isboundedtype(T::Type{&lt;:LazySet})</code></pre><p>Check whether a set type only represents bounded sets.</p><p><strong>Input</strong></p><ul><li><code>T</code> – set type</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set type only represents bounded sets.</p><p><strong>Notes</strong></p><p>See also <a href="../../API/#LazySets.API.isbounded-Tuple{LazySets.API.LazySet}"><code>isbounded(::LazySet)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/isboundedtype.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isboundedtype-Tuple{Type{&lt;:LazySet}}" href="#LazySets.API.isboundedtype-Tuple{Type{&lt;:LazySet}}"><code>LazySets.API.isboundedtype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">isboundedtype(::Type{&lt;:LazySet})</code></pre><p><strong>Notes</strong></p><p>Note that some sets may still represent an unbounded set even though their type actually does not (example: <a href="../../sets/HPolytope/#LazySets.HPolytopeModule.HPolytope"><code>HPolytope</code></a>, because the construction with non-bounding linear constraints is allowed).</p><p><strong>Algorithm</strong></p><p>The default implementation returns <code>false</code>. All set types that can determine boundedness should override this behavior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L369-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isconvextype-Tuple{Type{&lt;:LazySets.API.LazySet}}-lib-interfaces-LazySet" href="#LazySets.API.isconvextype-Tuple{Type{&lt;:LazySets.API.LazySet}}-lib-interfaces-LazySet"><code>LazySets.API.isconvextype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isconvextype(T::Type{&lt;:LazySet})</code></pre><p>Check whether <code>T</code> is convex just by using type information.</p><p><strong>Input</strong></p><ul><li><code>T</code> – subtype of <code>LazySet</code></li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set type only represents convex sets.</p><p><strong>Notes</strong></p><p>Since this operation only acts on types (not on values), it can return false negatives, i.e., there may be instances where the set is convex, even though the answer of this function is <code>false</code>. The examples below illustrate this point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/isconvextype.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isconvextype-Tuple{Type{&lt;:LazySet}}" href="#LazySets.API.isconvextype-Tuple{Type{&lt;:LazySet}}"><code>LazySets.API.isconvextype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">isconvextype(::Type{&lt;:LazySet})</code></pre><p><strong>Algorithm</strong></p><p>The default implementation returns <code>false</code>. All set types that can determine convexity should override this behavior.</p><p><strong>Examples</strong></p><p>A ball in the infinity norm is always convex:</p><pre><code class="language-julia-repl hljs">julia&gt; isconvextype(BallInf)
true</code></pre><p>The union (<code>UnionSet</code>) of two sets may in general be either convex or not. Since convexity cannot be decided by just using type information, <code>isconvextype</code> returns <code>false</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; isconvextype(UnionSet)
false</code></pre><p>However, the type parameters of set operations allow to decide convexity in some cases by falling back to the convexity information of the argument types. Consider the lazy intersection. The intersection of two convex sets is always convex:</p><pre><code class="language-julia-repl hljs">julia&gt; isconvextype(Intersection{Float64, BallInf{Float64}, BallInf{Float64}})
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L57-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isempty-lib-interfaces-LazySet" href="#Base.isempty-lib-interfaces-LazySet"><code>Base.isempty</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isempty(X::LazySet, witness::Bool=false)</code></pre><p>Check whether a set is empty.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If the <code>witness</code> option is deactivated: <code>true</code> iff <span>$X = ∅$</span></li><li>If the <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X = ∅$</span></li><li><code>(false, v)</code> iff <span>$X ≠ ∅$</span> for some <span>$v ∈ X$</span></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/isempty.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isempty" href="#Base.isempty"><code>Base.isempty</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">isempty(P::LazySet, witness::Bool=false;
        [use_polyhedra_interface]::Bool=false, [solver]=nothing,
        [backend]=nothing)</code></pre><p><strong>Input</strong></p><ul><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li><li><code>use_polyhedra_interface</code> – (optional, default: <code>false</code>) if <code>true</code>, we use              the <code>Polyhedra</code> interface for the emptiness test</li><li><code>solver</code>  – (optional, default: <code>nothing</code>) LP-solver backend; uses              <code>default_lp_solver</code> if not provided</li><li><code>backend</code> – (optional, default: <code>nothing</code>) backend for polyhedral              computations in <code>Polyhedra</code>; uses <code>default_polyhedra_backend(P)</code>              if not provided</li></ul><p><strong>Notes</strong></p><p>This implementation assumes that <code>P</code> is polyhedral.</p><p>The default value of the <code>backend</code> is set internally and depends on whether the <code>use_polyhedra_interface</code> option is set. If the option is set, we use <code>default_polyhedra_backend(P)</code>.</p><p>Witness production is not supported if <code>use_polyhedra_interface</code> is <code>true</code>.</p><p><strong>Algorithm</strong></p><p>The algorithm sets up a feasibility LP for the constraints of <code>P</code>. If <code>use_polyhedra_interface</code> is <code>true</code>, we call <code>Polyhedra.isempty</code>. Otherwise, we set up the LP internally.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L1323-L1356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isoperation-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.isoperation-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.isoperation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isoperation(X::LazySet)</code></pre><p>Check whether a set is an instance of a (lazy) set operation.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>X</code> is an instance of a set-based operation.</p><p><strong>Notes</strong></p><p>See also <a href="../../API/#LazySets.API.isoperationtype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>isoperationtype(::Type{&lt;:LazySet})</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/isoperation.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isoperation-Tuple{LazySet}" href="#LazySets.API.isoperation-Tuple{LazySet}"><code>LazySets.API.isoperation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">isoperation(X::LazySet)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation checks whether the set type of the input is an operation type using <a href="../../API/#LazySets.API.isoperationtype-Tuple{Type{&lt;:LazySets.API.LazySet}}"><code>isoperationtype(::Type{&lt;:LazySet})</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; B = BallInf([0.0, 0.0], 1.0);

julia&gt; isoperation(B)
false

julia&gt; isoperation(B ⊕ B)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L756-L777">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.ispolyhedral-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.ispolyhedral-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.ispolyhedral</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ispolyhedral(X::LazySet)</code></pre><p>Check whether a set is polyhedral.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> only if the set is polyhedral.</p><p><strong>Notes</strong></p><p>The answer is conservative, i.e., may sometimes be <code>false</code> even if the set is polyhedral.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/ispolyhedral.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.ispolyhedral-Tuple{LazySet}" href="#LazySets.API.ispolyhedral-Tuple{LazySet}"><code>LazySets.API.ispolyhedral</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">ispolyhedral(::LazySet)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation returns <code>false</code>. All set types that can determine the polyhedral property should override this behavior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L440-L449">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.low-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.low-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.low</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">low(X::LazySet)</code></pre><p>Compute the lowest coordinates of a set in each dimension.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A vector with the lowest coordinate of the set in each dimension.</p><p><strong>Notes</strong></p><p>See also <code>low(X::LazySet, i::Int)</code>.</p><p>The result is the lowermost corner of the box approximation, so it is not necessarily contained in <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/low.jl#L22-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.low-Tuple{LazySet}" href="#LazySets.API.low-Tuple{LazySet}"><code>LazySets.API.low</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">low(X::LazySet)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation applies <code>low</code> in each dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L130-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.norm-lib-interfaces-LazySet" href="#LinearAlgebra.norm-lib-interfaces-LazySet"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">norm(X::LazySet, [p]::Real=Inf)</code></pre><p>Return the norm of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p><p><strong>Notes</strong></p><p>The norm of a set is the norm of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume that is centered in the origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/norm.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">norm(X::LazySet, [p]::Real=Inf)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation handles the case <code>p == Inf</code> using <code>extrema</code>. Otherwise it checks whether <code>X</code> is polytopic, in which case it iterates over all vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L454-L464">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Polyhedra.polyhedron-Tuple{LazySet}" href="#Polyhedra.polyhedron-Tuple{LazySet}"><code>Polyhedra.polyhedron</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">polyhedron(P::LazySet; [backend]=default_polyhedra_backend(P))</code></pre><p>Compute a set representation from <code>Polyhedra.jl</code>.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polyhedral set</li><li><code>backend</code> – (optional, default: call <code>default_polyhedra_backend(P)</code>)               the polyhedral computations backend</li></ul><p><strong>Output</strong></p><p>A set representation in the <code>Polyhedra</code> library.</p><p><strong>Notes</strong></p><p>For further information on the supported backends see <a href="https://juliapolyhedra.github.io/">Polyhedra&#39;s documentation</a>.</p><p><strong>Algorithm</strong></p><p>This default implementation uses <code>tosimplehrep</code>, which computes the constraint representation of <code>P</code>. Set types preferring the vertex representation should implement their own method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L1245-L1270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.radius-lib-interfaces-LazySet" href="#LazySets.API.radius-lib-interfaces-LazySet"><code>LazySets.API.radius</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">radius(X::LazySet, [p]::Real=Inf)</code></pre><p>Return the radius of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p><p><strong>Notes</strong></p><p>The radius of a set is the radius of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/radius.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.radius" href="#LazySets.API.radius"><code>LazySets.API.radius</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">radius(X::LazySet, [p]::Real=Inf)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation handles the case <code>p == Inf</code> using <code>ballinf_approximation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L480-L489">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rationalize-Union{Tuple{T}, Tuple{Type{T}, LazySet{&lt;:AbstractFloat}, Real}} where T&lt;:Integer" href="#Base.rationalize-Union{Tuple{T}, Tuple{Type{T}, LazySet{&lt;:AbstractFloat}, Real}} where T&lt;:Integer"><code>Base.rationalize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rationalize(::Type{T}, X::LazySet, tol::Real) where {T&lt;:Integer}</code></pre><p>Approximate a set represented with floating-point numbers as a set represented with rationals of the given integer type.</p><p><strong>Input</strong></p><ul><li><code>T</code>   – (optional, default: <code>Int</code>) integer type to represent the rationals</li><li><code>X</code>   – set represented by floating-point components</li><li><code>tol</code> – (optional, default: <code>eps(N)</code>) tolerance of the result; each rationalized          component will differ by no more than <code>tol</code> with respect to the floating-point value</li></ul><p><strong>Output</strong></p><p>A set of the same base type as <code>X</code> where each numerical component is of type <code>Rational{T}</code>.</p><p><strong>Algorithm</strong></p><p>The default implementation rationalizes each field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L1154-L1175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityBase.Arrays.rectify-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet" href="#ReachabilityBase.Arrays.rectify-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet"><code>ReachabilityBase.Arrays.rectify</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rectify(X::LazySet)</code></pre><p>Compute the rectification of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the rectification of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/rectify.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReachabilityBase.Arrays.rectify" href="#ReachabilityBase.Arrays.rectify"><code>ReachabilityBase.Arrays.rectify</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">rectify(X::LazySet, [concrete_intersection]::Bool=false)</code></pre><p><strong>Algorithm</strong></p><p>For each dimension in which <code>X</code> is both positive and negative, we split <code>X</code> into these two parts and then project the negative part to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L1140-L1149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.reflect-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.reflect-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.reflect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reflect(X::LazySet)</code></pre><p>Compute the reflection of a set in the origin.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the reflection <span>$-X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/reflect.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.reflect-Tuple{LazySet}" href="#LazySets.API.reflect-Tuple{LazySet}"><code>LazySets.API.reflect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">reflect(P::LazySet)</code></pre><p><strong>Output</strong></p><p>The set <code>-P</code>, which is either of type <code>HPolytope</code> if <code>P</code> is a polytope (i.e., bounded) or of type <code>HPolyhedron</code> otherwise.</p><p><strong>Algorithm</strong></p><p>This function requires that the list of constraints of the set <code>P</code> is available, i.e., that it can be written as <span>$P = \{z ∈ ℝⁿ: ⋂ sᵢᵀz ≤ rᵢ, i = 1, ..., N\}.$</span></p><p>This function can be used to implement the alternative definition of the Minkowski difference</p><p class="math-container">\[    A ⊖ B = \{a − b \mid a ∈ A, b ∈ B\} = A ⊕ (-B)\]</p><p>by calling <code>minkowski_sum(A, reflect(B))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L611-L633">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.singleton_list-Tuple{LazySet}" href="#LazySets.singleton_list-Tuple{LazySet}"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">singleton_list(P::LazySet)</code></pre><p>Return the vertices of a polytopic set as a list of singletons.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polytopic set</li></ul><p><strong>Output</strong></p><p>A list of the vertices of <code>P</code> as <code>Singleton</code>s.</p><p><strong>Notes</strong></p><p>This function relies on <code>vertices_list</code>, which raises an error if the set is not polytopic (e.g., unbounded).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L881-L898">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.triangulate_faces-Tuple{LazySet}" href="#LazySets.triangulate_faces-Tuple{LazySet}"><code>LazySets.triangulate_faces</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">triangulate_faces(X::LazySet)</code></pre><p>Triangulate the faces of a three-dimensional polytopic set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – three-dimensional polytopic set</li></ul><p><strong>Output</strong></p><p>A tuple <code>(p, c)</code> where <code>p</code> is a matrix, with each column containing a point, and <code>c</code> is a list of 3-tuples containing the indices of the points in each triangle.</p><p><strong>Notes</strong></p><p>This function triangulates all faces of a 3D polytope. The result is a list of (flat) triangles in 3D which describe the boundary of <code>X</code>.</p><p><code>X</code> must contain at least three vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L1280-L1300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.tohrep-Tuple{LazySet}" href="#LazySets.tohrep-Tuple{LazySet}"><code>LazySets.tohrep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tohrep(P::LazySet)</code></pre><p>Convert a polyhedral set to constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polyhedral set</li></ul><p><strong>Output</strong></p><p>An <code>HPolyhedron</code> if <code>P</code> is bounded (via <code>isboundedtype</code>) or an <code>HPolytope</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L1453-L1466">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.tosimplehrep-Tuple{LazySet}" href="#LazySets.tosimplehrep-Tuple{LazySet}"><code>LazySets.tosimplehrep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tosimplehrep(S::LazySet)</code></pre><p>Return the simple constraint representation <span>$Ax ≤ b$</span> of a polyhedral set from its list of linear constraints.</p><p><strong>Input</strong></p><ul><li><code>S</code> – polyhedral set</li></ul><p><strong>Output</strong></p><p>The tuple <code>(A, b)</code> where <code>A</code> is the matrix of normal directions and <code>b</code> is the vector of offsets.</p><p><strong>Algorithm</strong></p><p>This fallback implementation relies on <code>constraints_list(S)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L590-L608">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.tovrep-Tuple{LazySet}" href="#LazySets.tovrep-Tuple{LazySet}"><code>LazySets.tovrep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tovrep(P::LazySet)</code></pre><p>Convert a polytopic set to vertex representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polytopic set</li></ul><p><strong>Output</strong></p><p>A <code>VPolytope</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L1475-L1487">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.vertices-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.vertices-Tuple{LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertices(X::LazySet)</code></pre><p>Construct an iterator over the vertices of a polytopic set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – polytopic set</li></ul><p><strong>Output</strong></p><p>An iterator over the vertices of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Unary/vertices.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.vertices-Tuple{LazySet}" href="#LazySets.API.vertices-Tuple{LazySet}"><code>LazySets.API.vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">vertices(X::LazySet)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation computes all vertices via <code>vertices_list</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L934-L942">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.affine_map-Tuple{AbstractMatrix, LazySets.API.LazySet, AbstractVector}-lib-interfaces-LazySet" href="#LazySets.API.affine_map-Tuple{AbstractMatrix, LazySets.API.LazySet, AbstractVector}-lib-interfaces-LazySet"><code>LazySets.API.affine_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">affine_map(M::AbstractMatrix, X::LazySet, v::AbstractVector)</code></pre><p>Compute the affine map <span>$M · X + v$</span>.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>X</code> – set</li><li><code>v</code> – translation vector</li></ul><p><strong>Output</strong></p><p>A set representing the affine map <span>$M · X + v$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Mixed/affine_map.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.affine_map-Tuple{Any, LazySet, AbstractVector}" href="#LazySets.API.affine_map-Tuple{Any, LazySet, AbstractVector}"><code>LazySets.API.affine_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">affine_map(M, X::LazySet, v::AbstractVector; [kwargs]...)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation applies the functions <code>linear_map</code> and <code>translate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L526-L534">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.exponential_map-Tuple{AbstractMatrix, LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.exponential_map-Tuple{AbstractMatrix, LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.exponential_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exponential_map(M::AbstractMatrix, X::LazySet)</code></pre><p>Compute the exponential map of <code>M</code> and <code>X</code>, i.e., <span>$eᴹ ⋅ X$</span>.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the exponential map <span>$eᴹ ⋅ X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Mixed/exponential_map.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.exponential_map-Tuple{AbstractMatrix, LazySet}" href="#LazySets.API.exponential_map-Tuple{AbstractMatrix, LazySet}"><code>LazySets.API.exponential_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">exponential_map(M::AbstractMatrix, X::LazySet)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation applies the functions <code>exp</code> and <code>linear_map</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L539-L547">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.is_interior_point-Tuple{AbstractVector{&lt;:Real}, LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.is_interior_point-Tuple{AbstractVector{&lt;:Real}, LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.is_interior_point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_interior_point(v::AbstractVector, X::LazySet; [p]::Real=Inf, [ε]::Real=_rtol(eltype(X)))</code></pre><p>Check whether a point is contained in the interior of a set.</p><p><strong>Input</strong></p><ul><li><code>v</code>  – point/vector</li><li><code>X</code>  – set</li><li><code>p</code>  – (optional; default: <code>Inf</code>) norm of the ball used to apply the error         tolerance</li><li><code>ε</code>  – (optional; default: <code>_rtol(eltype(X))</code>) error tolerance of the check</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the point <code>v</code> is strictly contained in <code>X</code> with tolerance <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Mixed/is_interior_point.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.is_interior_point-Union{Tuple{N}, Tuple{AbstractVector{N}, LazySet{N}}} where N&lt;:Real" href="#LazySets.API.is_interior_point-Union{Tuple{N}, Tuple{AbstractVector{N}, LazySet{N}}} where N&lt;:Real"><code>LazySets.API.is_interior_point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">is_interior_point(v::AbstractVector{N}, X::LazySet{N}; [p]=N(Inf), [ε]=_rtol(N)) where {N&lt;:Real}</code></pre><p><strong>Algorithm</strong></p><p>The default implementation determines <code>v ∈ interior(X)</code> with error tolerance <code>ε</code> by checking whether a <code>Ballp</code> of norm <code>p</code> with center <code>v</code> and radius <code>ε</code> is contained in <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L658-L668">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.linear_map-Tuple{AbstractMatrix, LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.linear_map-Tuple{AbstractMatrix, LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.linear_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_map(M::AbstractMatrix, X::LazySet)</code></pre><p>Compute the linear map <span>$M · X$</span>.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the linear map <span>$M · X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Mixed/linear_map.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.linear_map-Tuple{AbstractMatrix, LazySet}" href="#LazySets.API.linear_map-Tuple{AbstractMatrix, LazySet}"><code>LazySets.API.linear_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">linear_map(M::AbstractMatrix, P::LazySet; kwargs...)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation assumes that <code>P</code> is polyhedral and applies an algorithm based on the set type (see <a href="../AbstractPolyhedron/#LazySets._linear_map_polyhedron"><code>_linear_map_polyhedron</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L1411-L1420">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.project" href="#LazySets.API.project"><code>LazySets.API.project</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">project(X::LazySet, block::AbstractVector{Int}, [::Nothing=nothing],
        [n]::Int=dim(X); [kwargs...])</code></pre><p>Project a set to a given block by using a concrete linear map.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>block</code>   – block structure - a vector with the dimensions of interest</li><li><code>nothing</code> – (default: <code>nothing</code>) needed for dispatch</li><li><code>n</code>       – (optional, default: <code>dim(X)</code>) ambient dimension of the set <code>X</code></li></ul><p><strong>Output</strong></p><p>A set representing the projection of <code>X</code> to block <code>block</code>.</p><p><strong>Algorithm</strong></p><p>We apply the function <code>linear_map</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L1000-L1020">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.project" href="#LazySets.API.project"><code>LazySets.API.project</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">project(X::LazySet, block::AbstractVector{Int}, set_type::Type{&lt;:LazySet},
        [n]::Int=dim(X); [kwargs...])</code></pre><p>Project a set to a given block and set type, possibly involving an overapproximation.</p><p><strong>Input</strong></p><ul><li><code>X</code>        – set</li><li><code>block</code>    – block structure - a vector with the dimensions of interest</li><li><code>set_type</code> – target set type</li><li><code>n</code>        – (optional, default: <code>dim(X)</code>) ambient dimension of the set <code>X</code></li></ul><p><strong>Output</strong></p><p>A set of type <code>set_type</code> representing an overapproximation of the projection of <code>X</code>.</p><p><strong>Algorithm</strong></p><ol><li>Project the set <code>X</code> with <code>M⋅X</code>, where <code>M</code> is the identity matrix in the block</li></ol><p>coordinates and zero otherwise.</p><ol><li>Overapproximate the projected set using <code>overapproximate</code> and <code>set_type</code>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L1032-L1056">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.project" href="#LazySets.API.project"><code>LazySets.API.project</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">project(X::LazySet, block::AbstractVector{Int},
        set_type_and_precision::Pair{&lt;:UnionAll,&lt;:Real}, [n]::Int=dim(X);
        [kwargs...])</code></pre><p>Project a set to a given block and set type with a certified error bound.</p><p><strong>Input</strong></p><ul><li><code>X</code>     – set</li><li><code>block</code> – block structure - a vector with the dimensions of interest</li><li><code>set_type_and_precision</code> – pair <code>(T, ε)</code> of a target set type <code>T</code> and an                             error bound <code>ε</code> for approximation</li><li><code>n</code>     – (optional, default: <code>dim(X)</code>) ambient dimension of the set <code>X</code></li></ul><p><strong>Output</strong></p><p>A set representing the epsilon-close approximation of the projection of <code>X</code>.</p><p><strong>Notes</strong></p><p>Currently we only support <code>HPolygon</code> as set type, which implies that the set must be two-dimensional.</p><p><strong>Algorithm</strong></p><ol><li>Project the set <code>X</code> with <code>M⋅X</code>, where <code>M</code> is the identity matrix in the block</li></ol><p>coordinates and zero otherwise.</p><ol><li>Overapproximate the projected set with the given error bound <code>ε</code>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L1064-L1093">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.project" href="#LazySets.API.project"><code>LazySets.API.project</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">project(X::LazySet, block::AbstractVector{Int}, ε::Real, [n]::Int=dim(X);
        [kwargs...])</code></pre><p>Project a set to a given block and set type with an error bound.</p><p><strong>Input</strong></p><ul><li><code>X</code>     – set</li><li><code>block</code> – block structure - a vector with the dimensions of interest</li><li><code>ε</code>     – error bound for approximation</li><li><code>n</code>     – (optional, default: <code>dim(X)</code>) ambient dimension of the set <code>X</code></li></ul><p><strong>Output</strong></p><p>A set representing the epsilon-close approximation of the projection of <code>X</code>.</p><p><strong>Algorithm</strong></p><ol><li>Project the set <code>X</code> with <code>M⋅X</code>, where <code>M</code> is the identity matrix in the block</li></ol><p>coordinates and zero otherwise.</p><ol><li>Overapproximate the projected set with the given error bound <code>ε</code>.</li></ol><p>The target set type is chosen automatically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L1105-L1128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.scale-Tuple{Real, LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.scale-Tuple{Real, LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.scale</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scale(α::Real, X::LazySet)</code></pre><p>Compute the scaling of a set.</p><p><strong>Input</strong></p><ul><li><code>α</code> – scalar</li><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing <span>$α ⋅ X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Mixed/scale.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.scale-Tuple{Real, LazySet}" href="#LazySets.API.scale-Tuple{Real, LazySet}"><code>LazySets.API.scale</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">scale(α::Real, X::LazySet)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation computes <code>linear_map</code> with the diagonal matrix <span>$α*I$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L1434-L1442">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.translate-Tuple{LazySets.API.LazySet, AbstractVector}-lib-interfaces-LazySet" href="#LazySets.API.translate-Tuple{LazySets.API.LazySet, AbstractVector}-lib-interfaces-LazySet"><code>LazySets.API.translate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translate(X::LazySet, v::AbstractVector)</code></pre><p>Compute the translation of a set with a vector.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>v</code> – vector</li></ul><p><strong>Output</strong></p><p>A set representing <span>$X + \{v\}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Mixed/translate.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.translate-Tuple{LazySet, AbstractVector}" href="#LazySets.API.translate-Tuple{LazySet, AbstractVector}"><code>LazySets.API.translate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">translate(X::LazySet, v::AbstractVector)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation calls <code>translate!</code> on a copy of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L511-L519">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.cartesian_product-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.cartesian_product-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.cartesian_product</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cartesian_product(X::LazySet, Y::LazySet)</code></pre><p>Compute the Cartesian product of two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p>A set representing the Cartesian product <span>$X × Y$</span>.</p><p><strong>Notes</strong></p><p>The Cartesian product of two sets <span>$X$</span> and <span>$Y$</span> is defined as</p><p class="math-container">\[    X × Y = \{[x, y] \mid x ∈ X, y ∈ Y\}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Binary/cartesian_product.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.cartesian_product-Tuple{LazySet, LazySet}" href="#LazySets.API.cartesian_product-Tuple{LazySet, LazySet}"><code>LazySets.API.cartesian_product</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cartesian_product(X::LazySet, Y::LazySet; [backend]=nothing,
                  [algorithm]::String=&quot;vrep&quot;)</code></pre><p>Compute the Cartesian product of two sets.</p><p><strong>Input</strong></p><ul><li><p><code>X</code>         – set</p></li><li><p><code>Y</code>         – set</p></li><li><p><code>backend</code>   – (optional, default: <code>nothing</code>) backend for polyhedral                computation</p></li><li><p><code>algorithm</code> – (optional, default: &quot;hrep&quot;) the method used to transform the                sets <code>X</code> and <code>Y</code> before taking the Cartesian product; choose                between:</p><ul><li>&quot;vrep&quot; (use the vertex representation)</li><li>&quot;hrep&quot; (use the constraint representation)</li><li>&quot;hrep_polyhedra&quot; (use the constraint representation and <code>Polyhedra</code>)</li></ul></li></ul><p><strong>Output</strong></p><p>The <code>VPolytope</code> (if <code>&quot;vrep&quot;</code> was used) or <code>HPolytope</code>/<code>HPolyhedron</code> (if <code>&quot;hrep&quot;</code> or <code>&quot;hrep_polyhedra&quot;</code> was used) obtained by the concrete Cartesian product of <code>X</code> and <code>Y</code>. The choice between <code>HPolytope</code> and <code>HPolyhedron</code> is made based on boundedness information deduced from the type.</p><p><strong>Notes</strong></p><p>For further information on the supported backends see <a href="https://juliapolyhedra.github.io/">Polyhedra&#39;s documentation</a>.</p><p>If <code>X</code> can be converted to a one-dimensional interval and the vertices of <code>Y</code> are available, use <code>algorithm=&quot;vrep&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/ConcreteOperations/cartesian_product.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.convex_hull-Tuple{LazySet, LazySet}" href="#LazySets.API.convex_hull-Tuple{LazySet, LazySet}"><code>LazySets.API.convex_hull</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convex_hull(X::LazySet, Y::LazySet; [algorithm]=nothing,
            [backend]=nothing, [solver]=nothing)</code></pre><p>Compute the convex hull of two polytopic sets.</p><p><strong>Input</strong></p><ul><li><code>X</code>         – polytopic set</li><li><code>Y</code>         – polytopic set</li><li><code>algorithm</code> – (optional, default: <code>nothing</code>) the convex-hull algorithm</li><li><code>backend</code>   – (optional, default: <code>nothing</code>) backend for polyhedral                computations (used for higher-dimensional sets)</li><li><code>solver</code>    – (optional, default: <code>nothing</code>) the linear-programming solver                used in the backend</li></ul><p><strong>Output</strong></p><p>If the sets are empty, the result is an <code>EmptySet</code>. If the convex hull consists of a single point, the result is a <code>Singleton</code>. If the input sets are one-dimensional, the result is an <code>Interval</code>. If the input sets are two-dimensional, the result is a <code>VPolygon</code>. Otherwise the result is a <code>VPolytope</code>.</p><p><strong>Algorithm</strong></p><p>We compute the vertices of both <code>X</code> and <code>Y</code> using <code>vertices_list</code> and then compute the convex hull of the union of those vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/ConcreteOperations/convex_hull.jl#L9-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isapprox-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet" href="#Base.isapprox-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isapprox(X::LazySet, Y::LazySet)</code></pre><p>Check whether two sets of the same type are approximately equal.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>X</code> is approximately equal to <code>Y</code>.</p><p><strong>Notes</strong></p><p>The check is purely syntactic and the sets need to have the same base type, i.e., <code>X::T1 ≈ Y::T2</code> always returns <code>false</code> even if <code>X</code> and <code>Y</code> represent the same set. But <code>X::T{Int64} ≈ Y::T{Float64}</code> is a valid comparison. Note that, unlike most other binary operations, a query with <code>X</code> and <code>Y</code> of different dimension is allowed (and results in the answer <code>false</code>).</p><p>The convenience alias <code>≈</code> can be typed by <code>\approx&lt;tab&gt;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Binary/isapprox.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isapprox-Tuple{LazySet, LazySet}" href="#Base.isapprox-Tuple{LazySet, LazySet}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">isapprox(X::LazySet, Y::LazySet)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation recursively compares the fields of <code>X</code> and <code>Y</code> until a mismatch is found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; HalfSpace([1], 1) ≈ HalfSpace([1.0], 1.0)
true

julia&gt; HalfSpace([1], 1) ≈ HalfSpace([1.00000001], 0.99999999)
true

julia&gt; BallInf([0.0], 1.0) ≈ Hyperrectangle([0.0], [1.0])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/ConcreteOperations/isapprox.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isdisjoint-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet" href="#Base.isdisjoint-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet"><code>Base.isdisjoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isdisjoint(X::LazySet, Y::LazySet, [witness]::Bool=false)</code></pre><p>Check whether two sets are disjoint (i.e., do not intersect), and optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>Y</code>       – set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If the <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ∩ Y = ∅$</span></li><li>If the <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ∩ Y = ∅$</span></li><li><code>(false, v)</code> iff <span>$X ∩ Y ≠ ∅$</span> for some <span>$v ∈ X ∩ Y$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>The convenience alias <code>is_intersection_empty</code> is also available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Binary/isdisjoint.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isdisjoint" href="#Base.isdisjoint"><code>Base.isdisjoint</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">isdisjoint(X::LazySet, Y::LazySet, [witness]::Bool=false)</code></pre><p><strong>Algorithm</strong></p><p>This is a fallback implementation that computes the concrete intersection, <code>intersection</code>, of the given sets.</p><p>A witness is constructed using the <code>an_element</code> implementation of the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/ConcreteOperations/isdisjoint.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:==-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet" href="#Base.:==-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet"><code>Base.:==</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">==(X::LazySet, Y::LazySet)</code></pre><p>Check whether two sets use exactly the same set representation.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>X</code> is equal to <code>Y</code>.</p><p><strong>Notes</strong></p><p>The check is purely syntactic and the sets need to have the same base type, i.e., <code>X::T1 == Y::T2</code> always returns <code>false</code> even if <code>X</code> and <code>Y</code> represent the same set. But <code>X::T{Int64} == Y::T{Float64}</code> is a valid comparison. Note that, unlike most other binary operations, a query with <code>X</code> and <code>Y</code> of different dimension is allowed (and results in the answer <code>false</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Binary/isequal.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:==-Tuple{LazySet, LazySet}" href="#Base.:==-Tuple{LazySet, LazySet}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">==(X::LazySet, Y::LazySet)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation recursively compares the fields of <code>X</code> and <code>Y</code> until a mismatch is found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; HalfSpace([1], 1) == HalfSpace([1.0], 1.0)
true

julia&gt; HalfSpace([1], 1) == HalfSpace([1.00000001], 0.99999999)
false

julia&gt; BallInf([0.0], 1.0) == Hyperrectangle([0.0], [1.0])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/ConcreteOperations/isequal.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isequivalent-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.isequivalent-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.isequivalent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isequivalent(X::LazySet, Y::LazySet)</code></pre><p>Check whether two sets are equivalent, i.e., represent the same set of points.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>Y</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>X</code> is equivalent to <code>Y</code> (up to numerical precision).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Binary/isequivalent.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.isequivalent-Tuple{LazySet, LazySet}" href="#LazySets.API.isequivalent-Tuple{LazySet, LazySet}"><code>LazySets.API.isequivalent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">isequivalent(X::LazySet, Y::LazySet)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation first checks <code>X ≈ Y</code>, which returns <code>true</code> if and only if <code>X</code> and <code>Y</code> have the same base type and approximately the same values. If that fails, the implementation checks the double inclusion <code>X ⊆ Y &amp;&amp; Y ⊆ X</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = BallInf([0.1, 0.2], 0.3);

julia&gt; Y = convert(HPolytope, X);

julia&gt; X == Y
false

julia&gt; isequivalent(X, Y)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/ConcreteOperations/isequivalent.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.:⊂-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet" href="#LazySets.API.:⊂-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet"><code>LazySets.API.:⊂</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">⊂(X::LazySet, Y::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a set is a strict subset of another set, and optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>Y</code>       – set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If the <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊂ Y$</span></li><li>If the <code>witness</code> option is activated:<ul><li><code>(true, v)</code> iff <span>$X ⊂ Y$</span> for some <span>$v ∈ Y ∖ X$</span></li><li><code>(false, [])</code> iff <span>$X ⊂ Y$</span> does not hold</li></ul></li></ul><p><strong>Notes</strong></p><p>Strict inclusion is sometimes written as <code>⊊</code>. The following identity holds:</p><p class="math-container">\[    X ⊂ Y ⇔ X ⊆ Y ∧ Y ⊈ X\]</p><p><strong>Algorithm</strong></p><p>The default implementation first checks inclusion of <code>X</code> in <code>Y</code> and then checks noninclusion of <code>Y</code> in <code>X</code>:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Binary/isstrictsubset.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.:⊂" href="#LazySets.API.:⊂"><code>LazySets.API.:⊂</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">⊂(X::LazySet, Y::LazySet, [witness]::Bool=false)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation first checks inclusion of <code>X</code> in <code>Y</code> and then checks noninclusion of <code>Y</code> in <code>X</code>:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/ConcreteOperations/isstrictsubset.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet" href="#Base.:⊆-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}-lib-interfaces-LazySet"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">⊆(X::LazySet, Y::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a set is a subset of another set, and optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>Y</code>       – set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If the <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊆ Y$</span></li><li>If the <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ⊆ Y$</span></li><li><code>(false, v)</code> iff <span>$X ⊈ Y$</span> for some <span>$v ∈ X ∖ Y$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>The convenience alias <code>issubset</code> is also available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/API/Binary/issubset.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Extended help</strong></p><pre><code class="nohighlight hljs">⊆(X::LazySet, Y::LazySet, witness::Bool=false)</code></pre><p><strong>Algorithm</strong></p><p>The default implementation assumes that <code>Y</code> is polyhedral, i.e., that <code>constraints_list(Y)</code> is available, and checks inclusion of <code>X</code> in every constraint of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/ConcreteOperations/issubset.jl#L10-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.minkowski_difference-Tuple{LazySet, LazySet}" href="#LazySets.API.minkowski_difference-Tuple{LazySet, LazySet}"><code>LazySets.API.minkowski_difference</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minkowski_difference(P::LazySet, Q::LazySet)</code></pre><p>Concrete Minkowski difference (geometric difference) of a polytopic set and a compact set.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polytopic set</li><li><code>Q</code> – compact set that is subtracted from <code>P</code></li></ul><p><strong>Output</strong></p><p>An <code>HPolytope</code> that corresponds to the Minkowski difference of <code>P</code> minus <code>Q</code> if <code>P</code> is bounded, and an <code>HPolyhedron</code> if <code>P</code> is unbounded.</p><p><strong>Notes</strong></p><p>This implementation requires that the set <code>P</code> is polyhedral and that the set <code>Q</code> is bounded.</p><p><strong>Algorithm</strong></p><p>This method implements <a href="../../../bibliography/#KolmanovskyG98">Kolmanovsky and Gilbert [KG98]</a>, Theorem 2.3:</p><p>Suppose <span>$P$</span> is a polyhedron</p><p class="math-container">\[P = \{z ∈ ℝ^n: sᵢᵀz ≤ rᵢ,~i = 1, …, k\}.\]</p><p>where <span>$sᵢ ∈ ℝ^n, sᵢ ≠ 0$</span>, and <span>$rᵢ ∈ ℝ$</span>. Assume <span>$ρ(sᵢ,Q)$</span> is defined for <span>$i = 1, …, k$</span>. Then the Minkowski difference is</p><p class="math-container">\[\{z ∈ ℝ^n: sᵢᵀz ≤ rᵢ - ρ(sᵢ,Q),~i = 1, …, k\}.\]</p><p>While the algorithm applies the support function to <code>Q</code>, we have that <span>$P ⊖ Q = P ⊖ \text{CH}(Q)$</span> whenever <code>P</code> is convex, where CH denotes the convex hull. Hence, if <code>Q</code> is not convex by type information, we wrap it in a lazy <code>ConvexHull</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/ConcreteOperations/minkowski_difference.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.API.minkowski_sum-Tuple{LazySet, LazySet}" href="#LazySets.API.minkowski_sum-Tuple{LazySet, LazySet}"><code>LazySets.API.minkowski_sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minkowski_sum(P::LazySet, Q::LazySet;
              [backend]=nothing, [algorithm]=nothing, [prune]=true)</code></pre><p>Compute the Minkowski sum of two polyhedral sets.</p><p><strong>Input</strong></p><ul><li><code>P</code>         – polyhedral set</li><li><code>Q</code>         – polyhedral set</li><li><code>backend</code>   – (optional, default: <code>nothing</code>) polyhedral computations backend</li><li><code>algorithm</code> – (optional, default: <code>nothing</code>) algorithm to eliminate                variables; available options are <code>Polyhedra.FourierMotzkin</code>,                <code>Polyhedra.BlockElimination</code>, and <code>Polyhedra.ProjectGenerators</code></li><li><code>prune</code>     – (optional, default: <code>true</code>) if <code>true</code>, apply a post-processing                to remove redundant constraints or vertices</li></ul><p><strong>Output</strong></p><p>In two dimensions, if the sets are polygons, the result is a <code>VPolygon</code>. In higher dimensions, the result is an <code>HPolytope</code> if both <code>P</code> and <code>Q</code> are known to be bounded by their types, and an <code>HPolyhedron</code> otherwise.</p><p><strong>Notes</strong></p><p>This method requires that the list of constraints of both sets <code>P</code> and <code>Q</code> can be obtained. After obtaining the respective lists of constraints, the <code>minkowski_sum</code> method for polyhedral sets is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/ConcreteOperations/minkowski_sum.jl#L1-L29">source</a></section></article><p>Undocumented implementations:</p><ul><li><a href="../../API/#LazySets.API.high-Tuple{LazySets.API.LazySet, Int64}"><code>high</code></a></li><li><a href="../../API/#LazySets.API.low-Tuple{LazySets.API.LazySet, Int64}"><code>low</code></a></li><li><a href="../../API/#LazySets.API.exact_sum-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>exact_sum</code></a></li><li><a href="../../API/#LazySets.API.linear_combination-Tuple{LazySets.API.LazySet, LazySets.API.LazySet}"><code>linear_combination</code></a></li></ul><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>Plotting via the <code>Plots</code> package is available for one- or two-dimensional sets. The default algorithm is to plot an outer approximation using the support function (1D) respectively the support vector (2D). This means that (1) plotting will fail if these functionalities are not available (e.g., for lazy <code>Intersection</code>s) and (2) that plots of non-convex sets can be misleading. The implementation below internally relies on the function <code>plot_recipe</code>. For some set types (e.g., <code>Intersection</code>), the default implementation is overridden.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol, Any}, LazySet{N}}, Tuple{AbstractDict{Symbol, Any}, LazySet{N}, Real}} where N" href="#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol, Any}, LazySet{N}}, Tuple{AbstractDict{Symbol, Any}, LazySet{N}, Real}} where N"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_lazyset(X::LazySet{N}, [ε]::Real=N(PLOT_PRECISION); ...) where {N}</code></pre><p>Plot a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li><li><code>ε</code> – (optional, default: <code>PLOT_PRECISION</code>) approximation error bound</li></ul><p><strong>Notes</strong></p><p>This recipe just defines the default plotting options and then calls the function <code>plot_recipe</code>, which then implements the set-specific plotting.</p><p>The argument <code>ε</code> is ignored by some set types, e.g., for polyhedra (subtypes of <code>AbstractPolyhedron</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; B = Ball2(ones(2), 0.1);

julia&gt; plot(B, 1e-3)  # default accuracy value (explicitly given for clarity here)

julia&gt; plot(B, 1e-2)  # faster but less accurate than the previous call</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Plotting/plot_recipes.jl#L298-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{VN}, Tuple{N}, Tuple{AbstractDict{Symbol, Any}, AbstractVector{VN}}, Tuple{AbstractDict{Symbol, Any}, AbstractVector{VN}, Real}, Tuple{AbstractDict{Symbol, Any}, AbstractVector{VN}, Real, Int64}} where {N, VN&lt;:LazySet{N}}" href="#RecipesBase.apply_recipe-Union{Tuple{VN}, Tuple{N}, Tuple{AbstractDict{Symbol, Any}, AbstractVector{VN}}, Tuple{AbstractDict{Symbol, Any}, AbstractVector{VN}, Real}, Tuple{AbstractDict{Symbol, Any}, AbstractVector{VN}, Real, Int64}} where {N, VN&lt;:LazySet{N}}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_list(list::AbstractVector{VN}, [ε]::Real=N(PLOT_PRECISION),
          [Nφ]::Int=PLOT_POLAR_DIRECTIONS; [same_recipe]=false; ...)
    where {N, VN&lt;:LazySet{N}}</code></pre><p>Plot a list of sets.</p><p><strong>Input</strong></p><ul><li><code>list</code> – list of sets (1D or 2D)</li><li><code>ε</code>    – (optional, default: <code>PLOT_PRECISION</code>) approximation error bound</li><li><code>Nφ</code>   – (optional, default: <code>PLOT_POLAR_DIRECTIONS</code>) number of polar           directions (used to plot lazy intersections)</li><li><code>same_recipe</code> – (optional, default: <code>false</code>) switch for faster plotting but           without individual plot recipes (see notes below)</li></ul><p><strong>Notes</strong></p><p>For each set in the list we apply an individual plot recipe.</p><p>The option <code>same_recipe</code> provides access to a faster plotting scheme where all sets in the list are first converted to polytopes and then plotted in one single run. This, however, is not suitable when plotting flat sets (line segments, singletons) because then the polytope plot recipe does not deliver good results. Hence by default we do not use this option. For plotting a large number of (non-flat) polytopes, we highly advise activating this option.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; B1 = BallInf(zeros(2), 0.4);

julia&gt; B2 = BallInf(ones(2), 0.4);

julia&gt; plot([B1, B2])</code></pre><p>Some of the sets in the list may not be plotted precisely but rather overapproximated first. The second argument <code>ε</code> controls the accuracy of this overapproximation.</p><pre><code class="language-julia hljs">julia&gt; Bs = [BallInf(zeros(2), 0.4), Ball2(ones(2), 0.4)];

julia&gt; plot(Bs, 1e-3)  # default accuracy value (explicitly given for clarity)

julia&gt; plot(Bs, 1e-2)  # faster but less accurate than the previous call</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Plotting/plot_recipes.jl#L114-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.plot_vlist-Union{Tuple{S}, Tuple{S, Real}} where S&lt;:LazySet" href="#LazySets.plot_vlist-Union{Tuple{S}, Tuple{S, Real}} where S&lt;:LazySet"><code>LazySets.plot_vlist</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_vlist(X::S, ε::Real) where {S&lt;:LazySet}</code></pre><p>Return a list of vertices used for plotting a two-dimensional set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – two-dimensional set</li><li><code>ε</code> – precision parameter</li></ul><p><strong>Output</strong></p><p>A list of vertices of a polygon <code>P</code>. For convex <code>X</code>, <code>P</code> usually satisfies that the Hausdorff distance to <code>X</code> is less than <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L283-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.plot_recipe-Tuple{LazySet, Any}" href="#LazySets.plot_recipe-Tuple{LazySet, Any}"><code>LazySets.plot_recipe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_recipe(X::LazySet, [ε])</code></pre><p>Convert a compact convex set to a pair <code>(x, y)</code> of points for plotting.</p><p><strong>Input</strong></p><ul><li><code>X</code> – compact convex set</li><li><code>ε</code> – approximation-error bound</li></ul><p><strong>Output</strong></p><p>A pair <code>(x, y)</code> of points that can be plotted.</p><p><strong>Notes</strong></p><p>We do not support three-dimensional or higher-dimensional sets at the moment.</p><p><strong>Algorithm</strong></p><p>One-dimensional sets are converted to an <code>Interval</code>.</p><p>For two-dimensional sets, we first compute a polygonal overapproximation. The second argument, <code>ε</code>, corresponds to the error in Hausdorff distance between the overapproximating set and <code>X</code>. On the other hand, if you only want to produce a fast box-overapproximation of <code>X</code>, pass <code>ε=Inf</code>.</p><p>Finally, we use the plot recipe for the constructed set (interval or polygon).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/LazySet_functions.jl#L674-L703">source</a></section></article><p>For three-dimensional sets, we support <code>Makie</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.plot3d" href="#LazySets.plot3d"><code>LazySets.plot3d</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot3d(S::LazySet; [backend]=default_polyhedra_backend(S), [alpha]=1.0,
       [color]=:blue, [colormap]=:viridis, [colorrange]=nothing,
       [interpolate]=false, [overdraw]=false, [shading]=true,
       [transparency]=true, [visible]=true)</code></pre><p>Plot a three-dimensional set using <code>Makie</code>.</p><p><strong>Input</strong></p><ul><li><code>S</code>            – set</li><li><code>backend</code>      – (optional, default: <code>default_polyhedra_backend(S)</code>) backend                   for polyhedral computations</li><li><code>alpha</code>        – (optional, default: <code>1.0</code>) float in <code>[0,1]</code>; the alpha or                   transparency value</li><li><code>color</code>        – (optional, default: <code>:blue</code>) <code>Symbol</code> or <code>Colorant</code>; the                   color of the main plot element (markers, lines, etc.), which                   can be a color symbol/string like <code>:red</code></li><li><code>colormap</code>     – (optional, default: <code>:viridis</code>) the color map of the main                   plot; use <code>available_gradients()</code> to see which gradients are                   available, which can also be used as <code>[:red, :black]</code></li><li><code>colorrange</code>   – (optional, default: <code>nothing</code>, which falls back to                   <code>Makie.Automatic()</code>) a tuple <code>(min, max)</code> where <code>min</code> and                   <code>max</code> specify the data range to be used for indexing the                   <code>colormap</code></li><li><code>interpolate</code>  – (optional, default: <code>false</code>) a boolean for heatmap and                   images; toggles color interpolation between nearby pixels</li><li><code>overdraw</code>     – (optional, default: <code>false</code>)</li><li><code>shading</code>      – (optional, default: <code>true</code>) a boolean that toggles shading                   (for meshes)</li><li><code>transparency</code> – (optional, default: <code>true</code>) if <code>true</code>, the set is                   transparent, otherwise it is displayed as a solid object</li><li><code>visible</code>      – (optional, default: <code>true</code>) a boolean that toggles                   visibility of the plot</li></ul><p>For a complete list of attributes and usage see <a href="http://makie.juliaplots.org/stable/plot-attributes">Makie&#39;s documentation</a>.</p><p><strong>Notes</strong></p><p>This plot recipe works by computing the list of constraints of <code>S</code> and converting to a polytope in H-representation. Then, this polytope is transformed with <code>Polyhedra.Mesh</code> and plotted using the <code>mesh</code> function.</p><p>If the function <code>constraints_list</code> is not applicable to your set <code>S</code>, try overapproximation first; e.g. via</p><pre><code class="language-julia hljs">julia&gt; Sapprox = overapproximate(S, SphericalDirections(10))

julia&gt; using Polyhedra, GLMakie

julia&gt; plot3d(Sapprox)</code></pre><p>The number <code>10</code> above corresponds to the number of directions considered; for better resolution use higher values (but it will take longer).</p><p>For efficiency consider using the <code>CDDLib</code> backend, as in</p><pre><code class="language-julia hljs">julia&gt; using CDDLib

julia&gt; plot3d(Sapprox, backend=CDDLib.Library())</code></pre><p><strong>Examples</strong></p><p>The functionality requires <em>both</em> <code>Polyhedra</code> and a <code>Makie</code> backend. After loading <code>LazySets</code>, do <code>using Polyhedra, GLMakie</code> (or another Makie backend).</p><pre><code class="language-julia hljs">julia&gt; using LazySets, Polyhedra, GLMakie

julia&gt; plot3d(10 * rand(Hyperrectangle, dim=3))

julia&gt; plot3d!(10 * rand(Hyperrectangle, dim=3), color=:red)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Plotting/mesh.jl#L34-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.plot3d!" href="#LazySets.plot3d!"><code>LazySets.plot3d!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot3d!(S::LazySet; backend=default_polyhedra_backend(S), [alpha]=1.0,
       [color]=:blue, [colormap]=:viridis, [colorrange]=nothing,
       [interpolate]=false, [overdraw]=false, [shading]=true,
       [transparency]=true, [visible]=true)</code></pre><p>Plot a three-dimensional set using Makie.</p><p><strong>Input</strong></p><p>See <code>plot3d</code> for the description of the inputs. For a complete list of attributes and usage see <a href="http://makie.juliaplots.org/stable/plot-attributes">Makie&#39;s documentation</a>.</p><p><strong>Notes</strong></p><p>See the documentation of <code>plot3d</code> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Plotting/mesh.jl#L127-L144">source</a></section></article><h2 id="Aliases-for-set-types"><a class="docs-heading-anchor" href="#Aliases-for-set-types">Aliases for set types</a><a id="Aliases-for-set-types-1"></a><a class="docs-heading-anchor-permalink" href="#Aliases-for-set-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.CompactSet" href="#LazySets.CompactSet"><code>LazySets.CompactSet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CompactSet</code></pre><p>An alias for compact set types.</p><p><strong>Notes</strong></p><p>Most lazy operations are not captured by this alias because whether their result is compact depends on the argument(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/aliases.jl#L4-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LazySets.NonCompactSet" href="#LazySets.NonCompactSet"><code>LazySets.NonCompactSet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NonCompactSet</code></pre><p>An alias for non-compact set types.</p><p><strong>Notes</strong></p><p>Most lazy operations are not captured by this alias because whether their result is non-compact depends on the argument(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/71816e6ee03324d9cad2269ab169cff5aef576d5/src/Interfaces/aliases.jl#L20-L29">source</a></section></article><h2 id="Implementations"><a class="docs-heading-anchor" href="#Implementations">Implementations</a><a id="Implementations-1"></a><a class="docs-heading-anchor-permalink" href="#Implementations" title="Permalink"></a></h2><p>Concrete set representations:</p><ul><li><a href="../../sets/EmptySet/#def_EmptySet">Empty set (EmptySet)</a></li></ul><p>Lazy set operations:</p><ul><li><a href="../../lazy_operations/AffineMap/#def_AffineMap">Affine map (AffineMap)</a></li><li><a href="../../lazy_operations/LinearMap/#def_LinearMap">Linear map (LinearMap)</a></li><li><a href="../../lazy_operations/ExponentialMap/#def_ExponentialMap">Exponential map (ExponentialMap)</a></li><li><a href="../../lazy_operations/ExponentialMap/#def_ExponentialProjectionMap">Exponential projection map (ExponentialProjectionMap)</a></li><li><a href="../../lazy_operations/ResetMap/#def_ResetMap">Reset map (ResetMap)</a></li><li><a href="../../lazy_operations/Translation/#def_Translation">Translation</a></li><li><a href="../../lazy_operations/Bloating/#def_Bloating">Bloating</a></li><li><a href="../../lazy_operations/CartesianProduct/#def_CartesianProduct">Binary Cartesian product (CartesianProduct)</a></li><li><a href="../../lazy_operations/CartesianProduct/#def_CartesianProductArray"><span>$n$</span>-ary Cartesian product (CartesianProductArray)</a></li><li><a href="../../lazy_operations/ConvexHull/#def_ConvexHull">Binary convex hull (ConvexHull)</a></li><li><a href="../../lazy_operations/ConvexHull/#def_ConvexHullArray"><span>$n$</span>-ary convex hull (ConvexHullArray)</a></li><li><a href="../../lazy_operations/Intersection/#def_Intersection">Binary intersection</a></li><li><a href="../../lazy_operations/Intersection/#def_IntersectionArray"><span>$n$</span>-ary intersection (IntersectionArray)</a></li><li><a href="../../lazy_operations/MinkowskiSum/#def_MinkowskiSum">Binary Minkowski sum (MinkowskiSum)</a></li><li><a href="../../lazy_operations/MinkowskiSum/#def_MinkowskiSumArray"><span>$n$</span>-ary Minkowski sum (MinkowskiSumArray)</a></li><li><a href="../../lazy_operations/MinkowskiSum/#def_CachedMinkowskiSumArray"><span>$n$</span>-ary Minkowski sum with cache (CachedMinkowskiSumArray)</a></li><li><a href="../../lazy_operations/UnionSet/#def_UnionSet">Binary set union (UnionSet)</a></li><li><a href="../../lazy_operations/UnionSet/#def_UnionSetArray"><span>$n$</span>-ary set union (UnionSetArray)</a></li><li><a href="../../lazy_operations/Complement/#def_Complement">Complement</a></li><li><a href="../../lazy_operations/Rectification/#def_Rectification">Rectification</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview/">« Overview</a><a class="docs-footer-nextpage" href="../ConvexSet/">Convex sets (ConvexSet) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 23 September 2025 01:04">Tuesday 23 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
