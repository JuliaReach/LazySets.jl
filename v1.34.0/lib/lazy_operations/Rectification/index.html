<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rectification · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link href="../../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../../"><img class="logo" src="../../../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../../man/getting_started/">Getting Started</a></li><li><a class="toctext" href="../../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="toctext" href="../../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="toctext" href="../../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="toctext" href="../../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="toctext" href="../../../man/interval_hulls/">Interval Hulls</a></li><li><a class="toctext" href="../../../man/convex_hulls/">Convex Hulls</a></li><li><a class="toctext" href="../../../man/set_operations/">Operations on Sets</a></li><li><a class="toctext" href="../../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="toctext" href="../../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="toctext" href="../../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="toctext" href="../../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../../interfaces/">Interfaces</a></li><li><span class="toctext">Sets</span><ul><li><a class="toctext" href="../../sets/Ball1/">Ball1</a></li><li><a class="toctext" href="../../sets/Ball2/">Ball2</a></li><li><a class="toctext" href="../../sets/BallInf/">BallInf</a></li><li><a class="toctext" href="../../sets/Ballp/">Ballp</a></li><li><a class="toctext" href="../../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="toctext" href="../../sets/EmptySet/">EmptySet</a></li><li><a class="toctext" href="../../sets/HalfSpace/">HalfSpace</a></li><li><a class="toctext" href="../../sets/HPolygon/">HPolygon</a></li><li><a class="toctext" href="../../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="toctext" href="../../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="toctext" href="../../sets/HPolytope/">HPolytope</a></li><li><a class="toctext" href="../../sets/Hyperplane/">Hyperplane</a></li><li><a class="toctext" href="../../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="toctext" href="../../sets/Interval/">Interval</a></li><li><a class="toctext" href="../../sets/Line/">Line</a></li><li><a class="toctext" href="../../sets/LineSegment/">LineSegment</a></li><li><a class="toctext" href="../../sets/PolynomialZonotope/">PolynomialZonotope</a></li><li><a class="toctext" href="../../sets/Singleton/">Singleton</a></li><li><a class="toctext" href="../../sets/Universe/">Universe</a></li><li><a class="toctext" href="../../sets/VPolygon/">VPolygon</a></li><li><a class="toctext" href="../../sets/VPolytope/">VPolytope</a></li><li><a class="toctext" href="../../sets/ZeroSet/">ZeroSet</a></li><li><a class="toctext" href="../../sets/Zonotope/">Zonotope</a></li></ul></li><li><span class="toctext">Lazy Operations</span><ul><li><a class="toctext" href="../AffineMap/">AffineMap</a></li><li><a class="toctext" href="../Bloating/">Bloating</a></li><li><a class="toctext" href="../CartesianProduct/">CartesianProduct</a></li><li><a class="toctext" href="../Complement/">Complement</a></li><li><a class="toctext" href="../ConvexHull/">ConvexHull</a></li><li><a class="toctext" href="../ExponentialMap/">ExponentialMap</a></li><li><a class="toctext" href="../Intersection/">Intersection</a></li><li><a class="toctext" href="../LinearMap/">LinearMap</a></li><li><a class="toctext" href="../MinkowskiSum/">MinkowskiSum</a></li><li class="current"><a class="toctext" href>Rectification</a><ul class="internal"><li><a class="toctext" href="#Rectification-cache-1">Rectification cache</a></li></ul></li><li><a class="toctext" href="../ResetMap/">ResetMap</a></li><li><a class="toctext" href="../SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="toctext" href="../Translation/">Translation</a></li><li><a class="toctext" href="../UnionSet/">UnionSet</a></li></ul></li><li><a class="toctext" href="../../binary_functions/">Concrete Operations</a></li><li><a class="toctext" href="../../conversion/">Conversions between set representations</a></li><li><a class="toctext" href="../../comparisons/">Comparisons</a></li><li><a class="toctext" href="../../approximations/">Approximations</a></li><li><a class="toctext" href="../../utils/">Utility Functions</a></li><li><a class="toctext" href="../../parallel/">Parallel</a></li></ul></li><li><a class="toctext" href="../../../about/">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li>Lazy Operations</li><li><a href>Rectification</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/lazy_operations/Rectification.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Rectification</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="def_Rectification-1" href="#def_Rectification-1">Rectification</a></h1><p>Note that the rectification of a convex set is generally not convex. Hence this set type is not part of the convex-set family <code>LazySet</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Rectification" href="#LazySets.Rectification"><code>LazySets.Rectification</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Rectification{N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Type that represents the rectification of a convex set.</p><p><strong>Fields</strong></p><ul><li><code>X</code>     – convex set</li><li><code>cache</code> – storage of information computed before</li></ul><p><strong>Notes</strong></p><p>Given a vector <span>$v = (v_1, …, v_n)$</span>, its rectification is defined as <span>$\text{rectify}(v) = (v_1&#39;, …, v_n&#39;)$</span> such that <span>$v_i&#39; = \max(v_i, 0)$</span> for each <span>$i = 1, …, n$</span>.</p><p>The extension to a set <span>$X$</span> is defined elementwise:</p><div>\[    \text{rectify}(X) = \{\text{rectify}(x) \mid x ∈ X\}\]</div><p>The rectification of a convex set <span>$X$</span> is not necessarily convex. It can be expressed exactly as the union of the intersection of <span>$X$</span> with the nonnegative orthant and the projection of the intersection of <span>$X$</span> with each other orthant. This can be seen as follows.</p><p>First we observe that rectification distributes with union.</p><div>\[    \text{rectify}(X_1 ∪ … ∪ X_m) = ⋃_j \text{rectify}(X_j)\]</div><p>Next we express <span>$X$</span> as the union of the intersection of <span>$X$</span> with each orthant <span>$O$</span>.</p><div>\[    X = ⋃_j (X ∩ O_j)\]</div><p>Thus we have</p><div>\[    \text{rectify}(X) = \text{rectify}((X ∩ O_1) ∪ … ∪ (X ∩ O_m)) = ⋃_j \text{rectify}(X ∩ O_j).\]</div><p>Clearly, <span>$\text{rectify}(X ∩ O_j) = X$</span> if <span>$O_j$</span> is the nonnegative orthant.</p><p>For example, consider a two-dimensional case and call the orthants <span>$O_1, …, O_4$</span> in clockwise fashion, starting with the nonnegative orthant. We conclude that</p><div>\[    \text{rectify}(X) = (X ∩ O_1) ∪ \text{rectify}(X ∩ O_2) ∪ \text{rectify}(X ∩ O_3) ∪ \text{rectify}(X ∩ O_4).\]</div><p>The rectification of the intersection in the nonpositive orthant, <span>$\text{rectify}(X ∩ O_3)$</span>, is either the empty set or the singleton containing the origin. The rectification of <span>$X ∩ O_2$</span> and <span>$X ∩ O_4$</span> both result in flat <span>$1$</span>-dimensional line segments on the corresponding hyperplane of <span>$O_1$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/2c637151709be5968415449769da3d42bb86be25/src/LazyOperations/Rectification.jl#L28-L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{Rectification}" href="#LazySets.dim-Tuple{Rectification}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(r::Rectification)</code></pre><p>Return the dimension of a rectification.</p><p><strong>Input</strong></p><ul><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the rectification.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/2c637151709be5968415449769da3d42bb86be25/src/LazyOperations/Rectification.jl#L116-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, r::Rectification{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a rectification.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/2c637151709be5968415449769da3d42bb86be25/src/LazyOperations/Rectification.jl#L133-L147">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,#s15} where #s15&lt;:AbstractHyperrectangle{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,#s15} where #s15&lt;:AbstractHyperrectangle{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N},
  r::Rectification{N, &lt;:AbstractHyperrectangle{N}}) where {N&lt;:Real}</code></pre><p>Return the support vector of the rectification of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>r</code> – rectification of a hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>Let <span>$r(·)$</span> be the rectification of a vector respectively a set, and let <span>$H$</span> be a hyperrectangle. Then <span>$σ_{r(H)}(d) = r(σ_{H}(d))$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/2c637151709be5968415449769da3d42bb86be25/src/LazyOperations/Rectification.jl#L155-L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,#s15} where #s15&lt;:(CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N})}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,#s15} where #s15&lt;:(CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N})}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N},
  r::Rectification{N, &lt;:CartesianProduct{N}}) where {N&lt;:Real}</code></pre><p>Return the support vector of the rectification of a Cartesian product of two convex sets.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>r</code> – rectification of a Cartesian product of two convex sets</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>Rectification distributes with the Cartesian product. Let <span>$r(·)$</span> be the rectification of a set. We can just query the support vector for <span>$r(X)$</span> and <span>$r(Y)$</span> recursively: <span>$σ_{r(X × Y)}(d) = σ_{r(X)}(d_X) × σ_{r(Y)}(d_Y)$</span>, where <span>$x × y$</span> concatenates vectors <span>$x$</span> and <span>$y$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/2c637151709be5968415449769da3d42bb86be25/src/LazyOperations/Rectification.jl#L181-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,#s15} where #s15&lt;:(CartesianProductArray{N,S} where S&lt;:LazySet{N})}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,#s15} where #s15&lt;:(CartesianProductArray{N,S} where S&lt;:LazySet{N})}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N},
  r::Rectification{N, &lt;:CartesianProductArray{N}}) where {N&lt;:Real}</code></pre><p>Return the support vector of the rectification of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>r</code> – rectification of a Cartesian product of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>Rectification distributes with the Cartesian product. Let <span>$r(·)$</span> be the rectification of a set. We can just query the support vector for each subspace recursively: <span>$σ_{r(X_1 × ⋯ × X_m)}(d) = σ_{r(X_1)}(d_{X_1}) × ⋯ × σ_{r(X_m)}(d_{X_m})$</span>, where <span>$x × y$</span> concatenates vectors <span>$x$</span> and <span>$y$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/2c637151709be5968415449769da3d42bb86be25/src/LazyOperations/Rectification.jl#L212-L235">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, r::Rectification{N}) where {N&lt;:Real}</code></pre><p>Evaluate the support function of a rectification of a convex set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>r</code> – rectification of a convex set</li></ul><p><strong>Output</strong></p><p>The support value of the rectification of a convex set in the given direction.</p><p><strong>Algorithm</strong></p><p>We use different procedures for different types of input sets. If the wrapped set has a suitable structure for which we can efficiently compute the support vector, we fall back to the evaluation of the support function by means of the support vector. Otherwise we compute the union of projections to obtain a precise result (see <a href="#LazySets.to_union_of_projections-Union{Tuple{Rectification{N,S} where S&lt;:LazySet{N}}, Tuple{N}, Tuple{Rectification{N,S} where S&lt;:LazySet{N},Bool}} where N&lt;:Real"><code>to_union_of_projections</code></a>), and then compute the support function for this union. (The union is cached internally, so subsequent queries are more efficient.)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/2c637151709be5968415449769da3d42bb86be25/src/LazyOperations/Rectification.jl#L249-L274">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{Rectification{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{Rectification{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(r::Rectification{N}) where {N&lt;:Real}</code></pre><p>Return some element of a rectification.</p><p><strong>Input</strong></p><ul><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p>An element in the rectification. The implementation relies on the <code>an_element</code> function of the wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/2c637151709be5968415449769da3d42bb86be25/src/LazyOperations/Rectification.jl#L285-L298">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, r::Rectification{N}) where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a rectification.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ r$</span>.</p><p><strong>Algorithm</strong></p><p>We first scan for negative entries in the vector. If there are any, the vector is not contained in the rectification.</p><p>Next we ask a membership query in the wrapped set. If the answer is positive, the vector is contained in the rectification.</p><p>Otherwise, we scan for zero entries in the vector. If there are none, membership reduces to membership in the wrapped set, and so the answer is negative.</p><p>Finally, if there are zero entries in the vector and the vector is not contained in the wrapped set, we give up and throw an error.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/2c637151709be5968415449769da3d42bb86be25/src/LazyOperations/Rectification.jl#L303-L331">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{Rectification}" href="#Base.isempty-Tuple{Rectification}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(r::Rectification)</code></pre><p>Check whether a rectification is empty or not.</p><p><strong>Input</strong></p><ul><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/2c637151709be5968415449769da3d42bb86be25/src/LazyOperations/Rectification.jl#L353-L365">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Union{Tuple{Rectification{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.isbounded-Union{Tuple{Rectification{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(r::Rectification)</code></pre><p>Determine whether a rectification is bounded.</p><p><strong>Input</strong></p><ul><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the rectification is bounded.</p><p><strong>Algorithm</strong></p><p>Let <span>$X$</span> be the set wrapped by rectification <span>$r$</span>. We first check whether <span>$X$</span> is bounded (because then <span>$r$</span> is bounded). Otherwise, we check unboundedness of <span>$X$</span> in direction <span>$(1, 1, …, 1)$</span>, which is sufficient for unboundedness of <span>$r$</span>; this step is not necessary but rather a heuristics. Otherwise, we check boundedness of <span>$X$</span> in every positive unit direction, which is sufficient and necessary for boundedness of <span>$r$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/2c637151709be5968415449769da3d42bb86be25/src/LazyOperations/Rectification.jl#L370-L392">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.to_union_of_projections-Union{Tuple{Rectification{N,S} where S&lt;:LazySet{N}}, Tuple{N}, Tuple{Rectification{N,S} where S&lt;:LazySet{N},Bool}} where N&lt;:Real" href="#LazySets.to_union_of_projections-Union{Tuple{Rectification{N,S} where S&lt;:LazySet{N}}, Tuple{N}, Tuple{Rectification{N,S} where S&lt;:LazySet{N},Bool}} where N&lt;:Real"><code>LazySets.to_union_of_projections</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">to_union_of_projections(r::Rectification{N},
                        concrete_intersection::Bool=false
                       ) where {N&lt;:Real}</code></pre><p>Compute an equivalent union of projections from a rectification of a convex set.</p><p><strong>Input</strong></p><ul><li><code>r</code>                     – rectification of a convex set</li><li><code>concrete_intersection</code> – (optional, default: <code>false</code>) option to compute                            all intersections concretely or lazily</li></ul><p><strong>Algorithm</strong></p><p>Let <span>$X$</span> be the set wrapped by the rectification <span>$r$</span>. We compute a union of sets that represents the rectification of <span>$X$</span> precisely. The sets are lazy projections, potentially of intersections.</p><p>We first identify those dimensions where <span>$X$</span> is negative, using one support-function query per dimension, and collect the dimensions in the index set <span>$I_\text{neg}$</span>. For each element in <span>$I_\text{neg}$</span> we will later apply a projection to zero.</p><p>Next we identify those dimensions from <span>$I_\text{neg}$</span> where <span>$X$</span> is also positive, using another support-function query in each dimension, and collect the dimensions in the index set <span>$I_\text{mix}$</span>. Let us call the remaining dimensions (<span>$I_\text{neg} \setminus I_\text{mix}$</span>) <span>$I_\text{nonpos}$</span>. For each dimension in <span>$j ∈ I_\text{mix}$</span> we will apply an intersection with axis-aligned polyhedra. In particular, we distinguish two cases using half-spaces <span>$x_j ≤ 0$</span> and <span>$x_j ≥ 0$</span>, and then compute all possible combinations to intersect, using one half-space per dimension <span>$j ∈ I_\text{mix}$</span>.</p><p>Next we project the intersections in all dimensions from <span>$i ∈ I_\text{mix}$</span> such that we used the half-space <span>$x_i ≤ 0$</span> in their computation, and in all dimensions <span>$j ∈ I_\text{nonpos}$</span> irrespective of the half-space used.</p><p>Finally, we take the union of the resulting sets.</p><p><strong>Output</strong></p><p>The result can be one of three cases depending on the wrapped set <span>$X$</span>, namely</p><ul><li>the set <span>$X$</span> if <span>$X$</span> is contained in the positive quadrant,</li><li>a <code>LinearMap</code> (projection) of <span>$X$</span> if for each dimension, <span>$X$</span> is only either positive or negative, or</li><li>a <code>UnionSetArray</code> of <code>LinearMaps</code> (projections) otherwise.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/2c637151709be5968415449769da3d42bb86be25/src/LazyOperations/Rectification.jl#L415-L463">source</a></section><h2><a class="nav-anchor" id="Rectification-cache-1" href="#Rectification-cache-1">Rectification cache</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.RectificationCache" href="#LazySets.RectificationCache"><code>LazySets.RectificationCache</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">RectificationCache{N&lt;:Real}</code></pre><p>Struct that is used as a cache for <a href="#LazySets.Rectification"><code>Rectification</code></a>s.</p><p><strong>Fields</strong></p><ul><li><code>set</code>                – set represented by the rectification (can be <code>nothing</code>                         if not computed yet)</li><li><code>use_support_vector</code> – flag indicating whether to use support-vector                         computations for the cached set</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/2c637151709be5968415449769da3d42bb86be25/src/LazyOperations/Rectification.jl#L5-L16">source</a></section><footer><hr/><a class="previous" href="../MinkowskiSum/"><span class="direction">Previous</span><span class="title">MinkowskiSum</span></a><a class="next" href="../ResetMap/"><span class="direction">Next</span><span class="title">ResetMap</span></a></footer></article></body></html>
