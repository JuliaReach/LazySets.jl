<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SymmetricIntervalHull · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link href="../../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../../"><img class="logo" src="../../../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../../man/getting_started/">Getting Started</a></li><li><a class="toctext" href="../../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="toctext" href="../../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="toctext" href="../../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="toctext" href="../../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="toctext" href="../../../man/interval_hulls/">Interval Hulls</a></li><li><a class="toctext" href="../../../man/convex_hulls/">Convex Hulls</a></li><li><a class="toctext" href="../../../man/set_operations/">Operations on Sets</a></li><li><a class="toctext" href="../../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="toctext" href="../../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="toctext" href="../../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="toctext" href="../../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../../interfaces/">Interfaces</a></li><li><span class="toctext">Sets</span><ul><li><a class="toctext" href="../../sets/Ball1/">Ball1</a></li><li><a class="toctext" href="../../sets/Ball2/">Ball2</a></li><li><a class="toctext" href="../../sets/BallInf/">BallInf</a></li><li><a class="toctext" href="../../sets/Ballp/">Ballp</a></li><li><a class="toctext" href="../../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="toctext" href="../../sets/EmptySet/">EmptySet</a></li><li><a class="toctext" href="../../sets/HalfSpace/">HalfSpace</a></li><li><a class="toctext" href="../../sets/HPolygon/">HPolygon</a></li><li><a class="toctext" href="../../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="toctext" href="../../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="toctext" href="../../sets/HPolytope/">HPolytope</a></li><li><a class="toctext" href="../../sets/Hyperplane/">Hyperplane</a></li><li><a class="toctext" href="../../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="toctext" href="../../sets/Interval/">Interval</a></li><li><a class="toctext" href="../../sets/Line/">Line</a></li><li><a class="toctext" href="../../sets/LineSegment/">LineSegment</a></li><li><a class="toctext" href="../../sets/PolynomialZonotope/">PolynomialZonotope</a></li><li><a class="toctext" href="../../sets/Singleton/">Singleton</a></li><li><a class="toctext" href="../../sets/Universe/">Universe</a></li><li><a class="toctext" href="../../sets/VPolygon/">VPolygon</a></li><li><a class="toctext" href="../../sets/VPolytope/">VPolytope</a></li><li><a class="toctext" href="../../sets/ZeroSet/">ZeroSet</a></li><li><a class="toctext" href="../../sets/Zonotope/">Zonotope</a></li></ul></li><li><span class="toctext">Lazy Operations</span><ul><li><a class="toctext" href="../AffineMap/">AffineMap</a></li><li><a class="toctext" href="../Bloating/">Bloating</a></li><li><a class="toctext" href="../CartesianProduct/">CartesianProduct</a></li><li><a class="toctext" href="../Complement/">Complement</a></li><li><a class="toctext" href="../ConvexHull/">ConvexHull</a></li><li><a class="toctext" href="../ExponentialMap/">ExponentialMap</a></li><li><a class="toctext" href="../Intersection/">Intersection</a></li><li><a class="toctext" href="../LinearMap/">LinearMap</a></li><li><a class="toctext" href="../MinkowskiSum/">MinkowskiSum</a></li><li><a class="toctext" href="../Rectification/">Rectification</a></li><li><a class="toctext" href="../ResetMap/">ResetMap</a></li><li class="current"><a class="toctext" href>SymmetricIntervalHull</a><ul class="internal"></ul></li><li><a class="toctext" href="../Translation/">Translation</a></li><li><a class="toctext" href="../UnionSet/">UnionSet</a></li></ul></li><li><a class="toctext" href="../../binary_functions/">Concrete Operations</a></li><li><a class="toctext" href="../../conversion/">Conversions between set representations</a></li><li><a class="toctext" href="../../comparisons/">Comparisons</a></li><li><a class="toctext" href="../../approximations/">Approximations</a></li><li><a class="toctext" href="../../utils/">Utility Functions</a></li><li><a class="toctext" href="../../parallel/">Parallel</a></li></ul></li><li><a class="toctext" href="../../../about/">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li>Lazy Operations</li><li><a href>SymmetricIntervalHull</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/lazy_operations/SymmetricIntervalHull.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>SymmetricIntervalHull</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="def_SymmetricIntervalHull-1" href="#def_SymmetricIntervalHull-1">Symmetric interval hull (SymmetricIntervalHull)</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.SymmetricIntervalHull" href="#LazySets.SymmetricIntervalHull"><code>LazySets.SymmetricIntervalHull</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SymmetricIntervalHull{N&lt;:Real, S&lt;:LazySet{N}} &lt;: AbstractHyperrectangle{N}</code></pre><p>Type that represents the symmetric interval hull of a compact convex set.</p><p><strong>Fields</strong></p><ul><li><code>X</code>     – compact convex set</li><li><code>cache</code> – partial storage of already computed bounds, organized as mapping   from dimension to tuples <code>(bound, valid)</code>, where <code>valid</code> is a flag   indicating if the <code>bound</code> entry has been computed</li></ul><p><strong>Notes</strong></p><p>The symmetric interval hull can be computed with <span>$2n$</span> support vector queries of unit vectors, where <span>$n$</span> is the dimension of the wrapped set (i.e., two queries per dimension). When asking for the support vector for a direction <span>$d$</span>, one needs <span>$2k$</span> such queries, where <span>$k$</span> is the number of non-zero entries in <span>$d$</span>.</p><p>However, if one asks for many support vectors in a loop, the number of computations may exceed <span>$2n$</span>. To be most efficient in such cases, this type stores the intermediately computed bounds in the <code>cache</code> field.</p><p>The set <code>X</code> must be compact.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/LazyOperations/SymmetricIntervalHull.jl#L4-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{SymmetricIntervalHull}" href="#LazySets.dim-Tuple{SymmetricIntervalHull}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(sih::SymmetricIntervalHull)</code></pre><p>Return the dimension of a symmetric interval hull of a convex set.</p><p><strong>Input</strong></p><ul><li><code>sih</code> – symmetric interval hull of a convex set</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the symmetric interval hull of a convex set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/LazyOperations/SymmetricIntervalHull.jl#L140-L152">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},SymmetricIntervalHull{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},SymmetricIntervalHull{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, sih::SymmetricIntervalHull{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a symmetric interval hull of a convex set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>sih</code> – symmetric interval hull of a convex set</li></ul><p><strong>Output</strong></p><p>The support vector of the symmetric interval hull of a convex set in the given direction. If the direction has norm zero, the origin is returned.</p><p><strong>Algorithm</strong></p><p>For each non-zero entry in <code>d</code> we need to either look up the bound (if it has been computed before) or compute it, in which case we store it for future queries. One such computation just asks for the support vector of the underlying set for both the positive and negative unit vector in the respective dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/LazyOperations/SymmetricIntervalHull.jl#L157-L181">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Union{Tuple{SymmetricIntervalHull{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.center-Union{Tuple{SymmetricIntervalHull{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">center(sih::SymmetricIntervalHull{N}) where {N&lt;:Real}</code></pre><p>Return the center of a symmetric interval hull of a convex set.</p><p><strong>Input</strong></p><ul><li><code>sih</code> – symmetric interval hull of a convex set</li></ul><p><strong>Output</strong></p><p>The origin.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/LazyOperations/SymmetricIntervalHull.jl#L119-L131">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{SymmetricIntervalHull{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{SymmetricIntervalHull{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">radius_hyperrectangle(sih::SymmetricIntervalHull{N}) where {N&lt;:Real}</code></pre><p>Return the box radius of a symmetric interval hull of a convex set in every dimension.</p><p><strong>Input</strong></p><ul><li><code>sih</code> – symmetric interval hull of a convex set</li></ul><p><strong>Output</strong></p><p>The box radius of the symmetric interval hull of a convex set.</p><p><strong>Notes</strong></p><p>This function computes the symmetric interval hull explicitly.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/LazyOperations/SymmetricIntervalHull.jl#L89-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{SymmetricIntervalHull{N,S} where S&lt;:LazySet{N},Int64}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{SymmetricIntervalHull{N,S} where S&lt;:LazySet{N},Int64}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">radius_hyperrectangle(sih::SymmetricIntervalHull{N},
                      i::Int) where {N&lt;:Real}</code></pre><p>Return the box radius of a symmetric interval hull of a convex set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>sih</code> – symmetric interval hull of a convex set</li><li><code>i</code>   – dimension of interest</li></ul><p><strong>Output</strong></p><p>The radius in the given dimension. If it was computed before, this is just a look-up, otherwise it requires two support vector computations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/LazyOperations/SymmetricIntervalHull.jl#L66-L83">source</a></section><p>Inherited from <a href="../../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../../interfaces/#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../../interfaces/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><a href="../../interfaces/#LazySets.isbounded-Tuple{AbstractPolytope}"><code>isbounded</code></a></li><li><a href="../../interfaces/#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>singleton_list</code></a></li></ul><p>Inherited from <a href="../../interfaces/#LazySets.AbstractCentrallySymmetricPolytope"><code>AbstractCentrallySymmetricPolytope</code></a>:</p><ul><li><a href="../../interfaces/#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}"><code>isempty</code></a></li><li><a href="../../interfaces/#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><p>Inherited from <a href="../../interfaces/#LazySets.AbstractZonotope"><code>AbstractZonotope</code></a>:</p><ul><li><a href="../../interfaces/#LazySets.ngens-Tuple{AbstractZonotope}"><code>ngens</code></a></li><li><a href="../../interfaces/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractZonotope{N}}} where N&lt;:Real"><code>linear_map</code></a></li><li><a href="../../interfaces/#LazySets.order-Tuple{AbstractZonotope}"><code>order</code></a></li><li><a href="../../interfaces/#LazySets.togrep-Tuple{AbstractZonotope}"><code>togrep</code></a></li><li><a href="../../interfaces/#LazySets.translate-Union{Tuple{N}, Tuple{AbstractZonotope{N},AbstractArray{N,1}}} where N&lt;:Real"><code>translate</code></a></li></ul><p>Inherited from <a href="../../interfaces/#LazySets.AbstractHyperrectangle"><code>AbstractHyperrectangle</code></a>:</p><ul><li><a href="../../interfaces/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>ρ</code></a></li><li><a href="../../interfaces/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>σ</code></a></li><li><a href="../../interfaces/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>∈</code></a></li><li><a href="../../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../../interfaces/#LazySets.constraints_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>constraints_list</code></a></li><li><a href="../../interfaces/#LazySets.vertices_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>vertices_list</code></a></li><li><a href="../../interfaces/#LazySets.high-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>high</code></a></li><li><a href="../../interfaces/#LazySets.low-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>low</code></a></li><li><a href="../../interfaces/#LazySets.generators-Tuple{AbstractHyperrectangle}"><code>generators</code></a></li><li><a href="../../interfaces/#LazySets.genmat-Tuple{AbstractHyperrectangle}"><code>genmat</code></a></li></ul><footer><hr/><a class="previous" href="../ResetMap/"><span class="direction">Previous</span><span class="title">ResetMap</span></a><a class="next" href="../Translation/"><span class="direction">Next</span><span class="title">Translation</span></a></footer></article></body></html>
