<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conversions between set representations · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/getting_started/">Getting Started</a></li><li><a class="toctext" href="../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="toctext" href="../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="toctext" href="../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="toctext" href="../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="toctext" href="../../man/interval_hulls/">Interval Hulls</a></li><li><a class="toctext" href="../../man/convex_hulls/">Convex Hulls</a></li><li><a class="toctext" href="../../man/set_operations/">Operations on Sets</a></li><li><a class="toctext" href="../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="toctext" href="../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="toctext" href="../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="toctext" href="../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../interfaces/">Interfaces</a></li><li><span class="toctext">Sets</span><ul><li><a class="toctext" href="../sets/Ball1/">Ball1</a></li><li><a class="toctext" href="../sets/Ball2/">Ball2</a></li><li><a class="toctext" href="../sets/BallInf/">BallInf</a></li><li><a class="toctext" href="../sets/Ballp/">Ballp</a></li><li><a class="toctext" href="../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="toctext" href="../sets/EmptySet/">EmptySet</a></li><li><a class="toctext" href="../sets/HalfSpace/">HalfSpace</a></li><li><a class="toctext" href="../sets/HPolygon/">HPolygon</a></li><li><a class="toctext" href="../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="toctext" href="../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="toctext" href="../sets/HPolytope/">HPolytope</a></li><li><a class="toctext" href="../sets/Hyperplane/">Hyperplane</a></li><li><a class="toctext" href="../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="toctext" href="../sets/Interval/">Interval</a></li><li><a class="toctext" href="../sets/Line/">Line</a></li><li><a class="toctext" href="../sets/LineSegment/">LineSegment</a></li><li><a class="toctext" href="../sets/PolynomialZonotope/">PolynomialZonotope</a></li><li><a class="toctext" href="../sets/Singleton/">Singleton</a></li><li><a class="toctext" href="../sets/Universe/">Universe</a></li><li><a class="toctext" href="../sets/VPolygon/">VPolygon</a></li><li><a class="toctext" href="../sets/VPolytope/">VPolytope</a></li><li><a class="toctext" href="../sets/ZeroSet/">ZeroSet</a></li><li><a class="toctext" href="../sets/Zonotope/">Zonotope</a></li></ul></li><li><span class="toctext">Lazy Operations</span><ul><li><a class="toctext" href="../lazy_operations/AffineMap/">AffineMap</a></li><li><a class="toctext" href="../lazy_operations/Bloating/">Bloating</a></li><li><a class="toctext" href="../lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="toctext" href="../lazy_operations/Complement/">Complement</a></li><li><a class="toctext" href="../lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="toctext" href="../lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="toctext" href="../lazy_operations/Intersection/">Intersection</a></li><li><a class="toctext" href="../lazy_operations/LinearMap/">LinearMap</a></li><li><a class="toctext" href="../lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="toctext" href="../lazy_operations/Rectification/">Rectification</a></li><li><a class="toctext" href="../lazy_operations/ResetMap/">ResetMap</a></li><li><a class="toctext" href="../lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="toctext" href="../lazy_operations/Translation/">Translation</a></li><li><a class="toctext" href="../lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><a class="toctext" href="../binary_functions/">Concrete Operations</a></li><li class="current"><a class="toctext" href>Conversions between set representations</a><ul class="internal"></ul></li><li><a class="toctext" href="../comparisons/">Comparisons</a></li><li><a class="toctext" href="../approximations/">Approximations</a></li><li><a class="toctext" href="../utils/">Utility Functions</a></li><li><a class="toctext" href="../parallel/">Parallel</a></li></ul></li><li><a class="toctext" href="../../about/">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Conversions between set representations</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/conversion.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Conversions between set representations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Conversion-between-set-representations-1" href="#Conversion-between-set-representations-1">Conversion between set representations</a></h1><p>This section of the manual lists the conversion functions between set representations.</p><ul><li><a href="#Conversion-between-set-representations-1">Conversion between set representations</a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON2}, Tuple{HPOLYGON1}, Tuple{Type{HPOLYGON1},HPOLYGON2}} where HPOLYGON2&lt;:AbstractHPolygon where HPOLYGON1&lt;:AbstractHPolygon" href="#Base.convert-Union{Tuple{HPOLYGON2}, Tuple{HPOLYGON1}, Tuple{Type{HPOLYGON1},HPOLYGON2}} where HPOLYGON2&lt;:AbstractHPolygon where HPOLYGON1&lt;:AbstractHPolygon"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPOLYGON1},
        P::HPOLYGON2) where {HPOLYGON1&lt;:AbstractHPolygon,
                             HPOLYGON2&lt;:AbstractHPolygon}</code></pre><p>Convert between polygon types in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polygon</li></ul><p><strong>Output</strong></p><p>The polygon represented as the target type.</p><p><strong>Notes</strong></p><p>We need the <code>Union</code> type for <code>HPOLYGON1</code> because the target type must be concrete.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L12-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON},VPolygon}} where HPOLYGON&lt;:AbstractHPolygon" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON},VPolygon}} where HPOLYGON&lt;:AbstractHPolygon"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(T::Type{HPOLYGON}, P::VPolygon) where {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Converts a polygon in vertex representation to a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPOLYGON</code> – type used for dispatch</li><li><code>P</code>        – polygon in vertex representation</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L42-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{Hyperrectangle},AbstractHyperrectangle}" href="#Base.convert-Tuple{Type{Hyperrectangle},AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Hyperrectangle}, H::AbstractHyperrectangle)</code></pre><p>Convert a hyperrectangular set to a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – hyperrectangle type, used for dispatch</li><li><code>H</code>              – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; convert(Hyperrectangle, Interval(0.0, 1.0))
Hyperrectangle{Float64,Array{Float64,1},Array{Float64,1}}([0.5], [0.5])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L465-L485">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{Interval},AbstractHyperrectangle}" href="#Base.convert-Tuple{Type{Interval},AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Interval}, H::AbstractHyperrectangle)</code></pre><p>Converts a hyperrectangular set to an interval.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – interval type, used for dispatch</li><li><code>H</code>        – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>An interval.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; convert(Interval, Hyperrectangle([0.5], [0.5]))
Interval{Float64,IntervalArithmetic.Interval{Float64}}([0, 1])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L490-L510">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{Interval},LazySet{N}}} where N&lt;:Real" href="#Base.convert-Union{Tuple{N}, Tuple{Type{Interval},LazySet{N}}} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Interval}, S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Converts a convex set to an interval.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – interval type, used for dispatch</li><li><code>S</code>        – convex set</li></ul><p><strong>Output</strong></p><p>An interval.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L516-L529">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProductArray{N,HN}}} where HN&lt;:AbstractHyperrectangle{N} where N&lt;:Real" href="#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProductArray{N,HN}}} where HN&lt;:AbstractHyperrectangle{N} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Hyperrectangle},
        cpa::CartesianProductArray{N, HN}) where {N&lt;:Real, HN&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the cartesian product of a finite number of hyperrectangular sets to a single hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>S</code>              – cartesian product array of hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>This implementation uses the <code>center</code> and <code>radius_hyperrectangle</code> methods of <code>AbstractHyperrectangle</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L535-L555">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProductArray{N,Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}}}} where N&lt;:Real" href="#Base.convert-Union{Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProductArray{N,Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}}}} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Hyperrectangle},
        cpa::CartesianProductArray{N, Interval{N}}) where {N&lt;:Real}</code></pre><p>Converts the cartesian product of a finite number of intervals to a single hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>S</code>              – cartesian product array of intervals</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>This implementation uses the <code>min</code> and <code>max</code> methods of <code>Interval</code> to reduce the allocatons and improve performance (see LazySets#1143).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L600-L620">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON},AbstractHyperrectangle}} where HPOLYGON&lt;:AbstractHPolygon" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON},AbstractHyperrectangle}} where HPOLYGON&lt;:AbstractHPolygon"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPOLYGON}, H::AbstractHyperrectangle) where
    {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Converts a hyperrectangular set to a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPOLYGON</code>  – type used for dispatch</li><li><code>H</code>         – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L732-L746">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{VN}, Tuple{N}, Tuple{Type{HPOLYGON},HPolytope{N,VN}}} where HPOLYGON&lt;:AbstractHPolygon where VN&lt;:AbstractArray{N,1} where N&lt;:Real" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{VN}, Tuple{N}, Tuple{Type{HPOLYGON},HPolytope{N,VN}}} where HPOLYGON&lt;:AbstractHPolygon where VN&lt;:AbstractArray{N,1} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPOLYGON}, P::HPolytope{N}) where
    {N&lt;:Real, HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Convert from 2D polytope in H-representation to polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code>  – target type</li><li><code>P</code>     – source polytope (must be 2D)</li><li><code>prune</code> – (optional, default: <code>true</code>) flag for removing redundant            constraints in the end</li></ul><p><strong>Output</strong></p><p>The 2D polytope represented as polygon.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L218-L233">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON},AbstractSingleton{N}}} where HPOLYGON&lt;:AbstractHPolygon where N&lt;:Real" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON},AbstractSingleton{N}}} where HPOLYGON&lt;:AbstractHPolygon where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPOLYGON}, S::AbstractSingleton{N}
       ) where {N&lt;:Real, HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Convert from singleton to polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>S</code>    – singleton</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation with the minimal number of constraints (three).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L407-L422">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON},LineSegment{N}}} where HPOLYGON&lt;:AbstractHPolygon where N&lt;:Real" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON},LineSegment{N}}} where HPOLYGON&lt;:AbstractHPolygon where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPOLYGON}, L::LineSegment{N}
      ) where {N&lt;:Real, HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Convert from line segment to polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code>  – target type</li><li><code>L</code>     – line segment</li><li><code>prune</code> – (optional, default: <code>false</code>) flag for removing redundant            constraints in the end</li></ul><p><strong>Output</strong></p><p>A flat polygon in constraint representation with the minimal number of constraints (four).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L435-L451">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolyhedron},AbstractPolytope}" href="#Base.convert-Tuple{Type{HPolyhedron},AbstractPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPolyhedron}, P::AbstractPolytope)</code></pre><p>Convert a polytopic set to a polyhedron in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The given polytope represented as a polyhedron in constraint representation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L156-L169">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolytope},AbstractHPolygon}" href="#Base.convert-Tuple{Type{HPolytope},AbstractHPolygon}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPolytope}, P::AbstractHPolygon)</code></pre><p>Convert from polygon in H-representation to polytope in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polygon</li></ul><p><strong>Output</strong></p><p>The polygon represented as 2D polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L78-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolytope},AbstractHyperrectangle}" href="#Base.convert-Tuple{Type{HPolytope},AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPolytope}, H::AbstractHyperrectangle)</code></pre><p>Converts a hyperrectangular set to a polytope in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPolytope</code> – type used for dispatch</li><li><code>H</code>         – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A polytope in constraint representation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L713-L726">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolytope},AbstractPolytope}" href="#Base.convert-Tuple{Type{HPolytope},AbstractPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPolytope}, P::AbstractPolytope)</code></pre><p>Convert a polytopic set to a polytope in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The given polytope represented as a polytope in constraint representation.</p><p><strong>Algorithm</strong></p><p>First the list of constraints of <code>P</code> is computed, then the corresponding <code>HPolytope</code> is created.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L133-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolytope},VPolytope}" href="#Base.convert-Tuple{Type{HPolytope},VPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{HPolytope}, P::VPolytope)</code></pre><p>Convert from polytope in V-representation to polytope in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The polytope in the dual representation.</p><p><strong>Algorithm</strong></p><p>The <code>tohrep</code> function is invoked. It requires the <code>Polyhedra</code> package.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L174-L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolygon},AbstractHPolygon}" href="#Base.convert-Tuple{Type{VPolygon},AbstractHPolygon}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{VPolygon}, P::AbstractHPolygon)</code></pre><p>Converts a polygon in constraint representation to a polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>VPolygon</code> – type used for dispatch</li><li><code>P</code>        – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>A polygon in vertex representation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L60-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolygon},AbstractPolytope}" href="#Base.convert-Tuple{Type{VPolygon},AbstractPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{VPolygon}, P::AbstractPolytope)</code></pre><p>Convert polytopic set to polygon in V-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The 2D polytope represented as a polygon.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L114-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolytope},AbstractPolytope}" href="#Base.convert-Tuple{Type{VPolytope},AbstractPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{VPolytope}, P::AbstractPolytope)</code></pre><p>Convert polytopic type to polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The set <code>P</code> represented as a <code>VPolytope</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L96-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolytope},HPolytope}" href="#Base.convert-Tuple{Type{VPolytope},HPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{VPolytope}, P::HPolytope)</code></pre><p>Convert from polytope in H-representation to polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The polytope in the dual representation.</p><p><strong>Algorithm</strong></p><p>The <code>tovrep</code> function is invoked. It requires the <code>Polyhedra</code> package.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L196-L213">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{Zonotope},AbstractHyperrectangle}" href="#Base.convert-Tuple{Type{Zonotope},AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Zonotope}, H::AbstractHyperrectangle)</code></pre><p>Converts a hyperrectangular set to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code></li><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A zonotope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L244-L257">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{Zonotope},AbstractZonotope}" href="#Base.convert-Tuple{Type{Zonotope},AbstractZonotope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Zonotope}, Z::AbstractZonotope)</code></pre><p>Converts a zonotopic set to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code></li><li><code>H</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>A zonotope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L262-L275">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{IntervalArithmetic.IntervalBox},AbstractHyperrectangle}" href="#Base.convert-Tuple{Type{IntervalArithmetic.IntervalBox},AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{IntervalArithmetic.IntervalBox}, H::AbstractHyperrectangle)</code></pre><p>Converts a hyperrectangular set to an <code>IntervalBox</code> from <code>IntervalArithmetic</code>.</p><p><strong>Input</strong></p><ul><li><code>IntervalBox</code> – type used for dispatch</li><li><code>H</code>           – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>An <code>IntervalBox</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L790-L803">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{Hyperrectangle},IntervalArithmetic.IntervalBox}" href="#Base.convert-Tuple{Type{Hyperrectangle},IntervalArithmetic.IntervalBox}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Hyperrectangle}, IB::IntervalArithmetic.IntervalBox)</code></pre><p>Converts an <code>IntervalBox</code> from <code>IntervalArithmetic</code> to a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>IB</code>             – interval box</li></ul><p><strong>Output</strong></p><p>A <code>Hyperrectangle</code>.</p><p><strong>Notes</strong></p><p><code>IntervalArithmetic.IntervalBox</code> uses <em>static</em> vectors to store each component interval, hence the resulting <code>Hyperrectangle</code> has its center and radius represented as a static vector (<code>SArray</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L808-L827">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{ZN2}, Tuple{ZN1}, Tuple{N}, Tuple{Type{Zonotope},CartesianProduct{N,ZN1,ZN2}}} where ZN2&lt;:AbstractZonotope{N} where ZN1&lt;:AbstractZonotope{N} where N&lt;:Real" href="#Base.convert-Union{Tuple{ZN2}, Tuple{ZN1}, Tuple{N}, Tuple{Type{Zonotope},CartesianProduct{N,ZN1,ZN2}}} where ZN2&lt;:AbstractZonotope{N} where ZN1&lt;:AbstractZonotope{N} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Zonotope}, cp::CartesianProduct{N, ZN1, ZN2}
       ) where {N&lt;:Real, ZN1&lt;:AbstractZonotope{N}, ZN2&lt;:AbstractZonotope{N}}</code></pre><p>Converts the cartesian product of two zonotopes to a new zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type used for dispatch</li><li><code>S</code>        – cartesian product of two zonotopes</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>The cartesian product is obtained by:</p><ul><li>Concatenating the centers of each input zonotope.</li><li>Arranging the generators in block-diagional fashion, and filled with zeros in the off-diagonal; for this reason, the generator matrix of the returned zonotope is built as a sparse matrix.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L681-L704">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProduct{N,HN1,HN2}}} where HN2&lt;:AbstractHyperrectangle{N} where HN1&lt;:AbstractHyperrectangle{N} where N&lt;:Real" href="#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProduct{N,HN1,HN2}}} where HN2&lt;:AbstractHyperrectangle{N} where HN1&lt;:AbstractHyperrectangle{N} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Hyperrectangle},
        cp::CartesianProduct{N, HN1, HN2}) where {N&lt;:Real, HN1&lt;:AbstractHyperrectangle{N}, HN2&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the cartesian product of two hyperrectangular sets to a single hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>S</code>              – cartesian product of two hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>The result is obtained by concatenating the center and radius of each hyperrectangle. This implementation uses the <code>center</code> and <code>radius_hyperrectangle</code> methods of <code>AbstractHyperrectangle</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L571-L591">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope},CartesianProduct{N,HN1,HN2}}} where HN2&lt;:AbstractHyperrectangle{N} where HN1&lt;:AbstractHyperrectangle{N} where N&lt;:Real" href="#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope},CartesianProduct{N,HN1,HN2}}} where HN2&lt;:AbstractHyperrectangle{N} where HN1&lt;:AbstractHyperrectangle{N} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Zonotope}, cp::CartesianProduct{N, HN1, HN2}) where {N&lt;:Real,
    HN1&lt;:AbstractHyperrectangle{N}, HN2&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the cartesian product of two hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>cp</code>       – cartesian product of two hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>This method falls back to the conversion of the cartesian product to a single hyperrectangle, and then from a hyperrectangle to a zonotope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L280-L295">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope},CartesianProductArray{N,HN}}} where HN&lt;:AbstractHyperrectangle{N} where N&lt;:Real" href="#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope},CartesianProductArray{N,HN}}} where HN&lt;:AbstractHyperrectangle{N} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Zonotope}, cpa::CartesianProductArray{N, HN})
    where {N&lt;:Real, HN&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the cartesian product array of hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>cpa</code>      – cartesian product array of hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method falls back to the conversion of the cartesian product to a single hyperrectangle, and then from a hyperrectangle to a zonotope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L302-L321">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{ZN}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,ZN,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM}} where ZN&lt;:AbstractZonotope{N} where N" href="#Base.convert-Union{Tuple{ZN}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,ZN,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM}} where ZN&lt;:AbstractZonotope{N} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Zonotope}, S::LinearMap{N, ZN}
       ) where {N, ZN&lt;:AbstractZonotope{N}}</code></pre><p>Converts the lazy linear map of a zonotopic set to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>S</code>        – linear map of a zonotopic set</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method first applies the (concrete) linear map to the zonotopic set and then converts the result to a <code>Zonotope</code> type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L327-L346">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,CartesianProduct{N,HN1,HN2},NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM}} where HN2&lt;:AbstractHyperrectangle{N} where HN1&lt;:AbstractHyperrectangle{N} where N" href="#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,CartesianProduct{N,HN1,HN2},NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM}} where HN2&lt;:AbstractHyperrectangle{N} where HN1&lt;:AbstractHyperrectangle{N} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Zonotope}, S::LinearMap{N, CartesianProduct{N, HN1, HN2}}
       ) where {N, HN1&lt;:AbstractHyperrectangle{N},
                HN2&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the lazy linear map of the cartesian product of two hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>S</code>        – linear map of the cartesian product of hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method first converts the cartesian product to a zonotope, and then applies the (concrete) linear map to the zonotope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L352-L373">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,CartesianProductArray{N,HN},NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM}} where HN&lt;:AbstractHyperrectangle{N} where N" href="#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,CartesianProductArray{N,HN},NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM}} where HN&lt;:AbstractHyperrectangle{N} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Zonotope},S::LinearMap{N, CartesianProductArray{N, HN}}
       ) where {N, HN&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the lazy linear map of the cartesian product of a finite number of hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>S</code>        – linear map of a <code>CartesianProductArray</code> of hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method first converts the cartesian product array to a zonotope, and then applies the (concrete) linear map to the zonotope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L381-L401">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProduct{N,Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N},Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}}},AbstractHyperrectangle{N}}} where N&lt;:Real" href="#Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProduct{N,Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N},Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}}},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{CartesianProduct{N, Interval{N}, Interval{N}}},
        H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Converts a two-dimensional hyperrectangle to the cartesian product of two intervals.</p><p><strong>Input</strong></p><ul><li><code>CartesianProduct</code> – type used for dispatch</li><li><code>H</code>                – hyperrectangle</li></ul><p><strong>Output</strong></p><p>The cartesian product of two intervals.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L634-L649">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProductArray{N,Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}}},AbstractHyperrectangle{N}}} where N&lt;:Real" href="#Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProductArray{N,Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}}},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{CartesianProductArray{N, Interval{N}}},
        H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Converts a hyperrectangle to the cartesian product array of intervals.</p><p><strong>Input</strong></p><ul><li><code>CartesianProductArray</code> – type used for dispatch</li><li><code>H</code>                     – hyperrectangle</li></ul><p><strong>Output</strong></p><p>The cartesian product of a finite number of intervals.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L660-L674">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{AH}, Tuple{N}, Tuple{Type{Hyperrectangle},Rectification{N,AH}}} where AH&lt;:AbstractHyperrectangle{N} where N&lt;:Real" href="#Base.convert-Union{Tuple{AH}, Tuple{N}, Tuple{Type{Hyperrectangle},Rectification{N,AH}}} where AH&lt;:AbstractHyperrectangle{N} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Hyperrectangle}, r::Rectification{N, AH})
    where {N&lt;:Real, AH&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts a rectification of a hyperrectangle to a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>r</code>              – rectification of a hyperrectangle</li></ul><p><strong>Output</strong></p><p>A <code>Hyperrectangle</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L834-L848">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{IN}, Tuple{N}, Tuple{Type{Interval},Rectification{N,IN}}} where IN&lt;:(Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}) where N&lt;:Real" href="#Base.convert-Union{Tuple{IN}, Tuple{N}, Tuple{Type{Interval},Rectification{N,IN}}} where IN&lt;:(Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}) where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Interval},
        r::Rectification{N, IN}) where {N&lt;:Real, IN&lt;:Interval{N}}</code></pre><p>Converts a rectification of an interval to an interval.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – type used for dispatch</li><li><code>r</code>        – rectification of an interval</li></ul><p><strong>Output</strong></p><p>An <code>Interval</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L855-L869">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{IntervalArithmetic.Interval},Interval}" href="#Base.convert-Tuple{Type{IntervalArithmetic.Interval},Interval}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{IntervalArithmetic.Interval}, x::Interval)</code></pre><p>Converts a <code>LazySets</code> interval to an <code>Interval</code> from <code>IntervalArithmetic</code>.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – type used for dispatch, from <code>IntervalArithmetic</code></li><li><code>x</code>        – interval (<code>LazySets.Interval</code>)</li></ul><p><strong>Output</strong></p><p>An <code>IntervalArithmetic.Interval</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L754-L767">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{Interval},IntervalArithmetic.Interval}" href="#Base.convert-Tuple{Type{Interval},IntervalArithmetic.Interval}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Interval}, x::IntervalArithmetic.Interval)</code></pre><p>Converts an <code>Interval</code> from <code>IntervalArithmetic</code> to an interval in <code>LazySets</code>.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – type used for dispatch</li><li><code>x</code>        – interval (<code>IntervalArithmetic.Interval</code>)</li></ul><p><strong>Output</strong></p><p>A <code>LazySets.Interval</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L772-L785">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{VT}, Tuple{N}, Tuple{Type{VPolytope},ConvexHullArray{N,Singleton{N,VT}}}} where VT where N" href="#Base.convert-Union{Tuple{VT}, Tuple{N}, Tuple{Type{VPolytope},ConvexHullArray{N,Singleton{N,VT}}}} where VT where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{VPolytope},
        X::ConvexHullArray{N, Singleton{N, VT}}) where {N, VT}</code></pre><p>Converts the convex hull array of singletons to a polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><code>VPolytope</code> – type used for dispatch</li><li><code>X</code>         – convex hull array of singletons</li></ul><p><strong>Output</strong></p><p>A polytope in vertex representation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L875-L889">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{VT}, Tuple{N}, Tuple{Type{VPolygon},ConvexHullArray{N,Singleton{N,VT}}}} where VT where N" href="#Base.convert-Union{Tuple{VT}, Tuple{N}, Tuple{Type{VPolygon},ConvexHullArray{N,Singleton{N,VT}}}} where VT where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{VPolygon},
        X::ConvexHullArray{N, Singleton{N, VT}}) where {N, VT}</code></pre><p>Converts the convex hull array of singletons to a polygon in V-representation.</p><p><strong>Input</strong></p><ul><li><code>VPolygon</code>  – type used for dispatch</li><li><code>X</code>         – convex hull array of singletons</li></ul><p><strong>Output</strong></p><p>A polygon in vertex representation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L895-L909">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{ST}, Tuple{N}, Tuple{Type{MinkowskiSumArray},MinkowskiSum{N,ST,MinkowskiSumArray{N,ST}}}} where ST where N" href="#Base.convert-Union{Tuple{ST}, Tuple{N}, Tuple{Type{MinkowskiSumArray},MinkowskiSum{N,ST,MinkowskiSumArray{N,ST}}}} where ST where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{MinkowskiSumArray},
        X::MinkowskiSum{N, ST, MinkowskiSumArray{N, ST}}) where {N, ST}</code></pre><p>Converts the Minkowski sum of a Minkowski sum array to a Minkowski sum array.</p><p><strong>Input</strong></p><ul><li><code>MinkowskiSumArray</code>  – type used for dispatch</li><li><code>X</code>                  – Minkowski sum of a Minkowski sum array</li></ul><p><strong>Output</strong></p><p>A Minkowski sum array.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L916-L930">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{IT}, Tuple{N}, Tuple{Type{Interval},MinkowskiSum{N,IT,IT}}} where IT&lt;:(Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}) where N" href="#Base.convert-Union{Tuple{IT}, Tuple{N}, Tuple{Type{Interval},MinkowskiSum{N,IT,IT}}} where IT&lt;:(Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}) where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert(::Type{Interval}, x::MinkowskiSum{N, IT, IT}) where {N, IT&lt;:Interval{N}}</code></pre><p>Converts the Minkowski sum of two intervals into an interval.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – type used for dispatch</li><li><code>x</code>        – Minkowski sum of a pair of intervals</li></ul><p><strong>Output</strong></p><p>An interval.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/ba307fef9847c2e5e0c504f670705eb0e433908f/src/convert.jl#L936-L949">source</a></section><footer><hr/><a class="previous" href="../binary_functions/"><span class="direction">Previous</span><span class="title">Concrete Operations</span></a><a class="next" href="../comparisons/"><span class="direction">Next</span><span class="title">Comparisons</span></a></footer></article></body></html>
