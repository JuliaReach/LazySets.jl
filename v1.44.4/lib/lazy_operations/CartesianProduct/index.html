<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CartesianProduct · LazySets.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">LazySets.jl</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../../man/set_operations/">Operations on Sets</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../interfaces/">Interfaces</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../../sets/Line/">Line</a></li><li><a class="tocitem" href="../../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../../sets/PolynomialZonotope/">PolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../../sets/Star/">Star</a></li><li><a class="tocitem" href="../../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../../sets/Zonotope/">Zonotope</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../Bloating/">Bloating</a></li><li class="is-active"><a class="tocitem" href>CartesianProduct</a><ul class="internal"><li><a class="tocitem" href="#def_CartesianProduct"><span>Binary Cartesian product (CartesianProduct)</span></a></li><li><a class="tocitem" href="#def_CartesianProductArray"><span><span>$n$</span>-ary Cartesian product (CartesianProductArray)</span></a></li></ul></li><li><a class="tocitem" href="../Complement/">Complement</a></li><li><a class="tocitem" href="../ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../Intersection/">Intersection</a></li><li><a class="tocitem" href="../LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../InverseLinearMap/">InverseLinearMap</a></li><li><a class="tocitem" href="../MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../Rectification/">Rectification</a></li><li><a class="tocitem" href="../ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../Translation/">Translation</a></li><li><a class="tocitem" href="../UnionSet/">UnionSet</a></li></ul></li><li><a class="tocitem" href="../../binary_functions/">Concrete Operations</a></li><li><a class="tocitem" href="../../conversion/">Conversions between set representations</a></li><li><a class="tocitem" href="../../comparisons/">Comparisons</a></li><li><a class="tocitem" href="../../approximations/">Approximations</a></li><li><a class="tocitem" href="../../utils/">Utility Functions</a></li><li><a class="tocitem" href="../../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li><a class="is-disabled">Lazy Operations</a></li><li class="is-active"><a href>CartesianProduct</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CartesianProduct</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/lazy_operations/CartesianProduct.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Cartesian-product"><a class="docs-heading-anchor" href="#Cartesian-product">Cartesian product</a><a id="Cartesian-product-1"></a><a class="docs-heading-anchor-permalink" href="#Cartesian-product" title="Permalink"></a></h1><h2 id="def_CartesianProduct"><a class="docs-heading-anchor" href="#def_CartesianProduct">Binary Cartesian product (CartesianProduct)</a><a id="def_CartesianProduct-1"></a><a class="docs-heading-anchor-permalink" href="#def_CartesianProduct" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.CartesianProduct" href="#LazySets.CartesianProduct"><code>LazySets.CartesianProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CartesianProduct{N, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the Cartesian product of two sets, that is the set</p><p class="math-container">\[Z = \{ z ∈ \mathbb{R}^{n + m} : z = (x, y),\qquad x ∈ X, y ∈ Y \}.\]</p><p>If <span>$X ⊆ \mathbb{R}^n$</span> and <span>$Y ⊆ \mathbb{R}^m$</span>, then <span>$Z$</span> is <span>$n+m$</span>-dimensional.</p><p><strong>Fields</strong></p><ul><li><code>X</code> – first set</li><li><code>Y</code> – second set</li></ul><p><strong>Notes</strong></p><p>The Cartesian product of three elements is obtained recursively. See also <a href="#LazySets.CartesianProductArray"><code>CartesianProductArray</code></a> for an implementation of a Cartesian product of many sets without recursion, instead using an array, making the operations more efficient.</p><p>The <code>EmptySet</code> is the absorbing element for <code>CartesianProduct</code>.</p><p>The Cartesian product preserves convexity: if the set arguments are convex, then their Cartesian product is convex as well.</p><p>In some docstrings the word &quot;block&quot; is used to denote each wrapped set, with the natural order, i.e. we say that the first block of a Cartesian product <code>cp</code> is <code>cp.X</code> and the second block is <code>cp.Y</code>.</p><p><strong>Examples</strong></p><p>The Cartesian product between two sets <code>X</code> and <code>Y</code> can be constructed either using <code>CartesianProduct(X, Y)</code> or the short-cut notation <code>X × Y</code> (to enter the times symbol, write <code>imes[TAB]</code>).</p><pre><code class="language-julia-repl">julia&gt; I1 = Interval(0, 1);

julia&gt; I2 = Interval(2, 4);

julia&gt; I12 = I1 × I2;

julia&gt; typeof(I12)
CartesianProduct{Float64,Interval{Float64,IntervalArithmetic.Interval{Float64}},Interval{Float64,IntervalArithmetic.Interval{Float64}}}</code></pre><p>A hyperrectangle is the cartesian product of intervals, so we can convert <code>I12</code> exactly to a <code>Hyperrectangle</code> type:</p><pre><code class="language-julia-repl">julia&gt; convert(Hyperrectangle, I12)
Hyperrectangle{Float64,Array{Float64,1},Array{Float64,1}}([0.5, 3.0], [0.5, 1.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProduct.jl#L7-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.:×-Tuple{LazySet,LazySet}" href="#LinearAlgebra.:×-Tuple{LazySet,LazySet}"><code>LinearAlgebra.:×</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">×</code></pre><p>Unicode alias constructor × (<code>times</code>) for the binary Cartesian product operator.</p><p><strong>Notes</strong></p><p>Write <code>\times[TAB]</code> to enter this symbol.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProduct.jl#L84-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{LazySet,LazySet}" href="#Base.:*-Tuple{LazySet,LazySet}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    *(X::LazySet, Y::LazySet)</code></pre><p>Alias for the binary Cartesian product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProduct.jl#L75-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.swap-Tuple{CartesianProduct}" href="#LazySets.swap-Tuple{CartesianProduct}"><code>LazySets.swap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swap(cp::CartesianProduct)</code></pre><p>Return a new <code>CartesianProduct</code> object with the arguments swapped.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product of two sets</li></ul><p><strong>Output</strong></p><p>A new <code>CartesianProduct</code> object with the arguments swapped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProduct.jl#L95-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.dim-Tuple{CartesianProduct}" href="#LazySets.dim-Tuple{CartesianProduct}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dim(cp::CartesianProduct)</code></pre><p>Return the dimension of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Cartesian product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProduct.jl#L112-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.ρ-Tuple{AbstractArray{T,1} where T,CartesianProduct}" href="#LazySets.ρ-Tuple{AbstractArray{T,1} where T,CartesianProduct}"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ρ(d::AbstractVector, cp::CartesianProduct)</code></pre><p>Return the support function of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>The support function in the given direction. If the direction has norm zero, the result depends on the wrapped sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProduct.jl#L149-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{T,1} where T,CartesianProduct}" href="#LazySets.σ-Tuple{AbstractArray{T,1} where T,CartesianProduct}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">σ(d::AbstractVector, cp::CartesianProduct)</code></pre><p>Return the support vector of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProduct.jl#L129-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isbounded-Tuple{CartesianProduct}" href="#LazySets.isbounded-Tuple{CartesianProduct}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isbounded(cp::CartesianProduct)</code></pre><p>Determine whether a Cartesian product is bounded.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff both wrapped sets are bounded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProduct.jl#L169-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{T,1} where T,CartesianProduct}" href="#Base.:∈-Tuple{AbstractArray{T,1} where T,CartesianProduct}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∈(x::AbstractVector, cp::CartesianProduct)</code></pre><p>Check whether a given point is contained in a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>x</code>  – point/vector</li><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ cp$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProduct.jl#L186-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{CartesianProduct}" href="#Base.isempty-Tuple{CartesianProduct}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isempty(cp::CartesianProduct)</code></pre><p>Return if a Cartesian product is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the sub-blocks is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProduct.jl#L208-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.constraints_list-Tuple{CartesianProduct}" href="#LazySets.constraints_list-Tuple{CartesianProduct}"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraints_list(cp::CartesianProduct)</code></pre><p>Return the list of constraints of a (polyhedral) Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>A list of constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProduct.jl#L225-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N" href="#LazySets.vertices_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertices_list(P::AbstractHPolygon{N};
              apply_convex_hull::Bool=true,
              check_feasibility::Bool=true) where {N}</code></pre><p>Return the list of vertices of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>                 – polygon in constraint representation</li><li><code>apply_convex_hull</code> – (optional, default: <code>true</code>) flag to post-process the                        intersection of constraints with a convex hull</li><li><code>check_feasibility</code> – (optional, default: <code>true</code>) flag to check whether the                        polygon was empty (required for correctness in case of                        empty polygons)</li></ul><p><strong>Output</strong></p><p>List of vertices.</p><p><strong>Algorithm</strong></p><p>We compute each vertex as the intersection of consecutive lines defined by the half-spaces. If <code>check_feasibility</code> is active, we then check if the constraints of the polygon were actually feasible (i.e., they pointed in the <em>right</em> direction). For this we compute the <em>average</em> of all vertices and check membership in each constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/Interfaces/AbstractHPolygon.jl#L108-L136">source</a></section><section><div><pre><code class="language-none">vertices_list(B::Ball1{N, VN}) where {N, VN&lt;:AbstractVector}</code></pre><p>Return the list of vertices of a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the 1-norm</li></ul><p><strong>Output</strong></p><p>A list containing the vertices of the ball in the 1-norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/Sets/Ball1.jl#L84-L96">source</a></section><section><div><pre><code class="language-none">vertices_list(∅::EmptySet{N}) where {N}</code></pre><p>Return the list of vertices of an empty set.</p><p><strong>Input</strong></p><ul><li><code>∅</code> – empty set</li></ul><p><strong>Output</strong></p><p>The empty list of vertices, as the empty set does not contain any vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/Sets/EmptySet.jl#L297-L309">source</a></section><section><div><pre><code class="language-none">vertices_list(P::HPolytope{N};
              [backend]=nothing, [prune]::Bool=true) where {N}</code></pre><p>Return the list of vertices of a polytope in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polytope in constraint representation</li><li><code>backend</code> – (optional, default: <code>nothing</code>) the polyhedral computations backend</li><li><code>prune</code>   – (optional, default: <code>true</code>) flag to remove redundant vertices</li></ul><p><strong>Output</strong></p><p>List of vertices.</p><p><strong>Algorithm</strong></p><p>If the polytope is two-dimensional, the polytope is converted to a polygon in H-representation and then its <code>vertices_list</code> function is used. This ensures that, by default, the optimized two-dimensional methods are used.</p><p>It is possible to use the <code>Polyhedra</code> backend in two-dimensions as well by passing, e.g. <code>backend=CDDLib.Library()</code>.</p><p>If the polytope is not two-dimensional, the concrete polyhedra manipulation library <code>Polyhedra</code> is used. The actual computation is performed by a given backend; for the default backend used in <code>LazySets</code> see <code>default_polyhedra_backend(P)</code>. For further information on the supported backends see <a href="https://juliapolyhedra.github.io/Polyhedra.jl/">Polyhedra&#39;s documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/Sets/HPolytope.jl#L188-L218">source</a></section><section><div><pre><code class="language-none">vertices_list(cp::CartesianProduct{N}) where {N}</code></pre><p>Return the list of vertices of a (polytopic) Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProduct.jl#L242-L260">source</a></section><section><div><p>vertices_list(cpa::CartesianProductArray{N}) where {N}</p><p>Return the list of vertices of a (polytopic) Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProductArray.jl#L311-L330">source</a></section><section><div><pre><code class="language-none">vertices_list(em::ExponentialMap{N}) where {N}</code></pre><p>Return the list of vertices of a (polytopic) exponential map.</p><p><strong>Input</strong></p><ul><li><code>em</code> – exponential map</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying set <code>X</code> is polytopic. Then the result is just the exponential map applied to the vertices of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/ExponentialMap.jl#L396-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.linear_map-Tuple{AbstractArray{T,2} where T,CartesianProduct}" href="#LazySets.linear_map-Tuple{AbstractArray{T,2} where T,CartesianProduct}"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">linear_map(M::AbstractMatrix, cp::CartesianProduct)</code></pre><p>Concrete linear map of a (polyhedral) Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>M</code>  – matrix</li><li><code>cp</code> – Cartesian product of two sets</li></ul><p><strong>Output</strong></p><p>A polytope if <code>cp</code> is bounded and a polyhedron otherwise.</p><p><strong>Algorithm</strong></p><p>We convert the Cartesian product to constraint representation and then call <code>linear_map</code> on the corresponding polyhedron.</p><p>This is a fallback implementation and it will fail if the wrapped sets are not polyhedral.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProduct.jl#L278-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.project-Union{Tuple{HT}, Tuple{IT}, Tuple{N}, Tuple{CartesianProduct{N,IT,HT},AbstractArray{Int64,1}}} where HT&lt;:AbstractHyperrectangle{N} where IT&lt;:Interval where N" href="#LazySets.project-Union{Tuple{HT}, Tuple{IT}, Tuple{N}, Tuple{CartesianProduct{N,IT,HT},AbstractArray{Int64,1}}} where HT&lt;:AbstractHyperrectangle{N} where IT&lt;:Interval where N"><code>LazySets.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project(cp::CartesianProduct{N, IT, HT}, block::AbstractVector{Int};
        [kwargs...]) where {N, IT&lt;:Interval, HT&lt;:AbstractHyperrectangle{N}}</code></pre><p>Concrete projection of a Cartesian product between an interval and a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>cp</code>       – Cartesian product between an interval and a hyperrectangle</li><li><code>block</code>    – block structure, a vector with the dimensions of interest</li></ul><p><strong>Output</strong></p><p>A hyperrectangle representing the projection of the cartesian product <code>cp</code> on the dimensions specified by <code>block</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProduct.jl#L336-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.project-Union{Tuple{ZT}, Tuple{IT}, Tuple{N}, Tuple{CartesianProduct{N,IT,ZT},AbstractArray{Int64,1}}} where ZT&lt;:AbstractZonotope{N} where IT&lt;:Interval where N" href="#LazySets.project-Union{Tuple{ZT}, Tuple{IT}, Tuple{N}, Tuple{CartesianProduct{N,IT,ZT},AbstractArray{Int64,1}}} where ZT&lt;:AbstractZonotope{N} where IT&lt;:Interval where N"><code>LazySets.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project(cp::CartesianProduct{N, IT, ZT}, block::AbstractVector{Int};
        [kwargs...]) where {N, IT&lt;:Interval, ZT&lt;:AbstractZonotope{N}}</code></pre><p>Concrete projection of the Cartesian product between an interval and a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>cp</code>       – Cartesian product between an interval and a zonotopic set</li><li><code>block</code>    – block structure, a vector with the dimensions of interest</li></ul><p><strong>Output</strong></p><p>A zonotope representing the projection of the cartesian product <code>cp</code> on the dimensions specified by <code>block</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProduct.jl#L368-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.project-Union{Tuple{VP2}, Tuple{VP1}, Tuple{IT}, Tuple{N}, Tuple{CartesianProduct{N,IT,Union{VP1, VP2}},AbstractArray{Int64,1}}} where VP2&lt;:(VPolytope{N,VN} where VN&lt;:AbstractArray{N,1}) where VP1&lt;:(VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}) where IT&lt;:Interval where N" href="#LazySets.project-Union{Tuple{VP2}, Tuple{VP1}, Tuple{IT}, Tuple{N}, Tuple{CartesianProduct{N,IT,Union{VP1, VP2}},AbstractArray{Int64,1}}} where VP2&lt;:(VPolytope{N,VN} where VN&lt;:AbstractArray{N,1}) where VP1&lt;:(VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}) where IT&lt;:Interval where N"><code>LazySets.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project(cp::CartesianProduct{N, IT, Union{VP1, VP2}},
        block::AbstractVector{Int};
        [kwargs...]) where {N, IT&lt;:Interval, VP1&lt;:VPolygon{N}, VP2&lt;:VPolytope{N}}</code></pre><p>Concrete projection of the Cartesian product between an interval and a set in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>cp</code>       – Cartesian product between an interval and a <code>VPolygon</code> or a <code>VPolytope</code></li><li><code>block</code>    – block structure, a vector with the dimensions of interest</li></ul><p><strong>Output</strong></p><p>A <code>VPolytope</code> representing the projection of the cartesian product <code>cp</code> on the dimensions specified by <code>block</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProduct.jl#L397-L413">source</a></section></article><p>Inherited from <a href="../../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li>[<code>an_element</code>](@ref an_element(::LazySet)</li><li><a href="../../interfaces/#LazySets.singleton_list-Tuple{LazySet}"><code>singleton_list</code></a></li></ul><h2 id="def_CartesianProductArray"><a class="docs-heading-anchor" href="#def_CartesianProductArray"><span>$n$</span>-ary Cartesian product (CartesianProductArray)</a><a id="def_CartesianProductArray-1"></a><a class="docs-heading-anchor-permalink" href="#def_CartesianProductArray" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.CartesianProductArray" href="#LazySets.CartesianProductArray"><code>LazySets.CartesianProductArray</code></a> — <span class="docstring-category">Type</span></header><section><div><p>CartesianProductArray{N, S&lt;:LazySet{N}} &lt;: LazySet{N}</p><p>Type that represents the Cartesian product of a finite number of sets.</p><p><strong>Fields</strong></p><ul><li><code>array</code> – array of sets</li></ul><p><strong>Notes</strong></p><p>The <code>EmptySet</code> is the absorbing element for <code>CartesianProductArray</code>.</p><p>The Cartesian product preserves convexity: if the set arguments are convex, then their Cartesian product is convex as well.</p><p>Constructors:</p><ul><li><p><code>CartesianProductArray(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>CartesianProductArray([n]::Int=0, [N]::Type=Float64)</code></p></li></ul><p>– constructor for an empty product with optional size hint and numeric type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProductArray.jl#L7-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.dim-Tuple{CartesianProductArray}" href="#LazySets.dim-Tuple{CartesianProductArray}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span></header><section><div><p>dim(cpa::CartesianProductArray)</p><p>Return the dimension of a Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Cartesian product of a finite number of sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProductArray.jl#L67-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.ρ-Tuple{AbstractArray{T,1} where T,CartesianProductArray}" href="#LazySets.ρ-Tuple{AbstractArray{T,1} where T,CartesianProductArray}"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ρ(d::AbstractVector, cpa::CartesianProductArray)</p><p>Return the support function of a Cartesian product array.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The support function in the given direction. If the direction has norm zero, the result depends on the wrapped sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProductArray.jl#L149-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{T,1} where T,CartesianProductArray}" href="#LazySets.σ-Tuple{AbstractArray{T,1} where T,CartesianProductArray}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>σ(d::AbstractVector, cpa::CartesianProductArray)</p><p>Support vector of a Cartesian product array.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the product sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProductArray.jl#L84-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isbounded-Tuple{CartesianProductArray}" href="#LazySets.isbounded-Tuple{CartesianProductArray}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span></header><section><div><p>isbounded(cpa::CartesianProductArray)</p><p>Determine whether a Cartesian product of a finite number of sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product of a finite number of sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff all wrapped sets are bounded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProductArray.jl#L212-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{T,1} where T,CartesianProductArray}" href="#Base.:∈-Tuple{AbstractArray{T,1} where T,CartesianProductArray}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span></header><section><div><p>∈(x::AbstractVector, cpa::CartesianProductArray)</p><p>Check whether a given point is contained in a Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>x</code>   – point/vector</li><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ \text{cpa}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProductArray.jl#L230-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{CartesianProductArray}" href="#Base.isempty-Tuple{CartesianProductArray}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><p>isempty(cpa::CartesianProductArray)</p><p>Return if a Cartesian product is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the sub-blocks is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProductArray.jl#L259-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N" href="#LazySets.constraints_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraints_list(H::AbstractHyperrectangle{N}) where {N}</code></pre><p>Return the list of constraints of an axis-aligned hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A list of linear constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/Interfaces/AbstractHyperrectangle.jl#L231-L243">source</a></section><section><div><pre><code class="language-none">constraints_list(P::Ball1{N}) where {N}</code></pre><p>Return the list of constraints defining a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the 1-norm</li></ul><p><strong>Output</strong></p><p>The list of constraints of the ball.</p><p><strong>Algorithm</strong></p><p>The constraints can be defined as <span>$d_i^T (x-c) ≤ r$</span> for all <span>$d_i$</span>, where <span>$d_i$</span> is a vector with elements <span>$1$</span> or <span>$-1$</span> in <span>$n$</span> dimensions. To span all possible <span>$d_i$</span>, the function <code>Iterators.product</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/Sets/Ball1.jl#L234-L252">source</a></section><section><div><pre><code class="language-none">constraints_list(x::Interval{N}) where {N}</code></pre><p>Return the list of constraints of the given interval.</p><p><strong>Input</strong></p><ul><li><code>x</code> – interval</li></ul><p><strong>Output</strong></p><p>The list of constraints of the interval represented as two one-dimensional half-spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/Sets/Interval.jl#L390-L403">source</a></section><section><div><pre><code class="language-none">constraints_list(L::Line{N, VN}) where {N, VN}</code></pre><p>Return the list of constraints of a line.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line</li></ul><p><strong>Output</strong></p><p>A list containing <code>2n-2</code> half-spaces whose intersection is <code>L</code>, where <code>n</code> is the ambient dimension of <code>L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/Sets/Line.jl#L191-L204">source</a></section><section><div><pre><code class="language-none">constraints_list(U::Universe{N}) where {N}</code></pre><p>Return the list of constraints defining a universe.</p><p><strong>Input</strong></p><ul><li><code>U</code> – universe</li></ul><p><strong>Output</strong></p><p>The empty list of constraints, as the universe is unconstrained.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/Sets/Universe.jl#L42-L54">source</a></section><section><div><pre><code class="language-none">constraints_list(P::HParallelotope{N, VN}) where {N, VN}</code></pre><p>Return the list of constraints of the given parallelotope.</p><p><strong>Input</strong></p><ul><li><code>P</code> – parallelotope in constraint representation</li></ul><p><strong>Output</strong></p><p>The list of constraints of <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/Sets/HParallelotope.jl#L289-L301">source</a></section><section><div><p>constraints_list(cpa::CartesianProductArray{N}) where {N}</p><p>Return the list of constraints of a (polyhedral) Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A list of constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProductArray.jl#L276-L289">source</a></section><section><div><pre><code class="language-none">constraints_list(ia::IntersectionArray{N}) where {N}</code></pre><p>Return the list of constraints of an intersection of a finite number of (polyhedral) sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of (polyhedral) sets</li></ul><p><strong>Output</strong></p><p>The list of constraints of the intersection.</p><p><strong>Notes</strong></p><p>We assume that the underlying sets are polyhedral, i.e., offer a method <code>constraints_list</code>.</p><p><strong>Algorithm</strong></p><p>We create the polyhedron from the <code>constraints_list</code>s of the sets and remove redundant constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/IntersectionArray.jl#L164-L187">source</a></section><section><div><pre><code class="language-none">constraints_list(rm::ResetMap{N}) where {N}</code></pre><p>Return the list of constraints of a polytopic reset map.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map of a polytope</li></ul><p><strong>Output</strong></p><p>The list of constraints of the reset map.</p><p><strong>Notes</strong></p><p>We assume that the underlying set <code>X</code> is a polytope, i.e., is bounded and offers a method <code>constraints_list(X)</code>.</p><p><strong>Algorithm</strong></p><p>We fall back to <code>constraints_list</code> of a <code>LinearMap</code> of the <code>A</code>-matrix in the affine-map view of a reset map. Each reset dimension <span>$i$</span> is projected to zero, expressed by two constraints for each reset dimension. Then it remains to shift these constraints to the new value.</p><p>For instance, if the dimension <span>$5$</span> was reset to <span>$4$</span>, then there will be constraints <span>$x₅ ≤ 0$</span> and <span>$-x₅ ≤ 0$</span>. We then modify the right-hand side of these constraints to <span>$x₅ ≤ 4$</span> and <span>$-x₅ ≤ -4$</span>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/ResetMap.jl#L263-L293">source</a></section><section><div><pre><code class="language-none">constraints_list(rm::ResetMap{N, S}) where {N, S&lt;:AbstractHyperrectangle}</code></pre><p>Return the list of constraints of a hyperrectangular reset map.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map of a hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The list of constraints of the reset map.</p><p><strong>Algorithm</strong></p><p>We iterate through all dimensions. If there is a reset, we construct the corresponding (flat) constraints. Otherwise, we construct the corresponding constraints of the underlying set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/ResetMap.jl#L317-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N" href="#LazySets.vertices_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertices_list(P::AbstractHPolygon{N};
              apply_convex_hull::Bool=true,
              check_feasibility::Bool=true) where {N}</code></pre><p>Return the list of vertices of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>                 – polygon in constraint representation</li><li><code>apply_convex_hull</code> – (optional, default: <code>true</code>) flag to post-process the                        intersection of constraints with a convex hull</li><li><code>check_feasibility</code> – (optional, default: <code>true</code>) flag to check whether the                        polygon was empty (required for correctness in case of                        empty polygons)</li></ul><p><strong>Output</strong></p><p>List of vertices.</p><p><strong>Algorithm</strong></p><p>We compute each vertex as the intersection of consecutive lines defined by the half-spaces. If <code>check_feasibility</code> is active, we then check if the constraints of the polygon were actually feasible (i.e., they pointed in the <em>right</em> direction). For this we compute the <em>average</em> of all vertices and check membership in each constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/Interfaces/AbstractHPolygon.jl#L108-L136">source</a></section><section><div><pre><code class="language-none">vertices_list(B::Ball1{N, VN}) where {N, VN&lt;:AbstractVector}</code></pre><p>Return the list of vertices of a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the 1-norm</li></ul><p><strong>Output</strong></p><p>A list containing the vertices of the ball in the 1-norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/Sets/Ball1.jl#L84-L96">source</a></section><section><div><pre><code class="language-none">vertices_list(∅::EmptySet{N}) where {N}</code></pre><p>Return the list of vertices of an empty set.</p><p><strong>Input</strong></p><ul><li><code>∅</code> – empty set</li></ul><p><strong>Output</strong></p><p>The empty list of vertices, as the empty set does not contain any vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/Sets/EmptySet.jl#L297-L309">source</a></section><section><div><pre><code class="language-none">vertices_list(P::HPolytope{N};
              [backend]=nothing, [prune]::Bool=true) where {N}</code></pre><p>Return the list of vertices of a polytope in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polytope in constraint representation</li><li><code>backend</code> – (optional, default: <code>nothing</code>) the polyhedral computations backend</li><li><code>prune</code>   – (optional, default: <code>true</code>) flag to remove redundant vertices</li></ul><p><strong>Output</strong></p><p>List of vertices.</p><p><strong>Algorithm</strong></p><p>If the polytope is two-dimensional, the polytope is converted to a polygon in H-representation and then its <code>vertices_list</code> function is used. This ensures that, by default, the optimized two-dimensional methods are used.</p><p>It is possible to use the <code>Polyhedra</code> backend in two-dimensions as well by passing, e.g. <code>backend=CDDLib.Library()</code>.</p><p>If the polytope is not two-dimensional, the concrete polyhedra manipulation library <code>Polyhedra</code> is used. The actual computation is performed by a given backend; for the default backend used in <code>LazySets</code> see <code>default_polyhedra_backend(P)</code>. For further information on the supported backends see <a href="https://juliapolyhedra.github.io/Polyhedra.jl/">Polyhedra&#39;s documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/Sets/HPolytope.jl#L188-L218">source</a></section><section><div><pre><code class="language-none">vertices_list(cp::CartesianProduct{N}) where {N}</code></pre><p>Return the list of vertices of a (polytopic) Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProduct.jl#L242-L260">source</a></section><section><div><p>vertices_list(cpa::CartesianProductArray{N}) where {N}</p><p>Return the list of vertices of a (polytopic) Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProductArray.jl#L311-L330">source</a></section><section><div><pre><code class="language-none">vertices_list(em::ExponentialMap{N}) where {N}</code></pre><p>Return the list of vertices of a (polytopic) exponential map.</p><p><strong>Input</strong></p><ul><li><code>em</code> – exponential map</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying set <code>X</code> is polytopic. Then the result is just the exponential map applied to the vertices of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/ExponentialMap.jl#L396-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.linear_map-Tuple{AbstractArray{T,2} where T,CartesianProductArray}" href="#LazySets.linear_map-Tuple{AbstractArray{T,2} where T,CartesianProductArray}"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">linear_map(M::AbstractMatrix, cpa::CartesianProductArray)</code></pre><p>Concrete linear map of a Cartesian product of a finite number of (polyhedral) sets.</p><p><strong>Input</strong></p><ul><li><code>M</code>   – matrix</li><li><code>cpa</code> – Cartesian product of a finite number of sets</li></ul><p><strong>Output</strong></p><p>A polytope.</p><p><strong>Algorithm</strong></p><p>We check if the matrix is invertible. If so, we convert the Cartesian product to constraint representation. Otherwise, we convert the Cartesian product to vertex representation. In both cases, we then call <code>linear_map</code> on the resulting polytope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProductArray.jl#L560-L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.array-Tuple{CartesianProductArray}" href="#LazySets.array-Tuple{CartesianProductArray}"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span></header><section><div><p>array(cpa::CartesianProductArray)</p><p>Return the array of a Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The array of a Cartesian product of a finite number of sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProductArray.jl#L50-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.block_structure-Tuple{CartesianProductArray}" href="#LazySets.block_structure-Tuple{CartesianProductArray}"><code>LazySets.block_structure</code></a> — <span class="docstring-category">Method</span></header><section><div><p>block_structure(cpa::CartesianProductArray{N}) where {N}</p><p>Returns an array containing the dimension ranges of each block in a <code>CartesianProductArray</code>.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A vector of ranges</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using LazySets: block_structure

julia&gt; cpa = CartesianProductArray([BallInf(zeros(n), 1.0) for n in [3, 1, 2]]);

julia&gt; block_structure(cpa)
3-element Array{UnitRange{Int64},1}:
 1:3
 4:4
 5:6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProductArray.jl#L408-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.block_to_dimension_indices-Tuple{CartesianProductArray,Array{Int64,1}}" href="#LazySets.block_to_dimension_indices-Tuple{CartesianProductArray,Array{Int64,1}}"><code>LazySets.block_to_dimension_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><p>block<em>to</em>dimension_indices(cpa::CartesianProductArray{N}, vars::Vector{Int}) where {N}</p><p>Returns a vector mapping block index <code>i</code> to tuple <code>(f, l)</code> such that either <code>f = l = -1</code> or <code>f</code> is the first dimension index and <code>l</code> is the last dimension index of the <code>i</code>-th block, depending on whether one of the block&#39;s dimension indices is specified in <code>vars</code>.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li><li><code>vars</code> – list containing the variables of interest, sorted in ascending order</li></ul><p><strong>Output</strong></p><p>(i) A vector of tuples, where values in tuple relate to range of dimensions in the i-th block.</p><p>(ii) Number of constrained blocks</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using LazySets: block_to_dimension_indices

julia&gt; cpa = CartesianProductArray([BallInf(zeros(n), 1.0) for n in [1, 3, 2, 3]]);

julia&gt; m, k = block_to_dimension_indices(cpa, [2, 4, 8]);

julia&gt; m
4-element Array{Tuple{Int64,Int64},1}:
 (-1, -1)
 (2, 4)
 (-1, -1)
 (7, 9)

julia&gt; k
2</code></pre><p>This vector represents the mapping &quot;second block from dimension 2 to dimension 4, fourth block from dimension 7 to dimension 9.&quot; These blocks contain the dimensions specified in <code>[2, 4, 8]</code>. Number of constrained variables here is 2 (2nd and 4th blocks)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProductArray.jl#L447-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.substitute_blocks-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N},CartesianProductArray{N,S} where S&lt;:LazySet{N},Array{Tuple{Int64,Int64},1}}} where N" href="#LazySets.substitute_blocks-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N},CartesianProductArray{N,S} where S&lt;:LazySet{N},Array{Tuple{Int64,Int64},1}}} where N"><code>LazySets.substitute_blocks</code></a> — <span class="docstring-category">Method</span></header><section><div><p>substitute<em>blocks(low</em>dim<em>cpa::CartesianProductArray{N},                      orig</em>cpa::CartesianProductArray{N},                      blocks::Vector{Tuple{Int,Int}}) where {N}</p><p>Return merged Cartesian Product Array between original CPA and some low-dimensional CPA, which represents updated subset of variables in specified blocks.</p><p><strong>Input</strong></p><ul><li><code>low_dim_cpa</code> – low-dimensional cartesian product array</li><li><code>orig_cpa</code>    – original high-dimensional Cartesian product array</li><li><code>blocks</code>      – index of the first variable in each block of <code>orig_cpa</code></li></ul><p><strong>Output</strong></p><p>Merged cartesian product array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/5ece4f3a4f54b72235c5ec322868915c7908b8e8/src/LazyOperations/CartesianProductArray.jl#L524-L541">source</a></section></article><p>Inherited from <a href="../../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N"><code>an_element</code></a></li><li><a href="../../interfaces/#LazySets.singleton_list-Tuple{LazySet}"><code>singleton_list</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Bloating/">« Bloating</a><a class="docs-footer-nextpage" href="../Complement/">Complement »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 18 May 2021 20:33">Tuesday 18 May 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
