<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Binary Functions on Sets · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/getting_started.html">Getting Started</a></li><li><a class="toctext" href="../man/polyhedral_approximations.html">Polyhedral Approximations</a></li><li><a class="toctext" href="../man/decompose_example.html">Decomposing an Affine Map</a></li><li><a class="toctext" href="../man/fast_2d_LPs.html">Fast 2D LPs</a></li><li><a class="toctext" href="../man/iterative_refinement.html">Iterative Refinement</a></li><li><a class="toctext" href="../man/interval_hulls.html">Interval Hulls</a></li><li><a class="toctext" href="../man/convex_hulls.html">Convex Hulls</a></li><li><a class="toctext" href="../man/set_operations.html">Operations on Sets</a></li><li><a class="toctext" href="../man/reach_zonotopes.html">A Reachability Algorithm</a></li><li><a class="toctext" href="../man/reach_zonotopes_hybrid.html">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../man/concrete_polyhedra.html">Concrete Polyhedra</a></li><li><a class="toctext" href="../man/parallel_approximations.html">Parallel Approximations</a></li><li><a class="toctext" href="../man/lazy_intersections.html">Lazy Intersections</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="interfaces.html">Set Interfaces</a></li><li><a class="toctext" href="representations.html">Common Set Representations</a></li><li><a class="toctext" href="operations.html">Common Set Operations</a></li><li><a class="toctext" href="comparisons.html">Comparisons</a></li><li><a class="toctext" href="conversion.html">Conversions between set representations</a></li><li class="current"><a class="toctext" href="binary_functions.html">Binary Functions on Sets</a><ul class="internal"><li><a class="toctext" href="#Check-for-emptiness-of-intersection-1">Check for emptiness of intersection</a></li><li><a class="toctext" href="#Convex-hull-1">Convex hull</a></li><li><a class="toctext" href="#Intersection-of-two-sets-1">Intersection of two sets</a></li><li><a class="toctext" href="#Subset-check-1">Subset check</a></li></ul></li><li><a class="toctext" href="approximations.html">Approximations</a></li><li><a class="toctext" href="utils.html">Utility Functions</a></li><li><a class="toctext" href="parallel.html">Parallel</a></li></ul></li><li><a class="toctext" href="../about.html">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="binary_functions.html">Binary Functions on Sets</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/binary_functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Binary Functions on Sets</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Binary-Functions-on-Sets-1" href="#Binary-Functions-on-Sets-1">Binary Functions on Sets</a></h1><p>This section of the manual describes the binary functions for set types.</p><ul><li><a href="binary_functions.html#Binary-Functions-on-Sets-1">Binary Functions on Sets</a></li><ul><li><a href="binary_functions.html#Check-for-emptiness-of-intersection-1">Check for emptiness of intersection</a></li><li><a href="binary_functions.html#Convex-hull-1">Convex hull</a></li><li><a href="binary_functions.html#Intersection-of-two-sets-1">Intersection of two sets</a></li><li><a href="binary_functions.html#Subset-check-1">Subset check</a></li></ul></ul><h2><a class="nav-anchor" id="Check-for-emptiness-of-intersection-1" href="#Check-for-emptiness-of-intersection-1">Check for emptiness of intersection</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isdisjoint" href="#LazySets.isdisjoint"><code>LazySets.isdisjoint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isdisjoint(X, Y)</code></pre><p>An alternative name for <code>is_intersection_empty(X, Y)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L1285-L1289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{LazySet{N},LazySet{N}}, Tuple{LazySet{N},LazySet{N},Bool}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{LazySet{N},LazySet{N}}, Tuple{LazySet{N},LazySet{N},Bool}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_intersection_empty(X::LazySet{N},
                      Y::LazySet{N},
                      witness::Bool=false
                      )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether two sets do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>Y</code>       – another set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ∩ Y = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ∩ Y = ∅$</span></li><li><code>(false, v)</code> iff <span>$X ∩ Y ≠ ∅$</span> and <span>$v ∈ X ∩ Y$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>This is a fallback implementation that computes the concrete intersection, <code>intersection</code>, of the given sets.</p><p>A witness is constructed using the <code>an_element</code> implementation of the result.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L4-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N}}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N},Bool}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N}}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N},Bool}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_intersection_empty(H1::AbstractHyperrectangle{N},
                      H2::AbstractHyperrectangle{N},
                      witness::Bool=false
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether two hyperrectangles do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>H1</code> – first hyperrectangle</li><li><code>H2</code> – second hyperrectangle</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$H1 ∩ H2 = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$H1 ∩ H2 = ∅$</span></li><li><code>(false, v)</code> iff <span>$H1 ∩ H2 ≠ ∅$</span> and <span>$v ∈ H1 ∩ H2$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$H1 ∩ H2 ≠ ∅$</span> iff <span>$|c_2 - c_1| ≤ r_1 + r_2$</span>, where <span>$≤$</span> is taken component-wise.</p><p>A witness is computed by starting in one center and moving toward the other center for as long as the minimum of the radius and the center distance. In other words, the witness is the point in <code>H1</code> that is closest to the center of <code>H2</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L53-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{LazySet{N},AbstractSingleton{N}}, Tuple{LazySet{N},AbstractSingleton{N},Bool}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{LazySet{N},AbstractSingleton{N}}, Tuple{LazySet{N},AbstractSingleton{N},Bool}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_intersection_empty(X::LazySet{N},
                      S::AbstractSingleton{N},
                      witness::Bool=false
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set and a singleton do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – convex set</li><li><code>S</code>       – singleton</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ∩ X = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$S ∩ X = ∅$</span></li><li><code>(false, v)</code> iff <span>$S ∩ X ≠ ∅$</span> and <code>v</code> = <code>element(S)</code> <span>$∈ S ∩ X$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ∩ X = ∅$</span> iff <code>element(S)</code> <span>$∉ X$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L136-L162">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractSingleton{N}}, Tuple{AbstractHyperrectangle{N},AbstractSingleton{N},Bool}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractSingleton{N}}, Tuple{AbstractHyperrectangle{N},AbstractSingleton{N},Bool}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_intersection_empty(H::AbstractHyperrectangle{N},
                      S::AbstractSingleton{N},
                      witness::Bool=false
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a hyperrectangle and a singleton do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangle</li><li><code>S</code> – singleton</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$H ∩ S = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$H ∩ S = ∅$</span></li><li><code>(false, v)</code> iff <span>$H ∩ S ≠ ∅$</span> and <code>v</code> = <code>element(S)</code> <span>$∈ H ∩ S$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$H ∩ S = ∅$</span> iff <code>element(S)</code> <span>$∉ H$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L216-L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{AbstractSingleton{N},AbstractSingleton{N}}, Tuple{AbstractSingleton{N},AbstractSingleton{N},Bool}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{AbstractSingleton{N},AbstractSingleton{N}}, Tuple{AbstractSingleton{N},AbstractSingleton{N},Bool}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_intersection_empty(S1::AbstractSingleton{N},
                      S2::AbstractSingleton{N},
                      witness::Bool=false
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether two singletons do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>S1</code> – first singleton</li><li><code>S2</code> – second singleton</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S1 ∩ S2 = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$S1 ∩ S2 = ∅$</span></li><li><code>(false, v)</code> iff <span>$S1 ∩ S2 ≠ ∅$</span> and <code>v</code> = <code>element(S1)</code> <span>$∈ S1 ∩ S2$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S1 ∩ S2 = ∅$</span> iff <span>$S1 ≠ S2$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L178-L203">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{Zonotope{N},Hyperplane{N}}, Tuple{Zonotope{N},Hyperplane{N},Bool}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{Zonotope{N},Hyperplane{N}}, Tuple{Zonotope{N},Hyperplane{N},Bool}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_intersection_empty(Z::Zonotope{N}, H::Hyperplane{N}, witness::Bool=false
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a zonotope and a hyperplane do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotope</li><li><code>H</code> – hyperplane</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$Z ∩ H = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$Z ∩ H = ∅$</span></li><li><code>(false, v)</code> iff <span>$Z ∩ H ≠ ∅$</span> and <span>$v ∈ Z ∩ H$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$Z ∩ H = ∅$</span> iff <span>$(b - a⋅c) ∉ \left[ ± ∑_{i=1}^p |a⋅g_i| \right]$</span>, where <span>$a$</span>, <span>$b$</span> are the hyperplane coefficients, <span>$c$</span> is the zonotope&#39;s center, and <span>$g_i$</span> are the zonotope&#39;s generators.</p><p>For witness production we fall back to a less efficient implementation for general sets as the first argument.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L331-L359">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{Ball2{N},Ball2{N}}, Tuple{Ball2{N},Ball2{N},Bool}} where N&lt;:AbstractFloat" href="#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{Ball2{N},Ball2{N}}, Tuple{Ball2{N},Ball2{N},Bool}} where N&lt;:AbstractFloat"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_intersection_empty(B1::Ball2{N},
                      B2::Ball2{N},
                      witness::Bool=false
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:AbstractFloat}</code></pre><p>Check whether two balls in the 2-norm do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>B1</code> – first ball in the 2-norm</li><li><code>B2</code> – second ball in the 2-norm</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$B1 ∩ B2 = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$B1 ∩ B2 = ∅$</span></li><li><code>(false, v)</code> iff <span>$B1 ∩ B2 ≠ ∅$</span> and <span>$v ∈ B1 ∩ B2$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$B1 ∩ B2 = ∅$</span> iff <span>$‖ c_2 - c_1 ‖_2 &gt; r_1 + r_2$</span>.</p><p>A witness is computed depending on the smaller/bigger ball (to break ties, choose <code>B1</code> for the smaller ball) as follows.</p><ul><li>If the smaller ball&#39;s center is contained in the bigger ball, we return it.</li><li>Otherwise start in the smaller ball&#39;s center and move toward the other center until hitting the smaller ball&#39;s border. In other words, the witness is the point in the smaller ball that is closest to the center of the bigger ball.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L261-L294">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{LineSegment{N},LineSegment{N}}, Tuple{LineSegment{N},LineSegment{N},Bool}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{LineSegment{N},LineSegment{N}}, Tuple{LineSegment{N},LineSegment{N},Bool}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_intersection_empty(ls1::LineSegment{N},
                      ls2::LineSegment{N},
                      witness::Bool=false
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether two line segments do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>ls1</code> – first line segment</li><li><code>ls2</code> – second line segment</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$ls1 ∩ ls2 = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$ls1 ∩ ls2 = ∅$</span></li><li><code>(false, v)</code> iff <span>$ls1 ∩ ls2 ≠ ∅$</span> and <span>$v ∈ ls1 ∩ ls2$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>The algorithm is inspired from <a href="https://stackoverflow.com/a/565282">here</a>, which again is the special 2D case of a 3D algorithm by Ronald Goldman&#39;s article on the <em>Intersection of two lines in three-space</em> in Graphics Gems, Andrew S. (ed.), 1990.</p><p>We first check if the two line segments are parallel, and if so, if they are collinear. In the latter case, we check containment of any of the end points in the other line segment. Otherwise the lines are not parallel, so we can solve an equation of the intersection point, if it exists.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L384-L418">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{LazySet{N},Union{Hyperplane{N}, Line{N,VN} where VN&lt;:AbstractArray{N,1}}}, Tuple{LazySet{N},Union{Hyperplane{N}, Line{N,VN} where VN&lt;:AbstractArray{N,1}},Bool}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{LazySet{N},Union{Hyperplane{N}, Line{N,VN} where VN&lt;:AbstractArray{N,1}}}, Tuple{LazySet{N},Union{Hyperplane{N}, Line{N,VN} where VN&lt;:AbstractArray{N,1}},Bool}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_intersection_empty(X::LazySet{N},
                      hp::Union{Hyperplane{N}, Line{N}},
                      [witness]::Bool=false
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a compact set an a hyperplane do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – compact set</li><li><code>hp</code>      – hyperplane</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ∩ hp = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ∩ hp = ∅$</span></li><li><code>(false, v)</code> iff <span>$X ∩ hp ≠ ∅$</span> and <span>$v ∈ X ∩ hp$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>We assume that <code>X</code> is compact. Otherwise, the support vector queries may fail.</p><p><strong>Algorithm</strong></p><p>A compact convex set intersects with a hyperplane iff the support function in the negative resp. positive direction of the hyperplane&#39;s normal vector <span>$a$</span> is to the left resp. right of the hyperplane&#39;s constraint <span>$b$</span>:</p><div>\[-ρ(-a) ≤ b ≤ ρ(a)\]</div><p>For witness generation, we compute a line connecting the support vectors to the left and right, and then take the intersection of the line with the hyperplane. We follow <a href="https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form">this algorithm</a> for the line-hyperplane intersection.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L530-L572">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{LazySet{N},HalfSpace{N}}, Tuple{LazySet{N},HalfSpace{N},Bool}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{LazySet{N},HalfSpace{N}}, Tuple{LazySet{N},HalfSpace{N},Bool}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_intersection_empty(X::LazySet{N},
                      hs::HalfSpace{N},
                      [witness]::Bool=false
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a compact set an a half-space do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – compact set</li><li><code>hs</code>      – half-space</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ∩ hs = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ∩ hs = ∅$</span></li><li><code>(false, v)</code> iff <span>$X ∩ hs ≠ ∅$</span> and <span>$v ∈ X ∩ hs$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>We assume that <code>X</code> is compact. Otherwise, the support vector queries may fail.</p><p><strong>Algorithm</strong></p><p>A compact convex set intersects with a half-space iff the support vector in the negative direction of the half-space&#39;s normal vector <span>$a$</span> is contained in the half-space: <span>$σ(-a) ∈ hs$</span>. The support vector is thus also a witness.</p><p>Optional keyword arguments can be passed to the <code>ρ</code> function. In particular, if <code>X</code> is a lazy intersection, options can be passed to the line search algorithm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L632-L668">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{HalfSpace{N},HalfSpace{N}}, Tuple{HalfSpace{N},HalfSpace{N},Bool}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{HalfSpace{N},HalfSpace{N}}, Tuple{HalfSpace{N},HalfSpace{N},Bool}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_intersection_empty(hs1::HalfSpace{N},
                      hs2::HalfSpace{N},
                      [witness]::Bool=false
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether two half-spaces do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>hs1</code>     – half-space</li><li><code>hs2</code>     – half-space</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$hs1 ∩ hs2 = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$hs1 ∩ hs2 = ∅$</span></li><li><code>(false, v)</code> iff <span>$hs1 ∩ hs2 ≠ ∅$</span> and <span>$v ∈ hs1 ∩ hs2$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Two half-spaces do not intersect if and only if their normal vectors point in the opposite direction and there is a gap between the two defining hyperplanes.</p><p>The latter can be checked as follows: Let <span>$hs_1 : a_1⋅x = b_1$</span> and <span>$hs2 : a_2⋅x = b_2$</span>. Then we already know that <span>$a_2 = -k⋅a_1$</span> for some positive scaling factor <span>$k$</span>. Let <span>$x_1$</span> be a point on the defining hyperplane of <span>$hs_1$</span>. We construct a line segment from <span>$x_1$</span> to the point <span>$x_2$</span> on the defining hyperplane of <span>$hs_2$</span> by shooting a ray from <span>$x_1$</span> with direction <span>$a_1$</span>. Thus we look for a factor <span>$s$</span> such that <span>$(x_1 + s⋅a_1)⋅a_2 = b_2$</span>. This gives us <span>$s = (b_2 - x_1⋅a_2) / (-k a_1⋅a_1)$</span>. The gap exists if and only if <span>$s$</span> is positive.</p><p>If the normal vectors do not point in opposite directions, then the defining hyperplanes intersect and we can produce a witness as follows. All points <span>$x$</span> in this intersection satisfy <span>$a_1⋅x = b_1$</span> and <span>$a_2⋅x = b_2$</span>. Thus we have <span>$(a_1 + a_2)⋅x = b_1+b_2$</span>. We now find a dimension where <span>$a_1 + a_2$</span> is non-zero, say, <span>$i$</span>. Then the result is a vector with one non-zero entry in dimension <span>$i$</span>, defined as <span>$[0, …, 0, (b_1 + b_2)/(a_1[i] + a_2[i]), 0, …, 0]$</span>. Such a dimension <span>$i$</span> always exists.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L684-L730">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{Union{AbstractPolytope{N}, HPolyhedron{N}},LazySet{N}}, Tuple{Union{AbstractPolytope{N}, HPolyhedron{N}},LazySet{N},Bool}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{Union{AbstractPolytope{N}, HPolyhedron{N}},LazySet{N}}, Tuple{Union{AbstractPolytope{N}, HPolyhedron{N}},LazySet{N},Bool}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_intersection_empty(P::Union{HPolyhedron{N}, AbstractPolytope{N}},
                      X::LazySet{N},
                      witness::Bool=false;
                      solver=GLPKSolverLP(method=:Simplex)
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether two polyhedra do not intersect.</p><p><strong>Input</strong></p><ul><li><code>P</code>         – polyhedron</li><li><code>X</code>         – another set (see the Notes section below)</li><li><code>witness</code>   – (optional, default: <code>false</code>) compute a witness if activated</li><li><code>solver</code>    – (optional, default: <code>GLPKSolverLP(method=:Simplex)</code>) LP solver                backend</li><li><code>algorithm</code> – (optional, default: <code>&quot;exact&quot;</code>) algorithm keyword, one of:                * <code>&quot;exact&quot; (exact, uses a feasibility LP)                *</code>&quot;sufficient&quot; (sufficient, uses half-space checks)</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ∩ X = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$P ∩ X = ∅$</span></li><li><code>(false, v)</code> iff <span>$P ∩ X ≠ ∅$</span> and <span>$v ∈ P ∩ X$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>For <code>algorithm == &quot;exact&quot;</code>, we assume that <code>constraints_list(X)</code> is defined. For <code>algorithm == &quot;sufficient&quot;</code>, witness production is not supported.</p><p><strong>Algorithm</strong></p><p>For <code>algorithm == &quot;exact&quot;</code>, see @ref(isempty(P::HPoly{N}, ::Bool)).</p><p>For <code>algorithm == &quot;sufficient&quot;</code>, we rely on the intersection check between the set <code>X</code> and each constraint in <code>P</code>. This means one support function evaluation of <code>X</code> for each constraint of <code>P</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L808-L847">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{Union{AbstractPolytope{N}, HPolyhedron{N}},Union{AbstractPolytope{N}, HPolyhedron{N}}}, Tuple{Union{AbstractPolytope{N}, HPolyhedron{N}},Union{AbstractPolytope{N}, HPolyhedron{N}},Bool}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{Union{AbstractPolytope{N}, HPolyhedron{N}},Union{AbstractPolytope{N}, HPolyhedron{N}}}, Tuple{Union{AbstractPolytope{N}, HPolyhedron{N}},Union{AbstractPolytope{N}, HPolyhedron{N}},Bool}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_intersection_empty(X::LazySet{N},
                      Y::LazySet{N},
                      witness::Bool=false
                      )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether two sets do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>Y</code>       – another set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ∩ Y = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ∩ Y = ∅$</span></li><li><code>(false, v)</code> iff <span>$X ∩ Y ≠ ∅$</span> and <span>$v ∈ X ∩ Y$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>This is a fallback implementation that computes the concrete intersection, <code>intersection</code>, of the given sets.</p><p>A witness is constructed using the <code>an_element</code> implementation of the result.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L4-L32">source</a><div><div><pre><code class="language-none">is_intersection_empty(P::Union{HPolyhedron{N}, AbstractPolytope{N}},
                      X::LazySet{N},
                      witness::Bool=false;
                      solver=GLPKSolverLP(method=:Simplex)
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether two polyhedra do not intersect.</p><p><strong>Input</strong></p><ul><li><code>P</code>         – polyhedron</li><li><code>X</code>         – another set (see the Notes section below)</li><li><code>witness</code>   – (optional, default: <code>false</code>) compute a witness if activated</li><li><code>solver</code>    – (optional, default: <code>GLPKSolverLP(method=:Simplex)</code>) LP solver                backend</li><li><code>algorithm</code> – (optional, default: <code>&quot;exact&quot;</code>) algorithm keyword, one of:                * <code>&quot;exact&quot; (exact, uses a feasibility LP)                *</code>&quot;sufficient&quot; (sufficient, uses half-space checks)</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ∩ X = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$P ∩ X = ∅$</span></li><li><code>(false, v)</code> iff <span>$P ∩ X ≠ ∅$</span> and <span>$v ∈ P ∩ X$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>For <code>algorithm == &quot;exact&quot;</code>, we assume that <code>constraints_list(X)</code> is defined. For <code>algorithm == &quot;sufficient&quot;</code>, witness production is not supported.</p><p><strong>Algorithm</strong></p><p>For <code>algorithm == &quot;exact&quot;</code>, see @ref(isempty(P::HPoly{N}, ::Bool)).</p><p>For <code>algorithm == &quot;sufficient&quot;</code>, we rely on the intersection check between the set <code>X</code> and each constraint in <code>P</code>. This means one support function evaluation of <code>X</code> for each constraint of <code>P</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L808-L847">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},LazySet{N}}, Tuple{UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},LazySet{N},Bool}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},LazySet{N}}, Tuple{UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},LazySet{N},Bool}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_intersection_empty(cup::UnionSet{N}, X::LazySet{N}, [witness]::Bool=false
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a union of two convex sets and another set do not intersect.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of two convex sets</li><li><code>X</code>   – another set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$\text{cup} ∩ X = ∅$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L960-L974">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{UnionSetArray{N,S} where S&lt;:LazySet{N},LazySet{N}}, Tuple{UnionSetArray{N,S} where S&lt;:LazySet{N},LazySet{N},Bool}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{UnionSetArray{N,S} where S&lt;:LazySet{N},LazySet{N}}, Tuple{UnionSetArray{N,S} where S&lt;:LazySet{N},LazySet{N},Bool}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_intersection_empty(cup::UnionSetArray{N},
                      X::LazySet{N},
                      [witness]::Bool=false
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a union of a finite number of convex sets and another set do not intersect.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li><li><code>X</code>   – another set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$\text{cup} ∩ X = ∅$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L1002-L1019">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{Universe{N},LazySet{N}}, Tuple{Universe{N},LazySet{N},Bool}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{Universe{N},LazySet{N}}, Tuple{Universe{N},LazySet{N},Bool}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_intersection_empty(U::Universe{N},
                      X::LazySet{N},
                      [witness]::Bool=false
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a universe and another set do not intersect.</p><p><strong>Input</strong></p><ul><li><code>U</code> – universe</li><li><code>X</code> – another set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$X ≠ ∅$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L1094-L1110">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{Complement{N,S} where S&lt;:LazySet{N},LazySet{N}}, Tuple{Complement{N,S} where S&lt;:LazySet{N},LazySet{N},Bool}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{Complement{N,S} where S&lt;:LazySet{N},LazySet{N}}, Tuple{Complement{N,S} where S&lt;:LazySet{N},LazySet{N},Bool}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_intersection_empty(C::Complement{N},
                      X::LazySet{N},
                      [witness]::Bool=false
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether the complement of a convex set and another set do not intersect.</p><p><strong>Input</strong></p><ul><li><code>C</code> – complement of a convex set</li><li><code>X</code> – convex set</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ∩ C = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ∩ C = ∅$</span></li><li><code>(false, v)</code> iff <span>$X ∩ C ≠ ∅$</span> and <span>$v ∈ X ∩ C$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>We fall back to <code>X ⊆ C.X</code>, which can be justified as follows:</p><div>\[    X ∩ Y^C = ∅ ⟺ X ⊆ Y\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_intersection_empty.jl#L1236-L1263">source</a></section><h2><a class="nav-anchor" id="Convex-hull-1" href="#Convex-hull-1">Convex hull</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.convex_hull-Union{Tuple{N}, Tuple{Union{HPolyhedron{N}, HPolytope{N}},Union{HPolyhedron{N}, HPolytope{N}}}} where N&lt;:Real" href="#LazySets.convex_hull-Union{Tuple{N}, Tuple{Union{HPolyhedron{N}, HPolytope{N}},Union{HPolyhedron{N}, HPolytope{N}}}} where N&lt;:Real"><code>LazySets.convex_hull</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convex_hull(P1::HPoly{N}, P2::HPoly{N};
           [backend]=default_polyhedra_backend(P1, N)) where {N}</code></pre><p>Compute the convex hull of the set union of two polyhedra in H-representation.</p><p><strong>Input</strong></p><ul><li><code>P1</code>         – polyhedron</li><li><code>P2</code>         – another polyhedron</li><li><code>backend</code>    – (optional, default: <code>default_polyhedra_backend(P1, N)</code>)                 the polyhedral computations backend</li></ul><p><strong>Output</strong></p><p>The <code>HPolyhedron</code> (resp. <code>HPolytope</code>) obtained by the concrete convex hull of <code>P1</code> and <code>P2</code>.</p><p><strong>Notes</strong></p><p>For performance reasons, it is suggested to use the <code>CDDLib.Library()</code> backend for the <code>convex_hull</code>.</p><p>For further information on the supported backends see <a href="https://juliapolyhedra.github.io/Polyhedra.jl/">Polyhedra&#39;s documentation</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/HPolyhedron.jl#L434-L459">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.convex_hull-Union{Tuple{N}, Tuple{VPolytope{N},VPolytope{N}}} where N&lt;:Real" href="#LazySets.convex_hull-Union{Tuple{N}, Tuple{VPolytope{N},VPolytope{N}}} where N&lt;:Real"><code>LazySets.convex_hull</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convex_hull(P1::VPolytope{N}, P2::VPolytope{N};
            [backend]=default_polyhedra_backend(P1, N)) where {N}</code></pre><p>Compute the convex hull of the set union of two polytopes in V-representation.</p><p><strong>Input</strong></p><ul><li><code>P1</code>         – polytope</li><li><code>P2</code>         – another polytope</li><li><code>backend</code>    – (optional, default: <code>default_polyhedra_backend(P1, N)</code>) the polyhedral                 computations backend, see <a href="https://juliapolyhedra.github.io/Polyhedra.jl/latest/installation.html#Getting-Libraries-1">Polyhedra&#39;s documentation</a>                 for further information</li></ul><p><strong>Output</strong></p><p>The <code>VPolytope</code> obtained by the concrete convex hull of <code>P1</code> and <code>P2</code>.</p><p><strong>Notes</strong></p><p>For performance reasons, it is suggested to use the <code>CDDLib.Library()</code> backend for the <code>convex_hull</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/VPolytope.jl#L315-L337">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.convex_hull-Union{Tuple{N}, Tuple{VPolygon{N},VPolygon{N}}} where N&lt;:Real" href="#LazySets.convex_hull-Union{Tuple{N}, Tuple{VPolygon{N},VPolygon{N}}} where N&lt;:Real"><code>LazySets.convex_hull</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convex_hull(P::VPolygon{N}, Q::VPolygon{N};
            [algorithm]::String=&quot;monotone_chain&quot;)::VPolygon{N} where {N&lt;:Real}</code></pre><p>Return the convex hull of two polygons in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>         – polygon in vertex representation</li><li><code>Q</code>         – another polygon in vertex representation</li><li><code>algorithm</code> – (optional, default: &quot;monotone_chain&quot;) the algorithm used to                compute the convex hull</li></ul><p><strong>Output</strong></p><p>A new polygon such that its vertices are the convex hull of the given two polygons.</p><p><strong>Algorithm</strong></p><p>A convex hull algorithm is used to compute the convex hull of the vertices of the given input polygons <code>P</code> and <code>Q</code>; see <code>?convex_hull</code> for details on the available algorithms. The vertices of the output polygon are sorted in counter-clockwise fashion.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/VPolygon.jl#L502-L525">source</a></section><h2><a class="nav-anchor" id="Intersection-of-two-sets-1" href="#Intersection-of-two-sets-1">Intersection of two sets</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.intersection-Union{Tuple{N}, Tuple{AbstractSingleton{N},LazySet{N}}} where N&lt;:Real" href="#LazySets.intersection-Union{Tuple{N}, Tuple{AbstractSingleton{N},LazySet{N}}} where N&lt;:Real"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">intersection(S::AbstractSingleton{N},
             X::LazySet{N}
            )::Union{Singleton{N}, EmptySet{N}} where {N&lt;:Real}</code></pre><p>Return the intersection of a singleton with another set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – singleton</li><li><code>X</code> – another set</li></ul><p><strong>Output</strong></p><p>If the sets intersect, the result is <code>S</code>. Otherwise, the result is the empty set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/concrete_intersection.jl#L5-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.intersection-Union{Tuple{N}, Tuple{Line{N,VN} where VN&lt;:AbstractArray{N,1},Line{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.intersection-Union{Tuple{N}, Tuple{Line{N,VN} where VN&lt;:AbstractArray{N,1},Line{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">intersection(L1::Line{N}, L2::Line{N}
            )::Union{Singleton{N}, Line{N}, EmptySet{N}} where {N&lt;:Real}</code></pre><p>Return the intersection of two 2D lines.</p><p><strong>Input</strong></p><ul><li><code>L1</code> – first line</li><li><code>L2</code> – second line</li></ul><p><strong>Output</strong></p><p>If the lines are identical, the result is the first line. If the lines are parallel and not identical, the result is the empty set. Otherwise the result is the only intersection point.</p><p><strong>Examples</strong></p><p>The line <span>$y = -x + 1$</span> intersected with the line <span>$y = x$</span>:</p><pre><code class="language-julia-repl">julia&gt; intersection(Line([-1., 1.], 0.), Line([1., 1.], 1.))
Singleton{Float64,Array{Float64,1}}([0.5, 0.5])

julia&gt; intersection(Line([1., 1.], 1.), Line([1., 1.], 1.))
Line{Float64,Array{Float64,1}}([1.0, 1.0], 1.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/concrete_intersection.jl#L42-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.intersection-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N}}} where N&lt;:Real" href="#LazySets.intersection-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">intersection(H1::AbstractHyperrectangle{N},
             H2::AbstractHyperrectangle{N}
            )::Union{&lt;:Hyperrectangle{N}, EmptySet{N}} where {N&lt;:Real}</code></pre><p>Return the intersection of two hyperrectangles.</p><p><strong>Input</strong></p><ul><li><code>H1</code> – first hyperrectangle</li><li><code>H2</code> – second hyperrectangle</li></ul><p><strong>Output</strong></p><p>If the hyperrectangles do not intersect, the result is the empty set. Otherwise the result is the hyperrectangle that describes the intersection.</p><p><strong>Algorithm</strong></p><p>In each isolated direction <code>i</code> we compute the rightmost left border and the leftmost right border of the hyperrectangles. If these borders contradict, then the intersection is empty. Otherwise the result uses these borders in each dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/concrete_intersection.jl#L92-L115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.intersection-Union{Tuple{N}, Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N},Interval{N,IN} where IN&lt;:AbstractInterval{N}}} where N&lt;:Real" href="#LazySets.intersection-Union{Tuple{N}, Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N},Interval{N,IN} where IN&lt;:AbstractInterval{N}}} where N&lt;:Real"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">intersection(x::Interval{N},
             y::Interval{N}
             )::Union{Interval{N}, EmptySet{N}} where {N&lt;:Real}</code></pre><p>Return the intersection of two intervals.</p><p><strong>Input</strong></p><ul><li><code>x</code> – first interval</li><li><code>y</code> – second interval</li></ul><p><strong>Output</strong></p><p>If the intervals do not intersect, the result is the empty set. Otherwise the result is the interval that describes the intersection.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/concrete_intersection.jl#L152-L168">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.intersection-Union{Tuple{N}, Tuple{AbstractHPolygon{N},AbstractHPolygon{N}}, Tuple{AbstractHPolygon{N},AbstractHPolygon{N},Bool}} where N&lt;:Real" href="#LazySets.intersection-Union{Tuple{N}, Tuple{AbstractHPolygon{N},AbstractHPolygon{N}}, Tuple{AbstractHPolygon{N},AbstractHPolygon{N},Bool}} where N&lt;:Real"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">intersection(P1::AbstractHPolygon{N},
             P2::AbstractHPolygon{N}
            )::Union{HPolygon{N}, EmptySet{N}} where {N&lt;:Real}</code></pre><p>Return the intersection of two polygons in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P1</code>    – first polygon</li><li><code>P2</code>    – second polygon</li><li><code>prune</code> – (optional, default: <code>true</code>) flag for removing redundant constraints</li></ul><p><strong>Output</strong></p><p>If the polygons do not intersect, the result is the empty set. Otherwise the result is the polygon that describes the intersection.</p><p><strong>Algorithm</strong></p><p>We just combine the constraints of both polygons. To obtain a linear-time algorithm, we interleave the constraints. If there are two constraints with the same normal vector, we choose the tighter one.</p><p>Redundancy of constraints is checked with <a href="interfaces.html#LazySets.remove_redundant_constraints!-Tuple{AbstractHPolygon}"><code>remove_redundant_constraints!(::AbstractHPolygon)</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/concrete_intersection.jl#L179-L206">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.intersection-Union{Tuple{N}, Tuple{AbstractPolyhedron{N},AbstractPolyhedron{N}}} where N&lt;:Real" href="#LazySets.intersection-Union{Tuple{N}, Tuple{AbstractPolyhedron{N},AbstractPolyhedron{N}}} where N&lt;:Real"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">intersection(P1::AbstractPolyhedron{N},
             P2::AbstractPolyhedron{N};
             backend=nothing,
             use_polyhedra_interface=false) where {N&lt;:Real}</code></pre><p>Compute the intersection of two polyhedra.</p><p><strong>Input</strong></p><ul><li><code>P1</code>        – polyhedron</li><li><code>P2</code>        – polyhedron</li><li><code>backend</code>   – (optional, default: <code>nothing</code>) the LP solver or the backend for                polyhedral computations; its value is set internally, see the                Notes below for details</li><li><code>use_polyhedra_interface</code> – (optional, default: <code>false</code>) if <code>true</code>, use the                <code>Polyhedra</code> interface for the removal of constraints</li></ul><p><strong>Output</strong></p><p>An <code>HPolyhedron</code> resulting from the intersection of <code>P1</code> and <code>P2</code>, with the redundant constraints removed, or an empty set if the intersection is empty. If one of the arguments is a polytope, the result is an <code>HPolytope</code> instead.</p><p><strong>Notes</strong></p><p>The default value of the backend is set internally and depends on whether the Polyhedra backend is used or not. The default backends are <code>GLPKSolverLP()</code> and <code>default_polyhedra_backend(P1, N)</code>, respectively.</p><p>Note that if <code>use_polyhedra_interface</code> is set to <code>true</code>, there is no guarantee that the removal of constraints keep the set empty (see #1038 and Polyhedra#146), so it is better to check for emptiness of intersection before using this function in that case.</p><p><strong>Algorithm</strong></p><p>This implementation unifies the constraints of the two sets obtained from the <code>constraints_list</code> method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/concrete_intersection.jl#L300-L339">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.intersection-Union{Tuple{N}, Tuple{Union{VPolygon{N}, VPolytope{N}},Union{VPolygon{N}, VPolytope{N}}}} where N&lt;:Real" href="#LazySets.intersection-Union{Tuple{N}, Tuple{Union{VPolygon{N}, VPolytope{N}},Union{VPolygon{N}, VPolytope{N}}}} where N&lt;:Real"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">intersection(P1::Union{VPolytope{N}, VPolygon{N}},
             P2::Union{VPolytope{N}, VPolygon{N}};
             [backend]=default_polyhedra_backend(P1, N),
             [prunefunc]=removevredundancy!) where {N&lt;:Real}</code></pre><p>Compute the intersection of two polytopes in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>P1</code>        – polytope in vertex representation</li><li><code>P2</code>        – polytope in vertex representation</li><li><code>backend</code>   – (optional, default: <code>default_polyhedra_backend(P1, N)</code>) the                backend for polyhedral computations</li><li><code>prunefunc</code> – (optional, default: <code>removevredundancy!</code>) function to prune                the vertices of the result</li></ul><p><strong>Output</strong></p><p>A <code>VPolygon</code> if both arguments are <code>VPolygon</code>s, and a <code>VPolytope</code> otherwise.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/concrete_intersection.jl#L384-L404">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.intersection-Union{Tuple{N}, Tuple{UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},LazySet{N}}} where N&lt;:Real" href="#LazySets.intersection-Union{Tuple{N}, Tuple{UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},LazySet{N}}} where N&lt;:Real"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">intersection(cup::UnionSet{N}, X::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return the intersection of a union of two convex sets and another convex set.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of two convex sets</li><li><code>X</code>   – convex set</li></ul><p><strong>Output</strong></p><p>The union of the pairwise intersections, expressed as a <code>UnionSet</code>. If one of those sets is empty, only the other set is returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/concrete_intersection.jl#L420-L434">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.intersection-Union{Tuple{N}, Tuple{UnionSetArray{N,S} where S&lt;:LazySet{N},LazySet{N}}} where N&lt;:Real" href="#LazySets.intersection-Union{Tuple{N}, Tuple{UnionSetArray{N,S} where S&lt;:LazySet{N},LazySet{N}}} where N&lt;:Real"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">intersection(cup::UnionSetArray{N}, X::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return the intersection of a union of a finite number of convex sets and another convex set.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li><li><code>X</code>   – convex set</li></ul><p><strong>Output</strong></p><p>The union of the pairwise intersections, expressed as a <code>UnionSetArray</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/concrete_intersection.jl#L452-L466">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.intersection-Union{Tuple{N}, Tuple{Universe{N},LazySet{N}}} where N&lt;:Real" href="#LazySets.intersection-Union{Tuple{N}, Tuple{Universe{N},LazySet{N}}} where N&lt;:Real"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">intersection(U::Universe{N}, X::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return the intersection of a universe and a convex set.</p><p><strong>Input</strong></p><ul><li><code>U</code> – universe</li><li><code>X</code> – convex set</li></ul><p><strong>Output</strong></p><p>The set <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/concrete_intersection.jl#L514-L527">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.intersection-Union{Tuple{N}, Tuple{AbstractPolyhedron{N},ResetMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.intersection-Union{Tuple{N}, Tuple{AbstractPolyhedron{N},ResetMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">intersection(P::AbstractPolyhedron{N}, rm::ResetMap{N}) where {N&lt;:Real}</code></pre><p>Return the intersection of a polyhedron and a polyhedral reset map.</p><p><strong>Input</strong></p><ul><li><code>P</code>  – polyhedron</li><li><code>rm</code> – polyhedral reset map</li></ul><p><strong>Output</strong></p><p>A polyhedron.</p><p><strong>Notes</strong></p><p>We assume that <code>rm</code> is polyhedral, i.e., has a <code>constraints_list</code> method defined.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/concrete_intersection.jl#L554-L572">source</a></section><h2><a class="nav-anchor" id="Subset-check-1" href="#Subset-check-1">Subset check</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{LazySet{N},AbstractHyperrectangle{N}}, Tuple{LazySet{N},AbstractHyperrectangle{N},Bool}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{N}, Tuple{LazySet{N},AbstractHyperrectangle{N}}, Tuple{LazySet{N},AbstractHyperrectangle{N},Bool}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(S::LazySet{N}, H::AbstractHyperrectangle{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set is contained in a hyperrectangular set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>S</code> – inner convex set</li><li><code>H</code> – outer hyperrectangular set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ H$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$S ⊆ H$</span></li><li><code>(false, v)</code> iff <span>$S ⊈ H$</span> and <span>$v ∈ S \setminus H$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ⊆ H$</span> iff <span>$\operatorname{ihull}(S) ⊆ H$</span>, where  <span>$\operatorname{ihull}$</span> is the interval hull operator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L7-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{AbstractPolytope{N},LazySet{N}}, Tuple{AbstractPolytope{N},LazySet{N},Bool}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{N}, Tuple{AbstractPolytope{N},LazySet{N}}, Tuple{AbstractPolytope{N},LazySet{N},Bool}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, S::LazySet{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>P</code> – inner polytope</li><li><code>S</code> – outer convex set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$P ⊆ S$</span></li><li><code>(false, v)</code> iff <span>$P ⊈ S$</span> and <span>$v ∈ P \setminus S$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L153-L177">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{AbstractPolytope{N},AbstractHyperrectangle}, Tuple{AbstractPolytope{N},AbstractHyperrectangle,Bool}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{N}, Tuple{AbstractPolytope{N},AbstractHyperrectangle}, Tuple{AbstractPolytope{N},AbstractHyperrectangle,Bool}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, H::AbstractHyperrectangle, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a hyperrectangular set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>P</code> – inner polytope</li><li><code>H</code> – outer hyperrectangular set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ H$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$P ⊆ H$</span></li><li><code>(false, v)</code> iff <span>$P ⊈ H$</span> and <span>$v ∈ P \setminus H$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>This copy-pasted method just exists to avoid method ambiguities.</p><p><strong>Algorithm</strong></p><p>Since <span>$H$</span> is convex, <span>$P ⊆ H$</span> iff <span>$v_i ∈ H$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L38-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N}}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N},Bool}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N}}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N},Bool}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(H1::AbstractHyperrectangle{N},
  H2::AbstractHyperrectangle{N},
  [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a given hyperrectangular set is contained in another hyperrectangular set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>H1</code> – inner hyperrectangular set</li><li><code>H2</code> – outer hyperrectangular set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$H1 ⊆ H2$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$H1 ⊆ H2$</span></li><li><code>(false, v)</code> iff <span>$H1 ⊈ H2$</span> and <span>$v ∈ H1 \setminus H2$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$H1 ⊆ H2$</span> iff <span>$c_1 + r_1 ≤ c_2 + r_2 ∧ c_1 - r_1 ≥ c_2 - r_2$</span> iff <span>$r_1 - r_2 ≤ c_1 - c_2 ≤ -(r_1 - r_2)$</span>, where <span>$≤$</span> is taken component-wise.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L90-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{LazySet{N},AbstractPolyhedron{N}}, Tuple{LazySet{N},AbstractPolyhedron{N},Bool}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{N}, Tuple{LazySet{N},AbstractPolyhedron{N}}, Tuple{LazySet{N},AbstractPolyhedron{N},Bool}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(S::LazySet{N},
  P::AbstractPolyhedron{N},
  witness::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set is contained in a polyhedron, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>S</code> – inner convex set</li><li><code>P</code> – outer polyhedron (including a half-space)</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ P$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$S ⊆ P$</span></li><li><code>(false, v)</code> iff <span>$S ⊈ P$</span> and <span>$v ∈ P \setminus S$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, we can compare the support function of <span>$S$</span> and <span>$P$</span> in each direction of the constraints of <span>$P$</span>.</p><p>For witness generation, we use the support vector in the first direction where the above check fails.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L198-L227">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{AbstractSingleton{N},LazySet{N}}, Tuple{AbstractSingleton{N},LazySet{N},Bool}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{N}, Tuple{AbstractSingleton{N},LazySet{N}}, Tuple{AbstractSingleton{N},LazySet{N},Bool}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(S::AbstractSingleton{N}, set::LazySet{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a given set with a single value is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>S</code>   – inner set with a single value</li><li><code>set</code> – outer convex set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ \text{set}$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$S ⊆ \text{set}$</span></li><li><code>(false, v)</code> iff <span>$S ⊈ \text{set}$</span> and <span>$v ∈ S \setminus \text{set}$</span></li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L285-L305">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{AbstractSingleton{N},AbstractHyperrectangle{N}}, Tuple{AbstractSingleton{N},AbstractHyperrectangle{N},Bool}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{N}, Tuple{AbstractSingleton{N},AbstractHyperrectangle{N}}, Tuple{AbstractSingleton{N},AbstractHyperrectangle{N},Bool}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(S::AbstractSingleton{N},
  H::AbstractHyperrectangle{N},
  [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a given set with a single value is contained in a hyperrectangular set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>S</code> – inner set with a single value</li><li><code>H</code> – outer hyperrectangular set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ H$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$S ⊆ H$</span></li><li><code>(false, v)</code> iff <span>$S ⊈ H$</span> and <span>$v ∈ S \setminus H$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>This copy-pasted method just exists to avoid method ambiguities.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L317-L342">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{AbstractSingleton{N},AbstractSingleton{N}}, Tuple{AbstractSingleton{N},AbstractSingleton{N},Bool}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{N}, Tuple{AbstractSingleton{N},AbstractSingleton{N}}, Tuple{AbstractSingleton{N},AbstractSingleton{N},Bool}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(S1::AbstractSingleton{N},
  S2::AbstractSingleton{N},
  [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a given set with a single value is contained in another set with a single value, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>S1</code> – inner set with a single value</li><li><code>S2</code> – outer set with a single value</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S1 ⊆ S2$</span> iff <span>$S1 == S2$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$S1 ⊆ S2$</span></li><li><code>(false, v)</code> iff <span>$S1 ⊈ S2$</span> and <span>$v ∈ S1 \setminus S2$</span></li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L356-L377">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{Ball2{N},Ball2{N}}, Tuple{Ball2{N},Ball2{N},Bool}} where N&lt;:AbstractFloat" href="#Base.:⊆-Union{Tuple{N}, Tuple{Ball2{N},Ball2{N}}, Tuple{Ball2{N},Ball2{N},Bool}} where N&lt;:AbstractFloat"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(B1::Ball2{N}, B2::Ball2{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:AbstractFloat}</code></pre><p>Check whether a ball in the 2-norm is contained in another ball in the 2-norm, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>B1</code> – inner ball in the 2-norm</li><li><code>B2</code> – outer ball in the 2-norm</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$B1 ⊆ B2$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$B1 ⊆ B2$</span></li><li><code>(false, v)</code> iff <span>$B1 ⊈ B2$</span> and <span>$v ∈ B1 \setminus B2$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$B1 ⊆ B2$</span> iff <span>$‖ c_1 - c_2 ‖_2 + r_1 ≤ r_2$</span></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L394-L417">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{Union{Ball2{N}, Ballp{N}},AbstractSingleton{N}}, Tuple{Union{Ball2{N}, Ballp{N}},AbstractSingleton{N},Bool}} where N&lt;:AbstractFloat" href="#Base.:⊆-Union{Tuple{N}, Tuple{Union{Ball2{N}, Ballp{N}},AbstractSingleton{N}}, Tuple{Union{Ball2{N}, Ballp{N}},AbstractSingleton{N},Bool}} where N&lt;:AbstractFloat"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(B::Union{Ball2{N}, Ballp{N}},
  S::AbstractSingleton{N},
  [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:AbstractFloat}</code></pre><p>Check whether a ball in the 2-norm or p-norm is contained in a set with a single value, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>B</code> – inner ball in the 2-norm or p-norm</li><li><code>S</code> – outer set with a single value</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$B ⊆ S$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$B ⊆ S$</span></li><li><code>(false, v)</code> iff <span>$B ⊈ S$</span> and <span>$v ∈ B \setminus S$</span></li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L438-L459">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{LineSegment{N},LazySet{N}}, Tuple{LineSegment{N},LazySet{N},Bool}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{N}, Tuple{LineSegment{N},LazySet{N}}, Tuple{LineSegment{N},LazySet{N},Bool}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(L::LineSegment{N}, S::LazySet{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a line segment is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>L</code> – inner line segment</li><li><code>S</code> – outer convex set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$L ⊆ S$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$L ⊆ S$</span></li><li><code>(false, v)</code> iff <span>$L ⊈ S$</span> and <span>$v ∈ L \setminus S$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$L ⊆ S$</span> iff <span>$p ∈ S$</span> and <span>$q ∈ S$</span>, where <span>$p, q$</span> are the end points of <span>$L$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L487-L511">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{LineSegment{N},AbstractHyperrectangle{N}}, Tuple{LineSegment{N},AbstractHyperrectangle{N},Bool}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{N}, Tuple{LineSegment{N},AbstractHyperrectangle{N}}, Tuple{LineSegment{N},AbstractHyperrectangle{N},Bool}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(L::LineSegment{N}, H::AbstractHyperrectangle{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a line segment is contained in a hyperrectangular set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>L</code> – inner line segment</li><li><code>H</code> – outer hyperrectangular set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$L ⊆ H$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$L ⊆ H$</span></li><li><code>(false, v)</code> iff <span>$L ⊈ H$</span> and <span>$v ∈ L \setminus H$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>This copy-pasted method just exists to avoid method ambiguities.</p><p><strong>Algorithm</strong></p><p>Since <span>$H$</span> is convex, <span>$L ⊆ H$</span> iff <span>$p ∈ H$</span> and <span>$q ∈ H$</span>, where <span>$p, q$</span> are the end points of <span>$L$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L526-L554">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.Interval,LazySets.Interval}" href="#Base.:⊆-Tuple{LazySets.Interval,LazySets.Interval}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(x::Interval, y::Interval)</code></pre><p>Check whether an interval is contained in another interval.</p><p><strong>Input</strong></p><ul><li><code>x</code> – interval</li><li><code>y</code> – interval</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ⊆ y$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L572-L585">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{EmptySet{N},LazySet{N}}, Tuple{EmptySet{N},LazySet{N},Bool}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{N}, Tuple{EmptySet{N},LazySet{N}}, Tuple{EmptySet{N},LazySet{N},Bool}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(∅::EmptySet{N}, X::LazySet{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether an empty set is contained in another set.</p><p><strong>Input</strong></p><ul><li><code>∅</code>       – empty set</li><li><code>X</code>       – another set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated              (ignored, just kept for interface reasons)</li></ul><p><strong>Output</strong></p><p><code>true</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L594-L610">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{LazySet{N},EmptySet{N}}, Tuple{LazySet{N},EmptySet{N},Bool}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{N}, Tuple{LazySet{N},EmptySet{N}}, Tuple{LazySet{N},EmptySet{N},Bool}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(X::LazySet{N}, ∅::EmptySet{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a set is contained in an empty set.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – another set</li><li><code>∅</code>       – empty set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>X</code> is empty.</p><p><strong>Algorithm</strong></p><p>We rely on <code>isempty(X)</code> for the emptiness check and on <code>an_element(X)</code> for witness production.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L630-L650">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},LazySet{N}}, Tuple{UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},LazySet{N},Bool}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{N}, Tuple{UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},LazySet{N}}, Tuple{UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},LazySet{N},Bool}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(cup::UnionSet{N}, X::LazySet{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a union of two convex sets is contained in another set.</p><p><strong>Input</strong></p><ul><li><code>cup</code>     – union of two convex sets</li><li><code>X</code>       – another set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$\text{cup} ⊆ X$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$\text{cup} ⊆ X$</span></li><li><code>(false, v)</code> iff <span>$\text{cup} \not\subseteq X$</span> and <span>$v ∈ \text{cup} \setminus X$</span></li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L686-L705">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{UnionSetArray{N,S} where S&lt;:LazySet{N},LazySet{N}}, Tuple{UnionSetArray{N,S} where S&lt;:LazySet{N},LazySet{N},Bool}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{N}, Tuple{UnionSetArray{N,S} where S&lt;:LazySet{N},LazySet{N}}, Tuple{UnionSetArray{N,S} where S&lt;:LazySet{N},LazySet{N},Bool}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(cup::UnionSetArray{N}, X::LazySet{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a union of a finite number of convex sets is contained in another set.</p><p><strong>Input</strong></p><ul><li><code>cup</code>     – union of a finite number of convex sets</li><li><code>X</code>       – another set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$\text{cup} ⊆ X$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$\text{cup} ⊆ X$</span></li><li><code>(false, v)</code> iff <span>$\text{cup} \not\subseteq X$</span> and <span>$v ∈ \text{cup} \setminus X$</span></li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L711-L731">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{LazySet{N},Universe{N}}, Tuple{LazySet{N},Universe{N},Bool}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{N}, Tuple{LazySet{N},Universe{N}}, Tuple{LazySet{N},Universe{N},Bool}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(X::LazySet{N}, U::Universe{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set is contained in a universe.</p><p><strong>Input</strong></p><ul><li><code>U</code>       – universe</li><li><code>X</code>       – convex set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code></li><li>If <code>witness</code> option is activated: <code>(true, [])</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L753-L769">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{Universe{N},LazySet{N}}, Tuple{Universe{N},LazySet{N},Bool}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{N}, Tuple{Universe{N},LazySet{N}}, Tuple{Universe{N},LazySet{N},Bool}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(U::Universe{N}, X::LazySet{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a universe is contained in another convex set, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>U</code>       – universe</li><li><code>X</code>       – convex set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$U ⊆ X$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$U ⊆ X$</span></li><li><code>(false, v)</code> iff <span>$U \not\subseteq X$</span> and <span>$v ∈ U \setminus X$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>We fall back to <code>isuniversal(X)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L797-L821">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{LazySet{N},Complement{N,S} where S&lt;:LazySet{N}}, Tuple{LazySet{N},Complement{N,S} where S&lt;:LazySet{N},Bool}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{N}, Tuple{LazySet{N},Complement{N,S} where S&lt;:LazySet{N}}, Tuple{LazySet{N},Complement{N,S} where S&lt;:LazySet{N},Bool}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">⊆(X::LazySet{N}, C::Complement{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set is contained in the complement of another convex set, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – convex set</li><li><code>C</code>       – complement of a convex set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊆ C$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ⊆ C$</span></li><li><code>(false, v)</code> iff <span>$X \not\subseteq C$</span> and <span>$v ∈ X \setminus C$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>We fall back to <code>isdisjoint(X, C.X)</code>, which can be justified as follows.</p><div>\[    X ⊆ Y^C ⟺ X ∩ Y = ∅\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/869a23c58aa20dce797545d06a6341a268b41007/src/is_subset.jl#L857-L885">source</a></section><footer><hr/><a class="previous" href="conversion.html"><span class="direction">Previous</span><span class="title">Conversions between set representations</span></a><a class="next" href="approximations.html"><span class="direction">Next</span><span class="title">Approximations</span></a></footer></article></body></html>
