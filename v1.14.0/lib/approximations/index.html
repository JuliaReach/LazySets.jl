<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Approximations · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/getting_started/">Getting Started</a></li><li><a class="toctext" href="../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="toctext" href="../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="toctext" href="../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="toctext" href="../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="toctext" href="../../man/interval_hulls/">Interval Hulls</a></li><li><a class="toctext" href="../../man/convex_hulls/">Convex Hulls</a></li><li><a class="toctext" href="../../man/set_operations/">Operations on Sets</a></li><li><a class="toctext" href="../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="toctext" href="../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="toctext" href="../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="toctext" href="../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../interfaces/">Set Interfaces</a></li><li><a class="toctext" href="../representations/">Common Set Representations</a></li><li><a class="toctext" href="../operations/">Common Set Operations</a></li><li><a class="toctext" href="../comparisons/">Comparisons</a></li><li><a class="toctext" href="../conversion/">Conversions between set representations</a></li><li><a class="toctext" href="../binary_functions/">Binary Functions on Sets</a></li><li class="current"><a class="toctext" href>Approximations</a><ul class="internal"><li><a class="toctext" href="#Cartesian-Decomposition-1">Cartesian Decomposition</a></li><li><a class="toctext" href="#Overapproximations-1">Overapproximations</a></li><li><a class="toctext" href="#Box-Approximations-1">Box Approximations</a></li><li><a class="toctext" href="#Iterative-refinement-1">Iterative refinement</a></li><li><a class="toctext" href="#Template-directions-1">Template directions</a></li></ul></li><li><a class="toctext" href="../utils/">Utility Functions</a></li><li><a class="toctext" href="../parallel/">Parallel</a></li></ul></li><li><a class="toctext" href="../../about/">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Approximations</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/approximations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Approximations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Approximations-1" href="#Approximations-1">Approximations</a></h1><p>This section of the manual describes the Cartesian decomposition algorithms and the approximation of high-dimensional convex sets using projections.</p><ul><li><a href="#Approximations-1">Approximations</a></li><ul><li><a href="#Cartesian-Decomposition-1">Cartesian Decomposition</a></li><ul><li><a href="#Convenience-functions-1">Convenience functions</a></li></ul><li><a href="#Overapproximations-1">Overapproximations</a></li><li><a href="#Box-Approximations-1">Box Approximations</a></li><li><a href="#Iterative-refinement-1">Iterative refinement</a></li><li><a href="#Template-directions-1">Template directions</a></li></ul></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations" href="#LazySets.Approximations"><code>LazySets.Approximations</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Module <code>Approximations.jl</code> – polygonal approximation of convex sets through support vectors.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/Approximations.jl#L3-L6">source</a></section><h2><a class="nav-anchor" id="Cartesian-Decomposition-1" href="#Cartesian-Decomposition-1">Cartesian Decomposition</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.decompose" href="#LazySets.Approximations.decompose"><code>LazySets.Approximations.decompose</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">decompose(S::LazySet{N},
          partition::AbstractVector{&lt;:AbstractVector{Int}},
          block_options
         )::CartesianProductArray{N} where {N&lt;:Real}</code></pre><p>Decompose a high-dimensional set into a Cartesian product of overapproximations of the projections over the specified subspaces.</p><p><strong>Input</strong></p><ul><li><code>S</code>             – set</li><li><code>partition</code>     – vector of blocks (i.e., of vectors of integers) (see the                    Notes below)</li><li><code>block_options</code> – mapping from block indices in <code>partition</code> to a                    corresponding overapproximation option; we only require                    access via <code>[⋅]</code> (but see also the Notes below)</li></ul><p><strong>Output</strong></p><p>A <code>CartesianProductArray</code> containing the low-dimensional approximated projections.</p><p><strong>Algorithm</strong></p><p>For each block a specific <code>project</code> method is called, dispatching on the corresponding overapproximation option.</p><p><strong>Notes</strong></p><p>The argument <code>partition</code> requires some discussion. Typically, the list of blocks should form a partition of the set <span>$\{1, \dots, n\}$</span> represented as a list of consecutive blocks, where <span>$n$</span> is the ambient dimension of set <code>S</code>.</p><p>However, technically there is no problem if the blocks are not consecutive, blocks are missing, blocks occur more than once, or blocks are overlapping. This function will, however, stick to the order of blocks, so the resulting set must be interpreted with care in such cases. One use case is the need of a projection consisting of several blocks.</p><p>For convenience, the argument <code>block_options</code> can also be given as a single option instead of a mapping, which is then interpreted as the option for all blocks.</p><p><strong>Examples</strong></p><p>This function supports different options: one can specify the target set, the degree of accuracy, and template directions. These options are exemplified below, where we use the following example.</p><pre><code class="language-julia-repl">julia&gt; using LazySets.Approximations: decompose

julia&gt; S = Ball2(zeros(4), 1.);  # set to be decomposed (4D 2-norm unit ball)

julia&gt; P2d = [1:2, 3:4];  # a partition with two blocks of size two

julia&gt; P1d = [[1], [2], [3], [4]];  # a partition with four blocks of size one</code></pre><p><strong>Different set types</strong></p><p>We can decompose using polygons in constraint representation:</p><pre><code class="language-julia-repl">julia&gt; all([ai isa HPolygon for ai in array(decompose(S, P2d, HPolygon))])
true</code></pre><p>For decomposition into 1D subspaces, we can use <code>Interval</code>:</p><pre><code class="language-julia-repl">julia&gt; all([ai isa Interval for ai in array(decompose(S, P1d, Interval))])
true</code></pre><p>However, if you need to specify different set types for different blocks, the interface presented so far does not apply. See the paragraph <em>Advanced input for different block approximations</em> below for how to do that.</p><p><strong>Refining the decomposition I:  <span>$ε$</span>-close approximation</strong></p><p>The <span>$ε$</span> option can be used to refine a decomposition, i.e., obtain a more accurate result. We use the <a href="#Iterative-refinement-1">Iterative refinement</a> algorithm from the <code>Approximations</code> module.</p><p>To illustrate this, consider again the set <code>S</code> from above. We decompose into two 2D polygons. Using smaller <span>$ε$</span> implies a better precision, thus more constraints in each 2D decomposition. In the following example, we look at the number of constraints in the first block.</p><pre><code class="language-julia-repl">julia&gt; d(ε, bi) = array(decompose(S, P2d, (HPolygon =&gt; ε)))[bi]
d (generic function with 1 method)

julia&gt; [length(constraints_list(d(ε, 1))) for ε in [Inf, 0.1, 0.01]]
3-element Array{Int64,1}:
  4
  8
 32</code></pre><p><strong>Refining the decomposition II: template polyhedra</strong></p><p>Another way to refine a decomposition is by using template polyhedra. The idea is to specify a set of template directions and then to compute on each block the polytopic overapproximation obtained by evaluating the support function of the given input set over the template directions.</p><p>For example, octagonal 2D approximations of the set <code>S</code> are obtained with:</p><pre><code class="language-julia-repl">julia&gt; B = decompose(S, P2d, OctDirections);

julia&gt; length(B.array) == 2 &amp;&amp; all(dim(bi) == 2 for bi in B.array)
true</code></pre><p>See <a href="#Template-directions-1">Template directions</a> for the available template directions. Note that, in contrast to the polygonal <span>$ε$</span>-close approximation from above, this method can be applied to blocks of any size.</p><pre><code class="language-julia-repl">julia&gt; B = decompose(S, [1:4], OctDirections);

julia&gt; length(B.array) == 1 &amp;&amp; dim(B.array[1]) == 4
true</code></pre><p><strong>Advanced input for different block approximations</strong></p><p>Instead of defining the approximation option uniformly for each block, we can define different approximations for different blocks. The third argument has to be a mapping from block index (in the partition) to the corresponding approximation option.</p><p>For example:</p><pre><code class="language-julia-repl">julia&gt; res = array(decompose(S, P2d, Dict(1 =&gt; Hyperrectangle, 2 =&gt; 0.1)));

julia&gt; typeof(res[1]), typeof(res[2])
(Hyperrectangle{Float64}, HPolygon{Float64})</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/decompositions.jl#L69-L218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.project" href="#LazySets.Approximations.project"><code>LazySets.Approximations.project</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">project(S::LazySet{N},
        block::AbstractVector{Int},
        set_type::Type{&lt;:LinearMap},
        [n]::Int=dim(S)
       )::LinearMap{N} where {N&lt;:Real}</code></pre><p>Project a high-dimensional set to a given block by using a lazy linear map.</p><p><strong>Input</strong></p><ul><li><code>S</code>         – set</li><li><code>block</code>     – block structure - a vector with the dimensions of interest</li><li><code>LinearMap</code> – used for dispatch</li><li><code>n</code>         – (optional, default: <code>dim(S)</code>) ambient dimension of the set <code>S</code></li></ul><p><strong>Output</strong></p><p>A lazy <code>LinearMap</code> representing a projection of the set <code>S</code> to block <code>block</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/decompositions.jl#L256-L275">source</a><div><div><pre><code class="language-none">project(S::LazySet{N},
        block::AbstractVector{Int},
        set_type::Type{&lt;:LazySet},
        [n]::Int=dim(S)
       ) where {N&lt;:Real}</code></pre><p>Project a high-dimensional set to a given block and set type, possibly involving an overapproximation.</p><p><strong>Input</strong></p><ul><li><code>S</code>        – set</li><li><code>block</code>    – block structure - a vector with the dimensions of interest</li><li><code>set_type</code> – target set type</li><li><code>n</code>        – (optional, default: <code>dim(S)</code>) ambient dimension of the set <code>S</code></li></ul><p><strong>Output</strong></p><p>A set of type <code>set_type</code> representing an overapproximation of the projection of <code>S</code>.</p><p><strong>Algorithm</strong></p><ol><li>Project the set <code>S</code> with <code>M⋅S</code>, where <code>M</code> is the identity matrix in the block</li></ol><p>coordinates and zero otherwise.</p><ol><li>Overapproximate the projected lazy set using <code>overapproximate</code> and</li></ol><p><code>set_type</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/decompositions.jl#L286-L314">source</a><div><div><pre><code class="language-none">project(S::LazySet{N},
        block::AbstractVector{Int},
        set_type_and_precision::Pair{&lt;:UnionAll, &lt;:Real},
        [n]::Int=dim(S)
       ) where {N&lt;:Real}</code></pre><p>Project a high-dimensional set to a given block and set type with a certified error bound.</p><p><strong>Input</strong></p><ul><li><code>S</code>     – set</li><li><code>block</code> – block structure - a vector with the dimensions of interest</li><li><code>set_type_and_precision</code> – pair <code>(T, ε)</code> of a target set type <code>T</code> and an                             error bound <code>ε</code> for approximation</li><li><code>n</code>     – (optional, default: <code>dim(S)</code>) ambient dimension of the set <code>S</code></li></ul><p><strong>Output</strong></p><p>A set representing the epsilon-close approximation of the projection of <code>S</code>.</p><p><strong>Notes</strong></p><p>Currently we only support <code>HPolygon</code> as set type, which implies that the set must be two-dimensional.</p><p><strong>Algorithm</strong></p><ol><li>Project the set <code>S</code> with <code>M⋅S</code>, where <code>M</code> is the identity matrix in the block</li></ol><p>coordinates and zero otherwise.</p><ol><li>Overapproximate the projected lazy set with the given error bound <code>ε</code>.</li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/decompositions.jl#L324-L356">source</a><div><div><pre><code class="language-none">project(S::LazySet{N},
        block::AbstractVector{Int},
        ε::Real,
        [n]::Int=dim(S)
       ) where {N&lt;:Real}</code></pre><p>Project a high-dimensional set to a given block and set type with a certified error bound.</p><p><strong>Input</strong></p><ul><li><code>S</code>     – set</li><li><code>block</code> – block structure - a vector with the dimensions of interest</li><li><code>ε</code>     – error bound for approximation</li><li><code>n</code>     – (optional, default: <code>dim(S)</code>) ambient dimension of the set <code>S</code></li></ul><p><strong>Output</strong></p><p>A set representing the epsilon-close approximation of the projection of <code>S</code>.</p><p><strong>Algorithm</strong></p><ol><li>Project the set <code>S</code> with <code>M⋅S</code>, where <code>M</code> is the identity matrix in the block</li></ol><p>coordinates and zero otherwise.</p><ol><li>Overapproximate the projected lazy set with the given error bound <code>ε</code>.</li></ol><p>The target set type is chosen automatically.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/decompositions.jl#L371-L398">source</a><div><div><pre><code class="language-none">project(S::LazySet{N},
        block::AbstractVector{Int},
        directions::Type{&lt;:AbstractDirections},
        [n]::Int
       ) where {N&lt;:Real}</code></pre><p>Project a high-dimensional set to a given block using template directions.</p><p><strong>Input</strong></p><ul><li><code>S</code>          – set</li><li><code>block</code>      – block structure - a vector with the dimensions of interest</li><li><code>directions</code> – template directions</li><li><code>n</code>          – (optional, default: <code>dim(S)</code>) ambient dimension of the set <code>S</code></li></ul><p><strong>Output</strong></p><p>The template direction approximation of the projection of <code>S</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/decompositions.jl#L414-L433">source</a><div><div><pre><code class="language-none">project(H::HalfSpace{N}, block::AbstractVector{Int})</code></pre><p>Concrete projection of a half-space.</p><p><strong>Input</strong></p><ul><li><code>H</code>        – set</li><li><code>block</code>    – block structure, a vector with the dimensions of interest</li></ul><p><strong>Output</strong></p><p>A set representing the projection of the half-space <code>H</code> on the dimensions specified by <code>block</code>.</p><p><strong>Notes</strong></p><p>Currently only the case where the unconstrained dimensions of <code>H</code> are a subset of the <code>block</code> variables is implemented.</p><p><strong>Examples</strong></p><p>Consider the half-space <span>$x + y + 0⋅z ≤ 1$</span>, whose ambient dimension is <code>3</code>. The (trivial) projection in the three dimensions is achieved letting the block of variables to be <code>[1, 2, 3]</code>:</p><pre><code class="language-julia-repl">julia&gt; H = HalfSpace([1.0, 1.0, 0.0], 1.0)
HalfSpace{Float64,Array{Float64,1}}([1.0, 1.0, 0.0], 1.0)

julia&gt; using LazySets.Approximations: project

julia&gt; project(H, [1, 2, 3])
HalfSpace{Float64,Array{Float64,1}}([1.0, 1.0, 0.0], 1.0)</code></pre><p>Projecting along dimensions <code>1</code> and <code>2</code> only:</p><pre><code class="language-julia-repl">julia&gt; project(H, [1, 2])
HalfSpace{Float64,Array{Float64,1}}([1.0, 1.0], 1.0)</code></pre><p>In general, use the call syntax <code>project(H, constrained_dimensions(H))</code> to return the half-space projected on the dimensions where it is constrained only:</p><pre><code class="language-julia-repl">julia&gt; project(H, constrained_dimensions(H))
HalfSpace{Float64,Array{Float64,1}}([1.0, 1.0], 1.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/decompositions.jl#L443-L493">source</a><div><div><pre><code class="language-none">project(P::HPolyhedron{N}, block::AbstractVector{Int}) where {N}</code></pre><p>Concrete projection of a polyhedron in half-space representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>        – set</li><li><code>block</code>    – block structure, a vector with the dimensions of interest</li></ul><p><strong>Output</strong></p><p>A set representing the projection of <code>P</code> on the dimensions specified by <code>block</code>.</p><p><strong>Notes</strong></p><p>Currently only the case where the unconstrained dimensions of <code>P</code> are a subset of the <code>block</code> variables is implemented.</p><p><strong>Examples</strong></p><p>Consider the four-dimensional cross-polytope (unit ball in the 1-norm):</p><pre><code class="language-julia-repl">julia&gt; using LazySets.Approximations: project

julia&gt; P = convert(HPolyhedron, Ball1(zeros(4), 1.0));</code></pre><p>All dimensions are constrained, and computing the (trivial) projection on the whole space behaves as expected:</p><pre><code class="language-julia-repl">julia&gt; constrained_dimensions(P)
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; P_1234 = project(P, [1, 2, 3, 4]);

julia&gt; P_1234 == P
true</code></pre><p>Each constraint of the cross polytope is constrained in all dimensions.</p><p>Now let&#39;s take a ball in the infinity norm and remove some constraints:</p><pre><code class="language-julia-repl">julia&gt; B = BallInf(zeros(4), 1.0);

julia&gt; c = constraints_list(B)[1:2]
2-element Array{HalfSpace{Float64,VN} where VN&lt;:AbstractArray{Float64,1},1}:
 HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([1.0, 0.0, 0.0, 0.0], 1.0)
 HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([0.0, 1.0, 0.0, 0.0], 1.0)

julia&gt; P = HPolyhedron(c);

julia&gt; constrained_dimensions(P)
2-element Array{Int64,1}:
 1
 2</code></pre><p>Finally we take the concrete projection onto variables <code>1</code> and <code>2</code>:</p><pre><code class="language-julia-repl">julia&gt; project(P, [1, 2]) |&gt; constraints_list
2-element Array{HalfSpace{Float64,VN} where VN&lt;:AbstractArray{Float64,1},1}:
 HalfSpace{Float64,Array{Float64,1}}([1.0, 0.0], 1.0)
 HalfSpace{Float64,Array{Float64,1}}([0.0, 1.0], 1.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/decompositions.jl#L503-L576">source</a></section><h3><a class="nav-anchor" id="Convenience-functions-1" href="#Convenience-functions-1">Convenience functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.uniform_partition" href="#LazySets.Approximations.uniform_partition"><code>LazySets.Approximations.uniform_partition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia"> uniform_partition(n::Int, block_size::Int)</code></pre><p>Compute a uniform block partition of the given size.</p><p><strong>Input</strong></p><ul><li><code>n</code>          – number of dimensions of the partition</li><li><code>block_size</code> – size of each block</li></ul><p><strong>Output</strong></p><p>A vector of ranges, <code>Vector{UnitRange{Int}}</code>, such that the size of each block is the same, if possible.</p><p><strong>Examples</strong></p><p>If the number of dimensions <code>n</code> is 2, we have two options: either two blocks of size <code>1</code> or one block of size <code>2</code>:</p><pre><code class="language-julia-repl">julia&gt; LazySets.Approximations.uniform_partition(2, 1)
2-element Array{UnitRange{Int64},1}:
 1:1
 2:2

julia&gt; LazySets.Approximations.uniform_partition(2, 2)
1-element Array{UnitRange{Int64},1}:
 1:2</code></pre><p>If the block size argument is not compatible with (i.e. does not divide) <code>n</code>, the output is filled with one block of the size needed to reach <code>n</code>:</p><pre><code class="language-julia-repl">julia&gt; LazySets.Approximations.uniform_partition(3, 1)
3-element Array{UnitRange{Int64},1}:
 1:1
 2:2
 3:3

julia&gt; LazySets.Approximations.uniform_partition(3, 2)
2-element Array{UnitRange{Int64},1}:
 1:2
 3:3

julia&gt; LazySets.Approximations.uniform_partition(10, 6)
2-element Array{UnitRange{Int64},1}:
 1:6
 7:10</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/decompositions.jl#L1-L52">source</a></section><h2><a class="nav-anchor" id="Overapproximations-1" href="#Overapproximations-1">Overapproximations</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.overapproximate" href="#LazySets.Approximations.overapproximate"><code>LazySets.Approximations.overapproximate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">overapproximate(X::S, ::Type{S}, args...) where {S&lt;:LazySet}</code></pre><p>Overapproximating a set of type <code>S</code> with type <code>S</code> is a no-op.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>Type{S}</code> – target set type</li><li><code>args</code>    – further arguments (ignored)</li></ul><p><strong>Output</strong></p><p>The input set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L2-L16">source</a><div><div><pre><code class="language-none">overapproximate(S::LazySet{N},
                ::Type{&lt;:HPolygon},
                [ε]::Real=Inf)::HPolygon where {N&lt;:Real}</code></pre><p>Return an approximation of a given 2D convex set. If no error tolerance is given, or is <code>Inf</code>, the result is a box-shaped polygon. Otherwise the result is an ε-close approximation as a polygon.</p><p><strong>Input</strong></p><ul><li><code>S</code>        – convex set, assumed to be two-dimensional</li><li><code>HPolygon</code> – type for dispatch</li><li><code>ε</code>        – (optional, default: <code>Inf</code>) error bound</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L21-L39">source</a><div><div><pre><code class="language-none">overapproximate(S::LazySet, ε::Real)::HPolygon</code></pre><p>Alias for <code>overapproximate(S, HPolygon, ε)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L57-L61">source</a><div><div><pre><code class="language-none">overapproximate(S::LazySet,
                Type{&lt;:Hyperrectangle})::Union{Hyperrectangle, EmptySet}</code></pre><p>Return an approximation of a given set as a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>S</code>              – set</li><li><code>Hyperrectangle</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L68-L82">source</a><div><div><pre><code class="language-none">overapproximate(S::CartesianProductArray{N, &lt;:AbstractHyperrectangle{N}},
                ::Type{&lt;:Hyperrectangle}) where {N&lt;:Real}</code></pre><p>Return a tight overapproximation of the cartesian product array of a finite number of convex sets with and hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>S</code>              – cartesian product array of a finite number of convex set</li><li><code>Hyperrectangle</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>This method falls back to the corresponding <code>convert</code> method. Since the sets wrapped by the cartesian product array are hyperrectangles, it can be done efficiently without overapproximation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L89-L110">source</a><div><div><pre><code class="language-none">overapproximate(S::CartesianProduct{N, &lt;:AbstractHyperrectangle{N}, &lt;:AbstractHyperrectangle{N}},
                ::Type{&lt;:Hyperrectangle}) where {N&lt;:Real}</code></pre><p>Return a tight overapproximation of the cartesian product of two hyperrectangles by a new hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>S</code>              – cartesian product of two hyperrectangular sets</li><li><code>Hyperrectangle</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>This method falls back to the corresponding <code>convert</code> method. Since the sets wrapped by the cartesian product are hyperrectangles, it can be done efficiently without overapproximation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L116-L137">source</a><div><div><pre><code class="language-none">overapproximate(lm::LinearMap{N, &lt;:AbstractHyperrectangle{N}},
                ::Type{Hyperrectangle}) where {N}</code></pre><p>Return a tight overapproximation of the linear map of a hyperrectangular set using a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>S</code>              – linear map of a hyperrectangular set</li><li><code>Hyperrectangle</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>If <code>c</code> and <code>r</code> denote the center and vector radius of a hyperrectangle <code>H</code>, a tight hyperrectangular overapproximation of <code>M * H</code> is obtained by transforming <code>c ↦ M*c</code> and <code>r ↦ abs.(M) * c</code>, where <code>abs.(⋅)</code> denotes the element-wise absolute value operator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L143-L165">source</a><div><div><pre><code class="language-none">overapproximate(S::LazySet)::Union{Hyperrectangle, EmptySet}</code></pre><p>Alias for <code>overapproximate(S, Hyperrectangle)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L174-L178">source</a><div><div><pre><code class="language-none">overapproximate(S::ConvexHull{N, Zonotope{N}, Zonotope{N}},
                ::Type{&lt;:Zonotope})::Zonotope where {N&lt;:Real}</code></pre><p>Overapproximate the convex hull of two zonotopes.</p><p><strong>Input</strong></p><ul><li><code>S</code>        – convex hull of two zonotopes</li><li><code>Zonotope</code> – type for dispatch</li></ul><p><strong>Algorithm</strong></p><p>This function implements the method proposed in [1]. The convex hull of two zonotopes <span>$Z₁$</span> and <span>$Z₂$</span> of the same order, that we write</p><div>\[Z_j = ⟨c^{(j)}, g^{(j)}_1, …, g^{(j)}_p⟩\]</div><p>for <span>$j = 1, 2$</span>, can be overapproximated as follows:</p><div>\[CH(Z_1, Z_2) ⊆ \frac{1}{2}⟨c^{(1)}+c^{(2)}, g^{(1)}_1+g^{(2)}_1, …, g^{(1)}_p+g^{(2)}_p, c^{(1)}-c^{(2)}, g^{(1)}_1-g^{(2)}_1, …, g^{(1)}_p-g^{(2)}_p⟩.\]</div><p>If the zonotope order is not the same, this algorithm calls <code>reduce_order</code> to reduce the order to the minimum of the arguments.</p><p>It should be noted that the output zonotope is not necessarily the minimal enclosing zonotope, which is in general expensive in high dimensions. This is further investigated in [2].</p><p>[1] Reachability of Uncertain Linear Systems Using Zonotopes, A. Girard.     HSCC 2005.</p><p>[2] Zonotopes as bounding volumes, L. J. Guibas et al, Proc. of Symposium on     Discrete Algorithms, pp. 803-812.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L183-L221">source</a><div><div><pre><code class="language-none">overapproximate(Z::Zonotope, ::Type{&lt;:Hyperrectangle})::Hyperrectangle</code></pre><p>Return a tight overapproximation of a zonotope with an axis-aligned box.</p><p><strong>Input</strong></p><ul><li><code>Z</code>              – zonotope</li><li><code>Hyperrectangle</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>This function implements the method in [Section 5.1.2, 1]. A zonotope <span>$Z = ⟨c, G⟩$</span> can be overapproximated tightly by an axis-aligned box (i.e. a <code>Hyperrectangle</code>) such that its center is <span>$c$</span> and the radius along dimension <span>$i$</span> is the column-sum of the absolute values of the <span>$i$</span>-th row of <span>$G$</span> for <span>$i = 1,…, p$</span>, where <span>$p$</span> is the number of generators of <span>$Z$</span>.</p><p>[1] <em>Althoff, M., Stursberg, O., &amp; Buss, M. (2010). Computing reachable sets of hybrid systems using a combination of zonotopes and polytopes. Nonlinear analysis: hybrid systems, 4(2), 233-249.</em></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L259-L284">source</a><div><div><pre><code class="language-none">overapproximate(X::LazySet{N}, dir::AbstractDirections{N})::HPolytope{N}
    where {N}</code></pre><p>Overapproximating a set with template directions.</p><p><strong>Input</strong></p><ul><li><code>X</code>   – set</li><li><code>dir</code> – (concrete) direction representation</li></ul><p><strong>Output</strong></p><p>An <code>HPolytope</code> overapproximating the set <code>X</code> with the directions from <code>dir</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L290-L304">source</a><div><div><pre><code class="language-none">overapproximate(X::LazySet{N},
                dir::Type{&lt;:AbstractDirections})::HPolytope{N} where {N}</code></pre><p>Overapproximating a set with template directions.</p><p><strong>Input</strong></p><ul><li><code>X</code>   – set</li><li><code>dir</code> – type of direction representation</li></ul><p><strong>Output</strong></p><p>A <code>HPolytope</code> overapproximating the set <code>X</code> with the directions from <code>dir</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L317-L331">source</a><div><div><pre><code class="language-none">overapproximate(S::LazySet{N}, ::Type{&lt;:Interval}) where {N&lt;:Real}</code></pre><p>Return the overapproximation of a real unidimensional set with an interval.</p><p><strong>Input</strong></p><ul><li><code>S</code>        – one-dimensional set</li><li><code>Interval</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>An interval.</p><p><strong>Algorithm</strong></p><p>The method relies on the exact conversion to <code>Interval</code>. Two support function evaluations are needed in general.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L338-L356">source</a><div><div><pre><code class="language-none">overapproximate(cap::Intersection{N, &lt;:LazySet, &lt;:AbstractPolyhedron{N}},
                dir::AbstractDirections{N};
                kwargs...
               ) where {N&lt;:Real}</code></pre><p>Return the overapproximation of the intersection between a compact set and a polytope given a set of template directions.</p><p><strong>Input</strong></p><ul><li><code>cap</code>         – intersection of a compact set and a polytope</li><li><code>dir</code>         – template directions</li><li><code>kwargs</code>      – additional arguments that are passed to the support function                  algorithm</li></ul><p><strong>Output</strong></p><p>A polytope in H-representation such that the normal direction of each half-space is given by an element of <code>dir</code>.</p><p><strong>Algorithm</strong></p><p>Let <code>di</code> be a direction drawn from the set of template directions <code>dir</code>. Let <code>X</code> be the compact set and let <code>P</code> be the polytope. We overapproximate the set <code>X ∩ H</code> with a polytope in constraint representation using a given set of template directions <code>dir</code>.</p><p>The idea is to solve the univariate optimization problem <code>ρ(di, X ∩ Hi)</code> for each half-space in the set <code>P</code> and then take the minimum. This gives an overapproximation of the exact support function.</p><p>This algorithm is inspired from <a href="https://www.sciencedirect.com/science/article/pii/S1474667015371809">G. Frehse, R. Ray. Flowpipe-Guard Intersection for Reachability Computations with Support Functions</a>.</p><p><strong>Notes</strong></p><p>This method relies on having available the <code>constraints_list</code> of the polytope <code>P</code>.</p><p>This method of overapproximations can return a non-empty set even if the original intersection is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L383-L426">source</a><div><div><pre><code class="language-none">overapproximate(cap::Intersection{N, &lt;:HalfSpace{N}, &lt;:AbstractPolytope{N}},
                dir::AbstractDirections{N};
                [kwargs]...
               ) where {N&lt;:Real}</code></pre><p>Return the overapproximation of the intersection between a half-space and a polytope given a set of template directions.</p><p><strong>Input</strong></p><ul><li><code>cap</code>         – intersection of a half-space and a polytope</li><li><code>dir</code>         – template directions</li><li><code>kwargs</code>      – additional arguments that are passed to the support function                  algorithm</li></ul><p><strong>Output</strong></p><p>A polytope in H-representation such that the normal direction of each half-space is given by an element of <code>dir</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L476-L496">source</a><div><div><pre><code class="language-none">overapproximate(lm::LinearMap{N, &lt;:CartesianProductArray{N}},
                ::Type{CartesianProductArray{N, S}}
               ) where {N, S&lt;:LazySet{N}}</code></pre><p>Decompose a lazy linear map of a cartesian product array while keeping the original block structure.</p><p><strong>Input</strong></p><ul><li><code>lm</code>                    – lazy linear map of cartesian product array</li><li><code>CartesianProductArray</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>A <code>CartesianProductArray</code> representing the decomposed linear map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L814-L830">source</a><div><div><pre><code class="language-none">overapproximate(lm::LinearMap{N, &lt;:CartesianProductArray{N}},
                ::Type{&lt;:CartesianProductArray},
                dir::Type{&lt;:AbstractDirections}) where {N}</code></pre><p>Decompose a lazy linear map of a cartesian product array with template directions while keeping the original block structure.</p><p><strong>Input</strong></p><ul><li><code>lm</code>                    – lazy linear map of a cartesian product array</li><li><code>CartesianProductArray</code> – type for dispatch</li><li><code>dir</code>                   – template directions for overapproximation</li></ul><p><strong>Output</strong></p><p>A <code>CartesianProductArray</code> representing the decomposed linear map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L839-L856">source</a><div><div><pre><code class="language-none">overapproximate(lm::LinearMap{N, &lt;:CartesianProductArray{N}},
                ::Type{&lt;:CartesianProductArray},
                set_type::Type{&lt;:LazySet}) where {N}</code></pre><p>Decompose a lazy linear map of a cartesian product array with a given set type while keeping the original block structure.</p><p><strong>Input</strong></p><ul><li><code>lm</code>                    – lazy linear map of a cartesian product array</li><li><code>CartesianProductArray</code> – type for dispatch</li><li><code>set_type</code>              – set type for overapproximation</li></ul><p><strong>Output</strong></p><p>A <code>CartesianProductArray</code> representing the decomposed linear map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L865-L882">source</a><div><div><pre><code class="language-none">overapproximate(cap::Intersection{N,
                        &lt;:CartesianProductArray{N},
                        &lt;:AbstractPolyhedron{N}},
                   ::Type{CartesianProductArray}, oa) where {N}</code></pre><p>Return the intersection of the cartesian product of a finite number of convex sets and a polyhedron.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – Lazy intersection of cartesian product array and polyhedron</li><li><code>CartesianProductArray</code> – type for dispatch</li><li><code>oa</code>  – template directions</li></ul><p><strong>Output</strong></p><p>The intersection between <code>cpa</code> and <code>P</code> with overapproximation in each constrained block.</p><p><strong>Algorithm</strong></p><p>The intersection is only needed to be taken in the elements of the cartesian product array (subsets of variables, or &quot;blocks&quot;) which are constrained in <code>P</code>. Hence we first search for constrained blocks and then take the intersection of a lower-dimensional Cartesian product of these blocks with the projection of <code>Y</code> onto the variables of these blocks. (This projection is syntactic and exact.) The result is a <code>CartesianProductArray</code> with the same block structure as in <code>X</code>. However, when we decompose back our set we overapproximate during projection operation, therefore we need to specify overapproximation strategy (it is Hyperrectangle by default)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/overapproximate.jl#L917-L945">source</a></section><h2><a class="nav-anchor" id="Box-Approximations-1" href="#Box-Approximations-1">Box Approximations</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.ballinf_approximation" href="#LazySets.Approximations.ballinf_approximation"><code>LazySets.Approximations.ballinf_approximation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ballinf_approximation(S::LazySet{N};
                     )::BallInf{N} where {N&lt;:Real}</code></pre><p>Overapproximate a convex set by a tight ball in the infinity norm.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>A tight ball in the infinity norm.</p><p><strong>Algorithm</strong></p><p>The center and radius of the box are obtained by evaluating the support function of the given convex set along the canonical directions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/box_approximations.jl#L172-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.box_approximation" href="#LazySets.Approximations.box_approximation"><code>LazySets.Approximations.box_approximation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">box_approximation(S::LazySet{N})::Union{Hyperrectangle{N}, EmptySet{N}}
    where {N&lt;:Real}</code></pre><p>Overapproximate a convex set by a tight hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>A tight hyperrectangle.</p><p><strong>Algorithm</strong></p><p>The center of the hyperrectangle is obtained by averaging the support function of the given set in the canonical directions, and the lengths of the sides can be recovered from the distance among support functions in the same directions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/box_approximations.jl#L5-L24">source</a><div><div><pre><code class="language-none">box_approximation(r::Rectification{N}
                 )::Union{Hyperrectangle{N}, EmptySet{N}} where {N&lt;:Real}</code></pre><p>Overapproximate the rectification of a convex set by a tight hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>S</code> – rectification of a convex set</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>Box approximation and rectification distribute. Hence we first check whether the wrapped set is empty. If so, we return the empty set. Otherwise, we compute the box approximation of the wrapped set, rectify the resulting box (which is simple), and finally convert the resulting set to a box.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/box_approximations.jl#L44-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.interval_hull" href="#LazySets.Approximations.interval_hull"><code>LazySets.Approximations.interval_hull</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">interval_hull</code></pre><p>Alias for <code>box_approximation</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/box_approximations.jl#L74-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.box_approximation_symmetric" href="#LazySets.Approximations.box_approximation_symmetric"><code>LazySets.Approximations.box_approximation_symmetric</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">box_approximation_symmetric(S::LazySet{N}
                           )::Union{Hyperrectangle{N}, EmptySet{N}}
                            where {N&lt;:Real}</code></pre><p>Overapproximate a convex set by a tight hyperrectangle centered in the origin.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>A tight hyperrectangle centered in the origin.</p><p><strong>Algorithm</strong></p><p>The center of the box is the origin, and the radius is obtained by computing the maximum value of the support function evaluated at the canonical directions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/box_approximations.jl#L81-L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.symmetric_interval_hull" href="#LazySets.Approximations.symmetric_interval_hull"><code>LazySets.Approximations.symmetric_interval_hull</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">symmetric_interval_hull</code></pre><p>Alias for <code>box_approximation_symmetric</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/box_approximations.jl#L114-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.box_approximation_helper" href="#LazySets.Approximations.box_approximation_helper"><code>LazySets.Approximations.box_approximation_helper</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">box_approximation_helper(S::LazySet{N};
                        ) where {N&lt;:Real}</code></pre><p>Common code of <code>box_approximation</code> and <code>box_approximation_symmetric</code>.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>A tuple containing the data that is needed to construct a tightly overapproximating hyperrectangle.</p><ul><li><code>c</code> – center</li><li><code>r</code> – radius</li></ul><p><strong>Algorithm</strong></p><p>The center of the hyperrectangle is obtained by averaging the support function of the given convex set in the canonical directions. The lengths of the sides can be recovered from the distance among support functions in the same directions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/box_approximations.jl#L121-L145">source</a></section><h2><a class="nav-anchor" id="Iterative-refinement-1" href="#Iterative-refinement-1">Iterative refinement</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.LocalApproximation" href="#LazySets.Approximations.LocalApproximation"><code>LazySets.Approximations.LocalApproximation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">LocalApproximation{N&lt;:Real}</code></pre><p>Type that represents a local approximation in 2D.</p><p><strong>Fields</strong></p><ul><li><code>p1</code>        – first inner point</li><li><code>d1</code>        – first direction</li><li><code>p2</code>        – second inner point</li><li><code>d2</code>        – second direction</li><li><code>q</code>         – intersection of the lines l1 ⟂ d1 at p1 and l2 ⟂ d2 at p2</li><li><code>refinable</code> – states if this approximation is refinable</li><li><code>err</code>       – error upper bound</li></ul><p><strong>Notes</strong></p><p>The criteria for being refinable are determined in the method <code>new_approx</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/iterative_refinement.jl#L1-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.PolygonalOverapproximation" href="#LazySets.Approximations.PolygonalOverapproximation"><code>LazySets.Approximations.PolygonalOverapproximation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PolygonalOverapproximation{N&lt;:Real}</code></pre><p>Type that represents the polygonal approximation of a convex set.</p><p><strong>Fields</strong></p><ul><li><code>S</code>            – convex set</li><li><code>approx_stack</code> – stack of local approximations that still need to be examined</li><li><code>constraints</code>  – vector of linear constraints that are already finalized                   (i.e., they satisfy the given error bound)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/iterative_refinement.jl#L47-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.new_approx-Tuple{LazySet,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}" href="#LazySets.Approximations.new_approx-Tuple{LazySet,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}"><code>LazySets.Approximations.new_approx</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">new_approx(S::LazySet, p1::Vector{N}, d1::Vector{N}, p2::Vector{N},
           d2::Vector{N}) where {N&lt;:AbstractFloat}</code></pre><p>Create a <code>LocalApproximation</code> instance for the given excerpt of a polygonal approximation.</p><p><strong>Input</strong></p><ul><li><code>S</code>  – convex set</li><li><code>p1</code> – first inner point</li><li><code>d1</code> – first direction</li><li><code>p2</code> – second inner point</li><li><code>d2</code> – second direction</li></ul><p><strong>Output</strong></p><p>A local approximation of <code>S</code> in the given directions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/iterative_refinement.jl#L68-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.addapproximation!-Tuple{LazySets.Approximations.PolygonalOverapproximation,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}" href="#LazySets.Approximations.addapproximation!-Tuple{LazySets.Approximations.PolygonalOverapproximation,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}"><code>LazySets.Approximations.addapproximation!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">addapproximation!(Ω::PolygonalOverapproximation, p1::Vector{N},
    d1::Vector{N}, p2::Vector{N}, d2::Vector{N}) where {N&lt;:Real}</code></pre><p><strong>Input</strong></p><ul><li><code>Ω</code>  – polygonal overapproximation of a convex set</li><li><code>p1</code> – first inner point</li><li><code>d1</code> – first direction</li><li><code>p2</code> – second inner point</li><li><code>d2</code> – second direction</li></ul><p><strong>Output</strong></p><p>The list of local approximations in <code>Ω</code> of the set <code>Ω.S</code> is updated in-place and the new approximation is returned by this function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/iterative_refinement.jl#L103-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.refine-Tuple{LazySets.Approximations.LocalApproximation,LazySet}" href="#LazySets.Approximations.refine-Tuple{LazySets.Approximations.LocalApproximation,LazySet}"><code>LazySets.Approximations.refine</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">refine(approx::LocalApproximation, S::LazySet
      )::Tuple{LocalApproximation, LocalApproximation}</code></pre><p>Refine a given local approximation of the polygonal approximation of a convex set by splitting along the normal direction of the approximation.</p><p><strong>Input</strong></p><ul><li><code>approx</code> – local approximation to be refined</li><li><code>S</code>      – 2D convex set</li></ul><p><strong>Output</strong></p><p>The tuple consisting of the refined right and left local approximations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/iterative_refinement.jl#L129-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.tohrep-Tuple{LazySets.Approximations.PolygonalOverapproximation}" href="#LazySets.Approximations.tohrep-Tuple{LazySets.Approximations.PolygonalOverapproximation}"><code>LazySets.Approximations.tohrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tohrep(Ω::PolygonalOverapproximation{N})::AbstractHPolygon{N}
    where {N&lt;:Real}</code></pre><p>Convert a polygonal overapproximation into a concrete polygon.</p><p><strong>Input</strong></p><ul><li><code>Ω</code> – polygonal overapproximation of a convex set</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p><p><strong>Algorithm</strong></p><p>Internally we keep the constraints sorted. Hence we do not need to use <code>addconstraint!</code> when creating the <code>HPolygon</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/iterative_refinement.jl#L157-L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.approximate-Tuple{LazySet{Float64},Float64}" href="#LazySets.Approximations.approximate-Tuple{LazySet{Float64},Float64}"><code>LazySets.Approximations.approximate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">approximate(S::LazySet{N},
            ε::N)::PolygonalOverapproximation{N} where {N&lt;:AbstractFloat}</code></pre><p>Return an ε-close approximation of the given 2D convex set (in terms of Hausdorff distance) as an inner and an outer approximation composed by sorted local <code>Approximation2D</code>.</p><p><strong>Input</strong></p><ul><li><code>S</code> – 2D convex set</li><li><code>ε</code> – error bound</li></ul><p><strong>Output</strong></p><p>An ε-close approximation of the given 2D convex set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/iterative_refinement.jl#L190-L206">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.constraint-Tuple{LazySets.Approximations.LocalApproximation}" href="#LazySets.Approximations.constraint-Tuple{LazySets.Approximations.LocalApproximation}"><code>LazySets.Approximations.constraint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraint(approx::LocalApproximation)</code></pre><p>Convert a local approximation to a linear constraint.</p><p><strong>Input</strong></p><ul><li><code>approx</code> – local approximation</li></ul><p><strong>Output</strong></p><p>A linear constraint.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/iterative_refinement.jl#L30-L42">source</a></section><h2><a class="nav-anchor" id="Template-directions-1" href="#Template-directions-1">Template directions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.AbstractDirections" href="#LazySets.Approximations.AbstractDirections"><code>LazySets.Approximations.AbstractDirections</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractDirections{N}</code></pre><p>Abstract type for template direction representations.</p><p><strong>Notes</strong></p><p>All subtypes should implement the standard iterator methods from <code>Base</code> and the function <code>dim(d&lt;:AbstractDirections)::Int</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/template_directions.jl#L4-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.BoxDirections" href="#LazySets.Approximations.BoxDirections"><code>LazySets.Approximations.BoxDirections</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BoxDirections{N} &lt;: AbstractDirections{N}</code></pre><p>Box direction representation.</p><p><strong>Fields</strong></p><ul><li><code>n</code> – dimension</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/template_directions.jl#L37-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.OctDirections" href="#LazySets.Approximations.OctDirections"><code>LazySets.Approximations.OctDirections</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OctDirections{N} &lt;: AbstractDirections{N}</code></pre><p>Octagon direction representation.</p><p><strong>Fields</strong></p><ul><li><code>n</code> – dimension</li></ul><p><strong>Notes</strong></p><p>Octagon directions consist of all vectors that are zero almost everywhere except in two dimensions <span>$i$</span>, <span>$j$</span> (possibly <span>$i = j$</span>) where it is <span>$±1$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/template_directions.jl#L69-L82">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.BoxDiagDirections" href="#LazySets.Approximations.BoxDiagDirections"><code>LazySets.Approximations.BoxDiagDirections</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BoxDiagDirections{N} &lt;: AbstractDirections{N}</code></pre><p>Box-diagonal direction representation.</p><p><strong>Fields</strong></p><ul><li><code>n</code> – dimension</li></ul><p><strong>Notes</strong></p><p>Box-diagonal directions can be seen as the union of diagonal directions (all entries are ±1) and box directions (one entry is ±1, all other entries are 0). The iterator first enumerates all diagonal directions, and then all box directions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/template_directions.jl#L152-L167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.PolarDirections" href="#LazySets.Approximations.PolarDirections"><code>LazySets.Approximations.PolarDirections</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PolarDirections{N&lt;:AbstractFloat} &lt;: AbstractDirections{N}</code></pre><p>Polar directions representation.</p><p><strong>Fields</strong></p><ul><li><code>Nφ</code>    – length of the partition of the polar angle</li></ul><p><strong>Notes</strong></p><p>The <code>PolarDirections</code> constructor provides a sample of the unit sphere in <span>$\mathbb{R}^2$</span>, which is parameterized by the polar angles <span>$φ ∈ Dφ := [0, 2π]$</span> respectively; see the wikipedia entry <a href="https://en.wikipedia.org/wiki/Polar_coordinate_system">Polar coordinate system</a>. The domain <span>$Dφ$</span> is discretized in <span>$Nφ$</span> pieces. Then the Cartesian components of each direction are obtained with</p><div>\[[cos(φᵢ), sin(φᵢ)].\]</div><p><strong>Examples</strong></p><p>The integer passed as an argument is used to discretize <span>$φ$</span>:</p><pre><code class="language-julia-repl">julia&gt; using LazySets.Approximations: PolarDirections

julia&gt; pd = PolarDirections(2)
PolarDirections{Float64}(2, Array{Float64,1}[[1.0, 0.0], [-1.0, 1.22465e-16]])

julia&gt; pd.Nφ
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/template_directions.jl#L212-L247">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.SphericalDirections" href="#LazySets.Approximations.SphericalDirections"><code>LazySets.Approximations.SphericalDirections</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SphericalDirections{N&lt;:AbstractFloat} &lt;: AbstractDirections{N}</code></pre><p>Spherical directions representation.</p><p><strong>Fields</strong></p><ul><li><code>Nθ</code>    – length of the partition of the azimuthal angle</li><li><code>Nφ</code>    – length of the partition of the polar angle</li><li><code>stack</code> – list of computed directions</li></ul><p><strong>Notes</strong></p><p>The <code>SphericalDirections</code> constructor provides a sample of the unit sphere in <span>$\mathbb{R}^3$</span>, which is parameterized by the azimuthal and polar angles <span>$θ ∈ Dθ := [0, π]$</span> and <span>$φ ∈ Dφ := [0, 2π]$</span> respectively, see the wikipedia entry <a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system">Spherical coordinate system</a>. The domains <span>$Dθ$</span> and <span>$Dφ$</span> are discretized in <span>$Nθ$</span> and <span>$Nφ$</span> respectively. Then the Cartesian componentes of each direction are obtained with</p><div>\[[sin(θᵢ)*cos(φᵢ), sin(θᵢ)*sin(φᵢ), cos(θᵢ)].\]</div><p>The north and south poles are treated separately so that those points are not considered more than once.</p><p><strong>Examples</strong></p><p>A <code>SphericalDirections</code> can be built in different ways. If you pass only one integer, it is used to discretize both <span>$θ$</span> and <span>$φ$</span>:</p><pre><code class="language-julia-repl">julia&gt; using LazySets.Approximations: SphericalDirections

julia&gt; sd = SphericalDirections(3)
SphericalDirections{Float64}(3, 3, Array{Float64,1}[[0.0, 0.0, 1.0], [0.0, 0.0, -1.0], [1.0, 0.0, 6.12323e-17], [-1.0, 1.22465e-16, 6.12323e-17]])

julia&gt; sd.Nθ, sd.Nφ 
(3, 3)</code></pre><p>Pass two integers to control the discretization in <span>$θ$</span> and in <span>$φ$</span> separately:</p><pre><code class="language-julia-repl">julia&gt; sd_4_5 = SphericalDirections(4, 5);

julia&gt; length(sd_4_5)
10

julia&gt; sd_4_8 = SphericalDirections(4, 8);

julia&gt; length(sd_4_8)
16</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/fb09c20194f715898dce020e6dafa37359458c4a/src/Approximations/template_directions.jl#L284-L339">source</a></section><p>See also <code>overapproximate(X::LazySet, dir::AbstractDirections)::HPolytope</code>.</p><footer><hr/><a class="previous" href="../binary_functions/"><span class="direction">Previous</span><span class="title">Binary Functions on Sets</span></a><a class="next" href="../utils/"><span class="direction">Next</span><span class="title">Utility Functions</span></a></footer></article></body></html>
