<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Common Set Representations · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/getting_started.html">Getting Started</a></li><li><a class="toctext" href="../man/polyhedral_approximations.html">Polyhedral Approximations</a></li><li><a class="toctext" href="../man/decompose_example.html">Decomposing an Affine Map</a></li><li><a class="toctext" href="../man/fast_2d_LPs.html">Fast 2D LPs</a></li><li><a class="toctext" href="../man/iterative_refinement.html">Iterative Refinement</a></li><li><a class="toctext" href="../man/interval_hulls.html">Interval Hulls</a></li><li><a class="toctext" href="../man/convex_hulls.html">Convex Hulls</a></li><li><a class="toctext" href="../man/reach_zonotopes.html">A Reachability Algorithm</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="interfaces.html">Set Interfaces</a></li><li class="current"><a class="toctext" href="representations.html">Common Set Representations</a><ul class="internal"><li><a class="toctext" href="#Support-function-and-support-vector-1">Support function and support vector</a></li><li><a class="toctext" href="#Balls-1">Balls</a></li><li><a class="toctext" href="#Polygons-1">Polygons</a></li><li><a class="toctext" href="#Lines-and-linear-constraints-1">Lines and linear constraints</a></li><li><a class="toctext" href="#Hyperrectangles-1">Hyperrectangles</a></li><li><a class="toctext" href="#EmptySet-1">EmptySet</a></li><li><a class="toctext" href="#Singletons-1">Singletons</a></li><li><a class="toctext" href="#Zonotopes-1">Zonotopes</a></li></ul></li><li><a class="toctext" href="operations.html">Common Set Operations</a></li><li><a class="toctext" href="approximations.html">Approximations</a></li><li><a class="toctext" href="utils.html">Utility Functions</a></li></ul></li><li><a class="toctext" href="../about.html">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="representations.html">Common Set Representations</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/representations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Common Set Representations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Common-Set-Representations-1" href="#Common-Set-Representations-1">Common Set Representations</a></h1><p>This section of the manual describes the basic set representation types.</p><ul><li><a href="representations.html#Common-Set-Representations-1">Common Set Representations</a></li><ul><li><a href="representations.html#Support-function-and-support-vector-1">Support function and support vector</a></li><li><a href="representations.html#Balls-1">Balls</a></li><ul><li><a href="representations.html#Euclidean-norm-ball-1">Euclidean norm ball</a></li><li><a href="representations.html#Infinity-norm-ball-1">Infinity norm ball</a></li><li><a href="representations.html#Manhattan-norm-ball-1">Manhattan norm ball</a></li><li><a href="representations.html#p-norm-ball-1">p-norm ball</a></li></ul><li><a href="representations.html#Polygons-1">Polygons</a></li><ul><li><a href="representations.html#Constraint-representation-1">Constraint representation</a></li><li><a href="representations.html#Optimized-constraint-representation-1">Optimized constraint representation</a></li><li><a href="representations.html#Vertex-representation-1">Vertex representation</a></li></ul><li><a href="representations.html#Lines-and-linear-constraints-1">Lines and linear constraints</a></li><li><a href="representations.html#Hyperrectangles-1">Hyperrectangles</a></li><li><a href="representations.html#EmptySet-1">EmptySet</a></li><li><a href="representations.html#Singletons-1">Singletons</a></li><ul><li><a href="representations.html#ZeroSet-1">ZeroSet</a></li></ul><li><a href="representations.html#Zonotopes-1">Zonotopes</a></li></ul></ul><h2><a class="nav-anchor" id="Support-function-and-support-vector-1" href="#Support-function-and-support-vector-1">Support function and support vector</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets" href="#LazySets"><code>LazySets</code></a> — <span class="docstring-category">Module</span>.</div><div><p>Main module for <code>LazySets.jl</code> – a Julia package for calculus with convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/LazySets.jl#L3-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ" href="#LazySets.ρ"><code>LazySets.ρ</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ρ(d::AbstractVector{N}, S::LazySet)::N where {N&lt;:Real}</code></pre><p>Evaluate the support function of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>S</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>The support function of the set <code>S</code> for the direction <code>d</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/support_function.jl#L5-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.support_function" href="#LazySets.support_function"><code>LazySets.support_function</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">support_function</code></pre><p>Alias for the support function ρ.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/support_function.jl#L23-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.support_vector" href="#LazySets.support_vector"><code>LazySets.support_vector</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">support_vector</code></pre><p>Alias for the support vector σ.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/support_function.jl#L30-L34">source</a></section><h2><a class="nav-anchor" id="Balls-1" href="#Balls-1">Balls</a></h2><h3><a class="nav-anchor" id="Euclidean-norm-ball-1" href="#Euclidean-norm-ball-1">Euclidean norm ball</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Ball2" href="#LazySets.Ball2"><code>LazySets.Ball2</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Ball2{N&lt;:AbstractFloat} &lt;: AbstractPointSymmetric{N}</code></pre><p>Type that represents a ball in the 2-norm.</p><p><strong>Fields</strong></p><ul><li><p><code>center</code> – center of the ball as a real vector</p></li><li><p><code>radius</code> – radius of the ball as a real scalar (<span>$≥ 0$</span>)</p></li></ul><p><strong>Notes</strong></p><p>Mathematically, a ball in the 2-norm is defined as the set</p><div>\[\mathcal{B}_2^n(c, r) = \{ x ∈ \mathbb{R}^n : ‖ x - c ‖_2 ≤ r \},\]</div><p>where <span>$c ∈ \mathbb{R}^n$</span> is its center and <span>$r ∈ \mathbb{R}_+$</span> its radius. Here <span>$‖ ⋅ ‖_2$</span> denotes the Euclidean norm (also known as 2-norm), defined as <span>$‖ x ‖_2 = \left( \sum\limits_{i=1}^n |x_i|^2 \right)^{1/2}$</span> for any <span>$x ∈ \mathbb{R}^n$</span>.</p><p><strong>Examples</strong></p><p>Create a five-dimensional ball <code>B</code> in the 2-norm centered at the origin with radius 0.5:</p><pre><code class="language-julia-repl">julia&gt; B = Ball2(zeros(5), 0.5)
LazySets.Ball2{Float64}([0.0, 0.0, 0.0, 0.0, 0.0], 0.5)
julia&gt; dim(B)
5</code></pre><p>Evaluate <code>B</code>&#39;s support vector in the direction <span>$[1,2,3,4,5]$</span>:</p><pre><code class="language-julia-repl">julia&gt; σ([1.,2.,3.,4.,5.], B)
5-element Array{Float64,1}:
 0.06742
 0.13484
 0.20226
 0.26968
 0.3371</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Ball2.jl#L5-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.Ball2}" href="#LazySets.dim-Tuple{LazySets.Ball2}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(S::AbstractPointSymmetric)::Int</code></pre><p>Return the ambient dimension of a point symmetric set.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPointSymmetric.jl#L25-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Ball2}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Ball2}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, B::Ball2)::AbstractVector{&lt;:AbstractFloat} where {N&lt;:AbstractFloat}</code></pre><p>Return the support vector of a 2-norm ball in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>B</code> – ball in the 2-norm</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the origin is returned.</p><p><strong>Notes</strong></p><p>Let <span>$c$</span> and <span>$r$</span> be the center and radius of a ball <span>$B$</span> in the 2-norm, respectively. For nonzero direction <span>$d$</span> we have <span>$σ(d, B) = c + r * (d / ‖d‖_2)$</span>.</p><p>This function requires computing the 2-norm of the input direction, which is performed in the given precision of the numeric datatype of both the direction and the set. Exact inputs are not supported.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Ball2.jl#L88-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.Ball2{Float64}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.Ball2{Float64}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, B::Ball2{N})::Bool where {N&lt;:AbstractFloat}</code></pre><p>Check whether a given point is contained in a ball in the 2-norm.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>B</code> – ball in the 2-norm</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ B$</span>.</p><p><strong>Notes</strong></p><p>This implementation is worst-case optimized, i.e., it is optimistic and first computes (see below) the whole sum before comparing to the radius. In applications where the point is typically far away from the ball, a fail-fast implementation with interleaved comparisons could be more efficient.</p><p><strong>Algorithm</strong></p><p>Let <span>$B$</span> be an <span>$n$</span>-dimensional ball in the 2-norm with radius <span>$r$</span> and let <span>$c_i$</span> and <span>$x_i$</span> be the ball&#39;s center and the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ B$</span> iff <span>$\left( ∑_{i=1}^n |c_i - x_i|^2 \right)^{1/2} ≤ r$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = Ball2([1., 1.], sqrt(0.5))
LazySets.Ball2{Float64}([1.0, 1.0], 0.7071067811865476)
julia&gt; ∈([.5, 1.6], B)
false
julia&gt; ∈([.5, 1.5], B)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Ball2.jl#L124-L162">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{LazySets.Ball2{Float64}}" href="#LazySets.an_element-Tuple{LazySets.Ball2{Float64}}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(S::AbstractPointSymmetric{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a point symmetric set.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – point symmetric set</p></li></ul><p><strong>Output</strong></p><p>The center of the point symmetric set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPointSymmetric.jl#L42-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.Ball2,LazySets.Singleton}" href="#Base.:⊆-Tuple{LazySets.Ball2,LazySets.Singleton}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(S::LazySet, H::AbstractHyperrectangle{N}, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set is contained in a hyperrectangle, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – inner convex set</p></li><li><p><code>H</code> – outer hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ H$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S ⊆ H$</span></p></li><li><p><code>(false, v)</code> iff <span>$S \not\subseteq H$</span> and <span>$v ∈ S \setminus H$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ⊆ H$</span> iff <span>$\operatorname{ihull}(S) ⊆ H$</span>, where  <span>$\operatorname{ihull}$</span> is the interval hull operator.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L165-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.Ball2,LazySets.AbstractHyperrectangle}" href="#Base.:⊆-Tuple{LazySets.Ball2,LazySets.AbstractHyperrectangle}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(S::LazySet, H::AbstractHyperrectangle{N}, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set is contained in a hyperrectangle, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – inner convex set</p></li><li><p><code>H</code> – outer hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ H$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S ⊆ H$</span></p></li><li><p><code>(false, v)</code> iff <span>$S \not\subseteq H$</span> and <span>$v ∈ S \setminus H$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ⊆ H$</span> iff <span>$\operatorname{ihull}(S) ⊆ H$</span>, where  <span>$\operatorname{ihull}$</span> is the interval hull operator.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L165-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Tuple{LazySets.Ball2{Float64}}" href="#LazySets.center-Tuple{LazySets.Ball2{Float64}}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">center(B::Ball2{N})::Vector{N} where {N&lt;:AbstractFloat}</code></pre><p>Return the center of a ball in the 2-norm.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – ball in the 2-norm</p></li></ul><p><strong>Output</strong></p><p>The center of the ball in the 2-norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Ball2.jl#L67-L79">source</a></section><h3><a class="nav-anchor" id="Infinity-norm-ball-1" href="#Infinity-norm-ball-1">Infinity norm ball</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.BallInf" href="#LazySets.BallInf"><code>LazySets.BallInf</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">BallInf{N&lt;:Real} &lt;: AbstractHyperrectangle{N}</code></pre><p>Type that represents a ball in the infinity norm.</p><p><strong>Fields</strong></p><ul><li><p><code>center</code> – center of the ball as a real vector</p></li><li><p><code>radius</code> – radius of the ball as a real scalar (<span>$≥ 0$</span>)</p></li></ul><p><strong>Notes</strong></p><p>Mathematically, a ball in the infinity norm is defined as the set</p><div>\[\mathcal{B}_∞^n(c, r) = \{ x ∈ \mathbb{R}^n : ‖ x - c ‖_∞ ≤ r \},\]</div><p>where <span>$c ∈ \mathbb{R}^n$</span> is its center and <span>$r ∈ \mathbb{R}_+$</span> its radius. Here <span>$‖ ⋅ ‖_∞$</span> denotes the infinity norm, defined as <span>$‖ x ‖_∞ = \max\limits_{i=1,…,n} \vert x_i \vert$</span> for any <span>$x ∈ \mathbb{R}^n$</span>.</p><p><strong>Examples</strong></p><p>Create the two-dimensional unit ball and compute its support function along the positive <span>$x=y$</span> direction:</p><pre><code class="language-julia-repl">julia&gt; B = BallInf(zeros(2), 1.0)
LazySets.BallInf{Float64}([0.0, 0.0], 1.0)
julia&gt; dim(B)
2
julia&gt; ρ([1., 1.], B)
2.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/BallInf.jl#L5-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.BallInf}" href="#LazySets.dim-Tuple{LazySets.BallInf}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(P::AbstractPointSymmetricPolytope)::Int</code></pre><p>Return the ambient dimension of a point symmetric set.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – set</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPointSymmetricPolytope.jl#L40-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.BallInf{Float64}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.BallInf{Float64}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, B::AbstractHyperrectangle{N}
 )::AbstractVector{N} where {N&lt;:Real}</code></pre><p>Return the support vector of a box-shaped set in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>B</code> – box-shaped set</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the vertex with biggest values is returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L64-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.BallInf{Float64}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.BallInf{Float64}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, B::AbstractHyperrectangle{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a box-shaped set.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>B</code> – box-shaped set</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ B$</span>.</p><p><strong>Algorithm</strong></p><p>Let <span>$B$</span> be an <span>$n$</span>-dimensional box-shaped set, <span>$c_i$</span> and <span>$r_i$</span> be the box&#39;s center and radius and <span>$x_i$</span> be the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ B$</span> iff <span>$|c_i - x_i| ≤ r_i$</span> for all <span>$i=1,…,n$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L133-L153">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{LazySets.BallInf{Float64}}" href="#LazySets.an_element-Tuple{LazySets.BallInf{Float64}}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(P::AbstractPointSymmetricPolytope{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a point symmetric polytope.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – point symmetric polytope</p></li></ul><p><strong>Output</strong></p><p>The center of the point symmetric polytope.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPointSymmetricPolytope.jl#L58-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.BallInf,LazySets.AbstractHyperrectangle}" href="#Base.:⊆-Tuple{LazySets.BallInf,LazySets.AbstractHyperrectangle}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, S::LazySet, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ S$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq S$</span> and <span>$v ∈ P \setminus S$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L33-L57">source</a><div><pre><code class="language-none">⊆(S::LazySet, H::AbstractHyperrectangle{N}, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set is contained in a hyperrectangle, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – inner convex set</p></li><li><p><code>H</code> – outer hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ H$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S ⊆ H$</span></p></li><li><p><code>(false, v)</code> iff <span>$S \not\subseteq H$</span> and <span>$v ∈ S \setminus H$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ⊆ H$</span> iff <span>$\operatorname{ihull}(S) ⊆ H$</span>, where  <span>$\operatorname{ihull}$</span> is the interval hull operator.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L165-L189">source</a><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, H::AbstractHyperrectangle, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a hyperrectangle, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>H</code> – outer hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ H$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ H$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq H$</span> and <span>$v ∈ P \setminus H$</span></p></li></ul></li></ul><p><strong>Notes</strong></p><p>This copy-pasted method just exists to avoid method ambiguities.</p><p><strong>Algorithm</strong></p><p>Since <span>$H$</span> is convex, <span>$P ⊆ H$</span> iff <span>$v_i ∈ H$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L195-L223">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.BallInf,LazySets.LazySet}" href="#Base.:⊆-Tuple{LazySets.BallInf,LazySets.LazySet}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, S::LazySet, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ S$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq S$</span> and <span>$v ∈ P \setminus S$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L33-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Tuple{LazySets.BallInf{Float64},LazySets.AbstractHyperrectangle{Float64},Bool}" href="#LazySets.is_intersection_empty-Tuple{LazySets.BallInf{Float64},LazySets.AbstractHyperrectangle{Float64},Bool}"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_intersection_empty(H1::AbstractHyperrectangle{N},
                      H2::AbstractHyperrectangle{N},
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether two hyperrectangles intersect, and if so, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>H1</code> – first hyperrectangle</p></li><li><p><code>H2</code> – second hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$H1 ∩ H2 ≠ ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, v)</code> iff <span>$H1 ∩ H2 ≠ ∅$</span> and <span>$v ∈ H1 ∩ H2$</span></p></li><li><p><code>(false, [])</code> iff <span>$H1 ∩ H2 = ∅$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$H1 ∩ H2 ≠ ∅$</span> iff <span>$|c_2 - c_1| ≤ r_1 + r_2$</span>, where <span>$≤$</span> is taken component-wise.</p><p>A witness is computed by starting in one center and moving toward the other center for as long as the minimum of the radius and the center distance. In other words, the witness is the point in <code>H1</code> that is closest to the center of <code>H2</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L303-L334">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.norm" href="#Base.LinAlg.norm"><code>Base.LinAlg.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">norm(B::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the norm of a box-shaped set.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – box-shaped set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p><p><strong>Notes</strong></p><p>The norm of a box-shaped set is defined as the norm of the enclosing ball, of the given <span>$p$</span>-norm, of minimal volume.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L85-L103">source</a><div><pre><code class="language-none">norm(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the norm of a convex set. It is the norm of the enclosing ball (of the given norm) of minimal volume.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Approximations/box_approximations.jl#L156-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius" href="#LazySets.radius"><code>LazySets.radius</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">radius(B::BallInf, [p]::Real=Inf)::Real</code></pre><p>Return the radius of a ball in the infinity norm.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – ball in the infinity norm</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p><p><strong>Notes</strong></p><p>The radius is defined as the radius of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/BallInf.jl#L117-L135">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.diameter" href="#LazySets.diameter"><code>LazySets.diameter</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diameter(B::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the diameter of a box-shaped set.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – box-shaped set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p><p><strong>Notes</strong></p><p>The diameter is defined as the maximum distance in the given <span>$p$</span>-norm between any two elements of the set. Equivalently, it is the diameter of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L108-L128">source</a><div><pre><code class="language-none">diameter(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the diameter of a convex set. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Approximations/box_approximations.jl#L203-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.BallInf{Float64}}" href="#LazySets.vertices_list-Tuple{LazySets.BallInf{Float64}}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(B::AbstractHyperrectangle{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a box-shaped set.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – box-shaped set</p></li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Notes</strong></p><p>For high dimensions, it is preferable to develop a <code>vertex_iterator</code> approach.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L37-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.singleton_list-Tuple{LazySets.BallInf{Float64}}" href="#LazySets.singleton_list-Tuple{LazySets.BallInf{Float64}}"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">singleton_list(P::AbstractPolytope{N})::Vector{Singleton{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a polytopic as a list of singletons.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – a polytopic set</p></li></ul><p><strong>Output</strong></p><p>List containing a singleton for each vertex.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L82-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Tuple{LazySets.BallInf{Float64}}" href="#LazySets.center-Tuple{LazySets.BallInf{Float64}}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">center(B::BallInf{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a ball in the infinity norm.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – ball in the infinity norm</p></li></ul><p><strong>Output</strong></p><p>The center of the ball in the infinity norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/BallInf.jl#L96-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Tuple{LazySets.BallInf{Float64}}" href="#LazySets.radius_hyperrectangle-Tuple{LazySets.BallInf{Float64}}"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius_hyperrectangle(B::BallInf{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the box radius of a infinity norm ball, which is the same in every dimension.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – infinity norm ball</p></li></ul><p><strong>Output</strong></p><p>The box radius of the ball in the infinity norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/BallInf.jl#L74-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Tuple{LazySets.BallInf{Float64},Int64}" href="#LazySets.radius_hyperrectangle-Tuple{LazySets.BallInf{Float64},Int64}"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius_hyperrectangle(B::BallInf{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the box radius of a infinity norm ball in a given dimension.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – infinity norm ball</p></li></ul><p><strong>Output</strong></p><p>The box radius of the ball in the infinity norm in the given dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/BallInf.jl#L57-L69">source</a></section><h3><a class="nav-anchor" id="Manhattan-norm-ball-1" href="#Manhattan-norm-ball-1">Manhattan norm ball</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Ball1" href="#LazySets.Ball1"><code>LazySets.Ball1</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Ball1{N&lt;:Real} &lt;: AbstractPointSymmetricPolytope{N}</code></pre><p>Type that represents a ball in the 1-norm, also known as Manhattan or Taxicab norm.</p><p>It is defined as the set</p><div>\[\mathcal{B}_1^n(c, r) = \{ x ∈ \mathbb{R}^n : ∑_{i=1}^n |c_i - x_i| ≤ r \},\]</div><p>where <span>$c ∈ \mathbb{R}^n$</span> is its center and <span>$r ∈ \mathbb{R}_+$</span> its radius.</p><p><strong>Fields</strong></p><ul><li><p><code>center</code> – center of the ball as a real vector</p></li><li><p><code>radius</code> – radius of the ball as a scalar (<span>$≥ 0$</span>)</p></li></ul><p><strong>Examples</strong></p><p>Unit ball in the 1-norm in the plane:</p><pre><code class="language-julia-repl">julia&gt; B = Ball1(zeros(2), 1.)
LazySets.Ball1{Float64}([0.0, 0.0], 1.0)
julia&gt; dim(B)
2</code></pre><p>We evaluate the support vector in the East direction:</p><pre><code class="language-julia-repl">julia&gt; σ([0.,1], B)
2-element Array{Float64,1}:
 0.0
 1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Ball1.jl#L5-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.Ball1}" href="#LazySets.dim-Tuple{LazySets.Ball1}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(P::AbstractPointSymmetricPolytope)::Int</code></pre><p>Return the ambient dimension of a point symmetric set.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – set</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPointSymmetricPolytope.jl#L40-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Ball1{Float64}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Ball1{Float64}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, B::Ball1)::AbstractVector{N} where {N&lt;:Real}</code></pre><p>Return the support vector of a ball in the 1-norm in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>B</code> – ball in the 1-norm</p></li></ul><p><strong>Output</strong></p><p>Support vector in the given direction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Ball1.jl#L110-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.Ball1{Float64}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.Ball1{Float64}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, B::Ball1{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>B</code> – ball in the 1-norm</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ B$</span>.</p><p><strong>Notes</strong></p><p>This implementation is worst-case optimized, i.e., it is optimistic and first computes (see below) the whole sum before comparing to the radius. In applications where the point is typically far away from the ball, a fail-fast implementation with interleaved comparisons could be more efficient.</p><p><strong>Algorithm</strong></p><p>Let <span>$B$</span> be an <span>$n$</span>-dimensional ball in the 1-norm with radius <span>$r$</span> and let <span>$c_i$</span> and <span>$x_i$</span> be the ball&#39;s center and the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ B$</span> iff <span>$∑_{i=1}^n |c_i - x_i| ≤ r$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = Ball1([1., 1.], 1.);

julia&gt; ∈([.5, -.5], B)
false
julia&gt; ∈([.5, 1.5], B)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Ball1.jl#L131-L169">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{LazySets.Ball1{Float64}}" href="#LazySets.an_element-Tuple{LazySets.Ball1{Float64}}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(P::AbstractPointSymmetricPolytope{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a point symmetric polytope.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – point symmetric polytope</p></li></ul><p><strong>Output</strong></p><p>The center of the point symmetric polytope.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPointSymmetricPolytope.jl#L58-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.Ball1,LazySets.LazySet}" href="#Base.:⊆-Tuple{LazySets.Ball1,LazySets.LazySet}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, S::LazySet, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ S$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq S$</span> and <span>$v ∈ P \setminus S$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L33-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.Ball1{Float64}}" href="#LazySets.vertices_list-Tuple{LazySets.Ball1{Float64}}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(B::Ball1{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – ball in the 1-norm</p></li></ul><p><strong>Output</strong></p><p>A list containing the vertices of the ball in the 1-norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Ball1.jl#L79-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.singleton_list-Tuple{LazySets.Ball1{Float64}}" href="#LazySets.singleton_list-Tuple{LazySets.Ball1{Float64}}"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">singleton_list(P::AbstractPolytope{N})::Vector{Singleton{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a polytopic as a list of singletons.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – a polytopic set</p></li></ul><p><strong>Output</strong></p><p>List containing a singleton for each vertex.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L82-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Tuple{LazySets.Ball1{Float64}}" href="#LazySets.center-Tuple{LazySets.Ball1{Float64}}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">center(B::Ball1{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – ball in the 1-norm</p></li></ul><p><strong>Output</strong></p><p>The center of the ball in the 1-norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Ball1.jl#L58-L70">source</a></section><h3><a class="nav-anchor" id="p-norm-ball-1" href="#p-norm-ball-1">p-norm ball</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Ballp" href="#LazySets.Ballp"><code>LazySets.Ballp</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Ballp{N&lt;:AbstractFloat} &lt;: AbstractPointSymmetric{N}</code></pre><p>Type that represents a ball in the p-norm, for <span>$1 ≤ p ≤ ∞$</span>.</p><p>It is defined as the set</p><div>\[\mathcal{B}_p^n(c, r) = \{ x ∈ \mathbb{R}^n : ‖ x - c ‖_p ≤ r \},\]</div><p>where <span>$c ∈ \mathbb{R}^n$</span> is its center and <span>$r ∈ \mathbb{R}_+$</span> its radius. Here <span>$‖ ⋅ ‖_p$</span> for <span>$1 ≤ p ≤ ∞$</span> denotes the vector <span>$p$</span>-norm, defined as <span>$‖ x ‖_p = \left( \sum\limits_{i=1}^n |x_i|^p \right)^{1/p}$</span> for any <span>$x ∈ \mathbb{R}^n$</span>.</p><p><strong>Fields</strong></p><ul><li><p><code>p</code>      – norm as a real scalar</p></li><li><p><code>center</code> – center of the ball as a real vector</p></li><li><p><code>radius</code> – radius of the ball as a scalar (<span>$≥ 0$</span>)</p></li></ul><p><strong>Notes</strong></p><p>The special cases <span>$p=1$</span>, <span>$p=2$</span> and <span>$p=∞$</span> fall back to the specialized types <code>Ball1</code>, <code>Ball2</code> and <code>BallInf</code>, respectively.</p><p><strong>Examples</strong></p><p>A five-dimensional ball in the <span>$p=3/2$</span> norm centered at the origin of radius 0.5:</p><pre><code class="language-julia-repl">julia&gt; B = Ballp(3/2, zeros(5), 0.5)
LazySets.Ballp{Float64}(1.5, [0.0, 0.0, 0.0, 0.0, 0.0], 0.5)
julia&gt; dim(B)
5</code></pre><p>We evaluate the support vector in direction <span>$[1,2,…,5]$</span>:</p><pre><code class="language-julia-repl">julia&gt; σ(1.:5, B)
5-element Array{Float64,1}:
 0.013516
 0.054064
 0.121644
 0.216256
 0.3379</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Ballp.jl#L5-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.Ballp}" href="#LazySets.dim-Tuple{LazySets.Ballp}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(S::AbstractPointSymmetric)::Int</code></pre><p>Return the ambient dimension of a point symmetric set.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPointSymmetric.jl#L25-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Ballp}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Ballp}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, B::Ballp)::AbstractVector{N} where {N&lt;:AbstractFloat}</code></pre><p>Return the support vector of a <code>Ballp</code> in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>B</code> – ball in the p-norm</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the center of the ball is returned.</p><p><strong>Algorithm</strong></p><p>The support vector of the unit ball in the <span>$p$</span>-norm along direction <span>$d$</span> is:</p><div>\[σ_{\mathcal{B}_p^n(0, 1)}(d) = \dfrac{\tilde{v}}{‖\tilde{v}‖_q},\]</div><p>where <span>$\tilde{v}_i = \frac{|d_i|^q}{d_i}$</span> if <span>$d_i ≠ 0$</span> and <span>$tilde{v}_i = 0$</span> otherwise, for all <span>$i=1,…,n$</span>, and <span>$q$</span> is the conjugate number of <span>$p$</span>. By the affine transformation <span>$x = r\tilde{x} + c$</span>, one obtains that the support vector of <span>$\mathcal{B}_p^n(c, r)$</span> is</p><div>\[σ_{\mathcal{B}_p^n(c, r)}(d) = \dfrac{v}{‖v‖_q},\]</div><p>where <span>$v_i = c_i + r\frac{|d_i|^q}{d_i}$</span> if <span>$d_i ≠ 0$</span> and <span>$v_i = 0$</span> otherwise, for all <span>$i = 1, …, n$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Ballp.jl#L106-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.Ballp{Float64}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.Ballp{Float64}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, B::Ballp{N})::Bool where {N&lt;:AbstractFloat}</code></pre><p>Check whether a given point is contained in a ball in the p-norm.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>B</code> – ball in the p-norm</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ B$</span>.</p><p><strong>Notes</strong></p><p>This implementation is worst-case optimized, i.e., it is optimistic and first computes (see below) the whole sum before comparing to the radius. In applications where the point is typically far away from the ball, a fail-fast implementation with interleaved comparisons could be more efficient.</p><p><strong>Algorithm</strong></p><p>Let <span>$B$</span> be an <span>$n$</span>-dimensional ball in the p-norm with radius <span>$r$</span> and let <span>$c_i$</span> and <span>$x_i$</span> be the ball&#39;s center and the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ B$</span> iff <span>$\left( ∑_{i=1}^n |c_i - x_i|^p \right)^{1/p} ≤ r$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = Ballp(1.5, [1., 1.], 1.)
LazySets.Ballp{Float64}(1.5, [1.0, 1.0], 1.0)
julia&gt; ∈([.5, -.5], B)
false
julia&gt; ∈([.5, 1.5], B)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Ballp.jl#L153-L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{LazySets.Ballp{Float64}}" href="#LazySets.an_element-Tuple{LazySets.Ballp{Float64}}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(S::AbstractPointSymmetric{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a point symmetric set.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – point symmetric set</p></li></ul><p><strong>Output</strong></p><p>The center of the point symmetric set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPointSymmetric.jl#L42-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.Ballp,LazySets.Singleton}" href="#Base.:⊆-Tuple{LazySets.Ballp,LazySets.Singleton}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(S::LazySet, H::AbstractHyperrectangle{N}, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set is contained in a hyperrectangle, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – inner convex set</p></li><li><p><code>H</code> – outer hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ H$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S ⊆ H$</span></p></li><li><p><code>(false, v)</code> iff <span>$S \not\subseteq H$</span> and <span>$v ∈ S \setminus H$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ⊆ H$</span> iff <span>$\operatorname{ihull}(S) ⊆ H$</span>, where  <span>$\operatorname{ihull}$</span> is the interval hull operator.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L165-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.Ballp,LazySets.AbstractHyperrectangle}" href="#Base.:⊆-Tuple{LazySets.Ballp,LazySets.AbstractHyperrectangle}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(S::LazySet, H::AbstractHyperrectangle{N}, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set is contained in a hyperrectangle, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – inner convex set</p></li><li><p><code>H</code> – outer hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ H$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S ⊆ H$</span></p></li><li><p><code>(false, v)</code> iff <span>$S \not\subseteq H$</span> and <span>$v ∈ S \setminus H$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ⊆ H$</span> iff <span>$\operatorname{ihull}(S) ⊆ H$</span>, where  <span>$\operatorname{ihull}$</span> is the interval hull operator.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L165-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Tuple{LazySets.Ballp{Float64}}" href="#LazySets.center-Tuple{LazySets.Ballp{Float64}}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">center(B::Ballp{N})::Vector{N} where {N&lt;:AbstractFloat}</code></pre><p>Return the center of a ball in the p-norm.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – ball in the p-norm</p></li></ul><p><strong>Output</strong></p><p>The center of the ball in the p-norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Ballp.jl#L85-L97">source</a></section><h2><a class="nav-anchor" id="Polygons-1" href="#Polygons-1">Polygons</a></h2><h3><a class="nav-anchor" id="Constraint-representation-1" href="#Constraint-representation-1">Constraint representation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.HPolygon" href="#LazySets.HPolygon"><code>LazySets.HPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HPolygon{N&lt;:Real} &lt;: AbstractHPolygon{N}</code></pre><p>Type that represents a convex polygon in constraint representation whose edges are sorted in counter-clockwise fashion with respect to their normal directions.</p><p><strong>Fields</strong></p><ul><li><p><code>constraints_list</code> – list of linear constraints, sorted by the angle</p></li></ul><p><strong>Notes</strong></p><p>The default constructor assumes that the given list of edges is sorted. It <em>does not perform</em> any sorting. Use <code>addconstraint!</code> to iteratively add the edges in a sorted way.</p><ul><li><p><code>HPolygon(constraints_list::Vector{LinearConstraint{&lt;:Real}})</code> – default constructor</p></li><li><p><code>HPolygon()</code> – constructor with no constraints</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/HPolygon.jl#L5-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.HPolygon}" href="#LazySets.dim-Tuple{LazySets.HPolygon}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(P::AbstractPolygon)::Int</code></pre><p>Return the ambient dimension of a polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polygon, which is 2.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolygon.jl#L31-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.HPolygon{Float64}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.HPolygon{Float64}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, P::HPolygon{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the support vector of a polygon in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. The result is always one of the vertices; in particular, if the direction has norm zero, any vertex is returned.</p><p><strong>Algorithm</strong></p><p>Comparison of directions is performed using polar angles; see the overload of <code>&lt;=</code> for two-dimensional vectors.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/HPolygon.jl#L38-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.HPolygon{Float64}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.HPolygon{Float64}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, P::AbstractHPolygon{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given 2D point is contained in a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – two-dimensional point/vector</p></li><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation checks if the point lies on the outside of each edge.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHPolygon.jl#L124-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{LazySets.HPolygon{Float64}}" href="#LazySets.an_element-Tuple{LazySets.HPolygon{Float64}}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(P::AbstractHPolygon{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>A vertex of the polygon in constraint representation (the first one in the order of the constraints).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHPolygon.jl#L102-L115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.HPolygon,LazySets.LazySet}" href="#Base.:⊆-Tuple{LazySets.HPolygon,LazySets.LazySet}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, S::LazySet, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ S$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq S$</span> and <span>$v ∈ P \setminus S$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L33-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.HPolygon{Float64}}" href="#LazySets.vertices_list-Tuple{LazySets.HPolygon{Float64}}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(P::AbstractHPolygon{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>List of vertices.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHPolygon.jl#L69-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.singleton_list-Tuple{LazySets.HPolygon{Float64}}" href="#LazySets.singleton_list-Tuple{LazySets.HPolygon{Float64}}"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">singleton_list(P::AbstractPolytope{N})::Vector{Singleton{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a polytopic as a list of singletons.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – a polytopic set</p></li></ul><p><strong>Output</strong></p><p>List containing a singleton for each vertex.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L82-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tohrep-Tuple{LazySets.HPolygon{Float64}}" href="#LazySets.tohrep-Tuple{LazySets.HPolygon{Float64}}"><code>LazySets.tohrep</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">tohrep(P::AbstractHPolygon{N})::AbstractHPolygon{N} where {N&lt;:Real}</code></pre><p>Build a contraint representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>The identity, i.e., the same polygon instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHPolygon.jl#L48-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tovrep-Tuple{LazySets.HPolygon{Float64}}" href="#LazySets.tovrep-Tuple{LazySets.HPolygon{Float64}}"><code>LazySets.tovrep</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">tovrep(P::AbstractHPolygon{N})::VPolygon{N} where {N&lt;:Real}</code></pre><p>Build a vertex representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>The same polygon but in vertex representation, a <code>VPolygon</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHPolygon.jl#L30-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.addconstraint!-Tuple{LazySets.HPolygon{Float64},LazySets.LinearConstraint{Float64}}" href="#LazySets.addconstraint!-Tuple{LazySets.HPolygon{Float64},LazySets.LinearConstraint{Float64}}"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">addconstraint!(P::AbstractHPolygon{N},
               constraint::LinearConstraint{N})::Void where {N&lt;:Real}</code></pre><p>Add a linear constraint to a polygon in constraint representation, keeping the constraints sorted by their normal directions.</p><p><strong>Input</strong></p><ul><li><p><code>P</code>          – polygon in constraint representation</p></li><li><p><code>constraint</code> – linear constraint to add</p></li></ul><p><strong>Output</strong></p><p>Nothing.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHPolygon.jl#L158-L173">source</a></section><h3><a class="nav-anchor" id="Optimized-constraint-representation-1" href="#Optimized-constraint-representation-1">Optimized constraint representation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.HPolygonOpt" href="#LazySets.HPolygonOpt"><code>LazySets.HPolygonOpt</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HPolygonOpt{N&lt;:Real} &lt;: AbstractHPolygon{N}</code></pre><p>Type that represents a convex polygon in constraint representation whose edges are sorted in counter-clockwise fashion with respect to their normal directions. This is a refined version of <code>HPolygon</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>constraints_list</code> – list of linear constraints</p></li><li><p><code>ind</code> – index in the list of constraints to begin the search to evaluate the          support function</p></li></ul><p><strong>Notes</strong></p><p>This structure is optimized to evaluate the support function/vector with a large sequence of directions that are close to each other. The strategy is to have an index that can be used to warm-start the search for optimal values in the support vector computation.</p><p>The default constructor assumes that the given list of edges is sorted. It <em>does not perform</em> any sorting. Use <code>addconstraint!</code> to iteratively add the edges in a sorted way.</p><ul><li><p><code>HPolygonOpt(constraints_list::Vector{LinearConstraint{&lt;:Real}}, ind::Int)</code> – default constructor</p></li><li><p><code>HPolygonOpt(constraints_list::Vector{LinearConstraint{&lt;:Real}})</code> – constructor without index</p></li><li><p><code>HPolygonOpt(H::HPolygon{&lt;:Real})</code> – constructor from an HPolygon</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/HPolygonOpt.jl#L5-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.HPolygonOpt}" href="#LazySets.dim-Tuple{LazySets.HPolygonOpt}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(P::AbstractPolygon)::Int</code></pre><p>Return the ambient dimension of a polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polygon, which is 2.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolygon.jl#L31-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.HPolygonOpt{Float64}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.HPolygonOpt{Float64}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, P::HPolygonOpt{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the support vector of an optimized polygon in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>P</code> – optimized polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. The result is always one of the vertices; in particular, if the direction has norm zero, any vertex is returned.</p><p><strong>Algorithm</strong></p><p>Comparison of directions is performed using polar angles; see the overload of <code>&lt;=</code> for two-dimensional vectors.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/HPolygonOpt.jl#L62-L82">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.HPolygonOpt{Float64}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.HPolygonOpt{Float64}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, P::AbstractHPolygon{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given 2D point is contained in a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – two-dimensional point/vector</p></li><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation checks if the point lies on the outside of each edge.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHPolygon.jl#L124-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{LazySets.HPolygonOpt{Float64}}" href="#LazySets.an_element-Tuple{LazySets.HPolygonOpt{Float64}}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(P::AbstractHPolygon{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>A vertex of the polygon in constraint representation (the first one in the order of the constraints).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHPolygon.jl#L102-L115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.HPolygonOpt,LazySets.LazySet}" href="#Base.:⊆-Tuple{LazySets.HPolygonOpt,LazySets.LazySet}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, S::LazySet, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ S$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq S$</span> and <span>$v ∈ P \setminus S$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L33-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.HPolygonOpt{Float64}}" href="#LazySets.vertices_list-Tuple{LazySets.HPolygonOpt{Float64}}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(P::AbstractHPolygon{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>List of vertices.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHPolygon.jl#L69-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.singleton_list-Tuple{LazySets.HPolygonOpt{Float64}}" href="#LazySets.singleton_list-Tuple{LazySets.HPolygonOpt{Float64}}"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">singleton_list(P::AbstractPolytope{N})::Vector{Singleton{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a polytopic as a list of singletons.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – a polytopic set</p></li></ul><p><strong>Output</strong></p><p>List containing a singleton for each vertex.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L82-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tohrep-Tuple{LazySets.HPolygonOpt{Float64}}" href="#LazySets.tohrep-Tuple{LazySets.HPolygonOpt{Float64}}"><code>LazySets.tohrep</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">tohrep(P::AbstractHPolygon{N})::AbstractHPolygon{N} where {N&lt;:Real}</code></pre><p>Build a contraint representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>The identity, i.e., the same polygon instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHPolygon.jl#L48-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tovrep-Tuple{LazySets.HPolygonOpt{Float64}}" href="#LazySets.tovrep-Tuple{LazySets.HPolygonOpt{Float64}}"><code>LazySets.tovrep</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">tovrep(P::AbstractHPolygon{N})::VPolygon{N} where {N&lt;:Real}</code></pre><p>Build a vertex representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>The same polygon but in vertex representation, a <code>VPolygon</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHPolygon.jl#L30-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.addconstraint!-Tuple{LazySets.HPolygonOpt{Float64},LazySets.LinearConstraint{Float64}}" href="#LazySets.addconstraint!-Tuple{LazySets.HPolygonOpt{Float64},LazySets.LinearConstraint{Float64}}"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">addconstraint!(P::AbstractHPolygon{N},
               constraint::LinearConstraint{N})::Void where {N&lt;:Real}</code></pre><p>Add a linear constraint to a polygon in constraint representation, keeping the constraints sorted by their normal directions.</p><p><strong>Input</strong></p><ul><li><p><code>P</code>          – polygon in constraint representation</p></li><li><p><code>constraint</code> – linear constraint to add</p></li></ul><p><strong>Output</strong></p><p>Nothing.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHPolygon.jl#L158-L173">source</a></section><h3><a class="nav-anchor" id="Vertex-representation-1" href="#Vertex-representation-1">Vertex representation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.VPolygon" href="#LazySets.VPolygon"><code>LazySets.VPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VPolygon{N&lt;:Real} &lt;: AbstractPolygon{N}</code></pre><p>Type that represents a polygon by its vertices.</p><p><strong>Fields</strong></p><ul><li><p><code>vertices_list</code> – the list of vertices</p></li></ul><p><strong>Notes</strong></p><p>The constructor of <code>VPolygon</code> runs a convex hull algorithm, and the given vertices are sorted in counter-clockwise fashion. The constructor flag <code>apply_convex_hull</code> can be used to skip the computation of the convex hull.</p><ul><li><p><code>VPolygon(vertices_list::Vector{Vector{N}};           apply_convex_hull::Bool=true,           algorithm::String=&quot;monotone_chain&quot;)</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/VPolygon.jl#L5-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.VPolygon}" href="#LazySets.dim-Tuple{LazySets.VPolygon}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(P::AbstractPolygon)::Int</code></pre><p>Return the ambient dimension of a polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polygon, which is 2.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolygon.jl#L31-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.VPolygon{Float64}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.VPolygon{Float64}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, P::VPolygon{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the support vector of a polygon in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>P</code> – polygon in vertex representation</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the first vertex is returned.</p><p><strong>Algorithm</strong></p><p>This implementation performs a brute-force search, comparing the projection of each vector along the given direction. It runs in <span>$O(n)$</span> where <span>$n$</span> is the number of vertices.</p><p><strong>Notes</strong></p><p>For arbitrary points without structure this is the best one can do. However, a more efficient approach can be used if the vertices of the polygon have been sorted in counter-clockwise fashion. In that case a binary search algorithm can be used that runs in <span>$O(\log n)$</span>. See issue <a href="https://github.com/JuliaReach/LazySets.jl/issues/40">#40</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/VPolygon.jl#L103-L131">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.VPolygon{Float64}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.VPolygon{Float64}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, P::VPolygon{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>P</code> – polygon in vertex representation</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation exploits that the polygon&#39;s vertices are sorted in counter-clockwise fashion. Under this assumption we can just check if the vertex lies on the left of each edge, using the dot product.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; P = VPolygon([[2.0, 3.0], [3.0, 1.0], [5.0, 1.0], [4.0, 5.0]];
                    apply_convex_hull=false);

julia&gt; ∈([4.5, 3.1], P)
false
julia&gt; ∈([4.5, 3.0], P)
true
julia&gt; ∈([4.4, 3.4], P)  #  point lies on the edge -&gt; floating point error
false
julia&gt; P = VPolygon([[2//1, 3//1], [3//1, 1//1], [5//1, 1//1], [4//1, 5//1]];
                     apply_convex_hull=false);

julia&gt; ∈([44//10, 34//10], P)  #  with rational numbers the answer is correct
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/VPolygon.jl#L166-L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{LazySets.VPolygon{Float64}}" href="#LazySets.an_element-Tuple{LazySets.VPolygon{Float64}}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(P::VPolygon{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in vertex representation</p></li></ul><p><strong>Output</strong></p><p>The first vertex of the polygon in vertex representation.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/VPolygon.jl#L146-L158">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.VPolygon,LazySets.LazySet}" href="#Base.:⊆-Tuple{LazySets.VPolygon,LazySets.LazySet}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, S::LazySet, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ S$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq S$</span> and <span>$v ∈ P \setminus S$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L33-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.VPolygon{Float64}}" href="#LazySets.vertices_list-Tuple{LazySets.VPolygon{Float64}}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(P::VPolygon{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a convex polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – a polygon vertex representation</p></li></ul><p><strong>Output</strong></p><p>List of vertices.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/VPolygon.jl#L82-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.singleton_list-Tuple{LazySets.VPolygon{Float64}}" href="#LazySets.singleton_list-Tuple{LazySets.VPolygon{Float64}}"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">singleton_list(P::AbstractPolytope{N})::Vector{Singleton{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a polytopic as a list of singletons.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – a polytopic set</p></li></ul><p><strong>Output</strong></p><p>List containing a singleton for each vertex.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L82-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tohrep-Tuple{LazySets.VPolygon{Float64}}" href="#LazySets.tohrep-Tuple{LazySets.VPolygon{Float64}}"><code>LazySets.tohrep</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">tohrep(P::VPolygon{N})::AbstractHPolygon{N} where {N&lt;:Real}</code></pre><p>Build a constraint representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in vertex representation</p></li></ul><p><strong>Output</strong></p><p>The same polygon but in constraint representation, an <code>AbstractHPolygon</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/VPolygon.jl#L61-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tovrep-Tuple{LazySets.VPolygon{Float64}}" href="#LazySets.tovrep-Tuple{LazySets.VPolygon{Float64}}"><code>LazySets.tovrep</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">tovrep(P::VPolygon{N})::VPolygon{N} where {N&lt;:Real}</code></pre><p>Build a vertex representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in vertex representation</p></li></ul><p><strong>Output</strong></p><p>The identity, i.e., the same polygon instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/VPolygon.jl#L44-L56">source</a></section><h2><a class="nav-anchor" id="Lines-and-linear-constraints-1" href="#Lines-and-linear-constraints-1">Lines and linear constraints</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.LinearConstraint" href="#LazySets.LinearConstraint"><code>LazySets.LinearConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LinearConstraint{N&lt;:Real}</code></pre><p>Type that represents a linear constraint (a half-space) of the form <span>$a⋅x ≤ b$</span>.</p><p><strong>Fields</strong></p><ul><li><p><code>a</code> – normal direction</p></li><li><p><code>b</code> – constraint</p></li></ul><p><strong>Examples</strong></p><p>The set <span>$y ≥ 0$</span> in the plane:</p><pre><code class="language-julia-repl">julia&gt; LinearConstraint([0, -1.], 0.)
LazySets.LinearConstraint{Float64}([0.0, -1.0], 0.0)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/LinearConstraints.jl#L5-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Line" href="#LazySets.Line"><code>LazySets.Line</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Line{N&lt;:Real}</code></pre><p>Type that represents a line in 2D of the form <span>$a⋅x = b$</span>.</p><p><strong>Fields</strong></p><ul><li><p><code>a</code> – normal direction</p></li><li><p><code>b</code> – constraint</p></li></ul><p><strong>Examples</strong></p><p>The line <span>$y = -x + 1$</span>:</p><pre><code class="language-julia-repl">julia&gt; Line([1., 1.], 1.)
LazySets.Line{Float64}([1.0, 1.0], 1.0)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/LinearConstraints.jl#L29-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.intersection-Tuple{LazySets.Line{Float64},LazySets.Line{Float64}}" href="#LazySets.intersection-Tuple{LazySets.Line{Float64},LazySets.Line{Float64}}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">intersection(L1::Line{N}, L2::Line{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the intersection of two 2D lines.</p><p><strong>Input</strong></p><ul><li><p><code>L1</code> – first line</p></li><li><p><code>L2</code> – second line</p></li></ul><p><strong>Output</strong></p><p>If the lines are parallel or identical, the result is an empty vector. Otherwise the result is the only intersection point.</p><p><strong>Examples</strong></p><p>The line <span>$y = -x + 1$</span> intersected with the line <span>$y = x$</span>:</p><pre><code class="language-julia-repl">julia&gt; intersection(Line([-1., 1.], 0.), Line([1., 1.], 1.))
2-element Array{Float64,1}:
 0.5
 0.5
julia&gt; intersection(Line([1., 1.], 1.), Line([1., 1.], 1.))
0-element Array{Float64,1}
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/LinearConstraints.jl#L61-L90">source</a></section><h2><a class="nav-anchor" id="Hyperrectangles-1" href="#Hyperrectangles-1">Hyperrectangles</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Hyperrectangle" href="#LazySets.Hyperrectangle"><code>LazySets.Hyperrectangle</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Hyperrectangle{N&lt;:Real} &lt;: AbstractHyperrectangle{N}</code></pre><p>Type that represents a hyperrectangle.</p><p>A <a href="https://en.wikipedia.org/wiki/Hyperrectangle">hyperrectangle</a> is the Cartesian product of one-dimensional intervals.</p><p><strong>Fields</strong></p><ul><li><p><code>center</code> – center of the hyperrectangle as a real vector</p></li><li><p><code>radius</code> – radius of the ball as a real vector, i.e., half of its width along             each coordinate direction</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Hyperrectangle.jl#L7-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Hyperrectangle-Tuple{}" href="#LazySets.Hyperrectangle-Tuple{}"><code>LazySets.Hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Hyperrectangle(;kwargs...)</code></pre><p>Construct a hyperrectangle from keyword arguments.</p><p><strong>Input</strong></p><ul><li><p><code>kwargs</code> – keyword arguments; two combinations are allowed:</p><ol><li><p><code>center</code>, <code>radius</code> – vectors</p></li><li><p><code>high</code>, <code>low</code>      – vectors (if both <code>center</code> and <code>radius</code> are also                       defined, those are chosen instead)</p></li></ol></li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Examples</strong></p><p>The following three constructions are equivalent:</p><pre><code class="language-julia-repl">julia&gt; c = ones(2);

julia&gt; r = [0.1, 0.2];

julia&gt; l = [0.9, 0.8];

julia&gt; h = [1.1, 1.2];

julia&gt; H1 = Hyperrectangle(c, r)
LazySets.Hyperrectangle{Float64}([1.0, 1.0], [0.1, 0.2])
julia&gt; H2 = Hyperrectangle(center=c, radius=r)
LazySets.Hyperrectangle{Float64}([1.0, 1.0], [0.1, 0.2])
julia&gt; H3 = Hyperrectangle(low=l, high=h)
LazySets.Hyperrectangle{Float64}([1.0, 1.0], [0.1, 0.2])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Hyperrectangle.jl#L35-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.Hyperrectangle}" href="#LazySets.dim-Tuple{LazySets.Hyperrectangle}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(P::AbstractPointSymmetricPolytope)::Int</code></pre><p>Return the ambient dimension of a point symmetric set.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – set</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPointSymmetricPolytope.jl#L40-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Hyperrectangle{Float64}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Hyperrectangle{Float64}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, B::AbstractHyperrectangle{N}
 )::AbstractVector{N} where {N&lt;:Real}</code></pre><p>Return the support vector of a box-shaped set in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>B</code> – box-shaped set</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the vertex with biggest values is returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L64-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.Hyperrectangle{Float64}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.Hyperrectangle{Float64}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, B::AbstractHyperrectangle{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a box-shaped set.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>B</code> – box-shaped set</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ B$</span>.</p><p><strong>Algorithm</strong></p><p>Let <span>$B$</span> be an <span>$n$</span>-dimensional box-shaped set, <span>$c_i$</span> and <span>$r_i$</span> be the box&#39;s center and radius and <span>$x_i$</span> be the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ B$</span> iff <span>$|c_i - x_i| ≤ r_i$</span> for all <span>$i=1,…,n$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L133-L153">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{LazySets.Hyperrectangle{Float64}}" href="#LazySets.an_element-Tuple{LazySets.Hyperrectangle{Float64}}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(P::AbstractPointSymmetricPolytope{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a point symmetric polytope.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – point symmetric polytope</p></li></ul><p><strong>Output</strong></p><p>The center of the point symmetric polytope.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPointSymmetricPolytope.jl#L58-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.Hyperrectangle,LazySets.AbstractHyperrectangle}" href="#Base.:⊆-Tuple{LazySets.Hyperrectangle,LazySets.AbstractHyperrectangle}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, S::LazySet, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ S$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq S$</span> and <span>$v ∈ P \setminus S$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L33-L57">source</a><div><pre><code class="language-none">⊆(S::LazySet, H::AbstractHyperrectangle{N}, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set is contained in a hyperrectangle, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – inner convex set</p></li><li><p><code>H</code> – outer hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ H$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S ⊆ H$</span></p></li><li><p><code>(false, v)</code> iff <span>$S \not\subseteq H$</span> and <span>$v ∈ S \setminus H$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ⊆ H$</span> iff <span>$\operatorname{ihull}(S) ⊆ H$</span>, where  <span>$\operatorname{ihull}$</span> is the interval hull operator.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L165-L189">source</a><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, H::AbstractHyperrectangle, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a hyperrectangle, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>H</code> – outer hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ H$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ H$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq H$</span> and <span>$v ∈ P \setminus H$</span></p></li></ul></li></ul><p><strong>Notes</strong></p><p>This copy-pasted method just exists to avoid method ambiguities.</p><p><strong>Algorithm</strong></p><p>Since <span>$H$</span> is convex, <span>$P ⊆ H$</span> iff <span>$v_i ∈ H$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L195-L223">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.Hyperrectangle,LazySets.LazySet}" href="#Base.:⊆-Tuple{LazySets.Hyperrectangle,LazySets.LazySet}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, S::LazySet, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ S$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq S$</span> and <span>$v ∈ P \setminus S$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L33-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Tuple{LazySets.Hyperrectangle{Float64},LazySets.AbstractHyperrectangle{Float64},Bool}" href="#LazySets.is_intersection_empty-Tuple{LazySets.Hyperrectangle{Float64},LazySets.AbstractHyperrectangle{Float64},Bool}"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_intersection_empty(H1::AbstractHyperrectangle{N},
                      H2::AbstractHyperrectangle{N},
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether two hyperrectangles intersect, and if so, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>H1</code> – first hyperrectangle</p></li><li><p><code>H2</code> – second hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$H1 ∩ H2 ≠ ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, v)</code> iff <span>$H1 ∩ H2 ≠ ∅$</span> and <span>$v ∈ H1 ∩ H2$</span></p></li><li><p><code>(false, [])</code> iff <span>$H1 ∩ H2 = ∅$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$H1 ∩ H2 ≠ ∅$</span> iff <span>$|c_2 - c_1| ≤ r_1 + r_2$</span>, where <span>$≤$</span> is taken component-wise.</p><p>A witness is computed by starting in one center and moving toward the other center for as long as the minimum of the radius and the center distance. In other words, the witness is the point in <code>H1</code> that is closest to the center of <code>H2</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L303-L334">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.norm" href="#Base.LinAlg.norm"><code>Base.LinAlg.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">norm(B::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the norm of a box-shaped set.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – box-shaped set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p><p><strong>Notes</strong></p><p>The norm of a box-shaped set is defined as the norm of the enclosing ball, of the given <span>$p$</span>-norm, of minimal volume.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L85-L103">source</a><div><pre><code class="language-none">norm(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the norm of a convex set. It is the norm of the enclosing ball (of the given norm) of minimal volume.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Approximations/box_approximations.jl#L156-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius" href="#LazySets.radius"><code>LazySets.radius</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">radius(H::Hyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the radius of a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p><p><strong>Notes</strong></p><p>The radius is defined as the radius of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Hyperrectangle.jl#L150-L168">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.diameter" href="#LazySets.diameter"><code>LazySets.diameter</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diameter(B::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the diameter of a box-shaped set.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – box-shaped set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p><p><strong>Notes</strong></p><p>The diameter is defined as the maximum distance in the given <span>$p$</span>-norm between any two elements of the set. Equivalently, it is the diameter of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L108-L128">source</a><div><pre><code class="language-none">diameter(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the diameter of a convex set. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Approximations/box_approximations.jl#L203-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.Hyperrectangle{Float64}}" href="#LazySets.vertices_list-Tuple{LazySets.Hyperrectangle{Float64}}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(B::AbstractHyperrectangle{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a box-shaped set.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – box-shaped set</p></li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Notes</strong></p><p>For high dimensions, it is preferable to develop a <code>vertex_iterator</code> approach.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L37-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.singleton_list-Tuple{LazySets.Hyperrectangle{Float64}}" href="#LazySets.singleton_list-Tuple{LazySets.Hyperrectangle{Float64}}"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">singleton_list(P::AbstractPolytope{N})::Vector{Singleton{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a polytopic as a list of singletons.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – a polytopic set</p></li></ul><p><strong>Output</strong></p><p>List containing a singleton for each vertex.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L82-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Tuple{LazySets.Hyperrectangle{Float64}}" href="#LazySets.center-Tuple{LazySets.Hyperrectangle{Float64}}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">center(H::Hyperrectangle{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li></ul><p><strong>Output</strong></p><p>The center of the hyperrectangle.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Hyperrectangle.jl#L129-L141">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Tuple{LazySets.Hyperrectangle{Float64}}" href="#LazySets.radius_hyperrectangle-Tuple{LazySets.Hyperrectangle{Float64}}"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius_hyperrectangle(H::Hyperrectangle{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the box radius of a hyperrectangle in every dimension.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li></ul><p><strong>Output</strong></p><p>The box radius of the hyperrectangle.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Hyperrectangle.jl#L108-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Tuple{LazySets.Hyperrectangle{Float64},Int64}" href="#LazySets.radius_hyperrectangle-Tuple{LazySets.Hyperrectangle{Float64},Int64}"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius_hyperrectangle(H::Hyperrectangle{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the box radius of a hyperrectangle in a given dimension.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li></ul><p><strong>Output</strong></p><p>Zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Hyperrectangle.jl#L91-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Tuple{LazySets.Hyperrectangle}" href="#LazySets.high-Tuple{LazySets.Hyperrectangle}"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">high(H::Hyperrectangle{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the higher coordinates of a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li></ul><p><strong>Output</strong></p><p>A vector with the higher coordinates of the hyperrectangle, one entry per dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Hyperrectangle.jl#L178-L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Tuple{LazySets.Hyperrectangle}" href="#LazySets.low-Tuple{LazySets.Hyperrectangle}"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">low(H::Hyperrectangle{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the lower coordinates of a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li></ul><p><strong>Output</strong></p><p>A vector with the lower coordinates of the hyperrectangle, one entry per dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Hyperrectangle.jl#L196-L209">source</a></section><h2><a class="nav-anchor" id="EmptySet-1" href="#EmptySet-1">EmptySet</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.EmptySet" href="#LazySets.EmptySet"><code>LazySets.EmptySet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">EmptySet &lt;: LazySet</code></pre><p>Type that represents the empty set, i.e., the set with no elements.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/EmptySet.jl#L6-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.EmptySet}" href="#LazySets.dim-Tuple{LazySets.EmptySet}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(∅::EmptySet)</code></pre><p>Return the dimension of the empty set, which is -1 by convention.</p><p><strong>Input</strong></p><ul><li><p><code>∅</code> – an empty set</p></li></ul><p><strong>Output</strong></p><p><code>-1</code> by convention.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/EmptySet.jl#L20-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.EmptySet}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.EmptySet}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d, ∅)</code></pre><p>Return the support vector of an empty set.</p><p><strong>Input</strong></p><ul><li><p><code>∅</code> – an empty set</p></li></ul><p><strong>Output</strong></p><p>An error.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/EmptySet.jl#L37-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.EmptySet}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.EmptySet}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector, ∅::EmptySet)::Bool</code></pre><p>Check whether a given point is contained in an empty set.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>∅</code> – empty set</p></li></ul><p><strong>Output</strong></p><p>The output is always <code>false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ∈([1.0, 0.0], ∅)
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/EmptySet.jl#L54-L74">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{LazySets.EmptySet}" href="#LazySets.an_element-Tuple{LazySets.EmptySet}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(∅::EmptySet)</code></pre><p>Return some element of an empty set.</p><p><strong>Input</strong></p><ul><li><p><code>∅</code> – empty set</p></li></ul><p><strong>Output</strong></p><p>An error.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/EmptySet.jl#L79-L91">source</a></section><h2><a class="nav-anchor" id="Singletons-1" href="#Singletons-1">Singletons</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Singleton" href="#LazySets.Singleton"><code>LazySets.Singleton</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Singleton{N&lt;:Real} &lt;: AbstractSingleton{N}</code></pre><p>Type that represents a singleton, that is, a set with a unique element.</p><p><strong>Fields</strong></p><ul><li><p><code>element</code> – the only element of the set</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Singleton.jl#L3-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.Singleton}" href="#LazySets.dim-Tuple{LazySets.Singleton}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(P::AbstractPointSymmetricPolytope)::Int</code></pre><p>Return the ambient dimension of a point symmetric set.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – set</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPointSymmetricPolytope.jl#L40-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Singleton{Float64}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Singleton{Float64}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, B::AbstractHyperrectangle{N}
 )::AbstractVector{N} where {N&lt;:Real}</code></pre><p>Return the support vector of a box-shaped set in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>B</code> – box-shaped set</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the vertex with biggest values is returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L64-L79">source</a><div><pre><code class="language-none">σ(d::AbstractVector{N}, S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the support vector of a set with a single value.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p>The support vector, which is the set&#39;s vector itself, irrespective of the given direction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L117-L131">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.Singleton{Float64}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.Singleton{Float64}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, B::AbstractHyperrectangle{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a box-shaped set.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>B</code> – box-shaped set</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ B$</span>.</p><p><strong>Algorithm</strong></p><p>Let <span>$B$</span> be an <span>$n$</span>-dimensional box-shaped set, <span>$c_i$</span> and <span>$r_i$</span> be the box&#39;s center and radius and <span>$x_i$</span> be the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ B$</span> iff <span>$|c_i - x_i| ≤ r_i$</span> for all <span>$i=1,…,n$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L133-L153">source</a><div><pre><code class="language-none">∈(x::AbstractVector{N}, S::AbstractSingleton{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a set with a single value.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ S$</span>.</p><p><strong>Notes</strong></p><p>This implementation performs an exact comparison, which may be insufficient with floating point computations.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L156-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.Singleton,LazySets.AbstractSingleton}" href="#Base.:⊆-Tuple{LazySets.Singleton,LazySets.AbstractSingleton}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, S::LazySet, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ S$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq S$</span> and <span>$v ∈ P \setminus S$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L33-L57">source</a><div><pre><code class="language-none">⊆(S::LazySet, H::AbstractHyperrectangle{N}, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set is contained in a hyperrectangle, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – inner convex set</p></li><li><p><code>H</code> – outer hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ H$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S ⊆ H$</span></p></li><li><p><code>(false, v)</code> iff <span>$S \not\subseteq H$</span> and <span>$v ∈ S \setminus H$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ⊆ H$</span> iff <span>$\operatorname{ihull}(S) ⊆ H$</span>, where  <span>$\operatorname{ihull}$</span> is the interval hull operator.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L165-L189">source</a><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, H::AbstractHyperrectangle, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a hyperrectangle, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>H</code> – outer hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ H$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ H$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq H$</span> and <span>$v ∈ P \setminus H$</span></p></li></ul></li></ul><p><strong>Notes</strong></p><p>This copy-pasted method just exists to avoid method ambiguities.</p><p><strong>Algorithm</strong></p><p>Since <span>$H$</span> is convex, <span>$P ⊆ H$</span> iff <span>$v_i ∈ H$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L195-L223">source</a><div><pre><code class="language-none">⊆(S::AbstractSingleton{N}, set::LazySet, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a given set with a single value is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code>   – inner set with a single value</p></li><li><p><code>set</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ \text{set}$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S ⊆ \text{set}$</span></p></li><li><p><code>(false, v)</code> iff <span>$S \not\subseteq \text{set}$</span> and <span>$v ∈ S \setminus \text{set}$</span></p></li></ul></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L180-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.Singleton,LazySets.LazySet}" href="#Base.:⊆-Tuple{LazySets.Singleton,LazySets.LazySet}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, S::LazySet, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ S$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq S$</span> and <span>$v ∈ P \setminus S$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L33-L57">source</a><div><pre><code class="language-none">⊆(S::AbstractSingleton{N}, set::LazySet, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a given set with a single value is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code>   – inner set with a single value</p></li><li><p><code>set</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ \text{set}$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S ⊆ \text{set}$</span></p></li><li><p><code>(false, v)</code> iff <span>$S \not\subseteq \text{set}$</span> and <span>$v ∈ S \setminus \text{set}$</span></p></li></ul></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L180-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Tuple{LazySets.Singleton{Float64},LazySets.LazySet,Bool}" href="#LazySets.is_intersection_empty-Tuple{LazySets.Singleton{Float64},LazySets.LazySet,Bool}"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_intersection_empty(S::AbstractSingleton{N},
                      set::LazySet,
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a singleton and a convex set intersect, and if so, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code>   – singleton</p></li><li><p><code>set</code> – convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ∩ \operatorname{set} ≠ ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, v)</code> iff <span>$S ∩ \operatorname{set} ≠ ∅$</span> and <code>v</code> = <code>element(S)</code></p></li><li><p><code>(false, [])</code> iff <span>$S ∩ \operatorname{set} = ∅$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ∩ \operatorname{set} ≠ ∅$</span> iff <code>element(S)</code> <span>$∈ \operatorname{set}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L244-L269">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Tuple{LazySets.LazySet,LazySets.Singleton{Float64},Bool}" href="#LazySets.is_intersection_empty-Tuple{LazySets.LazySet,LazySets.Singleton{Float64},Bool}"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_intersection_empty(set::LazySet,
                      S::AbstractSingleton{N},
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set and a singleton intersect, and if so, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>set</code> – convex set</p></li><li><p><code>S</code>   – singleton</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ∩ \operatorname{set} ≠ ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, v)</code> iff <span>$S ∩ \operatorname{set} ≠ ∅$</span> and <code>v</code> = <code>element(S)</code></p></li><li><p><code>(false, [])</code> iff <span>$S ∩ \operatorname{set} = ∅$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ∩ \operatorname{set} ≠ ∅$</span> iff <code>element(S)</code> <span>$∈ \operatorname{set}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L282-L307">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Tuple{LazySets.Singleton{Float64},LazySets.Singleton{Float64},Bool}" href="#LazySets.is_intersection_empty-Tuple{LazySets.Singleton{Float64},LazySets.Singleton{Float64},Bool}"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_intersection_empty(H1::AbstractHyperrectangle{N},
                      H2::AbstractHyperrectangle{N},
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether two hyperrectangles intersect, and if so, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>H1</code> – first hyperrectangle</p></li><li><p><code>H2</code> – second hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$H1 ∩ H2 ≠ ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, v)</code> iff <span>$H1 ∩ H2 ≠ ∅$</span> and <span>$v ∈ H1 ∩ H2$</span></p></li><li><p><code>(false, [])</code> iff <span>$H1 ∩ H2 = ∅$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$H1 ∩ H2 ≠ ∅$</span> iff <span>$|c_2 - c_1| ≤ r_1 + r_2$</span>, where <span>$≤$</span> is taken component-wise.</p><p>A witness is computed by starting in one center and moving toward the other center for as long as the minimum of the radius and the center distance. In other words, the witness is the point in <code>H1</code> that is closest to the center of <code>H2</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L303-L334">source</a><div><pre><code class="language-none">is_intersection_empty(S::AbstractSingleton{N},
                      set::LazySet,
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a singleton and a convex set intersect, and if so, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code>   – singleton</p></li><li><p><code>set</code> – convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ∩ \operatorname{set} ≠ ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, v)</code> iff <span>$S ∩ \operatorname{set} ≠ ∅$</span> and <code>v</code> = <code>element(S)</code></p></li><li><p><code>(false, [])</code> iff <span>$S ∩ \operatorname{set} = ∅$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ∩ \operatorname{set} ≠ ∅$</span> iff <code>element(S)</code> <span>$∈ \operatorname{set}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L244-L269">source</a><div><pre><code class="language-none">is_intersection_empty(set::LazySet,
                      S::AbstractSingleton{N},
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set and a singleton intersect, and if so, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>set</code> – convex set</p></li><li><p><code>S</code>   – singleton</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ∩ \operatorname{set} ≠ ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, v)</code> iff <span>$S ∩ \operatorname{set} ≠ ∅$</span> and <code>v</code> = <code>element(S)</code></p></li><li><p><code>(false, [])</code> iff <span>$S ∩ \operatorname{set} = ∅$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ∩ \operatorname{set} ≠ ∅$</span> iff <code>element(S)</code> <span>$∈ \operatorname{set}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L282-L307">source</a><div><pre><code class="language-none">is_intersection_empty(S1::AbstractSingleton{N},
                      S2::AbstractSingleton{N},
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether two singletons intersect, and if so, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S1</code> – first singleton</p></li><li><p><code>S2</code> – second singleton</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S1 ∩ S2 ≠ ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, v)</code> iff <span>$S1 ∩ S2 ≠ ∅$</span> and <code>v</code> = <code>element(S1)</code></p></li><li><p><code>(false, [])</code> iff <span>$S1 ∩ S2 = ∅$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S1 ∩ S2 ≠ ∅$</span> iff <span>$S1 = S2$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L320-L344">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.norm" href="#Base.LinAlg.norm"><code>Base.LinAlg.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">norm(B::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the norm of a box-shaped set.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – box-shaped set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p><p><strong>Notes</strong></p><p>The norm of a box-shaped set is defined as the norm of the enclosing ball, of the given <span>$p$</span>-norm, of minimal volume.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L85-L103">source</a><div><pre><code class="language-none">norm(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the norm of a convex set. It is the norm of the enclosing ball (of the given norm) of minimal volume.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Approximations/box_approximations.jl#L156-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.diameter" href="#LazySets.diameter"><code>LazySets.diameter</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diameter(B::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the diameter of a box-shaped set.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – box-shaped set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p><p><strong>Notes</strong></p><p>The diameter is defined as the maximum distance in the given <span>$p$</span>-norm between any two elements of the set. Equivalently, it is the diameter of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L108-L128">source</a><div><pre><code class="language-none">diameter(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the diameter of a convex set. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Approximations/box_approximations.jl#L203-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.Singleton{Float64}}" href="#LazySets.vertices_list-Tuple{LazySets.Singleton{Float64}}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(B::AbstractHyperrectangle{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a box-shaped set.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – box-shaped set</p></li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Notes</strong></p><p>For high dimensions, it is preferable to develop a <code>vertex_iterator</code> approach.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L37-L53">source</a><div><pre><code class="language-none">vertices_list(S::AbstractSingleton{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a set with a single value.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p>A list containing only a single vertex.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L95-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.singleton_list-Tuple{LazySets.Singleton{Float64}}" href="#LazySets.singleton_list-Tuple{LazySets.Singleton{Float64}}"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">singleton_list(P::AbstractPolytope{N})::Vector{Singleton{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a polytopic as a list of singletons.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – a polytopic set</p></li></ul><p><strong>Output</strong></p><p>List containing a singleton for each vertex.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L82-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Tuple{LazySets.Singleton{Float64}}" href="#LazySets.center-Tuple{LazySets.Singleton{Float64}}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">center(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a set with a single value.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p>The only element of the set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L74-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Tuple{LazySets.Singleton{Float64}}" href="#LazySets.radius_hyperrectangle-Tuple{LazySets.Singleton{Float64}}"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius_hyperrectangle(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the box radius of a set with a single value in every dimension.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p>The zero vector.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L52-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Tuple{LazySets.Singleton{Float64},Int64}" href="#LazySets.radius_hyperrectangle-Tuple{LazySets.Singleton{Float64},Int64}"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius_hyperrectangle(S::AbstractSingleton{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the box radius of a set with a single value in a given dimension.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p>Zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L33-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{LazySets.Singleton{Float64}}" href="#LazySets.an_element-Tuple{LazySets.Singleton{Float64}}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(P::AbstractPointSymmetricPolytope{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a point symmetric polytope.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – point symmetric polytope</p></li></ul><p><strong>Output</strong></p><p>The center of the point symmetric polytope.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPointSymmetricPolytope.jl#L58-L70">source</a><div><pre><code class="language-none">an_element(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a set with a single value.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p>The only element in the set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L138-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.element-Tuple{LazySets.Singleton{Float64}}" href="#LazySets.element-Tuple{LazySets.Singleton{Float64}}"><code>LazySets.element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">element(S::Singleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the element of a singleton.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – singleton</p></li></ul><p><strong>Output</strong></p><p>The element of the singleton.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Singleton.jl#L20-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.element-Tuple{LazySets.Singleton{Float64},Int64}" href="#LazySets.element-Tuple{LazySets.Singleton{Float64},Int64}"><code>LazySets.element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">element(S::Singleton{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the i-th entry of the element of a singleton.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – singleton</p></li><li><p><code>i</code> – dimension</p></li></ul><p><strong>Output</strong></p><p>The i-th entry of the element of the singleton.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Singleton.jl#L37-L50">source</a></section><h3><a class="nav-anchor" id="ZeroSet-1" href="#ZeroSet-1">ZeroSet</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ZeroSet" href="#LazySets.ZeroSet"><code>LazySets.ZeroSet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ZeroSet{N&lt;:Real} &lt;: AbstractSingleton{N}</code></pre><p>Type that represents the zero set, i.e., the set that only contains the origin.</p><p><strong>Fields</strong></p><ul><li><p><code>dim</code> – the ambient dimension of this zero set</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/ZeroSet.jl#L5-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.ZeroSet}" href="#LazySets.dim-Tuple{LazySets.ZeroSet}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(Z::ZeroSet)::Int</code></pre><p>Return the ambient dimension of this zero set.</p><p><strong>Input</strong></p><ul><li><p><code>Z</code> – a zero set, i.e., a set that only contains the origin</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the zero set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/ZeroSet.jl#L63-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.ZeroSet}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.ZeroSet}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, Z::ZeroSet)::Vector{N} where {N&lt;:Real}</code></pre><p>Return the support vector of a zero set.</p><p><strong>Input</strong></p><ul><li><p><code>Z</code> – a zero set, i.e., a set that only contains the origin</p></li></ul><p><strong>Output</strong></p><p>The returned value is the origin since it is the only point that belongs to this set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/ZeroSet.jl#L80-L93">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.ZeroSet{Float64}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.ZeroSet{Float64}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, B::AbstractHyperrectangle{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a box-shaped set.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>B</code> – box-shaped set</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ B$</span>.</p><p><strong>Algorithm</strong></p><p>Let <span>$B$</span> be an <span>$n$</span>-dimensional box-shaped set, <span>$c_i$</span> and <span>$r_i$</span> be the box&#39;s center and radius and <span>$x_i$</span> be the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ B$</span> iff <span>$|c_i - x_i| ≤ r_i$</span> for all <span>$i=1,…,n$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L133-L153">source</a><div><pre><code class="language-none">∈(x::AbstractVector{N}, S::AbstractSingleton{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a set with a single value.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ S$</span>.</p><p><strong>Notes</strong></p><p>This implementation performs an exact comparison, which may be insufficient with floating point computations.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L156-L174">source</a><div><pre><code class="language-none">∈(x::AbstractVector{N}, Z::ZeroSet{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a zero set.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>Z</code> – zero set</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ Z$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Z = ZeroSet(2);

julia&gt; ∈([1.0, 0.0], Z)
false
julia&gt; ∈([0.0, 0.0], Z)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/ZeroSet.jl#L98-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.ZeroSet,LazySets.AbstractSingleton}" href="#Base.:⊆-Tuple{LazySets.ZeroSet,LazySets.AbstractSingleton}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, S::LazySet, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ S$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq S$</span> and <span>$v ∈ P \setminus S$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L33-L57">source</a><div><pre><code class="language-none">⊆(S::LazySet, H::AbstractHyperrectangle{N}, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set is contained in a hyperrectangle, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – inner convex set</p></li><li><p><code>H</code> – outer hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ H$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S ⊆ H$</span></p></li><li><p><code>(false, v)</code> iff <span>$S \not\subseteq H$</span> and <span>$v ∈ S \setminus H$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ⊆ H$</span> iff <span>$\operatorname{ihull}(S) ⊆ H$</span>, where  <span>$\operatorname{ihull}$</span> is the interval hull operator.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L165-L189">source</a><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, H::AbstractHyperrectangle, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a hyperrectangle, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>H</code> – outer hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ H$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ H$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq H$</span> and <span>$v ∈ P \setminus H$</span></p></li></ul></li></ul><p><strong>Notes</strong></p><p>This copy-pasted method just exists to avoid method ambiguities.</p><p><strong>Algorithm</strong></p><p>Since <span>$H$</span> is convex, <span>$P ⊆ H$</span> iff <span>$v_i ∈ H$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L195-L223">source</a><div><pre><code class="language-none">⊆(S::AbstractSingleton{N}, set::LazySet, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a given set with a single value is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code>   – inner set with a single value</p></li><li><p><code>set</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ \text{set}$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S ⊆ \text{set}$</span></p></li><li><p><code>(false, v)</code> iff <span>$S \not\subseteq \text{set}$</span> and <span>$v ∈ S \setminus \text{set}$</span></p></li></ul></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L180-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.ZeroSet,LazySets.LazySet}" href="#Base.:⊆-Tuple{LazySets.ZeroSet,LazySets.LazySet}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, S::LazySet, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ S$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq S$</span> and <span>$v ∈ P \setminus S$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L33-L57">source</a><div><pre><code class="language-none">⊆(S::AbstractSingleton{N}, set::LazySet, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a given set with a single value is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code>   – inner set with a single value</p></li><li><p><code>set</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ \text{set}$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S ⊆ \text{set}$</span></p></li><li><p><code>(false, v)</code> iff <span>$S \not\subseteq \text{set}$</span> and <span>$v ∈ S \setminus \text{set}$</span></p></li></ul></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L180-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Tuple{LazySets.ZeroSet{Float64},LazySets.LazySet,Bool}" href="#LazySets.is_intersection_empty-Tuple{LazySets.ZeroSet{Float64},LazySets.LazySet,Bool}"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_intersection_empty(S::AbstractSingleton{N},
                      set::LazySet,
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a singleton and a convex set intersect, and if so, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code>   – singleton</p></li><li><p><code>set</code> – convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ∩ \operatorname{set} ≠ ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, v)</code> iff <span>$S ∩ \operatorname{set} ≠ ∅$</span> and <code>v</code> = <code>element(S)</code></p></li><li><p><code>(false, [])</code> iff <span>$S ∩ \operatorname{set} = ∅$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ∩ \operatorname{set} ≠ ∅$</span> iff <code>element(S)</code> <span>$∈ \operatorname{set}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L244-L269">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Tuple{LazySets.LazySet,LazySets.ZeroSet{Float64},Bool}" href="#LazySets.is_intersection_empty-Tuple{LazySets.LazySet,LazySets.ZeroSet{Float64},Bool}"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_intersection_empty(set::LazySet,
                      S::AbstractSingleton{N},
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set and a singleton intersect, and if so, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>set</code> – convex set</p></li><li><p><code>S</code>   – singleton</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ∩ \operatorname{set} ≠ ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, v)</code> iff <span>$S ∩ \operatorname{set} ≠ ∅$</span> and <code>v</code> = <code>element(S)</code></p></li><li><p><code>(false, [])</code> iff <span>$S ∩ \operatorname{set} = ∅$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ∩ \operatorname{set} ≠ ∅$</span> iff <code>element(S)</code> <span>$∈ \operatorname{set}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L282-L307">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Tuple{LazySets.ZeroSet{Float64},LazySets.ZeroSet{Float64},Bool}" href="#LazySets.is_intersection_empty-Tuple{LazySets.ZeroSet{Float64},LazySets.ZeroSet{Float64},Bool}"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_intersection_empty(H1::AbstractHyperrectangle{N},
                      H2::AbstractHyperrectangle{N},
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether two hyperrectangles intersect, and if so, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>H1</code> – first hyperrectangle</p></li><li><p><code>H2</code> – second hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$H1 ∩ H2 ≠ ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, v)</code> iff <span>$H1 ∩ H2 ≠ ∅$</span> and <span>$v ∈ H1 ∩ H2$</span></p></li><li><p><code>(false, [])</code> iff <span>$H1 ∩ H2 = ∅$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$H1 ∩ H2 ≠ ∅$</span> iff <span>$|c_2 - c_1| ≤ r_1 + r_2$</span>, where <span>$≤$</span> is taken component-wise.</p><p>A witness is computed by starting in one center and moving toward the other center for as long as the minimum of the radius and the center distance. In other words, the witness is the point in <code>H1</code> that is closest to the center of <code>H2</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L303-L334">source</a><div><pre><code class="language-none">is_intersection_empty(S::AbstractSingleton{N},
                      set::LazySet,
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a singleton and a convex set intersect, and if so, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code>   – singleton</p></li><li><p><code>set</code> – convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ∩ \operatorname{set} ≠ ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, v)</code> iff <span>$S ∩ \operatorname{set} ≠ ∅$</span> and <code>v</code> = <code>element(S)</code></p></li><li><p><code>(false, [])</code> iff <span>$S ∩ \operatorname{set} = ∅$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ∩ \operatorname{set} ≠ ∅$</span> iff <code>element(S)</code> <span>$∈ \operatorname{set}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L244-L269">source</a><div><pre><code class="language-none">is_intersection_empty(set::LazySet,
                      S::AbstractSingleton{N},
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set and a singleton intersect, and if so, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>set</code> – convex set</p></li><li><p><code>S</code>   – singleton</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ∩ \operatorname{set} ≠ ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, v)</code> iff <span>$S ∩ \operatorname{set} ≠ ∅$</span> and <code>v</code> = <code>element(S)</code></p></li><li><p><code>(false, [])</code> iff <span>$S ∩ \operatorname{set} = ∅$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ∩ \operatorname{set} ≠ ∅$</span> iff <code>element(S)</code> <span>$∈ \operatorname{set}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L282-L307">source</a><div><pre><code class="language-none">is_intersection_empty(S1::AbstractSingleton{N},
                      S2::AbstractSingleton{N},
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether two singletons intersect, and if so, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S1</code> – first singleton</p></li><li><p><code>S2</code> – second singleton</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S1 ∩ S2 ≠ ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, v)</code> iff <span>$S1 ∩ S2 ≠ ∅$</span> and <code>v</code> = <code>element(S1)</code></p></li><li><p><code>(false, [])</code> iff <span>$S1 ∩ S2 = ∅$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S1 ∩ S2 ≠ ∅$</span> iff <span>$S1 = S2$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L320-L344">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.norm" href="#Base.LinAlg.norm"><code>Base.LinAlg.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">norm(B::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the norm of a box-shaped set.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – box-shaped set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p><p><strong>Notes</strong></p><p>The norm of a box-shaped set is defined as the norm of the enclosing ball, of the given <span>$p$</span>-norm, of minimal volume.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L85-L103">source</a><div><pre><code class="language-none">norm(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the norm of a convex set. It is the norm of the enclosing ball (of the given norm) of minimal volume.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Approximations/box_approximations.jl#L156-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.diameter" href="#LazySets.diameter"><code>LazySets.diameter</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diameter(B::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the diameter of a box-shaped set.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – box-shaped set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p><p><strong>Notes</strong></p><p>The diameter is defined as the maximum distance in the given <span>$p$</span>-norm between any two elements of the set. Equivalently, it is the diameter of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L108-L128">source</a><div><pre><code class="language-none">diameter(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the diameter of a convex set. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Approximations/box_approximations.jl#L203-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.ZeroSet{Float64}}" href="#LazySets.vertices_list-Tuple{LazySets.ZeroSet{Float64}}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(B::AbstractHyperrectangle{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a box-shaped set.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – box-shaped set</p></li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Notes</strong></p><p>For high dimensions, it is preferable to develop a <code>vertex_iterator</code> approach.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractHyperrectangle.jl#L37-L53">source</a><div><pre><code class="language-none">vertices_list(S::AbstractSingleton{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a set with a single value.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p>A list containing only a single vertex.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L95-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.singleton_list-Tuple{LazySets.ZeroSet{Float64}}" href="#LazySets.singleton_list-Tuple{LazySets.ZeroSet{Float64}}"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">singleton_list(P::AbstractPolytope{N})::Vector{Singleton{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a polytopic as a list of singletons.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – a polytopic set</p></li></ul><p><strong>Output</strong></p><p>List containing a singleton for each vertex.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L82-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Tuple{LazySets.ZeroSet{Float64}}" href="#LazySets.center-Tuple{LazySets.ZeroSet{Float64}}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">center(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a set with a single value.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p>The only element of the set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L74-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Tuple{LazySets.ZeroSet{Float64}}" href="#LazySets.radius_hyperrectangle-Tuple{LazySets.ZeroSet{Float64}}"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius_hyperrectangle(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the box radius of a set with a single value in every dimension.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p>The zero vector.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L52-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Tuple{LazySets.ZeroSet{Float64},Int64}" href="#LazySets.radius_hyperrectangle-Tuple{LazySets.ZeroSet{Float64},Int64}"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius_hyperrectangle(S::AbstractSingleton{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the box radius of a set with a single value in a given dimension.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p>Zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L33-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{LazySets.ZeroSet{Float64}}" href="#LazySets.an_element-Tuple{LazySets.ZeroSet{Float64}}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(P::AbstractPointSymmetricPolytope{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a point symmetric polytope.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – point symmetric polytope</p></li></ul><p><strong>Output</strong></p><p>The center of the point symmetric polytope.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPointSymmetricPolytope.jl#L58-L70">source</a><div><pre><code class="language-none">an_element(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a set with a single value.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p>The only element in the set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractSingleton.jl#L138-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.element-Tuple{LazySets.ZeroSet{Float64}}" href="#LazySets.element-Tuple{LazySets.ZeroSet{Float64}}"><code>LazySets.element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">element(S::ZeroSet{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the element of a zero set.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – zero set</p></li></ul><p><strong>Output</strong></p><p>The element of the zero set, i.e., a zero vector.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/ZeroSet.jl#L24-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.element-Tuple{LazySets.ZeroSet{Float64},Int64}" href="#LazySets.element-Tuple{LazySets.ZeroSet{Float64},Int64}"><code>LazySets.element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">element(S::ZeroSet{N}, ::Int)::N where {N&lt;:Real}</code></pre><p>Return the i-th entry of the element of a zero set.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – zero set</p></li><li><p><code>i</code> – dimension</p></li></ul><p><strong>Output</strong></p><p>The i-th entry of the element of the zero set, i.e., 0.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/ZeroSet.jl#L41-L54">source</a></section><h2><a class="nav-anchor" id="Zonotopes-1" href="#Zonotopes-1">Zonotopes</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Zonotope" href="#LazySets.Zonotope"><code>LazySets.Zonotope</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Zonotope{N&lt;:Real} &lt;: AbstractPointSymmetricPolytope{N}</code></pre><p>Type that represents a zonotope.</p><p><strong>Fields</strong></p><ul><li><p><code>center</code>     – center of the zonotope</p></li><li><p><code>generators</code> – matrix; each column is a generator of the zonotope</p></li></ul><p><strong>Notes</strong></p><p>Mathematically, a zonotope is defined as the set</p><div>\[Z = \left\{ c + ∑_{i=1}^p ξ_i g_i,~~ ξ_i \in [-1, 1]~~ ∀ i = 1,…, p \right\},\]</div><p>where <span>$c \in \mathbb{R}^n$</span> is its <em>center</em> and <span>$\{g_i\}_{i=1}^p$</span>, <span>$g_i \in \mathbb{R}^n$</span>, is the set of <em>generators</em>. This characterization defines a zonotope as the finite Minkowski sum of line elements. Zonotopes can be equivalently described as the image of a unit infinity-norm ball in <span>$\mathbb{R}^n$</span> by an affine transformation.</p><ul><li><p><code>Zonotope(center::AbstractVector{N},           generators::AbstractMatrix{N}) where {N&lt;:Real}</code></p></li><li><p><code>Zonotope(center::AbstractVector{N},           generators_list::AbstractVector{T}          ) where {N&lt;:Real, T&lt;:AbstractVector{N}}</code></p></li></ul><p><strong>Examples</strong></p><p>A two-dimensional zonotope with given center and set of generators:</p><pre><code class="language-julia-repl">julia&gt; Z = Zonotope([1.0, 0.0], 0.1*eye(2))
LazySets.Zonotope{Float64}([1.0, 0.0], [0.1 0.0; 0.0 0.1])
julia&gt; dim(Z)
2</code></pre><p>Compute its vertices:</p><pre><code class="language-julia-repl">julia&gt; vertices_list(Z)
4-element Array{Array{Float64,1},1}:
 [0.9, -0.1]
 [1.1, -0.1]
 [1.1, 0.1]
 [0.9, 0.1]</code></pre><p>Evaluate the support vector in a given direction:</p><pre><code class="language-julia-repl">julia&gt; σ([1., 1.], Z)
2-element Array{Float64,1}:
 1.1
 0.1</code></pre><p>Alternative constructor: A zonotope in two dimensions with three generators:</p><pre><code class="language-julia-repl">julia&gt; Z = Zonotope(ones(2), [[1., 0.], [0., 1.], [1., 1.]])
LazySets.Zonotope{Float64}([1.0, 1.0], [1.0 0.0 1.0; 0.0 1.0 1.0])
julia&gt; Z.generators
2×3 Array{Float64,2}:
 1.0  0.0  1.0
 0.0  1.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Zonotope.jl#L6-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.Zonotope}" href="#LazySets.dim-Tuple{LazySets.Zonotope}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(P::AbstractPointSymmetricPolytope)::Int</code></pre><p>Return the ambient dimension of a point symmetric set.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – set</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPointSymmetricPolytope.jl#L40-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Zonotope}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Zonotope}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, Z::Zonotope)::AbstractVector{&lt;:Real}</code></pre><p>Return the support vector of a zonotope in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>Z</code> – zonotope</p></li></ul><p><strong>Output</strong></p><p>Support vector in the given direction. If the direction has norm zero, the vertex with <span>$ξ_i = 1 \ \ ∀ i = 1,…, p$</span> is returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Zonotope.jl#L149-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.Zonotope{Float64}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.Zonotope{Float64}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, Z::Zonotope{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a zonotope.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>Z</code> – zonotope</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ Z$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation poses the problem as a linear equality system and solves it using <code>Base.:</code>. A zonotope centered in the origin with generators <span>$g_i$</span> contains a point <span>$x$</span> iff <span>$x = ∑_{i=1}^p ξ_i g_i$</span> for some <span>$ξ_i \in [-1, 1]~~ ∀ i = 1,…, p$</span>. Thus, we first ask for a solution and then check if it is in this Cartesian product of intervals.</p><p>Other algorithms exist which test the feasibility of an LP.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Z = Zonotope([1.0, 0.0], 0.1*eye(2));

julia&gt; ∈([1.0, 0.2], Z)
false
julia&gt; ∈([1.0, 0.1], Z)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Zonotope.jl#L169-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{LazySets.Zonotope{Float64}}" href="#LazySets.an_element-Tuple{LazySets.Zonotope{Float64}}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(P::AbstractPointSymmetricPolytope{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a point symmetric polytope.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – point symmetric polytope</p></li></ul><p><strong>Output</strong></p><p>The center of the point symmetric polytope.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPointSymmetricPolytope.jl#L58-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.Zonotope,LazySets.LazySet}" href="#Base.:⊆-Tuple{LazySets.Zonotope,LazySets.LazySet}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, S::LazySet, witness::Bool=false
 )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ S$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq S$</span> and <span>$v ∈ P \setminus S$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L33-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Tuple{LazySets.Zonotope{Float64}}" href="#LazySets.center-Tuple{LazySets.Zonotope{Float64}}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">center(Z::Zonotope{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a zonotope.</p><p><strong>Input</strong></p><ul><li><p><code>Z</code> – zonotope</p></li></ul><p><strong>Output</strong></p><p>The center of the zonotope.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Zonotope.jl#L92-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.Zonotope{Float64}}" href="#LazySets.vertices_list-Tuple{LazySets.Zonotope{Float64}}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(Z::Zonotope{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a zonotope.</p><p><strong>Input</strong></p><ul><li><p><code>Z</code> – zonotope</p></li></ul><p><strong>Output</strong></p><p>List of vertices.</p><p><strong>Notes</strong></p><p>This implementation computes a convex hull.</p><p>For high dimensions, it would be preferable to develop a <code>vertex_iterator</code> approach.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Zonotope.jl#L113-L132">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.singleton_list-Tuple{LazySets.Zonotope{Float64}}" href="#LazySets.singleton_list-Tuple{LazySets.Zonotope{Float64}}"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">singleton_list(P::AbstractPolytope{N})::Vector{Singleton{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a polytopic as a list of singletons.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – a polytopic set</p></li></ul><p><strong>Output</strong></p><p>List containing a singleton for each vertex.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/AbstractPolytope.jl#L82-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.order-Tuple{LazySets.Zonotope}" href="#LazySets.order-Tuple{LazySets.Zonotope}"><code>LazySets.order</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">order(Z::Zonotope)::Rational</code></pre><p>Return the order of a zonotope.</p><p><strong>Input</strong></p><ul><li><p><code>Z</code> – zonotope</p></li></ul><p><strong>Output</strong></p><p>A rational number representing the order of the zonotope.</p><p><strong>Notes</strong></p><p>The order of a zonotope is defined as the quotient of its number of generators and its dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a39656050c48303cc3f7dd227d2075ccdb7ea008/src/Zonotope.jl#L237-L254">source</a></section><footer><hr/><a class="previous" href="interfaces.html"><span class="direction">Previous</span><span class="title">Set Interfaces</span></a><a class="next" href="operations.html"><span class="direction">Next</span><span class="title">Common Set Operations</span></a></footer></article></body></html>
