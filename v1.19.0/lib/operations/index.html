<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Common Set Operations · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/getting_started/">Getting Started</a></li><li><a class="toctext" href="../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="toctext" href="../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="toctext" href="../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="toctext" href="../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="toctext" href="../../man/interval_hulls/">Interval Hulls</a></li><li><a class="toctext" href="../../man/convex_hulls/">Convex Hulls</a></li><li><a class="toctext" href="../../man/set_operations/">Operations on Sets</a></li><li><a class="toctext" href="../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="toctext" href="../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="toctext" href="../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="toctext" href="../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../interfaces/">Set Interfaces</a></li><li><a class="toctext" href="../representations/">Common Set Representations</a></li><li class="current"><a class="toctext" href>Common Set Operations</a><ul class="internal"><li><a class="toctext" href="#Cartesian-Product-1">Cartesian Product</a></li><li><a class="toctext" href="#Convex-Hull-1">Convex Hull</a></li><li><a class="toctext" href="#Intersection-1">Intersection</a></li><li><a class="toctext" href="#Minkowski-Sum-1">Minkowski Sum</a></li><li><a class="toctext" href="#Maps-1">Maps</a></li><li><a class="toctext" href="#Symmetric-Interval-Hull-1">Symmetric Interval Hull</a></li><li><a class="toctext" href="#Union-1">Union</a></li><li><a class="toctext" href="#Complement-1">Complement</a></li><li><a class="toctext" href="#Rectification-1">Rectification</a></li></ul></li><li><a class="toctext" href="../comparisons/">Comparisons</a></li><li><a class="toctext" href="../conversion/">Conversions between set representations</a></li><li><a class="toctext" href="../binary_functions/">Binary Functions on Sets</a></li><li><a class="toctext" href="../approximations/">Approximations</a></li><li><a class="toctext" href="../utils/">Utility Functions</a></li><li><a class="toctext" href="../parallel/">Parallel</a></li></ul></li><li><a class="toctext" href="../../about/">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Common Set Operations</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/operations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Common Set Operations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Common-Set-Operations-1" href="#Common-Set-Operations-1">Common Set Operations</a></h1><p>This section of the manual describes the basic symbolic types describing operations between sets.</p><ul><li><a href="#Common-Set-Operations-1">Common Set Operations</a></li><ul><li><a href="#Cartesian-Product-1">Cartesian Product</a></li><ul><li><a href="#Binary-Cartesian-Product-1">Binary Cartesian Product</a></li><li><a href="#n-ary-Cartesian-Product-1"><span>$n$</span>-ary Cartesian Product</a></li></ul><li><a href="#Convex-Hull-1">Convex Hull</a></li><ul><li><a href="#Binary-Convex-Hull-1">Binary Convex Hull</a></li><li><a href="#n-ary-Convex-Hull-1"><span>$n$</span>-ary Convex Hull</a></li><li><a href="#Convex-Hull-Algorithms-1">Convex Hull Algorithms</a></li></ul><li><a href="#Intersection-1">Intersection</a></li><ul><li><a href="#Binary-Intersection-1">Binary Intersection</a></li><li><a href="#n-ary-Intersection-1"><span>$n$</span>-ary Intersection</a></li></ul><li><a href="#Minkowski-Sum-1">Minkowski Sum</a></li><ul><li><a href="#Binary-Minkowski-Sum-1">Binary Minkowski Sum</a></li><li><a href="#n-ary-Minkowski-Sum-1"><span>$n$</span>-ary Minkowski Sum</a></li><li><a href="#n-ary-Minkowski-Sum-with-cache-1"><span>$n$</span>-ary Minkowski Sum with cache</a></li></ul><li><a href="#Maps-1">Maps</a></li><ul><li><a href="#Linear-Map-1">Linear Map</a></li><li><a href="#Exponential-Map-1">Exponential Map</a></li><li><a href="#Reset-Map-1">Reset Map</a></li><li><a href="#Translation-1">Translation</a></li><li><a href="#Affine-Map-1">Affine Map</a></li></ul><li><a href="#Symmetric-Interval-Hull-1">Symmetric Interval Hull</a></li><li><a href="#Union-1">Union</a></li><ul><li><a href="#Binary-Set-Union-1">Binary Set Union</a></li><li><a href="#n-ary-Set-Union-1"><span>$n$</span>-ary Set Union</a></li></ul><li><a href="#Complement-1">Complement</a></li><li><a href="#Rectification-1">Rectification</a></li></ul></ul><h2><a class="nav-anchor" id="Cartesian-Product-1" href="#Cartesian-Product-1">Cartesian Product</a></h2><h3><a class="nav-anchor" id="Binary-Cartesian-Product-1" href="#Binary-Cartesian-Product-1">Binary Cartesian Product</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CartesianProduct" href="#LazySets.CartesianProduct"><code>LazySets.CartesianProduct</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CartesianProduct{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents a Cartesian product of two convex sets.</p><p><strong>Fields</strong></p><ul><li><code>X</code> – first convex set</li><li><code>Y</code> – second convex set</li></ul><p><strong>Notes</strong></p><p>The Cartesian product of three elements is obtained recursively. See also <code>CartesianProductArray</code> for an implementation of a Cartesian product of many sets without recursion, instead using an array.</p><p>The <code>EmptySet</code> is the absorbing element for <code>CartesianProduct</code>.</p><p><strong>Examples</strong></p><p>The Cartesian product between two sets <code>X</code> and <code>Y</code> can be constructed either using <code>CartesianProduct(X, Y)</code> or the short-cut notation <code>X × Y</code>:</p><pre><code class="language-julia-repl">julia&gt; I1 = Interval(0, 1);

julia&gt; I2 = Interval(2, 4);

julia&gt; I12 = I1 × I2;

julia&gt; typeof(I12)
CartesianProduct{Float64,Interval{Float64,IntervalArithmetic.Interval{Float64}},Interval{Float64,IntervalArithmetic.Interval{Float64}}}</code></pre><p>A hyperrectangle is the cartesian product of intervals, so we can convert <code>I12</code> exactly to a <code>Hyperrectangle</code> type:</p><pre><code class="language-julia-repl">julia&gt; convert(Hyperrectangle, I12)
Hyperrectangle{Float64}([0.5, 3.0], [0.5, 1.0])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L10-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.:×-Tuple{LazySet,LazySet}" href="#LinearAlgebra.:×-Tuple{LazySet,LazySet}"><code>LinearAlgebra.:×</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">×</code></pre><p>Alias for the binary Cartesian product.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L68-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{LazySet,LazySet}" href="#Base.:*-Tuple{LazySet,LazySet}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">    *(X::LazySet, Y::LazySet)</code></pre><p>Alias for the binary Cartesian product.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L59-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.swap-Tuple{CartesianProduct}" href="#LazySets.swap-Tuple{CartesianProduct}"><code>LazySets.swap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">swap(cp::CartesianProduct)</code></pre><p>Return a new <code>CartesianProduct</code> object with the arguments swapped.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product of two convex sets</li></ul><p><strong>Output</strong></p><p>A new <code>CartesianProduct</code> object with the arguments swapped.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L75-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{CartesianProduct}" href="#LazySets.dim-Tuple{CartesianProduct}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(cp::CartesianProduct)::Int</code></pre><p>Return the dimension of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Cartesian product.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L92-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, cp::CartesianProduct{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>The support function in the given direction. If the direction has norm zero, the result depends on the wrapped sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L129-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, cp::CartesianProduct{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L109-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{CartesianProduct}" href="#LazySets.isbounded-Tuple{CartesianProduct}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(cp::CartesianProduct)::Bool</code></pre><p>Determine whether a Cartesian product is bounded.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff both wrapped sets are bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L149-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, cp::CartesianProduct{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>x</code>  – point/vector</li><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ cp$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L166-L179">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{CartesianProduct}" href="#Base.isempty-Tuple{CartesianProduct}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(cp::CartesianProduct)::Bool</code></pre><p>Return if a Cartesian product is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the sub-blocks is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L188-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(cp::CartesianProduct{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of a (polyhedral) Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>A list of constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L205-L217">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(cp::CartesianProduct{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a (polytopic) Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L222-L240">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, cp::CartesianProduct{N}) where {N&lt;:Real}</code></pre><p>Concrete linear map of a (polyhedral) Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>M</code>  – matrix</li><li><code>cp</code> – Cartesian product of two convex sets</li></ul><p><strong>Output</strong></p><p>A polytope.</p><p><strong>Algorithm</strong></p><p>We check if the matrix is invertible. If so, we convert the Cartesian product to constraint representation. Otherwise, we convert the Cartesian product to vertex representation. In both cases, we then call <code>linear_map</code> on the resulting polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L259-L279">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h3><a class="nav-anchor" id="n-ary-Cartesian-Product-1" href="#n-ary-Cartesian-Product-1"><span>$n$</span>-ary Cartesian Product</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CartesianProductArray" href="#LazySets.CartesianProductArray"><code>LazySets.CartesianProductArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CartesianProductArray{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the Cartesian product of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><code>array</code> – array of sets</li></ul><p><strong>Notes</strong></p><p>The <code>EmptySet</code> is the absorbing element for <code>CartesianProductArray</code>.</p><p>Constructors:</p><ul><li><p><code>CartesianProductArray(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>CartesianProductArray([n]::Int=0, [N]::Type=Float64)</code> – constructor for an empty product with optional size hint and numeric type</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L304-L323">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{CartesianProductArray}" href="#LazySets.dim-Tuple{CartesianProductArray}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(cpa::CartesianProductArray)::Int</code></pre><p>Return the dimension of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Cartesian product of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L360-L373">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, cp::CartesianProductArray{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a Cartesian product array.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The support function in the given direction. If the direction has norm zero, the result depends on the wrapped sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L404-L418">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, cpa::CartesianProductArray{N}) where {N&lt;:Real}</code></pre><p>Support vector of a Cartesian product array.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the product sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L378-L392">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{CartesianProductArray}" href="#LazySets.isbounded-Tuple{CartesianProductArray}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(cpa::CartesianProductArray)::Bool</code></pre><p>Determine whether a Cartesian product of a finite number of convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff all wrapped sets are bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L430-L443">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, cpa::CartesianProductArray{N}
 )::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>x</code>   – point/vector</li><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ \text{cpa}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L448-L463">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{CartesianProductArray}" href="#Base.isempty-Tuple{CartesianProductArray}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(cpa::CartesianProductArray)::Bool</code></pre><p>Return if a Cartesian product is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the sub-blocks is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L479-L491">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(cpa::CartesianProductArray{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of a (polyhedral) Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A list of constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L496-L509">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(cpa::CartesianProductArray{N}
             )::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a (polytopic) Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L532-L552">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, cpa::CartesianProductArray{N}
          ) where {N&lt;:Real}</code></pre><p>Concrete linear map of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>M</code>   – matrix</li><li><code>cpa</code> – Cartesian product of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>A polytope.</p><p><strong>Algorithm</strong></p><p>We check if the matrix is invertible. If so, we convert the Cartesian product to constraint representation. Otherwise, we convert the Cartesian product to vertex representation. In both cases, we then call <code>linear_map</code> on the resulting polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L773-L794">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.array-Union{Tuple{CartesianProductArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real" href="#LazySets.array-Union{Tuple{CartesianProductArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">array(cpa::CartesianProductArray{N, S}
     )::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The array of a Cartesian product of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L341-L354">source</a><div><div><pre><code class="language-none">array(cha::ConvexHullArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p>The array of a convex hull of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L238-L250">source</a><div><div><pre><code class="language-none">array(ia::IntersectionArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of an intersection of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array of an intersection of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L698-L710">source</a><div><div><pre><code class="language-none">array(msa::MinkowskiSumArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Minkowski sum of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The array of a Minkowski sum of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L260-L272">source</a><div><div><pre><code class="language-none">array(cms::CacheMinkowskiSum{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The array of a caching Minkowski sum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L460-L472">source</a><div><div><pre><code class="language-julia">array(cup::UnionSetArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array that holds the union of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L270-L282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.block_structure-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N" href="#LazySets.block_structure-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N"><code>LazySets.block_structure</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">block_structure(cpa::CartesianProductArray{N}) where {N}</code></pre><p>Returns an array containing the dimension ranges of each block in a <code>CartesianProductArray</code>.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A vector of ranges</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using LazySets: block_structure

julia&gt; cpa = CartesianProductArray([BallInf(zeros(n), 1.0) for n in [3, 1, 2]]);

julia&gt; block_structure(cpa)
3-element Array{UnitRange{Int64},1}:
 1:3
 4:4
 5:6</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L631-L657">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.block_to_dimension_indices-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N},Array{Int64,1}}} where N" href="#LazySets.block_to_dimension_indices-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N},Array{Int64,1}}} where N"><code>LazySets.block_to_dimension_indices</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">block_to_dimension_indices(cpa::CartesianProductArray{N}, vars::Vector{Int}) where {N}</code></pre><p>Returns a vector mapping block index <code>i</code> to tuple <code>(f, l)</code> such that either <code>f = l = -1</code> or <code>f</code> is the first dimension index and <code>l</code> is the last dimension index of the <code>i</code>-th block, depending on whether one of the block&#39;s dimension indices is specified in <code>vars</code>.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li><li><code>vars</code> – list containing the variables of interest, sorted in ascending order</li></ul><p><strong>Output</strong></p><p>(i) A vector of tuples, where values in tuple relate to range of dimensions in the i-th block. (ii) Number of constrained blocks</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using LazySets: block_to_dimension_indices

julia&gt; cpa = CartesianProductArray([BallInf(zeros(n), 1.0) for n in [1, 3, 2, 3]]);

julia&gt; block_to_dimension_indices(cpa, [2, 4, 8])
(Tuple{Int64,Int64}[(-1, -1), (2, 4), (-1, -1), (7, 9)], 2)</code></pre><p>This vector represents the mapping &quot;second block from dimension 2 to dimension 4, fourth block from dimension 7 to dimension 9.&quot; These blocks contain the dimensions specified in <code>[2, 4, 8]</code>. Number of constrained variables here is 2 (2nd and 4th blocks)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L670-L701">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.substitute_blocks-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N},CartesianProductArray{N,S} where S&lt;:LazySet{N},Array{Tuple{Int64,Int64},1}}} where N" href="#LazySets.substitute_blocks-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N},CartesianProductArray{N,S} where S&lt;:LazySet{N},Array{Tuple{Int64,Int64},1}}} where N"><code>LazySets.substitute_blocks</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">substitute_blocks(low_dim_cpa::CartesianProductArray{N},
                     orig_cpa::CartesianProductArray{N},
                       blocks::Vector{Tuple{Int,Int}}) where {N}</code></pre><p>Return merged Cartesian Product Array between original CPA and some low-dimensional CPA, which represents updated subset of variables in specified blocks.</p><p><strong>Input</strong></p><ul><li><code>low_dim_cpa</code> – low-dimensional cartesian product array</li><li><code>orig_cpa</code> – original high-dimensional Cartesian product array</li><li><code>blocks</code> – index of the first variable in each block of <code>orig_cpa</code></li></ul><p><strong>Output</strong></p><p>Merged cartesian product array</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L737-L754">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h2><a class="nav-anchor" id="Convex-Hull-1" href="#Convex-Hull-1">Convex Hull</a></h2><h3><a class="nav-anchor" id="Binary-Convex-Hull-1" href="#Binary-Convex-Hull-1">Binary Convex Hull</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ConvexHull" href="#LazySets.ConvexHull"><code>LazySets.ConvexHull</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ConvexHull{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the convex hull of the union of two convex sets.</p><p><strong>Fields</strong></p><ul><li><code>X</code> – convex set</li><li><code>Y</code> – convex set</li></ul><p><strong>Notes</strong></p><p>The <code>EmptySet</code> is the neutral element for <code>ConvexHull</code>.</p><p><strong>Examples</strong></p><p>Convex hull of two 100-dimensional Euclidean balls:</p><pre><code class="language-julia-repl">julia&gt; b1, b2 = Ball2(zeros(100), 0.1), Ball2(4*ones(100), 0.2);

julia&gt; c = ConvexHull(b1, b2);

julia&gt; typeof(c)
ConvexHull{Float64,Ball2{Float64},Ball2{Float64}}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L11-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CH" href="#LazySets.CH"><code>LazySets.CH</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CH</code></pre><p>Alias for <code>ConvexHull</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L61-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.swap-Tuple{ConvexHull}" href="#LazySets.swap-Tuple{ConvexHull}"><code>LazySets.swap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">swap(ch::ConvexHull)</code></pre><p>Return a new <code>ConvexHull</code> object with the arguments swapped.</p><p><strong>Input</strong></p><ul><li><code>ch</code> – convex hull of two convex sets</li></ul><p><strong>Output</strong></p><p>A new <code>ConvexHull</code> object with the arguments swapped.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L68-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{ConvexHull}" href="#LazySets.dim-Tuple{ConvexHull}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(ch::ConvexHull)::Int</code></pre><p>Return the dimension of a convex hull of two convex sets.</p><p><strong>Input</strong></p><ul><li><code>ch</code> – convex hull of two convex sets</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the convex hull of two convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L85-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHull{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHull{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, ch::ConvexHull{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a convex hull of two convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>ch</code> – convex hull of two convex sets</li></ul><p><strong>Output</strong></p><p>The support function of the convex hull in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L125-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHull{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHull{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, ch::ConvexHull{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a convex hull of two convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>ch</code> – convex hull of two convex sets</li></ul><p><strong>Output</strong></p><p>The support vector of the convex hull in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L102-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{ConvexHull}" href="#LazySets.isbounded-Tuple{ConvexHull}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(ch::ConvexHull)::Bool</code></pre><p>Determine whether a convex hull of two convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>ch</code> – convex hull of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff both wrapped sets are bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L144-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{ConvexHull}" href="#Base.isempty-Tuple{ConvexHull}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(ch::ConvexHull)::Bool</code></pre><p>Return if a convex hull of two convex sets is empty or not.</p><p><strong>Input</strong></p><ul><li><code>ch</code> – convex hull</li></ul><p><strong>Output</strong></p><p><code>true</code> iff both wrapped sets are empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L161-L173">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h3><a class="nav-anchor" id="n-ary-Convex-Hull-1" href="#n-ary-Convex-Hull-1"><span>$n$</span>-ary Convex Hull</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ConvexHullArray" href="#LazySets.ConvexHullArray"><code>LazySets.ConvexHullArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ConvexHullArray{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the symbolic convex hull of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><code>array</code> – array of sets</li></ul><p><strong>Notes</strong></p><p>The <code>EmptySet</code> is the neutral element for <code>ConvexHullArray</code>.</p><p>Constructors:</p><ul><li><p><code>ConvexHullArray(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>ConvexHullArray([n]::Int=0, [N]::Type=Float64)</code> – constructor for an empty hull with optional size hint and numeric type</p></li></ul><p><strong>Examples</strong></p><p>Convex hull of 100 two-dimensional balls whose centers follows a sinusoidal:</p><pre><code class="language-julia-repl">julia&gt; b = [Ball2([2*pi*i/100, sin(2*pi*i/100)], 0.05) for i in 1:100];

julia&gt; c = ConvexHullArray(b);</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L181-L210">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CHArray" href="#LazySets.CHArray"><code>LazySets.CHArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CHArray</code></pre><p>Alias for <code>ConvexHullArray</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L231-L235">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{ConvexHullArray}" href="#LazySets.dim-Tuple{ConvexHullArray}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(cha::ConvexHullArray)::Int</code></pre><p>Return the dimension of the convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the convex hull of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L255-L267">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHullArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHullArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, cha::ConvexHullArray{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a convex hull array in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p>The support function of the convex hull array in the given direction.</p><p><strong>Algorithm</strong></p><p>This algorihm calculates the maximum over all <span>$ρ(d, X_i)$</span> where the <span>$X_1, …, X_k$</span> are the sets in the array <code>cha</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L298-L316">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHullArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHullArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, cha::ConvexHullArray{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a convex hull array in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cha</code> – convex hull array</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L273-L282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{ConvexHullArray}" href="#LazySets.isbounded-Tuple{ConvexHullArray}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(cha::ConvexHullArray)::Bool</code></pre><p>Determine whether a convex hull of a finite number of convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff all wrapped sets are bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L321-L334">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.array-Union{Tuple{ConvexHullArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real" href="#LazySets.array-Union{Tuple{ConvexHullArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">array(cpa::CartesianProductArray{N, S}
     )::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The array of a Cartesian product of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L341-L354">source</a><div><div><pre><code class="language-none">array(cha::ConvexHullArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p>The array of a convex hull of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L238-L250">source</a><div><div><pre><code class="language-none">array(ia::IntersectionArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of an intersection of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array of an intersection of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L698-L710">source</a><div><div><pre><code class="language-none">array(msa::MinkowskiSumArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Minkowski sum of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The array of a Minkowski sum of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L260-L272">source</a><div><div><pre><code class="language-none">array(cms::CacheMinkowskiSum{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The array of a caching Minkowski sum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L460-L472">source</a><div><div><pre><code class="language-julia">array(cup::UnionSetArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array that holds the union of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L270-L282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{ConvexHullArray}" href="#Base.isempty-Tuple{ConvexHullArray}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(cha::ConvexHullArray)::Bool</code></pre><p>Return if a convex hull array is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p><code>true</code> iff all wrapped sets are empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L339-L351">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h3><a class="nav-anchor" id="Convex-Hull-Algorithms-1" href="#Convex-Hull-Algorithms-1">Convex Hull Algorithms</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.convex_hull-Union{Tuple{Array{VN,1}}, Tuple{VN}, Tuple{N}} where VN&lt;:AbstractArray{N,1} where N&lt;:Real" href="#LazySets.convex_hull-Union{Tuple{Array{VN,1}}, Tuple{VN}, Tuple{N}} where VN&lt;:AbstractArray{N,1} where N&lt;:Real"><code>LazySets.convex_hull</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convex_hull(points::Vector{VN};
            [algorithm]=nothing,
            [backend]=nothing,
            [solver]=nothing
            )::Vector{VN} where {N&lt;:Real, VN&lt;:AbstractVector{N}}</code></pre><p>Compute the convex hull of the given points.</p><p><strong>Input</strong></p><ul><li><code>points</code>    – list of vectors</li><li><code>algorithm</code> – (optional, default: <code>nothing</code>) the convex-hull algorithm; see                below for valid options</li><li><code>backend</code>   – (optional, default: <code>nothing</code>) polyhedral computation backend                for higher-dimensional point sets</li><li><code>solver</code>    – (optional, default: <code>nothing</code>) the linear-programming solver                used in the backend</li></ul><p><strong>Output</strong></p><p>The convex hull as a list of vectors with the coordinates of the points.</p><p><strong>Algorithm</strong></p><p>A pre-processing step treats the cases with up to two points for one dimension and up to four points for two dimensions. For more points in one resp. two dimensions, we use more general algorithms.</p><p>For the one-dimensional case we return the minimum and maximum points, in that order.</p><p>The two-dimensional case is handled with a planar convex hull algorithm. The following algorithms are available:</p><ul><li><code>&quot;monotone_chain&quot;</code>        – compute the convex hull of points in the plane                              using Andrew&#39;s monotone chain method</li><li><code>&quot;monotone_chain_sorted&quot;</code> – the same as <code>&quot;monotone_chain&quot;</code> but assuming that                              the points are already sorted in counter-clockwise                              fashion</li></ul><p>See the reference docstring of each of those algorithms for details.</p><p>The higher dimensional case is treated using the concrete polyhedra library <code>Polyhedra</code>, that gives access to libraries such as <code>CDDLib</code> and <code>ConvexHull.jl</code>. These libraries can be chosen from the <code>backend</code> argument.</p><p><strong>Notes</strong></p><p>For the in-place version use <code>convex_hull!</code> instead of <code>convex_hull</code>.</p><p><strong>Examples</strong></p><p>Compute the convex hull of a random set of points:</p><pre><code class="language-julia-repl">julia&gt; points = [randn(2) for i in 1:30]; # 30 random points in 2D

julia&gt; hull = convex_hull(points);

julia&gt; typeof(hull)
Array{Array{Float64,1},1}</code></pre><p>Plot both the random points and the computed convex hull polygon:</p><pre><code class="language-julia-repl">julia&gt; using Plots;

julia&gt; plot([Tuple(pi) for pi in points], seriestype=:scatter);

julia&gt; plot!(VPolygon(hull), alpha=0.2);</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/ConcreteOperations/convex_hull.jl#L70-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.monotone_chain!" href="#LazySets.monotone_chain!"><code>LazySets.monotone_chain!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">monotone_chain!(points::Vector{VN}; sort::Bool=true
               )::Vector{VN} where {N&lt;:Real, VN&lt;:AbstractVector{N}}</code></pre><p>Compute the convex hull of points in the plane using Andrew&#39;s monotone chain method.</p><p><strong>Input</strong></p><ul><li><code>points</code> – list of 2D vectors; is sorted in-place inside this function</li><li><code>sort</code>   – (optional, default: <code>true</code>) flag for sorting the vertices             lexicographically; sortedness is required for correctness</li></ul><p><strong>Output</strong></p><p>List of vectors containing the 2D coordinates of the corner points of the convex hull.</p><p><strong>Notes</strong></p><p>For large sets of points, it is convenient to use static vectors to get maximum performance. For information on how to convert usual vectors into static vectors, see the type <code>SVector</code> provided by the <a href="http://juliaarrays.github.io/StaticArrays.jl/stable/">StaticArrays</a> package.</p><p><strong>Algorithm</strong></p><p>This function implements Andrew&#39;s monotone chain convex hull algorithm to construct the convex hull of a set of <span>$n$</span> points in the plane in <span>$O(n \log n)$</span> time. For further details see <a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain">Monotone chain</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/ConcreteOperations/convex_hull.jl#L406-L439">source</a></section><h2><a class="nav-anchor" id="Intersection-1" href="#Intersection-1">Intersection</a></h2><h3><a class="nav-anchor" id="Binary-Intersection-1" href="#Binary-Intersection-1">Binary Intersection</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Intersection" href="#LazySets.Intersection"><code>LazySets.Intersection</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Intersection{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the intersection of two convex sets.</p><p><strong>Fields</strong></p><ul><li><code>X</code>     – convex set</li><li><code>Y</code>     – convex set</li><li><code>cache</code> – internal cache for avoiding recomputation; see            <a href="#LazySets.IntersectionCache"><code>IntersectionCache</code></a></li></ul><p><strong>Examples</strong></p><p>Create an expression, <span>$Z$</span>, which lazily represents the intersection of two squares <span>$X$</span> and <span>$Y$</span>:</p><pre><code class="language-julia-repl">julia&gt; X, Y = BallInf([0,0.], 0.5), BallInf([1,0.], 0.65);

julia&gt; Z = X ∩ Y;

julia&gt; typeof(Z)
Intersection{Float64,BallInf{Float64},BallInf{Float64}}

julia&gt; dim(Z)
2</code></pre><p>We can check if the intersection is empty with <code>isempty</code>:</p><pre><code class="language-julia-repl">julia&gt; isempty(Z)
false</code></pre><p>Do not confuse <code>Intersection</code> with the concrete operation, which is computed with the lowercase <code>intersection</code> function:</p><pre><code class="language-julia-repl">julia&gt; W = intersection(X, Y)
Hyperrectangle{Float64}([0.425, 0.0], [0.075, 0.5])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L48-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∩-Tuple{LazySet,LazySet}" href="#Base.:∩-Tuple{LazySet,LazySet}"><code>Base.:∩</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∩</code></pre><p>Alias for <code>Intersection</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L119-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{Intersection}" href="#LazySets.dim-Tuple{Intersection}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(cap::Intersection)::Int</code></pre><p>Return the dimension of an intersection of two convex sets.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the intersection of two convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L189-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, cap::Intersection{N}) where {N&lt;:Real}</code></pre><p>Return an upper bound on the support function of the intersection of two convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>    – direction</li><li><code>cap</code>  – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p>An uper bound on the support function in the given direction.</p><p><strong>Algorithm</strong></p><p>The support function of an intersection of <span>$X$</span> and <span>$Y$</span> is upper bounded by the minimum of the support functions of <span>$X$</span> and <span>$Y$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L225-L244">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2}}} where S2&lt;:Union{Hyperplane{N}, HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}, Line{N,VN} where VN&lt;:AbstractArray{N,1}} where S1&lt;:LazySet{N} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2}}} where S2&lt;:Union{Hyperplane{N}, HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}, Line{N,VN} where VN&lt;:AbstractArray{N,1}} where S1&lt;:LazySet{N} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N},
  cap::Intersection{N, S1, S2};
  [algorithm]::String=&quot;line_search&quot;,
  [kwargs...]) where {N&lt;:Real,
                      S1&lt;:LazySet{N},
                      S2&lt;:Union{HalfSpace{N}, Hyperplane{N}, Line{N}}}</code></pre><p>Return the support function of the intersection of a compact set and a half-space/hyperplane/line in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>         – direction</p></li><li><p><code>cap</code>       – lazy intersection of a compact set and a half-space/hyperplane/                line</p></li><li><p><code>algorithm</code> – (optional, default: <code>&quot;line_search&quot;</code>): the algorithm to                calculate the support function; valid options are:</p><ul><li><code>&quot;line_search&quot;</code> – solve the associated univariate optimization problem                    using a line search method (either Brent or the                    Golden Section method)</li><li><code>&quot;projection&quot;</code>  – only valid for intersection with a hyperplane;                    evaluates the support function by reducing the problem                    to the 2D intersection of a rank 2 linear                    transformation of the given compact set in the plane                    generated by the given direction <code>d</code> and the                    hyperplane&#39;s normal vector <code>n</code></li><li><code>&quot;simple&quot;</code>      – take the <span>$\min$</span> of the support function evaluation                    of each operand</li></ul></li></ul><p><strong>Output</strong></p><p>The scalar value of the support function of the set <code>cap</code> in the given direction.</p><p><strong>Notes</strong></p><p>It is assumed that the set <code>cap.X</code> is compact.</p><p>Any additional number of arguments to the algorithm backend can be passed as keyword arguments.</p><p><strong>Algorithm</strong></p><p>The algorithms are based on solving the associated optimization problem</p><div>\[\min_\{ λ ∈ D_h \} ρ(ℓ - λa, X) + λb.\]</div><p>where <span>$D_h = \{ λ : λ ≥ 0 \}$</span> if <span>$H$</span> is a half-space or <span>$D_h = \{ λ : λ ∈ \mathbb{R} \}$</span> if <span>$H$</span> is a hyperplane.</p><p>For additional information we refer to:</p><ul><li><a href="https://www.sciencedirect.com/science/article/pii/S1474667015371809">G. Frehse, R. Ray. Flowpipe-Guard Intersection for Reachability Computations with Support Functions</a>.</li><li><a href="https://tel.archives-ouvertes.fr/tel-00422569v2">C. Le Guernic. Reachability Analysis of Hybrid Systems with Linear Continuous Dynamics, PhD thesis</a>.</li><li><a href="https://www.springer.com/us/book/9783540627722">T. Rockafellar, R. Wets. Variational Analysis</a>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L308-L369">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2}}} where S2&lt;:AbstractPolyhedron{N} where S1&lt;:LazySet{N} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2}}} where S2&lt;:AbstractPolyhedron{N} where S1&lt;:LazySet{N} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, cap::Intersection{N, S1, S2}; kwargs...)
    where {N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:AbstractPolyhedron{N}}</code></pre><p>Return an upper bound on the support function of the intersection between a compact set and a polyhedron along a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>      – direction</li><li><code>cap</code>    – intersection of a compact set and a polyhedron</li><li><code>kwargs</code> – additional arguments that are passed to the support-function             algorithm</li></ul><p><strong>Output</strong></p><p>An upper bound of the support function of the given intersection.</p><p><strong>Algorithm</strong></p><p>The idea is to solve the univariate optimization problem <code>ρ(di, X ∩ Hi)</code> for each half-space in the set <code>P</code> and then take the minimum. This gives an overapproximation of the exact support function.</p><p>This algorithm is inspired from <a href="https://www.sciencedirect.com/science/article/pii/S1474667015371809">G. Frehse, R. Ray. Flowpipe-Guard Intersection for Reachability Computations with Support Functions</a>.</p><p><strong>Notes</strong></p><p>This method relies on the <code>constraints_list</code> of the polyhedron.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L389-L420">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2}}} where S2&lt;:AbstractPolyhedron{N} where S1&lt;:AbstractPolyhedron{N} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2}}} where S2&lt;:AbstractPolyhedron{N} where S1&lt;:AbstractPolyhedron{N} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, cap::Intersection{N, S1, S2}; kwargs...
 ) where {N&lt;:Real, S1&lt;:AbstractPolyhedron{N}, S2&lt;:AbstractPolyhedron{N}}</code></pre><p>Return an upper bound on the support function of the intersection between two polyhedral sets.</p><p><strong>Input</strong></p><ul><li><code>d</code>      – direction</li><li><code>cap</code>    – intersection of two polyhedral sets</li><li><code>kwargs</code> – additional arguments that are passed to the support-function             algorithm</li></ul><p><strong>Output</strong></p><p>The support function for the given direction.</p><p><strong>Algorithm</strong></p><p>We combine the constraints of the two polyhedra to a new <code>HPolyhedron</code>, for which we then evaluate the support function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L441-L463">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, cap::Intersection{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of an intersection of two convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cap</code> – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L206-L220">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{Intersection}" href="#LazySets.isbounded-Tuple{Intersection}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(cap::Intersection)::Bool</code></pre><p>Determine whether an intersection of two convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the intersection is bounded.</p><p><strong>Algorithm</strong></p><p>We first check if any of the wrapped sets is bounded. Otherwise, we check boundedness via <a href="../interfaces/#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>isbounded_unit_dimensions</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L508-L525">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{Intersection}" href="#Base.isempty-Tuple{Intersection}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(cap::Intersection)::Bool</code></pre><p>Return if the intersection is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the intersection is empty.</p><p><strong>Notes</strong></p><p>The result will be cached, so a second query will be fast.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L588-L604">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, cap::Intersection{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in an intersection of two convex sets.</p><p><strong>Input</strong></p><ul><li><code>x</code>   – point/vector</li><li><code>cap</code> – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ cap$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L533-L546">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(cap::Intersection{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of an intersection of two (polyhedral) sets.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two (polyhedral) sets</li></ul><p><strong>Output</strong></p><p>The list of constraints of the intersection.</p><p><strong>Notes</strong></p><p>We assume that the underlying sets are polyhedral, i.e., offer a method <code>constraints_list</code>.</p><p><strong>Algorithm</strong></p><p>We create the polyhedron by taking the intersection of the <code>constraints_list</code>s of the sets and remove redundant constraints.</p><p>This function ignores the boolean output from the in-place <code>remove_redundant_constraints!</code>, which may inform the user that the constraints are infeasible. In that case, the list of constraints at the moment when the infeasibility was detected is returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L551-L577">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isempty_known-Tuple{Intersection}" href="#LazySets.isempty_known-Tuple{Intersection}"><code>LazySets.isempty_known</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty_known(cap::Intersection)</code></pre><p>Ask whether the status of emptiness is known.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the emptiness status is known. In this case, <code>isempty(cap)</code> can be used to obtain the status.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L130-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.set_isempty!-Tuple{Intersection,Bool}" href="#LazySets.set_isempty!-Tuple{Intersection,Bool}"><code>LazySets.set_isempty!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">set_isempty!(cap::Intersection, isempty::Bool)</code></pre><p>Set the status of emptiness in the cache.</p><p><strong>Input</strong></p><ul><li><code>cap</code>     – intersection of two convex sets</li><li><code>isempty</code> – new status of emptiness</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L148-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.swap-Union{Tuple{Intersection{N,S1,S2}}, Tuple{S2}, Tuple{S1}, Tuple{N}} where S2 where S1 where N&lt;:Real" href="#LazySets.swap-Union{Tuple{Intersection{N,S1,S2}}, Tuple{S2}, Tuple{S1}, Tuple{N}} where S2 where S1 where N&lt;:Real"><code>LazySets.swap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">swap(cap::Intersection{N, S1, S2}) where {N&lt;:Real, S1, S2}</code></pre><p>Return a new <code>Intersection</code> object with the arguments swapped.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p>A new <code>Intersection</code> object with the arguments swapped. The old cache is shared between the old and new objects.</p><p><strong>Notes</strong></p><p>The advantage of using this function instead of manually swapping the arguments is that the cache is shared.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L162-L180">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.use_precise_ρ" href="#LazySets.use_precise_ρ"><code>LazySets.use_precise_ρ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">use_precise_ρ(cap::Intersection{N})::Bool where {N&lt;:Real}</code></pre><p>Determine whether a precise algorithm for computing <span>$ρ$</span> shall be applied.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> if a precise algorithm shall be applied.</p><p><strong>Notes</strong></p><p>The default implementation always returns <code>true</code>.</p><p>If the result is <code>false</code>, a coarse approximation of the support function is returned.</p><p>This function can be overwritten by the user to control the policy.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L282-L303">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets._line_search" href="#LazySets._line_search"><code>LazySets._line_search</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">_line_search(ℓ, X, H; [kwargs...])</code></pre><p>Given a compact and convex set <span>$X$</span> and a halfspace <span>$H = \{x: a^T x ≤ b \}$</span> or a hyperplane <span>$H = \{x: a^T x = b \}$</span>, calculate:</p><div>\[\min_\{ λ ∈ D_h \} ρ(ℓ - λa, X) + λb.\]</div><p>where <span>$D_h = \{ λ : λ ≥ 0 \}$</span> if <span>$H$</span> is a half-space or <span>$D_h = \{ λ : λ ∈ \mathbb{R} \}$</span> if <span>$H$</span> is a hyperplane.</p><p><strong>Input</strong></p><ul><li><code>ℓ</code>           – direction</li><li><code>X</code>           – set</li><li><code>H</code>           – halfspace or hyperplane</li></ul><p><strong>Output</strong></p><p>The tuple <code>(fmin, λmin)</code>, where <code>fmin</code> is the minimum value of the function <span>$f(λ) = ρ(ℓ - λa) + λb$</span> over the feasible set <span>$λ ≥ 0$</span>, and <span>$λmin$</span> is the minimizer.</p><p><strong>Notes</strong></p><p>This function requires the <code>Optim</code> package, and relies on the univariate optimization interface <code>Optim.optimize(...)</code>.</p><p>Additional arguments to the <code>optimize</code> backend can be passed as keyword arguments. The default method is <code>Optim.Brent()</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X = Ball1(zeros(2), 1.0);

julia&gt; H = HalfSpace([-1.0, 0.0], -1.0); # x &gt;= 0 

julia&gt; using Optim

julia&gt; using LazySets: _line_search

julia&gt; _line_search([1.0, 0.0], X, H) # uses Brent&#39;s method by default
(1.0, 999999.9849478417)</code></pre><p>We can specify the upper bound in Brent&#39;s method:</p><pre><code class="language-julia">julia&gt; _line_search([1.0, 0.0], X, H, upper=1e3)
(1.0, 999.9999849478418)</code></pre><p>Instead of using Brent, we use the Golden Section method:</p><pre><code class="language-julia">julia&gt; _line_search([1.0, 0.0], X, H, upper=1e3, method=GoldenSection())
(1.0, 381.9660112501051)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L874-L934">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets._projection" href="#LazySets._projection"><code>LazySets._projection</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">_projection(ℓ, X, H::Union{Hyperplane{N}, Line{N}};
            [lazy_linear_map]=false,
            [lazy_2d_intersection]=true,
            [algorithm_2d_intersection]=nothing,
            [kwargs...]) where {N}</code></pre><p>Given a compact and convex set <span>$X$</span> and a hyperplane <span>$H = \{x: n ⋅ x = γ \}$</span>, calculate the support function of the intersection between the rank-2 projection <span>$Π_{nℓ} X$</span> and the line <span>$Lγ = \{(x, y): x = γ \}$</span>.</p><p><strong>Input</strong></p><ul><li><code>ℓ</code>                    – direction</li><li><code>X</code>                    – set</li><li><code>H</code>                    – hyperplane</li><li><code>lazy_linear_map</code>      – (optional, default: <code>false</code>) to perform the projection                           lazily or concretely</li><li><code>lazy_2d_intersection</code> – (optional, default: <code>true</code>) to perform the 2D                           intersection between the projected set and the line                           lazily or concretely</li><li><code>algorithm_2d_intersection</code> – (optional, default: <code>nothing</code>) if given, fixes the                                support function algorithm used for the intersection                                in 2D; otherwise the default is implied</li></ul><p><strong>Output</strong></p><p>The support function of <span>$X ∩ H$</span> along direction <span>$ℓ$</span>.</p><p><strong>Algorithm</strong></p><p>This projection method is based on Prop. 8.2, page 103, <a href="https://tel.archives-ouvertes.fr/tel-00422569v2">C. Le Guernic. Reachability Analysis of Hybrid Systems with Linear Continuous Dynamics, PhD thesis</a>.</p><p>In the original algorithm, Section 8.2 of Le Guernic&#39;s thesis, the linear map is performed concretely and the intersection is performed lazily (these are the default options in this algorithm, but here the four combinations are available). If the set <span>$X$</span> is a zonotope, its concrete projection is again a zonotope (sometimes called &quot;zonogon&quot;). The intersection between this zonogon and the line can be taken efficiently in a lazy way (see Section 8.2.2 of Le Guernic&#39;s thesis), if one uses dispatch on <code>ρ(y_dir, Sℓ⋂Lγ; kwargs...)</code> given that <code>Sℓ</code> is itself a zonotope.</p><p><strong>Notes</strong></p><p>This function depends itself on the calculation of the support function of another set in two dimensions. Obviously one doesn&#39;t want to use again <code>algorithm=&quot;projection&quot;</code> for this second calculation. The option <code>algorithm_2d_intersection</code> is such that, if it is not given, the default support function algorithm is used (e.g. <code>&quot;line_search&quot;</code>). You can still pass additional arguments to the <code>&quot;line_search&quot;</code> backend through the <code>kwargs</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L974-L1026">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, cap::Intersection{N}) where {N}</code></pre><p>Return the concrete linear map of a lazy intersection.</p><p><strong>Input</strong></p><ul><li><code>M</code>   – matrix</li><li><code>cap</code> – lazy intersection</li></ul><p><strong>Output</strong></p><p>The set obtained by applying the given linear map to the lazy intersection.</p><p><strong>Notes</strong></p><p>This function relies on computing <code>cap</code> concretely (i.e. as a set representation), and then applying the linear map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L844-L862">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.plot_recipe-Union{Tuple{Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}, Tuple{Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},N}, Tuple{Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},N,Int64}} where N&lt;:Real" href="#LazySets.plot_recipe-Union{Tuple{Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}, Tuple{Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},N}, Tuple{Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},N,Int64}} where N&lt;:Real"><code>LazySets.plot_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_recipe(cap::Intersection{N}, [ε]::N=-one(N),
            [Nφ]::Int=PLOT_POLAR_DIRECTIONS) where {N&lt;:Real}</code></pre><p>Convert a lazy intersection to a pair <code>(x, y)</code> of points for plotting.</p><p><strong>Input</strong></p><ul><li><code>cap</code>  – lazy intersection</li><li><code>ε</code>    – (optional, default <code>0</code>) ignored, used for dispatch</li><li><code>Nφ</code>   – (optional, default: <code>PLOT_POLAR_DIRECTIONS</code>) number of polar           directions used in the template overapproximation</li></ul><p><strong>Output</strong></p><p>A pair <code>(x, y)</code> of points that can be plotted.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L618-L634">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{Dict{Symbol,Any},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{Dict{Symbol,Any},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},N}, Tuple{Dict{Symbol,Any},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},N,Int64}} where N&lt;:Real" href="#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{Dict{Symbol,Any},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{Dict{Symbol,Any},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},N}, Tuple{Dict{Symbol,Any},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},N,Int64}} where N&lt;:Real"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_intersection(cap::Intersection{N}, [ε]::N=zero(N),
                  [Nφ]::Int=PLOT_POLAR_DIRECTIONS) where {N&lt;:Real}</code></pre><p>Plot a lazy intersection.</p><p><strong>Input</strong></p><ul><li><code>cap</code>  – lazy intersection</li><li><code>ε</code>    – (optional, default <code>0</code>) ignored, used for dispatch</li><li><code>Nφ</code>   – (optional, default: <code>PLOT_POLAR_DIRECTIONS</code>) number of polar           directions used in the template overapproximation</li></ul><p><strong>Notes</strong></p><p>This function is separated from the main <code>LazySet</code> plot recipe because iterative refinement is not available for lazy intersections (since it uses the support vector (but see <a href="https://github.com/JuliaReach/LazySets.jl/issues/1187">#1187</a>)).</p><p>Also note that if the set is a <em>nested</em> intersection, you may have to manually overapproximate this set before plotting (see <code>LazySets.Approximations.overapproximate</code> for details).</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; using LazySets.Approximations

julia&gt; X = Ball2(zeros(2), 1.) ∩ Ball2(ones(2), 1.5);  # lazy intersection

julia&gt; plot(X)</code></pre><p>You can specify the accuracy of the overapproximation of the lazy intersection by passing a higher value for <code>Nφ</code>, which stands for the number of polar directions used in the overapproximation. This number can also be passed to the <code>plot</code> function directly.</p><pre><code class="language-julia">julia&gt; plot(overapproximate(X, PolarDirections(100)))

julia&gt; plot(X, -1., 100)  # equivalent to the above line</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/Plotting/plot_recipes.jl#L287-L331">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h4><a class="nav-anchor" id="Intersection-cache-1" href="#Intersection-cache-1">Intersection cache</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.IntersectionCache" href="#LazySets.IntersectionCache"><code>LazySets.IntersectionCache</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IntersectionCache</code></pre><p>Container for information cached by a lazy <code>Intersection</code> object.</p><p><strong>Fields</strong></p><ul><li><p><code>isempty</code> – is the intersection empty? There are three possible states,              encoded as <code>Int8</code> values -1, 0, 1:</p><ul><li><span>$-1$</span> - it is currently unknown whether the intersection is empty or not</li><li><span>$0$</span> - intersection is not empty</li><li><span>$1$</span> - intersection is empty</li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L13-L26">source</a></section><h3><a class="nav-anchor" id="n-ary-Intersection-1" href="#n-ary-Intersection-1"><span>$n$</span>-ary Intersection</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.IntersectionArray" href="#LazySets.IntersectionArray"><code>LazySets.IntersectionArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IntersectionArray{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the intersection of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><code>array</code> – array of convex sets</li></ul><p><strong>Notes</strong></p><p>This type assumes that the dimensions of all elements match.</p><p>The <code>EmptySet</code> is the absorbing element for <code>IntersectionArray</code>.</p><p>Constructors:</p><ul><li><p><code>IntersectionArray(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>IntersectionArray([n]::Int=0, [N]::Type=Float64)</code> – constructor for an empty sum with optional size hint and numeric type</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L656-L677">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{IntersectionArray}" href="#LazySets.dim-Tuple{IntersectionArray}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(ia::IntersectionArray)::Int</code></pre><p>Return the dimension of an intersection of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the intersection of a finite number of sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L719-L731">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},IntersectionArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},IntersectionArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, ia::IntersectionArray{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the support vector of an intersection of a finite number of sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the individual sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L736-L751">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{IntersectionArray}" href="#LazySets.isbounded-Tuple{IntersectionArray}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(ia::IntersectionArray)::Bool</code></pre><p>Determine whether an intersection of a finite number of convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the intersection is bounded.</p><p><strong>Algorithm</strong></p><p>We first check if any of the wrapped sets is bounded. Otherwise, we check boundedness via <a href="../interfaces/#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>isbounded_unit_dimensions</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L758-L775">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},IntersectionArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},IntersectionArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, ia::IntersectionArray{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in an intersection of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>x</code>  – point/vector</li><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ ia$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L783-L797">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.array-Union{Tuple{IntersectionArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real" href="#LazySets.array-Union{Tuple{IntersectionArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">array(cpa::CartesianProductArray{N, S}
     )::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The array of a Cartesian product of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L341-L354">source</a><div><div><pre><code class="language-none">array(cha::ConvexHullArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p>The array of a convex hull of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L238-L250">source</a><div><div><pre><code class="language-none">array(ia::IntersectionArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of an intersection of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array of an intersection of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L698-L710">source</a><div><div><pre><code class="language-none">array(msa::MinkowskiSumArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Minkowski sum of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The array of a Minkowski sum of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L260-L272">source</a><div><div><pre><code class="language-none">array(cms::CacheMinkowskiSum{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The array of a caching Minkowski sum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L460-L472">source</a><div><div><pre><code class="language-julia">array(cup::UnionSetArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array that holds the union of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L270-L282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{IntersectionArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{IntersectionArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(ia::IntersectionArray{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of an intersection of a finite number of (polyhedral) sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of (polyhedral) sets</li></ul><p><strong>Output</strong></p><p>The list of constraints of the intersection.</p><p><strong>Notes</strong></p><p>We assume that the underlying sets are polyhedral, i.e., offer a method <code>constraints_list</code>.</p><p><strong>Algorithm</strong></p><p>We create the polyhedron from the <code>constraints_list</code>s of the sets and remove redundant constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L807-L830">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h2><a class="nav-anchor" id="Minkowski-Sum-1" href="#Minkowski-Sum-1">Minkowski Sum</a></h2><h3><a class="nav-anchor" id="Binary-Minkowski-Sum-1" href="#Binary-Minkowski-Sum-1">Binary Minkowski Sum</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.MinkowskiSum" href="#LazySets.MinkowskiSum"><code>LazySets.MinkowskiSum</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MinkowskiSum{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the Minkowski sum of two convex sets.</p><p><strong>Fields</strong></p><ul><li><code>X</code> – first convex set</li><li><code>Y</code> – second convex set</li></ul><p><strong>Notes</strong></p><p>The <code>ZeroSet</code> is the neutral element and the <code>EmptySet</code> is the absorbing element for <code>MinkowskiSum</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L11-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.:⊕-Tuple{LazySet,LazySet}" href="#LazySets.:⊕-Tuple{LazySet,LazySet}"><code>LazySets.:⊕</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">⊕(X::LazySet, Y::LazySet)</code></pre><p>Unicode alias constructor ⊕ (<code>oplus</code>) for the lazy Minkowski sum operator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L66-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{LazySet,LazySet}" href="#Base.:+-Tuple{LazySet,LazySet}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">X + Y</code></pre><p>Convenience constructor for Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>X</code> – a convex set</li><li><code>Y</code> – another convex set</li></ul><p><strong>Output</strong></p><p>The symbolic Minkowski sum of <span>$X$</span> and <span>$Y$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L50-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.swap-Tuple{MinkowskiSum}" href="#LazySets.swap-Tuple{MinkowskiSum}"><code>LazySets.swap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">swap(ms::MinkowskiSum)</code></pre><p>Return a new <code>MinkowskiSum</code> object with the arguments swapped.</p><p><strong>Input</strong></p><ul><li><code>ms</code> – Minkowski sum of two convex sets</li></ul><p><strong>Output</strong></p><p>A new <code>MinkowskiSum</code> object with the arguments swapped.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L73-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{MinkowskiSum}" href="#LazySets.dim-Tuple{MinkowskiSum}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(ms::MinkowskiSum)::Int</code></pre><p>Return the dimension of a Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>ms</code> – Minkowski sum</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Minkowski sum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L90-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSum{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSum{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, ms::MinkowskiSum{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>ms</code> – Minkowski sum</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p><p><strong>Algorithm</strong></p><p>The support function in direction <span>$d$</span> of the Minkowski sum of two sets <span>$X$</span> and <span>$Y$</span> is the sum of the support functions of <span>$X$</span> and <span>$Y$</span> in direction <span>$d$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L132-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSum{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSum{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, ms::MinkowskiSum{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>ms</code> – Minkowski sum</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.</p><p><strong>Algorithm</strong></p><p>The support vector in direction <span>$d$</span> of the Minkowski sum of two sets <span>$X$</span> and <span>$Y$</span> is the sum of the support vectors of <span>$X$</span> and <span>$Y$</span> in direction <span>$d$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L107-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{MinkowskiSum}" href="#LazySets.isbounded-Tuple{MinkowskiSum}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(ms::MinkowskiSum)::Bool</code></pre><p>Determine whether a Minkowski sum is bounded.</p><p><strong>Input</strong></p><ul><li><code>ms</code> – Minkowski sum</li></ul><p><strong>Output</strong></p><p><code>true</code> iff both wrapped sets are bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L156-L168">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{MinkowskiSum}" href="#Base.isempty-Tuple{MinkowskiSum}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(ms::MinkowskiSum)::Bool</code></pre><p>Return if a Minkowski sum is empty or not.</p><p><strong>Input</strong></p><ul><li><code>ms</code> – Minkowski sum</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the wrapped sets are empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L173-L185">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Tuple{MinkowskiSum}" href="#LazySets.constraints_list-Tuple{MinkowskiSum}"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(ms::MinkowskiSum)</code></pre><p>Return the list of constraints of a lazy Minkowski sum of two polyhedral sets.</p><p><strong>Input</strong></p><ul><li><code>ms</code> – Minkowski sum of two polyhedral sets</li></ul><p><strong>Output</strong></p><p>The list of constraints of the Minkowski sum.</p><p><strong>Algorithm</strong></p><p>We compute a concrete set representation via <code>minkowski_sum</code> and call <code>constraints_list</code> on the result.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L190-L207">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h3><a class="nav-anchor" id="n-ary-Minkowski-Sum-1" href="#n-ary-Minkowski-Sum-1"><span>$n$</span>-ary Minkowski Sum</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.MinkowskiSumArray" href="#LazySets.MinkowskiSumArray"><code>LazySets.MinkowskiSumArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MinkowskiSumArray{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the Minkowski sum of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><code>array</code> – array of convex sets</li></ul><p><strong>Notes</strong></p><p>This type assumes that the dimensions of all elements match.</p><p>The <code>ZeroSet</code> is the neutral element and the <code>EmptySet</code> is the absorbing element for <code>MinkowskiSumArray</code>.</p><p>Constructors:</p><ul><li><p><code>MinkowskiSumArray(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>MinkowskiSumArray([n]::Int=0, [N]::Type=Float64)</code> – constructor for an empty sum with optional size hint and numeric type</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L216-L238">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{MinkowskiSumArray}" href="#LazySets.dim-Tuple{MinkowskiSumArray}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(msa::MinkowskiSumArray)::Int</code></pre><p>Return the dimension of a Minkowski sum of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Minkowski sum of a finite number of sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L277-L289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSumArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSumArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, msa::MinkowskiSumArray{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a Minkowski sum array of a finite number of sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p><p><strong>Algorithm</strong></p><p>The support function of the Minkowski sum of sets is the sum of the support functions of each set. </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L314-L333">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSumArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSumArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, msa::MinkowskiSumArray{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a Minkowski sum of a finite number of sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L294-L309">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{MinkowskiSumArray}" href="#LazySets.isbounded-Tuple{MinkowskiSumArray}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(msa::MinkowskiSumArray)::Bool</code></pre><p>Determine whether a Minkowski sum of a finite number of convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff all wrapped sets are bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L338-L350">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{MinkowskiSumArray}" href="#Base.isempty-Tuple{MinkowskiSumArray}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(msa::MinkowskiSumArray)::Bool</code></pre><p>Return if a Minkowski sum array is empty or not.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the wrapped sets are empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L355-L367">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.array-Union{Tuple{MinkowskiSumArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real" href="#LazySets.array-Union{Tuple{MinkowskiSumArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">array(cpa::CartesianProductArray{N, S}
     )::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The array of a Cartesian product of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L341-L354">source</a><div><div><pre><code class="language-none">array(cha::ConvexHullArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p>The array of a convex hull of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L238-L250">source</a><div><div><pre><code class="language-none">array(ia::IntersectionArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of an intersection of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array of an intersection of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L698-L710">source</a><div><div><pre><code class="language-none">array(msa::MinkowskiSumArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Minkowski sum of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The array of a Minkowski sum of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L260-L272">source</a><div><div><pre><code class="language-none">array(cms::CacheMinkowskiSum{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The array of a caching Minkowski sum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L460-L472">source</a><div><div><pre><code class="language-julia">array(cup::UnionSetArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array that holds the union of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L270-L282">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h3><a class="nav-anchor" id="n-ary-Minkowski-Sum-with-cache-1" href="#n-ary-Minkowski-Sum-with-cache-1"><span>$n$</span>-ary Minkowski Sum with cache</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CacheMinkowskiSum" href="#LazySets.CacheMinkowskiSum"><code>LazySets.CacheMinkowskiSum</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CacheMinkowskiSum{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the Minkowski sum of a finite number of convex sets. Support vector queries are cached.</p><p><strong>Fields</strong></p><ul><li><code>array</code> – array of convex sets</li><li><code>cache</code> – cache of support vector query results</li></ul><p><strong>Notes</strong></p><p>This type assumes that the dimensions of all elements match.</p><p>The <code>ZeroSet</code> is the neutral element and the <code>EmptySet</code> is the absorbing element for <code>CacheMinkowskiSum</code>.</p><p>The cache (field <code>cache</code>) is implemented as dictionary whose keys are directions and whose values are pairs <code>(k, s)</code> where <code>k</code> is the number of elements in the array <code>array</code> when the support vector was evaluated last time, and <code>s</code> is the support vector that was obtained. Thus this type assumes that <code>array</code> is not modified except by adding new sets at the end.</p><p>Constructors:</p><ul><li><p><code>CacheMinkowskiSum(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>CacheMinkowskiSum([n]::Int=0, [N]::Type=Float64)</code> – constructor for an empty sum with optional size hint and numeric type</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L401-L432">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{CacheMinkowskiSum}" href="#LazySets.dim-Tuple{CacheMinkowskiSum}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(cms::CacheMinkowskiSum)::Int</code></pre><p>Return the dimension of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the caching Minkowski sum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L478-L490">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CacheMinkowskiSum{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CacheMinkowskiSum{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, cms::CacheMinkowskiSum{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a caching Minkowski sum in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.</p><p><strong>Notes</strong></p><p>The result is cached, i.e., any further query with the same direction runs in constant time. When sets are added to the caching Minkowski sum, the query is only performed for the new sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L495-L516">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{CacheMinkowskiSum}" href="#LazySets.isbounded-Tuple{CacheMinkowskiSum}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(cms::CacheMinkowskiSum)::Bool</code></pre><p>Determine whether a caching Minkowski sum is bounded.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p><code>true</code> iff all wrapped sets are bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L542-L554">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{CacheMinkowskiSum}" href="#Base.isempty-Tuple{CacheMinkowskiSum}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(cms::CacheMinkowskiSum)::Bool</code></pre><p>Return if a caching Minkowski sum array is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the wrapped sets are empty.</p><p><strong>Notes</strong></p><p>Forgotten sets cannot be checked anymore. Usually they have been empty because otherwise the support vector query should have crashed before. In that case, the caching Minkowski sum should not be used further.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L559-L578">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.array-Union{Tuple{CacheMinkowskiSum{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real" href="#LazySets.array-Union{Tuple{CacheMinkowskiSum{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">array(cpa::CartesianProductArray{N, S}
     )::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The array of a Cartesian product of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/CartesianProduct.jl#L341-L354">source</a><div><div><pre><code class="language-none">array(cha::ConvexHullArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p>The array of a convex hull of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ConvexHull.jl#L238-L250">source</a><div><div><pre><code class="language-none">array(ia::IntersectionArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of an intersection of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array of an intersection of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Intersection.jl#L698-L710">source</a><div><div><pre><code class="language-none">array(msa::MinkowskiSumArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Minkowski sum of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The array of a Minkowski sum of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L260-L272">source</a><div><div><pre><code class="language-none">array(cms::CacheMinkowskiSum{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The array of a caching Minkowski sum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L460-L472">source</a><div><div><pre><code class="language-julia">array(cup::UnionSetArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array that holds the union of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L270-L282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.forget_sets!-Tuple{CacheMinkowskiSum}" href="#LazySets.forget_sets!-Tuple{CacheMinkowskiSum}"><code>LazySets.forget_sets!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">forget_sets!(cms::CacheMinkowskiSum)::Int</code></pre><p>Tell a caching Minkowski sum to forget the stored sets (but not the support vectors). Only those sets are forgotten such that for each cached direction the support vector has been computed before.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The number of sets that have been forgotten.</p><p><strong>Notes</strong></p><p>This function should only be used under the assertion that no new directions are queried in the future; otherwise such support vector results will be incorrect.</p><p>This implementation is optimistic and first tries to remove all sets. However, it also checks that for all cached directions the support vector has been computed before. If it finds that this is not the case, the implementation identifies the biggest index <span>$k$</span> such that the above holds for the <span>$k$</span> oldest sets, and then it only removes these. See the example below.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x1 = BallInf(ones(3), 3.); x2 = Ball1(ones(3), 5.);

julia&gt; cms1 = CacheMinkowskiSum(2); cms2 = CacheMinkowskiSum(2);

julia&gt; d = ones(3);

julia&gt; a1 = array(cms1); a2 = array(cms2);

julia&gt; push!(a1, x1); push!(a2, x1);

julia&gt; σ(d, cms1); σ(d, cms2);

julia&gt; push!(a1, x2); push!(a2, x2);

julia&gt; σ(d, cms1);

julia&gt; idx1 = forget_sets!(cms1) # support vector was computed for both sets
2

julia&gt; idx1 = forget_sets!(cms2) # support vector was only computed for first set
1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/MinkowskiSum.jl#L583-L637">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h2><a class="nav-anchor" id="Maps-1" href="#Maps-1">Maps</a></h2><h3><a class="nav-anchor" id="Linear-Map-1" href="#Linear-Map-1">Linear Map</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.LinearMap" href="#LazySets.LinearMap"><code>LazySets.LinearMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">LinearMap{N&lt;:Real, S&lt;:LazySet{N}, NM, MAT&lt;:AbstractMatrix{NM}} &lt;: LazySet{N}</code></pre><p>Type that represents a linear transformation <span>$M⋅S$</span> of a convex set <span>$S$</span>.</p><p><strong>Fields</strong></p><ul><li><code>M</code> – matrix/linear map</li><li><code>X</code> – convex set</li></ul><p><strong>Notes</strong></p><p>This type is parametric in the elements of the linear map, <code>NM</code>, which is independent of the numeric type of the wrapped set (<code>N</code>). Typically <code>NM = N</code>, but there may be exceptions, e.g., if <code>NM</code> is an interval that holds numbers of type <code>N</code>, where <code>N</code> is a floating point number type such as <code>Float64</code>.</p><p><strong>Examples</strong></p><p>For the examples we create a <span>$3×2$</span> matrix and two unit squares, one of them being two-dimensional and the other one being one-dimensional.</p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 1 3; 1 4]; X = BallInf([0, 0], 1); Y = BallInf([0], 1);</code></pre><p>The function <span>$*$</span> can be used as an alias to construct a <code>LinearMap</code> object.</p><pre><code class="language-julia-repl">julia&gt; lm = LinearMap(A, X)
LinearMap{Int64,BallInf{Int64},Int64,Array{Int64,2}}([1 2; 1 3; 1 4], BallInf{Int64}([0, 0], 1))

julia&gt; lm2 = A * X
LinearMap{Int64,BallInf{Int64},Int64,Array{Int64,2}}([1 2; 1 3; 1 4], BallInf{Int64}([0, 0], 1))

julia&gt; lm == lm2
true</code></pre><p>For convenience, <code>A</code> does not need to be a matrix but we also allow to use vectors (interpreted as an <span>$n×1$</span> matrix) and <code>UniformScaling</code>s resp. scalars (interpreted as a scaling, i.e., a scaled identity matrix). Scaling by <span>$1$</span> is ignored.</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra: I

julia&gt; [2, 3] * Y
LinearMap{Int64,BallInf{Int64},Int64,Array{Int64,2}}([2; 3], BallInf{Int64}([0], 1))

julia&gt; lm3 = 2 * X
LinearMap{Int64,BallInf{Int64},Int64,SparseArrays.SparseMatrixCSC{Int64,Int64}}(
  [1, 1]  =  2
  [2, 2]  =  2, BallInf{Int64}([0, 0], 1))

julia&gt; 2I * X == lm3
true

julia&gt; 1I * X == X
true</code></pre><p>Applying a linear map to a <code>LinearMap</code> object combines the two maps into a single <code>LinearMap</code> instance. Again we can make use of the conversion for convenience.</p><pre><code class="language-julia-repl">julia&gt; B = transpose(A); B * lm
LinearMap{Int64,BallInf{Int64},Int64,Array{Int64,2}}([3 9; 9 29], BallInf{Int64}([0, 0], 1))

julia&gt; B = [3, 4, 5]; B * lm
LinearMap{Int64,BallInf{Int64},Int64,Array{Int64,2}}([12 38], BallInf{Int64}([0, 0], 1))

julia&gt; B = 2; B * lm
LinearMap{Int64,BallInf{Int64},Int64,Array{Int64,2}}([2 4; 2 6; 2 8], BallInf{Int64}([0, 0], 1))</code></pre><p>The application of a <code>LinearMap</code> to a <code>ZeroSet</code> or an <code>EmptySet</code> is simplified automatically.</p><pre><code class="language-julia-repl">julia&gt; A * ZeroSet{Int}(2)
ZeroSet{Int64}(3)

julia&gt; A * EmptySet{Int}()
EmptySet{Int64}()</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/LinearMap.jl#L7-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{Union{Real, AbstractArray{T,2} where T, AbstractArray{T,1} where T, UniformScaling},LazySet}" href="#Base.:*-Tuple{Union{Real, AbstractArray{T,2} where T, AbstractArray{T,1} where T, UniformScaling},LazySet}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">    *(map::Union{AbstractMatrix, UniformScaling, AbstractVector, Real}, X::LazySet)</code></pre><p>Alias to create a <code>LinearMap</code> object.</p><p><strong>Input</strong></p><ul><li><code>map</code> – linear map</li><li><code>X</code>   – convex set</li></ul><p><strong>Output</strong></p><p>A lazy linear map, i.e., a <code>LinearMap</code> instance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/LinearMap.jl#L110-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LinearMap}" href="#LazySets.dim-Tuple{LinearMap}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(lm::LinearMap)::Int</code></pre><p>Return the dimension of a linear map.</p><p><strong>Input</strong></p><ul><li><code>lm</code> – linear map</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the linear map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/LinearMap.jl#L190-L202">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, lm::LinearMap{N}; kwargs...) where {N&lt;:Real}</code></pre><p>Return the support function of the linear map.</p><p><strong>Input</strong></p><ul><li><code>d</code>      – direction</li><li><code>lm</code>     – linear map</li><li><code>kwargs</code> – additional arguments that are passed to the support function             algorithm</li></ul><p><strong>Output</strong></p><p>The support function in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$L = M⋅S$</span>, where <span>$M$</span> is a matrix and <span>$S$</span> is a convex set, it follows that <span>$ρ(d, L) = ρ(M^T d, S)$</span> for any direction <span>$d$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/LinearMap.jl#L231-L252">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, lm::LinearMap{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of the linear map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>lm</code> – linear map</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$L = M⋅S$</span>, where <span>$M$</span> is a matrix and <span>$S$</span> is a convex set, it follows that <span>$σ(d, L) = M⋅σ(M^T d, S)$</span> for any direction <span>$d$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/LinearMap.jl#L207-L226">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, lm::LinearMap{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a linear map of a convex set.</p><p><strong>Input</strong></p><ul><li><code>x</code>  – point/vector</li><li><code>lm</code> – linear map of a convex set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ lm$</span>.</p><p><strong>Algorithm</strong></p><p>Note that <span>$x ∈ M⋅S$</span> iff <span>$M^{-1}⋅x ∈ S$</span>. This implementation does not explicitly invert the matrix, which is why it also works for non-square matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; lm = LinearMap([2.0 0.0; 0.0 1.0], BallInf([1., 1.], 1.));

julia&gt; [5.0, 1.0] ∈ lm
false
julia&gt; [3.0, 1.0] ∈ lm
true</code></pre><p>An example with non-square matrix:</p><pre><code class="language-julia-repl">julia&gt; B = BallInf(zeros(4), 1.);

julia&gt; M = [1. 0 0 0; 0 1 0 0]/2;

julia&gt; [0.5, 0.5] ∈ M*B
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/LinearMap.jl#L290-L330">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(lm::LinearMap{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a linear map.</p><p><strong>Input</strong></p><ul><li><code>lm</code> – linear map</li></ul><p><strong>Output</strong></p><p>An element in the linear map. It relies on the <code>an_element</code> function of the wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/LinearMap.jl#L335-L348">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{LinearMap}" href="#LazySets.isbounded-Tuple{LinearMap}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(lm::LinearMap; cond_tol::Number=DEFAULT_COND_TOL)::Bool</code></pre><p>Determine whether a linear map is bounded.</p><p><strong>Input</strong></p><ul><li><code>lm</code>       – linear map</li><li><code>cond_tol</code> – (optional) tolerance of matrix condition (used to check whether               the matrix is invertible)</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the linear map is bounded.</p><p><strong>Algorithm</strong></p><p>We first check if the matrix is zero or the wrapped set is bounded. If not, we perform a sufficient check whether the matrix is invertible. If the matrix is invertible, then the map being bounded is equivalent to the wrapped set being bounded, and hence the map is unbounded. Otherwise, we check boundedness via <a href="../interfaces/#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>isbounded_unit_dimensions</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/LinearMap.jl#L257-L279">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{LinearMap}" href="#Base.isempty-Tuple{LinearMap}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(lm::LinearMap)::Bool</code></pre><p>Return if a linear map is empty or not.</p><p><strong>Input</strong></p><ul><li><code>lm</code> – linear map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/LinearMap.jl#L353-L365">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(lm::LinearMap{N}; prune::Bool=true)::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a (polyhedral) linear map.</p><p><strong>Input</strong></p><ul><li><code>lm</code> – linear map</li><li><code>prune</code> – (optional, default: <code>true</code>) if true removes redundant vertices</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying set <code>X</code> is polyhedral. Then the result is just the linear map applied to the vertices of <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/LinearMap.jl#L370-L388">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(lm::LinearMap{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of a (polyhedral) linear map.</p><p><strong>Input</strong></p><ul><li><code>lm</code> – linear map</li></ul><p><strong>Output</strong></p><p>The list of constraints of the linear map.</p><p><strong>Notes</strong></p><p>We assume that the underlying set <code>X</code> is polyhedral, i.e., offers a method <code>constraints_list(X)</code>.</p><p><strong>Algorithm</strong></p><p>We fall back to a concrete set representation and apply <code>linear_map</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/LinearMap.jl#L408-L429">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, lm::LinearMap{N}) where {N&lt;:Real}</code></pre><p>Return the linear map of a lazy linear map.</p><p><strong>Input</strong></p><ul><li><code>M</code>  – matrix</li><li><code>lm</code> – linear map</li></ul><p><strong>Output</strong></p><p>The polytope representing the linear map of the lazy linear map of a set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/LinearMap.jl#L434-L447">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../interfaces/#LazySets.diameter"><code>diameter</code></a></li></ul><h3><a class="nav-anchor" id="Exponential-Map-1" href="#Exponential-Map-1">Exponential Map</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ExponentialMap" href="#LazySets.ExponentialMap"><code>LazySets.ExponentialMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ExponentialMap{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the action of an exponential map on a convex set.</p><p><strong>Fields</strong></p><ul><li><code>spmexp</code> – sparse matrix exponential</li><li><code>X</code>      – convex set</li></ul><p><strong>Examples</strong></p><p>The <code>ExponentialMap</code> type is overloaded to the usual times <code>*</code> operator when the linear map is a lazy matrix exponential. For instance,</p><pre><code class="language-julia-repl">julia&gt; using SparseArrays

julia&gt; A = sprandn(100, 100, 0.1);

julia&gt; E = SparseMatrixExp(A);

julia&gt; B = BallInf(zeros(100), 1.);

julia&gt; M = E * B; # represents the image set: exp(A) * B

julia&gt; M isa ExponentialMap
true

julia&gt; dim(M)
100</code></pre><p>The application of an <code>ExponentialMap</code> to a <code>ZeroSet</code> or an <code>EmptySet</code> is simplified automatically.</p><pre><code class="language-julia-repl">julia&gt; E * ZeroSet(100)
ZeroSet{Float64}(100)

julia&gt; E * EmptySet()
EmptySet{Float64}()</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ExponentialMap.jl#L152-L195">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{ExponentialMap}" href="#LazySets.dim-Tuple{ExponentialMap}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(em::ExponentialMap)::Int</code></pre><p>Return the dimension of an exponential map.</p><p><strong>Input</strong></p><ul><li><code>em</code> – an ExponentialMap</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the exponential map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ExponentialMap.jl#L235-L247">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ExponentialMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ExponentialMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, em::ExponentialMap{N}) where {N&lt;:Real}</code></pre><p>Return the support function of the exponential map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>em</code> – exponential map</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p><p><strong>Notes</strong></p><p>If <span>$E = \exp(M)⋅S$</span>, where <span>$M$</span> is a matrix and <span>$S$</span> is a convex set, it follows that <span>$ρ(d, E) = ρ(\exp(M)^T d, S)$</span> for any direction <span>$d$</span>.</p><p>We allow sparse direction vectors, but will convert them to dense vectors to be able to use <code>expmv</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ExponentialMap.jl#L284-L305">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ExponentialMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ExponentialMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, em::ExponentialMap{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of the exponential map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>em</code> – exponential map</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$E = \exp(M)⋅S$</span>, where <span>$M$</span> is a matrix and <span>$S$</span> is a convex set, it follows that <span>$σ(d, E) = \exp(M)⋅σ(\exp(M)^T d, S)$</span> for any direction <span>$d$</span>.</p><p>We allow sparse direction vectors, but will convert them to dense vectors to be able to use <code>expmv</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ExponentialMap.jl#L255-L277">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},ExponentialMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},ExponentialMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, em::ExponentialMap{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in an exponential map of a convex set.</p><p><strong>Input</strong></p><ul><li><code>x</code>  – point/vector</li><li><code>em</code> – exponential map of a convex set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ em$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation exploits that <span>$x ∈ \exp(M)⋅S$</span> iff <span>$\exp(-M)⋅x ∈ S$</span>. This follows from <span>$\exp(-M)⋅\exp(M) = I$</span> for any <span>$M$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SparseArrays

julia&gt; em = ExponentialMap(
        SparseMatrixExp(sparse([1, 2], [1, 2], [2.0, 1.0], 2, 2)),
        BallInf([1., 1.], 1.));

julia&gt; [-1.0, 1.0] ∈ em
false
julia&gt; [1.0, 1.0] ∈ em
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ExponentialMap.jl#L312-L345">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{ExponentialMap}" href="#LazySets.isbounded-Tuple{ExponentialMap}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(em::ExponentialMap)::Bool</code></pre><p>Determine whether an exponential map is bounded.</p><p><strong>Input</strong></p><ul><li><code>em</code> – exponential map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the exponential map is bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ExponentialMap.jl#L385-L397">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{ExponentialMap}" href="#Base.isempty-Tuple{ExponentialMap}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(em::ExponentialMap)::Bool</code></pre><p>Return if an exponential map is empty or not.</p><p><strong>Input</strong></p><ul><li><code>em</code> – exponential map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ExponentialMap.jl#L402-L414">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{ExponentialMap{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{ExponentialMap{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(em::ExponentialMap{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a (polytopic) exponential map.</p><p><strong>Input</strong></p><ul><li><code>em</code> – exponential map</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying set <code>X</code> is polytopic. Then the result is just the exponential map applied to the vertices of <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ExponentialMap.jl#L351-L368">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ExponentialProjectionMap" href="#LazySets.ExponentialProjectionMap"><code>LazySets.ExponentialProjectionMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ExponentialProjectionMap{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the application of a projection of a sparse matrix exponential to a convex set.</p><p><strong>Fields</strong></p><ul><li><code>spmexp</code> – projection of a sparse matrix exponential</li><li><code>X</code>      – convex set</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ExponentialMap.jl#L441-L451">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{ExponentialProjectionMap}" href="#LazySets.dim-Tuple{ExponentialProjectionMap}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(eprojmap::ExponentialProjectionMap)::Int</code></pre><p>Return the dimension of a projection of an exponential map.</p><p><strong>Input</strong></p><ul><li><code>eprojmap</code> – projection of an exponential map</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the projection of an exponential map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ExponentialMap.jl#L479-L491">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ExponentialProjectionMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ExponentialProjectionMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N},
  eprojmap::ExponentialProjectionMap{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a projection of an exponential map.</p><p><strong>Input</strong></p><ul><li><code>d</code>        – direction</li><li><code>eprojmap</code> – projection of an exponential map</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$S = (L⋅M⋅R)⋅X$</span>, where <span>$L$</span> and <span>$R$</span> are matrices, <span>$M$</span> is a matrix exponential, and <span>$X$</span> is a set, it follows that <span>$σ(d, S) = L⋅M⋅R⋅σ(R^T⋅M^T⋅L^T⋅d, X)$</span> for any direction <span>$d$</span>.</p><p>We allow sparse direction vectors, but will convert them to dense vectors to be able to use <code>expmv</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ExponentialMap.jl#L499-L523">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{ExponentialProjectionMap}" href="#LazySets.isbounded-Tuple{ExponentialProjectionMap}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(eprojmap::ExponentialProjectionMap)::Bool</code></pre><p>Determine whether an exponential projection map is bounded.</p><p><strong>Input</strong></p><ul><li><code>eprojmap</code> – exponential projection map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the exponential projection map is bounded.</p><p><strong>Algorithm</strong></p><p>We first check if the left or right projection matrix is zero or the wrapped set is bounded. Otherwise, we check boundedness via <a href="../interfaces/#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>isbounded_unit_dimensions</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ExponentialMap.jl#L539-L557">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{ExponentialProjectionMap}" href="#Base.isempty-Tuple{ExponentialProjectionMap}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(eprojmap::ExponentialProjectionMap)::Bool</code></pre><p>Return if an exponential projection map is empty or not.</p><p><strong>Input</strong></p><ul><li><code>eprojmap</code> – exponential projection map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ExponentialMap.jl#L566-L578">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.SparseMatrixExp" href="#LazySets.SparseMatrixExp"><code>LazySets.SparseMatrixExp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SparseMatrixExp{N}</code></pre><p>Type that represents the matrix exponential, <span>$\exp(M)$</span>, of a sparse matrix.</p><p><strong>Fields</strong></p><ul><li><code>M</code> – sparse matrix</li></ul><p><strong>Examples</strong></p><p>Take for exammple a random sparse matrix:</p><pre><code class="language-julia-repl">julia&gt; using SparseArrays

julia&gt; A = sprandn(100, 100, 0.1);

julia&gt; E = SparseMatrixExp(A);

julia&gt; size(E)
(100, 100)</code></pre><p>Now, <code>E</code> is a lazy representation of <span>$\exp(A)$</span>. To compute with <code>E</code>, use <code>get_row</code> and <code>get_column</code> (or <code>get_rows</code> and <code>get_columns</code>; they return row and column vectors (or matrices). For example:</p><pre><code class="language-julia-repl">julia&gt; get_row(E, 10); # compute E[10, :]

julia&gt; get_column(E, 10); # compute E[:, 10]

julia&gt; get_rows(E, [10]); # same as get_row(E, 10) but a 1x100 matrix is returned

julia&gt; get_columns(E, [10]); # same as get_column(E, 10) but a 100x1 matrix is returned</code></pre><p><strong>Notes</strong></p><p>This type is provided for use with very large and very sparse matrices. The evaluation of the exponential matrix action over vectors relies on the <a href="https://github.com/acroy/Expokit.jl">Expokit</a> package.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ExponentialMap.jl#L15-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Union{Tuple{N}, Tuple{SparseMatrixExp{N,MN} where MN&lt;:(AbstractSparseArray{N,Ti,2} where Ti),LazySet{N}}} where N&lt;:Real" href="#Base.:*-Union{Tuple{N}, Tuple{SparseMatrixExp{N,MN} where MN&lt;:(AbstractSparseArray{N,Ti,2} where Ti),LazySet{N}}} where N&lt;:Real"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">    *(spmexp::SparseMatrixExp{N}, X::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return the exponential map of a convex set from a sparse matrix exponential.</p><p><strong>Input</strong></p><ul><li><code>spmexp</code> – sparse matrix exponential</li><li><code>X</code>      – convex set</li></ul><p><strong>Output</strong></p><p>The exponential map of the convex set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ExponentialMap.jl#L215-L230">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.get_row-Tuple{SparseMatrixExp,Int64}" href="#LazySets.get_row-Tuple{SparseMatrixExp,Int64}"><code>LazySets.get_row</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_row(spmexp::SparseMatrixExp{N}, i::Int) where {N}</code></pre><p>Return a single row of a sparse matrix exponential.</p><p><strong>Input</strong></p><ul><li><code>spmexp</code> – sparse matrix exponential</li><li><code>i</code>      – row index</li></ul><p><strong>Output</strong></p><p>A row vector corresponding to the <code>i</code>th row of the matrix exponential.</p><p><strong>Notes</strong></p><p>This function uses Julia&#39;s <code>transpose</code> function to create the result. The result is of type <code>Transpose</code>; in Julia versions older than v0.7, the result was of type <code>RowVector</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ExponentialMap.jl#L105-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ProjectionSparseMatrixExp" href="#LazySets.ProjectionSparseMatrixExp"><code>LazySets.ProjectionSparseMatrixExp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ProjectionSparseMatrixExp{N&lt;:Real}</code></pre><p>Type that represents the projection of a sparse matrix exponential, i.e., <span>$L⋅\exp(M)⋅R$</span> for a given sparse matrix <span>$M$</span>.</p><p><strong>Fields</strong></p><ul><li><code>L</code> – left multiplication matrix</li><li><code>E</code> – sparse matrix exponential</li><li><code>R</code> – right multiplication matrix</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ExponentialMap.jl#L421-L432">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{ProjectionSparseMatrixExp,LazySet}" href="#Base.:*-Tuple{ProjectionSparseMatrixExp,LazySet}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">    *(projspmexp::ProjectionSparseMatrixExp, X::LazySet)</code></pre><p>Return the application of a projection of a sparse matrix exponential to a convex set.</p><p><strong>Input</strong></p><ul><li><code>projspmexp</code> – projection of a sparse matrix exponential</li><li><code>X</code>          – convex set</li></ul><p><strong>Output</strong></p><p>The application of the projection of a sparse matrix exponential to the convex set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ExponentialMap.jl#L457-L474">source</a></section><h3><a class="nav-anchor" id="Reset-Map-1" href="#Reset-Map-1">Reset Map</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ResetMap" href="#LazySets.ResetMap"><code>LazySets.ResetMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ResetMap{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents a lazy reset map. A reset map is a special case of an affine map <span>$A x + b, x ∈ X$</span> where the linear map <span>$A$</span> is the identity matrix with zero entries in all reset dimensions, and the translation vector <span>$b$</span> is zero in all other dimensions.</p><p><strong>Fields</strong></p><ul><li><code>X</code>      – convex set</li><li><code>resets</code> – resets (a mapping from an index to a new value)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X = BallInf([2.0, 2.0, 2.0], 1.0);

julia&gt; r = Dict(1 =&gt; 4.0, 3 =&gt; 0.0);

julia&gt; rm = ResetMap(X, r);
</code></pre><p>Here <code>rm</code> modifies the set <code>X</code> such that <code>x1</code> is reset to 4 and <code>x3</code> is reset to 0, while <code>x2</code> is not modified. Hence <code>rm</code> is equivalent to the set <code>Hyperrectangle([4.0, 2.0, 0.0], [0.0, 1.0, 0.0])</code>, i.e., an axis-aligned line segment embedded in 3D.</p><p>The corresponding affine map <span>$A x + b$</span> would be:</p><div>\[    egin{pmatrix} 0 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 0 nd{pmatrix} x +
    egin{pmatrix} 4 &amp; 0 &amp; 0 nd{pmatrix}\]</div><p>Use the function <code>get_A</code> (resp. <code>get_b</code>) to create the matrix <code>A</code> (resp. vector <code>b</code>) corresponding to a given reset map.</p><pre><code class="language-julia-repl">julia&gt; get_A(rm)
3×3 LinearAlgebra.Diagonal{Float64,Array{Float64,1}}:
 0.0   ⋅    ⋅
  ⋅   1.0   ⋅
  ⋅    ⋅   0.0

julia&gt; get_b(rm)
3-element SparseArrays.SparseVector{Float64,Int64} with 1 stored entry:
  [1]  =  4.0</code></pre><p>The application of a <code>ResetMap</code> to a <code>ZeroSet</code> or an <code>EmptySet</code> is simplified automatically.</p><pre><code class="language-julia-repl">julia&gt; ResetMap(ZeroSet(3), r)
Singleton{Float64,SparseArrays.SparseVector{Float64,Int64}}(  [1]  =  4.0)

julia&gt; ResetMap(EmptySet(), r)
EmptySet{Float64}()</code></pre><p>The (in this case unique) support vector of <code>rm</code> in direction <code>ones(3)</code> is:</p><pre><code class="language-julia-repl">julia&gt; σ(ones(3), rm)
3-element Array{Float64,1}:
 4.0
 3.0
 0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ResetMap.jl#L7-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{ResetMap}" href="#LazySets.dim-Tuple{ResetMap}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(rm::ResetMap)</code></pre><p>Return the dimension of a reset map.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map</li></ul><p><strong>Output</strong></p><p>The dimension of a reset map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ResetMap.jl#L158-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ResetMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ResetMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, rm::ResetMap{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a reset map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>rm</code> – reset map</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p><p><strong>Notes</strong></p><p>We use the usual dot-product definition, but for unbounded sets we redefine the product between <span>$0$</span> and <span>$±∞$</span> as <span>$0$</span>; Julia returns <code>NaN</code> here.</p><pre><code class="language-julia-repl">julia&gt; Inf * 0.0
NaN</code></pre><p>See the discussion <a href="https://math.stackexchange.com/questions/28940/why-is-infty-cdot-0-not-clearly-equal-to-0">here</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ResetMap.jl#L198-L224">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ResetMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ResetMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, rm::ResetMap{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a reset map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>rm</code> – reset map</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ResetMap.jl#L175-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{ResetMap}" href="#LazySets.an_element-Tuple{ResetMap}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(rm::ResetMap)</code></pre><p>Return some element of a reset map.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map</li></ul><p><strong>Output</strong></p><p>An element in the reset map. It relies on the <code>an_element</code> function of the wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ResetMap.jl#L229-L242">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{ResetMap}" href="#Base.isempty-Tuple{ResetMap}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(rm::ResetMap)::Bool</code></pre><p>Return if a reset map is empty or not.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ResetMap.jl#L247-L259">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.get_A-Union{Tuple{ResetMap{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.get_A-Union{Tuple{ResetMap{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.get_A</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_A(rm::ResetMap{N}) where {N&lt;:Real}</code></pre><p>Return the <span>$A$</span> matrix of the affine map <span>$A x + b, x ∈ X$</span> represented by a reset map.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map</li></ul><p><strong>Output</strong></p><p>The (diagonal) matrix for the affine map <span>$A x + b, x ∈ X$</span> represented by the reset map.</p><p><strong>Algorithm</strong></p><p>We construct the identity matrix and set all entries in the reset dimensions to zero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ResetMap.jl#L96-L115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.get_b-Union{Tuple{ResetMap{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.get_b-Union{Tuple{ResetMap{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.get_b</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_b(rm::ResetMap{N}) where {N&lt;:Real}</code></pre><p>Return the <span>$b$</span> vector of the affine map <span>$A x + b, x ∈ X$</span> represented by a reset map.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map</li></ul><p><strong>Output</strong></p><p>The (sparse) vector for the affine map <span>$A x + b, x ∈ X$</span> represented by the reset map. The vector contains the reset value for all reset dimensions, and is zero for all other dimensions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ResetMap.jl#L125-L141">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{ResetMap{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{ResetMap{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(rm::ResetMap{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of a polytopic reset map.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map of a polytope</li></ul><p><strong>Output</strong></p><p>The list of constraints of the reset map.</p><p><strong>Notes</strong></p><p>We assume that the underlying set <code>X</code> is a polytope, i.e., is bounded and offers a method <code>constraints_list(X)</code>.</p><p><strong>Algorithm</strong></p><p>We fall back to <code>constraints_list</code> of a <code>LinearMap</code> of the <code>A</code>-matrix in the affine-map view of a reset map. Each reset dimension <span>$i$</span> is projected to zero, expressed by two constraints for each reset dimension. Then it remains to shift these constraints to the new value.</p><p>For instance, if the dimension <span>$5$</span> was reset to <span>$4$</span>, then there will be constraints <span>$x₅ ≤ 0$</span> and <span>$-x₅ ≤ 0$</span>. We then modify the right-hand side of these constraints to <span>$x₅ ≤ 4$</span> and <span>$-x₅ ≤ -4$</span>, respectively.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ResetMap.jl#L264-L294">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{ResetMap{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:AbstractHyperrectangle where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{ResetMap{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:AbstractHyperrectangle where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(rm::ResetMap{N, S}) where
    {N&lt;:Real, S&lt;:AbstractHyperrectangle}</code></pre><p>Return the list of constraints of a hyperrectangular reset map.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map of a hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The list of constraints of the reset map.</p><p><strong>Algorithm</strong></p><p>We iterate through all dimensions. If there is a reset, we construct the corresponding (flat) constraints. Otherwise, we construct the corresponding constraints of the underlying set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/ResetMap.jl#L336-L355">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LazySets.isbounded-Tuple{LinearMap}"><code>isbounded</code></a></li><li><a href="../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../interfaces/#LazySets.diameter"><code>diameter</code></a></li></ul><h3><a class="nav-anchor" id="Translation-1" href="#Translation-1">Translation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Translation" href="#LazySets.Translation"><code>LazySets.Translation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Translation{N&lt;:Real, VN&lt;:AbstractVector{N}, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents a lazy translation.</p><p>The translation of set <code>X</code> along vector <code>v</code> is the map:</p><div>\[x ↦ x + v,\qquad x ∈ X\]</div><p>A translation is a special case of an affine map <span>$A x + b, x ∈ X$</span> where the linear map <span>$A$</span> is the identity matrix and the translation vector <span>$b = v$</span>.</p><p><strong>Fields</strong></p><ul><li><code>X</code> – convex set</li><li><code>v</code> – vector that defines the translation</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; X = BallInf([2.0, 2.0, 2.0], 1.0);

julia&gt; v = [1.0, 0.0, 0.0]; # translation along dimension 1

julia&gt; tr = Translation(X, v);

julia&gt; typeof(tr)
Translation{Float64,Array{Float64,1},BallInf{Float64}}

julia&gt; tr.X
BallInf{Float64}([2.0, 2.0, 2.0], 1.0)

julia&gt; tr.v
3-element Array{Float64,1}:
 1.0
 0.0
 0.0</code></pre><p>The sum operator <code>+</code> is overloaded to create translations:</p><pre><code class="language-julia-repl">julia&gt; X + v == Translation(X, v)
true</code></pre><p>And so does the Minkowski sum operator, <code>⊕</code>:</p><pre><code class="language-julia-repl">julia&gt; X ⊕ v == Translation(X, v)
true</code></pre><p>The translation of a translation is performed immediately:</p><pre><code class="language-julia-repl">julia&gt; tr = (X+v)+v
Translation{Float64,Array{Float64,1},BallInf{Float64}}(BallInf{Float64}([2.0, 2.0, 2.0], 1.0), [2.0, 0.0, 0.0])

julia&gt; tr.v
3-element Array{Float64,1}:
 2.0
 0.0
 0.0</code></pre><p>The dimension of a translation is obtained with the <code>dim</code> function:</p><pre><code class="language-julia-repl">julia&gt; dim(tr)
3</code></pre><p>For the support vector (resp. support function) along vector <code>d</code>, use <code>σ</code> and <code>ρ</code> respectively:</p><pre><code class="language-julia-repl">julia&gt; σ([1.0, 0.0, 0.0], tr)
3-element Array{Float64,1}:
 5.0
 3.0
 3.0

julia&gt; ρ([1.0, 0.0, 0.0], tr)
5.0</code></pre><p>See the docstring of each of these functions for details.</p><p>The <code>an_element</code> function is useful to obtain an element of a translation:</p><pre><code class="language-julia-repl">julia&gt; e = an_element(tr)
3-element Array{Float64,1}:
 4.0
 2.0
 2.0</code></pre><p>The lazy linear map of a translation is an affine map, since the following simplification rule applies: <span>$M * (X ⊕ v) = (M * X) ⊕ (M * v)$</span>:</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra: I

julia&gt; M = Matrix(2.0I, 3, 3);

julia&gt; Q = M * tr;

julia&gt; Q isa AffineMap &amp;&amp; Q.M == M &amp;&amp; Q.X == tr.X &amp;&amp; Q.v == 2 * tr.v
true</code></pre><p>Use the <code>isempty</code> method to query if the translation is empty; it falls back to the <code>isempty</code> method of the wrapped set:</p><pre><code class="language-julia-repl">julia&gt; isempty(tr)
false</code></pre><p>The list of constraints of the translation of a polyhedron (in general, a set whose <code>constraints_list</code> is available) can be computed from a lazy translation:</p><pre><code class="language-julia-repl">julia&gt; constraints_list(tr)
6-element Array{HalfSpace{Float64,VN} where VN&lt;:AbstractArray{Float64,1},1}:
 HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([1.0, 0.0, 0.0], 5.0)
 HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([0.0, 1.0, 0.0], 3.0)
 HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([0.0, 0.0, 1.0], 3.0)
 HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([-1.0, 0.0, 0.0], -3.0)
 HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([0.0, -1.0, 0.0], -1.0)
 HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([0.0, 0.0, -1.0], -1.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Translation.jl#L8-L141">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{LazySet,AbstractArray{T,1} where T}" href="#Base.:+-Tuple{LazySet,AbstractArray{T,1} where T}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">+(X::LazySet, v::AbstractVector)</code></pre><p>Convenience constructor for a translation.</p><p><strong>Input</strong></p><ul><li><code>X</code> – convex set</li><li><code>v</code> – vector</li></ul><p><strong>Output</strong></p><p>The symbolic translation of <span>$X$</span> along vector <span>$v$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Translation.jl#L159-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.:⊕-Tuple{LazySet,AbstractArray{T,1} where T}" href="#LazySets.:⊕-Tuple{LazySet,AbstractArray{T,1} where T}"><code>LazySets.:⊕</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">⊕(X::LazySet, v::AbstractVector)</code></pre><p>Unicode alias constructor ⊕ (<code>oplus</code>) for the lazy translation operator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Translation.jl#L178-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{Translation}" href="#LazySets.dim-Tuple{Translation}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(tr::Translation)::Int</code></pre><p>Return the dimension of a translation.</p><p><strong>Input</strong></p><ul><li><code>tr</code> – translation</li></ul><p><strong>Output</strong></p><p>The dimension of a translation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Translation.jl#L200-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, tr::Translation{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a translation.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>tr</code> – translation</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Translation.jl#L236-L249">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, tr::Translation{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a translation.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>tr</code> – translation</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Translation.jl#L217-L231">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{Translation}" href="#LazySets.an_element-Tuple{Translation}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(tr::Translation)</code></pre><p>Return some element of a translation.</p><p><strong>Input</strong></p><ul><li><code>tr</code> – translation</li></ul><p><strong>Output</strong></p><p>An element in the translation.</p><p><strong>Notes</strong></p><p>This function first asks for <code>an_element</code> function of the wrapped set, then translates this element according to the given translation vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Translation.jl#L254-L271">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{Translation}" href="#Base.isempty-Tuple{Translation}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(tr::Translation)::Bool</code></pre><p>Return if a translation is empty or not.</p><p><strong>Input</strong></p><ul><li><code>tr</code> – translation</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Translation.jl#L276-L288">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(tr::Translation{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of the translation of a set.</p><p><strong>Input</strong></p><ul><li><code>tr</code> – lazy translation of a polyhedron</li></ul><p><strong>Output</strong></p><p>The list of constraints of the translation.</p><p><strong>Notes</strong></p><p>We assume that the set wrapped by the lazy translation <code>X</code> offers a method <code>constraints_list(⋅)</code>.</p><p><strong>Algorithm</strong></p><p>Let the translation be defined by the set of points <code>y</code> such that <code>y = x + v</code> for all <code>x ∈ X</code>. Then, each defining halfspace <code>a⋅x ≤ b</code> is transformed to <code>a⋅y ≤ b + a⋅v</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Translation.jl#L293-L316">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, tr::Translation{N}) where {N&lt;:Real}</code></pre><p>Concrete linear map of a polyhedron in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>M</code>  – matrix</li><li><code>tr</code> – translation of a convex set</li></ul><p><strong>Output</strong></p><p>A concrete set corresponding to the linear map. The type of the result depends on the type of the set wrapped by <code>tr</code>.</p><p><strong>Algorithm</strong></p><p>We compute <code>translate(linear_map(M, tr.X), M * tr.v)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Translation.jl#L356-L374">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, tr::Translation{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in the translation of a convex set.</p><p><strong>Input</strong></p><ul><li><code>x</code>  – point/vector</li><li><code>tr</code> – translation of a convex set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ tr$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation relies on the set membership function for the wrapped set <code>tr.X</code>, since <span>$x ∈ X ⊕ v$</span> iff <span>$x - v ∈ X$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Translation.jl#L333-L351">source</a></section><h3><a class="nav-anchor" id="Affine-Map-1" href="#Affine-Map-1">Affine Map</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AffineMap" href="#LazySets.AffineMap"><code>LazySets.AffineMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AffineMap{N&lt;:Real, S&lt;:LazySet{N}, NM, MAT&lt;:AbstractMatrix{NM},
          VN&lt;:AbstractVector{NM}} &lt;: LazySet{N}</code></pre><p>Type that represents an affine transformation <span>$M⋅X ⊕ v$</span> of a convex set <span>$X$</span>.</p><p><strong>Fields</strong></p><ul><li><code>M</code> – matrix/linear map</li><li><code>X</code> – convex set</li><li><code>v</code> – translation vector</li></ul><p><strong>Notes</strong></p><p>An affine map is the composition of a linear map and a translation. This type is parametric in the coefficients of the linear map, <code>NM</code>, which may be different from the numeric type of the wrapped set (<code>N</code>). However, the numeric type of the translation vector should be <code>NM</code>.</p><p><strong>Examples</strong></p><p>For the examples we create a <span>$3×2$</span> matrix, a two-dimensional unit square, and a three-dimensional vector. Then we combine them in an <code>AffineMap</code>.</p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 1 3; 1 4]; X = BallInf([0, 0], 1); b2 = [1, 2]; b3 = [1, 2, 3];

julia&gt; AffineMap(A, X, b3)
AffineMap{Int64,BallInf{Int64},Int64,Array{Int64,2},Array{Int64,1}}([1 2; 1 3; 1 4], BallInf{Int64}([0, 0], 1), [1, 2, 3])</code></pre><p>For convenience, <code>A</code> does not need to be a matrix but we also allow to use <code>UniformScaling</code>s resp. scalars (interpreted as a scaling, i.e., a scaled identity matrix). Scaling by <span>$1$</span> is ignored and simplified to a pure <code>Translation</code>.</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra

julia&gt; am = AffineMap(2I, X, b2)
AffineMap{Int64,BallInf{Int64},Int64,Diagonal{Int64,Array{Int64,1}},Array{Int64,1}}([2 0; 0 2], BallInf{Int64}([0, 0], 1), [1, 2])

julia&gt; AffineMap(2, X, b2) == am
true

julia&gt; AffineMap(1, X, b2)
Translation{Int64,Array{Int64,1},BallInf{Int64}}(BallInf{Int64}([0, 0], 1), [1, 2])</code></pre><p>Applying a linear map to an <code>AffineMap</code> object combines the two maps into a new <code>AffineMap</code> instance. Again we can make use of the conversion for convenience.</p><pre><code class="language-julia-repl">julia&gt; B = [2 0; 0 2]; am2 = B * am
AffineMap{Int64,BallInf{Int64},Int64,Array{Int64,2},Array{Int64,1}}([4 0; 0 4], BallInf{Int64}([0, 0], 1), [2, 4])

julia&gt; 2 * am == am2
true</code></pre><p>The application of an <code>AffineMap</code> to a <code>ZeroSet</code> or an <code>EmptySet</code> is simplified automatically.</p><pre><code class="language-julia-repl">julia&gt; AffineMap(A, ZeroSet{Int}(2), b3)
Singleton{Int64,Array{Int64,1}}([1, 2, 3])

julia&gt; AffineMap(A, EmptySet{Int}(), b3)
EmptySet{Int64}()</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/AffineMap.jl#L12-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{AffineMap}" href="#LazySets.dim-Tuple{AffineMap}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(am::AffineMap)::Int</code></pre><p>Return the dimension of an affine map.</p><p><strong>Input</strong></p><ul><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>The dimension of an affine map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/AffineMap.jl#L153-L165">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, am::AffineMap{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of an affine map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/AffineMap.jl#L170-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, am::AffineMap{N}) where {N&lt;:Real}</code></pre><p>Return the support function of an affine map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/AffineMap.jl#L188-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{AffineMap}" href="#LazySets.an_element-Tuple{AffineMap}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(am::AffineMap)</code></pre><p>Return some element of an affine map.</p><p><strong>Input</strong></p><ul><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>An element of the affine map. It relies on the <code>an_element</code> function of the wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/AffineMap.jl#L206-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{AffineMap}" href="#Base.isempty-Tuple{AffineMap}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(am::AffineMap)::Bool</code></pre><p>Return whether an affine map is empty or not.</p><p><strong>Input</strong></p><ul><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty and the affine vector is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/AffineMap.jl#L224-L236">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{AffineMap}" href="#LazySets.isbounded-Tuple{AffineMap}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(am::AffineMap; cond_tol::Number=DEFAULT_COND_TOL)::Bool</code></pre><p>Determine whether an affine map is bounded.</p><p><strong>Input</strong></p><ul><li><code>am</code>       – affine map</li><li><code>cond_tol</code> – (optional) tolerance of matrix condition (used to check whether               the matrix is invertible)</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the affine map is bounded.</p><p><strong>Algorithm</strong></p><p>We first check if the matrix is zero or the wrapped set is bounded. If not, we perform a sufficient check whether the matrix is invertible. If the matrix is invertible, then the map being bounded is equivalent to the wrapped set being bounded, and hence the map is unbounded. Otherwise, we check boundedness via <a href="../interfaces/#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>isbounded_unit_dimensions</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/AffineMap.jl#L241-L263">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, am::AffineMap{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in the affine map of a convex set.</p><p><strong>Input</strong></p><ul><li><code>x</code>  – point/vector</li><li><code>am</code> – affine map of a convex set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ am$</span>.</p><p><strong>Algorithm</strong></p><p>Note that <span>$x ∈ M⋅S ⊕ v$</span> iff <span>$M^{-1}⋅(x - v) ∈ S$</span>. This implementation does not explicitly invert the matrix, which is why it also works for non-square matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; am = AffineMap([2.0 0.0; 0.0 1.0], BallInf([1., 1.], 1.), [-1.0, -1.0]);

julia&gt; [5.0, 1.0] ∈ am
false

julia&gt; [3.0, 1.0] ∈ am
true</code></pre><p>An example with a non-square matrix:</p><pre><code class="language-julia-repl">julia&gt; B = BallInf(zeros(4), 1.);

julia&gt; M = [1. 0 0 0; 0 1 0 0]/2;

julia&gt; [0.5, 0.5] ∈ M*B
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/AffineMap.jl#L274-L316">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(am::AffineMap{N};
              [apply_convex_hull]::Bool)::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a (polyhedral) affine map.</p><p><strong>Input</strong></p><ul><li><code>am</code>                – affine map</li><li><code>apply_convex_hull</code> – (optional, default: <code>true</code>) if <code>true</code>, apply the convex                        hull operation to the list of vertices transformed by the                        affine map </li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>This implementation computes all vertices of <code>X</code>, then transforms them through the affine map, i.e. <code>x ↦ M*x + v</code> for each vertex <code>x</code> of <code>X</code>. By default, the convex hull operation is taken before returning this list. For dimensions three or higher, this operation relies on the functionality through the concrete polyhedra library <code>Polyhedra.jl</code>.</p><p>If you are not interested in taking the convex hull of the resulting vertices under the affine map, pass <code>apply_convex_hull=false</code> as a keyword argument.</p><p>Note that we assume that the underlying set <code>X</code> is polyhedral, either concretely or lazily, i.e. there the function <code>vertices_list</code> should be applicable.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/AffineMap.jl#L321-L351">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(am::AffineMap{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of a (polyhedral) affine map.</p><p><strong>Input</strong></p><ul><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>The list of constraints of the affine map.</p><p><strong>Notes</strong></p><p>We assume that the underlying set <code>X</code> is polyhedral, i.e., offers a method <code>constraints_list(X)</code>.</p><p><strong>Algorithm</strong></p><p>Falls back to the list of constraints of the translation of a lazy linear map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/AffineMap.jl#L364-L385">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, am::AffineMap{N}) where {N&lt;:Real}</code></pre><p>Return the linear map of a lazy affine map.</p><p><strong>Input</strong></p><ul><li><code>M</code>  – matrix</li><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>A set corresponding to the linear map of the lazy affine map of a set.  </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/AffineMap.jl#L390-L403">source</a></section><h2><a class="nav-anchor" id="Symmetric-Interval-Hull-1" href="#Symmetric-Interval-Hull-1">Symmetric Interval Hull</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.SymmetricIntervalHull" href="#LazySets.SymmetricIntervalHull"><code>LazySets.SymmetricIntervalHull</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SymmetricIntervalHull{N&lt;:Real, S&lt;:LazySet{N}} &lt;: AbstractHyperrectangle{N}</code></pre><p>Type that represents the symmetric interval hull of a compact convex set.</p><p><strong>Fields</strong></p><ul><li><code>X</code>     – compact convex set</li><li><code>cache</code> – partial storage of already computed bounds, organized as mapping   from dimension to tuples <code>(bound, valid)</code>, where <code>valid</code> is a flag   indicating if the <code>bound</code> entry has been computed</li></ul><p><strong>Notes</strong></p><p>The symmetric interval hull can be computed with <span>$2n$</span> support vector queries of unit vectors, where <span>$n$</span> is the dimension of the wrapped set (i.e., two queries per dimension). When asking for the support vector for a direction <span>$d$</span>, one needs <span>$2k$</span> such queries, where <span>$k$</span> is the number of non-zero entries in <span>$d$</span>.</p><p>However, if one asks for many support vectors in a loop, the number of computations may exceed <span>$2n$</span>. To be most efficient in such cases, this type stores the intermediately computed bounds in the <code>cache</code> field.</p><p>The set <code>X</code> must be compact.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/SymmetricIntervalHull.jl#L4-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{SymmetricIntervalHull}" href="#LazySets.dim-Tuple{SymmetricIntervalHull}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(sih::SymmetricIntervalHull)::Int</code></pre><p>Return the dimension of a symmetric interval hull of a convex set.</p><p><strong>Input</strong></p><ul><li><code>sih</code> – symmetric interval hull of a convex set</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the symmetric interval hull of a convex set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/SymmetricIntervalHull.jl#L143-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},SymmetricIntervalHull{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},SymmetricIntervalHull{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, sih::SymmetricIntervalHull{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a symmetric interval hull of a convex set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>sih</code> – symmetric interval hull of a convex set</li></ul><p><strong>Output</strong></p><p>The support vector of the symmetric interval hull of a convex set in the given direction. If the direction has norm zero, the origin is returned.</p><p><strong>Algorithm</strong></p><p>For each non-zero entry in <code>d</code> we need to either look up the bound (if it has been computed before) or compute it, in which case we store it for future queries. One such computation just asks for the support vector of the underlying set for both the positive and negative unit vector in the respective dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/SymmetricIntervalHull.jl#L160-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Union{Tuple{SymmetricIntervalHull{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.center-Union{Tuple{SymmetricIntervalHull{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">center(sih::SymmetricIntervalHull{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a symmetric interval hull of a convex set.</p><p><strong>Input</strong></p><ul><li><code>sih</code> – symmetric interval hull of a convex set</li></ul><p><strong>Output</strong></p><p>The origin.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/SymmetricIntervalHull.jl#L122-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{SymmetricIntervalHull{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{SymmetricIntervalHull{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">radius_hyperrectangle(sih::SymmetricIntervalHull{N}
                     )::Vector{N} where {N&lt;:Real}</code></pre><p>Return the box radius of a symmetric interval hull of a convex set in every dimension.</p><p><strong>Input</strong></p><ul><li><code>sih</code> – symmetric interval hull of a convex set</li></ul><p><strong>Output</strong></p><p>The box radius of the symmetric interval hull of a convex set.</p><p><strong>Notes</strong></p><p>This function computes the symmetric interval hull explicitly.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/SymmetricIntervalHull.jl#L90-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{SymmetricIntervalHull{N,S} where S&lt;:LazySet{N},Int64}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{SymmetricIntervalHull{N,S} where S&lt;:LazySet{N},Int64}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">radius_hyperrectangle(sih::SymmetricIntervalHull{N},
                      i::Int)::N where {N&lt;:Real}</code></pre><p>Return the box radius of a symmetric interval hull of a convex set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>sih</code> – symmetric interval hull of a convex set</li><li><code>i</code>   – dimension of interest</li></ul><p><strong>Output</strong></p><p>The radius in the given dimension. If it was computed before, this is just a look-up, otherwise it requires two support vector computations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/SymmetricIntervalHull.jl#L67-L84">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../interfaces/#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.isbounded-Tuple{AbstractPolytope}"><code>isbounded</code></a></li><li><a href="../interfaces/#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>singleton_list</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractCentrallySymmetricPolytope"><code>AbstractCentrallySymmetricPolytope</code></a>:</p><ul><li><a href="../interfaces/#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}"><code>isempty</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractZonotope"><code>AbstractZonotope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.ngens-Tuple{AbstractZonotope}"><code>ngens</code></a></li><li><a href="../interfaces/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractZonotope{N}}} where N&lt;:Real"><code>linear_map</code></a></li><li><a href="../interfaces/#LazySets.order-Tuple{AbstractZonotope}"><code>order</code></a></li><li><a href="../interfaces/#LazySets.translate-Union{Tuple{N}, Tuple{AbstractZonotope{N},AbstractArray{N,1}}} where N&lt;:Real"><code>translate</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractHyperrectangle"><code>AbstractHyperrectangle</code></a>:</p><ul><li><a href="../interfaces/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>ρ</code></a></li><li><a href="../interfaces/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>σ</code></a></li><li><a href="../interfaces/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>∈</code></a></li><li><a href="../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../interfaces/#LazySets.constraints_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>constraints_list</code></a></li><li><a href="../interfaces/#LazySets.vertices_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>vertices_list</code></a></li><li><a href="../interfaces/#LazySets.high-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>high</code></a></li><li><a href="../interfaces/#LazySets.low-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>low</code></a></li><li><a href="../interfaces/#LazySets.generators-Tuple{AbstractHyperrectangle}"><code>generators</code></a></li><li><a href="../interfaces/#LazySets.genmat-Tuple{AbstractHyperrectangle}"><code>genmat</code></a></li></ul><h2><a class="nav-anchor" id="Union-1" href="#Union-1">Union</a></h2><p>Note that the union of convex sets is generally not convex. Hence these set types are not part of the convex-set family <code>LazySet</code>.</p><h3><a class="nav-anchor" id="Binary-Set-Union-1" href="#Binary-Set-Union-1">Binary Set Union</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.UnionSet" href="#LazySets.UnionSet"><code>LazySets.UnionSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">UnionSet{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}}</code></pre><p>Type that represents the set union of two convex sets.</p><p><strong>Fields</strong></p><ul><li><code>X</code> – convex set</li><li><code>Y</code> – convex set</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L12-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∪-Tuple{LazySet,LazySet}" href="#Base.:∪-Tuple{LazySet,LazySet}"><code>Base.:∪</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∪</code></pre><p>Alias for <code>UnionSet</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L42-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.swap-Tuple{UnionSet}" href="#LazySets.swap-Tuple{UnionSet}"><code>LazySets.swap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">swap(cup::UnionSet)</code></pre><p>Return a new <code>UnionSet</code> object with the arguments swapped.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of two convex sets</li></ul><p><strong>Output</strong></p><p>A new <code>UnionSet</code> object with the arguments swapped.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L49-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{UnionSet}" href="#LazySets.dim-Tuple{UnionSet}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(cup::UnionSet)::Int</code></pre><p>Return the dimension of the set union of two convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of two convex sets</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the union of two convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L66-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, cup::UnionSet{N}; [algorithm]=&quot;support_vector&quot;) where {N&lt;:Real}</code></pre><p>Return the support vector of the union of two convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>         – direction</li><li><code>cup</code>       – union of two convex sets</li><li><code>algorithm</code> – (optional, default: &quot;support<em>vector&quot;): the algorithm to compute                the support vector; if &quot;support</em>vector&quot;, use the support                vector of each argument; if &quot;support_function&quot; use the support                function of each argument and evaluate the support vector of only                one of them</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>The support vector of the union of two convex sets <span>$X$</span> and <span>$Y$</span> can be obtained as the vector that maximizes the support function of either <span>$X$</span> or <span>$Y$</span>, i.e. it is sufficient to find the <span>$\argmax(ρ(d, X), ρ(d, Y)])$</span> and evaluate its support vector.</p><p>The default implementation, with option <code>algorithm=&quot;support_vector&quot;</code>, computes the support vector of <span>$X$</span> and <span>$Y$</span> and then compares the support function using a dot product. If it happens that the support function can be more efficiently computed (without passing through the support vector), consider using the alternative <code>algorithm=&quot;support_function&quot;</code> implementation, which evaluates the support function of each set directly and then calls only the support vector of either <span>$X$</span> <em>or</em> <span>$Y$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L83-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, cup::UnionSet{N}) where {N&lt;:Real}</code></pre><p>Return the support function of the union of two convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cup</code> – union of two convex sets</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p><p><strong>Algorithm</strong></p><p>The support function of the union of two convex sets <span>$X$</span> and <span>$Y$</span> is the maximum of the support functions of <span>$X$</span> and <span>$Y$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L130-L148">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(cup::UnionSet{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a union of two convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of two convex sets</li></ul><p><strong>Output</strong></p><p>An element in the union of two convex sets.</p><p><strong>Algorithm</strong></p><p>We use <code>an_element</code> on the first wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L154-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, cup::UnionSet{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a union of two convex sets.</p><p><strong>Input</strong></p><ul><li><code>x</code>   – point/vector</li><li><code>cup</code> – union of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ cup$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L175-L188">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{UnionSet}" href="#Base.isempty-Tuple{UnionSet}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(cup::UnionSet)::Bool</code></pre><p>Check whether a union of two convex sets is empty.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the union is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L193-L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{UnionSet}" href="#LazySets.isbounded-Tuple{UnionSet}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(cup::UnionSet)::Bool</code></pre><p>Determine whether a union of two convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the union is bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L210-L222">source</a></section><h3><a class="nav-anchor" id="n-ary-Set-Union-1" href="#n-ary-Set-Union-1"><span>$n$</span>-ary Set Union</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.UnionSetArray" href="#LazySets.UnionSetArray"><code>LazySets.UnionSetArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">UnionSetArray{N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Type that represents the set union of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><code>array</code> – array of convex sets</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L231-L239">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{UnionSetArray}" href="#LazySets.dim-Tuple{UnionSetArray}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(cup::UnionSetArray)::Int</code></pre><p>Return the dimension of the set union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the union of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L253-L265">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.array-Union{Tuple{UnionSetArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real" href="#LazySets.array-Union{Tuple{UnionSetArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">array(cup::UnionSetArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array that holds the union of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L270-L282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSetArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSetArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, cup::UnionSetArray{N}; [algorithm]=&quot;support_vector&quot;) where {N&lt;:Real}</code></pre><p>Return the support vector of the union of a finite number of convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>         – direction</li><li><code>cup</code>       – union of a finite number of convex sets</li><li><code>algorithm</code> – (optional, default: &quot;support<em>vector&quot;): the algorithm to compute                the support vector; if &quot;support</em>vector&quot;, use the support                vector of each argument; if &quot;support_function&quot; use the support                function of each argument and evaluate the support vector of only                one of them</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>The support vector of the union of a finite number of convex sets <span>$X₁, X₂, ...$</span> can be obtained as the vector that maximizes the support function, i.e. it is sufficient to find the <span>$\argmax(ρ(d, X₂), ρ(d, X₂), ...])$</span> and evaluate its support vector.</p><p>The default implementation, with option <code>algorithm=&quot;support_vector&quot;</code>, computes the support vector of all <span>$X₁, X₂, ...$</span> and then compares the support function using a dot product. If it happens that the support function can be more efficiently computed (without passing through the support vector), consider using the alternative <code>algorithm=&quot;support_function&quot;</code> implementation, which evaluates the support function of each set directly and then calls only the support vector of one of the <span>$Xᵢ$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L287-L320">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSetArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSetArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, cup::UnionSetArray{N}) where {N&lt;:Real}</code></pre><p>Return the support function of the union of a finite number of convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p><p><strong>Algorithm</strong></p><p>The support function of the union of a finite number of convex sets <span>$X₁, X₂, ...$</span> can be obtained as the maximum of <span>$ρ(d, X₂), ρ(d, X₂), ...$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L337-L356">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{UnionSetArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{UnionSetArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(cup::UnionSetArray{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>An element in the union of a finite number of convex sets.</p><p><strong>Algorithm</strong></p><p>We use <code>an_element</code> on the first wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L363-L379">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSetArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSetArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, cup::UnionSetArray{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>x</code>   – point/vector</li><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ cup$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L384-L398">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{UnionSetArray}" href="#Base.isempty-Tuple{UnionSetArray}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(cup::UnionSetArray)::Bool</code></pre><p>Check whether a union of a finite number of convex sets is empty.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the union is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L403-L415">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{UnionSetArray}" href="#LazySets.isbounded-Tuple{UnionSetArray}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(cup::UnionSetArray)::Bool</code></pre><p>Determine whether a union of a finite number of convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the union is bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/UnionSet.jl#L420-L432">source</a></section><h2><a class="nav-anchor" id="Complement-1" href="#Complement-1">Complement</a></h2><p>Note that the complement of a convex set is generally not convex. Hence this set type is not part of the convex-set family <code>LazySet</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Complement" href="#LazySets.Complement"><code>LazySets.Complement</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Complement{N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Type that represents the complement of a convex set.</p><p><strong>Fields</strong></p><ul><li><code>X</code> – convex set</li></ul><p><strong>Notes</strong></p><p>Since <code>X</code> is assumed to be closed, unless <code>X</code> is empty or the universe, its complement is open (i.e., not closed). Since <code>X</code> is assumed to be closed, unless <code>X</code> is empty, the universe, or a half-space, its complement is not convex.</p><p>The complement of the complement is the original set again.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = BallInf(zeros(2), 1.); C = Complement(B)
Complement{Float64,BallInf{Float64}}(BallInf{Float64}([0.0, 0.0], 1.0))

julia&gt; Complement(C)
BallInf{Float64}([0.0, 0.0], 1.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Complement.jl#L6-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{Complement}" href="#LazySets.dim-Tuple{Complement}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(C::Complement)</code></pre><p>Return the dimension of the complement of a convex set.</p><p><strong>Input</strong></p><ul><li><code>C</code> – complement of a convex set</li></ul><p><strong>Output</strong></p><p>The dimension of the complement of a convex set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Complement.jl#L41-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Complement{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Complement{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, C::Complement{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in the complement of a convex set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>C</code> – complement of a convex set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the vector is contained in the complement.</p><p><strong>Algorithm</strong></p><div>\[    x ∈ X^C ⟺ x ∉ X\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Complement.jl#L58-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{Complement}" href="#Base.isempty-Tuple{Complement}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(C::Complement)::Bool</code></pre><p>Return if the complement of a convex set is empty or not.</p><p><strong>Input</strong></p><ul><li><code>C</code> – complement of a convex set</li></ul><p><strong>Output</strong></p><p><code>false</code> unless the original set is universal.</p><p><strong>Algorithm</strong></p><p>We use the <code>isuniversal</code> method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Complement.jl#L83-L99">source</a></section><h2><a class="nav-anchor" id="Rectification-1" href="#Rectification-1">Rectification</a></h2><p>Note that the rectification of a convex set is generally not convex. Hence this set type is not part of the convex-set family <code>LazySet</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Rectification" href="#LazySets.Rectification"><code>LazySets.Rectification</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Rectification{N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Type that represents the rectification of a convex set.</p><p><strong>Fields</strong></p><ul><li><code>X</code>     – convex set</li><li><code>cache</code> – storage of information computed before</li></ul><p><strong>Notes</strong></p><p>Given a vector <span>$v = (v_1, …, v_n)$</span>, its rectification is defined as <span>$\text{rectify}(v) = (v_1&#39;, …, v_n&#39;)$</span> such that <span>$v_i&#39; = \max(v_i, 0)$</span> for each <span>$i = 1, …, n$</span>.</p><p>The extension to a set <span>$X$</span> is defined elementwise:</p><div>\[    \text{rectify}(X) = \{\text{rectify}(x) \mid x ∈ X\}\]</div><p>The rectification of a convex set <span>$X$</span> is not necessarily convex. It can be expressed exactly as the union of the intersection of <span>$X$</span> with the nonnegative orthant and the projection of the intersection of <span>$X$</span> with each other orthant. This can be seen as follows.</p><p>First we observe that rectification distributes with union.</p><div>\[    \text{rectify}(X_1 ∪ … ∪ X_m) = ⋃_j \text{rectify}(X_j)\]</div><p>Next we express <span>$X$</span> as the union of the intersection of <span>$X$</span> with each orthant <span>$O$</span>.</p><div>\[    X = ⋃_j (X ∩ O_j)\]</div><p>Thus we have</p><div>\[    \text{rectify}(X) = \text{rectify}((X ∩ O_1) ∪ … ∪ (X ∩ O_m)) = ⋃_j \text{rectify}(X ∩ O_j).\]</div><p>Clearly, <span>$\text{rectify}(X ∩ O_j) = X$</span> if <span>$O_j$</span> is the nonnegative orthant.</p><p>For example, consider a two-dimensional case and call the orthants <span>$O_1, …, O_4$</span> in clockwise fashion, starting with the nonnegative orthant. We conclude that</p><div>\[    \text{rectify}(X) = (X ∩ O_1) ∪ \text{rectify}(X ∩ O_2) ∪ \text{rectify}(X ∩ O_3) ∪ \text{rectify}(X ∩ O_4).\]</div><p>The rectification of the intersection in the nonpositive orthant, <span>$\text{rectify}(X ∩ O_3)$</span>, is either the empty set or the singleton containing the origin. The rectification of <span>$X ∩ O_2$</span> and <span>$X ∩ O_4$</span> both result in flat <span>$1$</span>-dimensional line segments on the corresponding hyperplane of <span>$O_1$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Rectification.jl#L28-L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{Rectification}" href="#LazySets.dim-Tuple{Rectification}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(r::Rectification)::Int</code></pre><p>Return the dimension of a rectification.</p><p><strong>Input</strong></p><ul><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the rectification.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Rectification.jl#L116-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, r::Rectification{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a rectification.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Rectification.jl#L133-L147">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,#s50} where #s50&lt;:AbstractHyperrectangle{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,#s50} where #s50&lt;:AbstractHyperrectangle{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N},
  r::Rectification{N, &lt;:AbstractHyperrectangle{N}}) where {N&lt;:Real}</code></pre><p>Return the support vector of the rectification of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>r</code> – rectification of a hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>Let <span>$r(·)$</span> be the rectification of a vector respectively a set, and let <span>$H$</span> be a hyperrectangle. Then <span>$σ_{r(H)}(d) = r(σ_{H}(d))$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Rectification.jl#L155-L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,#s50} where #s50&lt;:(CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N})}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,#s50} where #s50&lt;:(CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N})}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N},
  r::Rectification{N, &lt;:CartesianProduct{N}}) where {N&lt;:Real}</code></pre><p>Return the support vector of the rectification of a Cartesian product of two convex sets.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>r</code> – rectification of a Cartesian product of two convex sets</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>Rectification distributes with the Cartesian product. Let <span>$r(·)$</span> be the rectification of a set. We can just query the support vector for <span>$r(X)$</span> and <span>$r(Y)$</span> recursively: <span>$σ_{r(X × Y)}(d) = σ_{r(X)}(d_X) × σ_{r(Y)}(d_Y)$</span>, where <span>$x × y$</span> concatenates vectors <span>$x$</span> and <span>$y$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Rectification.jl#L181-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,#s50} where #s50&lt;:(CartesianProductArray{N,S} where S&lt;:LazySet{N})}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,#s50} where #s50&lt;:(CartesianProductArray{N,S} where S&lt;:LazySet{N})}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N},
  r::Rectification{N, &lt;:CartesianProductArray{N}}) where {N&lt;:Real}</code></pre><p>Return the support vector of the rectification of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>r</code> – rectification of a Cartesian product of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>Rectification distributes with the Cartesian product. Let <span>$r(·)$</span> be the rectification of a set. We can just query the support vector for each subspace recursively: <span>$σ_{r(X_1 × ⋯ × X_m)}(d) = σ_{r(X_1)}(d_{X_1}) × ⋯ × σ_{r(X_m)}(d_{X_m})$</span>, where <span>$x × y$</span> concatenates vectors <span>$x$</span> and <span>$y$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Rectification.jl#L212-L235">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, r::Rectification{N}) where {N&lt;:Real}</code></pre><p>Evaluate the support function of a rectification of a convex set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>r</code> – rectification of a convex set</li></ul><p><strong>Output</strong></p><p>The support value of the rectification of a convex set in the given direction.</p><p><strong>Algorithm</strong></p><p>We use different procedures for different types of input sets. If the wrapped set has a suitable structure for which we can efficiently compute the support vector, we fall back to the evaluation of the support function by means of the support vector. Otherwise we compute the union of projections to obtain a precise result (see <a href="#LazySets.to_union_of_projections-Union{Tuple{Rectification{N,S} where S&lt;:LazySet{N}}, Tuple{N}, Tuple{Rectification{N,S} where S&lt;:LazySet{N},Bool}} where N&lt;:Real"><code>to_union_of_projections</code></a>), and then compute the support function for this union. (The union is cached internally, so subsequent queries are more efficient.)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Rectification.jl#L249-L274">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{Rectification{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{Rectification{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(r::Rectification{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a rectification.</p><p><strong>Input</strong></p><ul><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p>An element in the rectification. The implementation relies on the <code>an_element</code> function of the wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Rectification.jl#L285-L298">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, r::Rectification{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a rectification.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ r$</span>.</p><p><strong>Algorithm</strong></p><p>We first scan for negative entries in the vector. If there are any, the vector is not contained in the rectification.</p><p>Next we ask a membership query in the wrapped set. If the answer is positive, the vector is contained in the rectification.</p><p>Otherwise, we scan for zero entries in the vector. If there are none, membership reduces to membership in the wrapped set, and so the answer is negative.</p><p>Finally, if there are zero entries in the vector and the vector is not contained in the wrapped set, we give up and throw an error.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Rectification.jl#L303-L331">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{Rectification}" href="#Base.isempty-Tuple{Rectification}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(r::Rectification)::Bool</code></pre><p>Check whether a rectification is empty or not.</p><p><strong>Input</strong></p><ul><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Rectification.jl#L353-L365">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Union{Tuple{Rectification{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.isbounded-Union{Tuple{Rectification{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(r::Rectification)::Bool</code></pre><p>Determine whether a rectification is bounded.</p><p><strong>Input</strong></p><ul><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the rectification is bounded.</p><p><strong>Algorithm</strong></p><p>Let <span>$X$</span> be the set wrapped by rectification <span>$r$</span>. We first check whether <span>$X$</span> is bounded (because then <span>$r$</span> is bounded). Otherwise, we check unboundedness of <span>$X$</span> in direction <span>$(1, 1, …, 1)$</span>, which is sufficient for unboundedness of <span>$r$</span>; this step is not necessary but rather a heuristics. Otherwise, we check boundedness of <span>$X$</span> in every positive unit direction, which is sufficient and necessary for boundedness of <span>$r$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Rectification.jl#L370-L392">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.to_union_of_projections-Union{Tuple{Rectification{N,S} where S&lt;:LazySet{N}}, Tuple{N}, Tuple{Rectification{N,S} where S&lt;:LazySet{N},Bool}} where N&lt;:Real" href="#LazySets.to_union_of_projections-Union{Tuple{Rectification{N,S} where S&lt;:LazySet{N}}, Tuple{N}, Tuple{Rectification{N,S} where S&lt;:LazySet{N},Bool}} where N&lt;:Real"><code>LazySets.to_union_of_projections</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">to_union_of_projections(r::Rectification{N},
                        concrete_intersection::Bool=false
                       ) where {N&lt;:Real}</code></pre><p>Compute an equivalent union of projections from a rectification of a convex set.</p><p><strong>Input</strong></p><ul><li><code>r</code>                     – rectification of a convex set</li><li><code>concrete_intersection</code> – (optional, default: <code>false</code>) option to compute                            all intersections concretely or lazily</li></ul><p><strong>Algorithm</strong></p><p>Let <span>$X$</span> be the set wrapped by the rectification <span>$r$</span>. We compute a union of sets that represents the rectification of <span>$X$</span> precisely. The sets are lazy projections, potentially of intersections.</p><p>We first identify those dimensions where <span>$X$</span> is negative, using one support-function query per dimension, and collect the dimensions in the index set <span>$I_\text{neg}$</span>. For each element in <span>$I_\text{neg}$</span> we will later apply a projection to zero.</p><p>Next we identify those dimensions from <span>$I_\text{neg}$</span> where <span>$X$</span> is also positive, using another support-function query in each dimension, and collect the dimensions in the index set <span>$I_\text{mix}$</span>. Let us call the remaining dimensions (<span>$I_\text{neg} \setminus I_\text{mix}$</span>) <span>$I_\text{nonpos}$</span>. For each dimension in <span>$j ∈ I_\text{mix}$</span> we will apply an intersection with axis-aligned polyhedra. In particular, we distinguish two cases using half-spaces <span>$x_j ≤ 0$</span> and <span>$x_j ≥ 0$</span>, and then compute all possible combinations to intersect, using one half-space per dimension <span>$j ∈ I_\text{mix}$</span>.</p><p>Next we project the intersections in all dimensions from <span>$i ∈ I_\text{mix}$</span> such that we used the half-space <span>$x_i ≤ 0$</span> in their computation, and in all dimensions <span>$j ∈ I_\text{nonpos}$</span> irrespective of the half-space used.</p><p>Finally, we take the union of the resulting sets.</p><p><strong>Output</strong></p><p>The result can be one of three cases depending on the wrapped set <span>$X$</span>, namely</p><ul><li>the set <span>$X$</span> if <span>$X$</span> is contained in the positive quadrant,</li><li>a <code>LinearMap</code> (projection) of <span>$X$</span> if for each dimension, <span>$X$</span> is only either positive or negative, or</li><li>a <code>UnionSetArray</code> of <code>LinearMaps</code> (projections) otherwise.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Rectification.jl#L415-L463">source</a></section><h4><a class="nav-anchor" id="Rectification-cache-1" href="#Rectification-cache-1">Rectification cache</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.RectificationCache" href="#LazySets.RectificationCache"><code>LazySets.RectificationCache</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">RectificationCache{N&lt;:Real}</code></pre><p>Struct that is used as a cache for <a href="#LazySets.Rectification"><code>Rectification</code></a>s.</p><p><strong>Fields</strong></p><ul><li><code>set</code>                – set represented by the rectification (can be <code>nothing</code>                         if not computed yet)</li><li><code>use_support_vector</code> – flag indicating whether to use support-vector                         computations for the cached set</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/645799a8da892f068783078ba1cd4cfece435982/src/LazyOperations/Rectification.jl#L5-L16">source</a></section><footer><hr/><a class="previous" href="../representations/"><span class="direction">Previous</span><span class="title">Common Set Representations</span></a><a class="next" href="../comparisons/"><span class="direction">Next</span><span class="title">Comparisons</span></a></footer></article></body></html>
