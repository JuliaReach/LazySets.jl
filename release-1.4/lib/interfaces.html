<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Set Interfaces · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/getting_started.html">Getting Started</a></li><li><a class="toctext" href="../man/polyhedral_approximations.html">Polyhedral Approximations</a></li><li><a class="toctext" href="../man/decompose_example.html">Decomposing an Affine Map</a></li><li><a class="toctext" href="../man/fast_2d_LPs.html">Fast 2D LPs</a></li><li><a class="toctext" href="../man/iterative_refinement.html">Iterative Refinement</a></li><li><a class="toctext" href="../man/interval_hulls.html">Interval Hulls</a></li><li><a class="toctext" href="../man/convex_hulls.html">Convex Hulls</a></li><li><a class="toctext" href="../man/set_operations.html">Operations on Sets</a></li><li><a class="toctext" href="../man/reach_zonotopes.html">A Reachability Algorithm</a></li><li><a class="toctext" href="../man/reach_zonotopes_hybrid.html">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../man/concrete_polyhedra.html">Concrete Polyhedra</a></li></ul></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href="interfaces.html">Set Interfaces</a><ul class="internal"><li><a class="toctext" href="#LazySet-1">LazySet</a></li><li><a class="toctext" href="#Point-symmetric-set-1">Point symmetric set</a></li><li><a class="toctext" href="#Polytope-1">Polytope</a></li></ul></li><li><a class="toctext" href="representations.html">Common Set Representations</a></li><li><a class="toctext" href="operations.html">Common Set Operations</a></li><li><a class="toctext" href="conversion.html">Conversion between set representations</a></li><li><a class="toctext" href="binary_functions.html">Binary Functions on Sets</a></li><li><a class="toctext" href="approximations.html">Approximations</a></li><li><a class="toctext" href="utils.html">Utility Functions</a></li></ul></li><li><a class="toctext" href="../about.html">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="interfaces.html">Set Interfaces</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/interfaces.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Set Interfaces</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Set-Interfaces-1" href="#Set-Interfaces-1">Set Interfaces</a></h1><p>This section of the manual describes the interfaces for different set types. Every set that fits the description of an interface should also implement it. This helps in several ways:</p><ul><li><p>avoid code duplicates,</p></li><li><p>provide functions for many sets at once,</p></li><li><p>allow changes in the source code without changing the API.</p></li></ul><p>The interface functions are outlined in the interface documentation. See <a href="representations.html#Common-Set-Representations-1">Common Set Representations</a> for implementations of the interfaces.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The naming convention is such that all interface names (with the exception of the main abstract type <code>LazySet</code>) should be preceded by <code>Abstract</code>.</p></div></div><p>The following diagram shows the interface hierarchy.</p><p><img src="../assets/interfaces.png" alt="../assets/interfaces.png"/></p><ul><li><a href="interfaces.html#Set-Interfaces-1">Set Interfaces</a></li><ul><li><a href="interfaces.html#LazySet-1">LazySet</a></li><ul><li><a href="interfaces.html#Support-function-and-support-vector-1">Support function and support vector</a></li><li><a href="interfaces.html#Other-globally-defined-set-functions-1">Other globally defined set functions</a></li></ul><li><a href="interfaces.html#Point-symmetric-set-1">Point symmetric set</a></li><li><a href="interfaces.html#Polytope-1">Polytope</a></li><ul><li><a href="interfaces.html#Polygon-1">Polygon</a></li><ul><li><a href="interfaces.html#HPolygon-1">HPolygon</a></li></ul><li><a href="interfaces.html#Point-symmetric-polytope-1">Point symmetric polytope</a></li><ul><li><a href="interfaces.html#Hyperrectangle-1">Hyperrectangle</a></li><li><a href="interfaces.html#Singleton-1">Singleton</a></li></ul></ul></ul></ul><h2><a class="nav-anchor" id="LazySet-1" href="#LazySet-1">LazySet</a></h2><p>Every convex set in this library implements this interface.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.LazySet" href="#LazySets.LazySet"><code>LazySets.LazySet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LazySet{N}</code></pre><p>Abstract type for convex sets, i.e., sets characterized by a (possibly infinite) intersection of halfspaces, or equivalently, sets <span>$S$</span> such that for any two elements <span>$x, y ∈ S$</span> and <span>$0 ≤ λ ≤ 1$</span> it holds that <span>$λ·x + (1-λ)·y ∈ S$</span>.</p><p><strong>Notes</strong></p><p><code>LazySet</code> types should be parameterized with a type <code>N</code>, typically <code>N&lt;:Real</code>, for using different numeric types.</p><p>Every concrete <code>LazySet</code> must define the following functions:</p><ul><li><p><code>σ(d::AbstractVector{N}, S::LazySet{N}) where {N&lt;:Real}</code> – the support vector   of <code>S</code> in a given direction <code>d</code>; note that the numeric type <code>N</code> of <code>d</code> and   <code>S</code> must be identical; for some set types <code>N</code> may be more restrictive than   <code>Real</code></p></li><li><p><code>dim(S::LazySet)::Int</code> – the ambient dimension of <code>S</code></p></li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(LazySet)
18-element Array{Any,1}:
 AbstractPointSymmetric
 AbstractPolytope
 CacheMinkowskiSum
 CartesianProduct
 CartesianProductArray
 ConvexHull
 ConvexHullArray
 EmptySet
 ExponentialMap
 ExponentialProjectionMap
 HalfSpace
 Hyperplane
 Intersection
 IntersectionArray
 Line
 LinearMap
 MinkowskiSum
 MinkowskiSumArray</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LazySet.jl#L12-L53">source</a></section><h3><a class="nav-anchor" id="Support-function-and-support-vector-1" href="#Support-function-and-support-vector-1">Support function and support vector</a></h3><p>Every <code>LazySet</code> type must define a function <code>σ</code> to compute the support vector.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.support_vector" href="#LazySets.support_vector"><code>LazySets.support_vector</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">support_vector</code></pre><p>Alias for the support vector σ.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LazySet.jl#L96-L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Tuple{AbstractArray{Real,1},LazySets.LazySet{Real}}" href="#LazySets.ρ-Tuple{AbstractArray{Real,1},LazySets.LazySet{Real}}"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ρ(d::AbstractVector{N}, S::LazySet{N})::N where {N&lt;:Real}</code></pre><p>Evaluate the support function of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>S</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>The support function of the set <code>S</code> for the direction <code>d</code>.</p><p><strong>Notes</strong></p><p>The numeric type of the direction and the set must be identical.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LazySet.jl#L60-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.support_function" href="#LazySets.support_function"><code>LazySets.support_function</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">support_function</code></pre><p>Alias for the support function ρ.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LazySet.jl#L82-L86">source</a></section><h3><a class="nav-anchor" id="Other-globally-defined-set-functions-1" href="#Other-globally-defined-set-functions-1">Other globally defined set functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}" href="#Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}"><code>Base.LinAlg.norm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">norm(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the norm of a convex set. It is the norm of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LazySet.jl#L104-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius-Tuple{LazySets.LazySet,Real}" href="#LazySets.radius-Tuple{LazySets.LazySet,Real}"><code>LazySets.radius</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the radius of a convex set. It is the radius of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LazySet.jl#L128-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.diameter-Tuple{LazySets.LazySet,Real}" href="#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>LazySets.diameter</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">diameter(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the diameter of a convex set. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LazySet.jl#L152-L168">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{LazySets.LazySet{Real}}" href="#LazySets.an_element-Tuple{LazySets.LazySet{Real}}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>An element of a convex set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LazySet.jl#L174-L186">source</a></section><h2><a class="nav-anchor" id="Point-symmetric-set-1" href="#Point-symmetric-set-1">Point symmetric set</a></h2><p>Point symmetric sets such as balls of different norms are characterized by a center. Note that there is a special interface combination <a href="interfaces.html#Point-symmetric-polytope-1">Point symmetric polytope</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractPointSymmetric" href="#LazySets.AbstractPointSymmetric"><code>LazySets.AbstractPointSymmetric</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractPointSymmetric{N&lt;:Real} &lt;: LazySet{N}</code></pre><p>Abstract type for point symmetric sets.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPointSymmetric</code> must define the following functions:</p><ul><li><p><code>center(::AbstractPointSymmetric{N})::Vector{N}</code> – return the center point</p></li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPointSymmetric)
3-element Array{Any,1}:
 Ball2
 Ballp
 Ellipsoid</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractPointSymmetric.jl#L5-L23">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.AbstractPointSymmetric}" href="#LazySets.dim-Tuple{LazySets.AbstractPointSymmetric}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(S::AbstractPointSymmetric)::Int</code></pre><p>Return the ambient dimension of a point symmetric set.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractPointSymmetric.jl#L27-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{LazySets.AbstractPointSymmetric{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{LazySets.AbstractPointSymmetric{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(S::AbstractPointSymmetric{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a point symmetric set.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – point symmetric set</p></li></ul><p><strong>Output</strong></p><p>The center of the point symmetric set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractPointSymmetric.jl#L44-L56">source</a></section><h2><a class="nav-anchor" id="Polytope-1" href="#Polytope-1">Polytope</a></h2><p>A polytope has finitely many vertices (<em>V-representation</em>) resp. facets (<em>H-representation</em>). Note that there is a special interface combination <a href="interfaces.html#Point-symmetric-polytope-1">Point symmetric polytope</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractPolytope" href="#LazySets.AbstractPolytope"><code>LazySets.AbstractPolytope</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractPolytope{N&lt;:Real} &lt;: LazySet{N}</code></pre><p>Abstract type for polytopic sets, i.e., sets with finitely many flat facets, or equivalently, sets defined as an intersection of a finite number of halfspaces, or equivalently, sets with finitely many vertices.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolytope</code> must define the following functions:</p><ul><li><p><code>vertices_list(::AbstractPolytope{N})::Vector{Vector{N}}</code> – return a list of   all vertices</p></li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolytope)
4-element Array{Any,1}:
 AbstractPointSymmetricPolytope
 AbstractPolygon
 HPolytope
 VPolytope</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractPolytope.jl#L6-L27">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.singleton_list-Tuple{LazySets.AbstractPolytope}" href="#LazySets.singleton_list-Tuple{LazySets.AbstractPolytope}"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">singleton_list(P::AbstractPolytope{N})::Vector{Singleton{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a polytopic as a list of singletons.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – a polytopic set</p></li></ul><p><strong>Output</strong></p><p>List containing a singleton for each vertex.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractPolytope.jl#L34-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Tuple{AbstractArray{T,2} where T,LazySets.AbstractPolytope}" href="#LazySets.linear_map-Tuple{AbstractArray{T,2} where T,LazySets.AbstractPolytope}"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">linear_map(M::AbstractMatrix, P::AbstractPolytope{N}) where {N&lt;:Real}</code></pre><p>Concrete linear map of an abstract polytype.</p><p><strong>Input</strong></p><ul><li><p><code>M</code> – matrix</p></li><li><p><code>P</code> – abstract polytype</p></li></ul><p><strong>Output</strong></p><p>The polytope in V-representation obtained by applying the linear map <span>$M$</span> to the set <span>$P$</span>. If the given polytope is two-dimensional, a polygon instead of a general polytope is returned. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractPolytope.jl#L52-L67">source</a></section><h3><a class="nav-anchor" id="Polygon-1" href="#Polygon-1">Polygon</a></h3><p>A polygon is a two-dimensional polytope.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractPolygon" href="#LazySets.AbstractPolygon"><code>LazySets.AbstractPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractPolygon{N&lt;:Real} &lt;: AbstractPolytope{N}</code></pre><p>Abstract type for polygons (i.e., 2D polytopes).</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolygon</code> must define the following functions:</p><ul><li><p><code>tovrep(::AbstractPolygon{N})::VPolygon{N}</code>         – transform into   V-representation</p></li><li><p><code>tohrep(::AbstractPolygon{N})::AbstractHPolygon{N}</code> – transform into   H-representation</p></li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolygon)
2-element Array{Any,1}:
 AbstractHPolygon
 VPolygon</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractPolygon.jl#L7-L26">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.AbstractPolygon}" href="#LazySets.dim-Tuple{LazySets.AbstractPolygon}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(P::AbstractPolygon)::Int</code></pre><p>Return the ambient dimension of a polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polygon, which is 2.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractPolygon.jl#L33-L45">source</a></section><h4><a class="nav-anchor" id="HPolygon-1" href="#HPolygon-1">HPolygon</a></h4><p>An HPolygon is a polygon in H-representation (or constraint representation).</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractHPolygon" href="#LazySets.AbstractHPolygon"><code>LazySets.AbstractHPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractHPolygon{N&lt;:Real} &lt;: AbstractPolygon{N}</code></pre><p>Abstract type for polygons in H-representation (i.e., constraints).</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractHPolygon</code> must have the following fields:</p><ul><li><p><code>constraints::Vector{LinearConstraint{N}}</code> – the constraints</p></li></ul><p>New subtypes should be added to the <code>convert</code> method in order to be convertible.</p><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractHPolygon)
2-element Array{Any,1}:
 HPolygon
 HPolygonOpt</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractHPolygon.jl#L16-L34">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{LazySets.AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{LazySets.AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(P::AbstractHPolygon{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>A vertex of the polygon in constraint representation (the first one in the order of the constraints).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractHPolygon.jl#L134-L147">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Real,1},LazySets.AbstractHPolygon{Real}}" href="#Base.:∈-Tuple{AbstractArray{Real,1},LazySets.AbstractHPolygon{Real}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, P::AbstractHPolygon{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given 2D point is contained in a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – two-dimensional point/vector</p></li><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation checks if the point lies on the outside of each edge.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractHPolygon.jl#L154-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.AbstractHPolygon{Real}}" href="#LazySets.vertices_list-Tuple{LazySets.AbstractHPolygon{Real}}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(P::AbstractHPolygon{N},
              apply_convex_hull::Bool=false
             )::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code>                 – polygon in constraint representation</p></li><li><p><code>apply_convex_hull</code> – (optional, default: <code>false</code>) to post process or not the                        intersection of constraints with a convex hull</p></li></ul><p><strong>Output</strong></p><p>List of vertices.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractHPolygon.jl#L80-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tohrep-Tuple{LazySets.AbstractHPolygon{Real}}" href="#LazySets.tohrep-Tuple{LazySets.AbstractHPolygon{Real}}"><code>LazySets.tohrep</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">tohrep(P::AbstractHPolygon{N})::AbstractHPolygon{N} where {N&lt;:Real}</code></pre><p>Build a contraint representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>The identity, i.e., the same polygon instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractHPolygon.jl#L59-L71">source</a><div><pre><code class="language-none">tohrep(P::VPolygon{N}, ::Type{HPOLYGON}=HPolygon
      )::AbstractHPolygon{N} where {N&lt;:Real, HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Build a constraint representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code>        – polygon in vertex representation</p></li><li><p><code>HPOLYGON</code> – (optional, default: <code>HPolygon</code>) type of target polygon</p></li></ul><p><strong>Output</strong></p><p>The same polygon but in constraint representation, an <code>AbstractHPolygon</code>.</p><p><strong>Algorithm</strong></p><p>The algorithms consists of adding an edge for each consecutive pair of vertices. Since the vertices are already ordered in counter-clockwise fashion (CWW), the constraints will be sorted automatically (CCW) if we start with the first edge between the first and second vertex.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/VPolygon.jl#L75-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tovrep-Tuple{LazySets.AbstractHPolygon{Real}}" href="#LazySets.tovrep-Tuple{LazySets.AbstractHPolygon{Real}}"><code>LazySets.tovrep</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">tovrep(P::AbstractHPolygon{N})::VPolygon{N} where {N&lt;:Real}</code></pre><p>Build a vertex representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>The same polygon but in vertex representation, a <code>VPolygon</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractHPolygon.jl#L41-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.addconstraint!-Tuple{LazySets.AbstractHPolygon{Real},LazySets.HalfSpace{Real}}" href="#LazySets.addconstraint!-Tuple{LazySets.AbstractHPolygon{Real},LazySets.HalfSpace{Real}}"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">addconstraint!(P::AbstractHPolygon{N},
               constraint::LinearConstraint{N};
               [linear_search]::Bool=(
                length(P.constraints) &lt; BINARY_SEARCH_THRESHOLD)
              )::Nothing where {N&lt;:Real}</code></pre><p>Add a linear constraint to a polygon in constraint representation, keeping the constraints sorted by their normal directions.</p><p><strong>Input</strong></p><ul><li><p><code>P</code>          – polygon in constraint representation</p></li><li><p><code>constraint</code> – linear constraint to add</p></li></ul><p><strong>Output</strong></p><p>Nothing.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractHPolygon.jl#L188-L206">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Tuple{LazySets.AbstractHPolygon{Real}}" href="#LazySets.constraints_list-Tuple{LazySets.AbstractHPolygon{Real}}"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">constraints_list(P::AbstractHPolygon{N})::Vector{LinearConstraint{N}} where {N&lt;:Real}</code></pre><p>Return the list of constraints defining a polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in H-representation</p></li></ul><p><strong>Output</strong></p><p>The list of constraints of the polygon.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractHPolygon.jl#L114-L126">source</a></section><h3><a class="nav-anchor" id="Point-symmetric-polytope-1" href="#Point-symmetric-polytope-1">Point symmetric polytope</a></h3><p>A point symmetric polytope is a combination of two other interfaces: <a href="interfaces.html#Point-symmetric-set-1">Point symmetric set</a> and <a href="interfaces.html#Polytope-1">Polytope</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractPointSymmetricPolytope" href="#LazySets.AbstractPointSymmetricPolytope"><code>LazySets.AbstractPointSymmetricPolytope</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractPointSymmetricPolytope{N&lt;:Real} &lt;: AbstractPolytope{N}</code></pre><p>Abstract type for point symmetric, polytopic sets. It combines the <code>AbstractPointSymmetric</code> and <code>AbstractPolytope</code> interfaces. Such a type combination is necessary as long as Julia does not support <a href="https://github.com/JuliaLang/julia/issues/5">multiple inheritance</a>.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPointSymmetricPolytope</code> must define the following functions:</p><ul><li><p>from <code>AbstractPointSymmetric</code>:</p><ul><li><p><code>center(::AbstractPointSymmetricPolytope{N})::Vector{N}</code> – return the  center point</p></li></ul></li><li><p>from <code>AbstractPolytope</code>:</p><ul><li><p><code>vertices_list(::AbstractPointSymmetricPolytope{N})::Vector{Vector{N}}</code>  – return a list of all vertices</p></li></ul></li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPointSymmetricPolytope)
5-element Array{Any,1}:
 AbstractHyperrectangle
 Ball1
 Interval
 LineSegment
 Zonotope</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractPointSymmetricPolytope.jl#L7-L35">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.AbstractPointSymmetricPolytope}" href="#LazySets.dim-Tuple{LazySets.AbstractPointSymmetricPolytope}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(P::AbstractPointSymmetricPolytope)::Int</code></pre><p>Return the ambient dimension of a point symmetric set.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – set</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractPointSymmetricPolytope.jl#L42-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{LazySets.AbstractPointSymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{LazySets.AbstractPointSymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(P::AbstractPointSymmetricPolytope{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a point symmetric polytope.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – point symmetric polytope</p></li></ul><p><strong>Output</strong></p><p>The center of the point symmetric polytope.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractPointSymmetricPolytope.jl#L60-L72">source</a></section><h4><a class="nav-anchor" id="Hyperrectangle-1" href="#Hyperrectangle-1">Hyperrectangle</a></h4><p>A hyperrectangle is a special point symmetric polytope with axis-aligned facets.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractHyperrectangle" href="#LazySets.AbstractHyperrectangle"><code>LazySets.AbstractHyperrectangle</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractHyperrectangle{N&lt;:Real} &lt;: AbstractPointSymmetricPolytope{N}</code></pre><p>Abstract type for hyperrectangular sets.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractHyperrectangle</code> must define the following functions:</p><ul><li><p><code>radius_hyperrectangle(::AbstractHyperrectangle{N})::Vector{N}</code> – return the   hyperrectangle&#39;s radius, which is a full-dimensional vector</p></li><li><p><code>radius_hyperrectangle(::AbstractHyperrectangle{N}, i::Int)::N</code> – return the   hyperrectangle&#39;s radius in the <code>i</code>-th dimension</p></li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractHyperrectangle)
4-element Array{Any,1}:
 AbstractSingleton
 BallInf
 Hyperrectangle
 SymmetricIntervalHull</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractHyperrectangle.jl#L6-L27">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.norm-Tuple{LazySets.AbstractHyperrectangle,Real}" href="#Base.LinAlg.norm-Tuple{LazySets.AbstractHyperrectangle,Real}"><code>Base.LinAlg.norm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">norm(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the norm of a convex set. It is the norm of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LazySet.jl#L104-L119">source</a><div><pre><code class="language-none">norm(H::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the norm of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangular set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p><p><strong>Notes</strong></p><p>The norm of a hyperrectangular set is defined as the norm of the enclosing ball, of the given <span>$p$</span>-norm, of minimal volume that is centered in the origin.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractHyperrectangle.jl#L81-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius-Tuple{LazySets.AbstractHyperrectangle,Real}" href="#LazySets.radius-Tuple{LazySets.AbstractHyperrectangle,Real}"><code>LazySets.radius</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the radius of a convex set. It is the radius of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LazySet.jl#L128-L143">source</a><div><pre><code class="language-none">radius(H::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the radius of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangular set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p><p><strong>Notes</strong></p><p>The radius is defined as the radius of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center. It is the same for all corners of a hyperrectangular set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractHyperrectangle.jl#L104-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.AbstractHyperrectangle{Real}}" href="#LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.AbstractHyperrectangle{Real}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a hyperrectangular set in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>H</code> – hyperrectangular set</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the vertex with biggest values is returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractHyperrectangle.jl#L62-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Real,1},LazySets.AbstractHyperrectangle{Real}}" href="#Base.:∈-Tuple{AbstractArray{Real,1},LazySets.AbstractHyperrectangle{Real}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, H::AbstractHyperrectangle{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>H</code> – hyperrectangular set</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ H$</span>.</p><p><strong>Algorithm</strong></p><p>Let <span>$H$</span> be an <span>$n$</span>-dimensional hyperrectangular set, <span>$c_i$</span> and <span>$r_i$</span> be the box&#39;s center and radius and <span>$x_i$</span> be the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ H$</span> iff <span>$|c_i - x_i| ≤ r_i$</span> for all <span>$i=1,…,n$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractHyperrectangle.jl#L128-L148">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.AbstractHyperrectangle{Real}}" href="#LazySets.vertices_list-Tuple{LazySets.AbstractHyperrectangle{Real}}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(H::AbstractHyperrectangle{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangular set</p></li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Notes</strong></p><p>For high dimensions, it is preferable to develop a <code>vertex_iterator</code> approach.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractHyperrectangle.jl#L35-L51">source</a></section><h4><a class="nav-anchor" id="Singleton-1" href="#Singleton-1">Singleton</a></h4><p>A singleton is a special hyperrectangle consisting of only one point.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractSingleton" href="#LazySets.AbstractSingleton"><code>LazySets.AbstractSingleton</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSingleton{N&lt;:Real} &lt;: AbstractHyperrectangle{N}</code></pre><p>Abstract type for sets with a single value.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractSingleton</code> must define the following functions:</p><ul><li><p><code>element(::AbstractSingleton{N})::Vector{N}</code> – return the single element</p></li><li><p><code>element(::AbstractSingleton{N}, i::Int)::N</code> – return the single element&#39;s   entry in the <code>i</code>-th dimension</p></li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractSingleton)
2-element Array{Any,1}:
 Singleton
 ZeroSet</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractSingleton.jl#L8-L26">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{AbstractArray{N,1},LazySets.AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{AbstractArray{N,1},LazySets.AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a set with a single value.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p>The support vector, which is the set&#39;s vector itself, irrespective of the given direction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractSingleton.jl#L139-L153">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{AbstractArray{N,1},LazySets.AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{AbstractArray{N,1},LazySets.AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, S::AbstractSingleton{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a set with a single value.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ S$</span>.</p><p><strong>Notes</strong></p><p>This implementation performs an exact comparison, which may be insufficient with floating point computations.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractSingleton.jl#L159-L177">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{LazySets.AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{LazySets.AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>An element of a convex set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LazySet.jl#L174-L186">source</a><div><pre><code class="language-none">an_element(P::AbstractPointSymmetricPolytope{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a point symmetric polytope.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – point symmetric polytope</p></li></ul><p><strong>Output</strong></p><p>The center of the point symmetric polytope.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractPointSymmetricPolytope.jl#L60-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Tuple{LazySets.AbstractSingleton{Real}}" href="#LazySets.center-Tuple{LazySets.AbstractSingleton{Real}}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">center(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a set with a single value.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p>The only element of the set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractSingleton.jl#L74-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{LazySets.AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{LazySets.AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(S::AbstractSingleton{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a set with a single value.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p>A list containing only a single vertex.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractSingleton.jl#L95-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Tuple{LazySets.AbstractSingleton{Real}}" href="#LazySets.radius_hyperrectangle-Tuple{LazySets.AbstractSingleton{Real}}"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius_hyperrectangle(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the box radius of a set with a single value in every dimension.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p>The zero vector.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractSingleton.jl#L52-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Tuple{LazySets.AbstractSingleton{Real},Int64}" href="#LazySets.radius_hyperrectangle-Tuple{LazySets.AbstractSingleton{Real},Int64}"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius_hyperrectangle(S::AbstractSingleton{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the box radius of a set with a single value in a given dimension.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set with a single value</p></li></ul><p><strong>Output</strong></p><p>Zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractSingleton.jl#L33-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{AbstractArray{T,2} where T,LazySets.AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{AbstractArray{T,2} where T,LazySets.AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">linear_map(M::AbstractMatrix, S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Concrete linear map of an abstract singleton.</p><p><strong>Input</strong></p><ul><li><p><code>M</code> – matrix</p></li><li><p><code>S</code> – abstract singleton</p></li></ul><p><strong>Output</strong></p><p>The abstract singleton of the same type of <span>$S$</span> obtained by applying the linear map to the element in <span>$S$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractSingleton.jl#L113-L127">source</a></section><footer><hr/><a class="previous" href="../man/concrete_polyhedra.html"><span class="direction">Previous</span><span class="title">Concrete Polyhedra</span></a><a class="next" href="representations.html"><span class="direction">Next</span><span class="title">Common Set Representations</span></a></footer></article></body></html>
