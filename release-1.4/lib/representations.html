<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Common Set Representations · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/getting_started.html">Getting Started</a></li><li><a class="toctext" href="../man/polyhedral_approximations.html">Polyhedral Approximations</a></li><li><a class="toctext" href="../man/decompose_example.html">Decomposing an Affine Map</a></li><li><a class="toctext" href="../man/fast_2d_LPs.html">Fast 2D LPs</a></li><li><a class="toctext" href="../man/iterative_refinement.html">Iterative Refinement</a></li><li><a class="toctext" href="../man/interval_hulls.html">Interval Hulls</a></li><li><a class="toctext" href="../man/convex_hulls.html">Convex Hulls</a></li><li><a class="toctext" href="../man/set_operations.html">Operations on Sets</a></li><li><a class="toctext" href="../man/reach_zonotopes.html">A Reachability Algorithm</a></li><li><a class="toctext" href="../man/reach_zonotopes_hybrid.html">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../man/concrete_polyhedra.html">Concrete Polyhedra</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="interfaces.html">Set Interfaces</a></li><li class="current"><a class="toctext" href="representations.html">Common Set Representations</a><ul class="internal"><li><a class="toctext" href="#Balls-1">Balls</a></li><li><a class="toctext" href="#Ellipsoid-1">Ellipsoid</a></li><li><a class="toctext" href="#Empty-set-1">Empty set</a></li><li><a class="toctext" href="#Half-Space-1">Half-Space</a></li><li><a class="toctext" href="#Hyperplane-1">Hyperplane</a></li><li><a class="toctext" href="#Hyperrectangle-1">Hyperrectangle</a></li><li><a class="toctext" href="#Interval-1">Interval</a></li><li><a class="toctext" href="#Line-1">Line</a></li><li><a class="toctext" href="#Line-segment-1">Line segment</a></li><li><a class="toctext" href="#Polygons-1">Polygons</a></li><li><a class="toctext" href="#Polytopes-1">Polytopes</a></li><li><a class="toctext" href="#Singleton-1">Singleton</a></li><li><a class="toctext" href="#Zero-set-1">Zero set</a></li><li><a class="toctext" href="#Zonotope-1">Zonotope</a></li></ul></li><li><a class="toctext" href="operations.html">Common Set Operations</a></li><li><a class="toctext" href="conversion.html">Conversion between set representations</a></li><li><a class="toctext" href="binary_functions.html">Binary Functions on Sets</a></li><li><a class="toctext" href="approximations.html">Approximations</a></li><li><a class="toctext" href="utils.html">Utility Functions</a></li></ul></li><li><a class="toctext" href="../about.html">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="representations.html">Common Set Representations</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/representations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Common Set Representations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Common-Set-Representations-1" href="#Common-Set-Representations-1">Common Set Representations</a></h1><p>This section of the manual describes the basic set representation types.</p><ul><li><a href="representations.html#Common-Set-Representations-1">Common Set Representations</a></li><ul><li><a href="representations.html#Balls-1">Balls</a></li><ul><li><a href="representations.html#Euclidean-norm-ball-1">Euclidean norm ball</a></li><li><a href="representations.html#Infinity-norm-ball-1">Infinity norm ball</a></li><li><a href="representations.html#Manhattan-norm-ball-1">Manhattan norm ball</a></li><li><a href="representations.html#p-norm-ball-1">p-norm ball</a></li></ul><li><a href="representations.html#Ellipsoid-1">Ellipsoid</a></li><li><a href="representations.html#Empty-set-1">Empty set</a></li><li><a href="representations.html#Half-Space-1">Half-Space</a></li><li><a href="representations.html#Hyperplane-1">Hyperplane</a></li><li><a href="representations.html#Hyperrectangle-1">Hyperrectangle</a></li><li><a href="representations.html#Interval-1">Interval</a></li><li><a href="representations.html#Line-1">Line</a></li><li><a href="representations.html#Line-segment-1">Line segment</a></li><li><a href="representations.html#Polygons-1">Polygons</a></li><ul><li><a href="representations.html#Constraint-representation-1">Constraint representation</a></li><li><a href="representations.html#Optimized-constraint-representation-1">Optimized constraint representation</a></li><li><a href="representations.html#Vertex-representation-1">Vertex representation</a></li><li><a href="representations.html#Sorting-directions-1">Sorting directions</a></li></ul><li><a href="representations.html#Polytopes-1">Polytopes</a></li><ul><li><a href="representations.html#Constraint-representation-2">Constraint representation</a></li><li><a href="representations.html#Vertex-representation-2">Vertex representation</a></li></ul><li><a href="representations.html#Singleton-1">Singleton</a></li><li><a href="representations.html#Zero-set-1">Zero set</a></li><li><a href="representations.html#Zonotope-1">Zonotope</a></li></ul></ul><h2><a class="nav-anchor" id="Balls-1" href="#Balls-1">Balls</a></h2><h3><a class="nav-anchor" id="Euclidean-norm-ball-1" href="#Euclidean-norm-ball-1">Euclidean norm ball</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Ball2" href="#LazySets.Ball2"><code>LazySets.Ball2</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Ball2{N&lt;:AbstractFloat} &lt;: AbstractPointSymmetric{N}</code></pre><p>Type that represents a ball in the 2-norm.</p><p><strong>Fields</strong></p><ul><li><p><code>center</code> – center of the ball as a real vector</p></li><li><p><code>radius</code> – radius of the ball as a real scalar (<span>$≥ 0$</span>)</p></li></ul><p><strong>Notes</strong></p><p>Mathematically, a ball in the 2-norm is defined as the set</p><div>\[\mathcal{B}_2^n(c, r) = \{ x ∈ \mathbb{R}^n : ‖ x - c ‖_2 ≤ r \},\]</div><p>where <span>$c ∈ \mathbb{R}^n$</span> is its center and <span>$r ∈ \mathbb{R}_+$</span> its radius. Here <span>$‖ ⋅ ‖_2$</span> denotes the Euclidean norm (also known as 2-norm), defined as <span>$‖ x ‖_2 = \left( \sum\limits_{i=1}^n |x_i|^2 \right)^{1/2}$</span> for any <span>$x ∈ \mathbb{R}^n$</span>.</p><p><strong>Examples</strong></p><p>Create a five-dimensional ball <code>B</code> in the 2-norm centered at the origin with radius 0.5:</p><pre><code class="language-julia-repl">julia&gt; B = Ball2(zeros(5), 0.5)
Ball2{Float64}([0.0, 0.0, 0.0, 0.0, 0.0], 0.5)
julia&gt; dim(B)
5</code></pre><p>Evaluate <code>B</code>&#39;s support vector in the direction <span>$[1,2,3,4,5]$</span>:</p><pre><code class="language-julia-repl">julia&gt; σ([1.,2.,3.,4.,5.], B)
5-element Array{Float64,1}:
 0.06741998624632421
 0.13483997249264842
 0.20225995873897262
 0.26967994498529685
 0.3370999312316211</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Ball2.jl#L5-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{AbstractFloat,1},LazySets.Ball2{AbstractFloat}}" href="#LazySets.σ-Tuple{AbstractArray{AbstractFloat,1},LazySets.Ball2{AbstractFloat}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, B::Ball2{N}) where {N&lt;:AbstractFloat}</code></pre><p>Return the support vector of a 2-norm ball in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>B</code> – ball in the 2-norm</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the origin is returned.</p><p><strong>Notes</strong></p><p>Let <span>$c$</span> and <span>$r$</span> be the center and radius of a ball <span>$B$</span> in the 2-norm, respectively. For nonzero direction <span>$d$</span> we have</p><div>\[σ_B(d) = c + r \frac{d}{‖d‖_2}.\]</div><p>This function requires computing the 2-norm of the input direction, which is performed in the given precision of the numeric datatype of both the direction and the set. Exact inputs are not supported.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Ball2.jl#L90-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{AbstractFloat,1},LazySets.Ball2{AbstractFloat}}" href="#Base.:∈-Tuple{AbstractArray{AbstractFloat,1},LazySets.Ball2{AbstractFloat}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, B::Ball2{N})::Bool where {N&lt;:AbstractFloat}</code></pre><p>Check whether a given point is contained in a ball in the 2-norm.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>B</code> – ball in the 2-norm</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ B$</span>.</p><p><strong>Notes</strong></p><p>This implementation is worst-case optimized, i.e., it is optimistic and first computes (see below) the whole sum before comparing to the radius. In applications where the point is typically far away from the ball, a fail-fast implementation with interleaved comparisons could be more efficient.</p><p><strong>Algorithm</strong></p><p>Let <span>$B$</span> be an <span>$n$</span>-dimensional ball in the 2-norm with radius <span>$r$</span> and let <span>$c_i$</span> and <span>$x_i$</span> be the ball&#39;s center and the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ B$</span> iff <span>$\left( ∑_{i=1}^n |c_i - x_i|^2 \right)^{1/2} ≤ r$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = Ball2([1., 1.], sqrt(0.5))
Ball2{Float64}([1.0, 1.0], 0.7071067811865476)
julia&gt; ∈([.5, 1.6], B)
false
julia&gt; ∈([.5, 1.5], B)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Ball2.jl#L129-L167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Tuple{LazySets.Ball2}" href="#LazySets.center-Tuple{LazySets.Ball2}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">center(B::Ball2{N})::Vector{N} where {N&lt;:AbstractFloat}</code></pre><p>Return the center of a ball in the 2-norm.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – ball in the 2-norm</p></li></ul><p><strong>Output</strong></p><p>The center of the ball in the 2-norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Ball2.jl#L69-L81">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.LazySet,Real}"><code>radius</code></a></p></li><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPointSymmetric"><code>AbstractPointSymmetric</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.dim-Tuple{LazySets.AbstractPointSymmetric}"><code>dim</code></a></p></li><li><p><code>an_element</code></p></li></ul><h3><a class="nav-anchor" id="Infinity-norm-ball-1" href="#Infinity-norm-ball-1">Infinity norm ball</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.BallInf" href="#LazySets.BallInf"><code>LazySets.BallInf</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">BallInf{N&lt;:Real} &lt;: AbstractHyperrectangle{N}</code></pre><p>Type that represents a ball in the infinity norm.</p><p><strong>Fields</strong></p><ul><li><p><code>center</code> – center of the ball as a real vector</p></li><li><p><code>radius</code> – radius of the ball as a real scalar (<span>$≥ 0$</span>)</p></li></ul><p><strong>Notes</strong></p><p>Mathematically, a ball in the infinity norm is defined as the set</p><div>\[\mathcal{B}_∞^n(c, r) = \{ x ∈ \mathbb{R}^n : ‖ x - c ‖_∞ ≤ r \},\]</div><p>where <span>$c ∈ \mathbb{R}^n$</span> is its center and <span>$r ∈ \mathbb{R}_+$</span> its radius. Here <span>$‖ ⋅ ‖_∞$</span> denotes the infinity norm, defined as <span>$‖ x ‖_∞ = \max\limits_{i=1,…,n} \vert x_i \vert$</span> for any <span>$x ∈ \mathbb{R}^n$</span>.</p><p><strong>Examples</strong></p><p>Create the two-dimensional unit ball and compute its support function along the positive <span>$x=y$</span> direction:</p><pre><code class="language-julia-repl">julia&gt; B = BallInf(zeros(2), 1.0)
BallInf{Float64}([0.0, 0.0], 1.0)
julia&gt; dim(B)
2
julia&gt; ρ([1., 1.], B)
2.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/BallInf.jl#L3-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Tuple{LazySets.BallInf}" href="#LazySets.center-Tuple{LazySets.BallInf}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">center(B::BallInf{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a ball in the infinity norm.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – ball in the infinity norm</p></li></ul><p><strong>Output</strong></p><p>The center of the ball in the infinity norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/BallInf.jl#L96-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius-Tuple{LazySets.BallInf,Real}" href="#LazySets.radius-Tuple{LazySets.BallInf,Real}"><code>LazySets.radius</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the radius of a convex set. It is the radius of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LazySet.jl#L128-L143">source</a><div><pre><code class="language-none">radius(H::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the radius of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangular set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p><p><strong>Notes</strong></p><p>The radius is defined as the radius of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center. It is the same for all corners of a hyperrectangular set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractHyperrectangle.jl#L104-L123">source</a><div><pre><code class="language-none">radius(B::BallInf, [p]::Real=Inf)::Real</code></pre><p>Return the radius of a ball in the infinity norm.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – ball in the infinity norm</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p><p><strong>Notes</strong></p><p>The radius is defined as the radius of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/BallInf.jl#L117-L135">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Tuple{LazySets.BallInf}" href="#LazySets.radius_hyperrectangle-Tuple{LazySets.BallInf}"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius_hyperrectangle(B::BallInf{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the box radius of a infinity norm ball, which is the same in every dimension.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – infinity norm ball</p></li></ul><p><strong>Output</strong></p><p>The box radius of the ball in the infinity norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/BallInf.jl#L74-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Tuple{LazySets.BallInf,Int64}" href="#LazySets.radius_hyperrectangle-Tuple{LazySets.BallInf,Int64}"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius_hyperrectangle(B::BallInf{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the box radius of a infinity norm ball in a given dimension.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – infinity norm ball</p></li></ul><p><strong>Output</strong></p><p>The box radius of the ball in the infinity norm in the given dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/BallInf.jl#L57-L69">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.singleton_list-Tuple{LazySets.AbstractPolytope}"><code>singleton_list</code></a></p></li><li><p><a href="interfaces.html#LazySets.linear_map-Tuple{AbstractArray{T,2} where T,LazySets.AbstractPolytope}"><code>linear_map</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPointSymmetricPolytope"><code>AbstractPointSymmetricPolytope</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.dim-Tuple{LazySets.AbstractPointSymmetricPolytope}"><code>dim</code></a></p></li><li><p><code>an_element</code></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractHyperrectangle"><code>AbstractHyperrectangle</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.AbstractHyperrectangle{Real}}"><code>σ</code></a></p></li><li><p><a href="interfaces.html#Base.:∈-Tuple{AbstractArray{Real,1},LazySets.AbstractHyperrectangle{Real}}"><code>∈</code></a></p></li><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.AbstractHyperrectangle,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.vertices_list-Tuple{LazySets.AbstractHyperrectangle{Real}}"><code>vertices_list</code></a></p></li></ul><h3><a class="nav-anchor" id="Manhattan-norm-ball-1" href="#Manhattan-norm-ball-1">Manhattan norm ball</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Ball1" href="#LazySets.Ball1"><code>LazySets.Ball1</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Ball1{N&lt;:Real} &lt;: AbstractPointSymmetricPolytope{N}</code></pre><p>Type that represents a ball in the 1-norm, also known as Manhattan or Taxicab norm.</p><p>It is defined as the set</p><div>\[\mathcal{B}_1^n(c, r) = \{ x ∈ \mathbb{R}^n : ∑_{i=1}^n |c_i - x_i| ≤ r \},\]</div><p>where <span>$c ∈ \mathbb{R}^n$</span> is its center and <span>$r ∈ \mathbb{R}_+$</span> its radius.</p><p><strong>Fields</strong></p><ul><li><p><code>center</code> – center of the ball as a real vector</p></li><li><p><code>radius</code> – radius of the ball as a scalar (<span>$≥ 0$</span>)</p></li></ul><p><strong>Examples</strong></p><p>Unit ball in the 1-norm in the plane:</p><pre><code class="language-julia-repl">julia&gt; B = Ball1(zeros(2), 1.)
Ball1{Float64}([0.0, 0.0], 1.0)
julia&gt; dim(B)
2</code></pre><p>We evaluate the support vector in the East direction:</p><pre><code class="language-julia-repl">julia&gt; σ([0.,1], B)
2-element Array{Float64,1}:
 0.0
 1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Ball1.jl#L5-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.Ball1{Real}}" href="#LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.Ball1{Real}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, B::Ball1{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a ball in the 1-norm in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>B</code> – ball in the 1-norm</p></li></ul><p><strong>Output</strong></p><p>Support vector in the given direction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Ball1.jl#L113-L126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Real,1},LazySets.Ball1{Real}}" href="#Base.:∈-Tuple{AbstractArray{Real,1},LazySets.Ball1{Real}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, B::Ball1{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>B</code> – ball in the 1-norm</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ B$</span>.</p><p><strong>Notes</strong></p><p>This implementation is worst-case optimized, i.e., it is optimistic and first computes (see below) the whole sum before comparing to the radius. In applications where the point is typically far away from the ball, a fail-fast implementation with interleaved comparisons could be more efficient.</p><p><strong>Algorithm</strong></p><p>Let <span>$B$</span> be an <span>$n$</span>-dimensional ball in the 1-norm with radius <span>$r$</span> and let <span>$c_i$</span> and <span>$x_i$</span> be the ball&#39;s center and the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ B$</span> iff <span>$∑_{i=1}^n |c_i - x_i| ≤ r$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = Ball1([1., 1.], 1.);

julia&gt; ∈([.5, -.5], B)
false
julia&gt; ∈([.5, 1.5], B)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Ball1.jl#L134-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.Ball1}" href="#LazySets.vertices_list-Tuple{LazySets.Ball1}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(B::Ball1{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – ball in the 1-norm</p></li></ul><p><strong>Output</strong></p><p>A list containing the vertices of the ball in the 1-norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Ball1.jl#L82-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Tuple{LazySets.Ball1}" href="#LazySets.center-Tuple{LazySets.Ball1}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">center(B::Ball1{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – ball in the 1-norm</p></li></ul><p><strong>Output</strong></p><p>The center of the ball in the 1-norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Ball1.jl#L61-L73">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.LazySet,Real}"><code>radius</code></a></p></li><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.singleton_list-Tuple{LazySets.AbstractPolytope}"><code>singleton_list</code></a></p></li><li><p><a href="interfaces.html#LazySets.linear_map-Tuple{AbstractArray{T,2} where T,LazySets.AbstractPolytope}"><code>linear_map</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPointSymmetricPolytope"><code>AbstractPointSymmetricPolytope</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.dim-Tuple{LazySets.AbstractPointSymmetricPolytope}"><code>dim</code></a></p></li><li><p><code>an_element</code></p></li></ul><h3><a class="nav-anchor" id="p-norm-ball-1" href="#p-norm-ball-1">p-norm ball</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Ballp" href="#LazySets.Ballp"><code>LazySets.Ballp</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Ballp{N&lt;:AbstractFloat} &lt;: AbstractPointSymmetric{N}</code></pre><p>Type that represents a ball in the p-norm, for <span>$1 ≤ p ≤ ∞$</span>.</p><p>It is defined as the set</p><div>\[\mathcal{B}_p^n(c, r) = \{ x ∈ \mathbb{R}^n : ‖ x - c ‖_p ≤ r \},\]</div><p>where <span>$c ∈ \mathbb{R}^n$</span> is its center and <span>$r ∈ \mathbb{R}_+$</span> its radius. Here <span>$‖ ⋅ ‖_p$</span> for <span>$1 ≤ p ≤ ∞$</span> denotes the vector <span>$p$</span>-norm, defined as <span>$‖ x ‖_p = \left( \sum\limits_{i=1}^n |x_i|^p \right)^{1/p}$</span> for any <span>$x ∈ \mathbb{R}^n$</span>.</p><p><strong>Fields</strong></p><ul><li><p><code>p</code>      – norm as a real scalar</p></li><li><p><code>center</code> – center of the ball as a real vector</p></li><li><p><code>radius</code> – radius of the ball as a scalar (<span>$≥ 0$</span>)</p></li></ul><p><strong>Notes</strong></p><p>The special cases <span>$p=1$</span>, <span>$p=2$</span> and <span>$p=∞$</span> fall back to the specialized types <code>Ball1</code>, <code>Ball2</code> and <code>BallInf</code>, respectively.</p><p><strong>Examples</strong></p><p>A five-dimensional ball in the <span>$p=3/2$</span> norm centered at the origin of radius 0.5:</p><pre><code class="language-julia-repl">julia&gt; B = Ballp(3/2, zeros(5), 0.5)
Ballp{Float64}(1.5, [0.0, 0.0, 0.0, 0.0, 0.0], 0.5)
julia&gt; dim(B)
5</code></pre><p>We evaluate the support vector in direction <span>$[1,2,…,5]$</span>:</p><pre><code class="language-julia-repl">julia&gt; σ([1., 2, 3, 4, 5], B)
5-element Array{Float64,1}:
 0.013516004434607558
 0.05406401773843023
 0.12164403991146802
 0.21625607095372093
 0.33790011086518895</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Ballp.jl#L5-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{AbstractFloat,1},LazySets.Ballp{AbstractFloat}}" href="#LazySets.σ-Tuple{AbstractArray{AbstractFloat,1},LazySets.Ballp{AbstractFloat}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, B::Ballp{N}) where {N&lt;:AbstractFloat}</code></pre><p>Return the support vector of a <code>Ballp</code> in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>B</code> – ball in the p-norm</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the center of the ball is returned.</p><p><strong>Algorithm</strong></p><p>The support vector of the unit ball in the <span>$p$</span>-norm along direction <span>$d$</span> is:</p><div>\[σ_{\mathcal{B}_p^n(0, 1)}(d) = \dfrac{\tilde{v}}{‖\tilde{v}‖_q},\]</div><p>where <span>$\tilde{v}_i = \frac{|d_i|^q}{d_i}$</span> if <span>$d_i ≠ 0$</span> and <span>$tilde{v}_i = 0$</span> otherwise, for all <span>$i=1,…,n$</span>, and <span>$q$</span> is the conjugate number of <span>$p$</span>. By the affine transformation <span>$x = r\tilde{x} + c$</span>, one obtains that the support vector of <span>$\mathcal{B}_p^n(c, r)$</span> is</p><div>\[σ_{\mathcal{B}_p^n(c, r)}(d) = \dfrac{v}{‖v‖_q},\]</div><p>where <span>$v_i = c_i + r\frac{|d_i|^q}{d_i}$</span> if <span>$d_i ≠ 0$</span> and <span>$v_i = 0$</span> otherwise, for all <span>$i = 1, …, n$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Ballp.jl#L105-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{AbstractFloat,1},LazySets.Ballp{AbstractFloat}}" href="#Base.:∈-Tuple{AbstractArray{AbstractFloat,1},LazySets.Ballp{AbstractFloat}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, B::Ballp{N})::Bool where {N&lt;:AbstractFloat}</code></pre><p>Check whether a given point is contained in a ball in the p-norm.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>B</code> – ball in the p-norm</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ B$</span>.</p><p><strong>Notes</strong></p><p>This implementation is worst-case optimized, i.e., it is optimistic and first computes (see below) the whole sum before comparing to the radius. In applications where the point is typically far away from the ball, a fail-fast implementation with interleaved comparisons could be more efficient.</p><p><strong>Algorithm</strong></p><p>Let <span>$B$</span> be an <span>$n$</span>-dimensional ball in the p-norm with radius <span>$r$</span> and let <span>$c_i$</span> and <span>$x_i$</span> be the ball&#39;s center and the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ B$</span> iff <span>$\left( ∑_{i=1}^n |c_i - x_i|^p \right)^{1/p} ≤ r$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = Ballp(1.5, [1., 1.], 1.)
Ballp{Float64}(1.5, [1.0, 1.0], 1.0)
julia&gt; ∈([.5, -.5], B)
false
julia&gt; ∈([.5, 1.5], B)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Ballp.jl#L151-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Tuple{LazySets.Ballp}" href="#LazySets.center-Tuple{LazySets.Ballp}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">center(B::Ballp{N})::Vector{N} where {N&lt;:AbstractFloat}</code></pre><p>Return the center of a ball in the p-norm.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – ball in the p-norm</p></li></ul><p><strong>Output</strong></p><p>The center of the ball in the p-norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Ballp.jl#L84-L96">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.LazySet,Real}"><code>radius</code></a></p></li><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPointSymmetric"><code>AbstractPointSymmetric</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.dim-Tuple{LazySets.AbstractPointSymmetric}"><code>dim</code></a></p></li><li><p><code>an_element</code></p></li></ul><h2><a class="nav-anchor" id="Ellipsoid-1" href="#Ellipsoid-1">Ellipsoid</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Ellipsoid" href="#LazySets.Ellipsoid"><code>LazySets.Ellipsoid</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Ellipsoid{N&lt;:AbstractFloat} &lt;:  AbstractPointSymmetric{N}</code></pre><p>Type that represents an ellipsoid.</p><p>It is defined as the set</p><div>\[E = \left\{ x ∈ \mathbb{R}^n : (x-c)Q^{-1}(x-c) ≤ 1 \right\},\]</div><p>where <span>$c \in \mathbb{R}^n$</span> is its <em>center</em> and <span>$Q \in \mathbb{R}^{n×n}$</span> its <em>shape matrix</em>, which should be a positive definite matrix. An ellipsoid can also be characterized as the image of a Euclidean ball by an invertible linear transformation. It is the higher-dimensional generalization of an ellipse.</p><p><strong>Fields</strong></p><ul><li><p><code>center</code>       – center of the ellipsoid</p></li><li><p><code>shape matrix</code> – real positive definite matrix, i.e. it is equal to its transpose                   and <span>$x^\mathrm{T}Qx &gt; 0$</span> for all nonzero <span>$x$</span></p></li></ul><p><strong>Examples</strong></p><p>If the center is not specified, it is assumed that the center is the origin. For instance, a 3D ellipsoid with center at the origin and the shape matrix being the identity can be created with:</p><pre><code class="language-julia-repl">julia&gt; E = Ellipsoid(Matrix{Float64}(I, 3, 3))
Ellipsoid{Float64}([0.0, 0.0, 0.0], [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])

julia&gt; dim(E)
3

julia&gt; an_element(E)
3-element Array{Float64,1}:
 0.0
 0.0
 0.0</code></pre><p>This ellipsoid corresponds to the unit Euclidean ball. Let&#39;s evaluate its support vector in a given direction:</p><pre><code class="language-julia-repl">julia&gt; σ(ones(3), E)
3-element Array{Float64,1}:
 0.5773502691896258
 0.5773502691896258
 0.5773502691896258</code></pre><p>A two-dimensional ellipsoid with given center and shape matrix:</p><pre><code class="language-julia">julia&gt; E = Ellipsoid(ones(2), Diagonal([2.0, 0.5]))
Ellipsoid{Float64}([1.0, 1.0], [2.0 0.0; 0.0 0.5])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Ellipsoid.jl#L3-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{AbstractFloat,1},LazySets.Ellipsoid{AbstractFloat}}" href="#LazySets.σ-Tuple{AbstractArray{AbstractFloat,1},LazySets.Ellipsoid{AbstractFloat}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, E::Ellipsoid{N}) where {N&lt;:AbstractFloat}</code></pre><p>Return the support vector of an ellipsoid in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>E</code> – ellipsoid</p></li></ul><p><strong>Output</strong></p><p>Support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>Let <span>$E$</span> be an ellipsoid of center <span>$c$</span> and shape matrix <span>$Q = BB^\mathrm{T}$</span>. Its support vector along direction <span>$d$</span> can be deduced from that of the unit Euclidean ball <span>$\mathcal{B}_2$</span> using the algebraic relations for the support vector,</p><div>\[σ_{B\mathcal{B}_2 ⊕ c}(d) = c + Bσ_{\mathcal{B}_2} (B^\mathrm{T} d)
= c + \dfrac{Qd}{\sqrt{d^\mathrm{T}Q d}}.\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Ellipsoid.jl#L100-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{AbstractFloat,1},LazySets.Ellipsoid{AbstractFloat}}" href="#Base.:∈-Tuple{AbstractArray{AbstractFloat,1},LazySets.Ellipsoid{AbstractFloat}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, E::Ellipsoid{N})::Bool where {N&lt;:AbstractFloat}</code></pre><p>Check whether a given point is contained in an ellipsoid.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>E</code> – ellipsoid</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>x ∈ E</code>.</p><p><strong>Algorithm</strong></p><p>The point <span>$x$</span> belongs to the ellipsoid of center <span>$c$</span> and shape matrix <span>$Q$</span> if and only if</p><div>\[(x-c)^\mathrm{T} Q^{-1} (x-c) ≤ 1.\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Ellipsoid.jl#L134-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Tuple{LazySets.Ellipsoid}" href="#LazySets.center-Tuple{LazySets.Ellipsoid}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">center(E::Ellipsoid{N})::Vector{N} where {N&lt;:AbstractFloat}</code></pre><p>Return the center of the ellipsoid.</p><p><strong>Input</strong></p><ul><li><p><code>E</code> – ellipsoid</p></li></ul><p><strong>Output</strong></p><p>The center of the ellipsoid.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Ellipsoid.jl#L83-L95">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.LazySet,Real}"><code>radius</code></a></p></li><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPointSymmetric"><code>AbstractPointSymmetric</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.dim-Tuple{LazySets.AbstractPointSymmetric}"><code>dim</code></a></p></li><li><p><code>an_element</code></p></li></ul><h2><a class="nav-anchor" id="Empty-set-1" href="#Empty-set-1">Empty set</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.EmptySet" href="#LazySets.EmptySet"><code>LazySets.EmptySet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">EmptySet{N&lt;:Real} &lt;: LazySet{N}</code></pre><p>Type that represents the empty set, i.e., the set with no elements.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/EmptySet.jl#L6-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.∅" href="#LazySets.∅"><code>LazySets.∅</code></a> — <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">∅</code></pre><p>An <code>EmptySet</code> instance of type <code>Float64</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/EmptySet.jl#L16-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.EmptySet}" href="#LazySets.dim-Tuple{LazySets.EmptySet}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(∅::EmptySet)</code></pre><p>Return the dimension of the empty set, which is -1 by convention.</p><p><strong>Input</strong></p><ul><li><p><code>∅</code> – an empty set</p></li></ul><p><strong>Output</strong></p><p><code>-1</code> by convention.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/EmptySet.jl#L23-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.EmptySet{Real}}" href="#LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.EmptySet{Real}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, ∅::EmptySet{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of an empty set.</p><p><strong>Input</strong></p><ul><li><p><code>∅</code> – an empty set</p></li></ul><p><strong>Output</strong></p><p>An error.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/EmptySet.jl#L40-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Real,1},LazySets.EmptySet{Real}}" href="#Base.:∈-Tuple{AbstractArray{Real,1},LazySets.EmptySet{Real}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector, ∅::EmptySet)::Bool</code></pre><p>Check whether a given point is contained in an empty set.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>∅</code> – empty set</p></li></ul><p><strong>Output</strong></p><p>The output is always <code>false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ∈([1.0, 0.0], ∅)
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/EmptySet.jl#L57-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{LazySets.EmptySet}" href="#LazySets.an_element-Tuple{LazySets.EmptySet}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(∅::EmptySet)</code></pre><p>Return some element of an empty set.</p><p><strong>Input</strong></p><ul><li><p><code>∅</code> – empty set</p></li></ul><p><strong>Output</strong></p><p>An error.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/EmptySet.jl#L82-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.norm-Tuple{LazySets.EmptySet,Real}" href="#Base.LinAlg.norm-Tuple{LazySets.EmptySet,Real}"><code>Base.LinAlg.norm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">norm(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the norm of a convex set. It is the norm of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LazySet.jl#L104-L119">source</a><div><pre><code class="language-none">norm(S::EmptySet, [p]::Real=Inf)</code></pre><p>Return the norm of an empty set. It is the norm of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – empty set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>An error.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/EmptySet.jl#L99-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius-Tuple{LazySets.EmptySet,Real}" href="#LazySets.radius-Tuple{LazySets.EmptySet,Real}"><code>LazySets.radius</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the radius of a convex set. It is the radius of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LazySet.jl#L128-L143">source</a><div><pre><code class="language-none">radius(S::EmptySet, [p]::Real=Inf)</code></pre><p>Return the radius of an empty set. It is the radius of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – empty set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>An error.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/EmptySet.jl#L119-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.diameter-Tuple{LazySets.EmptySet,Real}" href="#LazySets.diameter-Tuple{LazySets.EmptySet,Real}"><code>LazySets.diameter</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">diameter(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the diameter of a convex set. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LazySet.jl#L152-L168">source</a><div><pre><code class="language-none">diameter(S::EmptySet, [p]::Real=Inf)</code></pre><p>Return the diameter of an empty set. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – empty set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>An error.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/EmptySet.jl#L139-L155">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.LazySet,Real}"><code>radius</code></a></p></li><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><h2><a class="nav-anchor" id="Half-Space-1" href="#Half-Space-1">Half-Space</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.HalfSpace" href="#LazySets.HalfSpace"><code>LazySets.HalfSpace</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HalfSpace{N&lt;:Real} &lt;: LazySet{N}</code></pre><p>Type that represents a (closed) half-space of the form <span>$a⋅x ≤ b$</span>.</p><p><strong>Fields</strong></p><ul><li><p><code>a</code> – normal direction</p></li><li><p><code>b</code> – constraint</p></li></ul><p><strong>Examples</strong></p><p>The set <span>$y ≥ 0$</span> in the plane:</p><pre><code class="language-julia-repl">julia&gt; HalfSpace([0, -1.], 0.)
HalfSpace{Float64}([0.0, -1.0], 0.0)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HalfSpace.jl#L7-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.LinearConstraint" href="#LazySets.LinearConstraint"><code>LazySets.LinearConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LinearConstraint</code></pre><p>Alias for <code>HalfSpace</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HalfSpace.jl#L31-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.HalfSpace}" href="#LazySets.dim-Tuple{LazySets.HalfSpace}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(hs::HalfSpace)::Int</code></pre><p>Return the dimension of a half-space.</p><p><strong>Input</strong></p><ul><li><p><code>hs</code> – half-space</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the half-space.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HalfSpace.jl#L42-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.HalfSpace{Real}}" href="#LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.HalfSpace{Real}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, hs::HalfSpace{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a half-space.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>  – direction</p></li><li><p><code>hs</code> – half-space</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction, which is only defined in the following two cases:</p><ol><li><p>The direction has norm zero.</p></li><li><p>The direction is the half-space&#39;s normal direction.</p></li></ol><p>In both cases the result is any point on the boundary (the defining hyperplane). Otherwise this function throws an error.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HalfSpace.jl#L59-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Real,1},LazySets.HalfSpace{Real}}" href="#Base.:∈-Tuple{AbstractArray{Real,1},LazySets.HalfSpace{Real}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, hs::HalfSpace{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a half-space.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>hs</code> – half-space</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ hs$</span>.</p><p><strong>Algorithm</strong></p><p>We just check if <span>$x$</span> satisfies <span>$a⋅x ≤ b$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HalfSpace.jl#L99-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{LazySets.HalfSpace{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{LazySets.HalfSpace{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(hs::HalfSpace{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a half-space.</p><p><strong>Input</strong></p><ul><li><p><code>hs</code> – half-space</p></li></ul><p><strong>Output</strong></p><p>An element on the defining hyperplane.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HalfSpace.jl#L82-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.halfspace_left-Tuple{AbstractArray{Real,1},AbstractArray{Real,1}}" href="#LazySets.halfspace_left-Tuple{AbstractArray{Real,1},AbstractArray{Real,1}}"><code>LazySets.halfspace_left</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">halfspace_left(p::AbstractVector{N},
               q::AbstractVector{N})::HalfSpace{N} where {N&lt;:Real}</code></pre><p>Return a half-space describing the &#39;left&#39; of a two-dimensional line segment through two points.</p><p><strong>Input</strong></p><ul><li><p><code>p</code> – first point</p></li><li><p><code>q</code> – second point</p></li></ul><p><strong>Output</strong></p><p>The half-space whose boundary goes through the two points <code>p</code> and <code>q</code> and which describes the left-hand side of the directed line segment <code>pq</code>.</p><p><strong>Algorithm</strong></p><p>The implementation is simple: the half-space <span>$a⋅x ≤ b$</span> is calculated as <code>a = [dy, -dx]</code>, where <span>$d = (dx, dy)$</span> denotes the line segment <code>pq</code>, that is, <span>$\vec{d} = \vec{p} - \vec{q}$</span>, and <code>b = dot(p, a)</code>.</p><p><strong>Examples</strong></p><p>The left half-space of the &quot;east&quot; and &quot;west&quot; directions in two-dimensions are the upper and lower half-spaces:</p><pre><code class="language-julia-repl">julia&gt; import LazySets.halfspace_left

julia&gt; halfspace_left([0.0, 0.0], [1.0, 0.0])
HalfSpace{Float64}([0.0, -1.0], 0.0)

julia&gt; halfspace_left([0.0, 0.0], [-1.0, 0.0])
HalfSpace{Float64}([0.0, 1.0], 0.0)</code></pre><p>We create a box from the sequence of line segments that describe its edges:</p><pre><code class="language-julia-repl">julia&gt; H1 = halfspace_left([-1.0, -1.0], [1.0, -1.0]);

julia&gt; H2 = halfspace_left([1.0, -1.0], [1.0, 1.0]);

julia&gt; H3 = halfspace_left([1.0, 1.0], [-1.0, 1.0]);

julia&gt; H4 = halfspace_left([-1.0, 1.0], [-1.0, -1.0]);

julia&gt; H = HPolygon([H1, H2, H3, H4]);

julia&gt; B = BallInf([0.0, 0.0], 1.0);

julia&gt; B ⊆ H &amp;&amp; H ⊆ B
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HalfSpace.jl#L121-L177">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.halfspace_right-Tuple{AbstractArray{Real,1},AbstractArray{Real,1}}" href="#LazySets.halfspace_right-Tuple{AbstractArray{Real,1},AbstractArray{Real,1}}"><code>LazySets.halfspace_right</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">halfspace_right(p::AbstractVector{N},
                q::AbstractVector{N})::HalfSpace{N} where {N&lt;:Real}</code></pre><p>Return a half-space describing the &#39;right&#39; of a two-dimensional line segment through two points.</p><p><strong>Input</strong></p><ul><li><p><code>p</code> – first point</p></li><li><p><code>q</code> – second point</p></li></ul><p><strong>Output</strong></p><p>The half-space whose boundary goes through the two points <code>p</code> and <code>q</code> and which describes the right-hand side of the directed line segment <code>pq</code>.</p><p><strong>Algorithm</strong></p><p>See the documentation of <code>halfspace_left</code>. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HalfSpace.jl#L186-L206">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.LazySet,Real}"><code>radius</code></a></p></li><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><h2><a class="nav-anchor" id="Hyperplane-1" href="#Hyperplane-1">Hyperplane</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Hyperplane" href="#LazySets.Hyperplane"><code>LazySets.Hyperplane</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Hyperplane{N&lt;:Real} &lt;: LazySet{N}</code></pre><p>Type that represents a hyperplane of the form <span>$a⋅x = b$</span>.</p><p><strong>Fields</strong></p><ul><li><p><code>a</code> – normal direction</p></li><li><p><code>b</code> – constraint</p></li></ul><p><strong>Examples</strong></p><p>The plane <span>$y = 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; Hyperplane([0, 1.], 0.)
Hyperplane{Float64}([0.0, 1.0], 0.0)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Hyperplane.jl#L6-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.Hyperplane}" href="#LazySets.dim-Tuple{LazySets.Hyperplane}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(hp::Hyperplane)::Int</code></pre><p>Return the dimension of a hyperplane.</p><p><strong>Input</strong></p><ul><li><p><code>hp</code> – hyperplane</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the hyperplane.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Hyperplane.jl#L34-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.Hyperplane{Real}}" href="#LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.Hyperplane{Real}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, hp::Hyperplane{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a hyperplane.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>  – direction</p></li><li><p><code>hp</code> – hyperplane</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction, which is only defined in the following two cases:</p><ol><li><p>The direction has norm zero.</p></li><li><p>The direction is the hyperplane&#39;s normal direction.</p></li></ol><p>In both cases the result is any point on the hyperplane. Otherwise this function throws an error.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Hyperplane.jl#L51-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Real,1},LazySets.Hyperplane{Real}}" href="#Base.:∈-Tuple{AbstractArray{Real,1},LazySets.Hyperplane{Real}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, hp::Hyperplane{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a hyperplane.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>hp</code> – hyperplane</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ hp$</span>.</p><p><strong>Algorithm</strong></p><p>We just check if <span>$x$</span> satisfies <span>$a⋅x = b$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Hyperplane.jl#L91-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{LazySets.Hyperplane{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{LazySets.Hyperplane{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(hp::Hyperplane{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a hyperplane.</p><p><strong>Input</strong></p><ul><li><p><code>hp</code> – hyperplane</p></li></ul><p><strong>Output</strong></p><p>An element on the hyperplane.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Hyperplane.jl#L74-L86">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.LazySet,Real}"><code>radius</code></a></p></li><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><h2><a class="nav-anchor" id="Hyperrectangle-1" href="#Hyperrectangle-1">Hyperrectangle</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Hyperrectangle" href="#LazySets.Hyperrectangle"><code>LazySets.Hyperrectangle</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Hyperrectangle{N&lt;:Real} &lt;: AbstractHyperrectangle{N}</code></pre><p>Type that represents a hyperrectangle.</p><p>A <a href="https://en.wikipedia.org/wiki/Hyperrectangle">hyperrectangle</a> is the Cartesian product of one-dimensional intervals.</p><p><strong>Fields</strong></p><ul><li><p><code>center</code> – center of the hyperrectangle as a real vector</p></li><li><p><code>radius</code> – radius of the ball as a real vector, i.e., half of its width along             each coordinate direction</p></li></ul><p><strong>Examples</strong></p><p>There is also a constructor from lower and upper bounds with keyword arguments <code>high</code> and <code>low</code>. The following two constructions are equivalent:</p><pre><code class="language-julia-repl">julia&gt; c = ones(2);

julia&gt; r = [0.1, 0.2];

julia&gt; l = [0.9, 0.8];

julia&gt; h = [1.1, 1.2];

julia&gt; Hyperrectangle(c, r)
Hyperrectangle{Float64}([1.0, 1.0], [0.1, 0.2])
julia&gt; Hyperrectangle(low=l, high=h)
Hyperrectangle{Float64}([1.0, 1.0], [0.1, 0.2])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Hyperrectangle.jl#L5-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Tuple{LazySets.Hyperrectangle}" href="#LazySets.center-Tuple{LazySets.Hyperrectangle}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">center(H::Hyperrectangle{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li></ul><p><strong>Output</strong></p><p>The center of the hyperrectangle.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Hyperrectangle.jl#L133-L145">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Tuple{LazySets.Hyperrectangle}" href="#LazySets.radius_hyperrectangle-Tuple{LazySets.Hyperrectangle}"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius_hyperrectangle(H::Hyperrectangle{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the box radius of a hyperrectangle in every dimension.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li></ul><p><strong>Output</strong></p><p>The box radius of the hyperrectangle.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Hyperrectangle.jl#L112-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Tuple{LazySets.Hyperrectangle,Int64}" href="#LazySets.radius_hyperrectangle-Tuple{LazySets.Hyperrectangle,Int64}"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius_hyperrectangle(H::Hyperrectangle{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the box radius of a hyperrectangle in a given dimension.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li></ul><p><strong>Output</strong></p><p>The radius in the given dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Hyperrectangle.jl#L95-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Tuple{LazySets.Hyperrectangle}" href="#LazySets.high-Tuple{LazySets.Hyperrectangle}"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">high(H::Hyperrectangle{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the higher coordinates of a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li></ul><p><strong>Output</strong></p><p>A vector with the higher coordinates of the hyperrectangle, one entry per dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Hyperrectangle.jl#L154-L167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Tuple{LazySets.Hyperrectangle}" href="#LazySets.low-Tuple{LazySets.Hyperrectangle}"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">low(H::Hyperrectangle{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the lower coordinates of a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li></ul><p><strong>Output</strong></p><p>A vector with the lower coordinates of the hyperrectangle, one entry per dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Hyperrectangle.jl#L172-L185">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.singleton_list-Tuple{LazySets.AbstractPolytope}"><code>singleton_list</code></a></p></li><li><p><a href="interfaces.html#LazySets.linear_map-Tuple{AbstractArray{T,2} where T,LazySets.AbstractPolytope}"><code>linear_map</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPointSymmetricPolytope"><code>AbstractPointSymmetricPolytope</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.dim-Tuple{LazySets.AbstractPointSymmetricPolytope}"><code>dim</code></a></p></li><li><p><code>an_element</code></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractHyperrectangle"><code>AbstractHyperrectangle</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.AbstractHyperrectangle{Real}}"><code>σ</code></a></p></li><li><p><a href="interfaces.html#Base.:∈-Tuple{AbstractArray{Real,1},LazySets.AbstractHyperrectangle{Real}}"><code>∈</code></a></p></li><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.AbstractHyperrectangle,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.AbstractHyperrectangle,Real}"><code>radius</code></a></p></li><li><p><a href="interfaces.html#LazySets.vertices_list-Tuple{LazySets.AbstractHyperrectangle{Real}}"><code>vertices_list</code></a></p></li></ul><h2><a class="nav-anchor" id="Interval-1" href="#Interval-1">Interval</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Interval" href="#LazySets.Interval"><code>LazySets.Interval</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Interval{N&lt;:Real, IN &lt;: AbstractInterval{N}} &lt;: AbstractPointSymmetricPolytope{N}</code></pre><p>Type representing an interval on the real line. Mathematically, it is of the form</p><div>\[[a, b] := \{ a ≤ x ≤ b \} ⊆ \mathbb{R}.\]</div><p><strong>Fields</strong></p><ul><li><p><code>dat</code> – data container for the given interval</p></li></ul><p><strong>Notes</strong></p><p>This type relies on the <a href="https://juliaintervals.github.io/IntervalArithmetic.jl/stable/">IntervalArithmetic.jl</a> library for representation of intervals and arithmetic operations.</p><p><strong>Examples</strong></p><p>Unidimensional intervals are symbolic representations of a real closed interval.</p><p>We can create intervals in different ways, the simpler way is to pass a pair of numbers:</p><pre><code class="language-julia-repl">julia&gt; x = Interval(0.0, 1.0)
Interval{Float64,IntervalArithmetic.Interval{Float64}}([0, 1])</code></pre><p>or a 2-vector:</p><pre><code class="language-julia-repl">julia&gt; x = Interval([0.0, 1.0])
Interval{Float64,IntervalArithmetic.Interval{Float64}}([0, 1])</code></pre><p>Note that if the package <code>IntervalArithmetic</code> is loaded in the current scope, you have to prepend the <code>LazySets</code> to the interval type, since there is a name conflict otherwise.</p><pre><code class="language-julia-repl">julia&gt; using IntervalArithmetic
WARNING: using IntervalArithmetic.Interval in module Main conflicts with an existing identifier.

julia&gt; x = Interval(IntervalArithmetic.Interval(0.0, 1.0))
Interval{Float64,IntervalArithmetic.Interval{Float64}}([0, 1])

julia&gt; dim(x)
1

julia&gt; center(x)
1-element Array{Float64,1}:
 0.5</code></pre><p>This type is such that the usual pairwise arithmetic operators <code>+</code>, <code>-</code>, <code>*</code> trigger the corresponding interval arithmetic backend method, and return a new <code>Interval</code> object. For the symbolic Minkowksi sum, use <code>MinkowskiSum</code> or <code>⊕</code>.</p><p>Interval of other numeric types can be created as well, eg. a rational interval:</p><pre><code class="language-julia-repl">julia&gt; Interval(0//1, 2//1)
Interval{Rational{Int64},IntervalArithmetic.AbstractInterval{Rational{Int64}}}([0//1, 2//1])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Interval.jl#L9-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.Interval}" href="#LazySets.dim-Tuple{LazySets.Interval}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(x::Interval)::Int</code></pre><p>Return the ambient dimension of an interval.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – interval</p></li></ul><p><strong>Output</strong></p><p>The integer 1.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Interval.jl#L112-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.Interval{Real,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{Real}}" href="#LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.Interval{Real,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{Real}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, x::Interval{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of an ellipsoid in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>x</code> – interval</p></li></ul><p><strong>Output</strong></p><p>Support vector in the given direction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Interval.jl#L127-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{T,1} where T,LazySets.Interval}" href="#Base.:∈-Tuple{AbstractArray{T,1} where T,LazySets.Interval}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(v::AbstractVector, x::Interval)</code></pre><p>Return whether a vector is contained in the interval.</p><p><strong>Input</strong></p><ul><li><p><code>v</code> – one-dimensional vector</p></li><li><p><code>x</code> – interval</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>x</code> contains <code>v</code>&#39;s first component.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Interval.jl#L211-L224">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{Real,LazySets.Interval}" href="#Base.:∈-Tuple{Real,LazySets.Interval}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(v::N, x::Interval) where {N}</code></pre><p>Return whether a number is contained in the interval.</p><p><strong>Input</strong></p><ul><li><p><code>v</code> – scalar</p></li><li><p><code>x</code> – interval</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>x</code> contains <code>v</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Interval.jl#L227-L240">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{LazySets.Interval}" href="#LazySets.an_element-Tuple{LazySets.Interval}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>An element of a convex set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LazySet.jl#L174-L186">source</a><div><pre><code class="language-none">an_element(P::AbstractPointSymmetricPolytope{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a point symmetric polytope.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – point symmetric polytope</p></li></ul><p><strong>Output</strong></p><p>The center of the point symmetric polytope.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractPointSymmetricPolytope.jl#L60-L72">source</a><div><pre><code class="language-none">an_element(x::Interval{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of an interval.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – interval</p></li></ul><p><strong>Output</strong></p><p>The left border (<code>low(x)</code>) of the interval.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Interval.jl#L273-L285">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.Interval}" href="#LazySets.vertices_list-Tuple{LazySets.Interval}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(x::Interval)</code></pre><p>Return the list of vertices of this interval.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – interval</p></li></ul><p><strong>Output</strong></p><p>The list of vertices of the interval represented as two one-dimensional vectors.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Interval.jl#L290-L302">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Tuple{LazySets.Interval}" href="#LazySets.center-Tuple{LazySets.Interval}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">center(x::Interval)</code></pre><p>Return the interval&#39;s center.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – interval</p></li></ul><p><strong>Output</strong></p><p>The center, or midpoint, of <span>$x$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Interval.jl#L146-L158">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Tuple{LazySets.Interval}" href="#LazySets.low-Tuple{LazySets.Interval}"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">low(x::Interval)</code></pre><p>Return the lower component of an interval.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – interval</p></li></ul><p><strong>Output</strong></p><p>The lower (<code>lo</code>) component of the interval.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Interval.jl#L243-L255">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Tuple{LazySets.Interval}" href="#LazySets.high-Tuple{LazySets.Interval}"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">high(x::Interval)</code></pre><p>Return the higher or upper component of an interval.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – interval</p></li></ul><p><strong>Output</strong></p><p>The higher (<code>hi</code>) component of the interval.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Interval.jl#L258-L270">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{LazySets.Interval,LazySets.Interval}" href="#Base.:+-Tuple{LazySets.Interval,LazySets.Interval}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">+(x::Interval, y::Interval)</code></pre><p>Return the sum of the intervals.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – interval</p></li><li><p><code>y</code> – interval</p></li></ul><p><strong>Output</strong></p><p>The sum of the intervals as a new <code>Interval</code> set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Interval.jl#L161-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Tuple{LazySets.Interval,LazySets.Interval}" href="#Base.:--Tuple{LazySets.Interval,LazySets.Interval}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">-(x::Interval, y::Interval)</code></pre><p>Return the difference of the intervals.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – interval</p></li><li><p><code>y</code> – interval</p></li></ul><p><strong>Output</strong></p><p>The difference of the intervals as a new <code>Interval</code> set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Interval.jl#L177-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{LazySets.Interval,LazySets.Interval}" href="#Base.:*-Tuple{LazySets.Interval,LazySets.Interval}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">    *(x::Interval, y::Interval)</code></pre><p>Return the product of the intervals.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – interval</p></li><li><p><code>y</code> – interval</p></li></ul><p><strong>Output</strong></p><p>The product of the intervals as a new <code>Interval</code> set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Interval.jl#L193-L208">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.singleton_list-Tuple{LazySets.AbstractPolytope}"><code>singleton_list</code></a></p></li><li><p><a href="interfaces.html#LazySets.linear_map-Tuple{AbstractArray{T,2} where T,LazySets.AbstractPolytope}"><code>linear_map</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractHyperrectangle"><code>AbstractHyperrectangle</code></a>:</p><ul><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.AbstractHyperrectangle,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.AbstractHyperrectangle,Real}"><code>radius</code></a></p></li></ul><h2><a class="nav-anchor" id="Line-1" href="#Line-1">Line</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Line" href="#LazySets.Line"><code>LazySets.Line</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Line{N&lt;:Real} &lt;: LazySet{N}</code></pre><p>Type that represents a line in 2D of the form <span>$a⋅x = b$</span> (i.e., a special case of a <code>Hyperplane</code>).</p><p><strong>Fields</strong></p><ul><li><p><code>a</code> – normal direction</p></li><li><p><code>b</code> – constraint</p></li></ul><p><strong>Examples</strong></p><p>The line <span>$y = -x + 1$</span>:</p><pre><code class="language-julia-repl">julia&gt; Line([1., 1.], 1.)
Line{Float64,Array{Float64,1}}([1.0, 1.0], 1.0)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Line.jl#L6-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.Line}" href="#LazySets.dim-Tuple{LazySets.Line}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(L::Line)::Int</code></pre><p>Return the ambient dimension of a line.</p><p><strong>Input</strong></p><ul><li><p><code>L</code> – line</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the line, which is 2.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Line.jl#L48-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.Line{Real,V} where V&lt;:AbstractArray{Real,1}}" href="#LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.Line{Real,V} where V&lt;:AbstractArray{Real,1}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, L::Line{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a line in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>L</code> – line</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction, which is defined the same way as for the more general <code>Hyperplane</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Line.jl#L65-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Real,1},LazySets.Line{Real,V} where V&lt;:AbstractArray{Real,1}}" href="#Base.:∈-Tuple{AbstractArray{Real,1},LazySets.Line{Real,V} where V&lt;:AbstractArray{Real,1}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, L::Line{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a line.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>L</code> – line</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>x ∈ L</code>.</p><p><strong>Algorithm</strong></p><p>The point <span>$x$</span> belongs to the line if and only if <span>$a⋅x = b$</span> holds.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Line.jl#L115-L132">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{LazySets.Line{N,V} where V&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{LazySets.Line{N,V} where V&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(L::Line{N})::Vector{N} where N&lt;:Real</code></pre><p>Return some element of a line.</p><p><strong>Input</strong></p><ul><li><p><code>L</code> – line</p></li></ul><p><strong>Output</strong></p><p>An element on the line.</p><p><strong>Algorithm</strong></p><p>If the <span>$b$</span> value of the line is zero, the result is the origin. Otherwise the result is some <span>$x = [x1, x2]$</span> such that <span>$a·[x1, x2] = b$</span>. We first find out in which dimension <span>$a$</span> is nonzero, say, dimension 1, and then choose <span>$x1 = 1$</span> and accordingly <span>$x2 = \frac{b - a1}{a2}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Line.jl#L84-L103">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.LazySet,Real}"><code>radius</code></a></p></li><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><h2><a class="nav-anchor" id="Line-segment-1" href="#Line-segment-1">Line segment</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.LineSegment" href="#LazySets.LineSegment"><code>LazySets.LineSegment</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LineSegment{N&lt;:Real} &lt;: AbstractPointSymmetricPolytope{N}</code></pre><p>Type that represents a line segment in 2D between two points <span>$p$</span> and <span>$q$</span>.</p><p><strong>Fields</strong></p><ul><li><p><code>p</code> – first point</p></li><li><p><code>q</code> – second point</p></li></ul><p><strong>Examples</strong></p><p>A line segment along the <span>$x = y$</span> diagonal:</p><pre><code class="language-julia-repl">julia&gt; s = LineSegment([0., 0], [1., 1.])
LineSegment{Float64}([0.0, 0.0], [1.0, 1.0])
julia&gt; dim(s)
2</code></pre><p>Use <span>$plot(s)$</span> to plot the extreme points of <code>s</code> and the line segment joining them. Membership test is computed with ∈ (<code>in</code>):</p><pre><code class="language-julia-repl">julia&gt; [0., 0] ∈ s &amp;&amp; [.25, .25] ∈ s &amp;&amp; [1., 1] ∈ s &amp;&amp; !([.5, .25] ∈ s)
true</code></pre><p>We can check the intersection with another line segment, and optionally compute a witness (which is just the common point in this case):</p><pre><code class="language-julia-repl">julia&gt; sn = LineSegment([1., 0], [0., 1.])
LineSegment{Float64}([1.0, 0.0], [0.0, 1.0])
julia&gt; isempty(s ∩ sn)
false
julia&gt; is_intersection_empty(s, sn, true)
(false, [0.5, 0.5])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LineSegment.jl#L6-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.LineSegment}" href="#LazySets.dim-Tuple{LazySets.LineSegment}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(L::LineSegment)::Int</code></pre><p>Return the ambient dimension of a line segment.</p><p><strong>Input</strong></p><ul><li><p><code>L</code> – line segment</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the line segment, which is 2.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LineSegment.jl#L69-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.LineSegment{Real}}" href="#LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.LineSegment{Real}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, L::LineSegment{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a line segment in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>L</code> – line segment</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>If the angle between the vector <span>$q - p$</span> and <span>$d$</span> is bigger than 90° and less than 270° (measured in counter-clockwise order), the result is <span>$p$</span>, otherwise it is <span>$q$</span>. If the angle is exactly 90° or 270°, or if the direction has norm zero, this implementation returns <span>$q$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LineSegment.jl#L86-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Real,1},LazySets.LineSegment{Real}}" href="#Base.:∈-Tuple{AbstractArray{Real,1},LazySets.LineSegment{Real}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, L::LineSegment{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a line segment.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>L</code> – line segment</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ L$</span>.</p><p><strong>Algorithm</strong></p><p>Let <span>$L = (p, q)$</span> be the line segment with extremes <span>$p$</span> and <span>$q$</span>, and let <span>$x$</span> be the given point.</p><ol><li><p>A necessary condition for <span>$x ∈ (p, q)$</span> is that the three points are aligned, thus their cross product should be zero.</p></li><li><p>It remains to check that <span>$x$</span> belongs to the box approximation of <span>$L$</span>. This amounts to comparing each coordinate with those of the extremes <span>$p$</span> and <span>$q$</span>.</p></li></ol><p><strong>Notes</strong></p><p>The algorithm is inspired from <a href="https://stackoverflow.com/a/328110">here</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LineSegment.jl#L129-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.halfspace_left-Tuple{LazySets.LineSegment}" href="#LazySets.halfspace_left-Tuple{LazySets.LineSegment}"><code>LazySets.halfspace_left</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">halfspace_left(L::LineSegment)</code></pre><p>Return a half-space describing the &#39;left&#39; of a two-dimensional line segment through two points.</p><p><strong>Input</strong></p><ul><li><p><code>L</code> – line segment</p></li></ul><p><strong>Output</strong></p><p>The half-space whose boundary goes through the two points <code>p</code> and <code>q</code> and which describes the left-hand side of the directed line segment <code>pq</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LineSegment.jl#L218-L232">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.halfspace_right-Tuple{LazySets.LineSegment}" href="#LazySets.halfspace_right-Tuple{LazySets.LineSegment}"><code>LazySets.halfspace_right</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">halfspace_right(L::LineSegment)</code></pre><p>Return a half-space describing the &#39;right&#39; of a two-dimensional line segment through two points.</p><p><strong>Input</strong></p><ul><li><p><code>L</code> – line segment</p></li></ul><p><strong>Output</strong></p><p>The half-space whose boundary goes through the two points <code>p</code> and <code>q</code> and which describes the right-hand side of the directed line segment <code>pq</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/LineSegment.jl#L235-L249">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.LazySet,Real}"><code>radius</code></a></p></li><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><h2><a class="nav-anchor" id="Polygons-1" href="#Polygons-1">Polygons</a></h2><h3><a class="nav-anchor" id="Constraint-representation-1" href="#Constraint-representation-1">Constraint representation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.HPolygon" href="#LazySets.HPolygon"><code>LazySets.HPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HPolygon{N&lt;:Real} &lt;: AbstractHPolygon{N}</code></pre><p>Type that represents a convex polygon in constraint representation whose edges are sorted in counter-clockwise fashion with respect to their normal directions.</p><p><strong>Fields</strong></p><ul><li><p><code>constraints</code> – list of linear constraints, sorted by the angle</p></li></ul><p><strong>Notes</strong></p><p>The default constructor assumes that the given list of edges is sorted. It <em>does not perform</em> any sorting. Use <code>addconstraint!</code> to iteratively add the edges in a sorted way.</p><ul><li><p><code>HPolygon(constraints::Vector{LinearConstraint{&lt;:Real}})</code> – default constructor</p></li><li><p><code>HPolygon()</code> – constructor with no constraints</p></li><li><p><code>HPolygon(S::LazySet)</code> – constructor from another set</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HPolygon.jl#L5-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.HPolygon{Real}}" href="#LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.HPolygon{Real}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, P::HPolygon{N};
  [linear_search]::Bool=(length(P.constraints) &lt; BINARY_SEARCH_THRESHOLD)
 ) where {N&lt;:Real}</code></pre><p>Return the support vector of a polygon in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>             – direction</p></li><li><p><code>P</code>             – polygon in constraint representation</p></li><li><p><code>linear_search</code> – (optional, default: see below) flag for controlling whether                    to perform a linear search or a binary search</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. The result is always one of the vertices; in particular, if the direction has norm zero, any vertex is returned.</p><p><strong>Algorithm</strong></p><p>Comparison of directions is performed using polar angles; see the overload of <code>&lt;=</code> for two-dimensional vectors.</p><p>For polygons with <code>BINARY_SEARCH_THRESHOLD = 10</code> or more constraints we use a binary search by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HPolygon.jl#L44-L71">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.LazySet,Real}"><code>radius</code></a></p></li><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.singleton_list-Tuple{LazySets.AbstractPolytope}"><code>singleton_list</code></a></p></li><li><p><a href="interfaces.html#LazySets.linear_map-Tuple{AbstractArray{T,2} where T,LazySets.AbstractPolytope}"><code>linear_map</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPolygon"><code>AbstractPolygon</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.dim-Tuple{LazySets.AbstractPolygon}"><code>dim</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractHPolygon"><code>AbstractHPolygon</code></a>:</p><ul><li><p><code>an_element</code></p></li><li><p><a href="interfaces.html#Base.:∈-Tuple{AbstractArray{Real,1},LazySets.AbstractHPolygon{Real}}"><code>∈</code></a></p></li><li><p><a href="interfaces.html#LazySets.vertices_list-Tuple{LazySets.AbstractHPolygon{Real}}"><code>vertices_list</code></a></p></li><li><p><a href="interfaces.html#LazySets.tohrep-Tuple{LazySets.AbstractHPolygon{Real}}"><code>tohrep</code></a></p></li><li><p><a href="interfaces.html#LazySets.tovrep-Tuple{LazySets.AbstractHPolygon{Real}}"><code>tovrep</code></a></p></li><li><p><a href="interfaces.html#LazySets.addconstraint!-Tuple{LazySets.AbstractHPolygon{Real},LazySets.HalfSpace{Real}}"><code>addconstraint!</code></a></p></li><li><p><a href="interfaces.html#LazySets.constraints_list-Tuple{LazySets.AbstractHPolygon{Real}}"><code>constraints_list</code></a></p></li></ul><h3><a class="nav-anchor" id="Optimized-constraint-representation-1" href="#Optimized-constraint-representation-1">Optimized constraint representation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.HPolygonOpt" href="#LazySets.HPolygonOpt"><code>LazySets.HPolygonOpt</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HPolygonOpt{N&lt;:Real} &lt;: AbstractHPolygon{N}</code></pre><p>Type that represents a convex polygon in constraint representation whose edges are sorted in counter-clockwise fashion with respect to their normal directions. This is a refined version of <code>HPolygon</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>constraints</code> – list of linear constraints</p></li><li><p><code>ind</code> – index in the list of constraints to begin the search to evaluate the          support function</p></li></ul><p><strong>Notes</strong></p><p>This structure is optimized to evaluate the support function/vector with a large sequence of directions that are close to each other. The strategy is to have an index that can be used to warm-start the search for optimal values in the support vector computation.</p><p>The default constructor assumes that the given list of edges is sorted. It <em>does not perform</em> any sorting. Use <code>addconstraint!</code> to iteratively add the edges in a sorted way.</p><ul><li><p><code>HPolygonOpt(constraints::Vector{LinearConstraint{&lt;:Real}}, [ind]::Int)</code> – default constructor with optional index</p></li><li><p><code>HPolygonOpt(S::LazySet)</code> – constructor from another set</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HPolygonOpt.jl#L5-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.HPolygonOpt{Real}}" href="#LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.HPolygonOpt{Real}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, P::HPolygonOpt{N};
  [linear_search]::Bool=(length(P.constraints) &lt; BINARY_SEARCH_THRESHOLD)
 ) where {N&lt;:Real}</code></pre><p>Return the support vector of an optimized polygon in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>             – direction</p></li><li><p><code>P</code>             – optimized polygon in constraint representation</p></li><li><p><code>linear_search</code> – (optional, default: see below) flag for controlling whether                    to perform a linear search or a binary search</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. The result is always one of the vertices; in particular, if the direction has norm zero, any vertex is returned.</p><p><strong>Algorithm</strong></p><p>Comparison of directions is performed using polar angles; see the overload of <code>&lt;=</code> for two-dimensional vectors.</p><p>For polygons with <code>BINARY_SEARCH_THRESHOLD = 10</code> or more constraints we use a binary search by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HPolygonOpt.jl#L63-L90">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.LazySet,Real}"><code>radius</code></a></p></li><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.singleton_list-Tuple{LazySets.AbstractPolytope}"><code>singleton_list</code></a></p></li><li><p><a href="interfaces.html#LazySets.linear_map-Tuple{AbstractArray{T,2} where T,LazySets.AbstractPolytope}"><code>linear_map</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPolygon"><code>AbstractPolygon</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.dim-Tuple{LazySets.AbstractPolygon}"><code>dim</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractHPolygon"><code>AbstractHPolygon</code></a>:</p><ul><li><p><code>an_element</code></p></li><li><p><a href="interfaces.html#Base.:∈-Tuple{AbstractArray{Real,1},LazySets.AbstractHPolygon{Real}}"><code>∈</code></a></p></li><li><p><a href="interfaces.html#LazySets.vertices_list-Tuple{LazySets.AbstractHPolygon{Real}}"><code>vertices_list</code></a></p></li><li><p><a href="interfaces.html#LazySets.tohrep-Tuple{LazySets.AbstractHPolygon{Real}}"><code>tohrep</code></a></p></li><li><p><a href="interfaces.html#LazySets.tovrep-Tuple{LazySets.AbstractHPolygon{Real}}"><code>tovrep</code></a></p></li><li><p><a href="interfaces.html#LazySets.addconstraint!-Tuple{LazySets.AbstractHPolygon{Real},LazySets.HalfSpace{Real}}"><code>addconstraint!</code></a></p></li><li><p><a href="interfaces.html#LazySets.constraints_list-Tuple{LazySets.AbstractHPolygon{Real}}"><code>constraints_list</code></a></p></li></ul><h3><a class="nav-anchor" id="Vertex-representation-1" href="#Vertex-representation-1">Vertex representation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.VPolygon" href="#LazySets.VPolygon"><code>LazySets.VPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VPolygon{N&lt;:Real} &lt;: AbstractPolygon{N}</code></pre><p>Type that represents a polygon by its vertices.</p><p><strong>Fields</strong></p><ul><li><p><code>vertices</code> – the list of vertices</p></li></ul><p><strong>Notes</strong></p><p>The constructor of <code>VPolygon</code> runs a convex hull algorithm, and the given vertices are sorted in counter-clockwise fashion. The constructor flag <code>apply_convex_hull</code> can be used to skip the computation of the convex hull.</p><ul><li><p><code>VPolygon(vertices::Vector{Vector{N}};           apply_convex_hull::Bool=true,           algorithm::String=&quot;monotone_chain&quot;)</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/VPolygon.jl#L5-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.VPolygon{Real}}" href="#LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.VPolygon{Real}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, P::VPolygon{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a polygon in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>P</code> – polygon in vertex representation</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the first vertex is returned.</p><p><strong>Algorithm</strong></p><p>This implementation performs a brute-force search, comparing the projection of each vector along the given direction. It runs in <span>$O(n)$</span> where <span>$n$</span> is the number of vertices.</p><p><strong>Notes</strong></p><p>For arbitrary points without structure this is the best one can do. However, a more efficient approach can be used if the vertices of the polygon have been sorted in counter-clockwise fashion. In that case a binary search algorithm can be used that runs in <span>$O(\log n)$</span>. See issue <a href="https://github.com/JuliaReach/LazySets.jl/issues/40">#40</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/VPolygon.jl#L159-L187">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Real,1},LazySets.VPolygon{Real}}" href="#Base.:∈-Tuple{AbstractArray{Real,1},LazySets.VPolygon{Real}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, P::VPolygon{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>P</code> – polygon in vertex representation</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation exploits that the polygon&#39;s vertices are sorted in counter-clockwise fashion. Under this assumption we can just check if the vertex lies on the left of each edge, using the dot product.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; P = VPolygon([[2.0, 3.0], [3.0, 1.0], [5.0, 1.0], [4.0, 5.0]];
                    apply_convex_hull=false);

julia&gt; ∈([4.5, 3.1], P)
false
julia&gt; ∈([4.5, 3.0], P)
true
julia&gt; ∈([4.4, 3.4], P)  #  point lies on the edge -&gt; floating point error
false
julia&gt; P = VPolygon([[2//1, 3//1], [3//1, 1//1], [5//1, 1//1], [4//1, 5//1]];
                     apply_convex_hull=false);

julia&gt; ∈([44//10, 34//10], P)  #  with rational numbers the answer is correct
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/VPolygon.jl#L217-L256">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{LazySets.VPolygon{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{LazySets.VPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(P::VPolygon{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in vertex representation</p></li></ul><p><strong>Output</strong></p><p>The first vertex of the polygon in vertex representation.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/VPolygon.jl#L199-L211">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.VPolygon}" href="#LazySets.vertices_list-Tuple{LazySets.VPolygon}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(P::VPolygon{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a convex polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – a polygon vertex representation</p></li></ul><p><strong>Output</strong></p><p>List of vertices.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/VPolygon.jl#L138-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tohrep-Tuple{LazySets.VPolygon}" href="#LazySets.tohrep-Tuple{LazySets.VPolygon}"><code>LazySets.tohrep</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">tohrep(P::VPolygon{N}, ::Type{HPOLYGON}=HPolygon
      )::AbstractHPolygon{N} where {N&lt;:Real, HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Build a constraint representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code>        – polygon in vertex representation</p></li><li><p><code>HPOLYGON</code> – (optional, default: <code>HPolygon</code>) type of target polygon</p></li></ul><p><strong>Output</strong></p><p>The same polygon but in constraint representation, an <code>AbstractHPolygon</code>.</p><p><strong>Algorithm</strong></p><p>The algorithms consists of adding an edge for each consecutive pair of vertices. Since the vertices are already ordered in counter-clockwise fashion (CWW), the constraints will be sorted automatically (CCW) if we start with the first edge between the first and second vertex.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/VPolygon.jl#L75-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tovrep-Tuple{LazySets.VPolygon}" href="#LazySets.tovrep-Tuple{LazySets.VPolygon}"><code>LazySets.tovrep</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">tovrep(P::VPolygon{N})::VPolygon{N} where {N&lt;:Real}</code></pre><p>Build a vertex representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in vertex representation</p></li></ul><p><strong>Output</strong></p><p>The identity, i.e., the same polygon instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/VPolygon.jl#L58-L70">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.LazySet,Real}"><code>radius</code></a></p></li><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.singleton_list-Tuple{LazySets.AbstractPolytope}"><code>singleton_list</code></a></p></li><li><p><a href="interfaces.html#LazySets.linear_map-Tuple{AbstractArray{T,2} where T,LazySets.AbstractPolytope}"><code>linear_map</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPolygon"><code>AbstractPolygon</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.dim-Tuple{LazySets.AbstractPolygon}"><code>dim</code></a></p></li></ul><h3><a class="nav-anchor" id="Sorting-directions-1" href="#Sorting-directions-1">Sorting directions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.jump2pi" href="#LazySets.jump2pi"><code>LazySets.jump2pi</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">jump2pi(x::N)::N where {N&lt;:AbstractFloat}</code></pre><p>Return <span>$x + 2π$</span> if <span>$x$</span> is negative, otherwise return <span>$x$</span>.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – real scalar</p></li></ul><p><strong>Output</strong></p><p><span>$x + 2π$</span> if <span>$x$</span> is negative, <span>$x$</span> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import LazySets.jump2pi

julia&gt; jump2pi(0.0)
0.0

julia&gt; jump2pi(-0.5)
5.783185307179586

julia&gt; jump2pi(0.5)
0.5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractPolygon.jl#L50-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&lt;=-Tuple{AbstractArray{AbstractFloat,1},AbstractArray{AbstractFloat,1}}" href="#Base.:&lt;=-Tuple{AbstractArray{AbstractFloat,1},AbstractArray{AbstractFloat,1}}"><code>Base.:&lt;=</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">&lt;=(u::AbstractVector{N}, v::AbstractVector{N})::Bool where {N&lt;:Real}</code></pre><p>Compares two 2D vectors by their direction.</p><p><strong>Input</strong></p><ul><li><p><code>u</code> –  first 2D direction</p></li><li><p><code>v</code> –  second 2D direction</p></li></ul><p><strong>Output</strong></p><p>True iff <span>$\arg(u) [2π] ≤ \arg(v) [2π]$</span></p><p><strong>Notes</strong></p><p>The argument is measured in counter-clockwise fashion, with the 0 being the direction (1, 0).</p><p><strong>Algorithm</strong></p><p>The implementation checks the quadrant of each direction, and compares directions using the right-hand rule. In particular, it doesn&#39;t use the arctangent.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractPolygon.jl#L116-L139">source</a><div><pre><code class="language-none">&lt;=(u::AbstractVector{N}, v::AbstractVector{N})::Bool where {N&lt;:AbstractFloat}</code></pre><p>Compares two 2D vectors by their direction.</p><p><strong>Input</strong></p><ul><li><p><code>u</code> –  first 2D direction</p></li><li><p><code>v</code> –  second 2D direction</p></li></ul><p><strong>Output</strong></p><p>True iff <span>$\arg(u) [2π] ≤ \arg(v) [2π]$</span></p><p><strong>Notes</strong></p><p>The argument is measured in counter-clockwise fashion, with the 0 being the direction (1, 0).</p><p><strong>Algorithm</strong></p><p>The implementation uses the arctangent function with sign, <code>atan</code>, which for two arguments implements the <a href="https://en.wikipedia.org/wiki/Atan2"><code>atan2</code> function</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractPolygon.jl#L152-L176">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.quadrant-Tuple{AbstractArray{Real,1}}" href="#LazySets.quadrant-Tuple{AbstractArray{Real,1}}"><code>LazySets.quadrant</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">quadrant(w::AbstractVector{N})::Int where {N&lt;:Real}</code></pre><p>Compute the quadrant where the direction <code>w</code> belongs.</p><p><strong>Input</strong></p><ul><li><p><code>w</code> –  direction</p></li></ul><p><strong>Output</strong></p><p>An integer from 0 to 3, with the following convention:</p><pre><code class="language-none">     ^
   1 | 0
  ---+--&gt;
   2 | 3</code></pre><p><strong>Algorithm</strong></p><p>The idea is to encode the following logic function: <span>$11 ↦ 0, 01 ↦ 1, 00 ↦ 2, 10 ↦ 3$</span>, according to the convention of above.</p><p>This function is inspired from AGPX&#39;s answer in: <a href="https://stackoverflow.com/a/46635372">Sort points in clockwise order?</a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/AbstractPolygon.jl#L82-L109">source</a></section><h2><a class="nav-anchor" id="Polytopes-1" href="#Polytopes-1">Polytopes</a></h2><h3><a class="nav-anchor" id="Constraint-representation-2" href="#Constraint-representation-2">Constraint representation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.HPolytope" href="#LazySets.HPolytope"><code>LazySets.HPolytope</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HPolytope{N&lt;:Real} &lt;: AbstractPolytope{N}</code></pre><p>Type that represents a convex polytope in H-representation.</p><p><strong>Fields</strong></p><ul><li><p><code>constraints</code> – vector of linear constraints</p></li></ul><p><strong>Note</strong></p><p>This type is more appropriately a <em>polyhedron</em>, because no check in the constructor is made that the constraints determine a bounded set from the finite intersection of half-spaces. This is a running assumption in this type.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HPolytope.jl#L8-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.HPolytope}" href="#LazySets.dim-Tuple{LazySets.HPolytope}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(P::HPolytope)::Int</code></pre><p>Return the dimension of a polytope in H-representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code>  – polytope in H-representation</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polytope in H-representation. If it has no constraints, the result is <span>$-1$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HPolytope.jl#L50-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.HPolytope{Real}}" href="#LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.HPolytope{Real}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, P::HPolytope{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a polyhedron (in H-representation) in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>P</code> – polyhedron in H-representation</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>This implementation uses <code>GLPKSolverLP</code> as linear programming backend.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HPolytope.jl#L68-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Real,1},LazySets.HPolytope{Real}}" href="#Base.:∈-Tuple{AbstractArray{Real,1},LazySets.HPolytope{Real}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, P::HPolytope{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given 2D point is contained in a polytope in constraint representation.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – two-dimensional point/vector</p></li><li><p><code>P</code> – polytope in constraint representation</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation checks if the point lies on the outside of each hyperplane. This is equivalent to checking if the point lies in each half-space.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HPolytope.jl#L105-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.addconstraint!-Tuple{LazySets.HPolytope{Real},LazySets.HalfSpace{Real}}" href="#LazySets.addconstraint!-Tuple{LazySets.HPolytope{Real},LazySets.HalfSpace{Real}}"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">addconstraint!(P::HPolytope{N},
               constraint::LinearConstraint{N})::Nothing where {N&lt;:Real}</code></pre><p>Add a linear constraint to a polyhedron in H-representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code>          – polyhedron in H-representation</p></li><li><p><code>constraint</code> – linear constraint to add</p></li></ul><p><strong>Output</strong></p><p>Nothing.</p><p><strong>Notes</strong></p><p>It is left to the user to guarantee that the dimension of all linear constraints is the same.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HPolytope.jl#L140-L159">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Tuple{LazySets.HPolytope}" href="#LazySets.constraints_list-Tuple{LazySets.HPolytope}"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">constraints_list(P::HPolytope{N})::Vector{LinearConstraint{N}} where {N&lt;:Real}</code></pre><p>Return the list of constraints defining a polyhedron in H-representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polytope in H-representation</p></li></ul><p><strong>Output</strong></p><p>The list of constraints of the polyhedron.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HPolytope.jl#L166-L178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tosimplehrep-Tuple{LazySets.HPolytope}" href="#LazySets.tosimplehrep-Tuple{LazySets.HPolytope}"><code>LazySets.tosimplehrep</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">tosimplehrep(P::HPolytope)</code></pre><p>Return the simple H-representation <span>$Ax ≤ b$</span> of a polytope.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polytope</p></li></ul><p><strong>Output</strong></p><p>The tuple <code>(A, b)</code> where <code>A</code> is the matrix of normal directions and <code>b</code> are the offsets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/HPolytope.jl#L184-L196">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.LazySet,Real}"><code>radius</code></a></p></li><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.singleton_list-Tuple{LazySets.AbstractPolytope}"><code>singleton_list</code></a></p></li><li><p><a href="interfaces.html#LazySets.linear_map-Tuple{AbstractArray{T,2} where T,LazySets.AbstractPolytope}"><code>linear_map</code></a></p></li></ul><h3><a class="nav-anchor" id="Vertex-representation-2" href="#Vertex-representation-2">Vertex representation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.VPolytope" href="#LazySets.VPolytope"><code>LazySets.VPolytope</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VPolytope{N&lt;:Real} &lt;: AbstractPolytope{N}</code></pre><p>Type that represents a convex polytope in V-representation.</p><p><strong>Fields</strong></p><ul><li><p><code>vertices</code> – the list of vertices</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/VPolytope.jl#L6-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.VPolytope}" href="#LazySets.dim-Tuple{LazySets.VPolytope}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(P::VPolytope)::Int</code></pre><p>Return the dimension of a polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code>  – polytope in V-representation</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polytope in V-representation. If it is empty, the result is <span>$-1$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = VPolytope();

julia&gt; dim(v) &gt; 0
false

julia&gt; v = VPolytope([ones(3)])
VPolytope{Float64}(Array{Float64,1}[[1.0, 1.0, 1.0]])

julia&gt; dim(v) == 3
true
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/VPolytope.jl#L38-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.VPolytope{Real}}" href="#LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.VPolytope{Real}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, P::VPolytope{N}; algorithm=&quot;hrep&quot;) where {N&lt;:Real}</code></pre><p>Return the support vector of a polyhedron (in V-representation) in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>         – direction</p></li><li><p><code>P</code>         – polyhedron in V-representation</p></li><li><p><code>algorithm</code> – (optional, default: <code>&#39;hrep&#39;</code>) method to compute the support vector</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/VPolytope.jl#L72-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.VPolytope}" href="#LazySets.vertices_list-Tuple{LazySets.VPolytope}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(P::VPolytope{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polytope in vertex representation</p></li></ul><p><strong>Output</strong></p><p>List of vertices.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/VPolytope.jl#L102-L114">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.LazySet,Real}"><code>radius</code></a></p></li><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.singleton_list-Tuple{LazySets.AbstractPolytope}"><code>singleton_list</code></a></p></li><li><p><a href="interfaces.html#LazySets.linear_map-Tuple{AbstractArray{T,2} where T,LazySets.AbstractPolytope}"><code>linear_map</code></a></p></li></ul><h2><a class="nav-anchor" id="Singleton-1" href="#Singleton-1">Singleton</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Singleton" href="#LazySets.Singleton"><code>LazySets.Singleton</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Singleton{N&lt;:Real} &lt;: AbstractSingleton{N}</code></pre><p>Type that represents a singleton, that is, a set with a unique element.</p><p><strong>Fields</strong></p><ul><li><p><code>element</code> – the only element of the set</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Singleton.jl#L3-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.element-Tuple{LazySets.Singleton}" href="#LazySets.element-Tuple{LazySets.Singleton}"><code>LazySets.element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">element(S::Singleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the element of a singleton.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – singleton</p></li></ul><p><strong>Output</strong></p><p>The element of the singleton.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Singleton.jl#L20-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.element-Tuple{LazySets.Singleton,Int64}" href="#LazySets.element-Tuple{LazySets.Singleton,Int64}"><code>LazySets.element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">element(S::Singleton{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the i-th entry of the element of a singleton.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – singleton</p></li><li><p><code>i</code> – dimension</p></li></ul><p><strong>Output</strong></p><p>The i-th entry of the element of the singleton.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Singleton.jl#L37-L50">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.singleton_list-Tuple{LazySets.AbstractPolytope}"><code>singleton_list</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPointSymmetricPolytope"><code>AbstractPointSymmetricPolytope</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.dim-Tuple{LazySets.AbstractPointSymmetricPolytope}"><code>dim</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractHyperrectangle"><code>AbstractHyperrectangle</code></a>:</p><ul><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.AbstractHyperrectangle,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.AbstractHyperrectangle,Real}"><code>radius</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractSingleton"><code>AbstractSingleton</code></a>:</p><ul><li><p><code>σ</code></p></li><li><p><code>∈</code></p></li><li><p><code>an_element</code></p></li><li><p><a href="interfaces.html#LazySets.center-Tuple{LazySets.AbstractSingleton{Real}}"><code>center</code></a></p></li><li><p><code>vertices_list</code></p></li><li><p><a href="interfaces.html#LazySets.radius_hyperrectangle-Tuple{LazySets.AbstractSingleton{Real}}"><code>radius_hyperrectangle</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius_hyperrectangle-Tuple{LazySets.AbstractSingleton{Real},Int64}"><code>radius_hyperrectangle</code></a></p></li><li><p><code>linear_map</code></p></li></ul><h2><a class="nav-anchor" id="Zero-set-1" href="#Zero-set-1">Zero set</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ZeroSet" href="#LazySets.ZeroSet"><code>LazySets.ZeroSet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ZeroSet{N&lt;:Real} &lt;: AbstractSingleton{N}</code></pre><p>Type that represents the zero set, i.e., the set that only contains the origin.</p><p><strong>Fields</strong></p><ul><li><p><code>dim</code> – the ambient dimension of this zero set</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/ZeroSet.jl#L6-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.ZeroSet}" href="#LazySets.dim-Tuple{LazySets.ZeroSet}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(Z::ZeroSet)::Int</code></pre><p>Return the ambient dimension of this zero set.</p><p><strong>Input</strong></p><ul><li><p><code>Z</code> – a zero set, i.e., a set that only contains the origin</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the zero set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/ZeroSet.jl#L65-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{AbstractArray{N,1},LazySets.ZeroSet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{AbstractArray{N,1},LazySets.ZeroSet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, Z::ZeroSet{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a zero set.</p><p><strong>Input</strong></p><ul><li><p><code>Z</code> – a zero set, i.e., a set that only contains the origin</p></li></ul><p><strong>Output</strong></p><p>The returned value is the origin since it is the only point that belongs to this set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/ZeroSet.jl#L82-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{AbstractArray{N,1},LazySets.ZeroSet{N}}, Tuple{N}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{AbstractArray{N,1},LazySets.ZeroSet{N}}, Tuple{N}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, Z::ZeroSet{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a zero set.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>Z</code> – zero set</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ Z$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Z = ZeroSet(2);

julia&gt; ∈([1.0, 0.0], Z)
false
julia&gt; ∈([0.0, 0.0], Z)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/ZeroSet.jl#L101-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.element-Tuple{LazySets.ZeroSet}" href="#LazySets.element-Tuple{LazySets.ZeroSet}"><code>LazySets.element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">element(S::ZeroSet{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the element of a zero set.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – zero set</p></li></ul><p><strong>Output</strong></p><p>The element of the zero set, i.e., a zero vector.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/ZeroSet.jl#L26-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.element-Tuple{LazySets.ZeroSet,Int64}" href="#LazySets.element-Tuple{LazySets.ZeroSet,Int64}"><code>LazySets.element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">element(S::ZeroSet{N}, ::Int)::N where {N&lt;:Real}</code></pre><p>Return the i-th entry of the element of a zero set.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – zero set</p></li><li><p><code>i</code> – dimension</p></li></ul><p><strong>Output</strong></p><p>The i-th entry of the element of the zero set, i.e., 0.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/ZeroSet.jl#L43-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{AbstractArray{T,2} where T,LazySets.ZeroSet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{AbstractArray{T,2} where T,LazySets.ZeroSet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">linear_map(M::AbstractMatrix, Z::ZeroSet{N}) where {N&lt;:Real}</code></pre><p>Concrete linear map of a zero set.</p><p><strong>Input</strong></p><ul><li><p><code>M</code> – matrix</p></li><li><p><code>Z</code> – zero set</p></li></ul><p><strong>Output</strong></p><p>The zero set whose dimension matches the output dimension of the given matrix.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/ZeroSet.jl#L133-L146">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.singleton_list-Tuple{LazySets.AbstractPolytope}"><code>singleton_list</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractHyperrectangle"><code>AbstractHyperrectangle</code></a>:</p><ul><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.AbstractHyperrectangle,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.AbstractHyperrectangle,Real}"><code>radius</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractSingleton"><code>AbstractSingleton</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.radius_hyperrectangle-Tuple{LazySets.AbstractSingleton{Real}}"><code>radius_hyperrectangle</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius_hyperrectangle-Tuple{LazySets.AbstractSingleton{Real},Int64}"><code>radius_hyperrectangle</code></a></p></li><li><p><code>vertices_list</code></p></li><li><p><a href="interfaces.html#LazySets.center-Tuple{LazySets.AbstractSingleton{Real}}"><code>center</code></a></p></li><li><p><code>an_element</code></p></li></ul><h2><a class="nav-anchor" id="Zonotope-1" href="#Zonotope-1">Zonotope</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Zonotope" href="#LazySets.Zonotope"><code>LazySets.Zonotope</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Zonotope{N&lt;:Real} &lt;: AbstractPointSymmetricPolytope{N}</code></pre><p>Type that represents a zonotope.</p><p><strong>Fields</strong></p><ul><li><p><code>center</code>     – center of the zonotope</p></li><li><p><code>generators</code> – matrix; each column is a generator of the zonotope</p></li></ul><p><strong>Notes</strong></p><p>Mathematically, a zonotope is defined as the set</p><div>\[Z = \left\{ c + ∑_{i=1}^p ξ_i g_i,~~ ξ_i \in [-1, 1]~~ ∀ i = 1,…, p \right\},\]</div><p>where <span>$c \in \mathbb{R}^n$</span> is its <em>center</em> and <span>$\{g_i\}_{i=1}^p$</span>, <span>$g_i \in \mathbb{R}^n$</span>, is the set of <em>generators</em>. This characterization defines a zonotope as the finite Minkowski sum of line elements. Zonotopes can be equivalently described as the image of a unit infinity-norm ball in <span>$\mathbb{R}^n$</span> by an affine transformation.</p><ul><li><p><code>Zonotope(center::AbstractVector{N},           generators::AbstractMatrix{N}) where {N&lt;:Real}</code></p></li><li><p><code>Zonotope(center::AbstractVector{N},           generators_list::AbstractVector{T}          ) where {N&lt;:Real, T&lt;:AbstractVector{N}}</code></p></li></ul><p><strong>Examples</strong></p><p>A two-dimensional zonotope with given center and set of generators:</p><pre><code class="language-julia-repl">julia&gt; Z = Zonotope([1.0, 0.0], [0.1 0.0; 0.0 0.1])
Zonotope{Float64}([1.0, 0.0], [0.1 0.0; 0.0 0.1])
julia&gt; dim(Z)
2</code></pre><p>Compute its vertices:</p><pre><code class="language-julia-repl">julia&gt; vertices_list(Z)
4-element Array{Array{Float64,1},1}:
 [0.9, -0.1]
 [1.1, -0.1]
 [1.1, 0.1]
 [0.9, 0.1]</code></pre><p>Evaluate the support vector in a given direction:</p><pre><code class="language-julia-repl">julia&gt; σ([1., 1.], Z)
2-element Array{Float64,1}:
 1.1
 0.1</code></pre><p>Alternative constructor: A zonotope in two dimensions with three generators:</p><pre><code class="language-julia-repl">julia&gt; Z = Zonotope(ones(2), [[1., 0.], [0., 1.], [1., 1.]])
Zonotope{Float64}([1.0, 1.0], [1.0 0.0 1.0; 0.0 1.0 1.0])
julia&gt; Z.generators
2×3 Array{Float64,2}:
 1.0  0.0  1.0
 0.0  1.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Zonotope.jl#L11-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.Zonotope{Real}}" href="#LazySets.σ-Tuple{AbstractArray{Real,1},LazySets.Zonotope{Real}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, Z::Zonotope{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a zonotope in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>Z</code> – zonotope</p></li></ul><p><strong>Output</strong></p><p>Support vector in the given direction. If the direction has norm zero, the vertex with <span>$ξ_i = 1 \ \ ∀ i = 1,…, p$</span> is returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Zonotope.jl#L155-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Real,1},LazySets.Zonotope{Real}}" href="#Base.:∈-Tuple{AbstractArray{Real,1},LazySets.Zonotope{Real}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, Z::Zonotope{N};
  solver=GLPKSolverLP(method=:Simplex))::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a zonotope.</p><p><strong>Input</strong></p><ul><li><p><code>x</code>      – point/vector</p></li><li><p><code>Z</code>      – zonotope</p></li><li><p><code>solver</code> – (optional, default: <code>GLPKSolverLP(method=:Simplex)</code>) the backend             used to solve the linear program</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ Z$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Z = Zonotope([1.0, 0.0], [0.1 0.0; 0.0 0.1]);

julia&gt; ∈([1.0, 0.2], Z)
false
julia&gt; ∈([1.0, 0.1], Z)
true</code></pre><p><strong>Algorithm</strong></p><p>The element membership problem is computed by stating and solving the following linear program with the simplex method. Let <span>$p$</span> and <span>$n$</span> be the number of generators and ambient dimension respectively. We consider the minimization of <span>$x_0$</span> in the <span>$p+1$</span>-dimensional space of elements <span>$(x_0, ξ_1, …, ξ_p)$</span> constrained to <span>$0 ≤ x_0 ≤ ∞$</span>, <span>$ξ_i ∈ [-1, 1]$</span> for all <span>$i = 1, …, p$</span>, and such that <span>$x-c = Gξ$</span> holds. If a feasible solution exists, the optimal value <span>$x_0 = 0$</span> is achieved.</p><p><strong>Notes</strong></p><p>This function is parametric in the number type <code>N</code>. For exact arithmetic use an appropriate backend, e.g. <code>solver=GLPKSolverLP(method=:Exact)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Zonotope.jl#L175-L217">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.Zonotope}" href="#LazySets.vertices_list-Tuple{LazySets.Zonotope}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(Z::Zonotope{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a zonotope.</p><p><strong>Input</strong></p><ul><li><p><code>Z</code> – zonotope</p></li></ul><p><strong>Output</strong></p><p>List of vertices.</p><p><strong>Notes</strong></p><p>This implementation computes a convex hull.</p><p>For high dimensions, it would be preferable to develop a <code>vertex_iterator</code> approach.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Zonotope.jl#L119-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Tuple{LazySets.Zonotope}" href="#LazySets.center-Tuple{LazySets.Zonotope}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">center(Z::Zonotope{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a zonotope.</p><p><strong>Input</strong></p><ul><li><p><code>Z</code> – zonotope</p></li></ul><p><strong>Output</strong></p><p>The center of the zonotope.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Zonotope.jl#L98-L110">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.order-Tuple{LazySets.Zonotope}" href="#LazySets.order-Tuple{LazySets.Zonotope}"><code>LazySets.order</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">order(Z::Zonotope)::Rational</code></pre><p>Return the order of a zonotope.</p><p><strong>Input</strong></p><ul><li><p><code>Z</code> – zonotope</p></li></ul><p><strong>Output</strong></p><p>A rational number representing the order of the zonotope.</p><p><strong>Notes</strong></p><p>The order of a zonotope is defined as the quotient of its number of generators and its dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Zonotope.jl#L237-L254">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.minkowski_sum-Tuple{LazySets.Zonotope,LazySets.Zonotope}" href="#LazySets.minkowski_sum-Tuple{LazySets.Zonotope,LazySets.Zonotope}"><code>LazySets.minkowski_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">minkowski_sum(Z1::Zonotope, Z2::Zonotope)</code></pre><p>Concrete Minkowski sum of a pair of zonotopes.</p><p><strong>Input</strong></p><ul><li><p><code>Z1</code> – one zonotope</p></li><li><p><code>Z2</code> – another zonotope</p></li></ul><p><strong>Output</strong></p><p>The zonotope obtained by summing the centers and concatenating the generators of <span>$Z_1$</span> and <span>$Z_2$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Zonotope.jl#L259-L273">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Tuple{AbstractArray{T,2} where T,LazySets.Zonotope}" href="#LazySets.linear_map-Tuple{AbstractArray{T,2} where T,LazySets.Zonotope}"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">linear_map(M::AbstractMatrix, Z::Zonotope)</code></pre><p>Concrete linear map of a zonotope.</p><p><strong>Input</strong></p><ul><li><p><code>M</code> – matrix</p></li><li><p><code>Z</code> – zonotope</p></li></ul><p><strong>Output</strong></p><p>The zonotope obtained by applying the linear map to the center and generators of <span>$Z$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Zonotope.jl#L278-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.scale-Tuple{Real,LazySets.Zonotope}" href="#LazySets.scale-Tuple{Real,LazySets.Zonotope}"><code>LazySets.scale</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">scale(α::Real, Z::Zonotope)</code></pre><p>Concrete scaling of a zonotope.</p><p><strong>Input</strong></p><ul><li><p><code>α</code> – scalar</p></li><li><p><code>Z</code> – zonotope</p></li></ul><p><strong>Output</strong></p><p>The zonotope obtained by applying the numerical scale to the center and generators of <span>$Z$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Zonotope.jl#L302-L316">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ngens-Tuple{LazySets.Zonotope}" href="#LazySets.ngens-Tuple{LazySets.Zonotope}"><code>LazySets.ngens</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ngens(Z::Zonotope)::Int</code></pre><p>Return the number of generators of a zonotope.</p><p><strong>Input</strong></p><ul><li><p><code>Z</code> – zonotope</p></li></ul><p><strong>Output</strong></p><p>Integer representing the number of generators.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Zonotope.jl#L323-L335">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.reduce_order-Tuple{LazySets.Zonotope,Any}" href="#LazySets.reduce_order-Tuple{LazySets.Zonotope,Any}"><code>LazySets.reduce_order</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reduce_order(Z::Zonotope, r)::Zonotope</code></pre><p>Reduce the order of a zonotope by overapproximating with a zonotope with less generators.</p><p><strong>Input</strong></p><ul><li><p><code>Z</code> – zonotope</p></li><li><p><code>r</code> – desired order</p></li></ul><p><strong>Output</strong></p><p>A new zonotope with less generators, if possible.</p><p><strong>Algorithm</strong></p><p>This function implements the algorithm described in A. Girard&#39;s <em>Reachability of Uncertain Linear Systems Using Zonotopes</em>, HSCC. Vol. 5. 2005.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/Zonotope.jl#L338-L357">source</a></section><p>Inherited from <a href="interfaces.html#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><p><a href="interfaces.html#Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}"><code>norm</code></a></p></li><li><p><a href="interfaces.html#LazySets.radius-Tuple{LazySets.LazySet,Real}"><code>radius</code></a></p></li><li><p><a href="interfaces.html#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>diameter</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.singleton_list-Tuple{LazySets.AbstractPolytope}"><code>singleton_list</code></a></p></li></ul><p>Inherited from <a href="interfaces.html#LazySets.AbstractPointSymmetricPolytope"><code>AbstractPointSymmetricPolytope</code></a>:</p><ul><li><p><a href="interfaces.html#LazySets.dim-Tuple{LazySets.AbstractPointSymmetricPolytope}"><code>dim</code></a></p></li><li><p><code>an_element</code></p></li></ul><footer><hr/><a class="previous" href="interfaces.html"><span class="direction">Previous</span><span class="title">Set Interfaces</span></a><a class="next" href="operations.html"><span class="direction">Next</span><span class="title">Common Set Operations</span></a></footer></article></body></html>
