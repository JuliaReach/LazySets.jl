<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Binary Functions on Sets · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/getting_started.html">Getting Started</a></li><li><a class="toctext" href="../man/polyhedral_approximations.html">Polyhedral Approximations</a></li><li><a class="toctext" href="../man/decompose_example.html">Decomposing an Affine Map</a></li><li><a class="toctext" href="../man/fast_2d_LPs.html">Fast 2D LPs</a></li><li><a class="toctext" href="../man/iterative_refinement.html">Iterative Refinement</a></li><li><a class="toctext" href="../man/interval_hulls.html">Interval Hulls</a></li><li><a class="toctext" href="../man/convex_hulls.html">Convex Hulls</a></li><li><a class="toctext" href="../man/set_operations.html">Operations on Sets</a></li><li><a class="toctext" href="../man/reach_zonotopes.html">A Reachability Algorithm</a></li><li><a class="toctext" href="../man/reach_zonotopes_hybrid.html">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../man/concrete_polyhedra.html">Concrete Polyhedra</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="interfaces.html">Set Interfaces</a></li><li><a class="toctext" href="representations.html">Common Set Representations</a></li><li><a class="toctext" href="operations.html">Common Set Operations</a></li><li><a class="toctext" href="conversion.html">Conversion between set representations</a></li><li class="current"><a class="toctext" href="binary_functions.html">Binary Functions on Sets</a><ul class="internal"><li><a class="toctext" href="#Subset-check-1">Subset check</a></li><li><a class="toctext" href="#Check-for-emptiness-of-intersection-1">Check for emptiness of intersection</a></li><li><a class="toctext" href="#Intersection-of-two-sets-1">Intersection of two sets</a></li></ul></li><li><a class="toctext" href="approximations.html">Approximations</a></li><li><a class="toctext" href="utils.html">Utility Functions</a></li></ul></li><li><a class="toctext" href="../about.html">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="binary_functions.html">Binary Functions on Sets</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/binary_functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Binary Functions on Sets</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Binary-Functions-on-Sets-1" href="#Binary-Functions-on-Sets-1">Binary Functions on Sets</a></h1><p>This section of the manual describes the binary functions for set types.</p><ul><li><a href="binary_functions.html#Binary-Functions-on-Sets-1">Binary Functions on Sets</a></li><ul><li><a href="binary_functions.html#Subset-check-1">Subset check</a></li><li><a href="binary_functions.html#Check-for-emptiness-of-intersection-1">Check for emptiness of intersection</a></li><li><a href="binary_functions.html#Intersection-of-two-sets-1">Intersection of two sets</a></li></ul></ul><h2><a class="nav-anchor" id="Subset-check-1" href="#Subset-check-1">Subset check</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{LazySets.LazySet{N},LazySets.AbstractHyperrectangle{N},Bool}, Tuple{LazySets.LazySet{N},LazySets.AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{LazySets.LazySet{N},LazySets.AbstractHyperrectangle{N},Bool}, Tuple{LazySets.LazySet{N},LazySets.AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(S::LazySet{N}, H::AbstractHyperrectangle{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set is contained in a hyperrectangle, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – inner convex set</p></li><li><p><code>H</code> – outer hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ H$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S ⊆ H$</span></p></li><li><p><code>(false, v)</code> iff <span>$S \not\subseteq H$</span> and <span>$v ∈ S \setminus H$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ⊆ H$</span> iff <span>$\operatorname{ihull}(S) ⊆ H$</span>, where  <span>$\operatorname{ihull}$</span> is the interval hull operator.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_subset.jl#L7-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{LazySets.AbstractPolytope{N},LazySets.LazySet{N},Bool}, Tuple{LazySets.AbstractPolytope{N},LazySets.LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{LazySets.AbstractPolytope{N},LazySets.LazySet{N},Bool}, Tuple{LazySets.AbstractPolytope{N},LazySets.LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, S::LazySet{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ S$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq S$</span> and <span>$v ∈ P \setminus S$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_subset.jl#L153-L177">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{LazySets.AbstractPolytope{N},LazySets.AbstractHyperrectangle,Bool}, Tuple{LazySets.AbstractPolytope{N},LazySets.AbstractHyperrectangle}, Tuple{N}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{LazySets.AbstractPolytope{N},LazySets.AbstractHyperrectangle,Bool}, Tuple{LazySets.AbstractPolytope{N},LazySets.AbstractHyperrectangle}, Tuple{N}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(P::AbstractPolytope{N}, H::AbstractHyperrectangle, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a polytope is contained in a hyperrectangle, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>H</code> – outer hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ H$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$P ⊆ H$</span></p></li><li><p><code>(false, v)</code> iff <span>$P \not\subseteq H$</span> and <span>$v ∈ P \setminus H$</span></p></li></ul></li></ul><p><strong>Notes</strong></p><p>This copy-pasted method just exists to avoid method ambiguities.</p><p><strong>Algorithm</strong></p><p>Since <span>$H$</span> is convex, <span>$P ⊆ H$</span> iff <span>$v_i ∈ H$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_subset.jl#L38-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{LazySets.AbstractHyperrectangle{N},LazySets.AbstractHyperrectangle{N},Bool}, Tuple{LazySets.AbstractHyperrectangle{N},LazySets.AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{LazySets.AbstractHyperrectangle{N},LazySets.AbstractHyperrectangle{N},Bool}, Tuple{LazySets.AbstractHyperrectangle{N},LazySets.AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(H1::AbstractHyperrectangle{N},
  H2::AbstractHyperrectangle{N},
  [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a given hyperrectangle is contained in another hyperrectangle, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>H1</code> – inner hyperrectangle</p></li><li><p><code>H2</code> – outer hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$H1 ⊆ H2$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$H1 ⊆ H2$</span></p></li><li><p><code>(false, v)</code> iff <span>$H1 \not\subseteq H2$</span> and <span>$v ∈ H1 \setminus H2$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$H1 ⊆ H2$</span> iff <span>$c_1 + r_1 ≤ c_2 + r_2 ∧ c_1 - r_1 ≥ c_2 - r_2$</span> iff <span>$r_1 - r_2 ≤ c_1 - c_2 ≤ -(r_1 - r_2)$</span>, where <span>$≤$</span> is taken component-wise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_subset.jl#L90-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{LazySets.AbstractSingleton{N},LazySets.LazySet{N},Bool}, Tuple{LazySets.AbstractSingleton{N},LazySets.LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{LazySets.AbstractSingleton{N},LazySets.LazySet{N},Bool}, Tuple{LazySets.AbstractSingleton{N},LazySets.LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(S::AbstractSingleton{N}, set::LazySet{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a given set with a single value is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code>   – inner set with a single value</p></li><li><p><code>set</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ \text{set}$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S ⊆ \text{set}$</span></p></li><li><p><code>(false, v)</code> iff <span>$S \not\subseteq \text{set}$</span> and <span>$v ∈ S \setminus \text{set}$</span></p></li></ul></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_subset.jl#L202-L222">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{LazySets.AbstractSingleton{N},LazySets.AbstractHyperrectangle{N},Bool}, Tuple{LazySets.AbstractSingleton{N},LazySets.AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{LazySets.AbstractSingleton{N},LazySets.AbstractHyperrectangle{N},Bool}, Tuple{LazySets.AbstractSingleton{N},LazySets.AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(S::AbstractSingleton{N},
  H::AbstractHyperrectangle{N},
  [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a given set with a single value is contained in a hyperrectangle, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – inner set with a single value</p></li><li><p><code>H</code> – outer hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ H$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S ⊆ H$</span></p></li><li><p><code>(false, v)</code> iff <span>$S \not\subseteq H$</span> and <span>$v ∈ S \setminus H$</span></p></li></ul></li></ul><p><strong>Notes</strong></p><p>This copy-pasted method just exists to avoid method ambiguities.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_subset.jl#L234-L259">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{LazySets.AbstractSingleton{N},LazySets.AbstractSingleton{N},Bool}, Tuple{LazySets.AbstractSingleton{N},LazySets.AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{LazySets.AbstractSingleton{N},LazySets.AbstractSingleton{N},Bool}, Tuple{LazySets.AbstractSingleton{N},LazySets.AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(S1::AbstractSingleton{N},
  S2::AbstractSingleton{N},
  [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a given set with a single value is contained in another set with a single value, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S1</code> – inner set with a single value</p></li><li><p><code>S2</code> – outer set with a single value</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S1 ⊆ S2$</span> iff <span>$S1 == S2$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S1 ⊆ S2$</span></p></li><li><p><code>(false, v)</code> iff <span>$S1 \not\subseteq S2$</span> and <span>$v ∈ S1 \setminus S2$</span></p></li></ul></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_subset.jl#L273-L294">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{LazySets.Ball2{AbstractFloat},LazySets.Ball2{AbstractFloat},Bool}, Tuple{LazySets.Ball2{AbstractFloat},LazySets.Ball2{AbstractFloat}}, Tuple{N}} where N&lt;:AbstractFloat" href="#Base.:⊆-Union{Tuple{LazySets.Ball2{AbstractFloat},LazySets.Ball2{AbstractFloat},Bool}, Tuple{LazySets.Ball2{AbstractFloat},LazySets.Ball2{AbstractFloat}}, Tuple{N}} where N&lt;:AbstractFloat"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(B1::Ball2{N}, B2::Ball2{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a ball in the 2-norm is contained in another ball in the 2-norm, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>B1</code> – inner ball in the 2-norm</p></li><li><p><code>B2</code> – outer ball in the 2-norm</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$B1 ⊆ B2$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$B1 ⊆ B2$</span></p></li><li><p><code>(false, v)</code> iff <span>$B1 \not\subseteq B2$</span> and <span>$v ∈ B1 \setminus B2$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$B1 ⊆ B2$</span> iff <span>$‖ c_1 - c_2 ‖_2 + r_1 ≤ r_2$</span></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_subset.jl#L311-L334">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{N}, Tuple{Union{LazySets.Ball2{N}, LazySets.Ballp{N}},LazySets.AbstractSingleton{N},Bool}, Tuple{Union{LazySets.Ball2{N}, LazySets.Ballp{N}},LazySets.AbstractSingleton{N}}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{N}, Tuple{Union{LazySets.Ball2{N}, LazySets.Ballp{N}},LazySets.AbstractSingleton{N},Bool}, Tuple{Union{LazySets.Ball2{N}, LazySets.Ballp{N}},LazySets.AbstractSingleton{N}}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(B::Union{Ball2{N}, Ballp{N}},
  S::AbstractSingleton{N},
  [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a ball in the 2-norm or p-norm is contained in a set with a single value, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – inner ball in the 2-norm or p-norm</p></li><li><p><code>S</code> – outer set with a single value</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$B ⊆ S$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$B ⊆ S$</span></p></li><li><p><code>(false, v)</code> iff <span>$B \not\subseteq S$</span> and <span>$v ∈ B \setminus S$</span></p></li></ul></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_subset.jl#L355-L376">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{LazySets.LineSegment{N},LazySets.LazySet{N},Bool}, Tuple{LazySets.LineSegment{N},LazySets.LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{LazySets.LineSegment{N},LazySets.LazySet{N},Bool}, Tuple{LazySets.LineSegment{N},LazySets.LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(L::LineSegment{N}, S::LazySet{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a line segment is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>L</code> – inner line segment</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$L ⊆ S$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$L ⊆ S$</span></p></li><li><p><code>(false, v)</code> iff <span>$L \not\subseteq S$</span> and <span>$v ∈ L \setminus S$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$L ⊆ S$</span> iff <span>$p ∈ S$</span> and <span>$q ∈ S$</span>, where <span>$p, q$</span> are the end points of <span>$L$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_subset.jl#L404-L428">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Union{Tuple{LazySets.LineSegment{N},LazySets.Hyperrectangle{N},Bool}, Tuple{LazySets.LineSegment{N},LazySets.Hyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#Base.:⊆-Union{Tuple{LazySets.LineSegment{N},LazySets.Hyperrectangle{N},Bool}, Tuple{LazySets.LineSegment{N},LazySets.Hyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(L::LineSegment{N}, H::Hyperrectangle{N}, [witness]::Bool=false
 )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a line segment is contained in a hyperrectangle, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>L</code> – inner line segment</p></li><li><p><code>H</code> – outer hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$L ⊆ H$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$L ⊆ H$</span></p></li><li><p><code>(false, v)</code> iff <span>$L \not\subseteq H$</span> and <span>$v ∈ L \setminus H$</span></p></li></ul></li></ul><p><strong>Notes</strong></p><p>This copy-pasted method just exists to avoid method ambiguities.</p><p><strong>Algorithm</strong></p><p>Since <span>$H$</span> is convex, <span>$L ⊆ H$</span> iff <span>$p ∈ H$</span> and <span>$q ∈ H$</span>, where <span>$p, q$</span> are the end points of <span>$L$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_subset.jl#L443-L471">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆-Tuple{LazySets.Interval,LazySets.Interval}" href="#Base.:⊆-Tuple{LazySets.Interval,LazySets.Interval}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">⊆(x::Interval, y::Interval)</code></pre><p>Check whether an interval is contained in another interval.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – interval</p></li><li><p><code>y</code> – interval</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ⊆ y$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_subset.jl#L485-L498">source</a></section><h2><a class="nav-anchor" id="Check-for-emptiness-of-intersection-1" href="#Check-for-emptiness-of-intersection-1">Check for emptiness of intersection</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{LazySets.AbstractHyperrectangle{N},LazySets.AbstractHyperrectangle{N},Bool}, Tuple{LazySets.AbstractHyperrectangle{N},LazySets.AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{LazySets.AbstractHyperrectangle{N},LazySets.AbstractHyperrectangle{N},Bool}, Tuple{LazySets.AbstractHyperrectangle{N},LazySets.AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_intersection_empty(H1::AbstractHyperrectangle{N},
                      H2::AbstractHyperrectangle{N},
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether two hyperrectangles do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>H1</code> – first hyperrectangle</p></li><li><p><code>H2</code> – second hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$H1 ∩ H2 = ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$H1 ∩ H2 = ∅$</span></p></li><li><p><code>(false, v)</code> iff <span>$H1 ∩ H2 ≠ ∅$</span> and <span>$v ∈ H1 ∩ H2$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$H1 ∩ H2 ≠ ∅$</span> iff <span>$|c_2 - c_1| ≤ r_1 + r_2$</span>, where <span>$≤$</span> is taken component-wise.</p><p>A witness is computed by starting in one center and moving toward the other center for as long as the minimum of the radius and the center distance. In other words, the witness is the point in <code>H1</code> that is closest to the center of <code>H2</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_intersection_empty.jl#L7-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{LazySets.AbstractHyperrectangle{N},LazySets.AbstractSingleton{N},Bool}, Tuple{LazySets.AbstractHyperrectangle{N},LazySets.AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{LazySets.AbstractHyperrectangle{N},LazySets.AbstractSingleton{N},Bool}, Tuple{LazySets.AbstractHyperrectangle{N},LazySets.AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_intersection_empty(H::AbstractHyperrectangle{N},
                      S::AbstractSingleton{N},
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a hyperrectangle and a singleton do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li><li><p><code>S</code> – singleton</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$H ∩ S = ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$H ∩ S = ∅$</span></p></li><li><p><code>(false, v)</code> iff <span>$H ∩ S ≠ ∅$</span> and <code>v</code> = <code>element(S)</code> <span>$∈ H ∩ S$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$H ∩ S = ∅$</span> iff <code>element(S)</code> <span>$∉ H$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_intersection_empty.jl#L192-L217">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{LazySets.AbstractSingleton{N},LazySets.LazySet{N},Bool}, Tuple{LazySets.AbstractSingleton{N},LazySets.LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{LazySets.AbstractSingleton{N},LazySets.LazySet{N},Bool}, Tuple{LazySets.AbstractSingleton{N},LazySets.LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_intersection_empty(S::AbstractSingleton{N},
                      set::LazySet{N},
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a singleton and a convex set do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code>   – singleton</p></li><li><p><code>set</code> – convex set</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ∩ \operatorname{set} = ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S ∩ \operatorname{set} = ∅$</span></p></li><li><p><code>(false, v)</code> iff <span>$S ∩ \operatorname{set} ≠ ∅$</span> and <code>v</code> = <code>element(S)</code> <span>$∈ S ∩ \operatorname{set}$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ∩ \operatorname{set} = ∅$</span> iff <code>element(S)</code> <span>$∉ \operatorname{set}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_intersection_empty.jl#L78-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{LazySets.AbstractSingleton{N},LazySets.AbstractHyperrectangle{N},Bool}, Tuple{LazySets.AbstractSingleton{N},LazySets.AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{LazySets.AbstractSingleton{N},LazySets.AbstractHyperrectangle{N},Bool}, Tuple{LazySets.AbstractSingleton{N},LazySets.AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_intersection_empty(S::AbstractSingleton{N},
                      H::AbstractHyperrectangle{N},
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a singleton and a hyperrectangle do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – singleton</p></li><li><p><code>H</code> – hyperrectangle</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$H ∩ S = ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$H ∩ S = ∅$</span></p></li><li><p><code>(false, v)</code> iff <span>$H ∩ S ≠ ∅$</span> and <code>v</code> = <code>element(S)</code> <span>$∈ H ∩ S$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ∩ H = ∅$</span> iff <code>element(S)</code> <span>$∉ H$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_intersection_empty.jl#L231-L256">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{LazySets.AbstractSingleton{N},LazySets.AbstractSingleton{N},Bool}, Tuple{LazySets.AbstractSingleton{N},LazySets.AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{LazySets.AbstractSingleton{N},LazySets.AbstractSingleton{N},Bool}, Tuple{LazySets.AbstractSingleton{N},LazySets.AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_intersection_empty(S1::AbstractSingleton{N},
                      S2::AbstractSingleton{N},
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether two singletons do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>S1</code> – first singleton</p></li><li><p><code>S2</code> – second singleton</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S1 ∩ S2 = ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S1 ∩ S2 = ∅$</span></p></li><li><p><code>(false, v)</code> iff <span>$S1 ∩ S2 ≠ ∅$</span> and <code>v</code> = <code>element(S1)</code> <span>$∈ S1 ∩ S2$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S1 ∩ S2 = ∅$</span> iff <span>$S1 ≠ S2$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_intersection_empty.jl#L153-L178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{LazySets.LazySet{N},LazySets.AbstractSingleton{N},Bool}, Tuple{LazySets.LazySet{N},LazySets.AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{LazySets.LazySet{N},LazySets.AbstractSingleton{N},Bool}, Tuple{LazySets.LazySet{N},LazySets.AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_intersection_empty(set::LazySet{N},
                      S::AbstractSingleton{N},
                      witness::Bool=false
                     )::Union{Bool,Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a convex set and a singleton do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>set</code> – convex set</p></li><li><p><code>S</code>   – singleton</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ∩ \operatorname{set} = ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$S ∩ \operatorname{set} = ∅$</span></p></li><li><p><code>(false, v)</code> iff <span>$S ∩ \operatorname{set} ≠ ∅$</span> and <code>v</code> = <code>element(S)</code> <span>$∈ S ∩ \operatorname{set}$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ∩ \operatorname{set} = ∅$</span> iff <code>element(S)</code> <span>$∉ \operatorname{set}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_intersection_empty.jl#L118-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{LazySets.Zonotope{N},LazySets.Hyperplane{N},Bool}, Tuple{LazySets.Zonotope{N},LazySets.Hyperplane{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{LazySets.Zonotope{N},LazySets.Hyperplane{N},Bool}, Tuple{LazySets.Zonotope{N},LazySets.Hyperplane{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_intersection_empty(Z::Zonotope{N}, H::Hyperplane{N}, witness::Bool=false
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a zonotope and a hyperplane do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>Z</code> – zonotope</p></li><li><p><code>H</code> – hyperplane</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$Z ∩ H = ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$Z ∩ H = ∅$</span></p></li><li><p><code>(false, v)</code> iff <span>$Z ∩ H ≠ ∅$</span> and <span>$v ∈ Z ∩ H$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$Z ∩ H = ∅$</span> iff <span>$(b - a⋅c) ∉ \left[ ± ∑_{i=1}^p |a⋅g_i| \right]$</span>, where <span>$a$</span>, <span>$b$</span> are the hyperplane coefficients, <span>$c$</span> is the zonotope&#39;s center, and <span>$g_i$</span> are the zonotope&#39;s generators.</p><p><strong>Notes</strong></p><p>Witness production is currently not supported.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_intersection_empty.jl#L338-L367">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{LazySets.Hyperplane{N},LazySets.Zonotope{N},Bool}, Tuple{LazySets.Hyperplane{N},LazySets.Zonotope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{LazySets.Hyperplane{N},LazySets.Zonotope{N},Bool}, Tuple{LazySets.Hyperplane{N},LazySets.Zonotope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_intersection_empty(H::Hyperplane{N}, Z::Zonotope{N}, witness::Bool=false
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a hyperplane and a zonotope do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperplane</p></li><li><p><code>Z</code> – zonotope</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$H ∩ Z = ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$H ∩ Z = ∅$</span></p></li><li><p><code>(false, v)</code> iff <span>$H ∩ Z ≠ ∅$</span> and <span>$v ∈ H ∩ Z$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$H ∩ Z = ∅$</span> iff <span>$(b - a⋅c) ∉ \left[ ± ∑_{i=1}^p |a⋅g_i| \right]$</span>, where <span>$a$</span>, <span>$b$</span> are the hyperplane coefficients, <span>$c$</span> is the zonotope&#39;s center, and <span>$g_i$</span> are the zonotope&#39;s generators.</p><p><strong>Notes</strong></p><p>Witness production is currently not supported.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_intersection_empty.jl#L385-L414">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{LazySets.Ball2{N},LazySets.Ball2{N},Bool}, Tuple{LazySets.Ball2{N},LazySets.Ball2{N}}, Tuple{N}} where N&lt;:AbstractFloat" href="#LazySets.is_intersection_empty-Union{Tuple{LazySets.Ball2{N},LazySets.Ball2{N},Bool}, Tuple{LazySets.Ball2{N},LazySets.Ball2{N}}, Tuple{N}} where N&lt;:AbstractFloat"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_intersection_empty(B1::Ball2{N},
                      B2::Ball2{N},
                      witness::Bool=false
                     )::Union{Bool, Tuple{Bool,Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether two balls in the 2-norm do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>B1</code> – first ball in the 2-norm</p></li><li><p><code>B2</code> – second ball in the 2-norm</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$B1 ∩ B2 = ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$B1 ∩ B2 = ∅$</span></p></li><li><p><code>(false, v)</code> iff <span>$B1 ∩ B2 ≠ ∅$</span> and <span>$v ∈ B1 ∩ B2$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$B1 ∩ B2 = ∅$</span> iff <span>$‖ c_2 - c_1 ‖_2 &gt; r_1 + r_2$</span>.</p><p>A witness is computed depending on the smaller/bigger ball (to break ties, choose <code>B1</code> for the smaller ball) as follows.</p><ul><li><p>If the smaller ball&#39;s center is contained in the bigger ball, we return it.</p></li><li><p>Otherwise start in the smaller ball&#39;s center and move toward the other center until hitting the smaller ball&#39;s border. In other words, the witness is the point in the smaller ball that is closest to the center of the bigger ball.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_intersection_empty.jl#L268-L301">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_intersection_empty-Union{Tuple{LazySets.LineSegment{N},LazySets.LineSegment{N},Bool}, Tuple{LazySets.LineSegment{N},LazySets.LineSegment{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.is_intersection_empty-Union{Tuple{LazySets.LineSegment{N},LazySets.LineSegment{N},Bool}, Tuple{LazySets.LineSegment{N},LazySets.LineSegment{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_intersection_empty(ls1::LineSegment{N},
                      ls2::LineSegment{N},
                      witness::Bool=false
                     )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether two line segments do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>ls1</code> – first line segment</p></li><li><p><code>ls2</code> – second line segment</p></li><li><p><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</p></li></ul><p><strong>Output</strong></p><ul><li><p>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$ls1 ∩ ls2 = ∅$</span></p></li><li><p>If <code>witness</code> option is activated:</p><ul><li><p><code>(true, [])</code> iff <span>$ls1 ∩ ls2 = ∅$</span></p></li><li><p><code>(false, v)</code> iff <span>$ls1 ∩ ls2 ≠ ∅$</span> and <span>$v ∈ ls1 ∩ ls2$</span></p></li></ul></li></ul><p><strong>Algorithm</strong></p><p>The algorithm is inspired from <a href="https://stackoverflow.com/a/565282">here</a>, which again is the special 2D case of a 3D algorithm by Ronald Goldman&#39;s article on the <em>Intersection of two lines in three-space</em> in Graphics Gems, Andrew S. (ed.), 1990.</p><p>We first check if the two line segments are parallel, and if so, if they are collinear. In the latter case, we check containment of any of the end points in the other line segment. Otherwise the lines are not parallel, so we can solve an equation of the intersection point, if it exists.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/is_intersection_empty.jl#L422-L456">source</a></section><h2><a class="nav-anchor" id="Intersection-of-two-sets-1" href="#Intersection-of-two-sets-1">Intersection of two sets</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.intersection-Union{Tuple{LazySets.Line{N,V} where V&lt;:AbstractArray{N,1},LazySets.Line{N,V} where V&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real" href="#LazySets.intersection-Union{Tuple{LazySets.Line{N,V} where V&lt;:AbstractArray{N,1},LazySets.Line{N,V} where V&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">intersection(L1::Line{N}, L2::Line{N}
            )::Union{Singleton{N}, Line{N}, EmptySet{N}} where {N&lt;:Real}</code></pre><p>Return the intersection of two 2D lines.</p><p><strong>Input</strong></p><ul><li><p><code>L1</code> – first line</p></li><li><p><code>L2</code> – second line</p></li></ul><p><strong>Output</strong></p><p>If the lines are identical, the result is the first line. If the lines are parallel and not identical, the result is the empty set. Otherwise the result is the only intersection point.</p><p><strong>Examples</strong></p><p>The line <span>$y = -x + 1$</span> intersected with the line <span>$y = x$</span>:</p><pre><code class="language-julia-repl">julia&gt; intersection(Line([-1., 1.], 0.), Line([1., 1.], 1.))
Singleton{Float64}([0.5, 0.5])
julia&gt; intersection(Line([1., 1.], 1.), Line([1., 1.], 1.))
Line{Float64,Array{Float64,1}}([1.0, 1.0], 1.0)
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/concrete_intersection.jl#L5-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.intersection-Union{Tuple{LazySets.Hyperrectangle{N},LazySets.Hyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.intersection-Union{Tuple{LazySets.Hyperrectangle{N},LazySets.Hyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">intersection(H1::AbstractHyperrectangle{N},
             H2::AbstractHyperrectangle{N}
            )::Union{&lt;:Hyperrectangle{N}, EmptySet{N}} where {N&lt;:Real}</code></pre><p>Return the intersection of two hyperrectangles.</p><p><strong>Input</strong></p><ul><li><p><code>H1</code> – first hyperrectangle</p></li><li><p><code>H2</code> – second hyperrectangle</p></li></ul><p><strong>Output</strong></p><p>If the hyperrectangles do not intersect, the result is the empty set. Otherwise the result is the hyperrectangle that describes the intersection.</p><p><strong>Algorithm</strong></p><p>In each isolated direction <code>i</code> we compute the rightmost left border and the leftmost right border of the hyperrectangles. If these borders contradict, then the intersection is empty. Otherwise the result uses these borders in each dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/67426ec1375627f7c2e28d9767301383b67173ba/src/concrete_intersection.jl#L55-L78">source</a></section><footer><hr/><a class="previous" href="conversion.html"><span class="direction">Previous</span><span class="title">Conversion between set representations</span></a><a class="next" href="approximations.html"><span class="direction">Next</span><span class="title">Approximations</span></a></footer></article></body></html>
