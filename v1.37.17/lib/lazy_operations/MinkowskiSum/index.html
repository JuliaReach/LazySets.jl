<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MinkowskiSum · LazySets.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">LazySets.jl</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../../man/set_operations/">Operations on Sets</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../interfaces/">Interfaces</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../../sets/Line/">Line</a></li><li><a class="tocitem" href="../../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../../sets/PolynomialZonotope/">PolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../../sets/Zonotope/">Zonotope</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../Bloating/">Bloating</a></li><li><a class="tocitem" href="../CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../Complement/">Complement</a></li><li><a class="tocitem" href="../ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../Intersection/">Intersection</a></li><li><a class="tocitem" href="../LinearMap/">LinearMap</a></li><li class="is-active"><a class="tocitem" href>MinkowskiSum</a><ul class="internal"><li><a class="tocitem" href="#def_MinkowskiSum"><span>Binary Minkowski sum (MinkowskiSum)</span></a></li><li><a class="tocitem" href="#def_MinkowskiSumArray"><span><span>$n$</span>-ary Minkowski sum (MinkowskiSumArray)</span></a></li><li><a class="tocitem" href="#def_CachedMinkowskiSumArray"><span><span>$n$</span>-ary Minkowski sum with cache (CachedMinkowskiSumArray)</span></a></li></ul></li><li><a class="tocitem" href="../Rectification/">Rectification</a></li><li><a class="tocitem" href="../ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../Translation/">Translation</a></li><li><a class="tocitem" href="../UnionSet/">UnionSet</a></li></ul></li><li><a class="tocitem" href="../../binary_functions/">Concrete Operations</a></li><li><a class="tocitem" href="../../conversion/">Conversions between set representations</a></li><li><a class="tocitem" href="../../comparisons/">Comparisons</a></li><li><a class="tocitem" href="../../approximations/">Approximations</a></li><li><a class="tocitem" href="../../utils/">Utility Functions</a></li><li><a class="tocitem" href="../../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li><a class="is-disabled">Lazy Operations</a></li><li class="is-active"><a href>MinkowskiSum</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MinkowskiSum</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/lazy_operations/MinkowskiSum.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Minkowski-sum"><a class="docs-heading-anchor" href="#Minkowski-sum">Minkowski sum</a><a id="Minkowski-sum-1"></a><a class="docs-heading-anchor-permalink" href="#Minkowski-sum" title="Permalink"></a></h1><h2 id="def_MinkowskiSum"><a class="docs-heading-anchor" href="#def_MinkowskiSum">Binary Minkowski sum (MinkowskiSum)</a><a id="def_MinkowskiSum-1"></a><a class="docs-heading-anchor-permalink" href="#def_MinkowskiSum" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.MinkowskiSum" href="#LazySets.MinkowskiSum"><code>LazySets.MinkowskiSum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MinkowskiSum{N, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the Minkowski sum of two convex sets.</p><p><strong>Fields</strong></p><ul><li><code>X</code> – first convex set</li><li><code>Y</code> – second convex set</li></ul><p><strong>Notes</strong></p><p>The <code>ZeroSet</code> is the neutral element and the <code>EmptySet</code> is the absorbing element for <code>MinkowskiSum</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSum.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.:⊕-Tuple{LazySet,LazySet}" href="#LazySets.:⊕-Tuple{LazySet,LazySet}"><code>LazySets.:⊕</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">⊕(X::LazySet, Y::LazySet)</code></pre><p>Unicode alias constructor ⊕ (<code>oplus</code>) for the lazy Minkowski sum operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSum.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{LazySet,LazySet}" href="#Base.:+-Tuple{LazySet,LazySet}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">X + Y</code></pre><p>Convenience constructor for Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>X</code> – a convex set</li><li><code>Y</code> – another convex set</li></ul><p><strong>Output</strong></p><p>The symbolic Minkowski sum of <span>$X$</span> and <span>$Y$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSum.jl#L43-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.swap-Tuple{MinkowskiSum}" href="#LazySets.swap-Tuple{MinkowskiSum}"><code>LazySets.swap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swap(ms::MinkowskiSum)</code></pre><p>Return a new <code>MinkowskiSum</code> object with the arguments swapped.</p><p><strong>Input</strong></p><ul><li><code>ms</code> – Minkowski sum of two convex sets</li></ul><p><strong>Output</strong></p><p>A new <code>MinkowskiSum</code> object with the arguments swapped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSum.jl#L66-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.dim-Tuple{MinkowskiSum}" href="#LazySets.dim-Tuple{MinkowskiSum}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dim(ms::MinkowskiSum)</code></pre><p>Return the dimension of a Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>ms</code> – Minkowski sum</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Minkowski sum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSum.jl#L83-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.ρ-Tuple{AbstractArray{T,1} where T,MinkowskiSum}" href="#LazySets.ρ-Tuple{AbstractArray{T,1} where T,MinkowskiSum}"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ρ(d::AbstractVector, ms::MinkowskiSum)</code></pre><p>Return the support function of a Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>ms</code> – Minkowski sum</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p><p><strong>Algorithm</strong></p><p>The support function in direction <span>$d$</span> of the Minkowski sum of two sets <span>$X$</span> and <span>$Y$</span> is the sum of the support functions of <span>$X$</span> and <span>$Y$</span> in direction <span>$d$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSum.jl#L125-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{T,1} where T,MinkowskiSum}" href="#LazySets.σ-Tuple{AbstractArray{T,1} where T,MinkowskiSum}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">σ(d::AbstractVector, ms::MinkowskiSum)</code></pre><p>Return the support vector of a Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>ms</code> – Minkowski sum</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.</p><p><strong>Algorithm</strong></p><p>The support vector in direction <span>$d$</span> of the Minkowski sum of two sets <span>$X$</span> and <span>$Y$</span> is the sum of the support vectors of <span>$X$</span> and <span>$Y$</span> in direction <span>$d$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSum.jl#L100-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isbounded-Tuple{MinkowskiSum}" href="#LazySets.isbounded-Tuple{MinkowskiSum}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isbounded(ms::MinkowskiSum)</code></pre><p>Determine whether a Minkowski sum is bounded.</p><p><strong>Input</strong></p><ul><li><code>ms</code> – Minkowski sum</li></ul><p><strong>Output</strong></p><p><code>true</code> iff both wrapped sets are bounded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSum.jl#L149-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{MinkowskiSum}" href="#Base.isempty-Tuple{MinkowskiSum}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isempty(ms::MinkowskiSum)</code></pre><p>Return if a Minkowski sum is empty or not.</p><p><strong>Input</strong></p><ul><li><code>ms</code> – Minkowski sum</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the wrapped sets are empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSum.jl#L166-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.constraints_list-Tuple{MinkowskiSum}" href="#LazySets.constraints_list-Tuple{MinkowskiSum}"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraints_list(ms::MinkowskiSum)</code></pre><p>Return the list of constraints of a lazy Minkowski sum of two polyhedral sets.</p><p><strong>Input</strong></p><ul><li><code>ms</code> – Minkowski sum of two polyhedral sets</li></ul><p><strong>Output</strong></p><p>The list of constraints of the Minkowski sum.</p><p><strong>Algorithm</strong></p><p>We compute a concrete set representation via <code>minkowski_sum</code> and call <code>constraints_list</code> on the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSum.jl#L183-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∈-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractArray{T,1} where T,MinkowskiSum{N,S1,S2}}} where S2&lt;:LazySet where S1&lt;:AbstractSingleton where N" href="#Base.:∈-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractArray{T,1} where T,MinkowskiSum{N,S1,S2}}} where S2&lt;:LazySet where S1&lt;:AbstractSingleton where N"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∈(x::AbstractVector, ms::MinkowskiSum{N, S1, S2}) where {N, S1&lt;:AbstractSingleton, S2&lt;:LazySet}</code></pre><p>Check whether a given point is contained in the Minkowski sum of a singleton and a set.</p><p><strong>Input</strong></p><ul><li><code>x</code>  – point</li><li><code>ms</code> – lazy Minkowski sum of a singleton and a set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ ms$</span>.</p><p><strong>Algorithm</strong></p><p>Note that <span>$x ∈ (S ⊕ P)$</span>, where <span>$S$</span> is a singleton set, <span>$S = \{s\}$</span> and <span>$P$</span> is a set, if and only if <span>$(x-s) ∈ P$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSum.jl#L205-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{MinkowskiSum{N,Z1,Z2}}, Tuple{Z2}, Tuple{Z1}, Tuple{N}} where Z2&lt;:AbstractZonotope{N} where Z1&lt;:AbstractZonotope{N} where N" href="#LazySets.vertices_list-Union{Tuple{MinkowskiSum{N,Z1,Z2}}, Tuple{Z2}, Tuple{Z1}, Tuple{N}} where Z2&lt;:AbstractZonotope{N} where Z1&lt;:AbstractZonotope{N} where N"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertices_list(P::AbstractHPolygon{N};
              apply_convex_hull::Bool=true,
              check_feasibility::Bool=true) where {N}</code></pre><p>Return the list of vertices of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>                 – polygon in constraint representation</li><li><code>apply_convex_hull</code> – (optional, default: <code>true</code>) flag to post-process the                        intersection of constraints with a convex hull</li><li><code>check_feasibility</code> – (optional, default: <code>true</code>) flag to check whether the                        polygon was empty (required for correctness in case of                        empty polygons)</li></ul><p><strong>Output</strong></p><p>List of vertices.</p><p><strong>Algorithm</strong></p><p>We compute each vertex as the intersection of consecutive lines defined by the half-spaces. If <code>check_feasibility</code> is active, we then check if the constraints of the polygon were actually feasible (i.e., they pointed in the <em>right</em> direction). For this we compute the <em>average</em> of all vertices and check membership in each constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/Interfaces/AbstractHPolygon.jl#L108-L136">source</a></section><section><div><pre><code class="language-none">vertices_list(B::Ball1{N, VN}) where {N, VN&lt;:AbstractVector}</code></pre><p>Return the list of vertices of a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the 1-norm</li></ul><p><strong>Output</strong></p><p>A list containing the vertices of the ball in the 1-norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/Sets/Ball1.jl#L84-L96">source</a></section><section><div><pre><code class="language-none">vertices_list(∅::EmptySet{N}) where {N}</code></pre><p>Return the list of vertices of an empty set.</p><p><strong>Input</strong></p><ul><li><code>∅</code> – empty set</li></ul><p><strong>Output</strong></p><p>The empty list of vertices, as the empty set does not contain any vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/Sets/EmptySet.jl#L293-L305">source</a></section><section><div><pre><code class="language-none">vertices_list(P::HPolytope{N};
              [backend]=nothing, [prune]::Bool=true) where {N}</code></pre><p>Return the list of vertices of a polytope in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polytope in constraint representation</li><li><code>backend</code> – (optional, default: <code>nothing</code>) the polyhedral computations backend</li><li><code>prune</code>   – (optional, default: <code>true</code>) flag to remove redundant vertices</li></ul><p><strong>Output</strong></p><p>List of vertices.</p><p><strong>Algorithm</strong></p><p>If the polytope is two-dimensional, the polytope is converted to a polygon in H-representation and then its <code>vertices_list</code> function is used. This ensures that, by default, the optimized two-dimensional methods are used.</p><p>It is possible to use the <code>Polyhedra</code> backend in two-dimensions as well by passing, e.g. <code>backend=CDDLib.Library()</code>.</p><p>If the polytope is not two-dimensional, the concrete polyhedra manipulation library <code>Polyhedra</code> is used. The actual computation is performed by a given backend; for the default backend used in <code>LazySets</code> see <code>default_polyhedra_backend(N)</code>. For further information on the supported backends see <a href="https://juliapolyhedra.github.io/Polyhedra.jl/">Polyhedra&#39;s documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/Sets/HPolytope.jl#L180-L210">source</a></section><section><div><pre><code class="language-none">vertices_list(cp::CartesianProduct{N}) where {N}</code></pre><p>Return the list of vertices of a (polytopic) Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/CartesianProduct.jl#L225-L243">source</a></section><section><div><p>vertices_list(cpa::CartesianProductArray{N}) where {N}</p><p>Return the list of vertices of a (polytopic) Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/CartesianProductArray.jl#L309-L328">source</a></section><section><div><pre><code class="language-none">vertices_list(em::ExponentialMap{N}) where {N}</code></pre><p>Return the list of vertices of a (polytopic) exponential map.</p><p><strong>Input</strong></p><ul><li><code>em</code> – exponential map</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying set <code>X</code> is polytopic. Then the result is just the exponential map applied to the vertices of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/ExponentialMap.jl#L398-L415">source</a></section><section><div><pre><code class="language-none">vertices_list(ms::MinkowskiSum{N, Z1, Z2}) where {N, Z1&lt;:AbstractZonotope{N}, Z2&lt;:AbstractZonotope{N}}</code></pre><p>Return the list of vertices for the Minkowski sum of two zonotopic sets.</p><p><strong>Input</strong></p><ul><li><code>ms</code> – Minkowski sum of two zonotopic sets</li></ul><p><strong>Output</strong></p><p>The list of vertices of the Minkowski sum of two zonotopic sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSum.jl#L258-L270">source</a></section></article><p>Inherited from <a href="../../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N"><code>an_element</code></a></li><li><a href="../../interfaces/#LazySets.singleton_list-Tuple{LazySet}"><code>singleton_list</code></a></li></ul><h2 id="def_MinkowskiSumArray"><a class="docs-heading-anchor" href="#def_MinkowskiSumArray"><span>$n$</span>-ary Minkowski sum (MinkowskiSumArray)</a><a id="def_MinkowskiSumArray-1"></a><a class="docs-heading-anchor-permalink" href="#def_MinkowskiSumArray" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.MinkowskiSumArray" href="#LazySets.MinkowskiSumArray"><code>LazySets.MinkowskiSumArray</code></a> — <span class="docstring-category">Type</span></header><section><div><p>MinkowskiSumArray{N, S&lt;:LazySet{N}} &lt;: LazySet{N}</p><p>Type that represents the Minkowski sum of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><code>array</code> – array of convex sets</li></ul><p><strong>Notes</strong></p><p>This type assumes that the dimensions of all elements match.</p><p>The <code>ZeroSet</code> is the neutral element and the <code>EmptySet</code> is the absorbing element for <code>MinkowskiSumArray</code>.</p><p>Constructors:</p><ul><li><p><code>MinkowskiSumArray(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>MinkowskiSumArray([n]::Int=0, [N]::Type=Float64)</code></p></li></ul><p>– constructor for an empty sum with optional size hint and numeric type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSumArray.jl#L8-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.dim-Tuple{MinkowskiSumArray}" href="#LazySets.dim-Tuple{MinkowskiSumArray}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span></header><section><div><p>dim(msa::MinkowskiSumArray)</p><p>Return the dimension of a Minkowski sum of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Minkowski sum of a finite number of sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSumArray.jl#L72-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.ρ-Tuple{AbstractArray{T,1} where T,MinkowskiSumArray}" href="#LazySets.ρ-Tuple{AbstractArray{T,1} where T,MinkowskiSumArray}"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ρ(d::AbstractVector, msa::MinkowskiSumArray)</p><p>Return the support function of a Minkowski sum array of a finite number of sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p><p><strong>Algorithm</strong></p><p>The support function of the Minkowski sum of sets is the sum of the support functions of each set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSumArray.jl#L109-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{T,1} where T,MinkowskiSumArray}" href="#LazySets.σ-Tuple{AbstractArray{T,1} where T,MinkowskiSumArray}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>σ(d::AbstractVector, msa::MinkowskiSumArray)</p><p>Return the support vector of a Minkowski sum of a finite number of sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSumArray.jl#L89-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isbounded-Tuple{MinkowskiSumArray}" href="#LazySets.isbounded-Tuple{MinkowskiSumArray}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isbounded(msa::MinkowskiSumArray)</code></pre><p>Determine whether a Minkowski sum of a finite number of convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff all wrapped sets are bounded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSumArray.jl#L133-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{MinkowskiSumArray}" href="#Base.isempty-Tuple{MinkowskiSumArray}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><p>isempty(msa::MinkowskiSumArray)</p><p>Return if a Minkowski sum array is empty or not.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the wrapped sets are empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSumArray.jl#L150-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.array-Tuple{MinkowskiSumArray}" href="#LazySets.array-Tuple{MinkowskiSumArray}"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span></header><section><div><p>array(msa::MinkowskiSumArray)</p><p>Return the array of a Minkowski sum of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The array of a Minkowski sum of a finite number of convex sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/MinkowskiSumArray.jl#L55-L67">source</a></section></article><p>Inherited from <a href="../../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N"><code>an_element</code></a></li><li><a href="../../interfaces/#LazySets.singleton_list-Tuple{LazySet}"><code>singleton_list</code></a></li></ul><h2 id="def_CachedMinkowskiSumArray"><a class="docs-heading-anchor" href="#def_CachedMinkowskiSumArray"><span>$n$</span>-ary Minkowski sum with cache (CachedMinkowskiSumArray)</a><a id="def_CachedMinkowskiSumArray-1"></a><a class="docs-heading-anchor-permalink" href="#def_CachedMinkowskiSumArray" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.CachedMinkowskiSumArray" href="#LazySets.CachedMinkowskiSumArray"><code>LazySets.CachedMinkowskiSumArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CachedMinkowskiSumArray{N, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the Minkowski sum of a finite number of convex sets. Support vector queries are cached.</p><p><strong>Fields</strong></p><ul><li><code>array</code> – array of convex sets</li><li><code>cache</code> – cache of support vector query results</li></ul><p><strong>Notes</strong></p><p>This type assumes that the dimensions of all elements match.</p><p>The <code>ZeroSet</code> is the neutral element and the <code>EmptySet</code> is the absorbing element for <code>CachedMinkowskiSumArray</code>.</p><p>The cache (field <code>cache</code>) is implemented as dictionary whose keys are directions and whose values are pairs <code>(k, s)</code> where <code>k</code> is the number of elements in the array <code>array</code> when the support vector was evaluated last time, and <code>s</code> is the support vector that was obtained. Thus this type assumes that <code>array</code> is not modified except by adding new sets at the end.</p><p>Constructors:</p><ul><li><p><code>CachedMinkowskiSumArray(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>CachedMinkowskiSumArray([n]::Int=0, [N]::Type=Float64)</code> – constructor for an empty sum with optional size hint and numeric type</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/CachedMinkowskiSumArray.jl#L32-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.dim-Tuple{CachedMinkowskiSumArray}" href="#LazySets.dim-Tuple{CachedMinkowskiSumArray}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dim(cms::CachedMinkowskiSumArray)</code></pre><p>Return the dimension of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the caching Minkowski sum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/CachedMinkowskiSumArray.jl#L107-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{T,1} where T,CachedMinkowskiSumArray}" href="#LazySets.σ-Tuple{AbstractArray{T,1} where T,CachedMinkowskiSumArray}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">σ(d::AbstractVector, cms::CachedMinkowskiSumArray)</code></pre><p>Return the support vector of a caching Minkowski sum in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.</p><p><strong>Notes</strong></p><p>The result is cached, i.e., any further query with the same direction runs in constant time. When sets are added to the caching Minkowski sum, the query is only performed for the new sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/CachedMinkowskiSumArray.jl#L124-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isbounded-Tuple{CachedMinkowskiSumArray}" href="#LazySets.isbounded-Tuple{CachedMinkowskiSumArray}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isbounded(cms::CachedMinkowskiSumArray)</code></pre><p>Determine whether a caching Minkowski sum is bounded.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p><code>true</code> iff all wrapped sets are bounded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/CachedMinkowskiSumArray.jl#L171-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{CachedMinkowskiSumArray}" href="#Base.isempty-Tuple{CachedMinkowskiSumArray}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isempty(cms::CachedMinkowskiSumArray)</code></pre><p>Return if a caching Minkowski sum array is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the wrapped sets are empty.</p><p><strong>Notes</strong></p><p>Forgotten sets cannot be checked anymore. Usually they have been empty because otherwise the support vector query should have crashed before. In that case, the caching Minkowski sum should not be used further.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/CachedMinkowskiSumArray.jl#L188-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.array-Tuple{CachedMinkowskiSumArray}" href="#LazySets.array-Tuple{CachedMinkowskiSumArray}"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">array(cms::CachedMinkowskiSumArray)</code></pre><p>Return the array of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The array of a caching Minkowski sum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/CachedMinkowskiSumArray.jl#L90-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.forget_sets!-Tuple{CachedMinkowskiSumArray}" href="#LazySets.forget_sets!-Tuple{CachedMinkowskiSumArray}"><code>LazySets.forget_sets!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">forget_sets!(cms::CachedMinkowskiSumArray)</code></pre><p>Tell a caching Minkowski sum to forget the stored sets (but not the support vectors). Only those sets are forgotten such that for each cached direction the support vector has been computed before.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The number of sets that have been forgotten.</p><p><strong>Notes</strong></p><p>This function should only be used under the assertion that no new directions are queried in the future; otherwise such support vector results will be incorrect.</p><p>This implementation is optimistic and first tries to remove all sets. However, it also checks that for all cached directions the support vector has been computed before. If it finds that this is not the case, the implementation identifies the biggest index <span>$k$</span> such that the above holds for the <span>$k$</span> oldest sets, and then it only removes these. See the example below.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x1 = BallInf(ones(3), 3.); x2 = Ball1(ones(3), 5.);

julia&gt; cms1 = CachedMinkowskiSumArray(2); cms2 = CachedMinkowskiSumArray(2);

julia&gt; d = ones(3);

julia&gt; a1 = array(cms1); a2 = array(cms2);

julia&gt; push!(a1, x1); push!(a2, x1);

julia&gt; σ(d, cms1); σ(d, cms2);

julia&gt; push!(a1, x2); push!(a2, x2);

julia&gt; σ(d, cms1);

julia&gt; idx1 = forget_sets!(cms1) # support vector was computed for both sets
2

julia&gt; idx1 = forget_sets!(cms2) # support vector was only computed for first set
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e52065fe9c294a5f1c7cae172ce7db4fa9e48b45/src/LazyOperations/CachedMinkowskiSumArray.jl#L212-L266">source</a></section></article><p>Inherited from <a href="../../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N"><code>an_element</code></a></li><li><a href="../../interfaces/#LazySets.singleton_list-Tuple{LazySet}"><code>singleton_list</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../LinearMap/">« LinearMap</a><a class="docs-footer-nextpage" href="../Rectification/">Rectification »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 31 December 2020 23:42">Thursday 31 December 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
