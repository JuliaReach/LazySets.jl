<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Concrete Operations · LazySets.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">LazySets.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../man/set_operations/">Operations on Sets</a></li><li><a class="tocitem" href="../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../sets/Line/">Line</a></li><li><a class="tocitem" href="../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../sets/PolynomialZonotope/">PolynomialZonotope</a></li><li><a class="tocitem" href="../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../sets/Star/">Star</a></li><li><a class="tocitem" href="../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../sets/Zonotope/">Zonotope</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lazy_operations/AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../lazy_operations/Bloating/">Bloating</a></li><li><a class="tocitem" href="../lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../lazy_operations/Complement/">Complement</a></li><li><a class="tocitem" href="../lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../lazy_operations/Intersection/">Intersection</a></li><li><a class="tocitem" href="../lazy_operations/LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../lazy_operations/Rectification/">Rectification</a></li><li><a class="tocitem" href="../lazy_operations/ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../lazy_operations/Translation/">Translation</a></li><li><a class="tocitem" href="../lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li class="is-active"><a class="tocitem" href>Concrete Operations</a><ul class="internal"><li><a class="tocitem" href="#Cartesian-product"><span>Cartesian product</span></a></li><li><a class="tocitem" href="#Check-for-emptiness-of-intersection"><span>Check for emptiness of intersection</span></a></li><li><a class="tocitem" href="#Convex-hull"><span>Convex hull</span></a></li><li><a class="tocitem" href="#Intersection-of-two-sets"><span>Intersection of two sets</span></a></li><li><a class="tocitem" href="#Minkowski-sum"><span>Minkowski sum</span></a></li><li><a class="tocitem" href="#Minkowski-difference"><span>Minkowski difference</span></a></li><li><a class="tocitem" href="#Subset-check"><span>Subset check</span></a></li><li><a class="tocitem" href="#Set-difference"><span>Set difference</span></a></li></ul></li><li><a class="tocitem" href="../conversion/">Conversions between set representations</a></li><li><a class="tocitem" href="../comparisons/">Comparisons</a></li><li><a class="tocitem" href="../approximations/">Approximations</a></li><li><a class="tocitem" href="../utils/">Utility Functions</a></li><li><a class="tocitem" href="../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Concrete Operations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Concrete Operations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/binary_functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Binary-Functions-on-Sets"><a class="docs-heading-anchor" href="#Binary-Functions-on-Sets">Binary Functions on Sets</a><a id="Binary-Functions-on-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-Functions-on-Sets" title="Permalink"></a></h1><p>This section of the manual describes the binary functions for set types.</p><ul><li><a href="#Binary-Functions-on-Sets">Binary Functions on Sets</a></li><ul><li><a href="#Cartesian-product">Cartesian product</a></li><li><a href="#Check-for-emptiness-of-intersection">Check for emptiness of intersection</a></li><li><a href="#Convex-hull">Convex hull</a></li><li><a href="#Intersection-of-two-sets">Intersection of two sets</a></li><li><a href="#Minkowski-sum">Minkowski sum</a></li><li><a href="#Minkowski-difference">Minkowski difference</a></li><li><a href="#Subset-check">Subset check</a></li><li><a href="#Set-difference">Set difference</a></li></ul></ul><h2 id="Cartesian-product"><a class="docs-heading-anchor" href="#Cartesian-product">Cartesian product</a><a id="Cartesian-product-1"></a><a class="docs-heading-anchor-permalink" href="#Cartesian-product" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.cartesian_product-Tuple{Union{HPolyhedron{N,VN} where VN&lt;:AbstractArray{N,1}, HPolytope{N,VN} where VN&lt;:AbstractArray{N,1}} where N,Union{HPolyhedron{N,VN} where VN&lt;:AbstractArray{N,1}, HPolytope{N,VN} where VN&lt;:AbstractArray{N,1}} where N}" href="#LazySets.cartesian_product-Tuple{Union{HPolyhedron{N,VN} where VN&lt;:AbstractArray{N,1}, HPolytope{N,VN} where VN&lt;:AbstractArray{N,1}} where N,Union{HPolyhedron{N,VN} where VN&lt;:AbstractArray{N,1}, HPolytope{N,VN} where VN&lt;:AbstractArray{N,1}} where N}"><code>LazySets.cartesian_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cartesian_product(P1::HPoly, P2::HPoly; [backend]=nothing)</code></pre><p>Compute the Cartesian product of two polyhedra in H-representaion.</p><p><strong>Input</strong></p><ul><li><code>P1</code>         – polyhedron</li><li><code>P2</code>         – another polyhedron</li><li><code>backend</code>    – (optional, default: <code>nothing</code>) the polyhedral computations backend</li></ul><p><strong>Output</strong></p><p>The polyhedron obtained by the concrete cartesian product of <code>P1</code> and <code>P2</code>.</p><p><strong>Notes</strong></p><p>For further information on the supported backends see <a href="https://juliapolyhedra.github.io/">Polyhedra&#39;s documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/cartesian_product.jl#L94-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.cartesian_product-Tuple{VPolytope,VPolytope}" href="#LazySets.cartesian_product-Tuple{VPolytope,VPolytope}"><code>LazySets.cartesian_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cartesian_product(P1::VPolytope, P2::VPolytope; [backend]=nothing)</code></pre><p>Compute the Cartesian product of two polytopes in V-representation.</p><p><strong>Input</strong></p><ul><li><code>P1</code>      – polytope</li><li><code>P2</code>      – another polytope</li><li><code>backend</code> – (optional, default: <code>nothing</code>) the polyhedral computations backend</li></ul><p><strong>Output</strong></p><p>The <code>VPolytope</code> obtained by the concrete Cartesian product of <code>P1</code> and <code>P2</code>.</p><p><strong>Notes</strong></p><p>For further information on the supported backends see <a href="https://juliapolyhedra.github.io/">Polyhedra&#39;s documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/cartesian_product.jl#L52-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.cartesian_product-Tuple{LazySet,LazySet}" href="#LazySets.cartesian_product-Tuple{LazySet,LazySet}"><code>LazySets.cartesian_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cartesian_product(X::LazySet, Y::LazySet; [backend]=nothing, [algorithm]::String=&quot;vrep&quot;)</code></pre><p>Compute the Cartesian product of two sets.</p><p><strong>Input</strong></p><ul><li><code>X</code>         – set</li><li><code>Y</code>         – another set</li><li><code>backend</code>   – (optional, default: <code>nothing</code>) the polyhedral computations backend</li><li><code>algorithm</code> – (optional, default: &quot;hrep&quot;) the method used to transform each set                <code>X</code> and <code>Y</code> before taking the Cartesian product; choose between                &quot;vrep&quot; (use the vertex representation) and &quot;hrep&quot; (use the constraint representation)</li></ul><p><strong>Output</strong></p><p>The <code>VPolytope</code> (if &quot;vrep&quot; was used) or <code>HPolytope</code> (if &quot;hrep&quot; was used) obtained by the concrete Cartesian product of <code>X</code> and <code>Y</code>.</p><p><strong>Notes</strong></p><p>For further information on the supported backends see <a href="https://juliapolyhedra.github.io/">Polyhedra&#39;s documentation</a>.</p><p>If <code>X</code> can be converted to a one-dimensional interval and the vertices of <code>Y</code> are available use <code>algorithm=&quot;vrep&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/cartesian_product.jl#L3-L29">source</a></section></article><h2 id="Check-for-emptiness-of-intersection"><a class="docs-heading-anchor" href="#Check-for-emptiness-of-intersection">Check for emptiness of intersection</a><a id="Check-for-emptiness-of-intersection-1"></a><a class="docs-heading-anchor-permalink" href="#Check-for-emptiness-of-intersection" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>isdisjoint</code> can be used as an alternative name to <code>is_intersection_empty</code>.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(X::LazySet, Y::LazySet, witness::Bool=false)</code></pre><p>Check whether two sets do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>Y</code>       – another set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ∩ Y = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ∩ Y = ∅$</span></li><li><code>(false, v)</code> iff <span>$X ∩ Y ≠ ∅$</span> and <span>$v ∈ X ∩ Y$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>This is a fallback implementation that computes the concrete intersection, <code>intersection</code>, of the given sets.</p><p>A witness is constructed using the <code>an_element</code> implementation of the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L6-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(H1::AbstractHyperrectangle,
                      H2::AbstractHyperrectangle,
                      witness::Bool=false
                     )</code></pre><p>Check whether two hyperrectangles do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>H1</code> – first hyperrectangle</li><li><code>H2</code> – second hyperrectangle</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$H1 ∩ H2 = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$H1 ∩ H2 = ∅$</span></li><li><code>(false, v)</code> iff <span>$H1 ∩ H2 ≠ ∅$</span> and <span>$v ∈ H1 ∩ H2$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$H1 ∩ H2 ≠ ∅$</span> iff <span>$|c_2 - c_1| ≤ r_1 + r_2$</span>, where <span>$≤$</span> is taken component-wise.</p><p>A witness is computed by starting in one center and moving toward the other center for as long as the minimum of the radius and the center distance. In other words, the witness is the point in <code>H1</code> that is closest to the center of <code>H2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L83-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(X::LazySet, S::AbstractSingleton, witness::Bool=false)</code></pre><p>Check whether a convex set and a singleton do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – convex set</li><li><code>S</code>       – singleton</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ∩ X = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$S ∩ X = ∅$</span></li><li><code>(false, v)</code> iff <span>$S ∩ X ≠ ∅$</span> and <code>v</code> = <code>element(S)</code> <span>$∈ S ∩ X$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ∩ X = ∅$</span> iff <code>element(S)</code> <span>$∉ X$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L211-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(H::AbstractHyperrectangle,
                      S::AbstractSingleton,
                      witness::Bool=false
                     )</code></pre><p>Check whether a hyperrectangle and a singleton do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangle</li><li><code>S</code> – singleton</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$H ∩ S = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$H ∩ S = ∅$</span></li><li><code>(false, v)</code> iff <span>$H ∩ S ≠ ∅$</span> and <code>v</code> = <code>element(S)</code> <span>$∈ H ∩ S$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$H ∩ S = ∅$</span> iff <code>element(S)</code> <span>$∉ H$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L289-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(S1::AbstractSingleton,
                      S2::AbstractSingleton,
                      witness::Bool=false
                     )</code></pre><p>Check whether two singletons do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>S1</code> – first singleton</li><li><code>S2</code> – second singleton</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S1 ∩ S2 = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$S1 ∩ S2 = ∅$</span></li><li><code>(false, v)</code> iff <span>$S1 ∩ S2 ≠ ∅$</span> and <code>v</code> = <code>element(S1)</code> <span>$∈ S1 ∩ S2$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S1 ∩ S2 = ∅$</span> iff <span>$S1 ≠ S2$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L250-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(Z::AbstractZonotope, H::Union{Hyperplane, Line2D}, witness::Bool=false)</code></pre><p>Check whether a zonotope and a hyperplane do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>Z</code>       – zonotope</li><li><code>H</code>       – hyperplane</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$Z ∩ H = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$Z ∩ H = ∅$</span></li><li><code>(false, v)</code> iff <span>$Z ∩ H ≠ ∅$</span> and <span>$v ∈ Z ∩ H$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$Z ∩ H = ∅$</span> iff <span>$(b - a⋅c) ∉ \left[ ± ∑_{i=1}^p |a⋅g_i| \right]$</span>, where <span>$a$</span>, <span>$b$</span> are the hyperplane coefficients, <span>$c$</span> is the zonotope&#39;s center, and <span>$g_i$</span> are the zonotope&#39;s generators.</p><p>For witness production we fall back to a less efficient implementation for general sets as the first argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L399-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(B1::Ball2, B2::Ball2, witness::Bool=false)</code></pre><p>Check whether two balls in the 2-norm do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>B1</code> – first ball in the 2-norm</li><li><code>B2</code> – second ball in the 2-norm</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$B1 ∩ B2 = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$B1 ∩ B2 = ∅$</span></li><li><code>(false, v)</code> iff <span>$B1 ∩ B2 ≠ ∅$</span> and <span>$v ∈ B1 ∩ B2$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$B1 ∩ B2 = ∅$</span> iff <span>$‖ c_2 - c_1 ‖_2 &gt; r_1 + r_2$</span>.</p><p>A witness is computed depending on the smaller/bigger ball (to break ties, choose <code>B1</code> for the smaller ball) as follows.</p><ul><li>If the smaller ball&#39;s center is contained in the bigger ball, we return it.</li><li>Otherwise start in the smaller ball&#39;s center and move toward the other center until hitting the smaller ball&#39;s border. In other words, the witness is the point in the smaller ball that is closest to the center of the bigger ball.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L334-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(ls1::LineSegment,
                      ls2::LineSegment,
                      witness::Bool=false
                     )</code></pre><p>Check whether two line segments do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>ls1</code> – first line segment</li><li><code>ls2</code> – second line segment</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$ls1 ∩ ls2 = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$ls1 ∩ ls2 = ∅$</span></li><li><code>(false, v)</code> iff <span>$ls1 ∩ ls2 ≠ ∅$</span> and <span>$v ∈ ls1 ∩ ls2$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>The algorithm is inspired from <a href="https://stackoverflow.com/a/565282">here</a>, which again is the special 2D case of a 3D algorithm by Ronald Goldman&#39;s article on the <em>Intersection of two lines in three-space</em> in Graphics Gems, Andrew S. (ed.), 1990.</p><p>We first check if the two line segments are parallel, and if so, if they are collinear. In the latter case, we check containment of any of the end points in the other line segment. Otherwise the lines are not parallel, so we can solve an equation of the intersection point, if it exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L510-L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(X::LazySet,
                      hp::Union{Hyperplane, Line2D},
                      [witness]::Bool=false
                     )</code></pre><p>Check whether a compact set an a hyperplane do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – compact set</li><li><code>hp</code>      – hyperplane</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ∩ hp = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ∩ hp = ∅$</span></li><li><code>(false, v)</code> iff <span>$X ∩ hp ≠ ∅$</span> and <span>$v ∈ X ∩ hp$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>We assume that <code>X</code> is compact. Otherwise, the support vector queries may fail.</p><p><strong>Algorithm</strong></p><p>A compact convex set intersects with a hyperplane iff the support function in the negative resp. positive direction of the hyperplane&#39;s normal vector <span>$a$</span> is to the left resp. right of the hyperplane&#39;s constraint <span>$b$</span>:</p><p class="math-container">\[-ρ(-a) ≤ b ≤ ρ(a)\]</p><p>For witness generation, we compute a line connecting the support vectors to the left and right, and then take the intersection of the line with the hyperplane. We follow <a href="https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form">this algorithm</a> for the line-hyperplane intersection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L655-L697">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(X::LazySet, hs::HalfSpace, [witness]::Bool=false)</code></pre><p>Check whether a compact set an a half-space do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – compact set</li><li><code>hs</code>      – half-space</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ∩ hs = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ∩ hs = ∅$</span></li><li><code>(false, v)</code> iff <span>$X ∩ hs ≠ ∅$</span> and <span>$v ∈ X ∩ hs$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>We assume that <code>X</code> is compact. Otherwise, the support vector queries may fail.</p><p><strong>Algorithm</strong></p><p>A compact convex set intersects with a half-space iff the support vector in the negative direction of the half-space&#39;s normal vector <span>$a$</span> is contained in the half-space: <span>$σ(-a) ∈ hs$</span>. The support vector is thus also a witness.</p><p>Optional keyword arguments can be passed to the <code>ρ</code> function. In particular, if <code>X</code> is a lazy intersection, options can be passed to the line search algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L778-L811">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(hs1::HalfSpace, hs2::HalfSpace, [witness]::Bool=false)</code></pre><p>Check whether two half-spaces do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>hs1</code>     – half-space</li><li><code>hs2</code>     – half-space</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$hs1 ∩ hs2 = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$hs1 ∩ hs2 = ∅$</span></li><li><code>(false, v)</code> iff <span>$hs1 ∩ hs2 ≠ ∅$</span> and <span>$v ∈ hs1 ∩ hs2$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Two half-spaces do not intersect if and only if their normal vectors point in the opposite direction and there is a gap between the two defining hyperplanes.</p><p>The latter can be checked as follows: Let <span>$hs_1 : a_1⋅x = b_1$</span> and <span>$hs2 : a_2⋅x = b_2$</span>. Then we already know that <span>$a_2 = -k⋅a_1$</span> for some positive scaling factor <span>$k$</span>. Let <span>$x_1$</span> be a point on the defining hyperplane of <span>$hs_1$</span>. We construct a line segment from <span>$x_1$</span> to the point <span>$x_2$</span> on the defining hyperplane of <span>$hs_2$</span> by shooting a ray from <span>$x_1$</span> with direction <span>$a_1$</span>. Thus we look for a factor <span>$s$</span> such that <span>$(x_1 + s⋅a_1)⋅a_2 = b_2$</span>. This gives us <span>$s = (b_2 - x_1⋅a_2) / (-k a_1⋅a_1)$</span>. The gap exists if and only if <span>$s$</span> is positive.</p><p>If the normal vectors do not point in opposite directions, then the defining hyperplanes intersect and we can produce a witness as follows. All points <span>$x$</span> in this intersection satisfy <span>$a_1⋅x = b_1$</span> and <span>$a_2⋅x = b_2$</span>. Thus we have <span>$(a_1 + a_2)⋅x = b_1+b_2$</span>. We now find a dimension where <span>$a_1 + a_2$</span> is non-zero, say, <span>$i$</span>. Then the result is a vector with one non-zero entry in dimension <span>$i$</span>, defined as <span>$[0, …, 0, (b_1 + b_2)/(a_1[i] + a_2[i]), 0, …, 0]$</span>. Such a dimension <span>$i$</span> always exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L821-L864">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(P::AbstractPolyhedron,
                      X::LazySet,
                      witness::Bool=false;
                      solver=nothing
                     )</code></pre><p>Check whether two polyhedra do not intersect.</p><p><strong>Input</strong></p><ul><li><code>P</code>         – polyhedron</li><li><code>X</code>         – another set (see the Notes section below)</li><li><code>witness</code>   – (optional, default: <code>false</code>) compute a witness if activated</li><li><code>solver</code>    – (optional, default: <code>nothing</code>) the backend used to solve the                linear program</li><li><code>algorithm</code> – (optional, default: <code>&quot;exact&quot;</code>) algorithm keyword, one of:                * <code>&quot;exact&quot; (exact, uses a feasibility LP)                *</code>&quot;sufficient&quot; (sufficient, uses half-space checks)</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ∩ X = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$P ∩ X = ∅$</span></li><li><code>(false, v)</code> iff <span>$P ∩ X ≠ ∅$</span> and <span>$v ∈ P ∩ X$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>For <code>algorithm == &quot;exact&quot;</code>, we assume that <code>constraints_list(X)</code> is defined. For <code>algorithm == &quot;sufficient&quot;</code>, witness production is not supported.</p><p>For <code>solver == nothing</code> we fall back to <code>default_lp_solver(N)</code>.</p><p><strong>Algorithm</strong></p><p>For <code>algorithm == &quot;exact&quot;</code>, see <a href="../interfaces/#Base.isempty-Tuple{AbstractCentrallySymmetric}"><code>isempty(P::HPoly, ::Bool)</code></a>.</p><p>For <code>algorithm == &quot;sufficient&quot;</code>, we rely on the intersection check between the set <code>X</code> and each constraint in <code>P</code>. This means one support function evaluation of <code>X</code> for each constraint of <code>P</code>. With the sufficiency algorithm, this function may return <code>false</code> even in the case where the intersection is empty. On the other hand, if the algorithm returns <code>true</code>, then it is guaranteed that the intersection is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L943-L987">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(cup::UnionSet, X::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a union of two convex sets and another set do not intersect.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of two convex sets</li><li><code>X</code>   – another set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$\text{cup} ∩ X = ∅$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L1105-L1118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(cup::UnionSetArray, X::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a union of a finite number of convex sets and another set do not intersect.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li><li><code>X</code>   – another set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$\text{cup} ∩ X = ∅$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L1135-L1149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(U::Universe, X::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a universe and another set do not intersect.</p><p><strong>Input</strong></p><ul><li><code>U</code> – universe</li><li><code>X</code> – another set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$X ≠ ∅$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L1212-L1225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(C::Complement, X::LazySet, [witness]::Bool=false)</code></pre><p>Check whether the complement of a convex set and another set do not intersect.</p><p><strong>Input</strong></p><ul><li><code>C</code> – complement of a convex set</li><li><code>X</code> – convex set</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ∩ C = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ∩ C = ∅$</span></li><li><code>(false, v)</code> iff <span>$X ∩ C ≠ ∅$</span> and <span>$v ∈ X ∩ C$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>We fall back to <code>X ⊆ C.X</code>, which can be justified as follows:</p><p class="math-container">\[    X ∩ Y^C = ∅ ⟺ X ⊆ Y\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L1302-L1326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(Z1::AbstractZonotope, Z2::AbstractZonotope,
                      witness::Bool=false)</code></pre><p>Check whether two zonotopes do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>Z1</code>      – zonotope</li><li><code>Z2</code>      – zonotope</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$Z1 ∩ Z2 = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$Z1 ∩ Z2 = ∅$</span></li><li><code>(false, v)</code> iff <span>$Z1 ∩ Z2 ≠ ∅$</span> and <span>$v ∈ Z1 ∩ Z2$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$Z1 ∩ Z2 = ∅$</span> iff <span>$c_1 - c_2 ∉ Z(0, (g_1, g_2))$</span> where <span>$c_i$</span> and <span>$g_i$</span> are the center and generators of zonotope <code>Zi</code> and <span>$Z(c, g)$</span> represents the zonotope with center <span>$c$</span> and generators <span>$g$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L453-L478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(I1::Interval, I2::Interval, witness::Bool=false)</code></pre><p>Check whether two intervals do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>I1</code>      – first interval</li><li><code>I2</code>      – second interval</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$I1 ∩ I2 = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$I1 ∩ I2 = ∅$</span></li><li><code>(false, v)</code> iff <span>$I1 ∩ I2 ≠ ∅$</span> and <span>$v ∈ I1 ∩ I2$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$I1 ∩ I2 ≠ ∅$</span> iff there is a gap between the left-most point of the second interval and the left-most point of the first interval, or vice-versa.</p><p>A witness is computed by taking the maximum over the left-most points of each interval, which is guaranteed to belong to the intersection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L153-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty-Tuple{CartesianProductArray,AbstractPolyhedron}" href="#LazySets.is_intersection_empty-Tuple{CartesianProductArray,AbstractPolyhedron}"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_intersection_empty(cpa::CartesianProductArray, P::AbstractPolyhedron)</code></pre><p>Check whether a polytopic Cartesian product array intersects with a polyhedron.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array of polytopes</li><li><code>P</code>   – polyhedron</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$\text{cpa} ∩ Y = ∅$</span>.</p><p><strong>Algorithm</strong></p><p>We first identify the blocks of <code>cpa</code> in which <code>P</code> is constrained. Then we project <code>cpa</code> to those blocks and convert the result to an <code>HPolytope</code> <code>Q</code>. Finally we determine whether <code>Q</code> and the projected <code>P</code> intersect.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L1336-L1356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty-Tuple{CartesianProductArray,CartesianProductArray}" href="#LazySets.is_intersection_empty-Tuple{CartesianProductArray,CartesianProductArray}"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_intersection_empty(X::CartesianProductArray, Y::CartesianProductArray)</code></pre><p>Check whether two Cartesian products of a finite number of convex sets do not intersect.</p><p><strong>Input</strong></p><ul><li><code>X</code> – Cartesian product array of convex sets</li><li><code>Y</code> – Cartesian product array of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$X ∩ Y = ∅$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L1387-L1401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(cpa::CartesianProductArray,
                      H::AbstractHyperrectangle,
                      [witness]::Bool=false)</code></pre><p>Check whether a Cartesian product of a finite number of convex sets and a hyperrectangular set do not intersect, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>cpa</code>     – Cartesian product of a finite number of convex sets</li><li><code>H</code>       – hyperrectangular set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$cpa ∩ H = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$cpa ∩ H = ∅$</span></li><li><code>(false, v)</code> iff <span>$cpa ∩ H ≠ ∅$</span> and <span>$v ∈ cpa ∩ H$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>The sets <code>cpa</code> and <code>H</code> are disjoint if and only if at least one block of <code>cpa</code> and the corresponding projection of <code>H</code> are disjoint. We perform these checks sequentially.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L1415-L1442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.is_intersection_empty" href="#LazySets.is_intersection_empty"><code>LazySets.is_intersection_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_intersection_empty(L1::Line2D, L2::Line2D, witness::Bool=false)</code></pre><p>Check whether two two-dimensional lines do not intersect.</p><p><strong>Input</strong></p><ul><li><code>L1</code> – line</li><li><code>L2</code> – line</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$L1 ∩ L2 = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$L1 ∩ L2 = ∅$</span></li><li><code>(false, v)</code> iff <span>$L1 ∩ L2 ≠ ∅$</span> and <span>$v ∈ L1 ∩ L2$</span></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/isdisjoint.jl#L1542-L1558">source</a></section></article><h2 id="Convex-hull"><a class="docs-heading-anchor" href="#Convex-hull">Convex hull</a><a id="Convex-hull-1"></a><a class="docs-heading-anchor-permalink" href="#Convex-hull" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.convex_hull-Union{Tuple{N}, Tuple{LazySet{N},LazySet{N}}} where N&lt;:Real" href="#LazySets.convex_hull-Union{Tuple{N}, Tuple{LazySet{N},LazySet{N}}} where N&lt;:Real"><code>LazySets.convex_hull</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convex_hull(X::LazySet{N}, Y::LazySet{N}; [algorithm]=nothing,
            [backend]=nothing, [solver]=nothing) where {N&lt;:Real}</code></pre><p>Compute the convex hull of the given convex sets.</p><p><strong>Input</strong></p><ul><li><code>X</code>         – convex set</li><li><code>Y</code>         – convex set</li><li><code>algorithm</code> – (optional, default: <code>nothing</code>) the convex-hull algorithm</li><li><code>backend</code>   – (optional, default: <code>nothing</code>) backend for polyhedral                computations (used for higher-dimensional sets)</li><li><code>solver</code>    – (optional, default: <code>nothing</code>) the linear-programming solver                used in the backend</li></ul><p><strong>Output</strong></p><p>If the input sets are one-dimensional, the result is an <code>Interval</code>. If the input sets are two-dimensional, the result is a <code>VPolygon</code>. Otherwise the result is a <code>VPolytope</code>.</p><p><strong>Algorithm</strong></p><p>One-dimensional sets are resolved by using <code>overapproximate</code> with an <code>Interval</code> (which is exact). For higher-dimensional sets, we compute the vertices of both <code>X</code> and <code>Y</code> using <code>vertices_list</code> and then compute the convex hull of the union of those vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/convex_hull.jl#L11-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.convex_hull-Tuple{Union{HPolyhedron{N,VN} where VN&lt;:AbstractArray{N,1}, HPolytope{N,VN} where VN&lt;:AbstractArray{N,1}} where N,Union{HPolyhedron{N,VN} where VN&lt;:AbstractArray{N,1}, HPolytope{N,VN} where VN&lt;:AbstractArray{N,1}} where N}" href="#LazySets.convex_hull-Tuple{Union{HPolyhedron{N,VN} where VN&lt;:AbstractArray{N,1}, HPolytope{N,VN} where VN&lt;:AbstractArray{N,1}} where N,Union{HPolyhedron{N,VN} where VN&lt;:AbstractArray{N,1}, HPolytope{N,VN} where VN&lt;:AbstractArray{N,1}} where N}"><code>LazySets.convex_hull</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convex_hull(P1::HPoly, P2::HPoly;
           [backend]=default_polyhedra_backend(P1))</code></pre><p>Compute the convex hull of the set union of two polyhedra in H-representation.</p><p><strong>Input</strong></p><ul><li><code>P1</code>         – polyhedron</li><li><code>P2</code>         – another polyhedron</li><li><code>backend</code>    – (optional, default: <code>default_polyhedra_backend(P1)</code>)                 the polyhedral computations backend</li></ul><p><strong>Output</strong></p><p>The <code>HPolyhedron</code> (resp. <code>HPolytope</code>) obtained by the concrete convex hull of <code>P1</code> and <code>P2</code>.</p><p><strong>Notes</strong></p><p>For performance reasons, it is suggested to use the <code>CDDLib.Library()</code> backend for the <code>convex_hull</code>.</p><p>For further information on the supported backends see <a href="https://juliapolyhedra.github.io/">Polyhedra&#39;s documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/convex_hull.jl#L562-L587">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.convex_hull-Tuple{VPolytope,VPolytope}" href="#LazySets.convex_hull-Tuple{VPolytope,VPolytope}"><code>LazySets.convex_hull</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convex_hull(P1::VPolytope, P2::VPolytope; [backend]=nothing)</code></pre><p>Compute the convex hull of the set union of two polytopes in V-representation.</p><p><strong>Input</strong></p><ul><li><code>P1</code>         – polytope</li><li><code>P2</code>         – another polytope</li><li><code>backend</code>    – (optional, default: <code>nothing</code>) the polyhedral                 computations backend</li></ul><p><strong>Output</strong></p><p>The <code>VPolytope</code> obtained by the concrete convex hull of <code>P1</code> and <code>P2</code>.</p><p><strong>Notes</strong></p><p>This function takes the union of the vertices of each polytope and then relies on a concrete convex hull algorithm. For low dimensions, a specialized implementation for polygons is used. For higher dimensions, <code>convex_hull</code> relies on the polyhedral backend that can be specified using the <code>backend</code> keyword argument.</p><p>For performance reasons, it is suggested to use the <code>CDDLib.Library()</code> backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/convex_hull.jl#L530-L555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.convex_hull-Tuple{VPolygon,VPolygon}" href="#LazySets.convex_hull-Tuple{VPolygon,VPolygon}"><code>LazySets.convex_hull</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convex_hull(P::VPolygon, Q::VPolygon; [algorithm]::String=&quot;monotone_chain&quot;)</code></pre><p>Return the convex hull of two polygons in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>         – polygon in vertex representation</li><li><code>Q</code>         – another polygon in vertex representation</li><li><code>algorithm</code> – (optional, default: &quot;monotone_chain&quot;) the algorithm used to                compute the convex hull</li></ul><p><strong>Output</strong></p><p>A new polygon such that its vertices are the convex hull of the given two polygons.</p><p><strong>Algorithm</strong></p><p>A convex hull algorithm is used to compute the convex hull of the vertices of the given input polygons <code>P</code> and <code>Q</code>; see <code>?convex_hull</code> for details on the available algorithms. The vertices of the output polygon are sorted in counter-clockwise fashion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/convex_hull.jl#L500-L522">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.convex_hull-Union{Tuple{Array{VN,1}}, Tuple{VN}, Tuple{N}} where VN&lt;:AbstractArray{N,1} where N&lt;:Real" href="#LazySets.convex_hull-Union{Tuple{Array{VN,1}}, Tuple{VN}, Tuple{N}} where VN&lt;:AbstractArray{N,1} where N&lt;:Real"><code>LazySets.convex_hull</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convex_hull(points::Vector{VN};
            [algorithm]=nothing,
            [backend]=nothing,
            [solver]=nothing
            ) where {N&lt;:Real, VN&lt;:AbstractVector{N}}</code></pre><p>Compute the convex hull of the given points.</p><p><strong>Input</strong></p><ul><li><code>points</code>    – list of vectors</li><li><code>algorithm</code> – (optional, default: <code>nothing</code>) the convex-hull algorithm; see                below for valid options</li><li><code>backend</code>   – (optional, default: <code>nothing</code>) polyhedral computation backend                for higher-dimensional point sets</li><li><code>solver</code>    – (optional, default: <code>nothing</code>) the linear-programming solver                used in the backend</li></ul><p><strong>Output</strong></p><p>The convex hull as a list of vectors with the coordinates of the points.</p><p><strong>Algorithm</strong></p><p>A pre-processing step treats the cases with up to two points for one dimension and up to four points for two dimensions. For more points in one resp. two dimensions, we use more general algorithms.</p><p>For the one-dimensional case we return the minimum and maximum points, in that order.</p><p>The two-dimensional case is handled with a planar convex hull algorithm. The following algorithms are available:</p><ul><li><code>&quot;monotone_chain&quot;</code>        – compute the convex hull of points in the plane                              using Andrew&#39;s monotone chain method</li><li><code>&quot;monotone_chain_sorted&quot;</code> – the same as <code>&quot;monotone_chain&quot;</code> but assuming that                              the points are already sorted in counter-clockwise                              fashion</li></ul><p>See the reference docstring of each of those algorithms for details.</p><p>The higher dimensional case is treated using the concrete polyhedra library <code>Polyhedra</code>, that gives access to libraries such as <code>CDDLib</code> and <code>ConvexHull.jl</code>. These libraries can be chosen from the <code>backend</code> argument.</p><p><strong>Notes</strong></p><p>For the in-place version use <code>convex_hull!</code> instead of <code>convex_hull</code>.</p><p><strong>Examples</strong></p><p>Compute the convex hull of a random set of points:</p><pre><code class="language-julia-repl">julia&gt; points = [randn(2) for i in 1:30]; # 30 random points in 2D

julia&gt; hull = convex_hull(points);

julia&gt; typeof(hull)
Array{Array{Float64,1},1}</code></pre><p>Plot both the random points and the computed convex hull polygon:</p><pre><code class="language-julia-repl">julia&gt; using Plots;

julia&gt; plot([Tuple(pi) for pi in points], seriestype=:scatter);

julia&gt; plot!(VPolygon(hull), alpha=0.2);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/convex_hull.jl#L72-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.convex_hull-Union{Tuple{UnionSetArray{N,PT}}, Tuple{PT}, Tuple{N}} where PT&lt;:AbstractPolytope{N} where N" href="#LazySets.convex_hull-Union{Tuple{UnionSetArray{N,PT}}, Tuple{PT}, Tuple{N}} where PT&lt;:AbstractPolytope{N} where N"><code>LazySets.convex_hull</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convex_hull(U::UnionSetArray{N, PT}; kwargs...) where {N, PT&lt;:AbstractPolytope{N}}</code></pre><p>Compute the convex hull of a union of a finite number of polytopes.</p><p><strong>Input</strong></p><ul><li><code>U</code> – UnionSetArray of polytopes</li></ul><p><strong>Output</strong></p><p>A list of the vertices of the convex hull.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/convex_hull.jl#L482-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.monotone_chain!" href="#LazySets.monotone_chain!"><code>LazySets.monotone_chain!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">monotone_chain!(points::Vector{VN}; sort::Bool=true
               ) where {N&lt;:Real, VN&lt;:AbstractVector{N}}</code></pre><p>Compute the convex hull of points in the plane using Andrew&#39;s monotone chain method.</p><p><strong>Input</strong></p><ul><li><code>points</code> – list of 2D vectors; is sorted in-place inside this function</li><li><code>sort</code>   – (optional, default: <code>true</code>) flag for sorting the vertices             lexicographically; sortedness is required for correctness</li></ul><p><strong>Output</strong></p><p>List of vectors containing the 2D coordinates of the corner points of the convex hull.</p><p><strong>Notes</strong></p><p>For large sets of points, it is convenient to use static vectors to get maximum performance. For information on how to convert usual vectors into static vectors, see the type <code>SVector</code> provided by the <a href="http://juliaarrays.github.io/StaticArrays.jl/stable/">StaticArrays</a> package.</p><p><strong>Algorithm</strong></p><p>This function implements Andrew&#39;s monotone chain convex hull algorithm to construct the convex hull of a set of <span>$n$</span> points in the plane in <span>$O(n \log n)$</span> time. For further details see <a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain">Monotone chain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/convex_hull.jl#L408-L441">source</a></section></article><h2 id="Intersection-of-two-sets"><a class="docs-heading-anchor" href="#Intersection-of-two-sets">Intersection of two sets</a><a id="Intersection-of-two-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Intersection-of-two-sets" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Tuple{AbstractSingleton,LazySet}" href="#LazySets.intersection-Tuple{AbstractSingleton,LazySet}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(S::AbstractSingleton, X::LazySet)</code></pre><p>Return the intersection of a singleton with another set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – singleton</li><li><code>X</code> – another set</li></ul><p><strong>Output</strong></p><p>If the sets intersect, the result is <code>S</code>. Otherwise, the result is the empty set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L29-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Tuple{Line2D,Line2D}" href="#LazySets.intersection-Tuple{Line2D,Line2D}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(L1::Line2D, L2::Line2D)</code></pre><p>Return the intersection of two two-dimensional lines.</p><p><strong>Input</strong></p><ul><li><code>L1</code> – first line</li><li><code>L2</code> – second line</li></ul><p><strong>Output</strong></p><p>Three outcomes are possible:</p><ul><li>If the lines are identical, the result is the first line.</li><li>If the lines are parallel and not identical, the result is the empty set.</li><li>Otherwise the result is the only intersection point.</li></ul><p><strong>Algorithm</strong></p><p>We first check whether the lines are parallel. If not, we use <a href="https://en.wikipedia.org/wiki/Cramer%27s_rule">Cramer&#39;s rule</a> to compute the intersection point.</p><p><strong>Examples</strong></p><p>The line <span>$y = -x + 1$</span> intersected with the line <span>$y = x$</span>:</p><pre><code class="language-julia-repl">julia&gt; intersection(Line2D([-1., 1.], 0.), Line2D([1., 1.], 1.))
Singleton{Float64,Array{Float64,1}}([0.5, 0.5])

julia&gt; intersection(Line2D([1., 1.], 1.), Line2D([1., 1.], 1.))
Line2D{Float64,Array{Float64,1}}([1.0, 1.0], 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L62-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Tuple{AbstractHyperrectangle,AbstractHyperrectangle}" href="#LazySets.intersection-Tuple{AbstractHyperrectangle,AbstractHyperrectangle}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(H1::AbstractHyperrectangle, H2::AbstractHyperrectangle)</code></pre><p>Return the intersection of two hyperrectangles.</p><p><strong>Input</strong></p><ul><li><code>H1</code> – first hyperrectangle</li><li><code>H2</code> – second hyperrectangle</li></ul><p><strong>Output</strong></p><p>If the hyperrectangles do not intersect, the result is the empty set. Otherwise the result is the hyperrectangle that describes the intersection.</p><p><strong>Algorithm</strong></p><p>In each isolated direction <code>i</code> we compute the rightmost left border and the leftmost right border of the hyperrectangles. If these borders contradict, then the intersection is empty. Otherwise the result uses these borders in each dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L214-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Tuple{Interval,Interval}" href="#LazySets.intersection-Tuple{Interval,Interval}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(x::Interval, y::Interval)</code></pre><p>Return the intersection of two intervals.</p><p><strong>Input</strong></p><ul><li><code>x</code> – first interval</li><li><code>y</code> – second interval</li></ul><p><strong>Output</strong></p><p>If the intervals do not intersect, the result is the empty set. Otherwise the result is the interval that describes the intersection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L255-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Tuple{Interval,HalfSpace}" href="#LazySets.intersection-Tuple{Interval,HalfSpace}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(X::Interval, hs::HalfSpace)</code></pre><p>Compute the intersection of an interval and a half-space.</p><p><strong>Input</strong></p><ul><li><code>X</code>  – interval</li><li><code>hs</code> – half-space</li></ul><p><strong>Output</strong></p><p>If the sets do not intersect, the result is the empty set. If the interval is fully contained in the half-space, the result is the original interval. Otherwise the result is the interval that describes the intersection.</p><p><strong>Algorithm</strong></p><p>We first handle the special case that the normal vector <code>a</code> of <code>hs</code> is close to zero. Then we distinguish the cases that <code>hs</code> is a lower or an upper bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L279-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Tuple{Interval,Hyperplane}" href="#LazySets.intersection-Tuple{Interval,Hyperplane}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(X::Interval, hp::Hyperplane)</code></pre><p>Compute the intersection of an interval and a hyperplane.</p><p><strong>Input</strong></p><ul><li><code>X</code>  – interval</li><li><code>hp</code> – hyperplane</li></ul><p><strong>Output</strong></p><p>If the sets do not intersect, the result is the empty set. Otherwise the result is the singleton that describes the intersection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L365-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Tuple{Interval,LazySet}" href="#LazySets.intersection-Tuple{Interval,LazySet}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(X::Interval, Y::LazySet)</code></pre><p>Compute the intersection of an interval and a convex set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – interval</li><li><code>Y</code> – convex set</li></ul><p><strong>Output</strong></p><p>If the sets do not intersect, the result is the empty set. Otherwise the result is the interval that describes the intersection, which may be of type <code>Singleton</code> if the intersection is very small.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L397-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection" href="#LazySets.intersection"><code>LazySets.intersection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">intersection(P1::AbstractHPolygon, P2::AbstractHPolygon, [prune]::Bool=true)</code></pre><p>Return the intersection of two polygons in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P1</code>    – first polygon</li><li><code>P2</code>    – second polygon</li><li><code>prune</code> – (optional, default: <code>true</code>) flag for removing redundant constraints</li></ul><p><strong>Output</strong></p><p>If the polygons do not intersect, the result is the empty set. Otherwise the result is the polygon that describes the intersection.</p><p><strong>Algorithm</strong></p><p>We just combine the constraints of both polygons. To obtain a linear-time algorithm, we interleave the constraints. If there are two constraints with the same normal vector, we choose the tighter one.</p><p>Redundancy of constraints is checked with <a href="../interfaces/#LazySets.remove_redundant_constraints!-Tuple{AbstractHPolygon}"><code>remove_redundant_constraints!(::AbstractHPolygon)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L469-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Union{Tuple{N}, Tuple{AbstractPolyhedron{N},AbstractPolyhedron{N}}} where N" href="#LazySets.intersection-Union{Tuple{N}, Tuple{AbstractPolyhedron{N},AbstractPolyhedron{N}}} where N"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(P1::AbstractPolyhedron{N},
             P2::AbstractPolyhedron{N};
             [backend]=default_lp_solver(N)) where {N}</code></pre><p>Compute the intersection of two polyhedra.</p><p><strong>Input</strong></p><ul><li><code>P1</code>      – polyhedron</li><li><code>P2</code>      – polyhedron</li><li><code>backend</code> – (optional, default: <code>default_lp_solver(N)</code>) the LP solver used              for the removal of redundant constraints; see the <code>Notes</code> section              below for details</li></ul><p><strong>Output</strong></p><p>An <code>HPolyhedron</code> resulting from the intersection of <code>P1</code> and <code>P2</code>, with the redundant constraints removed, or an empty set if the intersection is empty. If one of the arguments is a polytope, the result is an <code>HPolytope</code> instead.</p><p><strong>Notes</strong></p><p>The default value of the solver backend is <code>default_lp_solver(N)</code> and it is used to run a feasiblity LP to remove the redundant constraints of the intersection.</p><p>If you want to use the <code>Polyhedra</code> library, pass an appropriate backend. For example, to use the default Polyhedra library use <code>default_polyhedra_backend(P)</code> or use <code>CDDLib.Library()</code> for the CDD library.</p><p>There are some shortcomings of the removal of constraints using the default Polyhedra library; see e.g. #1038 and Polyhedra#146. It is safer to check for emptiness of intersection before calling this function in those cases.</p><p><strong>Algorithm</strong></p><p>This implementation unifies the constraints of the two sets obtained from the <code>constraints_list</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L591-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Tuple{Union{VPolygon, VPolytope},Union{VPolygon, VPolytope}}" href="#LazySets.intersection-Tuple{Union{VPolygon, VPolytope},Union{VPolygon, VPolytope}}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(P1::Union{VPolygon, VPolytope}, P2::Union{VPolygon, VPolytope};
             [backend]=nothing,
             [prunefunc]=removevredundancy!)</code></pre><p>Compute the intersection of two polytopes in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>P1</code>        – polytope in vertex representation</li><li><code>P2</code>        – polytope in vertex representation</li><li><code>backend</code>   – (optional, default: <code>nothing</code>) the backend for polyhedral                computations</li><li><code>prunefunc</code> – (optional, default: <code>removevredundancy!</code>) function to prune                the vertices of the result</li></ul><p><strong>Output</strong></p><p>A <code>VPolytope</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L678-L697">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Tuple{VPolygon,VPolygon}" href="#LazySets.intersection-Tuple{VPolygon,VPolygon}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(P1::VPolygon, P2::VPolygon; apply_convex_hull::Bool=true)</code></pre><p>Compute the intersection of two polygons in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>P1</code> – polygon in vertex representation</li><li><code>P2</code> – polygon in vertex representation</li><li><code>apply_convex_hull</code> – (default, optional: <code>true</code>) use the flag to skip the                        computation of the convex hull in the resulting <code>VPolygon</code></li></ul><p><strong>Output</strong></p><p>A <code>VPolygon</code> or an <code>EmptySet</code> if the intersection is empty.</p><p><strong>Algorithm</strong></p><p>This function applies the <a href="https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm">Sutherland–Hodgman polygon clipping algorithm</a>. The implementation is based on the one found in <a href="http://www.rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping#Julia">rosetta code</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L734-L756">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Tuple{UnionSet,LazySet}" href="#LazySets.intersection-Tuple{UnionSet,LazySet}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(cup::UnionSet, X::LazySet)</code></pre><p>Return the intersection of a union of two convex sets and another convex set.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of two convex sets</li><li><code>X</code>   – convex set</li></ul><p><strong>Output</strong></p><p>The union of the pairwise intersections, expressed as a <code>UnionSet</code>. If one of those sets is empty, only the other set is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L770-L784">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Tuple{UnionSetArray,LazySet}" href="#LazySets.intersection-Tuple{UnionSetArray,LazySet}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(cup::UnionSetArray, X::LazySet)</code></pre><p>Return the intersection of a union of a finite number of convex sets and another convex set.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li><li><code>X</code>   – convex set</li></ul><p><strong>Output</strong></p><p>The union of the pairwise intersections, expressed as a <code>UnionSetArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L798-L812">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Tuple{Universe,LazySet}" href="#LazySets.intersection-Tuple{Universe,LazySet}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(U::Universe, X::LazySet)</code></pre><p>Return the intersection of a universe and a convex set.</p><p><strong>Input</strong></p><ul><li><code>U</code> – universe</li><li><code>X</code> – convex set</li></ul><p><strong>Output</strong></p><p>The set <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L850-L863">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Tuple{AbstractPolyhedron,ResetMap}" href="#LazySets.intersection-Tuple{AbstractPolyhedron,ResetMap}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(P::AbstractPolyhedron, rm::ResetMap)</code></pre><p>Return the intersection of a polyhedron and a polyhedral reset map.</p><p><strong>Input</strong></p><ul><li><code>P</code>  – polyhedron</li><li><code>rm</code> – polyhedral reset map</li></ul><p><strong>Output</strong></p><p>A polyhedron.</p><p><strong>Notes</strong></p><p>We assume that <code>rm</code> is polyhedral, i.e., has a <code>constraints_list</code> method defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L880-L898">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Tuple{CartesianProductArray,CartesianProductArray}" href="#LazySets.intersection-Tuple{CartesianProductArray,CartesianProductArray}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    intersection(X::CartesianProductArray, Y::CartesianProductArray)</code></pre><p>Return the intersection between cartesian products of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – cartesian product of a finite number of convex sets</li><li><code>Y</code> – cartesian product of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The decomposed set which represents concrete intersection between <code>X</code> and <code>Y</code></p><p><strong>Algorithm</strong></p><p>This algorithm intersect corresponding blocks between sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L923-L940">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Tuple{LinearMap,LazySet}" href="#LazySets.intersection-Tuple{LinearMap,LazySet}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(L::LinearMap, S::LazySet)</code></pre><p>Return the intersection of a lazy linear map and a convex set.</p><p><strong>Input</strong></p><ul><li><code>L</code> – linear map</li><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>The polytope obtained by the intersection of <code>l.M * L.X</code> and <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L824-L837">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Tuple{CartesianProductArray,AbstractPolyhedron}" href="#LazySets.intersection-Tuple{CartesianProductArray,AbstractPolyhedron}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(cpa::CartesianProductArray, P::AbstractPolyhedron)</code></pre><p>Compute the intersection of a Cartesian product of a finite number of polyhedral sets with a polyhedron.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product of a finite number of polyhedral sets</li><li><code>P</code>   – polyhedron</li></ul><p><strong>Output</strong></p><p>A Cartesian product of a finite number of polyhedral sets. See the <em>Algorithm</em> section below for details about the structure.</p><p><strong>Notes</strong></p><p>The restriction to polyhedral sets in <code>cpa</code> only applies to the blocks that are actually intersected with <code>P</code> (see the <em>Algorithm</em> section below for details). All other blocks are not considered by the intersection and remain identical.</p><p><strong>Algorithm</strong></p><p>The underlying idea of the algorithm is to exploit the unconstrained dimensions of <code>P</code>. Without loss of generality, assume that <code>cpa</code> has the structure <span>$X × Y × Z$</span> such that only the dimensions of <span>$Y$</span> are constrained in <span>$P$</span>, and denoting a suitable projection of <span>$P$</span> to the dimensions of <span>$Y$</span> with <span>$P|_Y$</span>, we have the following equivalence:</p><p class="math-container">\[    (X × Y × Z) ∩ P = X × (Y ∩ P|_Y) × Z\]</p><p>Note that <span>$Y$</span> may still consist of many blocks. However, due to the structural restriction of a Cartesian product, we cannot break down this set further even if <span>$P|_Y$</span> is still unconstrained in some dimensions of blocks in <span>$Y$</span>. This would require a restructuring of the dimensions. Consider this example:</p><p class="math-container">\[    Y := [0, 1] × [1, 2] × [2, 3]
    P|_Y := x₁ + x₃ ≤ 2
    Y ∩ P|_Y = 0 ≤ x₁ ∧ 1 ≤ x₂ ≤ 2 ∧ 2 ≤ x₃ ∧ x₁ + x₃ ≤ 2\]</p><p>Even though the constraints of dimension <span>$x₂$</span> are decoupled from the rest, due to the last constraint the Cartesian product cannot be broken down further. In particular, the result <span>$Y ∩ P|_Y$</span> is a polyhedron in this implementation.</p><p>Now we explain the implementation of the above idea. We first identify the dimensions in which <code>P</code> is constrained. Then we identify the block dimensions of <span>$X × Y × Z$</span> such that <span>$Y$</span> has minimal dimension. Finally, we convert <span>$Y$</span> to a polyhedron and intersect it with a suitable projection of <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L947-L1005">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Tuple{LineSegment,Line2D}" href="#LazySets.intersection-Tuple{LineSegment,Line2D}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(a::LineSegment, b::Line2D)</code></pre><p>Compute the intersection of a line and a line segment in two dimensions.</p><p><strong>Input</strong></p><ul><li><code>a</code> – LineSegment</li><li><code>b</code> – Line2D</li></ul><p><strong>Output</strong></p><p>If the sets do not intersect, the result is the empty set. Otherwise the result is the singleton or line segment that describes the intersection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L117-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.intersection-Tuple{LineSegment,LineSegment}" href="#LazySets.intersection-Tuple{LineSegment,LineSegment}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(a::LineSegment, b::LineSegment)</code></pre><p>Return the intersection of two two-dimensional line segments.</p><p><strong>Input</strong></p><ul><li><code>a</code> – first line segment</li><li><code>b</code> – second line segment</li></ul><p><strong>Output</strong></p><p>A singleton, line segment or the empty set depending on the result of the intersection.</p><p><strong>Notes</strong></p><ul><li><p>If the line segments cross, or are parallel and have one point in common, that point is returned.</p></li><li><p>If the line segments are parallel and have a line segment in common, that segment is returned.</p></li><li><p>Otherwise, if there is no intersection, an empty set is returned.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/intersection.jl#L153-L176">source</a></section></article><h2 id="Minkowski-sum"><a class="docs-heading-anchor" href="#Minkowski-sum">Minkowski sum</a><a id="Minkowski-sum-1"></a><a class="docs-heading-anchor-permalink" href="#Minkowski-sum" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.minkowski_sum-Tuple{LazySet,LazySet}" href="#LazySets.minkowski_sum-Tuple{LazySet,LazySet}"><code>LazySets.minkowski_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minkowski_sum(P::LazySet, Q::LazySet;
              [backend]=nothing,
              [algorithm]=nothing,
              [prune]=true)</code></pre><p>Concrete Minkowski sum for a pair of lazy sets using their constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>         – lazy set</li><li><code>Q</code>         – another lazy set</li><li><code>backend</code>   – (optional, default: <code>nothing</code>) polyhedral computations backend</li><li><code>algorithm</code> – (optional, default: <code>nothing</code>) algorithm to compute the elimination                of variables; available options are <code>Polyhedra.FourierMotzkin</code>,                <code>Polyhedra.BlockElimination</code>, and <code>Polyhedra.ProjectGenerators</code></li><li><code>prune</code>     – (optional, default: <code>true</code>) if <code>true</code>, apply a post-processing algorithm                to remove redundant constraints</li></ul><p><strong>Output</strong></p><p>An <code>HPolytope</code> that corresponds to the Minkowski sum of <code>P</code> and <code>Q</code> if both <code>P</code> and <code>Q</code> are bounded; otherwise an <code>HPolyhedron</code>.</p><p><strong>Notes</strong></p><p>This function requires that the list of constraints of both lazy sets <code>P</code> and <code>Q</code> can be obtained. After obtaining the respective lists of constraints, the <code>minkowski_sum</code> fucntion for polyhedral sets is used. For details see <a href="#LazySets.minkowski_sum-Tuple{VPolytope,VPolytope}"><code>minkowski_sum(::VPolytope, ::VPolytope)</code></a>.</p><p>This method requires <code>Polyhedra</code> and <code>CDDLib</code>, so you have to do:</p><pre><code class="language-julia">julia&gt; using LazySets, Polyhedra, CDDLib

julia&gt; ...

julia&gt; minkowski_sum(P, Q)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/minkowski_sum.jl#L3-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.minkowski_sum-Tuple{AbstractPolyhedron,AbstractPolyhedron}" href="#LazySets.minkowski_sum-Tuple{AbstractPolyhedron,AbstractPolyhedron}"><code>LazySets.minkowski_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minkowski_sum(P::AbstractPolyhedron, Q::AbstractPolyhedron;
              [backend]=nothing,
              [algorithm]=nothing,
              [prune]=true)</code></pre><p>Compute the Minkowski sum between two polyhedra in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>         – polyhedron in constraint representation</li><li><code>Q</code>         – another polyhedron in constraint representation</li><li><code>backend</code>   – (optional, default: <code>nothing</code>) polyhedral computations backend</li><li><code>algorithm</code> – (optional, default: <code>nothing</code>) algorithm to compute the elimination                of variables; available options are <code>Polyhedra.FourierMotzkin</code>,                <code>Polyhedra.BlockElimination</code>, and <code>Polyhedra.ProjectGenerators</code></li><li><code>prune</code>     – (optional, default: <code>true</code>) if <code>true</code>, apply a post-processing algorithm                to remove redundant constraints</li></ul><p><strong>Output</strong></p><p>A polyhedron in H-representation that corresponds to the Minkowski sum of <code>P</code> and <code>Q</code>.</p><p><strong>Notes</strong></p><p>This method requires <code>Polyhedra</code> and <code>CDDLib</code>, so you have to do:</p><pre><code class="language-julia">julia&gt; using LazySets, Polyhedra, CDDLib

julia&gt; ...

julia&gt; minkowski_sum(P, Q)</code></pre><p><strong>Algorithm</strong></p><p>This function implements the concrete Minkowski sum by projection and variable elimination as detailed in [1]. The idea is that if we write <span>$P$</span> and <span>$Q$</span> in <em>simple H-representation</em>, that is, <span>$P = \{x ∈ \mathbb{R}^n : Ax ≤ b \}$</span> and <span>$Q = \{x ∈ \mathbb{R}^n : Cx ≤ d \}$</span>, then their Minkowski sum can be seen as the projection onto the first <span>$n$</span>-dimensional coordinates of the polyhedron</p><p class="math-container">\[    \begin{pmatrix} 0 &amp; A \ C &amp; -C \end{pmatrix} \binom{x}{y} ≤ inom{b}{d}\]</p><p>This is seen by noting that <span>$P ⊕ Q$</span> corresponds to the set of points <span>$x ∈ \mathbb{R}^n$</span> such that <span>$x = y + z$</span> with <span>$Ay ≤ b$</span> and <span>$Cz ≤ d$</span>; hence it follows that <span>$Ay ≤ b$</span> and <span>$C(x-y) ≤ d$</span>, and the inequality displayed above follows by considering the <span>$2n$</span>-dimensional space <span>$\binom{x}{y}$</span>. The reduction from <span>$2n$</span> to <span>$n$</span> variables is performed using an elimination algorithm as described next.</p><p>The elimination of variables depends on the concrete polyhedra library <code>Polyhedra</code>, which itself uses <code>CDDLib</code> for variable elimination. The available algorithms are:</p><ul><li><p><code>Polyhedra.FourierMotzkin</code>   – computation of the projection by computing the                                 H-representation and applying the Fourier-Motzkin                                 elimination algorithm to it</p></li><li><p><code>Polyhedra.BlockElimination</code> – computation of the projection by computing the                                 H-representation and applying the block elimination                                 algorithm to it</p></li><li><p><code>Polyhedra.ProjectGenerators</code> – computation of the projection by computing the                                  V-representation</p></li></ul><p>[1] Kvasnica, Michal. &quot;Minkowski addition of convex polytopes.&quot; (2005): 1-10.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/minkowski_sum.jl#L61-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.minkowski_sum-Tuple{VPolytope,VPolytope}" href="#LazySets.minkowski_sum-Tuple{VPolytope,VPolytope}"><code>LazySets.minkowski_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minkowski_sum(P1::VPolytope, P2::VPolytope;
              [apply_convex_hull]=true,
              [backend]=nothing,
              [solver]=nothing)</code></pre><p>Compute the Minkowski sum between two polytopes in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>P1</code>                – polytope</li><li><code>P2</code>                – another polytope</li><li><code>apply_convex_hull</code> – (optional, default: <code>true</code>) if <code>true</code>, post-process the                        pairwise sums using a convex hull algorithm</li><li><code>backend</code>           – (optional, default: <code>nothing</code>) the backend for                        polyhedral computations used to post-process with a                        convex hull; see <code>default_polyhedra_backend(P1)</code></li><li><code>solver</code>            – (optional, default: <code>nothing</code>) the backend used to                        solve the linear program; see                        <code>default_lp_solver_polyhedra(N)</code></li></ul><p><strong>Output</strong></p><p>A new polytope in vertex representation whose vertices are the convex hull of the sum of all possible sums of vertices of <code>P1</code> and <code>P2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/minkowski_sum.jl#L388-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.minkowski_sum-Tuple{AbstractHyperrectangle,AbstractHyperrectangle}" href="#LazySets.minkowski_sum-Tuple{AbstractHyperrectangle,AbstractHyperrectangle}"><code>LazySets.minkowski_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minkowski_sum(H1::AbstractHyperrectangle, H2::AbstractHyperrectangle)</code></pre><p>Concrete Minkowski sum of a pair of hyperrectangular sets.</p><p><strong>Input</strong></p><ul><li><code>H1</code> – hyperrectangular set</li><li><code>H2</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A <code>Hyperrectangle</code> corresponding to the concrete Minkowski sum of <code>H1</code> and <code>H2</code>.</p><p><strong>Algorithm</strong></p><p>The resulting hyperrectangle is obtained by summing up the centers and radiuses of <code>H1</code> and <code>H2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/minkowski_sum.jl#L196-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.minkowski_sum-Tuple{AbstractZonotope,AbstractZonotope}" href="#LazySets.minkowski_sum-Tuple{AbstractZonotope,AbstractZonotope}"><code>LazySets.minkowski_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minkowski_sum(Z1::AbstractZonotope, Z2::AbstractZonotope)</code></pre><p>Concrete Minkowski sum of a pair of zonotopic sets.</p><p><strong>Input</strong></p><ul><li><code>Z1</code> – zonotopic set</li><li><code>Z2</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>A <code>Zonotope</code> corresponding to the concrete Minkowski sum of <code>Z1</code> and <code>Z2</code>.</p><p><strong>Algorithm</strong></p><p>The resulting zonotope is obtained by summing up the centers and concatenating the generators of <code>Z1</code> and <code>Z2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/minkowski_sum.jl#L221-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.minkowski_sum-Tuple{VPolygon,VPolygon}" href="#LazySets.minkowski_sum-Tuple{VPolygon,VPolygon}"><code>LazySets.minkowski_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minkowski_sum(P::VPolygon, Q::VPolygon)</code></pre><p>The Minkowski Sum of two polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in vertex representation</li><li><code>Q</code> – another polygon in vertex representation</li></ul><p><strong>Output</strong></p><p>A polygon in vertex representation.</p><p><strong>Algorithm</strong></p><p>We treat each edge of the polygons as a vector, attaching them in polar order (attaching the tail of the next vector to the head of the previous vector). The resulting polygonal chain will be a polygon, which is the Minkowski sum of the given polygons. This algorithm assumes that the vertices of P and Q are sorted in counter-clockwise fashion and has linear complexity O(m+n) where m and n are the number of vertices of P and Q respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/minkowski_sum.jl#L298-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.minkowski_sum-Tuple{PolynomialZonotope,AbstractZonotope}" href="#LazySets.minkowski_sum-Tuple{PolynomialZonotope,AbstractZonotope}"><code>LazySets.minkowski_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minkowski_sum(PZ::PolynomialZonotope, Z::AbstractZonotope)</code></pre><p>Return the Minkowski sum of a polynomial zonotope and a usual zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>PZ</code> – polynomial zonotope</li><li><code>Z</code>  – usual zonotopic set</li></ul><p><strong>Output</strong></p><p>A polynomial zonotope whose center is the sum of the centers of <code>PZ</code> and <code>Z</code> and whose generators are the concatenation of the generators of <code>PZ</code> and <code>Z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/minkowski_sum.jl#L451-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.minkowski_sum-Tuple{Interval,Interval}" href="#LazySets.minkowski_sum-Tuple{Interval,Interval}"><code>LazySets.minkowski_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minkowski_sum(x::Interval, y::Interval)</code></pre><p>Concrete Minkowski sum of a pair of intervals.</p><p><strong>Input</strong></p><ul><li><code>x</code> – hyperrectangular set</li><li><code>y</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>An <code>Interval</code> corresponding to the concrete Minkowski sum of <code>x</code> and <code>y</code>.</p><p><strong>Algorithm</strong></p><p>The function takes the sum of <code>x</code> and <code>y</code> following the rules of interval arithmetic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/minkowski_sum.jl#L275-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.minkowski_sum-Tuple{AbstractSingleton,AbstractSingleton}" href="#LazySets.minkowski_sum-Tuple{AbstractSingleton,AbstractSingleton}"><code>LazySets.minkowski_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minkowski_sum(X::AbstractSingleton, Y::AbstractSingleton)</code></pre><p>Concrete Minkowski sum of a pair of singletons.</p><p><strong>Input</strong></p><ul><li><code>X</code> – singleton</li><li><code>Y</code> – singleton</li></ul><p><strong>Output</strong></p><p>A singleton</p><p><strong>Algorithm</strong></p><p>The singleton obtained by summing the elements in <code>X</code> and <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/minkowski_sum.jl#L246-L263">source</a></section></article><h2 id="Minkowski-difference"><a class="docs-heading-anchor" href="#Minkowski-difference">Minkowski difference</a><a id="Minkowski-difference-1"></a><a class="docs-heading-anchor-permalink" href="#Minkowski-difference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.minkowski_difference-Union{Tuple{N}, Tuple{LazySet{N},LazySet{N}}} where N&lt;:Real" href="#LazySets.minkowski_difference-Union{Tuple{N}, Tuple{LazySet{N},LazySet{N}}} where N&lt;:Real"><code>LazySets.minkowski_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minkowski_difference(P::LazySet{N}, Q::LazySet{N}) where {N&lt;:Real}</code></pre><p>Concrete Minkowski difference (geometric difference) for a pair of convex sets.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polytopic set</li><li><code>Q</code> – compact convex set that is subtracted from <code>P</code></li></ul><p><strong>Output</strong></p><p>An <code>HPolytope</code> that corresponds to the Minkowski difference of <code>P</code> minus <code>Q</code> if <code>P</code> is bounded, and an <code>HPolyhedron</code> if <code>P</code> is unbounded.</p><p><strong>Notes</strong></p><p>This function requires that the list of constraints of the set <code>P</code> is available and that the set <code>Q</code> is bounded.</p><p><strong>Algorithm</strong></p><p>This function implements Theorem 2.3 in [1], which we state next.</p><p>Suppose <span>$P$</span> is a polyhedron</p><p class="math-container">\[P = \{z ∈ ℝ^n: sᵢᵀz ≤ rᵢ,~i = 1, …, N\}.\]</p><p>where <span>$sᵢ ∈ ℝ^n, sᵢ ≠ 0$</span>, and <span>$rᵢ ∈ ℝ$</span>. Assume <span>$ρ(sᵢ,Q)$</span> is defined for <span>$i = 1, …, N$</span>. Then,</p><p class="math-container">\[P ⊖ Q = \{z ∈ ℝ^n: sᵢᵀz ≤ rᵢ - ρ(sᵢ,Q),~i = 1, …, N\}.\]</p><p>where <span>$⊖$</span> is defined as <span>$P ⊖ Q = \{z ∈ ℝ^n: z + v ∈ P  ~∀~v ∈ Q\}$</span> and is called the <em>Minkowski difference</em> (also referenced as <em>Pontryagin difference</em>, or geometric difference). It is denoted in [1] as the operation <code>P ~ Q</code>.</p><p>[1] Ilya Kolmanovsky and Elmer G. Gilbert (1997). <em>Theory and computation of disturbance invariant sets for discrete-time linear systems.</em> <a href="http://dx.doi.org/10.1155/S1024123X98000866">Mathematical Problems in Engineering Volume 4, Issue 4, Pages 317-367.</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/minkowski_difference.jl#L3-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.pontryagin_difference" href="#LazySets.pontryagin_difference"><code>LazySets.pontryagin_difference</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pontryagin_difference(P::LazySet{N}, Q::LazySet{N}) where {N&lt;:Real}</code></pre><p>An alias for the function <code>minkowski_difference</code>.</p><p><strong>Notes</strong></p><p>Due to inconsistent naming conventions, both the name <em>Minkowski difference</em> and <em>Pontryagin difference</em> are used to refer to the geometric difference of two sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/minkowski_difference.jl#L64-L74">source</a></section></article><h2 id="Subset-check"><a class="docs-heading-anchor" href="#Subset-check">Subset check</a><a id="Subset-check-1"></a><a class="docs-heading-anchor-permalink" href="#Subset-check" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.issubset" href="#Base.issubset"><code>Base.issubset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issubset(X::LazySet, Y::LazySet, [witness]::Bool=false, args...)</code></pre><p>Alias for <code>⊆</code> (inclusion check).</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>Y</code>       – set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊆ Y$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ⊆ Y$</span></li><li><code>(false, v)</code> iff <span>$X ⊈ Y$</span> and <span>$v ∈ X \setminus Y$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>For more documentation see <code>⊆</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(X::LazySet, P::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a convex set is contained in a polyhedral set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – inner convex set</li><li><code>Y</code>       – outer polyhedral set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊆ P$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ⊆ P$</span></li><li><code>(false, v)</code> iff <span>$X ⊈ P$</span> and <span>$v ∈ X \setminus P$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>We require that <code>constraints_list(P)</code> is available.</p><p><strong>Algorithm</strong></p><p>We check inclusion of <code>X</code> in every constraint of <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L38-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(S::LazySet, H::AbstractHyperrectangle, [witness]::Bool=false)</code></pre><p>Check whether a convex set is contained in a hyperrectangular set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>S</code> – inner convex set</li><li><code>H</code> – outer hyperrectangular set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ H$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$S ⊆ H$</span></li><li><code>(false, v)</code> iff <span>$S ⊈ H$</span> and <span>$v ∈ S \setminus H$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ⊆ H$</span> iff <span>$\operatorname{ihull}(S) ⊆ H$</span>, where  <span>$\operatorname{ihull}$</span> is the interval hull operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L78-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(P::AbstractPolytope, S::LazySet, [witness]::Bool=false;
  algorithm=_default_issubset(P, S))</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code>   – (optional, default: <code>false</code>) compute a witness if activated</p></li><li><p><code>algorithm</code> – (optional, default: <code>&quot;constraints&quot;</code> if the constraints list of <code>S</code>                is available, otherwise <code>&quot;vertices&quot;</code>) algorithm for the inclusion                check; available options are:</p><ul><li><p><code>&quot;constraints&quot;</code>, using the list of constraints of <code>P</code> and support function evaluations of <code>S</code></p></li><li><p><code>&quot;vertices&quot;</code>, using the list of vertices of <code>P</code> and membership evaluations of <code>S</code></p></li></ul></li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$P ⊆ S$</span></li><li><code>(false, v)</code> iff <span>$P ⊈ S$</span> and <span>$v ∈ P \setminus S$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L173-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(X::LazySet, P::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a convex set is contained in a polyhedral set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – inner convex set</li><li><code>Y</code>       – outer polyhedral set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊆ P$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ⊆ P$</span></li><li><code>(false, v)</code> iff <span>$X ⊈ P$</span> and <span>$v ∈ X \setminus P$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>We require that <code>constraints_list(P)</code> is available.</p><p><strong>Algorithm</strong></p><p>We check inclusion of <code>X</code> in every constraint of <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L38-L64">source</a></section><section><div><pre><code class="language-julia">⊆(S::LazySet, H::AbstractHyperrectangle, [witness]::Bool=false)</code></pre><p>Check whether a convex set is contained in a hyperrectangular set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>S</code> – inner convex set</li><li><code>H</code> – outer hyperrectangular set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ H$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$S ⊆ H$</span></li><li><code>(false, v)</code> iff <span>$S ⊈ H$</span> and <span>$v ∈ S \setminus H$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ⊆ H$</span> iff <span>$\operatorname{ihull}(S) ⊆ H$</span>, where  <span>$\operatorname{ihull}$</span> is the interval hull operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L78-L101">source</a></section><section><div><pre><code class="language-julia">⊆(P::AbstractPolytope, S::LazySet, [witness]::Bool=false;
  algorithm=_default_issubset(P, S))</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code>   – (optional, default: <code>false</code>) compute a witness if activated</p></li><li><p><code>algorithm</code> – (optional, default: <code>&quot;constraints&quot;</code> if the constraints list of <code>S</code>                is available, otherwise <code>&quot;vertices&quot;</code>) algorithm for the inclusion                check; available options are:</p><ul><li><p><code>&quot;constraints&quot;</code>, using the list of constraints of <code>P</code> and support function evaluations of <code>S</code></p></li><li><p><code>&quot;vertices&quot;</code>, using the list of vertices of <code>P</code> and membership evaluations of <code>S</code></p></li></ul></li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$P ⊆ S$</span></li><li><code>(false, v)</code> iff <span>$P ⊈ S$</span> and <span>$v ∈ P \setminus S$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L173-L206">source</a></section><section><div><pre><code class="language-julia">⊆(X::LazySet, P::AbstractPolyhedron, [witness]::Bool=false)</code></pre><p>Check whether a convex set is contained in a polyhedron, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code> – inner convex set</li><li><code>P</code> – outer polyhedron (including a half-space)</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊆ P$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ⊆ P$</span></li><li><code>(false, v)</code> iff <span>$X ⊈ P$</span> and <span>$v ∈ P \setminus X$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$X$</span> is convex, we can compare the support function of <span>$X$</span> and <span>$P$</span> in each direction of the constraints of <span>$P$</span>.</p><p>For witness generation, we use the support vector in the first direction where the above check fails.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L246-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆-Tuple{AbstractZonotope,AbstractHyperrectangle}" href="#Base.:⊆-Tuple{AbstractZonotope,AbstractHyperrectangle}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">⊆(X::LazySet, P::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a convex set is contained in a polyhedral set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – inner convex set</li><li><code>Y</code>       – outer polyhedral set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊆ P$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ⊆ P$</span></li><li><code>(false, v)</code> iff <span>$X ⊈ P$</span> and <span>$v ∈ X \setminus P$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>We require that <code>constraints_list(P)</code> is available.</p><p><strong>Algorithm</strong></p><p>We check inclusion of <code>X</code> in every constraint of <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L38-L64">source</a></section><section><div><pre><code class="language-julia">⊆(S::LazySet, H::AbstractHyperrectangle, [witness]::Bool=false)</code></pre><p>Check whether a convex set is contained in a hyperrectangular set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>S</code> – inner convex set</li><li><code>H</code> – outer hyperrectangular set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ H$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$S ⊆ H$</span></li><li><code>(false, v)</code> iff <span>$S ⊈ H$</span> and <span>$v ∈ S \setminus H$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ⊆ H$</span> iff <span>$\operatorname{ihull}(S) ⊆ H$</span>, where  <span>$\operatorname{ihull}$</span> is the interval hull operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L78-L101">source</a></section><section><div><pre><code class="language-julia">⊆(P::AbstractPolytope, S::LazySet, [witness]::Bool=false;
  algorithm=_default_issubset(P, S))</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code>   – (optional, default: <code>false</code>) compute a witness if activated</p></li><li><p><code>algorithm</code> – (optional, default: <code>&quot;constraints&quot;</code> if the constraints list of <code>S</code>                is available, otherwise <code>&quot;vertices&quot;</code>) algorithm for the inclusion                check; available options are:</p><ul><li><p><code>&quot;constraints&quot;</code>, using the list of constraints of <code>P</code> and support function evaluations of <code>S</code></p></li><li><p><code>&quot;vertices&quot;</code>, using the list of vertices of <code>P</code> and membership evaluations of <code>S</code></p></li></ul></li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$P ⊆ S$</span></li><li><code>(false, v)</code> iff <span>$P ⊈ S$</span> and <span>$v ∈ P \setminus S$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L173-L206">source</a></section><section><div><pre><code class="language-julia">⊆(X::LazySet, P::AbstractPolyhedron, [witness]::Bool=false)</code></pre><p>Check whether a convex set is contained in a polyhedron, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code> – inner convex set</li><li><code>P</code> – outer polyhedron (including a half-space)</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊆ P$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ⊆ P$</span></li><li><code>(false, v)</code> iff <span>$X ⊈ P$</span> and <span>$v ∈ P \setminus X$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$X$</span> is convex, we can compare the support function of <span>$X$</span> and <span>$P$</span> in each direction of the constraints of <span>$P$</span>.</p><p>For witness generation, we use the support vector in the first direction where the above check fails.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L246-L272">source</a></section><section><div><pre><code class="language-julia">⊆(Z::AbstractZonotope, H::AbstractHyperrectangle, [witness]::Bool=false)</code></pre><p>Check whether a zonotopic set is contained in a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>Z</code>       – inner zonotopic set</li><li><code>H</code>       – outer hyperrectangular set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$Z ⊆ H$</span> otherwise <code>false</code></p><p><strong>Algorithm</strong></p><p>Algorithm based on Lemma 3.1 of [1]</p><p>[1] Mitchell, I. M., Budzis, J., &amp; Bolyachevets, A. (2019, April). Invariant,  viability and discriminating kernel under-approximation via zonotope scaling.  In Proceedings of the 22nd ACM International Conference on Hybrid Systems:  Computation and Control (pp. 268-269).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L933-L956">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(H1::AbstractHyperrectangle, H2::AbstractHyperrectangle, [witness]::Bool=false)</code></pre><p>Check whether a given hyperrectangular set is contained in another hyperrectangular set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>H1</code> – inner hyperrectangular set</li><li><code>H2</code> – outer hyperrectangular set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$H1 ⊆ H2$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$H1 ⊆ H2$</span></li><li><code>(false, v)</code> iff <span>$H1 ⊈ H2$</span> and <span>$v ∈ H1 \setminus H2$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$H1 ⊆ H2$</span> iff <span>$c_1 + r_1 ≤ c_2 + r_2 ∧ c_1 - r_1 ≥ c_2 - r_2$</span> iff <span>$r_1 - r_2 ≤ c_1 - c_2 ≤ -(r_1 - r_2)$</span>, where <span>$≤$</span> is taken component-wise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L114-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(X::LazySet, P::AbstractPolyhedron, [witness]::Bool=false)</code></pre><p>Check whether a convex set is contained in a polyhedron, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code> – inner convex set</li><li><code>P</code> – outer polyhedron (including a half-space)</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊆ P$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ⊆ P$</span></li><li><code>(false, v)</code> iff <span>$X ⊈ P$</span> and <span>$v ∈ P \setminus X$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$X$</span> is convex, we can compare the support function of <span>$X$</span> and <span>$P$</span> in each direction of the constraints of <span>$P$</span>.</p><p>For witness generation, we use the support vector in the first direction where the above check fails.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L246-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(S::AbstractSingleton, X::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a given set with a single value is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>S</code>       – inner set with a single value</li><li><code>X</code>       – outer convex set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ X$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$S ⊆ X$</span></li><li><code>(false, v)</code> iff <span>$S ⊈ X$</span> and <span>$v ∈ S \setminus X$</span></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L302-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(X::LazySet, P::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a convex set is contained in a polyhedral set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – inner convex set</li><li><code>Y</code>       – outer polyhedral set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊆ P$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ⊆ P$</span></li><li><code>(false, v)</code> iff <span>$X ⊈ P$</span> and <span>$v ∈ X \setminus P$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>We require that <code>constraints_list(P)</code> is available.</p><p><strong>Algorithm</strong></p><p>We check inclusion of <code>X</code> in every constraint of <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L38-L64">source</a></section><section><div><pre><code class="language-julia">⊆(S::LazySet, H::AbstractHyperrectangle, [witness]::Bool=false)</code></pre><p>Check whether a convex set is contained in a hyperrectangular set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>S</code> – inner convex set</li><li><code>H</code> – outer hyperrectangular set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ H$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$S ⊆ H$</span></li><li><code>(false, v)</code> iff <span>$S ⊈ H$</span> and <span>$v ∈ S \setminus H$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ⊆ H$</span> iff <span>$\operatorname{ihull}(S) ⊆ H$</span>, where  <span>$\operatorname{ihull}$</span> is the interval hull operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L78-L101">source</a></section><section><div><pre><code class="language-julia">⊆(H1::AbstractHyperrectangle, H2::AbstractHyperrectangle, [witness]::Bool=false)</code></pre><p>Check whether a given hyperrectangular set is contained in another hyperrectangular set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>H1</code> – inner hyperrectangular set</li><li><code>H2</code> – outer hyperrectangular set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$H1 ⊆ H2$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$H1 ⊆ H2$</span></li><li><code>(false, v)</code> iff <span>$H1 ⊈ H2$</span> and <span>$v ∈ H1 \setminus H2$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$H1 ⊆ H2$</span> iff <span>$c_1 + r_1 ≤ c_2 + r_2 ∧ c_1 - r_1 ≥ c_2 - r_2$</span> iff <span>$r_1 - r_2 ≤ c_1 - c_2 ≤ -(r_1 - r_2)$</span>, where <span>$≤$</span> is taken component-wise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L114-L137">source</a></section><section><div><pre><code class="language-julia">⊆(P::AbstractPolytope, S::LazySet, [witness]::Bool=false;
  algorithm=_default_issubset(P, S))</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code>   – (optional, default: <code>false</code>) compute a witness if activated</p></li><li><p><code>algorithm</code> – (optional, default: <code>&quot;constraints&quot;</code> if the constraints list of <code>S</code>                is available, otherwise <code>&quot;vertices&quot;</code>) algorithm for the inclusion                check; available options are:</p><ul><li><p><code>&quot;constraints&quot;</code>, using the list of constraints of <code>P</code> and support function evaluations of <code>S</code></p></li><li><p><code>&quot;vertices&quot;</code>, using the list of vertices of <code>P</code> and membership evaluations of <code>S</code></p></li></ul></li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$P ⊆ S$</span></li><li><code>(false, v)</code> iff <span>$P ⊈ S$</span> and <span>$v ∈ P \setminus S$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L173-L206">source</a></section><section><div><pre><code class="language-julia">⊆(X::LazySet, P::AbstractPolyhedron, [witness]::Bool=false)</code></pre><p>Check whether a convex set is contained in a polyhedron, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code> – inner convex set</li><li><code>P</code> – outer polyhedron (including a half-space)</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊆ P$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ⊆ P$</span></li><li><code>(false, v)</code> iff <span>$X ⊈ P$</span> and <span>$v ∈ P \setminus X$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$X$</span> is convex, we can compare the support function of <span>$X$</span> and <span>$P$</span> in each direction of the constraints of <span>$P$</span>.</p><p>For witness generation, we use the support vector in the first direction where the above check fails.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L246-L272">source</a></section><section><div><pre><code class="language-julia">⊆(S::AbstractSingleton, X::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a given set with a single value is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>S</code>       – inner set with a single value</li><li><code>X</code>       – outer convex set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ X$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$S ⊆ X$</span></li><li><code>(false, v)</code> iff <span>$S ⊈ X$</span> and <span>$v ∈ S \setminus X$</span></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L302-L320">source</a></section><section><div><pre><code class="language-julia">⊆(Z::AbstractZonotope, H::AbstractHyperrectangle, [witness]::Bool=false)</code></pre><p>Check whether a zonotopic set is contained in a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>Z</code>       – inner zonotopic set</li><li><code>H</code>       – outer hyperrectangular set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$Z ⊆ H$</span> otherwise <code>false</code></p><p><strong>Algorithm</strong></p><p>Algorithm based on Lemma 3.1 of [1]</p><p>[1] Mitchell, I. M., Budzis, J., &amp; Bolyachevets, A. (2019, April). Invariant,  viability and discriminating kernel under-approximation via zonotope scaling.  In Proceedings of the 22nd ACM International Conference on Hybrid Systems:  Computation and Control (pp. 268-269).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L933-L956">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(S1::AbstractSingleton, S2::AbstractSingleton, witness::Bool=false)</code></pre><p>Check whether a given set with a single value is contained in another set with a single value, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>S1</code> – inner set with a single value</li><li><code>S2</code> – outer set with a single value</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S1 ⊆ S2$</span> iff <span>$S1 == S2$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$S1 ⊆ S2$</span></li><li><code>(false, v)</code> iff <span>$S1 ⊈ S2$</span> and <span>$v ∈ S1 \setminus S2$</span></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L341-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(B1::Ball2, B2::Ball2{N}, [witness]::Bool=false
 ) where {N&lt;:AbstractFloat}</code></pre><p>Check whether a ball in the 2-norm is contained in another ball in the 2-norm, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>B1</code> – inner ball in the 2-norm</li><li><code>B2</code> – outer ball in the 2-norm</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$B1 ⊆ B2$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$B1 ⊆ B2$</span></li><li><code>(false, v)</code> iff <span>$B1 ⊈ B2$</span> and <span>$v ∈ B1 \setminus B2$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$B1 ⊆ B2$</span> iff <span>$‖ c_1 - c_2 ‖_2 + r_1 ≤ r_2$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L374-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(B::Union{Ball2, Ballp}, S::AbstractSingleton, witness::Bool=false)</code></pre><p>Check whether a ball in the 2-norm or p-norm is contained in a set with a single value, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>B</code> – inner ball in the 2-norm or p-norm</li><li><code>S</code> – outer set with a single value</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$B ⊆ S$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$B ⊆ S$</span></li><li><code>(false, v)</code> iff <span>$B ⊈ S$</span> and <span>$v ∈ B \setminus S$</span></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L418-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(L::LineSegment, S::LazySet, witness::Bool=false)</code></pre><p>Check whether a line segment is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>L</code> – inner line segment</li><li><code>S</code> – outer convex set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$L ⊆ S$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$L ⊆ S$</span></li><li><code>(false, v)</code> iff <span>$L ⊈ S$</span> and <span>$v ∈ L \setminus S$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$L ⊆ S$</span> iff <span>$p ∈ S$</span> and <span>$q ∈ S$</span>, where <span>$p, q$</span> are the end points of <span>$L$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L462-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(X::LazySet, P::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a convex set is contained in a polyhedral set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – inner convex set</li><li><code>Y</code>       – outer polyhedral set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊆ P$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ⊆ P$</span></li><li><code>(false, v)</code> iff <span>$X ⊈ P$</span> and <span>$v ∈ X \setminus P$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>We require that <code>constraints_list(P)</code> is available.</p><p><strong>Algorithm</strong></p><p>We check inclusion of <code>X</code> in every constraint of <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L38-L64">source</a></section><section><div><pre><code class="language-julia">⊆(S::LazySet, H::AbstractHyperrectangle, [witness]::Bool=false)</code></pre><p>Check whether a convex set is contained in a hyperrectangular set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>S</code> – inner convex set</li><li><code>H</code> – outer hyperrectangular set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$S ⊆ H$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$S ⊆ H$</span></li><li><code>(false, v)</code> iff <span>$S ⊈ H$</span> and <span>$v ∈ S \setminus H$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><span>$S ⊆ H$</span> iff <span>$\operatorname{ihull}(S) ⊆ H$</span>, where  <span>$\operatorname{ihull}$</span> is the interval hull operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L78-L101">source</a></section><section><div><pre><code class="language-julia">⊆(P::AbstractPolytope, S::LazySet, [witness]::Bool=false;
  algorithm=_default_issubset(P, S))</code></pre><p>Check whether a polytope is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – inner polytope</p></li><li><p><code>S</code> – outer convex set</p></li><li><p><code>witness</code>   – (optional, default: <code>false</code>) compute a witness if activated</p></li><li><p><code>algorithm</code> – (optional, default: <code>&quot;constraints&quot;</code> if the constraints list of <code>S</code>                is available, otherwise <code>&quot;vertices&quot;</code>) algorithm for the inclusion                check; available options are:</p><ul><li><p><code>&quot;constraints&quot;</code>, using the list of constraints of <code>P</code> and support function evaluations of <code>S</code></p></li><li><p><code>&quot;vertices&quot;</code>, using the list of vertices of <code>P</code> and membership evaluations of <code>S</code></p></li></ul></li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P ⊆ S$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$P ⊆ S$</span></li><li><code>(false, v)</code> iff <span>$P ⊈ S$</span> and <span>$v ∈ P \setminus S$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$P ⊆ S$</span> iff <span>$v_i ∈ S$</span> for all vertices <span>$v_i$</span> of <span>$P$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L173-L206">source</a></section><section><div><pre><code class="language-julia">⊆(X::LazySet, P::AbstractPolyhedron, [witness]::Bool=false)</code></pre><p>Check whether a convex set is contained in a polyhedron, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code> – inner convex set</li><li><code>P</code> – outer polyhedron (including a half-space)</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊆ P$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ⊆ P$</span></li><li><code>(false, v)</code> iff <span>$X ⊈ P$</span> and <span>$v ∈ P \setminus X$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$X$</span> is convex, we can compare the support function of <span>$X$</span> and <span>$P$</span> in each direction of the constraints of <span>$P$</span>.</p><p>For witness generation, we use the support vector in the first direction where the above check fails.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L246-L272">source</a></section><section><div><pre><code class="language-julia">⊆(L::LineSegment, S::LazySet, witness::Bool=false)</code></pre><p>Check whether a line segment is contained in a convex set, and if not, optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>L</code> – inner line segment</li><li><code>S</code> – outer convex set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$L ⊆ S$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$L ⊆ S$</span></li><li><code>(false, v)</code> iff <span>$L ⊈ S$</span> and <span>$v ∈ L \setminus S$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>Since <span>$S$</span> is convex, <span>$L ⊆ S$</span> iff <span>$p ∈ S$</span> and <span>$q ∈ S$</span>, where <span>$p, q$</span> are the end points of <span>$L$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L462-L485">source</a></section><section><div><pre><code class="language-julia">⊆(Z::AbstractZonotope, H::AbstractHyperrectangle, [witness]::Bool=false)</code></pre><p>Check whether a zonotopic set is contained in a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>Z</code>       – inner zonotopic set</li><li><code>H</code>       – outer hyperrectangular set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$Z ⊆ H$</span> otherwise <code>false</code></p><p><strong>Algorithm</strong></p><p>Algorithm based on Lemma 3.1 of [1]</p><p>[1] Mitchell, I. M., Budzis, J., &amp; Bolyachevets, A. (2019, April). Invariant,  viability and discriminating kernel under-approximation via zonotope scaling.  In Proceedings of the 22nd ACM International Conference on Hybrid Systems:  Computation and Control (pp. 268-269).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L933-L956">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(x::Interval, y::Interval, [witness]::Bool=false)</code></pre><p>Check whether an interval is contained in another interval.</p><p><strong>Input</strong></p><ul><li><code>x</code>       – interval</li><li><code>y</code>       – interval</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ⊆ y$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L509-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(∅::EmptySet, X::LazySet, witness::Bool=false)</code></pre><p>Check whether an empty set is contained in another set.</p><p><strong>Input</strong></p><ul><li><code>∅</code>       – empty set</li><li><code>X</code>       – another set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated              (ignored, just kept for interface reasons)</li></ul><p><strong>Output</strong></p><p><code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L533-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(X::LazySet, ∅::EmptySet, [witness]::Bool=false)</code></pre><p>Check whether a set is contained in an empty set.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – another set</li><li><code>∅</code>       – empty set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>X</code> is empty.</p><p><strong>Algorithm</strong></p><p>We rely on <code>isempty(X)</code> for the emptiness check and on <code>an_element(X)</code> for witness production.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L562-L581">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(cup::UnionSet, X::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a union of two convex sets is contained in another set.</p><p><strong>Input</strong></p><ul><li><code>cup</code>     – union of two convex sets</li><li><code>X</code>       – another set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$\text{cup} ⊆ X$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$\text{cup} ⊆ X$</span></li><li><code>(false, v)</code> iff <span>$\text{cup} \not\subseteq X$</span> and <span>$v ∈ \text{cup} \setminus X$</span></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L615-L633">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(cup::UnionSetArray, X::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a union of a finite number of convex sets is contained in another set.</p><p><strong>Input</strong></p><ul><li><code>cup</code>     – union of a finite number of convex sets</li><li><code>X</code>       – another set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$\text{cup} ⊆ X$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$\text{cup} ⊆ X$</span></li><li><code>(false, v)</code> iff <span>$\text{cup} \not\subseteq X$</span> and <span>$v ∈ \text{cup} \setminus X$</span></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L638-L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(X::LazySet, U::Universe, [witness]::Bool=false)</code></pre><p>Check whether a convex set is contained in a universe.</p><p><strong>Input</strong></p><ul><li><code>U</code>       – universe</li><li><code>X</code>       – convex set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code></li><li>If <code>witness</code> option is activated: <code>(true, [])</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L679-L694">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(U::Universe, X::LazySet, [witness]::Bool=false)</code></pre><p>Check whether a universe is contained in another convex set, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>U</code>       – universe</li><li><code>X</code>       – convex set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$U ⊆ X$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$U ⊆ X$</span></li><li><code>(false, v)</code> iff <span>$U \not\subseteq X$</span> and <span>$v ∈ U \setminus X$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>We fall back to <code>isuniversal(X)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L709-L732">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(X::LazySet, C::Complement, [witness]::Bool=false)</code></pre><p>Check whether a convex set is contained in the complement of another convex set, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – convex set</li><li><code>C</code>       – complement of a convex set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊆ C$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ⊆ C$</span></li><li><code>(false, v)</code> iff <span>$X \not\subseteq C$</span> and <span>$v ∈ X \setminus C$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p>We fall back to <code>isdisjoint(X, C.X)</code>, which can be justified as follows.</p><p class="math-container">\[    X ⊆ Y^C ⟺ X ∩ Y = ∅\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L751-L778">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(X::CartesianProduct, Y::CartesianProduct, [witness]::Bool=false;
  check_block_equality::Bool=true)</code></pre><p>Check whether a Cartesian product of two convex sets is contained in another Cartesian product of two convex sets, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – Cartesian product of two convex sets</li><li><code>Y</code>       – Cartesian product of two convex sets</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li><li><code>check_block_equality</code> – (optional, default: <code>true</code>) flag for checking that                           the block structure of the two sets is identical</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊆ Y$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ⊆ Y$</span></li><li><code>(false, v)</code> iff <span>$X \not\subseteq Y$</span> and <span>$v ∈ X \setminus Y$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>This algorithm requires that the two Cartesian products share the same block structure. If <code>check_block_equality</code> is activated, we check this property and, if it does not hold, we use a fallback implementation based on conversion to constraint representation (assuming that the sets are polyhedral).</p><p><strong>Algorithm</strong></p><p>We check for inclusion for each block of the Cartesian products.</p><p>For witness production, we obtain a witness in one of the blocks. We then construct a high-dimensional witness by obtaining any point in the other blocks (using <code>an_element</code>) and concatenating these points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L787-L826">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(X::CartesianProductArray, Y::CartesianProductArray, [witness]::Bool=false;
  check_block_equality::Bool=true)</code></pre><p>Check whether a Cartesian product of finitely many convex sets is contained in another Cartesian product of finitely many convex sets, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – Cartesian product of finitely many convex sets</li><li><code>Y</code>       – Cartesian product of finitely many convex sets</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li><li><code>check_block_equality</code> – (optional, default: <code>true</code>) flag for checking that                            the block structure of the two sets is identical</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X ⊆ Y$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X ⊆ Y$</span></li><li><code>(false, v)</code> iff <span>$X \not\subseteq Y$</span> and <span>$v ∈ X \setminus Y$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>This algorithm requires that the two Cartesian products share the same block structure. If <code>check_block_equality</code> is activated, we check this property and, if it does not hold, we use a fallback implementation based on conversion to constraint representation (assuming that the sets are polyhedral).</p><p><strong>Algorithm</strong></p><p>We check for inclusion for each block of the Cartesian products.</p><p>For witness production, we obtain a witness in one of the blocks. We then construct a high-dimensional witness by obtaining any point in the other blocks (using <code>an_element</code>) and concatenating these points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L859-L898">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊆(Z::AbstractZonotope, H::AbstractHyperrectangle, [witness]::Bool=false)</code></pre><p>Check whether a zonotopic set is contained in a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>Z</code>       – inner zonotopic set</li><li><code>H</code>       – outer hyperrectangular set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$Z ⊆ H$</span> otherwise <code>false</code></p><p><strong>Algorithm</strong></p><p>Algorithm based on Lemma 3.1 of [1]</p><p>[1] Mitchell, I. M., Budzis, J., &amp; Bolyachevets, A. (2019, April). Invariant,  viability and discriminating kernel under-approximation via zonotope scaling.  In Proceedings of the 22nd ACM International Conference on Hybrid Systems:  Computation and Control (pp. 268-269).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/issubset.jl#L933-L956">source</a></section></article><h2 id="Set-difference"><a class="docs-heading-anchor" href="#Set-difference">Set difference</a><a id="Set-difference-1"></a><a class="docs-heading-anchor-permalink" href="#Set-difference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.:\\-Tuple{LazySet,LazySet}" href="#Base.:\\-Tuple{LazySet,LazySet}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">\(X::LazySet, Y::LazySet)</code></pre><p>Convenience alias for set difference.</p><p><strong>Input</strong></p><ul><li><code>X</code> – a set</li><li><code>Y</code> – another set</li></ul><p><strong>Output</strong></p><p>The set difference between <code>X</code> and <code>Y</code>.</p><p><strong>Notes</strong></p><p>If <code>X</code> and <code>Y</code> are intervals, <code>X \ Y</code> is used in some libraries to denote the left division, as the example below shows. However, it should not be confused with the <em>set difference</em>. For example,</p><pre><code class="language-julia">julia&gt; X = Interval(0, 2); Y = Interval(1, 4);

julia&gt; X \ Y   # computing the set difference
LazySets.Interval{Float64,IntervalArithmetic.Interval{Float64}}([0, 1])

julia&gt; X.dat \ Y.dat  # computing the left division
[0.5, ∞]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/difference.jl#L8-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.difference-Union{Tuple{IN}, Tuple{N}, Tuple{IN,IN}} where IN&lt;:(Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}) where N" href="#LazySets.difference-Union{Tuple{IN}, Tuple{N}, Tuple{IN,IN}} where IN&lt;:(Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}) where N"><code>LazySets.difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">difference(I1::IN, I2::IN) where {N, IN&lt;:Interval{N}}</code></pre><p>Return the set difference between the given intervals.</p><p>The set difference is defined as:</p><p class="math-container">\[    I₁ \setminus I₂ = \{x: x ∈ I₁ \text{ and } x ∉ I₂ \}\]</p><p>The backslash symbol, <code>\</code>, can be used as an alias.</p><p><strong>Input</strong></p><ul><li><code>I1</code> – first interval</li><li><code>I2</code> – second interval</li></ul><p><strong>Output</strong></p><p>Depending on the position of the intervals, the output is one of the following:</p><ul><li>An <code>EmptySet</code>.</li><li>An <code>Interval</code>.</li><li>A <code>UnionSet</code> of two <code>Interval</code> sets.</li></ul><p><strong>Algorithm</strong></p><p>Let <span>$I₁ = [a, b]$</span> and <span>$I₂ = [c, d]$</span> be intervals. Their set difference is <span>$I₁ \setminus I₂ = \{x: x ∈ I₁ \text{ and } x ∉ I₂ \}$</span> and depending on their position three different results may occur:</p><ul><li>If <span>$I₁$</span> and <span>$I₂$</span> do not overlap, i.e. if their intersection is empty, then the set difference is just <span>$I₁$</span>.</li><li>Otherwise, let <code>I₁₂ = I₁ ∩ I₂</code> and assume that it is not empty, then either <span>$I₁₂$</span> splits <code>I₁</code> into one interval or into two intervals. The latter case happens when the inclusion is strict on both ends of <span>$I₂$</span>.</li></ul><p>To check for strict inclusion, we assume that the inclusion is strict and then check if the resulting intervals that cover <code>I₁</code> (one to its left and one to its right, let them be <code>Ileft</code> and <code>Iright</code>), obtained by intersection with <code>I₂</code>, are flat or not. Three cases may arise:</p><ul><li>If both <code>Ileft</code> and <code>Iright</code> are flat then it means that <code>I₁ = I₂</code>, then the set difference is the empty set.</li><li>If only <code>Ileft</code> is flat, then the remaining interval not covered by <code>I₂</code> is <code>Iright</code>. In a similar manner, if only <code>Iright</code> is flat, then <code>Ileft</code> is returned.</li><li>Finally, if none of the intervals is flat, then <code>I₂</code> is strictly contained in <code>I₁</code> and the set union of <code>Ileft</code> and <code>Iright</code> is returned.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/difference.jl#L44-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.difference-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N}}} where N" href="#LazySets.difference-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N}}} where N"><code>LazySets.difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">difference(X::AbstractHyperrectangle{N}, Y::AbstractHyperrectangle{N}) where {N}</code></pre><p>Return the set difference between the given hyperrectangular sets.</p><p><strong>Input</strong></p><ul><li><code>X</code> – first hyperrectangular set</li><li><code>Y</code> – second hyperrectangular set</li></ul><p>The set difference is defined as:</p><p class="math-container">\[    X \setminus Y = \{x: x ∈ X \text{ and } x ∉ Y \}\]</p><p><strong>Output</strong></p><p>A <code>UnionSetArray</code> consisting of the union of hyperrectangles. Note that this union is in general not convex.</p><p><strong>Algorithm</strong></p><p>This function calls the implementation in <code>IntervalArithmetic.setdiff</code>.</p><p><strong>Notes</strong></p><p>The backslash symbol, <code>\</code>, can be used as an alias.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/ConcreteOperations/difference.jl#L121-L149">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lazy_operations/UnionSet/">« UnionSet</a><a class="docs-footer-nextpage" href="../conversion/">Conversions between set representations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 16 February 2021 02:15">Tuesday 16 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
