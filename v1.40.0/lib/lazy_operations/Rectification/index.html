<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rectification · LazySets.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">LazySets.jl</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../../man/set_operations/">Operations on Sets</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../interfaces/">Interfaces</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../../sets/Line/">Line</a></li><li><a class="tocitem" href="../../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../../sets/PolynomialZonotope/">PolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../../sets/Star/">Star</a></li><li><a class="tocitem" href="../../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../../sets/Zonotope/">Zonotope</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../Bloating/">Bloating</a></li><li><a class="tocitem" href="../CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../Complement/">Complement</a></li><li><a class="tocitem" href="../ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../Intersection/">Intersection</a></li><li><a class="tocitem" href="../LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../MinkowskiSum/">MinkowskiSum</a></li><li class="is-active"><a class="tocitem" href>Rectification</a><ul class="internal"><li><a class="tocitem" href="#Rectification-cache"><span>Rectification cache</span></a></li></ul></li><li><a class="tocitem" href="../ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../Translation/">Translation</a></li><li><a class="tocitem" href="../UnionSet/">UnionSet</a></li></ul></li><li><a class="tocitem" href="../../binary_functions/">Concrete Operations</a></li><li><a class="tocitem" href="../../conversion/">Conversions between set representations</a></li><li><a class="tocitem" href="../../comparisons/">Comparisons</a></li><li><a class="tocitem" href="../../approximations/">Approximations</a></li><li><a class="tocitem" href="../../utils/">Utility Functions</a></li><li><a class="tocitem" href="../../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li><a class="is-disabled">Lazy Operations</a></li><li class="is-active"><a href>Rectification</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Rectification</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/lazy_operations/Rectification.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="def_Rectification"><a class="docs-heading-anchor" href="#def_Rectification">Rectification</a><a id="def_Rectification-1"></a><a class="docs-heading-anchor-permalink" href="#def_Rectification" title="Permalink"></a></h1><p>Note that the rectification of a convex set is generally not convex. Hence this set type is not part of the convex-set family <code>LazySet</code>.</p><article class="docstring"><header><a class="docstring-binding" id="LazySets.Rectification" href="#LazySets.Rectification"><code>LazySets.Rectification</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Rectification{N, S&lt;:LazySet{N}}</code></pre><p>Type that represents the rectification of a convex set.</p><p><strong>Fields</strong></p><ul><li><code>X</code>     – convex set</li><li><code>cache</code> – storage of information computed before</li></ul><p><strong>Notes</strong></p><p>Given a vector <span>$v = (v_1, …, v_n)$</span>, its rectification is defined as <span>$\text{rectify}(v) = (v_1&#39;, …, v_n&#39;)$</span> such that <span>$v_i&#39; = \max(v_i, 0)$</span> for each <span>$i = 1, …, n$</span>.</p><p>The extension to a set <span>$X$</span> is defined elementwise:</p><p class="math-container">\[    \text{rectify}(X) = \{\text{rectify}(x) \mid x ∈ X\}\]</p><p>The rectification of a convex set <span>$X$</span> is not necessarily convex. It can be expressed exactly as the union of the intersection of <span>$X$</span> with the nonnegative orthant and the projection of the intersection of <span>$X$</span> with each other orthant. This can be seen as follows.</p><p>First we observe that rectification distributes with union.</p><p class="math-container">\[    \text{rectify}(X_1 ∪ … ∪ X_m) = ⋃_j \text{rectify}(X_j)\]</p><p>Next we express <span>$X$</span> as the union of the intersection of <span>$X$</span> with each orthant <span>$O$</span>.</p><p class="math-container">\[    X = ⋃_j (X ∩ O_j)\]</p><p>Thus we have</p><p class="math-container">\[    \text{rectify}(X) = \text{rectify}((X ∩ O_1) ∪ … ∪ (X ∩ O_m)) = ⋃_j \text{rectify}(X ∩ O_j).\]</p><p>Clearly, <span>$\text{rectify}(X ∩ O_j) = X$</span> if <span>$O_j$</span> is the nonnegative orthant.</p><p>For example, consider a two-dimensional case and call the orthants <span>$O_1, …, O_4$</span> in clockwise fashion, starting with the nonnegative orthant. We conclude that</p><p class="math-container">\[    \text{rectify}(X) = (X ∩ O_1) ∪ \text{rectify}(X ∩ O_2) ∪ \text{rectify}(X ∩ O_3) ∪ \text{rectify}(X ∩ O_4).\]</p><p>The rectification of the intersection in the nonpositive orthant, <span>$\text{rectify}(X ∩ O_3)$</span>, is either the empty set or the singleton containing the origin. The rectification of <span>$X ∩ O_2$</span> and <span>$X ∩ O_4$</span> both result in flat <span>$1$</span>-dimensional line segments on the corresponding hyperplane of <span>$O_1$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/LazyOperations/Rectification.jl#L28-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.set-Tuple{Rectification}" href="#LazySets.set-Tuple{Rectification}"><code>LazySets.set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set(r::Rectification)</code></pre><p>Return the original set of a rectification.</p><p><strong>Input</strong></p><ul><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p>The original set of the rectification.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/LazyOperations/Rectification.jl#L120-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.dim-Tuple{Rectification}" href="#LazySets.dim-Tuple{Rectification}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dim(r::Rectification)</code></pre><p>Return the dimension of a rectification.</p><p><strong>Input</strong></p><ul><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the rectification.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/LazyOperations/Rectification.jl#L137-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{T,1} where T,Rectification}" href="#LazySets.σ-Tuple{AbstractArray{T,1} where T,Rectification}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">σ(d::AbstractVector, r::Rectification)</code></pre><p>Return the support vector of a rectification.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/LazyOperations/Rectification.jl#L154-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{T,1} where T,Rectification{N,var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:AbstractHyperrectangle{N}}} where N" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{T,1} where T,Rectification{N,var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:AbstractHyperrectangle{N}}} where N"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">σ(d::AbstractVector, r::Rectification{N, &lt;:AbstractHyperrectangle{N}}) where {N}</code></pre><p>Return the support vector of the rectification of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>r</code> – rectification of a hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>Let <span>$r(·)$</span> be the rectification of a vector respectively a set, and let <span>$H$</span> be a hyperrectangle. Then <span>$σ_{r(H)}(d) = r(σ_{H}(d))$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/LazyOperations/Rectification.jl#L176-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{T,1} where T,Rectification{N,var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:(CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N})}} where N" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{T,1} where T,Rectification{N,var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:(CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N})}} where N"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">σ(d::AbstractVector, r::Rectification{N, &lt;:CartesianProduct{N}}) where {N}</code></pre><p>Return the support vector of the rectification of a Cartesian product of two convex sets.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>r</code> – rectification of a Cartesian product of two convex sets</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>Rectification distributes with the Cartesian product. Let <span>$r(·)$</span> be the rectification of a set. We can just query the support vector for <span>$r(X)$</span> and <span>$r(Y)$</span> recursively: <span>$σ_{r(X × Y)}(d) = σ_{r(X)}(d_X) × σ_{r(Y)}(d_Y)$</span>, where <span>$x × y$</span> concatenates vectors <span>$x$</span> and <span>$y$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/LazyOperations/Rectification.jl#L200-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{T,1} where T,Rectification{N,var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:(CartesianProductArray{N,S} where S&lt;:LazySet{N})}} where N" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{T,1} where T,Rectification{N,var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:(CartesianProductArray{N,S} where S&lt;:LazySet{N})}} where N"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">σ(d::AbstractVector, r::Rectification{N, &lt;:CartesianProductArray{N}}) where {N}</code></pre><p>Return the support vector of the rectification of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>r</code> – rectification of a Cartesian product of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>Rectification distributes with the Cartesian product. Let <span>$r(·)$</span> be the rectification of a set. We can just query the support vector for each subspace recursively: <span>$σ_{r(X_1 × ⋯ × X_m)}(d) = σ_{r(X_1)}(d_{X_1}) × ⋯ × σ_{r(X_m)}(d_{X_m})$</span>, where <span>$x × y$</span> concatenates vectors <span>$x$</span> and <span>$y$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/LazyOperations/Rectification.jl#L229-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.ρ-Tuple{AbstractArray{T,1} where T,Rectification}" href="#LazySets.ρ-Tuple{AbstractArray{T,1} where T,Rectification}"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ρ(d::AbstractVector, r::Rectification)</code></pre><p>Evaluate the support function of a rectification of a convex set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>r</code> – rectification of a convex set</li></ul><p><strong>Output</strong></p><p>The support value of the rectification of a convex set in the given direction.</p><p><strong>Algorithm</strong></p><p>We use different procedures for different types of input sets. If the wrapped set has a suitable structure for which we can efficiently compute the support vector, we fall back to the evaluation of the support function by means of the support vector. Otherwise we compute the union of projections to obtain a precise result (see <a href="#LazySets.to_union_of_projections"><code>to_union_of_projections</code></a>), and then compute the support function for this union. (The union is cached internally, so subsequent queries are more efficient.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/LazyOperations/Rectification.jl#L264-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.an_element-Tuple{Rectification}" href="#LazySets.an_element-Tuple{Rectification}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">an_element(r::Rectification)</code></pre><p>Return some element of a rectification.</p><p><strong>Input</strong></p><ul><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p>An element in the rectification. The implementation relies on the <code>an_element</code> function of the wrapped set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/LazyOperations/Rectification.jl#L300-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{T,1} where T,Rectification}" href="#Base.:∈-Tuple{AbstractArray{T,1} where T,Rectification}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∈(x::AbstractVector, r::Rectification)</code></pre><p>Check whether a given point is contained in a rectification.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ r$</span>.</p><p><strong>Algorithm</strong></p><p>We first scan for negative entries in the vector. If there are any, the vector is not contained in the rectification.</p><p>Next we ask a membership query in the wrapped set. If the answer is positive, the vector is contained in the rectification.</p><p>Otherwise, we scan for zero entries in the vector. If there are none, membership reduces to membership in the wrapped set, and so the answer is negative.</p><p>Finally, if there are zero entries in the vector and the vector is not contained in the wrapped set, we give up and throw an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/LazyOperations/Rectification.jl#L318-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{Rectification}" href="#Base.isempty-Tuple{Rectification}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isempty(r::Rectification)</code></pre><p>Check whether a rectification is empty or not.</p><p><strong>Input</strong></p><ul><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/LazyOperations/Rectification.jl#L369-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isbounded-Union{Tuple{Rectification{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N" href="#LazySets.isbounded-Union{Tuple{Rectification{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isbounded(P::AbstractPolyhedron{N}; [solver]=default_lp_solver(N)) where {N}</code></pre><p>Determine whether a polyhedron is bounded.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polyhedron</li><li><code>solver</code>  – (optional, default: <code>default_lp_solver(N)</code>) the backend used              to solve the linear program</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the polyhedron is bounded</p><p><strong>Algorithm</strong></p><p>We first check if the polyhedron has more than <code>max(dim(P), 1)</code> constraints, which is a necessary condition for boundedness.</p><p>If so, we check boundedness via <a href="lib/sets/HPolyhedron/#LazySets._isbounded_stiemke-Union{Tuple{HPolyhedron{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N"><code>_isbounded_stiemke</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/Interfaces/AbstractPolyhedron_functions.jl#L918-L939">source</a></section><section><div><pre><code class="language-none">isbounded(r::Rectification{N}) where {N}</code></pre><p>Determine whether a rectification is bounded.</p><p><strong>Input</strong></p><ul><li><code>r</code> – rectification</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the rectification is bounded.</p><p><strong>Algorithm</strong></p><p>Let <span>$X$</span> be the set wrapped by rectification <span>$r$</span>. We first check whether <span>$X$</span> is bounded (because then <span>$r$</span> is bounded). Otherwise, we check unboundedness of <span>$X$</span> in direction <span>$(1, 1, …, 1)$</span>, which is sufficient for unboundedness of <span>$r$</span>; this step is not necessary but rather a heuristics. Otherwise, we check boundedness of <span>$X$</span> in every positive unit direction, which is sufficient and necessary for boundedness of <span>$r$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/LazyOperations/Rectification.jl#L386-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.to_union_of_projections" href="#LazySets.to_union_of_projections"><code>LazySets.to_union_of_projections</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_union_of_projections(r::Rectification{N},
                        concrete_intersection::Bool=false
                       ) where {N}</code></pre><p>Compute an equivalent union of projections from a rectification of a convex set.</p><p><strong>Input</strong></p><ul><li><code>r</code>                     – rectification of a convex set</li><li><code>concrete_intersection</code> – (optional, default: <code>false</code>) option to compute                            all intersections concretely or lazily</li></ul><p><strong>Algorithm</strong></p><p>Let <span>$X$</span> be the set wrapped by the rectification <span>$r$</span>. We compute a union of sets that represents the rectification of <span>$X$</span> precisely. The sets are lazy projections, potentially of intersections.</p><p>We first identify those dimensions where <span>$X$</span> is negative, using one support-function query per dimension, and collect the dimensions in the index set <span>$I_\text{neg}$</span>. For each element in <span>$I_\text{neg}$</span> we will later apply a projection to zero.</p><p>Next we identify those dimensions from <span>$I_\text{neg}$</span> where <span>$X$</span> is also positive, using another support-function query in each dimension, and collect the dimensions in the index set <span>$I_\text{mix}$</span>. Let us call the remaining dimensions (<span>$I_\text{neg} \setminus I_\text{mix}$</span>) <span>$I_\text{nonpos}$</span>. For each dimension in <span>$j ∈ I_\text{mix}$</span> we will apply an intersection with axis-aligned polyhedra. In particular, we distinguish two cases using half-spaces <span>$x_j ≤ 0$</span> and <span>$x_j ≥ 0$</span>, and then compute all possible combinations to intersect, using one half-space per dimension <span>$j ∈ I_\text{mix}$</span>.</p><p>Next we project the intersections in all dimensions from <span>$i ∈ I_\text{mix}$</span> such that we used the half-space <span>$x_i ≤ 0$</span> in their computation, and in all dimensions <span>$j ∈ I_\text{nonpos}$</span> irrespective of the half-space used.</p><p>Finally, we take the union of the resulting sets.</p><p><strong>Output</strong></p><p>The result can be one of three cases depending on the wrapped set <span>$X$</span>, namely</p><ul><li>the set <span>$X$</span> if <span>$X$</span> is contained in the positive quadrant,</li><li>a <code>LinearMap</code> (projection) of <span>$X$</span> if for each dimension, <span>$X$</span> is only either positive or negative, or</li><li>a <code>UnionSetArray</code> of <code>LinearMaps</code> (projections) otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/LazyOperations/Rectification.jl#L431-L479">source</a></section></article><p>Inherited from <a href="../../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../../interfaces/#LazySets.singleton_list-Tuple{LazySet}"><code>singleton_list</code></a></li></ul><h2 id="Rectification-cache"><a class="docs-heading-anchor" href="#Rectification-cache">Rectification cache</a><a id="Rectification-cache-1"></a><a class="docs-heading-anchor-permalink" href="#Rectification-cache" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.RectificationCache" href="#LazySets.RectificationCache"><code>LazySets.RectificationCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RectificationCache{N}</code></pre><p>Struct that is used as a cache for <a href="#LazySets.Rectification"><code>Rectification</code></a>s.</p><p><strong>Fields</strong></p><ul><li><code>set</code>                – set represented by the rectification (can be <code>nothing</code>                         if not computed yet)</li><li><code>use_support_vector</code> – flag indicating whether to use support-vector                         computations for the cached set</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a881ddd1e5caa74f2ea5dc5f6f29f5d8ba569ff0/src/LazyOperations/Rectification.jl#L5-L16">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../MinkowskiSum/">« MinkowskiSum</a><a class="docs-footer-nextpage" href="../ResetMap/">ResetMap »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 16 February 2021 02:15">Tuesday 16 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
