<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AffineMap · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link href="../../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../../"><img class="logo" src="../../../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../../man/getting_started/">Getting Started</a></li><li><a class="toctext" href="../../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="toctext" href="../../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="toctext" href="../../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="toctext" href="../../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="toctext" href="../../../man/interval_hulls/">Interval Hulls</a></li><li><a class="toctext" href="../../../man/convex_hulls/">Convex Hulls</a></li><li><a class="toctext" href="../../../man/set_operations/">Operations on Sets</a></li><li><a class="toctext" href="../../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="toctext" href="../../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="toctext" href="../../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="toctext" href="../../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../../interfaces/">Interfaces</a></li><li><span class="toctext">Sets</span><ul><li><a class="toctext" href="../../sets/Ball1/">Ball1</a></li><li><a class="toctext" href="../../sets/Ball2/">Ball2</a></li><li><a class="toctext" href="../../sets/BallInf/">BallInf</a></li><li><a class="toctext" href="../../sets/Ballp/">Ballp</a></li><li><a class="toctext" href="../../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="toctext" href="../../sets/EmptySet/">EmptySet</a></li><li><a class="toctext" href="../../sets/HalfSpace/">HalfSpace</a></li><li><a class="toctext" href="../../sets/HPolygon/">HPolygon</a></li><li><a class="toctext" href="../../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="toctext" href="../../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="toctext" href="../../sets/HPolytope/">HPolytope</a></li><li><a class="toctext" href="../../sets/Hyperplane/">Hyperplane</a></li><li><a class="toctext" href="../../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="toctext" href="../../sets/Interval/">Interval</a></li><li><a class="toctext" href="../../sets/Line/">Line</a></li><li><a class="toctext" href="../../sets/LineSegment/">LineSegment</a></li><li><a class="toctext" href="../../sets/PolynomialZonotope/">PolynomialZonotope</a></li><li><a class="toctext" href="../../sets/Singleton/">Singleton</a></li><li><a class="toctext" href="../../sets/Universe/">Universe</a></li><li><a class="toctext" href="../../sets/VPolygon/">VPolygon</a></li><li><a class="toctext" href="../../sets/VPolytope/">VPolytope</a></li><li><a class="toctext" href="../../sets/ZeroSet/">ZeroSet</a></li><li><a class="toctext" href="../../sets/Zonotope/">Zonotope</a></li></ul></li><li><span class="toctext">Lazy Operations</span><ul><li class="current"><a class="toctext" href>AffineMap</a><ul class="internal"></ul></li><li><a class="toctext" href="../Bloating/">Bloating</a></li><li><a class="toctext" href="../CartesianProduct/">CartesianProduct</a></li><li><a class="toctext" href="../Complement/">Complement</a></li><li><a class="toctext" href="../ConvexHull/">ConvexHull</a></li><li><a class="toctext" href="../ExponentialMap/">ExponentialMap</a></li><li><a class="toctext" href="../Intersection/">Intersection</a></li><li><a class="toctext" href="../LinearMap/">LinearMap</a></li><li><a class="toctext" href="../MinkowskiSum/">MinkowskiSum</a></li><li><a class="toctext" href="../Rectification/">Rectification</a></li><li><a class="toctext" href="../ResetMap/">ResetMap</a></li><li><a class="toctext" href="../SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="toctext" href="../Translation/">Translation</a></li><li><a class="toctext" href="../UnionSet/">UnionSet</a></li></ul></li><li><a class="toctext" href="../../binary_functions/">Concrete Operations</a></li><li><a class="toctext" href="../../conversion/">Conversions between set representations</a></li><li><a class="toctext" href="../../comparisons/">Comparisons</a></li><li><a class="toctext" href="../../approximations/">Approximations</a></li><li><a class="toctext" href="../../utils/">Utility Functions</a></li><li><a class="toctext" href="../../parallel/">Parallel</a></li></ul></li><li><a class="toctext" href="../../../about/">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li>Lazy Operations</li><li><a href>AffineMap</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/lazy_operations/AffineMap.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>AffineMap</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="def_AffineMap-1" href="#def_AffineMap-1">Affine map (AffineMap)</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AffineMap" href="#LazySets.AffineMap"><code>LazySets.AffineMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AffineMap{N&lt;:Real, S&lt;:LazySet{N}, NM, MAT&lt;:AbstractMatrix{NM},
          VN&lt;:AbstractVector{NM}} &lt;: LazySet{N}</code></pre><p>Type that represents an affine transformation <span>$M⋅X ⊕ v$</span> of a convex set <span>$X$</span>.</p><p><strong>Fields</strong></p><ul><li><code>M</code> – matrix/linear map</li><li><code>X</code> – convex set</li><li><code>v</code> – translation vector</li></ul><p><strong>Notes</strong></p><p>An affine map is the composition of a linear map and a translation. This type is parametric in the coefficients of the linear map, <code>NM</code>, which may be different from the numeric type of the wrapped set (<code>N</code>). However, the numeric type of the translation vector should be <code>NM</code>.</p><p><strong>Examples</strong></p><p>For the examples we create a <span>$3×2$</span> matrix, a two-dimensional unit square, and a three-dimensional vector. Then we combine them in an <code>AffineMap</code>.</p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 1 3; 1 4]; X = BallInf([0, 0], 1); b2 = [1, 2]; b3 = [1, 2, 3];

julia&gt; AffineMap(A, X, b3)
AffineMap{Int64,BallInf{Int64},Int64,Array{Int64,2},Array{Int64,1}}([1 2; 1 3; 1 4], BallInf{Int64}([0, 0], 1), [1, 2, 3])</code></pre><p>For convenience, <code>A</code> does not need to be a matrix but we also allow to use <code>UniformScaling</code>s resp. scalars (interpreted as a scaling, i.e., a scaled identity matrix). Scaling by <span>$1$</span> is ignored and simplified to a pure <code>Translation</code>.</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra

julia&gt; am = AffineMap(2I, X, b2)
AffineMap{Int64,BallInf{Int64},Int64,Diagonal{Int64,Array{Int64,1}},Array{Int64,1}}([2 0; 0 2], BallInf{Int64}([0, 0], 1), [1, 2])

julia&gt; AffineMap(2, X, b2) == am
true

julia&gt; AffineMap(1, X, b2)
Translation{Int64,Array{Int64,1},BallInf{Int64}}(BallInf{Int64}([0, 0], 1), [1, 2])</code></pre><p>Applying a linear map to an <code>AffineMap</code> object combines the two maps into a new <code>AffineMap</code> instance. Again we can make use of the conversion for convenience.</p><pre><code class="language-julia-repl">julia&gt; B = [2 0; 0 2]; am2 = B * am
AffineMap{Int64,BallInf{Int64},Int64,Array{Int64,2},Array{Int64,1}}([4 0; 0 4], BallInf{Int64}([0, 0], 1), [2, 4])

julia&gt; 2 * am == am2
true</code></pre><p>The application of an <code>AffineMap</code> to a <code>ZeroSet</code> or an <code>EmptySet</code> is simplified automatically.</p><pre><code class="language-julia-repl">julia&gt; AffineMap(A, ZeroSet{Int}(2), b3)
Singleton{Int64,Array{Int64,1}}([1, 2, 3])

julia&gt; AffineMap(A, EmptySet{Int}(2), b3)
EmptySet{Int64}(2)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8809b65aeb8b3215e5941fdc15801869f0f013ef/src/LazyOperations/AffineMap.jl#L12-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{AffineMap}" href="#LazySets.dim-Tuple{AffineMap}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(am::AffineMap)</code></pre><p>Return the dimension of an affine map.</p><p><strong>Input</strong></p><ul><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>The dimension of an affine map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8809b65aeb8b3215e5941fdc15801869f0f013ef/src/LazyOperations/AffineMap.jl#L156-L168">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, am::AffineMap{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of an affine map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8809b65aeb8b3215e5941fdc15801869f0f013ef/src/LazyOperations/AffineMap.jl#L173-L186">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, am::AffineMap{N}) where {N&lt;:Real}</code></pre><p>Return the support function of an affine map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8809b65aeb8b3215e5941fdc15801869f0f013ef/src/LazyOperations/AffineMap.jl#L191-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{AffineMap}" href="#LazySets.an_element-Tuple{AffineMap}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(am::AffineMap)</code></pre><p>Return some element of an affine map.</p><p><strong>Input</strong></p><ul><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>An element of the affine map. It relies on the <code>an_element</code> function of the wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8809b65aeb8b3215e5941fdc15801869f0f013ef/src/LazyOperations/AffineMap.jl#L209-L222">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{AffineMap}" href="#Base.isempty-Tuple{AffineMap}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(am::AffineMap)</code></pre><p>Return whether an affine map is empty or not.</p><p><strong>Input</strong></p><ul><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty and the affine vector is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8809b65aeb8b3215e5941fdc15801869f0f013ef/src/LazyOperations/AffineMap.jl#L227-L239">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{AffineMap}" href="#LazySets.isbounded-Tuple{AffineMap}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(am::AffineMap; cond_tol::Number=DEFAULT_COND_TOL)</code></pre><p>Determine whether an affine map is bounded.</p><p><strong>Input</strong></p><ul><li><code>am</code>       – affine map</li><li><code>cond_tol</code> – (optional) tolerance of matrix condition (used to check whether               the matrix is invertible)</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the affine map is bounded.</p><p><strong>Algorithm</strong></p><p>We first check if the matrix is zero or the wrapped set is bounded. If not, we perform a sufficient check whether the matrix is invertible. If the matrix is invertible, then the map being bounded is equivalent to the wrapped set being bounded, and hence the map is unbounded. Otherwise, we check boundedness via <a href="../../interfaces/#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>isbounded_unit_dimensions</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8809b65aeb8b3215e5941fdc15801869f0f013ef/src/LazyOperations/AffineMap.jl#L244-L266">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, am::AffineMap{N}) where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in the affine map of a convex set.</p><p><strong>Input</strong></p><ul><li><code>x</code>  – point/vector</li><li><code>am</code> – affine map of a convex set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ am$</span>.</p><p><strong>Algorithm</strong></p><p>Note that <span>$x ∈ M⋅S ⊕ v$</span> iff <span>$M^{-1}⋅(x - v) ∈ S$</span>. This implementation does not explicitly invert the matrix, which is why it also works for non-square matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; am = AffineMap([2.0 0.0; 0.0 1.0], BallInf([1., 1.], 1.), [-1.0, -1.0]);

julia&gt; [5.0, 1.0] ∈ am
false

julia&gt; [3.0, 1.0] ∈ am
true</code></pre><p>An example with a non-square matrix:</p><pre><code class="language-julia-repl">julia&gt; B = BallInf(zeros(4), 1.);

julia&gt; M = [1. 0 0 0; 0 1 0 0]/2;

julia&gt; [0.5, 0.5] ∈ M*B
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8809b65aeb8b3215e5941fdc15801869f0f013ef/src/LazyOperations/AffineMap.jl#L277-L319">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(am::AffineMap{N}; [apply_convex_hull]::Bool) where {N&lt;:Real}</code></pre><p>Return the list of vertices of a (polyhedral) affine map.</p><p><strong>Input</strong></p><ul><li><code>am</code>                – affine map</li><li><code>apply_convex_hull</code> – (optional, default: <code>true</code>) if <code>true</code>, apply the convex                        hull operation to the list of vertices transformed by the                        affine map</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>This implementation computes all vertices of <code>X</code>, then transforms them through the affine map, i.e. <code>x ↦ M*x + v</code> for each vertex <code>x</code> of <code>X</code>. By default, the convex hull operation is taken before returning this list. For dimensions three or higher, this operation relies on the functionality through the concrete polyhedra library <code>Polyhedra.jl</code>.</p><p>If you are not interested in taking the convex hull of the resulting vertices under the affine map, pass <code>apply_convex_hull=false</code> as a keyword argument.</p><p>Note that we assume that the underlying set <code>X</code> is polyhedral, either concretely or lazily, i.e. there the function <code>vertices_list</code> should be applicable.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8809b65aeb8b3215e5941fdc15801869f0f013ef/src/LazyOperations/AffineMap.jl#L324-L353">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(am::AffineMap{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of a (polyhedral) affine map.</p><p><strong>Input</strong></p><ul><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>The list of constraints of the affine map.</p><p><strong>Notes</strong></p><p>We assume that the underlying set <code>X</code> is polyhedral, i.e., offers a method <code>constraints_list(X)</code>.</p><p><strong>Algorithm</strong></p><p>Falls back to the list of constraints of the translation of a lazy linear map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8809b65aeb8b3215e5941fdc15801869f0f013ef/src/LazyOperations/AffineMap.jl#L366-L387">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AffineMap{N,S,NM,MAT,VN} where VN&lt;:AbstractArray{NM,1} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, am::AffineMap{N}) where {N&lt;:Real}</code></pre><p>Return the linear map of a lazy affine map.</p><p><strong>Input</strong></p><ul><li><code>M</code>  – matrix</li><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>A set corresponding to the linear map of the lazy affine map of a set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/8809b65aeb8b3215e5941fdc15801869f0f013ef/src/LazyOperations/AffineMap.jl#L392-L405">source</a></section><footer><hr/><a class="previous" href="../../sets/Zonotope/"><span class="direction">Previous</span><span class="title">Zonotope</span></a><a class="next" href="../Bloating/"><span class="direction">Next</span><span class="title">Bloating</span></a></footer></article></body></html>
