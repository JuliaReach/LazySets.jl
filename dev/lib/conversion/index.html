<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conversions between set representations · LazySets.jl</title><meta name="title" content="Conversions between set representations · LazySets.jl"/><meta property="og:title" content="Conversions between set representations · LazySets.jl"/><meta property="twitter:title" content="Conversions between set representations · LazySets.jl"/><meta name="description" content="Documentation for LazySets.jl."/><meta property="og:description" content="Documentation for LazySets.jl."/><meta property="twitter:description" content="Documentation for LazySets.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/aligned.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LazySets.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../man/optional_dependencies/">Optional Features</a></li><li><a class="tocitem" href="../../man/tour/">A Tour of LazySets</a></li><li><a class="tocitem" href="../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../man/unary_set_operations/">Unary Operations on Sets</a></li><li><a class="tocitem" href="../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../API/">API</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Set Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../interfaces/overview/">Overview</a></li><li><a class="tocitem" href="../interfaces/LazySet/">General sets (LazySet)</a></li><li><a class="tocitem" href="../interfaces/ConvexSet/">Convex sets (ConvexSet)</a></li><li><a class="tocitem" href="../interfaces/AbstractCentrallySymmetric/">Centrally symmetric sets (AbstractCentrallySymmetric)</a></li><li><a class="tocitem" href="../interfaces/AbstractPolyhedron/">Polyhedra (AbstractPolyhedron)</a></li><li><a class="tocitem" href="../interfaces/AbstractPolytope/">Polytopes (AbstractPolytope)</a></li><li><a class="tocitem" href="../interfaces/AbstractPolygon/">Polygons (AbstractPolygon)</a></li><li><a class="tocitem" href="../interfaces/AbstractHPolygon/">Polygons in constraint representation (AbstractHPolygon)</a></li><li><a class="tocitem" href="../interfaces/AbstractCentrallySymmetricPolytope/">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a></li><li><a class="tocitem" href="../interfaces/AbstractZonotope/">Zonotopes (AbstractZonotope)</a></li><li><a class="tocitem" href="../interfaces/AbstractHyperrectangle/">Hyperrectangles (AbstractHyperrectangle)</a></li><li><a class="tocitem" href="../interfaces/AbstractSingleton/">Singletons (AbstractSingleton)</a></li><li><a class="tocitem" href="../interfaces/AbstractAffineMap/">Affine maps (AbstractAffineMap)</a></li><li><a class="tocitem" href="../interfaces/AbstractPolynomialZonotope/">Polynomial zonotope sets (AbstractPolynomialZonotope)</a></li><li><a class="tocitem" href="../interfaces/AbstractSparsePolynomialZonotope/">Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)</a></li><li><a class="tocitem" href="../interfaces/AbstractBallp/">Balls in the p-norm (AbstractBallp)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../sets/DensePolynomialZonotope/">DensePolynomialZonotope</a></li><li><a class="tocitem" href="../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../sets/HParallelotope/">HParallelotope</a></li><li><a class="tocitem" href="../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../sets/Line/">Line</a></li><li><a class="tocitem" href="../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../sets/Polygon/">Polygon</a></li><li><a class="tocitem" href="../sets/SimpleSparsePolynomialZonotope/">SimpleSparsePolynomialZonotope</a></li><li><a class="tocitem" href="../sets/SparsePolynomialZonotope/">SparsePolynomialZonotope</a></li><li><a class="tocitem" href="../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../sets/Star/">Star</a></li><li><a class="tocitem" href="../sets/Tetrahedron/">Tetrahedron</a></li><li><a class="tocitem" href="../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../sets/Zonotope/">Zonotope</a></li><li><a class="tocitem" href="../sets/ZonotopeMD/">ZonotopeMD</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lazy_operations/AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../lazy_operations/Bloating/">Bloating</a></li><li><a class="tocitem" href="../lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../lazy_operations/Complement/">Complement</a></li><li><a class="tocitem" href="../lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../lazy_operations/Intersection/">Intersection</a></li><li><a class="tocitem" href="../lazy_operations/LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../lazy_operations/InverseLinearMap/">InverseLinearMap</a></li><li><a class="tocitem" href="../lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../lazy_operations/QuadraticMap/">QuadraticMap</a></li><li><a class="tocitem" href="../lazy_operations/Rectification/">Rectification</a></li><li><a class="tocitem" href="../lazy_operations/ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../lazy_operations/Translation/">Translation</a></li><li><a class="tocitem" href="../lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Concrete Binary Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../concrete_binary_operations/overview/">Binary set operations</a></li><li><a class="tocitem" href="../concrete_binary_operations/cartesian_product/">Cartesian Product</a></li><li><a class="tocitem" href="../concrete_binary_operations/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../concrete_binary_operations/difference/">Set difference</a></li><li><a class="tocitem" href="../concrete_binary_operations/distance/">Distance</a></li><li><a class="tocitem" href="../concrete_binary_operations/intersection/">Intersection of two sets</a></li><li><a class="tocitem" href="../concrete_binary_operations/minkowski_sum/">Minkowski Sum</a></li><li><a class="tocitem" href="../concrete_binary_operations/minkowski_difference/">Minkowski Difference</a></li><li><a class="tocitem" href="../concrete_binary_operations/isdisjoint/">Check for Disjointness of Sets</a></li><li><a class="tocitem" href="../concrete_binary_operations/issubset/">Subset Check</a></li></ul></li><li class="is-active"><a class="tocitem" href>Conversions between set representations</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Approximations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../approximations/overview/">Overview</a></li><li><a class="tocitem" href="../approximations/overapproximate/">Overapproximation</a></li><li><a class="tocitem" href="../approximations/box_approximation/">Box Approximation</a></li><li><a class="tocitem" href="../approximations/iterative_refinement/">Iterative refinement</a></li><li><a class="tocitem" href="../approximations/template_directions/">Template directions</a></li><li><a class="tocitem" href="../approximations/underapproximate/">Underapproximation</a></li><li><a class="tocitem" href="../approximations/approximate/">Approximation</a></li><li><a class="tocitem" href="../approximations/decompose/">Cartesian Decomposition</a></li><li><a class="tocitem" href="../approximations/hausdorff_distance/">Hausdorff Distance</a></li><li><a class="tocitem" href="../approximations/overapproximate_norm/">Norm Overapproximation</a></li><li><a class="tocitem" href="../approximations/overapproximate_expmap/">Overapproximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">MatrixSets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../matrixsets/MatrixZonotope/">MatrixZonotope</a></li></ul></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li><a class="tocitem" href="../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Conversions between set representations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Conversions between set representations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/conversion.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Conversion-between-set-representations"><a class="docs-heading-anchor" href="#Conversion-between-set-representations">Conversion between set representations</a><a id="Conversion-between-set-representations-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-between-set-representations" title="Permalink"></a></h1><p>This section of the manual lists the conversion functions between set representations.</p><ul><li><a href="#Conversion-between-set-representations">Conversion between set representations</a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{Interval}, Rectification{N, &lt;:Interval}}} where N" href="#Base.convert-Union{Tuple{N}, Tuple{Type{Interval}, Rectification{N, &lt;:Interval}}} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Interval}, R::Rectification{N,&lt;:Interval}) where {N}</code></pre><p>Convert a rectification of an interval to an interval.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – target type</li><li><code>R</code>        – rectification of an interval</li></ul><p><strong>Output</strong></p><p>An <code>Interval</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/Interval.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{IT}, Tuple{N}, Tuple{Type{Interval}, MinkowskiSum{N, IT, IT}}} where {N, IT&lt;:Interval}" href="#Base.convert-Union{Tuple{IT}, Tuple{N}, Tuple{Type{Interval}, MinkowskiSum{N, IT, IT}}} where {N, IT&lt;:Interval}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Interval}, ms::MinkowskiSum{N, IT, IT}) where {N, IT&lt;:Interval}</code></pre><p>Convert the Minkowski sum of two intervals to an interval.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – target type</li><li><code>ms</code>       – Minkowski sum of two intervals</li></ul><p><strong>Output</strong></p><p>An interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/Interval.jl#L19-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Hyperrectangle}, CartesianProduct{N, HN1, HN2}}} where {N, HN1&lt;:AbstractHyperrectangle, HN2&lt;:AbstractHyperrectangle}" href="#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Hyperrectangle}, CartesianProduct{N, HN1, HN2}}} where {N, HN1&lt;:AbstractHyperrectangle, HN2&lt;:AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Hyperrectangle}, cp::CartesianProduct{N, HN1, HN2})
    where {N, HN1&lt;:AbstractHyperrectangle, HN2&lt;:AbstractHyperrectangle}</code></pre><p>Convert the Cartesian product of two hyperrectangular sets to a single hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – target type</li><li><code>S</code>              – Cartesian product of two hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>The result is obtained by concatenating the center and radius of each hyperrectangle. This implementation uses the <code>center</code> and <code>radius_hyperrectangle</code> methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/Hyperrectangle.jl#L37-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Hyperrectangle}, CartesianProductArray{N, HN}}} where {N, HN&lt;:AbstractHyperrectangle}" href="#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Hyperrectangle}, CartesianProductArray{N, HN}}} where {N, HN&lt;:AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Hyperrectangle}, cpa::CartesianProductArray{N, HN})
    where {N, HN&lt;:AbstractHyperrectangle}</code></pre><p>Convert the Cartesian product of a finite number of hyperrectangular sets to a single hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – target type</li><li><code>S</code>              – Cartesian product array of hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>This implementation uses the <code>center</code> and <code>radius_hyperrectangle</code> methods of <code>AbstractHyperrectangle</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/Hyperrectangle.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{IN}, Tuple{N}, Tuple{Type{Hyperrectangle}, CartesianProductArray{N, IN}}} where {N, IN&lt;:Interval}" href="#Base.convert-Union{Tuple{IN}, Tuple{N}, Tuple{Type{Hyperrectangle}, CartesianProductArray{N, IN}}} where {N, IN&lt;:Interval}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Hyperrectangle},
        cpa::CartesianProductArray{N, IN}) where {N, IN&lt;:Interval}</code></pre><p>Convert the Cartesian product of a finite number of intervals to a single hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – target type</li><li><code>S</code>              – Cartesian product array of intervals</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>This implementation uses the <code>min</code> and <code>max</code> methods of <code>Interval</code> to reduce the allocations and improve performance (see LazySets#1143).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/Hyperrectangle.jl#L68-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{AH}, Tuple{N}, Tuple{Type{Hyperrectangle}, Rectification{N, AH}}} where {N, AH&lt;:AbstractHyperrectangle}" href="#Base.convert-Union{Tuple{AH}, Tuple{N}, Tuple{Type{Hyperrectangle}, Rectification{N, AH}}} where {N, AH&lt;:AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Hyperrectangle}, r::Rectification{N, AH})
    where {N, AH&lt;:AbstractHyperrectangle}</code></pre><p>Convert a rectification of a hyperrectangle to a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – target type</li><li><code>r</code>              – rectification of a hyperrectangle</li></ul><p><strong>Output</strong></p><p>A <code>Hyperrectangle</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/Hyperrectangle.jl#L102-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolygon}, LazySet}" href="#Base.convert-Tuple{Type{HPolygon}, LazySet}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{HPolygon}, X::LazySet; [check_boundedness]::Bool=true,
        prune::Bool=true)</code></pre><p>Convert a two-dimensional polytopic set to a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPolygon</code>             – target type</li><li><code>X</code>                 – two-dimensional polytopic set</li><li><code>check_boundedness</code> – (optional, default <code>!isboundedtype(typeof(X))</code>) if                        <code>true</code> check whether the set <code>X</code> is bounded before                        creating the polygon</li><li><code>prune</code>             – (optional, default: <code>true</code>) flag for removing redundant                        constraints in the end</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p><p><strong>Algorithm</strong></p><p>We compute the list of constraints of <code>X</code>, then instantiate the polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/convert.jl#L52-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolygon}, VPolygon}" href="#Base.convert-Tuple{Type{HPolygon}, VPolygon}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(T::Type{HPolygon}, P::VPolygon)</code></pre><p>Convert a polygon in vertex representation to a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPolygon</code> – target type</li><li><code>P</code>     – polygon in vertex representation</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/convert.jl#L88-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{HPolygon}, LineSegment{N, VN} where VN&lt;:AbstractVector{N}}} where N" href="#Base.convert-Union{Tuple{N}, Tuple{Type{HPolygon}, LineSegment{N, VN} where VN&lt;:AbstractVector{N}}} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{HPolygon}, L::LineSegment{N}) where {N}</code></pre><p>Convert a line segment to a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPolygon</code> – target type</li><li><code>L</code>     – line segment</li><li><code>prune</code> – (optional, default: <code>false</code>) flag for removing redundant            constraints in the end</li></ul><p><strong>Output</strong></p><p>A flat polygon in constraint representation with the minimal number of constraints (four).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/convert.jl#L107-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolygonOpt}, LazySet}" href="#Base.convert-Tuple{Type{HPolygonOpt}, LazySet}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{HPolygonOpt}, X::LazySet; [check_boundedness]::Bool=true,
        prune::Bool=true)</code></pre><p>Convert a two-dimensional polytopic set to a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPolygonOpt</code>             – target type</li><li><code>X</code>                 – two-dimensional polytopic set</li><li><code>check_boundedness</code> – (optional, default <code>!isboundedtype(typeof(X))</code>) if                        <code>true</code> check whether the set <code>X</code> is bounded before                        creating the polygon</li><li><code>prune</code>             – (optional, default: <code>true</code>) flag for removing redundant                        constraints in the end</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p><p><strong>Algorithm</strong></p><p>We compute the list of constraints of <code>X</code>, then instantiate the polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/convert.jl#L52-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolygonOpt}, VPolygon}" href="#Base.convert-Tuple{Type{HPolygonOpt}, VPolygon}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(T::Type{HPolygonOpt}, P::VPolygon)</code></pre><p>Convert a polygon in vertex representation to a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPolygonOpt</code> – target type</li><li><code>P</code>     – polygon in vertex representation</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/convert.jl#L88-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{HPolygonOpt}, LineSegment{N, VN} where VN&lt;:AbstractVector{N}}} where N" href="#Base.convert-Union{Tuple{N}, Tuple{Type{HPolygonOpt}, LineSegment{N, VN} where VN&lt;:AbstractVector{N}}} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{HPolygonOpt}, L::LineSegment{N}) where {N}</code></pre><p>Convert a line segment to a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPolygonOpt</code> – target type</li><li><code>L</code>     – line segment</li><li><code>prune</code> – (optional, default: <code>false</code>) flag for removing redundant            constraints in the end</li></ul><p><strong>Output</strong></p><p>A flat polygon in constraint representation with the minimal number of constraints (four).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/convert.jl#L107-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolygon}, AbstractHPolygon}" href="#Base.convert-Tuple{Type{VPolygon}, AbstractHPolygon}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{VPolygon}, P::AbstractHPolygon)</code></pre><p>Convert a polygon in constraint representation to a polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>VPolygon</code> – target type</li><li><code>P</code>        – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>A polygon in vertex representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/VPolygon.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{ZN}, Tuple{N}, Tuple{Type{Zonotope}, LinearMap{N, ZN, NM} where NM}} where {N, ZN&lt;:AbstractZonotope}" href="#Base.convert-Union{Tuple{ZN}, Tuple{N}, Tuple{Type{Zonotope}, LinearMap{N, ZN, NM} where NM}} where {N, ZN&lt;:AbstractZonotope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Zonotope}, S::LinearMap{N, ZN})
    where {N, ZN&lt;:AbstractZonotope}</code></pre><p>Convert the lazy linear map of a zonotopic set to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – target type</li><li><code>S</code>        – linear map of a zonotopic set</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method first applies the (concrete) linear map to the zonotopic set and then converts the result to a <code>Zonotope</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/Zonotope.jl#L121-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope}, LinearMap{N, CartesianProduct{N, HN1, HN2}, NM} where NM}} where {N, HN1&lt;:AbstractHyperrectangle, HN2&lt;:AbstractHyperrectangle}" href="#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope}, LinearMap{N, CartesianProduct{N, HN1, HN2}, NM} where NM}} where {N, HN1&lt;:AbstractHyperrectangle, HN2&lt;:AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Zonotope}, S::LinearMap{N, CartesianProduct{N, HN1, HN2}}
       ) where {N, HN1&lt;:AbstractHyperrectangle,
                HN2&lt;:AbstractHyperrectangle}</code></pre><p>Convert the lazy linear map of the Cartesian product of two hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – target type</li><li><code>S</code>        – linear map of the Cartesian product of hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method first converts the Cartesian product to a zonotope, and then applies the (concrete) linear map to the zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/Zonotope.jl#L145-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope}, LinearMap{N, CartesianProductArray{N, HN}, NM} where NM}} where {N, HN&lt;:AbstractHyperrectangle}" href="#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope}, LinearMap{N, CartesianProductArray{N, HN}, NM} where NM}} where {N, HN&lt;:AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Zonotope},S::LinearMap{N, CartesianProductArray{N, HN}})
    where {N, HN&lt;:AbstractHyperrectangle}</code></pre><p>Convert the lazy linear map of the Cartesian product of a finite number of hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – target type</li><li><code>S</code>        – linear map of a <code>CartesianProductArray</code> of hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method first converts the Cartesian product array to a zonotope, and then applies the (concrete) linear map to the zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/Zonotope.jl#L173-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{ZN2}, Tuple{ZN1}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProduct{N, ZN1, ZN2}}} where {N, ZN1&lt;:AbstractZonotope, ZN2&lt;:AbstractZonotope}" href="#Base.convert-Union{Tuple{ZN2}, Tuple{ZN1}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProduct{N, ZN1, ZN2}}} where {N, ZN1&lt;:AbstractZonotope, ZN2&lt;:AbstractZonotope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Zonotope}, cp::CartesianProduct{N, ZN1, ZN2}
       ) where {N, ZN1&lt;:AbstractZonotope, ZN2&lt;:AbstractZonotope}</code></pre><p>Convert the Cartesian product of two zonotopic sets to a new zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – target type</li><li><code>S</code>        – Cartesian product of two zonotopic sets</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>The Cartesian product is obtained by:</p><ul><li>Concatenating the centers of each input zonotope.</li><li>Arranging the generators in block-diagonal fashion, and filled with zeros in the off-diagonal; for this reason, the generator matrix of the returned zonotope is built as a sparse matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/Zonotope.jl#L199-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProduct{N, HN1, HN2}}} where {N, HN1&lt;:AbstractHyperrectangle, HN2&lt;:AbstractHyperrectangle}" href="#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProduct{N, HN1, HN2}}} where {N, HN1&lt;:AbstractHyperrectangle, HN2&lt;:AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Zonotope}, cp::CartesianProduct{N, HN1, HN2}) where {N,
        HN1&lt;:AbstractHyperrectangle, HN2&lt;:AbstractHyperrectangle}</code></pre><p>Convert the Cartesian product of two hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – target type</li><li><code>cp</code>       – Cartesian product of two hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>This method falls back to the conversion of the Cartesian product to a single hyperrectangle, and then from a hyperrectangle to a zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/Zonotope.jl#L74-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{AZ}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProductArray{N, AZ}}} where {N, AZ&lt;:AbstractZonotope}" href="#Base.convert-Union{Tuple{AZ}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProductArray{N, AZ}}} where {N, AZ&lt;:AbstractZonotope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Zonotope}, cpa::CartesianProductArray{N, AZ})
    where {N, AZ&lt;:AbstractZonotope}</code></pre><p>Convert a Cartesian product array of zonotopic sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – target type</li><li><code>cpa</code>       – Cartesian product array of zonotopic sets</li></ul><p><strong>Output</strong></p><p>A zonotope with sparse matrix representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/Zonotope.jl#L239-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProductArray{N, HN}}} where {N, HN&lt;:AbstractHyperrectangle}" href="#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope}, CartesianProductArray{N, HN}}} where {N, HN&lt;:AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{Zonotope}, cpa::CartesianProductArray{N, HN})
    where {N, HN&lt;:AbstractHyperrectangle}</code></pre><p>Convert the Cartesian product array of hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – target type</li><li><code>cpa</code>      – Cartesian product array of hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method falls back to the conversion of the Cartesian product to a single hyperrectangle, and then from a hyperrectangle to a zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/Zonotope.jl#L96-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProduct{N, Interval{N}, Interval{N}}}, AbstractHyperrectangle{N}}} where N" href="#Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProduct{N, Interval{N}, Interval{N}}}, AbstractHyperrectangle{N}}} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{CartesianProduct{N, Interval{N}, Interval{N}}},
        H::AbstractHyperrectangle{N}) where {N}</code></pre><p>Convert a two-dimensional hyperrectangle to the Cartesian product of two intervals.</p><p><strong>Input</strong></p><ul><li><code>CartesianProduct</code> – target type</li><li><code>H</code>                – hyperrectangle</li></ul><p><strong>Output</strong></p><p>The Cartesian product of two intervals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/CartesianProduct.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProductArray{N, Interval{N}}}, AbstractHyperrectangle{N}}} where N" href="#Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProductArray{N, Interval{N}}}, AbstractHyperrectangle{N}}} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{CartesianProductArray{N, Interval{N}}},
        H::AbstractHyperrectangle{N}) where {N}</code></pre><p>Convert a hyperrectangle to the Cartesian product array of intervals.</p><p><strong>Input</strong></p><ul><li><code>CartesianProductArray</code> – target type</li><li><code>H</code>                     – hyperrectangle</li></ul><p><strong>Output</strong></p><p>The Cartesian product of a finite number of intervals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/CartesianProductArray.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{ST}, Tuple{N}, Tuple{Type{MinkowskiSumArray}, MinkowskiSum{N, ST, MinkowskiSumArray{N, ST}}}} where {N, ST}" href="#Base.convert-Union{Tuple{ST}, Tuple{N}, Tuple{Type{MinkowskiSumArray}, MinkowskiSum{N, ST, MinkowskiSumArray{N, ST}}}} where {N, ST}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{MinkowskiSumArray},
        X::MinkowskiSum{N, ST, MinkowskiSumArray{N, ST}}) where {N, ST}</code></pre><p>Convert the Minkowski sum of a Minkowski sum array to a Minkowski sum array.</p><p><strong>Input</strong></p><ul><li><code>MinkowskiSumArray</code>  – target type</li><li><code>X</code>                  – Minkowski sum of a Minkowski sum array</li></ul><p><strong>Output</strong></p><p>A Minkowski sum array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/MinkowskiSumArray.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{AffineMap{N, PT, N, MN, VN} where {N, VN&lt;:AbstractVector{N}, MN&lt;:AbstractMatrix{N}, PT&lt;:AbstractPolyhedron{N}}}, AbstractPolyhedron{N}}} where N" href="#Base.convert-Union{Tuple{N}, Tuple{Type{AffineMap{N, PT, N, MN, VN} where {N, VN&lt;:AbstractVector{N}, MN&lt;:AbstractMatrix{N}, PT&lt;:AbstractPolyhedron{N}}}, AbstractPolyhedron{N}}} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{STAR}, P::AbstractPolyhedron{N}) where {N}</code></pre><p>Convert a polyhedral set to a star set represented as a lazy affine map.</p><p><strong>Input</strong></p><ul><li><code>STAR</code> – target type</li><li><code>P</code>    – polyhedral set</li></ul><p><strong>Output</strong></p><p>A star set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/AffineMap.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Tuple{Type{AffineMap{N, PT, N, MN, VN} where {N, VN&lt;:AbstractVector{N}, MN&lt;:AbstractMatrix{N}, PT&lt;:AbstractPolyhedron{N}}}, Star}" href="#Base.convert-Tuple{Type{AffineMap{N, PT, N, MN, VN} where {N, VN&lt;:AbstractVector{N}, MN&lt;:AbstractMatrix{N}, PT&lt;:AbstractPolyhedron{N}}}, Star}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{STAR}, X::Star)</code></pre><p>Convert a star set to its equivalent representation as a lazy affine map.</p><p><strong>Input</strong></p><ul><li><code>STAR</code> – target type</li><li><code>X</code>    – star set</li></ul><p><strong>Output</strong></p><p>A star set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/AffineMap.jl#L22-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Tuple{Type{SimpleSparsePolynomialZonotope}, AbstractZonotope}" href="#Base.convert-Tuple{Type{SimpleSparsePolynomialZonotope}, AbstractZonotope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{SimpleSparsePolynomialZonotope}, Z::AbstractZonotope)</code></pre><p>Convert a zonotope to a simple sparse polynomial zonotope.</p><p><strong>Input</strong></p><ul><li><code>SimpleSparsePolynomialZonotope</code> – target type</li><li><code>Z</code>                              – zonotopic set</li></ul><p><strong>Output</strong></p><p>A simple sparse polynomial zonotope.</p><p><strong>Algorithm</strong></p><p>This method implements <a href="../../bibliography/#KochdumperA21">Kochdumper and Althoff [KA21]</a>, Proposition 3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/SimpleSparsePolynomialZonotope.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Tuple{Type{SparsePolynomialZonotope}, AbstractZonotope}" href="#Base.convert-Tuple{Type{SparsePolynomialZonotope}, AbstractZonotope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{SparsePolynomialZonotope}, Z::AbstractZonotope; [algorithm]=&quot;GI&quot;)</code></pre><p>Convert a zonotope to sparse polynomial zonotope.</p><p><strong>Input</strong></p><ul><li><code>SparsePolynomialZonotope</code> – target type</li><li><code>Z</code>                        – zonotopic set</li><li><code>algorithm</code>                – (optional, default: <code>&quot;GI&quot;</code>) algorithm</li></ul><p><strong>Output</strong></p><p>A sparse polynomial zonotope.</p><p><strong>Algorithm</strong></p><p>The <code>&quot;GI&quot;</code> method creates a polynomial zonotope with only independent generators.</p><p>The <code>&quot;K21&quot;</code> method creates a polynomial zonotope with only dependent generators, implementing <a href="../../bibliography/#Kochdumper21a">Kochdumper [Koc22]</a>, Proposition 3.1.9.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/SparsePolynomialZonotope.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{SparsePolynomialZonotope}, SimpleSparsePolynomialZonotope{N, VN, MN} where {VN&lt;:AbstractVector{N}, MN&lt;:AbstractMatrix{N}}}} where N" href="#Base.convert-Union{Tuple{N}, Tuple{Type{SparsePolynomialZonotope}, SimpleSparsePolynomialZonotope{N, VN, MN} where {VN&lt;:AbstractVector{N}, MN&lt;:AbstractMatrix{N}}}} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{SparsePolynomialZonotope}, SSPZ::SimpleSparsePolynomialZonotope)</code></pre><p>Convert a simple sparse polynomial zonotope to a sparse polynomial zonotope.</p><p><strong>Input</strong></p><ul><li><code>SparsePolynomialZonotope</code> – target type</li><li><code>SSPZ</code>                     – simple sparse polynomial zonotope</li></ul><p><strong>Output</strong></p><p>A sparse polynomial zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/Convert/SparsePolynomialZonotope.jl#L50-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Tuple{Type{MatrixZonotope}, IntervalMatrices.IntervalMatrix}" href="#Base.convert-Tuple{Type{MatrixZonotope}, IntervalMatrices.IntervalMatrix}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{MatrixZonotope}, IM::IntervalMatrix)</code></pre><p>Convert an interval matrix to a matrix zonotope</p><p><strong>Input</strong></p><ul><li><code>MatrixZonotope</code> – target type</li><li><code>IM</code> – an interval matrix</li></ul><p><strong>Output</strong></p><p>A matrix zonotope with one generator</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LazySets, IntervalMatrices

julia&gt; IM = IntervalMatrix([interval(-1.1, -0.9) interval(-4.1, -3.9);
            interval(3.9, 4.1) interval(-1.1, -0.9)])
2×2 IntervalMatrix{Float64, IntervalArithmetic.Interval{Float64}, Matrix{IntervalArithmetic.Interval{Float64}}}:
 [-1.10001, -0.9]  [-4.1, -3.89999]
  [3.89999, 4.1]   [-1.10001, -0.9]

julia&gt; MZ = convert(MatrixZonotope, IM)
MatrixZonotope{Float64, Matrix{Float64}}([-1.0 -4.0; 4.0 -1.0], [[0.10000000000000009 0.10000000000000009; 0.10000000000000009 0.10000000000000009]], [1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6326714273f8e4217ad224750c6accc3df1b0118/src/MatrixSets/convert.jl#L5-L33">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../concrete_binary_operations/issubset/">« Subset Check</a><a class="docs-footer-nextpage" href="../approximations/overview/">Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Thursday 30 October 2025 21:36">Thursday 30 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
