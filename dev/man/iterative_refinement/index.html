<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Iterative Refinement · LazySets.jl</title><meta name="title" content="Iterative Refinement · LazySets.jl"/><meta property="og:title" content="Iterative Refinement · LazySets.jl"/><meta property="twitter:title" content="Iterative Refinement · LazySets.jl"/><meta name="description" content="Documentation for LazySets.jl."/><meta property="og:description" content="Documentation for LazySets.jl."/><meta property="twitter:description" content="Documentation for LazySets.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/aligned.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LazySets.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../optional_dependencies/">Optional Features</a></li><li><a class="tocitem" href="../tour/">A Tour of LazySets</a></li><li><a class="tocitem" href="../convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../fast_2d_LPs/">Fast 2D LPs</a></li><li class="is-active"><a class="tocitem" href>Iterative Refinement</a><ul class="internal"><li><a class="tocitem" href="#Local-approximations"><span>Local approximations</span></a></li><li><a class="tocitem" href="#Refinement"><span>Refinement</span></a></li><li><a class="tocitem" href="#Algorithm"><span>Algorithm</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li></ul></li><li><a class="tocitem" href="../interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../unary_set_operations/">Unary Operations on Sets</a></li><li><a class="tocitem" href="../reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/API/">API</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Set Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lib/interfaces/overview/">Overview</a></li><li><a class="tocitem" href="../../lib/interfaces/LazySet/">General sets (LazySet)</a></li><li><a class="tocitem" href="../../lib/interfaces/ConvexSet/">Convex sets (ConvexSet)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractCentrallySymmetric/">Centrally symmetric sets (AbstractCentrallySymmetric)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractPolyhedron/">Polyhedra (AbstractPolyhedron)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractPolytope/">Polytopes (AbstractPolytope)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractPolygon/">Polygons (AbstractPolygon)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractHPolygon/">Polygons in constraint representation (AbstractHPolygon)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractCentrallySymmetricPolytope/">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractZonotope/">Zonotopes (AbstractZonotope)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractHyperrectangle/">Hyperrectangles (AbstractHyperrectangle)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractSingleton/">Singletons (AbstractSingleton)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractAffineMap/">Affine maps (AbstractAffineMap)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractPolynomialZonotope/">Polynomial zonotope sets (AbstractPolynomialZonotope)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractSparsePolynomialZonotope/">Sparse polynomial zonotope sets (AbstractSparsePolynomialZonotope)</a></li><li><a class="tocitem" href="../../lib/interfaces/AbstractBallp/">Balls in the p-norm (AbstractBallp)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lib/sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../../lib/sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../../lib/sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../../lib/sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../../lib/sets/DensePolynomialZonotope/">DensePolynomialZonotope</a></li><li><a class="tocitem" href="../../lib/sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../../lib/sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../../lib/sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../../lib/sets/HParallelotope/">HParallelotope</a></li><li><a class="tocitem" href="../../lib/sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../../lib/sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../../lib/sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../../lib/sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../../lib/sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../../lib/sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../../lib/sets/Interval/">Interval</a></li><li><a class="tocitem" href="../../lib/sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../../lib/sets/Line/">Line</a></li><li><a class="tocitem" href="../../lib/sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../../lib/sets/Polygon/">Polygon</a></li><li><a class="tocitem" href="../../lib/sets/SimpleSparsePolynomialZonotope/">SimpleSparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../lib/sets/SparsePolynomialZonotope/">SparsePolynomialZonotope</a></li><li><a class="tocitem" href="../../lib/sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../../lib/sets/Star/">Star</a></li><li><a class="tocitem" href="../../lib/sets/Tetrahedron/">Tetrahedron</a></li><li><a class="tocitem" href="../../lib/sets/Universe/">Universe</a></li><li><a class="tocitem" href="../../lib/sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../../lib/sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../../lib/sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../../lib/sets/Zonotope/">Zonotope</a></li><li><a class="tocitem" href="../../lib/sets/ZonotopeMD/">ZonotopeMD</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lib/lazy_operations/AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../../lib/lazy_operations/Bloating/">Bloating</a></li><li><a class="tocitem" href="../../lib/lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../../lib/lazy_operations/Complement/">Complement</a></li><li><a class="tocitem" href="../../lib/lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../../lib/lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../../lib/lazy_operations/Intersection/">Intersection</a></li><li><a class="tocitem" href="../../lib/lazy_operations/LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../../lib/lazy_operations/InverseLinearMap/">InverseLinearMap</a></li><li><a class="tocitem" href="../../lib/lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../../lib/lazy_operations/QuadraticMap/">QuadraticMap</a></li><li><a class="tocitem" href="../../lib/lazy_operations/Rectification/">Rectification</a></li><li><a class="tocitem" href="../../lib/lazy_operations/ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../../lib/lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../../lib/lazy_operations/Translation/">Translation</a></li><li><a class="tocitem" href="../../lib/lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Concrete Binary Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lib/concrete_binary_operations/overview/">Binary set operations</a></li><li><a class="tocitem" href="../../lib/concrete_binary_operations/cartesian_product/">Cartesian Product</a></li><li><a class="tocitem" href="../../lib/concrete_binary_operations/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../lib/concrete_binary_operations/difference/">Set difference</a></li><li><a class="tocitem" href="../../lib/concrete_binary_operations/distance/">Distance</a></li><li><a class="tocitem" href="../../lib/concrete_binary_operations/intersection/">Intersection of two sets</a></li><li><a class="tocitem" href="../../lib/concrete_binary_operations/minkowski_sum/">Minkowski Sum</a></li><li><a class="tocitem" href="../../lib/concrete_binary_operations/minkowski_difference/">Minkowski Difference</a></li><li><a class="tocitem" href="../../lib/concrete_binary_operations/isdisjoint/">Check for Disjointness of Sets</a></li><li><a class="tocitem" href="../../lib/concrete_binary_operations/issubset/">Subset Check</a></li></ul></li><li><a class="tocitem" href="../../lib/conversion/">Conversions between set representations</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Approximations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lib/approximations/overview/">Overview</a></li><li><a class="tocitem" href="../../lib/approximations/overapproximate/">Overapproximation</a></li><li><a class="tocitem" href="../../lib/approximations/box_approximation/">Box Approximation</a></li><li><a class="tocitem" href="../../lib/approximations/iterative_refinement/">Iterative refinement</a></li><li><a class="tocitem" href="../../lib/approximations/template_directions/">Template directions</a></li><li><a class="tocitem" href="../../lib/approximations/underapproximate/">Underapproximation</a></li><li><a class="tocitem" href="../../lib/approximations/approximate/">Approximation</a></li><li><a class="tocitem" href="../../lib/approximations/decompose/">Cartesian Decomposition</a></li><li><a class="tocitem" href="../../lib/approximations/hausdorff_distance/">Hausdorff Distance</a></li><li><a class="tocitem" href="../../lib/approximations/overapproximate_norm/">Norm Overapproximation</a></li><li><a class="tocitem" href="../../lib/approximations/overapproximate_expmap/">Overapproximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">MatrixSets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lib/matrixsets/MatrixZonotope/">MatrixZonotope</a></li></ul></li><li><a class="tocitem" href="../../lib/utils/">Utilities</a></li><li><a class="tocitem" href="../../lib/parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Iterative Refinement</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Iterative Refinement</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/man/iterative_refinement.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Iterative-Refinement"><a class="docs-heading-anchor" href="#Iterative-Refinement">Iterative Refinement</a><a id="Iterative-Refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Iterative-Refinement" title="Permalink"></a></h1><p>This section of the manual describes an approximation method for an arbitrary two-dimensional convex set <span>$S$</span> and a given error bound <span>$ε$</span> using support vectors. The basic idea is to add new supporting directions whenever the approximation error is still bigger than <span>$ε$</span>.</p><ul><li><a href="#Iterative-Refinement">Iterative Refinement</a></li><li class="no-marker"><ul><li><a href="#Local-approximations">Local approximations</a></li><li><a href="#Refinement">Refinement</a></li><li><a href="#Algorithm">Algorithm</a></li><li><a href="#Example">Example</a></li></ul></li></ul><h2 id="Local-approximations"><a class="docs-heading-anchor" href="#Local-approximations">Local approximations</a><a id="Local-approximations-1"></a><a class="docs-heading-anchor-permalink" href="#Local-approximations" title="Permalink"></a></h2><p>The polygonal approximation of an arbitrary lazy convex set <code>S</code> is represented by a list of local approximations or refinements. More precisely, a <em>local approximation</em> is a triple <span>$(p_1, p_2, q)$</span>, where:</p><ul><li><span>$p_1$</span> and <span>$p_2$</span> belong to <span>$S$</span></li><li>the segments <span>$(p_1 q)$</span> and <span>$(p_2 q)$</span> belong to support lines of <span>$S$</span></li></ul><p>Since <span>$S$</span> is assumed to be convex, the segment <span>$(p_1 p_2)$</span> is inside <span>$S$</span>. Taking each support line <span>$(p_1 q)$</span> of a given list of local approximations of <span>$S$</span>, we can build a polygon in constraint representation that overapproximates <code>S</code>.</p><p>The type <code>LocalApproximation{N}</code> implements a local approximation; it is parametric in the numeric type <code>N</code>, and also contains additional information regarding the quality of the approximation: The <code>refinable</code> field is a boolean that is <code>true</code> whenever the approximation can be improved, and <code>err</code> is an upper bound on the exact Hausdorff distance of the approximation with respect to the exact set <code>S</code>.</p><p>Given the unit ball in the 2-norm, below we plot the local approximation along the East and North directions.</p><pre><code class="language-julia hljs">using Plots, LazySets, LazySets.Approximations

b = Ball2(zeros(2), 1.)

plot(b, 1e-3, aspectratio=1, alpha=0.3, legend=false)

plot!(Singleton([1.0, 0.0]), annotations=(1.1, 0.1, text(&quot;p1&quot;)), color=&quot;green&quot;)
plot!(Singleton([0.0, 1.0]), annotations=(0.1, 1.1, text(&quot;p2&quot;)), color=&quot;green&quot;)
plot!(Singleton([1.0, 1.0]), annotations=(1.09, 1.1, text(&quot;q&quot;)))
plot!(Singleton([0.0, 0.0]), annotations=(0.1, 0.0, text(&quot;0&quot;)), color=&quot;green&quot;)
plot!(annotations=(1.4, 0.1, text(&quot;d1&quot;)))
plot!(annotations=(0.1, 1.4, text(&quot;d2&quot;)))
plot!(annotations=(0.75, 0.8, text(&quot;ndir&quot;)))

plot!(x-&gt;x, x-&gt;1., -0.8, 1.3, line=1, color=&quot;black&quot;, linestyle=:dash)
plot!(x-&gt;1., x-&gt;x, -0.8, 1.3, line=1, color=&quot;black&quot;, linestyle=:dash)
plot!(x-&gt;x+1, x-&gt;0., 0.0, 0.4, line=1, color=&quot;red&quot;, linestyle=:solid, arrow=true)
plot!(x-&gt;0., x-&gt;x+1, 0.0, 0.4, line=1, color=&quot;red&quot;, linestyle=:solid, arrow=true)
plot!(x-&gt;-x, x-&gt;x+1, -1.2, .2, line=1., color=&quot;black&quot;, linestyle=:dashdot)
plot!(x-&gt;x+.6, x-&gt;x+.6, -.1, .08, line=1, color=&quot;red&quot;, linestyle=:solid, arrow=true)</code></pre><img src="f5443e12.svg" alt="Example block output"/><p>We can instantiate and append this approximation to a fresh <code>PolygonalOverapproximation</code> object, which is a type that wraps a set and a list of <code>LocalApproximation</code>s. The approximation is refinable, since it can be &quot;split&quot; along <code>ndir</code>, where <code>ndir</code> is the direction normal to the line <span>$(p_1 p_2)$</span> (shown dash-dotted in the figure), providing two approximations which are closer to the given set in Hausdorff distance.</p><pre><code class="language-julia hljs">using LazySets.Approximations: PolygonalOverapproximation, addapproximation!

Ω = PolygonalOverapproximation(b)
p1, d1, p2, d2 = [1.0, 0.0], [1.0, 0.0], [0.0, 1.0], [0.0, 1.0]
approx_EAST_NORTH = addapproximation!(Ω, p1, d1, p2, d2)

approx_EAST_NORTH.refinable</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>The associated error is <span>$\sqrt{2}-1 ≈ 0.414213$</span>, which is the distance between the point <span>$q$</span> and the intersection between the line <span>$(0 q)$</span> and the circle. Note that this point corresponds to the support vector of the set <code>b</code> along <code>ndir</code>.</p><pre><code class="language-julia hljs">approx_EAST_NORTH.err</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.414213562373095</code></pre><p>The refined approximation is computed next.</p><h2 id="Refinement"><a class="docs-heading-anchor" href="#Refinement">Refinement</a><a id="Refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Refinement" title="Permalink"></a></h2><p>Basically, the refinement step consists of splitting the local approximation <span>$(p_1, p_2, q)$</span> into two local approximations <span>$(p_1, s, q&#39;)$</span> and <span>$(s, p_2, q&#39;&#39;)$</span>, where <code>s</code> is the support vector of <span>$S$</span> along <code>ndir</code>.</p><p>To illustrate this, first let&#39;s add the remaining three approximations to <code>Ω</code> along the canonical directions, to build a box overapproximation of <code>b</code>.</p><pre><code class="language-julia hljs">using LazySets.Approximations: refine, tohrep

plot(b, 1e-3, aspectratio=1, alpha=0.3)

# initialize box directions
DIR_EAST, DIR_NORTH, DIR_WEST, DIR_SOUTH = [1., 0.], [0., 1.], [-1., 0.], [0., -1.]
pE, pN, pW, pS = σ(DIR_EAST, b), σ(DIR_NORTH, b), σ(DIR_WEST, b), σ(DIR_SOUTH, b)

Ω = PolygonalOverapproximation(b)
addapproximation!(Ω, pS, DIR_SOUTH, pE, DIR_EAST)
addapproximation!(Ω, pW, DIR_WEST, pS, DIR_SOUTH)
addapproximation!(Ω, pN, DIR_NORTH, pW, DIR_WEST)
addapproximation!(Ω, pE, DIR_EAST, pN, DIR_NORTH)

plot!(tohrep(Ω), alpha=0.2, color=&quot;orange&quot;)</code></pre><img src="e8619b2f.svg" alt="Example block output"/><p>Next we refine the first approximation of the list.</p><pre><code class="language-julia hljs">approx = pop!(Ω.approx_stack)
(r1, r2) = refine(approx, Ω.S)
push!(Ω.approx_stack, r2)
push!(Ω.approx_stack, r1)

plot(b, 1e-3, aspectratio=1, alpha=0.3)
plot!(tohrep(Ω), alpha=0.2, color=&quot;orange&quot;)</code></pre><img src="79be4f90.svg" alt="Example block output"/><p>We call <code>r1</code> and <code>r2</code> the right and left approximations respectively, since they are saved in counter-clockwise order. We can check that the first two approximations are still refinable.</p><pre><code class="language-julia hljs">Ω.approx_stack[end].refinable,  Ω.approx_stack[end-1].refinable</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(true, true)</code></pre><p>Hence, we can make again a refinement of that approximation.</p><pre><code class="language-julia hljs">approx = pop!(Ω.approx_stack)
(r1, r2) = refine(approx, Ω.S)
push!(Ω.approx_stack, r2)
push!(Ω.approx_stack, r1)

plot(b, 1e-3, aspectratio=1, alpha=0.3)
plot!(tohrep(Ω), alpha=0.2, color=&quot;orange&quot;)</code></pre><img src="64d8ea10.svg" alt="Example block output"/><p>The criterion for an approximation being refinable is that we can properly define a normal direction <code>ndir</code>. This boils down to checking for the following &quot;degenerate&quot; cases:</p><ol><li><span>$p_1$</span> and <span>$p_2$</span> overlap.</li><li><span>$p_1$</span> and <span>$q$</span> overlap.</li><li><span>$p_2$</span> and <span>$q$</span> overlap.</li></ol><p>Moreover, we include the condition <code>approx_error &gt; TOL</code> where <code>TOL</code> is the floating point epsilon in the given numerical precision.</p><h2 id="Algorithm"><a class="docs-heading-anchor" href="#Algorithm">Algorithm</a><a id="Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm" title="Permalink"></a></h2><p>Having presented the individual steps, we give the pseudocode of the iterative refinement algorithm, see <code>overapproximate_hausdorff(S, ε)</code>.</p><p>The algorithm consists of the following steps:</p><ol><li><em>Initialization</em>. The approximation is initialized with box directions, i.e. it starts with four <code>LocalApproximation</code> objects. Let <code>i=1</code>.</li><li><em>Refinement loop</em>. If the local approximation at index <code>i</code> has an error greater than the threshold <code>ε</code>, then refine. Otherwise, increment <code>i &lt;- i+1</code>.</li><li><em>Redundancy check</em>. Insert the refined right approximation at position <code>i</code>, and check whether the left approximation is redundant or not with respect to the one at position <code>i+1</code>. Checking for redundancy amounts to checking for overlap of both <code>p1</code> and <code>q</code>. Then, either substitute at <code>i+1</code> or insert (keeping the approximation at <code>i+1</code>) depending on the redundancy check.</li><li><em>Stopping criterion</em>. Terminate if the index <code>i</code> exceeds the current length of the approximations list; otherwise continue with step 2.</li></ol><p>Observe that the algorithm finishes when all approximations are such that their associated error is smaller than <code>ε</code>, hence the Hausdorff distance between <code>S</code> and its polygonal overapproximation is no greater than <code>ε</code>.</p><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>As a final example consider the iterative refinement of the ball <code>b</code> for different values of the approximation threshold <code>ε</code>.</p><pre><code class="language-julia hljs">using LazySets.Approximations: overapproximate_hausdorff

p0 = plot(b, 1e-6, aspectratio=1)
p1 = plot!(p0, overapproximate(b, 1.), alpha=0.4, aspectratio=1)

p0 = plot(b, 1e-6, aspectratio=1)
p2 = plot!(p0, overapproximate(b, 0.1), alpha=0.4, aspectratio=1)

p0 = plot(b, 1e-6, aspectratio=1)
p3 = plot!(p0, overapproximate(b, 0.01), alpha=0.4, aspectratio=1)

plot(p1, p2, p3, layout=(1, 3))</code></pre><img src="0b7222d6.svg" alt="Example block output"/><p>Meanwhile, the number of constraints of the polygonal overapproximation increases, in this example by a power of 2 when the error is divided by a factor 10.</p><pre><code class="language-julia hljs">h = ε -&gt;  length(overapproximate_hausdorff(b, ε).constraints)
h(1.), h(0.1), h(0.01)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(4, 8, 32)</code></pre><div class="admonition is-info" id="Note-2445115100049656"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2445115100049656" title="Permalink"></a></header><div class="admonition-body"><p>Actually, the plotting function for an arbitrary convex <code>LazySet</code>, <code>plot(...)</code> (called <em>recipe</em> in the context of <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>), receives a numeric argument <code>ε</code> and the routine itself calls <code>overapproximate</code>. However, some sets such as abstract polygons have their own plotting recipe and hence do not require the error threshold, since they are plotted exactly as the convex hull of their vertices.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fast_2d_LPs/">« Fast 2D LPs</a><a class="docs-footer-nextpage" href="../interval_hulls/">Interval Hulls »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Saturday 1 November 2025 05:25">Saturday 1 November 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
