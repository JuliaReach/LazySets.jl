<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Approximations · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/getting_started.html">Getting Started</a></li><li><a class="toctext" href="../man/polyhedral_approximations.html">Polyhedral Approximations</a></li><li><a class="toctext" href="../man/decompose_example.html">Decomposing an Affine Map</a></li><li><a class="toctext" href="../man/fast_2d_LPs.html">Fast 2D LPs</a></li><li><a class="toctext" href="../man/iterative_refinement.html">Iterative Refinement</a></li><li><a class="toctext" href="../man/interval_hulls.html">Interval Hulls</a></li><li><a class="toctext" href="../man/convex_hulls.html">Convex Hulls</a></li><li><a class="toctext" href="../man/set_operations.html">Operations on Sets</a></li><li><a class="toctext" href="../man/reach_zonotopes.html">A Reachability Algorithm</a></li><li><a class="toctext" href="../man/reach_zonotopes_hybrid.html">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../man/concrete_polyhedra.html">Concrete Polyhedra</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="interfaces.html">Set Interfaces</a></li><li><a class="toctext" href="representations.html">Common Set Representations</a></li><li><a class="toctext" href="operations.html">Common Set Operations</a></li><li><a class="toctext" href="conversion.html">Conversion between set representations</a></li><li><a class="toctext" href="binary_functions.html">Binary Functions on Sets</a></li><li class="current"><a class="toctext" href="approximations.html">Approximations</a><ul class="internal"><li><a class="toctext" href="#Cartesian-Decomposition-1">Cartesian Decomposition</a></li><li><a class="toctext" href="#Overapproximations-1">Overapproximations</a></li><li><a class="toctext" href="#Box-Approximations-1">Box Approximations</a></li><li><a class="toctext" href="#Iterative-refinement-1">Iterative refinement</a></li></ul></li><li><a class="toctext" href="utils.html">Utility Functions</a></li></ul></li><li><a class="toctext" href="../about.html">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="approximations.html">Approximations</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/approximations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Approximations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Approximations-1" href="#Approximations-1">Approximations</a></h1><p>This section of the manual describes the Cartesian decomposition algorithms and the approximation of high-dimensional convex sets using projections.</p><ul><li><a href="approximations.html#Approximations-1">Approximations</a></li><ul><li><a href="approximations.html#Cartesian-Decomposition-1">Cartesian Decomposition</a></li><li><a href="approximations.html#Overapproximations-1">Overapproximations</a></li><li><a href="approximations.html#Box-Approximations-1">Box Approximations</a></li><ul><li><a href="approximations.html#Metric-properties-of-sets-1">Metric properties of sets</a></li></ul><li><a href="approximations.html#Iterative-refinement-1">Iterative refinement</a></li></ul></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations" href="#LazySets.Approximations"><code>LazySets.Approximations</code></a> — <span class="docstring-category">Module</span>.</div><div><p>Module <code>Approximations.jl</code> – polygonal approximation of convex sets through support vectors.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/Approximations.jl#L3-L6">source</a></section><h2><a class="nav-anchor" id="Cartesian-Decomposition-1" href="#Cartesian-Decomposition-1">Cartesian Decomposition</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.decompose" href="#LazySets.Approximations.decompose"><code>LazySets.Approximations.decompose</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">decompose(S::LazySet{N};
          [set_type]::Type{&lt;:Union{HPolygon, Hyperrectangle, Interval}}=Hyperrectangle,
          [ɛ]::Real=Inf,
          [blocks]::AbstractVector{Int}=default_block_structure(S, set_type),
          [block_types]::Dict{Type{&lt;:LazySet}, AbstractVector{&lt;:AbstractVector{Int}}}
         )::CartesianProductArray where {N&lt;:Real}</code></pre><p>Decompose a high-dimensional set into a Cartesian product of overapproximations of the projections over the specified subspaces.</p><p><strong>Input</strong></p><ul><li><p><code>S</code>           – set</p></li><li><p><code>set_type</code>    – (optional, default: <code>Hyperrectangle</code>) type of set approximation                  for each subspace</p></li><li><p><code>ɛ</code>           – (optional, default: <code>Inf</code>) error bound for polytopic approximation</p></li><li><p><code>blocks</code>      – (optional, default: [2, …, 2] or [1, …, 1] if <code>set_type</code> is an interval)                  block structure - a vector with the size of each block</p></li><li><p><code>block_types</code> – (optional, default: Interval for 1D and Hyperrectangle                  for mD blocks) a mapping from set types to blocks</p></li></ul><p><strong>Output</strong></p><p>A <code>CartesianProductArray</code> containing the low-dimensional approximated projections.</p><p><strong>Algorithm</strong></p><p>For each block a specific <code>project</code> method is called, dispatched on the <code>set_type</code> argument.</p><p><strong>Notes</strong></p><p>If <code>block_types</code> is given, the options <code>set_type</code> and <code>blocks</code> are ignored.</p><p><strong>Examples</strong></p><p>The <code>decompose</code> function supports different options, such as: supplying different dimensions for the decomposition, defining the target set of the decomposition, or specifying the degree of accuracy of the target decomposition. These options are exemplified below.</p><p><strong>Different dimensions</strong></p><p>By default, <code>decompose</code> returns a Cartesian product of 2D <code>Hyperrectangle</code> sets. For example:</p><pre><code class="language-julia-repl">julia&gt; import LazySets.Approximations:decompose

julia&gt; S = Ball2(zeros(4), 1.);

julia&gt; array(decompose(S))
2-element Array{LazySets.LazySet{Float64},1}:
 LazySets.Hyperrectangle{Float64}([0.0, 0.0], [1.0, 1.0])
 LazySets.Hyperrectangle{Float64}([0.0, 0.0], [1.0, 1.0])</code></pre><p>Other block sizes can be specified using the <code>blocks</code> option, which refers to each block size of the partition:</p><pre><code class="language-julia-repl">julia&gt; array(decompose(S, blocks=[1, 3]))
2-element Array{LazySets.LazySet{Float64},1}:
 LazySets.Hyperrectangle{Float64}([0.0], [1.0])
 LazySets.Hyperrectangle{Float64}([0.0, 0.0, 0.0], [1.0, 1.0, 1.0])

julia&gt; array(decompose(S, blocks=[4]))
1-element Array{LazySets.LazySet{Float64},1}:
 LazySets.Hyperrectangle{Float64}([0.0, 0.0, 0.0, 0.0], [1.0, 1.0, 1.0, 1.0])</code></pre><p><strong>Different set types</strong></p><p>We can also decompose using polygons in constraint representation, through the <code>set_type</code> optional argument:</p><pre><code class="language-julia-repl">julia&gt; [ai isa HPolygon for ai in array(decompose(S, set_type=HPolygon))]
2-element Array{Bool,1}:
 true
 true</code></pre><p>For decomposition into 1D subspaces, we can use <code>Interval</code>:</p><pre><code class="language-julia-repl">julia&gt; [ai isa Interval for ai in array(decompose(S, set_type=Interval))]
4-element Array{Bool,1}:
 true
 true
 true
 true</code></pre><p>However, if you need to specify different set types for different blocks, the interface presented so far does not apply. In the paragraph <em>Advanced different set types input</em> we explain <code>block_types</code>, useful precisely for that purpose.</p><p><strong>Refining the decomposition</strong></p><p>The <span>$ɛ$</span> option can be used to refine, that is obtain a more accurate decomposition in those blocks where <code>HPolygon</code> types are used, and it relies on the iterative refinement algorithm provided in the <code>Approximations</code> module.</p><p>To illustrate this, consider the unit 4D ball in the 2-norm. Using smaller <span>$ɛ$</span> implies a better precision, thus more constraints in each 2D decomposition:</p><pre><code class="language-julia-repl">julia&gt; S = Ball2(zeros(4), 1.);

julia&gt; d(ε, bi) = array(decompose(S, set_type=HPolygon, ε=ε))[bi]
d (generic function with 1 method)

julia&gt; [length(constraints_list(d(ε, 1))) for ε in [Inf, 0.1, 0.01]]
3-element Array{Int64,1}:
  4
  8
 32</code></pre><p><strong>Advanced different set types input</strong></p><p>We can define different set types for different blocks, using the optional <code>block_types</code> input argument. It is a dictionary where the keys correspond to set types, and the values correspond to the blocks, namely the initial and final block indices should be given.</p><p>For example:</p><pre><code class="language-julia-repl">julia&gt; S = Ball2(zeros(3), 1.);

julia&gt; array(decompose(S, block_types=Dict(Interval=&gt;[1:1], Hyperrectangle=&gt;[2:3])))
2-element Array{LazySets.LazySet{Float64},1}:
 LazySets.Interval{Float64,IntervalArithmetic.Interval{Float64}}([-1, 1])
 LazySets.Hyperrectangle{Float64}([0.0, 0.0], [1.0, 1.0])</code></pre><p>We can additionally pass ε, which is automatically used for each <code>HPolygon</code> type block.</p><pre><code class="language-julia-repl">julia&gt; S = Ball2(zeros(8), 1.);

julia&gt; bt = Dict(Interval=&gt;[1:1], Hyperrectangle=&gt;[2:4], HPolygon=&gt;[5:6, 7:8]);

julia&gt; [typeof(ai) for ai in array(decompose(S, block_types=bt, ε=0.01))]
4-element Array{DataType,1}:
 LazySets.Interval{Float64,IntervalArithmetic.Interval{Float64}}
 LazySets.Hyperrectangle{Float64}
 LazySets.HPolygon{Float64}
 LazySets.HPolygon{Float64}</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/decompositions.jl#L34-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.default_block_structure" href="#LazySets.Approximations.default_block_structure"><code>LazySets.Approximations.default_block_structure</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">default_block_structure(S::LazySet, set_type::Type{&lt;:LazySet})::AbstractVector{Int}</code></pre><p>Compute the default block structure.</p><p><strong>Input</strong></p><ul><li><p><code>S</code>        – set</p></li><li><p><code>set_type</code> – target set type</p></li></ul><p><strong>Output</strong></p><p>A vector representing the block structure, such that:</p><ul><li><p>If the target <code>set_type</code> is an interval, the default is blocks of size 1.</p></li><li><p>Otherwise, the default is blocks of size 2. Depending on the dimension, the last block has size 1 or 2.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/decompositions.jl#L1-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.project" href="#LazySets.Approximations.project"><code>LazySets.Approximations.project</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">project(S::LazySet{N},
        block::AbstractVector{Int},
        set_type::Type{&lt;:LazySet},
        [n]::Int=dim(S),
        [ɛ]::Real=Inf
       )::LazySet{N} where {N&lt;:Real}</code></pre><p>Default implementation for projecting a high-dimensional set to a given set type with possible overapproximation.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set</p></li><li><p><code>block</code> – block structure - a vector with the dimensions of interest</p></li><li><p><code>set_type</code> – target set type</p></li><li><p><code>n</code> – (optional, default: <code>dim(S)</code>) ambient dimension of the set <code>S</code></p></li><li><p><code>ɛ</code> – (optional, default: <code>Inf</code>) ignored</p></li></ul><p><strong>Output</strong></p><p>A set of type <code>set_type</code> representing an overapproximation of the projection of <code>S</code>.</p><p><strong>Algorithm</strong></p><ol><li><p>Project the set <code>S</code> with <code>M⋅S</code>, where <code>M</code> is the identity matrix in the block coordinates and zero otherwise.</p></li><li><p>Overapproximate the projected lazy set using <code>overapproximate</code>.</p></li></ol></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/decompositions.jl#L231-L259">source</a><div><pre><code class="language-none">project(S::LazySet{N},
        block::AbstractVector{Int},
        set_type::Type{&lt;:HPolygon},
        [n]::Int=dim(S),
        [ɛ]::Real=Inf
       )::HPolygon where {N&lt;:Real}</code></pre><p>Project a high-dimensional set to a two-dimensional polygon with a certified error bound.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set</p></li><li><p><code>block</code> – block structure - a vector with the dimensions of interest</p></li><li><p><code>set_type</code> – <code>HPolygon</code> - used for dispatch</p></li><li><p><code>n</code> – (optional, default: <code>dim(S)</code>) ambient dimension of the set <code>S</code></p></li><li><p><code>ɛ</code> – (optional, default: <code>Inf</code>) error bound for polytopic approximation</p></li></ul><p><strong>Output</strong></p><p>A <code>HPolygon</code> representing the epsilon-close approximation of the box approximation of the projection of <code>S</code>.</p><p><strong>Notes</strong></p><p><code>block</code> must have length 2.</p><p><strong>Algorithm</strong></p><p>If <code>ɛ &lt; Inf</code>, the algorithm proceeds as follows:</p><ol><li><p>Project the set <code>S</code> with <code>M⋅S</code>, where <code>M</code> is the identity matrix in the block coordinates and zero otherwise.</p></li><li><p>Overapproximate the set with the given error bound <code>ɛ</code>.</p></li></ol><p>If <code>ɛ == Inf</code>, the algorithm uses a box approximation.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/decompositions.jl#L270-L306">source</a><div><pre><code class="language-none">project(S::LazySet{N},
        block::AbstractVector{Int},
        set_type::Type{&lt;:Hyperrectangle},
        [n]::Int=dim(S),
        [ɛ]::Real=Inf
       )::Hyperrectangle where {N&lt;:Real}</code></pre><p>Project a high-dimensional set to a low-dimensional hyperrectangle.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set</p></li><li><p><code>block</code> – block structure - a vector with the dimensions of interest</p></li><li><p><code>set_type</code> – <code>Hyperrectangle</code> - used for dispatch</p></li><li><p><code>n</code> – (optional, default: <code>dim(S)</code>) ambient dimension of the set <code>S</code></p></li><li><p><code>ɛ</code> – (optional, default: <code>Inf</code>) - used for dispatch, ignored</p></li></ul><p><strong>Output</strong></p><p>The box approximation of the projection of <code>S</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/decompositions.jl#L338-L359">source</a></section><h2><a class="nav-anchor" id="Overapproximations-1" href="#Overapproximations-1">Overapproximations</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.overapproximate" href="#LazySets.Approximations.overapproximate"><code>LazySets.Approximations.overapproximate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">overapproximate(S::LazySet{N},
                ::Type{&lt;:HPolygon},
                [ɛ]::Real=Inf)::HPolygon where {N&lt;:Real}</code></pre><p>Return an approximation of a given 2D convex set. If no error tolerance is given, or is <code>Inf</code>, the result is a box-shaped polygon. Otherwise the result is an ɛ-close approximation as a polygon.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set, assumed to be two-dimensional</p></li><li><p><code>HPolygon</code> for dispatch</p></li><li><p><code>ɛ</code> – (optional, default: <code>Inf</code>) error bound</p></li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/overapproximate.jl#L1-L19">source</a><div><pre><code class="language-none">overapproximate(S::LazySet, ɛ::Real)::HPolygon</code></pre><p>Alias for <code>overapproximate(S, HPolygon, ɛ)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/overapproximate.jl#L40-L44">source</a><div><pre><code class="language-none">overapproximate(S::LazySet, Type{&lt;:Hyperrectangle})::Hyperrectangle</code></pre><p>Return an approximation of a given set as a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – set</p></li><li><p><code>Hyperrectangle</code> for dispatch</p></li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/overapproximate.jl#L47-L60">source</a><div><pre><code class="language-none">overapproximate(S::LazySet)::Hyperrectangle</code></pre><p>Alias for <code>overapproximate(S, Hyperrectangle)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/overapproximate.jl#L63-L67">source</a><div><pre><code class="language-none">overapproximate(S::ConvexHull{N, Zonotope{N}, Zonotope{N}},
                 ::Type{&lt;:Zonotope})::Zonotope where {N&lt;:Real}</code></pre><p>Overapproximate the convex hull of two zonotopes.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex hull of two zonotopes of the same order</p></li><li><p><code>Zonotope</code> for dispatch</p></li></ul><p><strong>Algorithm</strong></p><p>This function implements the method proposed in <em>Reachability of Uncertain Linear Systems Using Zonotopes, A. Girard, HSCC 2005</em>. The convex hull of two zonotopes of the same order, that we write <span>$Z_j = ⟨c^{(j)}, g^{(j)}_1, …, g^{(j)}_p⟩$</span> for <span>$j = 1, 2$</span>, can be overapproximated as follows:</p><div>\[CH(Z_1, Z_2) ⊆ \frac{1}{2}⟨c^{(1)}+c^{(2)}, g^{(1)}_1+g^{(2)}_1, …, g^{(1)}_p+g^{(2)}_p, c^{(1)}-c^{(2)}, g^{(1)}_1-g^{(2)}_1, …, g^{(1)}_p-g^{(2)}_p⟩.\]</div><p>It should be noted that the output zonotope is not necessarily the minimal enclosing zonotope, which is in general expensive in high dimensions. This is further investigated in: <em>Zonotopes as bounding volumes, L. J. Guibas et al, Proc. of Symposium on Discrete Algorithms, pp. 803-812</em>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/overapproximate.jl#L70-L96">source</a><div><pre><code class="language-none">overapproximate(::LazySet{N}, ::Type{LazySets.Interval}) where {N&lt;:Real}</code></pre><p>Return the overapproximation of a real unidimensional set with an interval.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – one-dimensional set</p></li><li><p><code>Interval</code> for dispatch</p></li></ul><p><strong>Output</strong></p><p>An interval.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/overapproximate.jl#L2-L15">source</a><div><pre><code class="language-none">overapproximate(I::LazySets.Interval, ::Type{LazySets.Interval})</code></pre><p>Overapproximating an interval with an interval is a no-op.</p><p><strong>Input</strong></p><ul><li><p><code>I</code> – interval</p></li><li><p><code>Interval</code> for dispatch</p></li></ul><p><strong>Output</strong></p><p>The input interval.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/overapproximate.jl#L2-L15">source</a></section><h2><a class="nav-anchor" id="Box-Approximations-1" href="#Box-Approximations-1">Box Approximations</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.ballinf_approximation" href="#LazySets.Approximations.ballinf_approximation"><code>LazySets.Approximations.ballinf_approximation</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ballinf_approximation(S::LazySet{N})::BallInf{N} where {N&lt;:Real}</code></pre><p>Overapproximate a convex set by a tight ball in the infinity norm.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>A tight ball in the infinity norm.</p><p><strong>Algorithm</strong></p><p>The center and radius of the box are obtained by evaluating the support function of the given convex set along the canonical directions.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/box_approximations.jl#L117-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.box_approximation" href="#LazySets.Approximations.box_approximation"><code>LazySets.Approximations.box_approximation</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">box_approximation(S::LazySet)::Hyperrectangle</code></pre><p>Overapproximate a convex set by a tight hyperrectangle.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>A tight hyperrectangle.</p><p><strong>Algorithm</strong></p><p>The center of the hyperrectangle is obtained by averaging the support function of the given set in the canonical directions, and the lengths of the sides can be recovered from the distance among support functions in the same directions.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/box_approximations.jl#L5-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.interval_hull" href="#LazySets.Approximations.interval_hull"><code>LazySets.Approximations.interval_hull</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">interval_hull</code></pre><p>Alias for <code>box_approximation</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/box_approximations.jl#L36-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.box_approximation_symmetric" href="#LazySets.Approximations.box_approximation_symmetric"><code>LazySets.Approximations.box_approximation_symmetric</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">box_approximation_symmetric(S::LazySet{N})::Hyperrectangle{N} where {N&lt;:Real}</code></pre><p>Overapproximate a convex set by a tight hyperrectangle centered in the origin.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>A tight hyperrectangle centered in the origin.</p><p><strong>Algorithm</strong></p><p>The center of the box is the origin, and the radius is obtained by computing the maximum value of the support function evaluated at the canonical directions.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/box_approximations.jl#L43-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.symmetric_interval_hull" href="#LazySets.Approximations.symmetric_interval_hull"><code>LazySets.Approximations.symmetric_interval_hull</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">symmetric_interval_hull</code></pre><p>Alias for <code>box_approximation_symmetric</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/box_approximations.jl#L67-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.box_approximation_helper" href="#LazySets.Approximations.box_approximation_helper"><code>LazySets.Approximations.box_approximation_helper</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">box_approximation_helper(S::LazySet)</code></pre><p>Common code of <code>box_approximation</code> and <code>box_approximation_symmetric</code>.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>A tuple containing the data that is needed to construct a tightly overapproximating hyperrectangle.</p><ul><li><p><code>c</code> – center</p></li><li><p><code>r</code> – radius</p></li></ul><p><strong>Algorithm</strong></p><p>The center of the hyperrectangle is obtained by averaging the support function of the given convex set in the canonical directions. The lengths of the sides can be recovered from the distance among support functions in the same directions.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/box_approximations.jl#L74-L97">source</a></section><h3><a class="nav-anchor" id="Metric-properties-of-sets-1" href="#Metric-properties-of-sets-1">Metric properties of sets</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}" href="#Base.LinAlg.norm-Tuple{LazySets.LazySet,Real}"><code>Base.LinAlg.norm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">norm(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the norm of a convex set. It is the norm of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/LazySet.jl#L99-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius-Tuple{LazySets.LazySet,Real}" href="#LazySets.radius-Tuple{LazySets.LazySet,Real}"><code>LazySets.radius</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radius(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the radius of a convex set. It is the radius of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/LazySet.jl#L123-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.diameter-Tuple{LazySets.LazySet,Real}" href="#LazySets.diameter-Tuple{LazySets.LazySet,Real}"><code>LazySets.diameter</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">diameter(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the diameter of a convex set. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/LazySet.jl#L147-L163">source</a></section><h2><a class="nav-anchor" id="Iterative-refinement-1" href="#Iterative-refinement-1">Iterative refinement</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.LocalApproximation" href="#LazySets.Approximations.LocalApproximation"><code>LazySets.Approximations.LocalApproximation</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LocalApproximation{N&lt;:Real}</code></pre><p>Type that represents a local approximation in 2D.</p><p><strong>Fields</strong></p><ul><li><p><code>p1</code>         – first inner point</p></li><li><p><code>d1</code>         – first direction</p></li><li><p><code>p2</code>         – second inner point</p></li><li><p><code>d2</code>         – second direction</p></li><li><p><code>q</code>          – intersection of the lines l1 ⟂ d1 at p1 and l2 ⟂ d2 at p2</p></li><li><p><code>refinable</code>  – states if this approximation is refinable</p></li><li><p><code>err</code>        – error upper bound</p></li></ul><p><strong>Notes</strong></p><p>The criteria for refinable are determined in the method <code>new_approx</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/iterative_refinement.jl#L1-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.PolygonalOverapproximation" href="#LazySets.Approximations.PolygonalOverapproximation"><code>LazySets.Approximations.PolygonalOverapproximation</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PolygonalOverapproximation{N&lt;:Real}</code></pre><p>Type that represents the polygonal approximation of a convex set.</p><p><strong>Fields</strong></p><ul><li><p><code>S</code>           – convex set</p></li><li><p><code>approx_list</code> – vector of local approximations</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/iterative_refinement.jl#L30-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.new_approx-Tuple{LazySets.LazySet,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}" href="#LazySets.Approximations.new_approx-Tuple{LazySets.LazySet,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}"><code>LazySets.Approximations.new_approx</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">new_approx(S::LazySet, p1::Vector{N}, d1::Vector{N}, p2::Vector{N},
           d2::Vector{N}) where {N&lt;:Real}</code></pre><p><strong>Input</strong></p><ul><li><p><code>S</code>          – convex set</p></li><li><p><code>p1</code>         – first inner point</p></li><li><p><code>d1</code>         – first direction</p></li><li><p><code>p2</code>         – second inner point</p></li><li><p><code>d2</code>         – second direction</p></li></ul><p><strong>Output</strong></p><p>A local approximation of <code>S</code> in the given directions.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/iterative_refinement.jl#L49-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.addapproximation!-Tuple{LazySets.Approximations.PolygonalOverapproximation,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}" href="#LazySets.Approximations.addapproximation!-Tuple{LazySets.Approximations.PolygonalOverapproximation,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}"><code>LazySets.Approximations.addapproximation!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">addapproximation!(Ω::PolygonalOverapproximation,
    p1::Vector{N}, d1::Vector{N}, p2::Vector{N}, d2::Vector{N}) where {N&lt;:Real}</code></pre><p><strong>Input</strong></p><ul><li><p><code>Ω</code>          – polygonal overapproximation of a convex set</p></li><li><p><code>p1</code>         – first inner point</p></li><li><p><code>d1</code>         – first direction</p></li><li><p><code>p2</code>         – second inner point</p></li><li><p><code>d2</code>         – second direction</p></li></ul><p><strong>Output</strong></p><p>The list of local approximations in <code>Ω</code> of the set <code>Ω.S</code> is updated in-place and the new approximation is returned by this function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/iterative_refinement.jl#L81-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.refine-Tuple{LazySets.Approximations.PolygonalOverapproximation,Int64}" href="#LazySets.Approximations.refine-Tuple{LazySets.Approximations.PolygonalOverapproximation,Int64}"><code>LazySets.Approximations.refine</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">refine(Ω::PolygonalOverapproximation, i::Int)::Tuple{LocalApproximation, LocalApproximation}</code></pre><p>Refine a given local approximation of the polygonal approximation of a convex set, by splitting along the normal direction to the approximation.</p><p><strong>Input</strong></p><ul><li><p><code>Ω</code>   – polygonal overapproximation of a convex set</p></li><li><p><code>i</code>   – integer index for the local approximation to be refined</p></li></ul><p><strong>Output</strong></p><p>The tuple consisting of the refined right and left local approximations.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/iterative_refinement.jl#L107-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.tohrep-Tuple{LazySets.Approximations.PolygonalOverapproximation}" href="#LazySets.Approximations.tohrep-Tuple{LazySets.Approximations.PolygonalOverapproximation}"><code>LazySets.Approximations.tohrep</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">tohrep(Ω::PolygonalOverapproximation{N})::AbstractHPolygon where {N&lt;:Real}</code></pre><p>Convert a polygonal overapproximation into a concrete polygon.</p><p><strong>Input</strong></p><ul><li><p><code>Ω</code>   – polygonal overapproximation of a convex set</p></li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/iterative_refinement.jl#L133-L145">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Approximations.approximate-Tuple{LazySets.LazySet{Float64},Float64}" href="#LazySets.Approximations.approximate-Tuple{LazySets.LazySet{Float64},Float64}"><code>LazySets.Approximations.approximate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">approximate(S::LazySet{N},
            ɛ::N)::PolygonalOverapproximation{N} where {N&lt;:Real}</code></pre><p>Return an ɛ-close approximation of the given 2D convex set (in terms of Hausdorff distance) as an inner and an outer approximation composed by sorted local <code>Approximation2D</code>.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – 2D convex set</p></li><li><p><code>ɛ</code> – error bound</p></li></ul><p><strong>Output</strong></p><p>An ɛ-close approximation of the given 2D convex set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/59b20365dba9a4f12f94eef30ab9b8e5bf0944a9/src/Approximations/iterative_refinement.jl#L154-L170">source</a></section><p>See <a href="../man/iterative_refinement.html#Iterative-Refinement-1">Iterative Refinement</a> for more details.</p><footer><hr/><a class="previous" href="binary_functions.html"><span class="direction">Previous</span><span class="title">Binary Functions on Sets</span></a><a class="next" href="utils.html"><span class="direction">Next</span><span class="title">Utility Functions</span></a></footer></article></body></html>
