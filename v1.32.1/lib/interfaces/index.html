<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interfaces · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/getting_started/">Getting Started</a></li><li><a class="toctext" href="../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="toctext" href="../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="toctext" href="../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="toctext" href="../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="toctext" href="../../man/interval_hulls/">Interval Hulls</a></li><li><a class="toctext" href="../../man/convex_hulls/">Convex Hulls</a></li><li><a class="toctext" href="../../man/set_operations/">Operations on Sets</a></li><li><a class="toctext" href="../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="toctext" href="../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="toctext" href="../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="toctext" href="../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href>Interfaces</a><ul class="internal"><li><a class="toctext" href="#def_LazySet-1">General sets (LazySet)</a></li><li><a class="toctext" href="#def_AbstractCentrallySymmetric-1">Centrally symmetric sets (AbstractCentrallySymmetric)</a></li><li><a class="toctext" href="#def_AbstractPolyhedron-1">Polyhedra (AbstractPolyhedron)</a></li><li><a class="toctext" href="#def_AbstractPolytope-1">Polytopes (AbstractPolytope)</a></li><li><a class="toctext" href="#def_AbstractPolygon-1">Polygons (AbstractPolygon)</a></li><li><a class="toctext" href="#def_AbstractHPolygon-1">Polygons in constraint representation (AbstractHPolygon)</a></li><li><a class="toctext" href="#def_AbstractCentrallySymmetricPolytope-1">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a></li><li><a class="toctext" href="#def_AbstractZonotope-1">Zonotopes (AbstractZonotope)</a></li><li><a class="toctext" href="#def_AbstractHyperrectangle-1">Hyperrectangles (AbstractHyperrectangle)</a></li><li><a class="toctext" href="#def_AbstractSingleton-1">Singletons (AbstractSingleton)</a></li><li><a class="toctext" href="#def_AbstractAffineMap-1">Affine maps (AbstractAffineMap)</a></li></ul></li><li><span class="toctext">Sets</span><ul><li><a class="toctext" href="../sets/Ball1/">Ball1</a></li><li><a class="toctext" href="../sets/Ball2/">Ball2</a></li><li><a class="toctext" href="../sets/BallInf/">BallInf</a></li><li><a class="toctext" href="../sets/Ballp/">Ballp</a></li><li><a class="toctext" href="../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="toctext" href="../sets/EmptySet/">EmptySet</a></li><li><a class="toctext" href="../sets/HalfSpace/">HalfSpace</a></li><li><a class="toctext" href="../sets/HPolygon/">HPolygon</a></li><li><a class="toctext" href="../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="toctext" href="../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="toctext" href="../sets/HPolytope/">HPolytope</a></li><li><a class="toctext" href="../sets/Hyperplane/">Hyperplane</a></li><li><a class="toctext" href="../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="toctext" href="../sets/Interval/">Interval</a></li><li><a class="toctext" href="../sets/Line/">Line</a></li><li><a class="toctext" href="../sets/LineSegment/">LineSegment</a></li><li><a class="toctext" href="../sets/PolynomialZonotope/">PolynomialZonotope</a></li><li><a class="toctext" href="../sets/Singleton/">Singleton</a></li><li><a class="toctext" href="../sets/Universe/">Universe</a></li><li><a class="toctext" href="../sets/VPolygon/">VPolygon</a></li><li><a class="toctext" href="../sets/VPolytope/">VPolytope</a></li><li><a class="toctext" href="../sets/ZeroSet/">ZeroSet</a></li><li><a class="toctext" href="../sets/Zonotope/">Zonotope</a></li></ul></li><li><span class="toctext">Lazy Operations</span><ul><li><a class="toctext" href="../lazy_operations/AffineMap/">AffineMap</a></li><li><a class="toctext" href="../lazy_operations/Bloating/">Bloating</a></li><li><a class="toctext" href="../lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="toctext" href="../lazy_operations/Complement/">Complement</a></li><li><a class="toctext" href="../lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="toctext" href="../lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="toctext" href="../lazy_operations/Intersection/">Intersection</a></li><li><a class="toctext" href="../lazy_operations/LinearMap/">LinearMap</a></li><li><a class="toctext" href="../lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="toctext" href="../lazy_operations/Rectification/">Rectification</a></li><li><a class="toctext" href="../lazy_operations/ResetMap/">ResetMap</a></li><li><a class="toctext" href="../lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="toctext" href="../lazy_operations/Translation/">Translation</a></li><li><a class="toctext" href="../lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><a class="toctext" href="../binary_functions/">Concrete Operations</a></li><li><a class="toctext" href="../conversion/">Conversions between set representations</a></li><li><a class="toctext" href="../comparisons/">Comparisons</a></li><li><a class="toctext" href="../approximations/">Approximations</a></li><li><a class="toctext" href="../utils/">Utility Functions</a></li><li><a class="toctext" href="../parallel/">Parallel</a></li></ul></li><li><a class="toctext" href="../../about/">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Interfaces</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/interfaces.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Interfaces</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Set-Interfaces-1" href="#Set-Interfaces-1">Set Interfaces</a></h1><p>This section of the manual describes the interfaces for different set types. Every set that fits the description of an interface should also implement it. This helps in several ways:</p><ul><li>avoid code duplicates,</li><li>provide functions for many sets at once,</li><li>allow changes in the source code without changing the API.</li></ul><p>The interface functions are outlined in the interface documentation. For implementations of the interfaces see the corresponding sub-pages linked in the respective sections.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The naming convention is such that all interface names (with the exception of the main abstract type <code>LazySet</code>) should be preceded by <code>Abstract</code>.</p></div></div><p>The following diagram shows the interface hierarchy.</p><p><img src="../../assets/interfaces.png" alt="../assets/interfaces.png"/></p><ul><li><a href="#Set-Interfaces-1">Set Interfaces</a></li><ul><li><a href="#def_LazySet-1">General sets (LazySet)</a></li><ul><li><a href="#Support-function-and-support-vector-1">Support function and support vector</a></li><li><a href="#Other-globally-defined-set-functions-1">Other globally defined set functions</a></li><li><a href="#Set-functions-that-override-Base-functions-1">Set functions that override Base functions</a></li><li><a href="#Aliases-for-set-types-1">Aliases for set types</a></li><li><a href="#Implementations-1">Implementations</a></li></ul><li><a href="#def_AbstractCentrallySymmetric-1">Centrally symmetric sets (AbstractCentrallySymmetric)</a></li><ul><li><a href="#Implementations-2">Implementations</a></li></ul><li><a href="#def_AbstractPolyhedron-1">Polyhedra (AbstractPolyhedron)</a></li><ul><li><a href="#Implementations-3">Implementations</a></li></ul><li><a href="#def_AbstractPolytope-1">Polytopes (AbstractPolytope)</a></li><ul><li><a href="#Implementations-4">Implementations</a></li></ul><li><a href="#def_AbstractPolygon-1">Polygons (AbstractPolygon)</a></li><ul><li><a href="#Implementations-5">Implementations</a></li></ul><li><a href="#def_AbstractHPolygon-1">Polygons in constraint representation (AbstractHPolygon)</a></li><ul><li><a href="#Implementations-6">Implementations</a></li></ul><li><a href="#def_AbstractCentrallySymmetricPolytope-1">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a></li><ul><li><a href="#Implementations-7">Implementations</a></li></ul><li><a href="#def_AbstractZonotope-1">Zonotopes (AbstractZonotope)</a></li><ul><li><a href="#Implementations-8">Implementations</a></li></ul><li><a href="#def_AbstractHyperrectangle-1">Hyperrectangles (AbstractHyperrectangle)</a></li><ul><li><a href="#Implementations-9">Implementations</a></li></ul><li><a href="#def_AbstractSingleton-1">Singletons (AbstractSingleton)</a></li><ul><li><a href="#Implementations-10">Implementations</a></li></ul><li><a href="#def_AbstractAffineMap-1">Affine maps (AbstractAffineMap)</a></li><ul><li><a href="#Implementations-11">Implementations</a></li></ul></ul></ul><h2><a class="nav-anchor" id="def_LazySet-1" href="#def_LazySet-1">General sets (LazySet)</a></h2><p>Every convex set in this library implements this interface.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.LazySet" href="#LazySets.LazySet"><code>LazySets.LazySet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">LazySet{N}</code></pre><p>Abstract type for convex sets, i.e., sets characterized by a (possibly infinite) intersection of halfspaces, or equivalently, sets <span>$S$</span> such that for any two elements <span>$x, y ∈ S$</span> and <span>$0 ≤ λ ≤ 1$</span> it holds that <span>$λ·x + (1-λ)·y ∈ S$</span>.</p><p><strong>Notes</strong></p><p><code>LazySet</code> types should be parameterized with a type <code>N</code>, typically <code>N&lt;:Real</code>, for using different numeric types.</p><p>Every concrete <code>LazySet</code> must define the following functions:</p><ul><li><code>σ(d::AbstractVector{N}, S::LazySet{N}) where {N&lt;:Real}</code> – the support vector   of <code>S</code> in a given direction <code>d</code>; note that the numeric type <code>N</code> of <code>d</code> and   <code>S</code> must be identical; for some set types <code>N</code> may be more restrictive than   <code>Real</code></li><li><code>dim(S::LazySet)</code> – the ambient dimension of <code>S</code></li></ul><p>The function</p><ul><li><code>ρ(d::AbstractVector{N}, S::LazySet{N}) where {N&lt;:Real}</code> – the support   function of <code>S</code> in a given direction <code>d</code>; note that the numeric type <code>N</code> of   <code>d</code> and <code>S</code> must be identical; for some set types <code>N</code> may be more   restrictive than <code>Real</code></li></ul><p>is optional because there is a fallback implementation relying on <code>σ</code>. However, for unbounded sets (which includes most lazy set types) this fallback cannot be used and an explicit method must be implemented.</p><p>The subtypes of <code>LazySet</code> (including abstract interfaces):</p><pre><code class="language-julia-repl">julia&gt; subtypes(LazySet, false)
14-element Array{Any,1}:
 AbstractAffineMap
 AbstractCentrallySymmetric
 AbstractPolyhedron
 Bloating
 CachedMinkowskiSumArray
 CartesianProduct
 CartesianProductArray
 ConvexHull
 ConvexHullArray
 EmptySet
 Intersection
 IntersectionArray
 MinkowskiSum
 MinkowskiSumArray</code></pre><p>If we only consider <em>concrete</em> subtypes, then:</p><pre><code class="language-julia-repl">julia&gt; concrete_subtypes = subtypes(LazySet, true);

julia&gt; length(concrete_subtypes)
39

julia&gt; println.(concrete_subtypes);
AffineMap
Ball1
Ball2
BallInf
Ballp
Bloating
CachedMinkowskiSumArray
CartesianProduct
CartesianProductArray
ConvexHull
ConvexHullArray
Ellipsoid
EmptySet
ExponentialMap
ExponentialProjectionMap
HPolygon
HPolygonOpt
HPolyhedron
HPolytope
HalfSpace
Hyperplane
Hyperrectangle
Intersection
IntersectionArray
Interval
Line
LineSegment
LinearMap
MinkowskiSum
MinkowskiSumArray
ResetMap
Singleton
SymmetricIntervalHull
Translation
Universe
VPolygon
VPolytope
ZeroSet
Zonotope</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L29-L127">source</a></section><h3><a class="nav-anchor" id="Support-function-and-support-vector-1" href="#Support-function-and-support-vector-1">Support function and support vector</a></h3><p>Every <code>LazySet</code> type must define a function <code>σ</code> to compute the support vector.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.support_vector" href="#LazySets.support_vector"><code>LazySets.support_vector</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">support_vector</code></pre><p>Alias for the support vector σ.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L244-L248">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Evaluate the support function of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>The support function of the set <code>S</code> for the direction <code>d</code>.</p><p><strong>Notes</strong></p><p>The numeric type of the direction and the set must be identical.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L208-L225">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.support_function" href="#LazySets.support_function"><code>LazySets.support_function</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">support_function</code></pre><p>Alias for the support function ρ.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L230-L234">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ" href="#LazySets.σ"><code>LazySets.σ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">σ</code></pre><p>Function to compute the support vector σ.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L237-L241">source</a></section><h3><a class="nav-anchor" id="Other-globally-defined-set-functions-1" href="#Other-globally-defined-set-functions-1">Other globally defined set functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.basetype" href="#LazySets.basetype"><code>LazySets.basetype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">basetype(T::Type{&lt;:LazySet})</code></pre><p>Return the base type of the given set type (i.e., without type parameters).</p><p><strong>Input</strong></p><ul><li><code>T</code> – set type, used for dispatch</li></ul><p><strong>Output</strong></p><p>The base type of <code>T</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L163-L175">source</a><div><div><pre><code class="language-none">basetype(S::LazySet)</code></pre><p>Return the base type of the given set (i.e., without type parameters).</p><p><strong>Input</strong></p><ul><li><code>S</code> – set instance, used for dispatch</li></ul><p><strong>Output</strong></p><p>The base type of <code>S</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; z = rand(Zonotope);

julia&gt; basetype(z)
Zonotope

julia&gt; basetype(z + z)
MinkowskiSum

julia&gt; basetype(LinearMap(rand(2, 2), z + z))
LinearMap</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L178-L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">norm(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the norm of a convex set. It is the norm of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L303-L318">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius" href="#LazySets.radius"><code>LazySets.radius</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">radius(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the radius of a convex set. It is the radius of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L327-L342">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.diameter" href="#LazySets.diameter"><code>LazySets.diameter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">diameter(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the diameter of a convex set. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L351-L367">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{LazySet}" href="#LazySets.isbounded-Tuple{LazySet}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(S::LazySet)</code></pre><p>Determine whether a set is bounded.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set is bounded.</p><p><strong>Algorithm</strong></p><p>We check boundedness via <a href="#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>isbounded_unit_dimensions</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L251-L267">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.isbounded_unit_dimensions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded_unit_dimensions(S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Determine whether a set is bounded in each unit dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set is bounded in each unit dimension.</p><p><strong>Algorithm</strong></p><p>This function performs <span>$2n$</span> support function checks, where <span>$n$</span> is the ambient dimension of <code>S</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L272-L289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>An element of a convex set.</p><p><strong>Algorithm</strong></p><p>An element of the set is obtained by evaluating its support vector along direction <span>$[1, 0, …, 0]$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L395-L412">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tosimplehrep-Tuple{LazySet}" href="#LazySets.tosimplehrep-Tuple{LazySet}"><code>LazySets.tosimplehrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tosimplehrep(S::LazySet)</code></pre><p>Return the simple H-representation <span>$Ax ≤ b$</span> of a set from its list of linear constraints.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p>The tuple <code>(A, b)</code> where <code>A</code> is the matrix of normal directions and <code>b</code> is the vector of offsets.</p><p><strong>Notes</strong></p><p>This function only works for sets that can be represented exactly by a finite list of linear constraints. This fallback implementation relies on <code>constraints_list(S)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L552-L572">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isuniversal-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},Bool}} where N&lt;:Real" href="#LazySets.isuniversal-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},Bool}} where N&lt;:Real"><code>LazySets.isuniversal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isuniversal(X::LazySet{N}, [witness]::Bool=false) where {N&lt;:Real}</code></pre><p>Check whether a given convex set is universal, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – convex set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X$</span> is universal</li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X$</span> is universal</li><li><code>(false, v)</code> iff <span>$X$</span> is not universal and <span>$v ∉ X$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>This is a naive fallback implementation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L603-L624">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.affine_map-Tuple{AbstractArray{T,2} where T,LazySet,AbstractArray{T,1} where T}" href="#LazySets.affine_map-Tuple{AbstractArray{T,2} where T,LazySet,AbstractArray{T,1} where T}"><code>LazySets.affine_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">affine_map(M::AbstractMatrix, X::LazySet, v::AbstractVector)</code></pre><p>Compute a concrete affine map.</p><p><strong>Input</strong></p><ul><li><code>M</code> – linear map</li><li><code>X</code> – convex set</li><li><code>v</code> – translation vector</li></ul><p><strong>Output</strong></p><p>A set representing the affine map of <code>X</code>.</p><p><strong>Algorithm</strong></p><p>The implementation applies the functions <code>linear_map</code> and <code>translate</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L372-L390">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.reflect-Tuple{LazySet}" href="#LazySets.reflect-Tuple{LazySet}"><code>LazySets.reflect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">reflect(P::LazySet{N}) where {N&lt;:Real}</code></pre><p>Concrete reflection of a convex set <code>P</code>, resulting in the reflected set <code>-P</code>.</p><p><strong>Note</strong></p><p>This function requires that the list of constraints of the set <code>P</code> is available, i.e. such that it can be written as <span>$P = \{z ∈ ℝⁿ: ⋂ sᵢᵀz ≤ rᵢ, i = 1, ..., N\}.$</span></p><p>This function can be used to implement the alternative definition of the Minkowski Difference, which writes as</p><div>\[A ⊖ B = \{a − b | a ∈ A, b ∈ B\} = A ⊕ (-B)\]</div><p>by calling <code>minkowski_sum(A, reflect(B))</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L575-L592">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_interior_point-Union{Tuple{N}, Tuple{AbstractArray{N,1},LazySet{N}}} where N&lt;:Real" href="#LazySets.is_interior_point-Union{Tuple{N}, Tuple{AbstractArray{N,1},LazySet{N}}} where N&lt;:Real"><code>LazySets.is_interior_point</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_interior_point(d::AbstractVector{N}, P::LazySet{N};
                  p=N(Inf), ε=_rtol(N)) where {N&lt;:Real}</code></pre><p>Check if the point <code>d</code> is contained in the interior of the convex set <code>P</code>.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – point</li><li><code>P</code>  – set</li><li><code>p</code>  – (optional; default: <code>N(Inf)</code>) norm of the ball used to apply the error         tolerance</li><li><code>ε</code>  – (optional; default: <code>_rtol(N)</code>) error tolerance of check</li></ul><p><strong>Output</strong></p><p>Boolean which indicates if the point <code>d</code> is contained in <code>P</code>.</p><p><strong>Algorithm</strong></p><p>The implementation checks if a <code>Ballp</code> of norm <code>p</code> with center <code>d</code> and radius <code>ε</code> is contained in the set <code>P</code>. This is a numerical check for <code>d ∈ interior(P)</code> with error tolerance <code>ε</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L641-L664">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isoperationtype-Tuple{Type{#s15} where #s15&lt;:LazySet}" href="#LazySets.isoperationtype-Tuple{Type{#s15} where #s15&lt;:LazySet}"><code>LazySets.isoperationtype</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isoperationtype(X::Type{&lt;:LazySet})</code></pre><p>Check whether the given <code>LazySet</code> type is an operation or not.</p><p><strong>Input</strong></p><ul><li><code>X</code> – subtype of <code>LazySet</code></li></ul><p><strong>Output</strong></p><p><code>true</code> if the given set type is a set-based operation and <code>false</code> otherwise.</p><p><strong>Notes</strong></p><p>The fallback for this function returns an error that <code>isoperationtype</code> is not implemented. Subtypes of <code>LazySet</code> should dispatch on this function as required.</p><p>See also <a href="#LazySets.isoperation-Tuple{LazySet}"><code>isoperation(X&lt;:LazySet)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isoperationtype(BallInf)
false

julia&gt; isoperationtype(LinearMap)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L756-L785">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isoperation-Tuple{LazySet}" href="#LazySets.isoperation-Tuple{LazySet}"><code>LazySets.isoperation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isoperation(X::LazySet)</code></pre><p>Check whether the given <code>LazySet</code> is an instance of a set operation or not.</p><p><strong>Input</strong></p><ul><li><code>X</code> – a <code>LazySet</code></li></ul><p><strong>Output</strong></p><p><code>true</code> if <code>X</code> is an instance of a set-based operation and <code>false</code> otherwise.</p><p><strong>Notes</strong></p><p>The fallback implementation returns whether the set type of the input is an operation or not using <code>isoperationtype</code>.</p><p>See also <a href="#LazySets.isoperationtype-Tuple{Type{#s15} where #s15&lt;:LazySet}"><code>isoperationtype(X::Type{&lt;:LazySet})</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = BallInf([0.0, 0.0], 1.0);

julia&gt; isoperation(B)
false

julia&gt; isoperation(B ⊕ B)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L717-L748">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isequivalent-Tuple{LazySet,LazySet}" href="#LazySets.isequivalent-Tuple{LazySet,LazySet}"><code>LazySets.isequivalent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isequivalent(X::LazySet, Y::LazySet)</code></pre><p>Return whether two LazySets are equal in the mathematical sense, i.e. equivalent.</p><p><strong>Input</strong></p><ul><li><code>X</code> – any <code>LazySet</code></li><li><code>Y</code> – another <code>LazySet</code></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>X</code> is equivalent to <code>Y</code>.</p><p><strong>Algorithm</strong></p><p>First, the check <code>X == Y</code> is performed which returns <code>true</code> if and only if the given sets are of the same type, and have the same values (modulo floating-point tolerance). Otherwise, the double inclusion check <code>X ⊆ Y &amp;&amp; Y ⊆ X</code> is used.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X = BallInf([0.1, 0.2], 0.3);

julia&gt; Y = convert(HPolytope, X);

julia&gt; X == Y
false

julia&gt; isequivalent(X, Y)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L793-L826">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isconvextype-Tuple{Type{#s15} where #s15&lt;:LazySet}" href="#LazySets.isconvextype-Tuple{Type{#s15} where #s15&lt;:LazySet}"><code>LazySets.isconvextype</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isconvextype(X::Type{&lt;:LazySet})</code></pre><p>Check whether the given <code>LazySet</code> type is convex.</p><p><strong>Input</strong></p><ul><li><code>X</code> – subtype of <code>LazySet</code></li></ul><p><strong>Output</strong></p><p><code>true</code> if the given set type is guaranteed to be convex by using only type information, and <code>false</code> otherwise.</p><p><strong>Notes</strong></p><p>Since this operation only acts on types (not on values), it can return false negatives, i.e. there may be instances where the set is convex, even though the answer of this function is <code>false</code>. The examples below illustrate this point.</p><p><strong>Examples</strong></p><p>A ball in the infinity norm is always convex, hence we get:</p><pre><code class="language-julia-repl">julia&gt; isconvextype(BallInf)
true</code></pre><p>For instance, the union (<code>UnionSet</code>) of two sets may in general be either convex or not, since convexity cannot be decided by just using type information. Hence, <code>isconvextype</code> returns <code>false</code> if <code>X</code> is <code>Type{&lt;:UnionSet}</code>.</p><pre><code class="language-julia-repl">julia&gt; isconvextype(UnionSet)
false</code></pre><p>However, the type parameters from the set operations allow to decide convexity in some cases, by falling back to the convexity of the type of its arguments. Consider for instance the lazy intersection. The intersection of two convex sets is always convex, hence we can get:</p><pre><code class="language-julia-repl">julia&gt; isconvextype(Intersection{Float64, BallInf{Float64}, BallInf{Float64}})
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L834-L881">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.surface-Union{Tuple{LazySet{N}}, Tuple{N}} where N" href="#LazySets.surface-Union{Tuple{LazySet{N}}, Tuple{N}} where N"><code>LazySets.surface</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">surface(X::LazySet{N}) where {N}</code></pre><p>Compute the surface area of a set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set</li></ul><p><strong>Output</strong></p><p>A number representing the surface area of <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L884-L896">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.area-Union{Tuple{LazySet{N}}, Tuple{N}} where N" href="#LazySets.area-Union{Tuple{LazySet{N}}, Tuple{N}} where N"><code>LazySets.area</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">area(X::LazySet{N}) where {N}</code></pre><p>Compute the area of a two-dimensional polytopic set using the Shoelace formula.</p><p><strong>Input</strong></p><ul><li><code>X</code> – two-dimensional set</li></ul><p><strong>Output</strong></p><p>A number representing the area of <code>X</code>.</p><p><strong>Notes</strong></p><p>This algorithm is applicable to any lazy set <code>X</code> such that its list of vertices, <code>vertices_list</code>, can be computed.</p><p><strong>Algorithm</strong></p><p>Let <code>m</code> be the number of vertices of <code>X</code>. The following instances are considered:</p><ul><li><code>m = 0, 1, 2</code>: the output is zero.</li><li><code>m = 3</code>: the triangle case is computed using the Shoelace formula with 3 points.</li><li><code>m = 4</code>: the quadrilateral case is obtained by the factored version of the Shoelace          formula with 4 points.</li></ul><p>Otherwise, the general Shoelace formula is used; for detals see the wikipedia article <a href="https://en.wikipedia.org/wiki/Shoelace_formula">Shoelace formula</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L906-L935">source</a></section><p>Plotting is available for general one- or two-dimensional <code>LazySet</code>s, provided that the overapproximation using iterative refinement is available:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.plot_recipe-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},N}} where N&lt;:Real" href="#LazySets.plot_recipe-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},N}} where N&lt;:Real"><code>LazySets.plot_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_recipe(X::LazySet{N}, [ε]::N=N(PLOT_PRECISION)) where {N&lt;:Real}</code></pre><p>Convert a convex set to a pair <code>(x, y)</code> of points for plotting.</p><p><strong>Input</strong></p><ul><li><code>X</code> – convex set</li><li><code>ε</code> – (optional, default: <code>PLOT_PRECISION</code>) approximation error bound</li></ul><p><strong>Output</strong></p><p>A pair <code>(x, y)</code> of points that can be plotted.</p><p><strong>Notes</strong></p><p>Plotting of unbounded sets is not implemented yet (see <a href="https://github.com/JuliaReach/LazySets.jl/issues/576">#576</a>).</p><p><strong>Algorithm</strong></p><p>We first assert that <code>X</code> is bounded.</p><p>One-dimensional sets are converted to an <code>Interval</code>. We do not support three-dimensional or higher-dimensional sets at the moment.</p><p>For two-dimensional sets, we first compute a polygonal overapproximation. The second argument, <code>ε</code>, corresponds to the error in Hausdorff distance between the overapproximating set and <code>X</code>. The default value <code>PLOT_PRECISION</code> is chosen such that the unit ball in the 2-norm is approximated with reasonable accuracy. On the other hand, if you only want to produce a fast box-overapproximation of <code>X</code>, pass <code>ε=Inf</code>. Finally, we use the plot recipe for polygons.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L670-L704">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol,Any},LazySet{N}}, Tuple{AbstractDict{Symbol,Any},LazySet{N},N}} where N&lt;:Real" href="#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol,Any},LazySet{N}}, Tuple{AbstractDict{Symbol,Any},LazySet{N},N}} where N&lt;:Real"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_lazyset(X::LazySet{N}, [ε]::N=N(PLOT_PRECISION); ...) where {N&lt;:Real}</code></pre><p>Plot a convex set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – convex set</li><li><code>ε</code> – (optional, default: <code>PLOT_PRECISION</code>) approximation error bound</li></ul><p><strong>Notes</strong></p><p>See <a href="#LazySets.plot_recipe-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},N}} where N&lt;:Real"><code>plot_recipe(::LazySet{&lt;:Real})</code></a>.</p><p>For polyhedral set types (subtypes of <code>AbstractPolyhedron</code>), the argument <code>ε</code> is ignored.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; B = Ball2(ones(2), 0.1);

julia&gt; plot(B, 1e-3)  # default accuracy value (explicitly given for clarity)

julia&gt; plot(B, 1e-2)  # faster but less accurate than the previous call</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Plotting/plot_recipes.jl#L199-L225">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{VN}, Tuple{N}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1}}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1},N}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1},N,Int64}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1},N,Int64,Bool}} where VN&lt;:LazySet{N} where N&lt;:Real" href="#RecipesBase.apply_recipe-Union{Tuple{VN}, Tuple{N}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1}}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1},N}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1},N,Int64}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1},N,Int64,Bool}} where VN&lt;:LazySet{N} where N&lt;:Real"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_list(list::AbstractVector{VN}, [ε]::N=N(PLOT_PRECISION),
          [Nφ]::Int=PLOT_POLAR_DIRECTIONS, [fast]::Bool=false; ...)
    where {N&lt;:Real, VN&lt;:LazySet{N}}</code></pre><p>Plot a list of convex sets.</p><p><strong>Input</strong></p><ul><li><code>list</code> – list of convex sets (1D or 2D)</li><li><code>ε</code>    – (optional, default: <code>PLOT_PRECISION</code>) approximation error bound</li><li><code>Nφ</code>   – (optional, default: <code>PLOT_POLAR_DIRECTIONS</code>) number of polar           directions (used to plot lazy intersections)</li><li><code>fast</code> – (optional, default: <code>false</code>) switch for faster plotting but without           individual plot recipes (see notes below)</li></ul><p><strong>Notes</strong></p><p>For each set in the list we apply an individual plot recipe.</p><p>The option <code>fast</code> provides access to a faster plotting scheme where all sets in the list are first converted to polytopes and then plotted in one single run. This, however, is not suitable when plotting flat sets (line segments, singletons) because then the polytope plot recipe does not deliver good results. Hence by default we do not use this option. For plotting a large number of (non-flat) polytopes, we highly advise activating this option.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; B1 = BallInf(zeros(2), 0.4);

julia&gt; B2 = BallInf(ones(2), 0.4);

julia&gt; plot([B1, B2])</code></pre><p>Some of the sets in the list may not be plotted precisely but rather overapproximated first. The second argument <code>ε</code> controls the accuracy of this overapproximation.</p><pre><code class="language-julia">julia&gt; Bs = [BallInf(zeros(2), 0.4), Ball2(ones(2), 0.4)];

julia&gt; plot(Bs, 1e-3)  # default accuracy value (explicitly given for clarity)

julia&gt; plot(Bs, 1e-2)  # faster but less accurate than the previous call</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Plotting/plot_recipes.jl#L90-L139">source</a></section><p>For three-dimensional sets, we support <code>Makie</code>:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.plot3d" href="#LazySets.plot3d"><code>LazySets.plot3d</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">plot3d(S::LazySet{N}; backend=default_polyhedra_backend(S, N),
       alpha=1.0, color=:blue, colormap=:viridis, colorrange=nothing,
       interpolate=false, linewidth=1, overdraw=false, shading=true,
       transparency=true, visible=true) where {N}</code></pre><p>Plot a three-dimensional convex set using <code>Makie</code>.</p><p><strong>Input</strong></p><ul><li><code>S</code>            – convex set</li><li><code>backend</code>      – (optional, default: <code>default_polyhedra_backend(S, N)</code>) polyhedral                   computations backend </li><li><code>alpha</code>        – (optional, default: <code>1.0</code>) float in <code>[0,1]</code>; the alpha or                   transparency value</li><li><code>color</code>        – (optional, default: <code>:blue</code>) <code>Symbol</code> or <code>Colorant</code>; the color                   of the main plot element (markers, lines, etc.) and it can be                   a color symbol/string like <code>:red</code></li><li><code>colormap</code>     – (optional, default: <code>:viridis</code>) the color map of the main plot;                   call <code>available_gradients()</code> to see what gradients are available,                   and it can also be used as <code>[:red, :black]</code></li><li><code>colorrange</code>   – (optional, default: <code>nothing</code>, which falls back to                   <code>Makie.AbstractPlotting.Automatic()</code>) a tuple <code>(min, max)</code>                   where <code>min</code> and <code>max</code> specify the data range to be used for                   indexing the colormap</li><li><code>interpolate</code>  – (optional, default: <code>false</code>) a bool for heatmap and images,                   it toggles color interpolation between nearby pixels</li><li><code>linewidth</code>    – (optional, default: <code>1</code>) a number that specifies the width of                   the line in <code>line</code> and <code>linesegments</code> plots</li><li><code>overdraw</code>     – (optional, default: <code>false</code>)</li><li><code>shading</code>      – (optional, default: <code>true</code>) a boolean that specifies if shading                   should be on or not (for meshes)</li><li><code>transparency</code> – (optional, default: <code>true</code>) if <code>true</code>, the set is transparent                   otherwise it is displayed as a solid object</li><li><code>visible</code>      – (optional, default: <code>true</code>) a bool that toggles visibility                   of the plot</li></ul><p>For a complete list of attributes and usage see <a href="http://makie.juliaplots.org/stable/plot-attributes">Makie&#39;s documentation</a>.</p><p><strong>Notes</strong></p><p>This plot recipe works by computing the list of constraints of <code>S</code> and converting to a polytope in H-representation. Then, this polytope is transformed with <code>Polyhedra.Mesh</code> and it is plotted using the <code>mesh</code> function.</p><p>If the function <code>constraints_list</code> is not applicable to your set <code>S</code>, try overapproximation first; e.g. via</p><pre><code class="language-julia">julia&gt; using LazySets.Approximations

julia&gt; Sapprox = overapproximate(S, SphericalDirections(10))

julia&gt; plot3d(Sapprox)</code></pre><p>The number <code>10</code> above corresponds to the number of directions considered; for  better resolution use higher values (but it will take longer).</p><p>For efficiency consider using the <code>CDDLib</code> backend, as in</p><pre><code class="language-julia">julia&gt; using CDDLib

julia&gt; plot3d(Sapprox, backend=CDDLib.Library())</code></pre><p><strong>Examples</strong></p><p>The functionality requires <em>both</em> <code>Polyhedra</code> and <code>Makie</code>; so after loading <code>LazySets</code>, do <code>using Makie, Polyhedra</code> (or <code>using Polyhedra, Makie</code>, the order doesn&#39;t matter).</p><pre><code class="language-julia">julia&gt; using LazySets, Makie, Polyhedra

julia&gt; plot3d(10. * rand(Hyperrectangle, dim=3))

julia&gt; plot3d!(10. * rand(Hyperrectangle, dim=3), color=:red)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Plotting/mesh.jl#L36-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.plot3d!" href="#LazySets.plot3d!"><code>LazySets.plot3d!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">plot3d!(S::LazySet{N}; backend=default_polyhedra_backend(S, N),
        alpha=1.0, color=:blue, colormap=:viridis, colorrange=nothing, interpolate=false,
        linewidth=1, overdraw=false, shading=true, transparency=true, visible=true) where {N}</code></pre><p>Plot a three-dimensional convex set using Makie.</p><p><strong>Input</strong></p><p>See <code>plot3d</code> for the description of the inputs. For a complete list of attributes and usage see <a href="http://makie.juliaplots.org/stable/plot-attributes">Makie&#39;s documentation</a>.</p><p><strong>Notes</strong></p><p>See the documentation of <code>plot3d</code> for examples.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Plotting/mesh.jl#L131-L147">source</a></section><h3><a class="nav-anchor" id="Set-functions-that-override-Base-functions-1" href="#Set-functions-that-override-Base-functions-1">Set functions that override Base functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Tuple{LazySet,LazySet}" href="#Base.:==-Tuple{LazySet,LazySet}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">==(X::LazySet, Y::LazySet)</code></pre><p>Return whether two LazySets of the same type are exactly equal.</p><p><strong>Input</strong></p><ul><li><code>X</code> – any <code>LazySet</code></li><li><code>Y</code> – another <code>LazySet</code> of the same type as <code>X</code></li></ul><p><strong>Output</strong></p><ul><li><code>true</code> iff <code>X</code> is equal to <code>Y</code>.</li></ul><p><strong>Notes</strong></p><p>The check is purely syntactic and the sets need to have the same base type. For instance, <code>X::VPolytope == Y::HPolytope</code> returns <code>false</code> even if <code>X</code> and <code>Y</code> represent the same polytope. However <code>X::HPolytope{Int64} == Y::HPolytope{Float64}</code> is a valid comparison.</p><p><strong>Algorithm</strong></p><p>We recursively compare the fields of <code>X</code> and <code>Y</code> until a mismatch is found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; HalfSpace([1], 1) == HalfSpace([1], 1)
true

julia&gt; HalfSpace([1], 1) == HalfSpace([1.0], 1.0)
true

julia&gt; Ball1([0.], 1.) == Ball2([0.], 1.)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L418-L455">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:≈-Tuple{LazySet,LazySet}" href="#Base.:≈-Tuple{LazySet,LazySet}"><code>Base.:≈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">≈(X::LazySet, Y::LazySet)</code></pre><p>Return whether two LazySets of the same type are approximately equal.</p><p><strong>Input</strong></p><ul><li><code>X</code> – any <code>LazySet</code></li><li><code>Y</code> – another <code>LazySet</code> of the same type as <code>X</code></li></ul><p><strong>Output</strong></p><ul><li><code>true</code> iff <code>X</code> is equal to <code>Y</code>.</li></ul><p><strong>Notes</strong></p><p>The check is purely syntactic and the sets need to have the same base type. For instance, <code>X::VPolytope ≈ Y::HPolytope</code> returns <code>false</code> even if <code>X</code> and <code>Y</code> represent the same polytope. However <code>X::HPolytope{Int64} ≈ Y::HPolytope{Float64}</code> is a valid comparison.</p><p><strong>Algorithm</strong></p><p>We recursively compare the fields of <code>X</code> and <code>Y</code> until a mismatch is found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; HalfSpace([1], 1) ≈ HalfSpace([1], 1)
true

julia&gt; HalfSpace([1], 1) ≈ HalfSpace([1.00000001], 0.99999999)
true

julia&gt; HalfSpace([1], 1) ≈ HalfSpace([1.0], 1.0)
true

julia&gt; Ball1([0.], 1.) ≈ Ball2([0.], 1.)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L470-L510">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy-Tuple{LazySet}" href="#Base.copy-Tuple{LazySet}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">copy(S::LazySet)</code></pre><p>Return a deep copy of the given set by copying its values recursively.</p><p><strong>Input</strong></p><ul><li><code>S</code> – any <code>LazySet</code></li></ul><p><strong>Output</strong></p><p>A copy of <code>S</code>.</p><p><strong>Notes</strong></p><p>This function performs a <code>deepcopy</code> of each field in <code>S</code>, resulting in a completely independent object. See the documentation of <code>?deepcopy</code> for further details.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L531-L549">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eltype" href="#Base.eltype"><code>Base.eltype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">eltype(::Type{&lt;:LazySet{N}}) where {N}</code></pre><p>Return the numeric type (<code>N</code>) of the given set type.</p><p><strong>Input</strong></p><ul><li><code>T</code> – set type, used for dispatch</li></ul><p><strong>Output</strong></p><p>The numeric type of <code>T</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L133-L145">source</a><div><div><pre><code class="language-none">eltype(::LazySet{N}) where {N}</code></pre><p>Return the numeric type (<code>N</code>) of the given set.</p><p><strong>Input</strong></p><ul><li><code>X</code> – set instance, used for dispatch</li></ul><p><strong>Output</strong></p><p>The numeric type of <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L148-L160">source</a></section><h3><a class="nav-anchor" id="Aliases-for-set-types-1" href="#Aliases-for-set-types-1">Aliases for set types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CompactSet" href="#LazySets.CompactSet"><code>LazySets.CompactSet</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">CompactSet</code></pre><p>An alias for compact set types.</p><p><strong>Notes</strong></p><p>Most lazy operations are not captured by this alias because whether their result is compact or not depends on the argument(s).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/aliases.jl#L4-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.NonCompactSet" href="#LazySets.NonCompactSet"><code>LazySets.NonCompactSet</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">NonCompactSet</code></pre><p>An alias for non-compact set types.</p><p><strong>Notes</strong></p><p>Most lazy operations are not captured by this alias because whether their result is non-compact or not depends on the argument(s).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/aliases.jl#L20-L29">source</a></section><h3><a class="nav-anchor" id="Implementations-1" href="#Implementations-1">Implementations</a></h3><p>Concrete set representations:</p><ul><li><a href="../sets/EmptySet/#def_EmptySet-1">Empty set (EmptySet)</a></li><li><a href="../sets/PolynomialZonotope/#def_PolynomialZonotope-1">Polynomial zonotope (PolynomialZonotope)</a></li></ul><p>Lazy set operations:</p><ul><li><a href="../lazy_operations/AffineMap/#def_AffineMap-1">Affine map (AffineMap)</a></li><li><a href="../lazy_operations/LinearMap/#def_LinearMap-1">Linear map (LinearMap)</a></li><li><a href="../lazy_operations/ExponentialMap/#def_ExponentialMap-1">Exponential map (ExponentialMap)</a></li><li><a href="../lazy_operations/ExponentialMap/#def_ExponentialProjectionMap-1">Exponential projection map (ExponentialProjectionMap)</a></li><li><a href="../lazy_operations/ResetMap/#def_ResetMap-1">Reset map (ResetMap)</a></li><li><a href="../lazy_operations/Translation/#def_Translation-1">Translation</a></li><li><a href="../lazy_operations/Bloating/#def_Bloating-1">Bloating</a></li><li><a href="../lazy_operations/CartesianProduct/#def_CartesianProduct-1">Binary Cartesian product (CartesianProduct)</a></li><li><a href="../lazy_operations/CartesianProduct/#def_CartesianProductArray-1"><span>$n$</span>-ary Cartesian product (CartesianProductArray)</a></li><li><a href="../lazy_operations/ConvexHull/#def_ConvexHull-1">Binary convex hull (ConvexHull)</a></li><li><a href="../lazy_operations/ConvexHull/#def_ConvexHullArray-1"><span>$n$</span>-ary convex hull (ConvexHullArray)</a></li><li><a href="../lazy_operations/Intersection/#def_Intersection-1">Binary intersection</a></li><li><a href="../lazy_operations/Intersection/#def_IntersectionArray-1"><span>$n$</span>-ary intersection (IntersectionArray)</a></li><li><a href="../lazy_operations/MinkowskiSum/#def_MinkowskiSum-1">Binary Minkowski sum (MinkowskiSum)</a></li><li><a href="../lazy_operations/MinkowskiSum/#def_MinkowskiSumArray-1"><span>$n$</span>-ary Minkowski sum (MinkowskiSumArray)</a></li><li><a href="../lazy_operations/MinkowskiSum/#def_CachedMinkowskiSumArray-1"><span>$n$</span>-ary Minkowski sum with cache (CachedMinkowskiSumArray)</a></li><li><a href="../lazy_operations/UnionSet/#def_UnionSet-1">Binary set union (UnionSet)</a></li><li><a href="../lazy_operations/UnionSet/#def_UnionSetArray-1"><span>$n$</span>-ary set union (UnionSetArray)</a></li><li><a href="../lazy_operations/Complement/#def_Complement-1">Complement</a></li><li><a href="../lazy_operations/Rectification/#def_Rectification-1">Rectification</a></li></ul><h2><a class="nav-anchor" id="def_AbstractCentrallySymmetric-1" href="#def_AbstractCentrallySymmetric-1">Centrally symmetric sets (AbstractCentrallySymmetric)</a></h2><p>Centrally symmetric sets such as balls of different norms are characterized by a center. Note that there is a special interface combination <a href="#def_AbstractCentrallySymmetricPolytope-1">Centrally symmetric polytope</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractCentrallySymmetric" href="#LazySets.AbstractCentrallySymmetric"><code>LazySets.AbstractCentrallySymmetric</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractCentrallySymmetric{N&lt;:Real} &lt;: LazySet{N}</code></pre><p>Abstract type for centrally symmetric sets.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractCentrallySymmetric</code> must define the following functions:</p><ul><li><code>center(::AbstractCentrallySymmetric{N})</code> – return the center   point</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractCentrallySymmetric)
3-element Array{Any,1}:
 Ball2
 Ballp
 Ellipsoid</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractCentrallySymmetric.jl#L7-L26">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractCentrallySymmetric}" href="#LazySets.dim-Tuple{AbstractCentrallySymmetric}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(S::AbstractCentrallySymmetric)</code></pre><p>Return the ambient dimension of a centrally symmetric set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractCentrallySymmetric.jl#L31-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{AbstractCentrallySymmetric}" href="#LazySets.isbounded-Tuple{AbstractCentrallySymmetric}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(S::AbstractCentrallySymmetric)</code></pre><p>Determine whether a centrally symmetric set is bounded.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p><code>true</code> (since a set with a unique center must be bounded).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractCentrallySymmetric.jl#L48-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isuniversal-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}, Tuple{AbstractCentrallySymmetric{N},Bool}} where N&lt;:Real" href="#LazySets.isuniversal-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}, Tuple{AbstractCentrallySymmetric{N},Bool}} where N&lt;:Real"><code>LazySets.isuniversal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isuniversal(S::AbstractCentrallySymmetric{N}, [witness]::Bool=false
           ) where {N&lt;:Real}</code></pre><p>Check whether a centrally symmetric set is universal.</p><p><strong>Input</strong></p><ul><li><code>S</code>       – centrally symmetric set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>false</code></li><li>If <code>witness</code> option is activated: <code>(false, v)</code> where <span>$v ∉ S$</span></li></ul><p><strong>Algorithm</strong></p><p>A witness is obtained by computing the support vector in direction <code>d = [1, 0, …, 0]</code> and adding <code>d</code> on top.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractCentrallySymmetric.jl#L99-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(S::AbstractCentrallySymmetric{N}) where {N&lt;:Real}</code></pre><p>Return some element of a centrally symmetric set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p>The center of the centrally symmetric set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractCentrallySymmetric.jl#L65-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{AbstractCentrallySymmetric}" href="#Base.isempty-Tuple{AbstractCentrallySymmetric}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(S::AbstractCentrallySymmetric)</code></pre><p>Return if a centrally symmetric set is empty or not.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractCentrallySymmetric.jl#L82-L94">source</a></section><h3><a class="nav-anchor" id="Implementations-2" href="#Implementations-2">Implementations</a></h3><ul><li><a href="../sets/Ball2/#def_Ball2-1">Euclidean-norm ball (Ball2)</a></li><li><a href="../sets/Ellipsoid/#def_Ellipsoid-1">Ellipsoid</a></li><li><a href="../sets/Ballp/#def_Ballp-1">p-norm ball (Ballp)</a></li></ul><h2><a class="nav-anchor" id="def_AbstractPolyhedron-1" href="#def_AbstractPolyhedron-1">Polyhedra (AbstractPolyhedron)</a></h2><p>A polyhedron has finitely many facets (<em>H-representation</em>) and is not necessarily bounded.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractPolyhedron" href="#LazySets.AbstractPolyhedron"><code>LazySets.AbstractPolyhedron</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractPolyhedron{N&lt;:Real} &lt;: LazySet{N}</code></pre><p>Abstract type for compact convex polyhedral sets.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolyhedron</code> must define the following functions:</p><ul><li><code>constraints_list(::AbstractPolyhedron{N})</code> – return a list of all facet   constraints</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolyhedron)
6-element Array{Any,1}:
 AbstractPolytope
 HPolyhedron
 HalfSpace
 Hyperplane
 Line
 Universe</code></pre><p>Polyhedra are defined as the intersection of a finite number of closed half-spaces. As such, polyhedra are closed and convex but not necessarily bounded. Bounded polyhedra are called <em>polytopes</em> (see <a href="#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolyhedron.jl#L3-L29">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractPolyhedron{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractPolyhedron{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, P::AbstractPolyhedron{N}) where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a polyhedron.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>P</code> – polyhedron</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation checks if the point lies inside each defining half-space.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolyhedron_functions.jl#L27-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isuniversal-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}, Tuple{AbstractPolyhedron{N},Bool}} where N&lt;:Real" href="#LazySets.isuniversal-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}, Tuple{AbstractPolyhedron{N},Bool}} where N&lt;:Real"><code>LazySets.isuniversal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isuniversal(P::AbstractPolyhedron{N}, [witness]::Bool=false
           ) where {N&lt;:Real}</code></pre><p>Check whether a polyhedron is universal.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polyhedron</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P$</span> is universal</li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$P$</span> is universal</li><li><code>(false, v)</code> iff <span>$P$</span> is not universal and <span>$v ∉ P$</span></li></ul></li></ul><p><strong>Algorithm</strong></p><p><code>P</code> is universal iff it has no constraints.</p><p>A witness is produced using <code>isuniversal(H)</code> where <code>H</code> is the first linear constraint of <code>P</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolyhedron_functions.jl#L57-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constrained_dimensions-Tuple{AbstractPolyhedron}" href="#LazySets.constrained_dimensions-Tuple{AbstractPolyhedron}"><code>LazySets.constrained_dimensions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constrained_dimensions(P::AbstractPolyhedron) where {N&lt;:Real}</code></pre><p>Return the indices in which a polyhedron is constrained.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polyhedron</li></ul><p><strong>Output</strong></p><p>A vector of ascending indices <code>i</code> such that the polyhedron is constrained in dimension <code>i</code>.</p><p><strong>Examples</strong></p><p>A 2D polyhedron with constraint <span>$x1 ≥ 0$</span> is constrained in dimension 1 only.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolyhedron_functions.jl#L92-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolyhedron{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolyhedron{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N},
           P::AbstractPolyhedron{N};
           [algorithm]::Union{String, Nothing}=nothing,
           [check_invertibility]::Bool=true,
           [cond_tol]::Number=DEFAULT_COND_TOL,
           [inverse]::Union{AbstractMatrix{N}, Nothing}=nothing,
           [backend]=nothing,
           [elimination_method]=nothing) where {N&lt;:Real}</code></pre><p>Concrete linear map of a polyhedral set.</p><p><strong>Input</strong></p><ul><li><p><code>M</code>         – matrix</p></li><li><p><code>P</code>         – polyhedral set</p></li><li><p><code>algorithm</code> – (optional; default: <code>nothing</code>) algorithm to be used; for the                description see the Algorithm section below; possible choices are:</p><ul><li><code>&quot;inverse&quot;</code>, alias: <code>&quot;inv&quot;</code></li><li><code>&quot;inverse_right&quot;</code>, alias: <code>&quot;inv_right&quot;</code></li><li><code>&quot;elimination&quot;</code>, alias: <code>&quot;elim&quot;</code></li><li><code>&quot;lift&quot;</code></li><li><code>&quot;vrep&quot;</code></li></ul></li><li><p><code>check_invertibility</code> – (optional, default: <code>true</code>) if <code>true</code> check whether                          given matrix <code>M</code> is invertible; set to <code>false</code> only                          if you know that <code>M</code> is invertible</p></li><li><p><code>cond_tol</code>  – (optional; default: <code>DEFAULT_COND_TOL</code>) tolerance of matrix                condition (used to check whether the matrix is invertible)</p></li><li><p><code>inverse</code>   – (optional; default: <code>nothing</code>) matrix inverse <code>M⁻¹</code>; use this                option if you have already computed the inverse matrix of <code>M</code></p></li><li><p><code>backend</code>   – (optional: default: <code>nothing</code>) polyhedra backend</p></li><li><p><code>elimination_method</code>  – (optional: default: <code>nothing</code>) elimination method for                          the <code>&quot;elimination&quot;</code> algorithm</p></li></ul><p><strong>Output</strong></p><p>The type of the result is &quot;as close as possible&quot; to the the type of <code>P</code>. Let <code>(m, n)</code> be the size of <code>M</code>, where <code>m ≠ n</code> is allowed for rectangular maps.</p><p>To fix the type of the output to something different than the default value, consider post-processing the result of this function with a call to a suitable <code>convert</code> method.</p><p>In particular, the output depends on the type of <code>P</code>, on <code>m</code>, and the algorithm that was used:</p><ul><li><p>If the vertex-based approach was used:</p><ul><li>If <code>P</code> is a <code>VPolygon</code> and <code>m = 2</code> then the output is a <code>VPolygon</code>.</li><li>If <code>P</code> is a <code>VPolytope</code> then the output is a <code>VPolytope</code>.</li><li>Otherwise, the output is an <code>Interval</code> if <code>m = 1</code>, a <code>VPolygon</code> if <code>m = 2</code> and a <code>VPolytope</code> in other cases.</li></ul></li><li><p>If the invertibility criterion was used:</p><ul><li>The types of <code>HalfSpace</code>, <code>Hyperplane</code>, <code>Line</code> and <code>AbstractHPolygon</code> are preserved.</li><li>If <code>P</code> is an <code>AbstractPolytope</code>, then the output is an <code>Interval</code> if <code>m = 1</code>, an <code>HPolygon</code> if <code>m = 2</code> and an <code>HPolytope</code> in other cases.</li><li>Otherwise, the output is an <code>HPolyhedron</code>.</li></ul></li></ul><p><strong>Notes</strong></p><p>Since the different linear map algorithms work at the level of constraints (not sets representations), this function uses dispatch on two stages: once the algorithm has been defined, first the helper functions <code>_linear_map_hrep_helper</code> (resp. <code>_linear_map_vrep</code>) are invoked, which dispatch on the set type. Then, each helper function calls the concrete implementation of <code>_linear_map_hrep</code>, which dispatches on the algorithm, and returns a list of constraints.</p><p>To simplify working with different algorithms and options, the types <code>&lt;: AbstractLinearMapAlgorithm</code> are used. These types are singleton type or types that carry only the key data for the given algorithm, such as the matrix inverse or the polyhedra backend.</p><p>New subtypes of the <code>AbstractPolyhedron</code> interface may define their own helper functions <code>_linear_map_vrep</code>, respectively <code>_linear_map_hrep_helper</code> for special handling of the constraints returned by the implementations of <code>_linear_map_hrep</code>; otherwise the fallback implementation for <code>AbstractPolyhedron</code> is used, which instantiates an <code>HPolyhedron</code>.</p><p><strong>Algorithm</strong></p><p>This function mainly implements several approaches for the linear map: inverse, right inverse, transformation to the vertex representation, variable elimination, and variable lifting. Depending on the properties of <code>M</code> and <code>P</code>, one algorithm may be preferable over the other. Details on the algorithms are given in the following subsections.</p><p>Otherwise, if the algorithm argument is not specified, a default option is chosen based on heuristics on the types and values of <code>M</code> and <code>P</code>:</p><ul><li>If the <code>&quot;inverse&quot;</code> algorithm applies, it is used.</li><li>If the <code>&quot;inverse_right&quot;</code> algorithm applies, it is used.</li><li>Otherwise, if the <code>&quot;lift&quot;</code> algorithm applies, it is used.</li><li>Otherwise, the <code>&quot;elimination&quot;</code> algorithm is used.</li></ul><p>Note that <code>&quot;inverse&quot;</code> does not require the external library <code>Polyhedra</code>, and neither does <code>&quot;inverse_right&quot;</code>. However, the fallback method <code>&quot;elimination&quot;</code> requires <code>Polyhedra</code> as well as the library <code>CDDLib</code>.</p><p>The optional keyword arguments <code>inverse</code> and <code>check_invertibility</code> modify the default behavior:</p><ul><li>If an inverse matrix is passed in <code>inverse</code>, the given algorithm is applied, and if none is given, either <code>&quot;inverse&quot;</code> or <code>&quot;inverse_right&quot;</code> is applied (in that order of preference).</li><li>If <code>check_invertibility</code> is set to <code>false</code>, the given algorithm is applied, and if none is given, either <code>&quot;inverse&quot;</code> or <code>&quot;inverse_right&quot;</code> is applied (in that order of preference).</li></ul><p><strong>Inverse</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm=&quot;inverse&quot;</code> (or <code>algorithm=&quot;inv&quot;</code>). The algorithm requires that <code>M</code> is invertible, square, and dense. If you know a priori that <code>M</code> is invertible, set the flag <code>check_invertibility=false</code>, such that no extra checks are done within <code>linear_map</code>. Otherwise, we check the sufficient condition that the condition number of <code>M</code> is not too high. The threshold for the condition number can be modified from its default value, <code>DEFAULT_COND_TOL</code>, by passing a custom <code>cond_tol</code>.</p><p>The algorithm is described next. Assuming that the matrix <span>$M$</span> is invertible (which we check via a sufficient condition,), <span>$y = M x$</span> implies <span>$x = \text{inv}(M) y$</span> and we can transform the polyhedron <span>$A x ≤ b$</span> to the polyhedron <span>$A \text{inv}(M) y ≤ b$</span>.</p><p>If the dense condition on <code>M</code> is not fullfilled, there are two suggested workarounds: either transform to dense matrix, i.e. calling <code>linear_map</code> with <code>Matrix(M)</code>, or use the <code>&quot;inverse_right&quot;</code> algorithm, which does not compute the inverse matrix explicitly, but uses a polyalgorithm; see the documentation of <code>?</code> for details.</p><p><strong>Inverse-right</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm=&quot;inverse_right&quot;</code> (or <code>algorithm=&quot;inv_right&quot;</code>). This algorithm applies to square and invertible matrices <code>M</code>. The idea is essentially the same as for the <code>&quot;inverse&quot;</code> algorithm; the difference is that in <code>&quot;inverse&quot;</code> the full matrix inverse is computed, and in <code>&quot;inverse_right&quot;</code> only the left division on the normal vectors is used. In particular, <code>&quot;inverse_right&quot;</code> is good as a workaround when <code>M</code> is sparse (since the <code>inv</code> function is not available for sparse matrices).</p><p><strong>Elimination</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm = &quot;elimination&quot;</code> or <code>algorithm = &quot;elim&quot;</code>. The algorithm applies to any matrix <code>M</code> (invertible or not), and any polyhedron <code>P</code> (bounded or not).</p><p>The idea is described next. If <code>P : Ax &lt;= b</code> and <code>y = Mx</code> denote the polyhedron and the linear map respectively, we consider the vector <code>z = [y, x]</code>, write the given equalities and the inequalities, and then eliminate the last x variables (there are <code>length(x)</code> in total) using a call to <code>Polyhedra.eliminate</code> to a backend library that can do variable elimination, typically <code>CDDLib</code> with the <code>BlockElimination()</code> algorithm. In this way we have eliminated the &quot;old&quot; variables <code>x</code> and kept the &quot;new&quot; or transformed variables &quot;y&quot;.</p><p>The default elimination method is block elimination. For possible options we refer to the documentation of Polyhedra, <a href="https://juliapolyhedra.github.io/Polyhedra.jl/latest/projection/">projection/elimination</a>.</p><p><strong>Lift</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm=&quot;lift&quot;</code>. The algorithm applies if <code>M</code> is rectangular of size <code>m × n</code> with <code>m &gt; n</code> and full rank (i.e. of rank <code>n</code>).</p><p>The idea is to embed the polyhedron into the <code>m</code>-dimensional space by appending zeros, i.e. extending all constraints of <code>P</code> to <code>m</code> dimensions, and constraining the last <code>m - n</code> dimensions to <code>0</code>. The matrix resulting matrix is extended to an invertible <code>m × m</code> matrix and the algorithm using the inverse of the linear map is applied. For the technical details of the extension of <code>M</code> to a higher-dimensional invertible matrix, see <code>LazySets.Arrays.extend</code>.</p><p><strong>Vertex representation</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm=&quot;vrep&quot;</code>. The idea is to convert the polyhedron to its vertex representation and apply the linear map to each vertex of <code>P</code>.</p><p>The returned set is a polytope in vertex representation. Note that conversion of the result back to half-space representation is not computed by default, since this may be costly. If you used this algorithm and still want to convert back to half-space representation, apply <code>tohrep</code> to the result of this function. Note that this method only works for bounded polyhedra.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolyhedron_functions.jl#L388-L574">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.chebyshev_center-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}} where N&lt;:AbstractFloat" href="#LazySets.chebyshev_center-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}} where N&lt;:AbstractFloat"><code>LazySets.chebyshev_center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">chebyshev_center(P::AbstractPolyhedron{N};
                 [get_radius]::Bool=false,
                 [backend]=default_polyhedra_backend(P, N),
                 [solver]=JuMP.with_optimizer(GLPK.Optimizer)
                 ) where {N&lt;:AbstractFloat}</code></pre><p>Compute the <a href="https://en.wikipedia.org/wiki/Chebyshev_center">Chebyshev center</a> of a polytope.</p><p><strong>Input</strong></p><ul><li><code>P</code>          – polytope</li><li><code>get_radius</code> – (optional; default: <code>false</code>) option to additionally return the                 radius of the largest ball enclosed by <code>P</code> around the                 Chebyshev center</li><li><code>backend</code>    – (optional; default: <code>default_polyhedra_backend(P, N)</code>) the                 backend for polyhedral computations</li><li><code>solver</code>     – (optional; default: <code>JuMP.with_optimizer(GLPK.Optimizer)</code>) the                 LP solver passed to <code>Polyhedra</code></li></ul><p><strong>Output</strong></p><p>If <code>get_radius</code> is <code>false</code>, the result is the Chebyshev center of <code>P</code>. If <code>get_radius</code> is <code>true</code>, the result is the pair <code>(c, r)</code> where <code>c</code> is the Chebyshev center of <code>P</code> and <code>r</code> is the radius of the largest ball with center <code>c</code> enclosed by <code>P</code>.</p><p><strong>Notes</strong></p><p>The Chebyshev center is the center of a largest Euclidean ball enclosed by <code>P</code>. In general, the center of such a ball is not unique (but the radius is).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolyhedron_functions.jl#L806-L838">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(P::AbstractPolyhedron{N}) where {N&lt;:Real}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polyhedron</li></ul><p><strong>Output</strong></p><p>An element of a polyhedron.</p><p><strong>Algorithm</strong></p><p>An element of the polyhedron is obtained by evaluating its support vector along direction <span>$[1, 0, …, 0]$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolyhedron_functions.jl#L855-L872">source</a></section><p>Plotting (bounded) polyhedra is available, too:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.plot_recipe-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}, Tuple{AbstractPolyhedron{N},N}} where N&lt;:Real" href="#LazySets.plot_recipe-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}, Tuple{AbstractPolyhedron{N},N}} where N&lt;:Real"><code>LazySets.plot_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_recipe(P::AbstractPolyhedron{N}, [ε]::N=zero(N)) where {N&lt;:Real}</code></pre><p>Convert a (bounded) polyhedron to a pair <code>(x, y)</code> of points for plotting.</p><p><strong>Input</strong></p><ul><li><code>P</code> – bounded polyhedron</li><li><code>ε</code> – (optional, default: <code>0</code>) ignored, used for dispatch</li></ul><p><strong>Output</strong></p><p>A pair <code>(x, y)</code> of points that can be plotted.</p><p><strong>Algorithm</strong></p><p>We first assert that <code>P</code> is bounded (i.e., that <code>P</code> is a polytope).</p><p>One-dimensional polytopes are converted to an <code>Interval</code>. Three-dimensional or higher-dimensional polytopes are not supported.</p><p>For two-dimensional polytopes (i.e., polygons) we compute their set of vertices using <code>vertices_list</code> and then plot the convex hull of these vertices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolyhedron_functions.jl#L758-L781">source</a></section><h3><a class="nav-anchor" id="Implementations-3" href="#Implementations-3">Implementations</a></h3><ul><li><a href="../sets/HalfSpace/#def_HalfSpace-1">Half-space (HalfSpace)</a></li><li><a href="../sets/HPolyhedron/#def_HPolyhedron-1">Polyhedron in constraint representation (HPolyhedron)</a></li><li><a href="../sets/Hyperplane/#def_Hyperplane-1">Hyperplane</a></li><li><a href="../sets/Line/#def_Line-1">Line</a></li><li><a href="../sets/Universe/#def_Universe-1">Universe</a></li></ul><h2><a class="nav-anchor" id="def_AbstractPolytope-1" href="#def_AbstractPolytope-1">Polytopes (AbstractPolytope)</a></h2><p>A polytope is a bounded set with finitely many vertices (<em>V-representation</em>) resp. facets (<em>H-representation</em>). Note that there is a special interface combination <a href="#def_AbstractCentrallySymmetricPolytope-1">Centrally symmetric polytope</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractPolytope" href="#LazySets.AbstractPolytope"><code>LazySets.AbstractPolytope</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractPolytope{N&lt;:Real} &lt;: AbstractPolyhedron{N}</code></pre><p>Abstract type for compact convex polytopic sets.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolytope</code> must define the following functions:</p><ul><li><code>vertices_list(::AbstractPolytope{N})</code> – return a list of all vertices</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolytope)
4-element Array{Any,1}:
 AbstractCentrallySymmetricPolytope
 AbstractPolygon
 HPolytope
 VPolytope</code></pre><p>A polytope is a bounded polyhedron (see <a href="#LazySets.AbstractPolyhedron"><code>AbstractPolyhedron</code></a>). Polytopes are compact convex sets with either of the following equivalent properties:</p><ol><li>They are the intersection of a finite number of closed half-spaces.</li><li>They are the convex hull of finitely many vertices.</li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolytope.jl#L9-L33">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{AbstractPolytope}" href="#LazySets.isbounded-Tuple{AbstractPolytope}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(P::AbstractPolytope)</code></pre><p>Determine whether a polytopic set is bounded.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polytopic set</li></ul><p><strong>Output</strong></p><p><code>true</code> (since a polytope must be bounded).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolytope.jl#L42-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isuniversal-Union{Tuple{AbstractPolytope{N}}, Tuple{N}, Tuple{AbstractPolytope{N},Bool}} where N&lt;:Real" href="#LazySets.isuniversal-Union{Tuple{AbstractPolytope{N}}, Tuple{N}, Tuple{AbstractPolytope{N},Bool}} where N&lt;:Real"><code>LazySets.isuniversal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isuniversal(P::AbstractPolytope{N}, [witness]::Bool=false
           ) where {N&lt;:Real}</code></pre><p>Check whether a polyhedron is universal.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polyhedron</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>false</code></li><li>If <code>witness</code> option is activated: <code>(false, v)</code> where <span>$v ∉ P$</span></li></ul><p><strong>Algorithm</strong></p><p>A witness is produced using <code>isuniversal(H)</code> where <code>H</code> is the first linear constraint of <code>P</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolytope.jl#L98-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">singleton_list(P::AbstractPolytope{N}) where {N&lt;:Real}</code></pre><p>Return the vertices of a polytopic set as a list of singletons.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polytopic set</li></ul><p><strong>Output</strong></p><p>List containing a singleton for each vertex.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolytope.jl#L59-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{AbstractPolytope}" href="#Base.isempty-Tuple{AbstractPolytope}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(P::AbstractPolytope)</code></pre><p>Determine whether a polytope is empty.</p><p><strong>Input</strong></p><ul><li><code>P</code> – abstract polytope</li></ul><p><strong>Output</strong></p><p><code>true</code> if the given polytope contains no vertices, and <code>false</code> otherwise.</p><p><strong>Algorithm</strong></p><p>This algorithm checks whether the <code>vertices_list</code> of the given polytope is empty or not.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolytope.jl#L76-L93">source</a></section><h3><a class="nav-anchor" id="Implementations-4" href="#Implementations-4">Implementations</a></h3><ul><li><a href="../sets/HPolytope/#def_HPolytope-1">Polytope in constraint representation (HPolytope)</a></li><li><a href="../sets/VPolytope/#def_VPolytope-1">Polytope in vertex representation (VPolytope)</a></li></ul><h2><a class="nav-anchor" id="def_AbstractPolygon-1" href="#def_AbstractPolygon-1">Polygons (AbstractPolygon)</a></h2><p>A polygon is a two-dimensional polytope.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractPolygon" href="#LazySets.AbstractPolygon"><code>LazySets.AbstractPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractPolygon{N&lt;:Real} &lt;: AbstractPolytope{N}</code></pre><p>Abstract type for polygons (i.e., 2D polytopes).</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolygon</code> must define the following functions:</p><ul><li><code>tovrep(::AbstractPolygon{N})</code>         – transform into   V-representation</li><li><code>tohrep(::AbstractPolygon{N}) where {S&lt;:AbstractHPolygon{N}}</code> – transform   into H-representation</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolygon)
2-element Array{Any,1}:
 AbstractHPolygon
 VPolygon</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolygon.jl#L7-L26">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractPolygon}" href="#LazySets.dim-Tuple{AbstractPolygon}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(P::AbstractPolygon)</code></pre><p>Return the ambient dimension of a polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polygon, which is 2.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolygon.jl#L34-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolygon{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolygon{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N},
           P::AbstractPolyhedron{N};
           [algorithm]::Union{String, Nothing}=nothing,
           [check_invertibility]::Bool=true,
           [cond_tol]::Number=DEFAULT_COND_TOL,
           [inverse]::Union{AbstractMatrix{N}, Nothing}=nothing,
           [backend]=nothing,
           [elimination_method]=nothing) where {N&lt;:Real}</code></pre><p>Concrete linear map of a polyhedral set.</p><p><strong>Input</strong></p><ul><li><p><code>M</code>         – matrix</p></li><li><p><code>P</code>         – polyhedral set</p></li><li><p><code>algorithm</code> – (optional; default: <code>nothing</code>) algorithm to be used; for the                description see the Algorithm section below; possible choices are:</p><ul><li><code>&quot;inverse&quot;</code>, alias: <code>&quot;inv&quot;</code></li><li><code>&quot;inverse_right&quot;</code>, alias: <code>&quot;inv_right&quot;</code></li><li><code>&quot;elimination&quot;</code>, alias: <code>&quot;elim&quot;</code></li><li><code>&quot;lift&quot;</code></li><li><code>&quot;vrep&quot;</code></li></ul></li><li><p><code>check_invertibility</code> – (optional, default: <code>true</code>) if <code>true</code> check whether                          given matrix <code>M</code> is invertible; set to <code>false</code> only                          if you know that <code>M</code> is invertible</p></li><li><p><code>cond_tol</code>  – (optional; default: <code>DEFAULT_COND_TOL</code>) tolerance of matrix                condition (used to check whether the matrix is invertible)</p></li><li><p><code>inverse</code>   – (optional; default: <code>nothing</code>) matrix inverse <code>M⁻¹</code>; use this                option if you have already computed the inverse matrix of <code>M</code></p></li><li><p><code>backend</code>   – (optional: default: <code>nothing</code>) polyhedra backend</p></li><li><p><code>elimination_method</code>  – (optional: default: <code>nothing</code>) elimination method for                          the <code>&quot;elimination&quot;</code> algorithm</p></li></ul><p><strong>Output</strong></p><p>The type of the result is &quot;as close as possible&quot; to the the type of <code>P</code>. Let <code>(m, n)</code> be the size of <code>M</code>, where <code>m ≠ n</code> is allowed for rectangular maps.</p><p>To fix the type of the output to something different than the default value, consider post-processing the result of this function with a call to a suitable <code>convert</code> method.</p><p>In particular, the output depends on the type of <code>P</code>, on <code>m</code>, and the algorithm that was used:</p><ul><li><p>If the vertex-based approach was used:</p><ul><li>If <code>P</code> is a <code>VPolygon</code> and <code>m = 2</code> then the output is a <code>VPolygon</code>.</li><li>If <code>P</code> is a <code>VPolytope</code> then the output is a <code>VPolytope</code>.</li><li>Otherwise, the output is an <code>Interval</code> if <code>m = 1</code>, a <code>VPolygon</code> if <code>m = 2</code> and a <code>VPolytope</code> in other cases.</li></ul></li><li><p>If the invertibility criterion was used:</p><ul><li>The types of <code>HalfSpace</code>, <code>Hyperplane</code>, <code>Line</code> and <code>AbstractHPolygon</code> are preserved.</li><li>If <code>P</code> is an <code>AbstractPolytope</code>, then the output is an <code>Interval</code> if <code>m = 1</code>, an <code>HPolygon</code> if <code>m = 2</code> and an <code>HPolytope</code> in other cases.</li><li>Otherwise, the output is an <code>HPolyhedron</code>.</li></ul></li></ul><p><strong>Notes</strong></p><p>Since the different linear map algorithms work at the level of constraints (not sets representations), this function uses dispatch on two stages: once the algorithm has been defined, first the helper functions <code>_linear_map_hrep_helper</code> (resp. <code>_linear_map_vrep</code>) are invoked, which dispatch on the set type. Then, each helper function calls the concrete implementation of <code>_linear_map_hrep</code>, which dispatches on the algorithm, and returns a list of constraints.</p><p>To simplify working with different algorithms and options, the types <code>&lt;: AbstractLinearMapAlgorithm</code> are used. These types are singleton type or types that carry only the key data for the given algorithm, such as the matrix inverse or the polyhedra backend.</p><p>New subtypes of the <code>AbstractPolyhedron</code> interface may define their own helper functions <code>_linear_map_vrep</code>, respectively <code>_linear_map_hrep_helper</code> for special handling of the constraints returned by the implementations of <code>_linear_map_hrep</code>; otherwise the fallback implementation for <code>AbstractPolyhedron</code> is used, which instantiates an <code>HPolyhedron</code>.</p><p><strong>Algorithm</strong></p><p>This function mainly implements several approaches for the linear map: inverse, right inverse, transformation to the vertex representation, variable elimination, and variable lifting. Depending on the properties of <code>M</code> and <code>P</code>, one algorithm may be preferable over the other. Details on the algorithms are given in the following subsections.</p><p>Otherwise, if the algorithm argument is not specified, a default option is chosen based on heuristics on the types and values of <code>M</code> and <code>P</code>:</p><ul><li>If the <code>&quot;inverse&quot;</code> algorithm applies, it is used.</li><li>If the <code>&quot;inverse_right&quot;</code> algorithm applies, it is used.</li><li>Otherwise, if the <code>&quot;lift&quot;</code> algorithm applies, it is used.</li><li>Otherwise, the <code>&quot;elimination&quot;</code> algorithm is used.</li></ul><p>Note that <code>&quot;inverse&quot;</code> does not require the external library <code>Polyhedra</code>, and neither does <code>&quot;inverse_right&quot;</code>. However, the fallback method <code>&quot;elimination&quot;</code> requires <code>Polyhedra</code> as well as the library <code>CDDLib</code>.</p><p>The optional keyword arguments <code>inverse</code> and <code>check_invertibility</code> modify the default behavior:</p><ul><li>If an inverse matrix is passed in <code>inverse</code>, the given algorithm is applied, and if none is given, either <code>&quot;inverse&quot;</code> or <code>&quot;inverse_right&quot;</code> is applied (in that order of preference).</li><li>If <code>check_invertibility</code> is set to <code>false</code>, the given algorithm is applied, and if none is given, either <code>&quot;inverse&quot;</code> or <code>&quot;inverse_right&quot;</code> is applied (in that order of preference).</li></ul><p><strong>Inverse</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm=&quot;inverse&quot;</code> (or <code>algorithm=&quot;inv&quot;</code>). The algorithm requires that <code>M</code> is invertible, square, and dense. If you know a priori that <code>M</code> is invertible, set the flag <code>check_invertibility=false</code>, such that no extra checks are done within <code>linear_map</code>. Otherwise, we check the sufficient condition that the condition number of <code>M</code> is not too high. The threshold for the condition number can be modified from its default value, <code>DEFAULT_COND_TOL</code>, by passing a custom <code>cond_tol</code>.</p><p>The algorithm is described next. Assuming that the matrix <span>$M$</span> is invertible (which we check via a sufficient condition,), <span>$y = M x$</span> implies <span>$x = \text{inv}(M) y$</span> and we can transform the polyhedron <span>$A x ≤ b$</span> to the polyhedron <span>$A \text{inv}(M) y ≤ b$</span>.</p><p>If the dense condition on <code>M</code> is not fullfilled, there are two suggested workarounds: either transform to dense matrix, i.e. calling <code>linear_map</code> with <code>Matrix(M)</code>, or use the <code>&quot;inverse_right&quot;</code> algorithm, which does not compute the inverse matrix explicitly, but uses a polyalgorithm; see the documentation of <code>?</code> for details.</p><p><strong>Inverse-right</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm=&quot;inverse_right&quot;</code> (or <code>algorithm=&quot;inv_right&quot;</code>). This algorithm applies to square and invertible matrices <code>M</code>. The idea is essentially the same as for the <code>&quot;inverse&quot;</code> algorithm; the difference is that in <code>&quot;inverse&quot;</code> the full matrix inverse is computed, and in <code>&quot;inverse_right&quot;</code> only the left division on the normal vectors is used. In particular, <code>&quot;inverse_right&quot;</code> is good as a workaround when <code>M</code> is sparse (since the <code>inv</code> function is not available for sparse matrices).</p><p><strong>Elimination</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm = &quot;elimination&quot;</code> or <code>algorithm = &quot;elim&quot;</code>. The algorithm applies to any matrix <code>M</code> (invertible or not), and any polyhedron <code>P</code> (bounded or not).</p><p>The idea is described next. If <code>P : Ax &lt;= b</code> and <code>y = Mx</code> denote the polyhedron and the linear map respectively, we consider the vector <code>z = [y, x]</code>, write the given equalities and the inequalities, and then eliminate the last x variables (there are <code>length(x)</code> in total) using a call to <code>Polyhedra.eliminate</code> to a backend library that can do variable elimination, typically <code>CDDLib</code> with the <code>BlockElimination()</code> algorithm. In this way we have eliminated the &quot;old&quot; variables <code>x</code> and kept the &quot;new&quot; or transformed variables &quot;y&quot;.</p><p>The default elimination method is block elimination. For possible options we refer to the documentation of Polyhedra, <a href="https://juliapolyhedra.github.io/Polyhedra.jl/latest/projection/">projection/elimination</a>.</p><p><strong>Lift</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm=&quot;lift&quot;</code>. The algorithm applies if <code>M</code> is rectangular of size <code>m × n</code> with <code>m &gt; n</code> and full rank (i.e. of rank <code>n</code>).</p><p>The idea is to embed the polyhedron into the <code>m</code>-dimensional space by appending zeros, i.e. extending all constraints of <code>P</code> to <code>m</code> dimensions, and constraining the last <code>m - n</code> dimensions to <code>0</code>. The matrix resulting matrix is extended to an invertible <code>m × m</code> matrix and the algorithm using the inverse of the linear map is applied. For the technical details of the extension of <code>M</code> to a higher-dimensional invertible matrix, see <code>LazySets.Arrays.extend</code>.</p><p><strong>Vertex representation</strong></p><p>This algorithm is invoked with the keyword argument <code>algorithm=&quot;vrep&quot;</code>. The idea is to convert the polyhedron to its vertex representation and apply the linear map to each vertex of <code>P</code>.</p><p>The returned set is a polytope in vertex representation. Note that conversion of the result back to half-space representation is not computed by default, since this may be costly. If you used this algorithm and still want to convert back to half-space representation, apply <code>tohrep</code> to the result of this function. Note that this method only works for bounded polyhedra.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolyhedron_functions.jl#L388-L574">source</a></section><p>The following helper functions are used for sorting directions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.jump2pi" href="#LazySets.jump2pi"><code>LazySets.jump2pi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">jump2pi(x::N) where {N&lt;:AbstractFloat}</code></pre><p>Return <span>$x + 2π$</span> if <span>$x$</span> is negative, otherwise return <span>$x$</span>.</p><p><strong>Input</strong></p><ul><li><code>x</code> – real scalar</li></ul><p><strong>Output</strong></p><p><span>$x + 2π$</span> if <span>$x$</span> is negative, <span>$x$</span> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LazySets: jump2pi

julia&gt; jump2pi(0.0)
0.0

julia&gt; jump2pi(-0.5)
5.783185307179586

julia&gt; jump2pi(0.5)
0.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolygon.jl#L51-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&lt;=-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:AbstractFloat" href="#Base.:&lt;=-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:AbstractFloat"><code>Base.:&lt;=</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">&lt;=(u::AbstractVector{N}, v::AbstractVector{N}) where {N&lt;:Real}</code></pre><p>Compare two 2D vectors by their direction.</p><p><strong>Input</strong></p><ul><li><code>u</code> – first 2D direction</li><li><code>v</code> – second 2D direction</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$\arg(u) [2π] ≤ \arg(v) [2π]$</span>.</p><p><strong>Notes</strong></p><p>The argument is measured in counter-clockwise fashion, with the 0 being the direction (1, 0).</p><p><strong>Algorithm</strong></p><p>The implementation checks the quadrant of each direction, and compares directions using the right-hand rule (see <a href="../utils/#LazySets.Arrays.is_right_turn"><code>is_right_turn</code></a>). In particular, this method does not use the arctangent.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolygon.jl#L117-L141">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&lt;=-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:Real" href="#Base.:&lt;=-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:Real"><code>Base.:&lt;=</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">&lt;=(u::AbstractVector{N}, v::AbstractVector{N}) where {N&lt;:Real}</code></pre><p>Compare two 2D vectors by their direction.</p><p><strong>Input</strong></p><ul><li><code>u</code> – first 2D direction</li><li><code>v</code> – second 2D direction</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$\arg(u) [2π] ≤ \arg(v) [2π]$</span>.</p><p><strong>Notes</strong></p><p>The argument is measured in counter-clockwise fashion, with the 0 being the direction (1, 0).</p><p><strong>Algorithm</strong></p><p>The implementation checks the quadrant of each direction, and compares directions using the right-hand rule (see <a href="utils/#LazySets.Arrays.is_right_turn"><code>is_right_turn</code></a>). In particular, this method does not use the arctangent.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolygon.jl#L117-L141">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.quadrant-Tuple{AbstractArray{Real,1}}" href="#LazySets.quadrant-Tuple{AbstractArray{Real,1}}"><code>LazySets.quadrant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">quadrant(w::AbstractVector{N}) where {N&lt;:Real}</code></pre><p>Compute the quadrant where the direction <code>w</code> belongs.</p><p><strong>Input</strong></p><ul><li><code>w</code> –  direction</li></ul><p><strong>Output</strong></p><p>An integer from 0 to 3, with the following convention:</p><pre><code class="language-none">     ^
   1 | 0
  ---+--&gt;
   2 | 3</code></pre><p><strong>Algorithm</strong></p><p>The idea is to encode the following logic function: <span>$11 ↦ 0, 01 ↦ 1, 00 ↦ 2, 10 ↦ 3$</span>, according to the convention of above.</p><p>This function is inspired from AGPX&#39;s answer in: <a href="https://stackoverflow.com/a/46635372">Sort points in clockwise order?</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolygon.jl#L83-L110">source</a></section><h3><a class="nav-anchor" id="Implementations-5" href="#Implementations-5">Implementations</a></h3><ul><li><a href="../sets/VPolygon/#def_VPolygon-1">Polygon in vertex representation (VPolygon)</a></li></ul><h2><a class="nav-anchor" id="def_AbstractHPolygon-1" href="#def_AbstractHPolygon-1">Polygons in constraint representation (AbstractHPolygon)</a></h2><p>An HPolygon is a polygon in H-representation (or constraint representation).</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractHPolygon" href="#LazySets.AbstractHPolygon"><code>LazySets.AbstractHPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractHPolygon{N&lt;:Real} &lt;: AbstractPolygon{N}</code></pre><p>Abstract type for polygons in H-representation (i.e., constraints).</p><p><strong>Notes</strong></p><p>All subtypes must satisfy the invariant that constraints are sorted counter-clockwise.</p><p>Every concrete <code>AbstractHPolygon</code> must have the following fields:</p><ul><li><code>constraints::Vector{LinearConstraint{N, AbstractVector{N}}}</code> – the constraints</li></ul><p>New subtypes should be added to the <code>convert</code> method in order to be convertible.</p><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractHPolygon)
2-element Array{Any,1}:
 HPolygon
 HPolygonOpt</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHPolygon.jl#L20-L41">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(P::AbstractHPolygon{N}) where {N&lt;:Real}</code></pre><p>Return some element of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>A vertex of the polygon in constraint representation (the first one in the order of the constraints).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHPolygon.jl#L165-L178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHPolygon{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHPolygon{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, P::AbstractHPolygon{N}) where {N&lt;:Real}</code></pre><p>Check whether a given 2D point is contained in a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>x</code> – two-dimensional point/vector</li><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation checks if the point lies on the outside of each edge.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHPolygon.jl#L185-L203">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Union{Tuple{Type{HPOLYGON}}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon" href="#Base.rand-Union{Tuple{Type{HPOLYGON}}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{HPOLYGON}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing,
     [num_constraints]::Int=-1) where {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Create a random polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPOLYGON</code>        – type for dispatch</li><li><code>N</code>               – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>             – (optional, default: 2) dimension</li><li><code>rng</code>             – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>            – (optional, default: <code>nothing</code>) seed for reseeding</li><li><code>num_constraints</code> – (optional, default: <code>-1</code>) number of constraints of the                      polygon (must be 3 or bigger; see comment below)</li></ul><p><strong>Output</strong></p><p>A random polygon in constraint representation.</p><p><strong>Algorithm</strong></p><p>We create a random polygon in vertex representation and convert it to constraint representation. See <a href="../sets/VPolygon/#Base.rand-Tuple{Type{VPolygon}}"><code>rand(::Type{VPolygon})</code></a>. For non-flat polygons the number of vertices and the number of constraints are identical.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHPolygon.jl#L215-L243">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tohrep-Union{Tuple{HPOLYGON}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon" href="#LazySets.tohrep-Union{Tuple{HPOLYGON}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon"><code>LazySets.tohrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tohrep(P::HPOLYGON) where {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Build a contraint representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>The identity, i.e., the same polygon instance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHPolygon.jl#L67-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tovrep-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.tovrep-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.tovrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tovrep(P::AbstractHPolygon{N}) where {N&lt;:Real}</code></pre><p>Build a vertex representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>The same polygon but in vertex representation, a <code>VPolygon</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHPolygon.jl#L49-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.addconstraint!-Union{Tuple{N}, Tuple{AbstractHPolygon{N},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.addconstraint!-Union{Tuple{N}, Tuple{AbstractHPolygon{N},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">addconstraint!(P::AbstractHPolygon{N},
               constraint::LinearConstraint{N};
               [linear_search]::Bool=(length(P.constraints) &lt;
                                      BINARY_SEARCH_THRESHOLD),
               [prune]::Bool=true) where {N&lt;:Real}</code></pre><p>Add a linear constraint to a polygon in constraint representation, keeping the constraints sorted by their normal directions.</p><p><strong>Input</strong></p><ul><li><code>P</code>             – polygon in constraint representation</li><li><code>constraint</code>    – linear constraint to add</li><li><code>linear_search</code> – (optional, default: <code>length(constraints) &lt;                    BINARY_SEARCH_THRESHOLD</code>) flag to choose between linear                    and binary search</li><li><code>prune</code>         – (optional, default: <code>true</code>) flag for removing redundant                    constraints in the end</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHPolygon.jl#L373-L392">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.addconstraint!-Union{Tuple{LC}, Tuple{N}, Tuple{Array{LC,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where LC&lt;:(HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}) where N&lt;:Real" href="#LazySets.addconstraint!-Union{Tuple{LC}, Tuple{N}, Tuple{Array{LC,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where LC&lt;:(HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}) where N&lt;:Real"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">addconstraint!(constraints::Vector{LC},
               new_constraint::LinearConstraint{N};
               [linear_search]::Bool=(length(P.constraints) &lt;
                                      BINARY_SEARCH_THRESHOLD),
               [prune]::Bool=true
              ) where {N&lt;:Real, LC&lt;:LinearConstraint{N}}</code></pre><p>Add a linear constraint to a sorted vector of constrains, keeping the constraints sorted by their normal directions.</p><p><strong>Input</strong></p><ul><li><code>constraints</code>    – vector of linear constraintspolygon in constraint                     representation</li><li><code>new_constraint</code> – linear constraint to add</li><li><code>linear_search</code>  – (optional, default: <code>length(constraints) &lt;                     BINARY_SEARCH_THRESHOLD</code>) flag to choose between linear                     and binary search</li><li><code>prune</code>          – (optional, default: <code>true</code>) flag for removing redundant                     constraints in the end</li></ul><p><strong>Algorithm</strong></p><p>If <code>prune</code> is active, we check if the new constraint is redundant. If the constraint is not redundant, we perform the same check to the left and to the right until we find the first constraint that is not redundant.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHPolygon.jl#L402-L429">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isredundant-Union{Tuple{N}, Tuple{HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.isredundant-Union{Tuple{N}, Tuple{HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.isredundant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isredundant(cmid::LinearConstraint{N}, cright::LinearConstraint{N},
            cleft::LinearConstraint{N}) where {N&lt;:Real}</code></pre><p>Check whether a linear constraint is redundant wrt. two surrounding constraints.</p><p><strong>Input</strong></p><ul><li><code>cmid</code>   – linear constraint of concern</li><li><code>cright</code> – linear constraint to the right (clockwise turn)</li><li><code>cleft</code>  – linear constraint to the left (counter-clockwise turn)</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the constraint is redundant.</p><p><strong>Algorithm</strong></p><p>We first check whether the angle between the surrounding constraints is &lt; 180°, which is a necessary condition (unless the direction is identical to one of the other two constraints). If so, we next check if the angle is 0°, in which case the constraint <code>cmid</code> is redundant unless it is strictly tighter than the other two constraints. If the angle is strictly between 0° and 180°, the constraint <code>cmid</code> is redundant if and only if the vertex defined by the other two constraints lies inside the set defined by <code>cmid</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHPolygon.jl#L262-L288">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.remove_redundant_constraints!-Tuple{AbstractHPolygon}" href="#LazySets.remove_redundant_constraints!-Tuple{AbstractHPolygon}"><code>LazySets.remove_redundant_constraints!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">remove_redundant_constraints!(P::AbstractHPolygon)</code></pre><p>Remove all redundant constraints of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>The same polygon with all redundant constraints removed.</p><p><strong>Notes</strong></p><p>Since we only consider bounded polygons and a polygon needs at least three constraints to be bounded, we stop removing redundant constraints if there are three or less constraints left. This means that for non-bounded polygons the result may be unexpected.</p><p><strong>Algorithm</strong></p><p>We go through all consecutive triples of constraints and check if the one in the middle is redundant. For this we assume that the constraints are sorted.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHPolygon.jl#L324-L349">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(P::AbstractHPolygon{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints defining a polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in H-representation</li></ul><p><strong>Output</strong></p><p>The list of constraints of the polygon. The implementation guarantees that the constraints are sorted counter-clockwise.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHPolygon.jl#L143-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(P::AbstractHPolygon{N};
              apply_convex_hull::Bool=true,
              check_feasibility::Bool=true) where {N&lt;:Real}</code></pre><p>Return the list of vertices of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>                 – polygon in constraint representation</li><li><code>apply_convex_hull</code> – (optional, default: <code>true</code>) flag to post-process the                        intersection of constraints with a convex hull</li><li><code>check_feasibility</code> – (optional, default: <code>true</code>) flag to check whether the                        polygon was empty (required for correctness in case of                        empty polygons)</li></ul><p><strong>Output</strong></p><p>List of vertices.</p><p><strong>Algorithm</strong></p><p>We compute each vertex as the intersection of consecutive lines defined by the half-spaces. If <code>check_feasibility</code> is active, we then check if the constraints of the polygon were actually feasible (i.e., they pointed in the <em>right</em> direction). For this we compute the <em>average</em> of all vertices and check membership in each constraint.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHPolygon.jl#L88-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded" href="#LazySets.isbounded"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isbounded(P::AbstractHPolygon, [use_type_assumption]::Bool=true)</code></pre><p>Determine whether a polygon in constraint representation is bounded.</p><p><strong>Input</strong></p><ul><li><code>P</code>                   – polygon in constraint representation</li><li><code>use_type_assumption</code> – (optional, default: <code>true</code>) flag for ignoring the                          type assumption that polygons are bounded</li></ul><p><strong>Output</strong></p><p><code>true</code> if <code>use_type_assumption</code> is activated. Otherwise, <code>true</code> iff <code>P</code> is bounded.</p><p><strong>Algorithm</strong></p><p>If <code>!use_type_assumption</code>, we convert <code>P</code> to an <code>HPolyhedron</code> <code>P2</code> and then use <code>isbounded(P2)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHPolygon.jl#L554-L574">source</a></section><h3><a class="nav-anchor" id="Implementations-6" href="#Implementations-6">Implementations</a></h3><ul><li><a href="../sets/HPolygon/#def_HPolygon-1">Polygon in constraint representation (HPolygon)</a></li><li><a href="../sets/HPolygonOpt/#def_HPolygonOpt-1">Polygon in optimized constraint representation (HPolygonOpt)</a></li></ul><h2><a class="nav-anchor" id="def_AbstractCentrallySymmetricPolytope-1" href="#def_AbstractCentrallySymmetricPolytope-1">Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)</a></h2><p>A centrally symmetric polytope is a combination of two other interfaces: <a href="#def_AbstractCentrallySymmetric-1">Centrally symmetric sets</a> and <a href="#def_AbstractPolytope-1">Polytope</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractCentrallySymmetricPolytope" href="#LazySets.AbstractCentrallySymmetricPolytope"><code>LazySets.AbstractCentrallySymmetricPolytope</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractCentrallySymmetricPolytope{N&lt;:Real} &lt;: AbstractPolytope{N}</code></pre><p>Abstract type for centrally symmetric, polytopic sets. It combines the <code>AbstractCentrallySymmetric</code> and <code>AbstractPolytope</code> interfaces. Such a type combination is necessary as long as Julia does not support <a href="https://github.com/JuliaLang/julia/issues/5">multiple inheritance</a>.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractCentrallySymmetricPolytope</code> must define the following functions:</p><ul><li>from <code>AbstractCentrallySymmetric</code>:<ul><li><code>center(::AbstractCentrallySymmetricPolytope{N})</code> – return the  center point</li></ul></li><li>from <code>AbstractPolytope</code>:<ul><li><code>vertices_list(::AbstractCentrallySymmetricPolytope{N})</code>  – return a list of all vertices</li></ul></li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractCentrallySymmetricPolytope)
2-element Array{Any,1}:
 AbstractZonotope
 Ball1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractCentrallySymmetricPolytope.jl#L9-L34">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}" href="#LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(P::AbstractCentrallySymmetricPolytope)</code></pre><p>Return the ambient dimension of a centrally symmetric, polytopic set.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric, polytopic set</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polytopic set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractCentrallySymmetricPolytope.jl#L42-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(P::AbstractCentrallySymmetricPolytope{N}) where {N&lt;:Real}</code></pre><p>Return some element of a centrally symmetric polytope.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric polytope</li></ul><p><strong>Output</strong></p><p>The center of the centrally symmetric polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractCentrallySymmetricPolytope.jl#L60-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}" href="#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(P::AbstractCentrallySymmetricPolytope)</code></pre><p>Return if a centrally symmetric, polytopic set is empty or not.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric, polytopic set</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractCentrallySymmetricPolytope.jl#L77-L89">source</a></section><h3><a class="nav-anchor" id="Implementations-7" href="#Implementations-7">Implementations</a></h3><ul><li><a href="../sets/Ball1/#def_Ball1-1">Manhattan-norm ball (Ball1)</a></li></ul><h2><a class="nav-anchor" id="def_AbstractZonotope-1" href="#def_AbstractZonotope-1">Zonotopes (AbstractZonotope)</a></h2><p>A zonotope is a specific centrally symmetric polytope characterized by a center and a collection of generators.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractZonotope" href="#LazySets.AbstractZonotope"><code>LazySets.AbstractZonotope</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractZonotope{N&lt;:Real} &lt;: AbstractCentrallySymmetricPolytope{N}</code></pre><p>Abstract type for zonotopic sets.</p><p><strong>Notes</strong></p><p>Mathematically, a zonotope is defined as the set</p><div>\[Z = \left\{ c + ∑_{i=1}^p ξ_i g_i,~~ ξ_i \in [-1, 1]~~ ∀ i = 1,…, p \right\},\]</div><p>where <span>$c \in \mathbb{R}^n$</span> is its center and <span>$\{g_i\}_{i=1}^p$</span>, <span>$g_i \in \mathbb{R}^n$</span>, is the set of generators. This characterization defines a zonotope as the finite Minkowski sum of line segments. Zonotopes can be equivalently described as the image of a unit infinity-norm ball in <span>$\mathbb{R}^n$</span> by an affine transformation.</p><p>See <a href="../sets/Zonotope/#LazySets.Zonotope"><code>Zonotope</code></a> for a standard implementation of this interface.</p><p>Every concrete <code>AbstractZonotope</code> must define the following functions:</p><ul><li><code>genmat(::AbstractZonotope{N})</code> – return the generator matrix</li><li><code>generators(::AbstractZonotope{N})</code> – return an iterator over the generators</li></ul><p>Since the functions <code>genmat</code> and <code>generators</code> can be defined in terms of each other, it is sufficient to only genuinely implement one of them and let the implementation of the other function call the fallback implementation <code>genmat_fallback</code> resp. <code>generators_fallback</code>.</p><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractZonotope)
3-element Array{Any,1}:
 AbstractHyperrectangle
 LineSegment
 Zonotope</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractZonotope.jl#L10-L47">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ngens-Tuple{AbstractZonotope}" href="#LazySets.ngens-Tuple{AbstractZonotope}"><code>LazySets.ngens</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ngens(Z::AbstractZonotope)</code></pre><p>Return the number of generators of a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>An integer representing the number of generators.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractZonotope.jl#L178-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.genmat_fallback-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.genmat_fallback-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.genmat_fallback</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">genmat_fallback(Z::AbstractZonotope{N}) where {N&lt;:Real}</code></pre><p>Fallback definition of <code>genmat</code> for zonotopic sets.</p><p><strong>Input</strong></p><ul><li><code>Z</code>     – zonotopic set</li><li><code>gens</code>  – (optional; default: <code>generators(Z)</code>) iterator over generators</li><li><code>ngens</code> – (optional; default: <code>nothing</code>) number of generators or <code>nothing</code> if            unknown</li></ul><p><strong>Output</strong></p><p>A matrix where each column represents one generator of <code>Z</code>.</p><p><strong>Notes</strong></p><p>Passing the number of generators is much more efficient as otherwise the generators have to be obtained from the iterator (<code>gens</code>) and stored in an intermediate vector until the final result matrix can be allocated.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractZonotope.jl#L55-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.generators_fallback-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.generators_fallback-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.generators_fallback</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">generators_fallback(Z::AbstractZonotope{N}) where {N&lt;:Real}</code></pre><p>Fallback definition of <code>generators</code> for zonotopic sets.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>An iterator over the generators of <code>Z</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractZonotope.jl#L138-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractZonotope{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractZonotope{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, Z::AbstractZonotope{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a zonotopic set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>The support function of the zonotopic set in the given direction.</p><p><strong>Algorithm</strong></p><p>The support value is <span>$cᵀ d + ‖Gᵀ d‖₁$</span> where <span>$c$</span> is the center and <span>$G$</span> is the generator matrix of <code>Z</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractZonotope.jl#L221-L240">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractZonotope{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractZonotope{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, Z::AbstractZonotope{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a zonotopic set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>A support vector in the given direction. If the direction has norm zero, the vertex with <span>$ξ_i = 1 \ \ ∀ i = 1,…, p$</span> is returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractZonotope.jl#L245-L260">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractZonotope{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractZonotope{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, Z::AbstractZonotope{N};
  solver=default_lp_solver(N)) where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>x</code>      – point/vector</li><li><code>Z</code>      – zonotopic set</li><li><code>solver</code> – (optional, default: <code>default_lp_solver(N)</code>) the backend used to             solve the linear program</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ Z$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Z = Zonotope([1.0, 0.0], [0.1 0.0; 0.0 0.1]);

julia&gt; [1.0, 0.2] ∈ Z
false
julia&gt; [1.0, 0.1] ∈ Z
true</code></pre><p><strong>Algorithm</strong></p><p>The membership problem is computed by stating and solving the following linear program. Let <span>$p$</span> and <span>$n$</span> be the number of generators and ambient dimension, respectively. We consider the minimization of <span>$x_0$</span> in the <span>$p+1$</span>-dimensional space of elements <span>$(x_0, ξ_1, …, ξ_p)$</span> constrained to <span>$0 ≤ x_0 ≤ ∞$</span>, <span>$ξ_i ∈ [-1, 1]$</span> for all <span>$i = 1, …, p$</span>, and such that <span>$x-c = Gξ$</span> holds. If a feasible solution exists, the optimal value <span>$x_0 = 0$</span> is achieved.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractZonotope.jl#L266-L304">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractZonotope{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractZonotope{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, Z::AbstractZonotope{N}) where {N&lt;:Real}</code></pre><p>Concrete linear map of a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>The zonotope obtained by applying the linear map to the center and generators of <span>$Z$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractZonotope.jl#L322-L336">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{AbstractZonotope{N},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{N}, Tuple{AbstractZonotope{N},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(Z::AbstractZonotope{N}, v::AbstractVector{N}; share::Bool=false
         ) where {N&lt;:Real}</code></pre><p>Translate (i.e., shift) a zonotope by a given vector.</p><p><strong>Input</strong></p><ul><li><code>Z</code>     – zonotope</li><li><code>v</code>     – translation vector</li><li><code>share</code> – (optional, default: <code>false</code>) flag for sharing unmodified parts of            the original set representation</li></ul><p><strong>Output</strong></p><p>A translated zonotope.</p><p><strong>Notes</strong></p><p>The generator matrix is shared with the original zonotope if <code>share == true</code>.</p><p><strong>Algorithm</strong></p><p>We add the vector to the center of the zonotope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractZonotope.jl#L347-L371">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(P::AbstractZonotope{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints defining a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>The list of constraints of the zonotopic set.</p><p><strong>Algorithm</strong></p><p>This is the (inefficient) fallback implementation for rational numbers. It first computes the vertices and then converts the corresponding polytope to constraint representation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractZonotope.jl#L429-L447">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N&lt;:AbstractFloat" href="#LazySets.constraints_list-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N&lt;:AbstractFloat"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(Z::AbstractZonotope{N}; check_full_rank::Bool=true
                ) where {N&lt;:AbstractFloat}</code></pre><p>Return the list of constraints defining a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code>               – zonotopic set</li><li><code>check_full_rank</code> – (optional; default: <code>true</code>) flag for checking whether the                      generator matrix has full rank</li></ul><p><strong>Output</strong></p><p>The list of constraints of the zonotopic set.</p><p><strong>Notes</strong></p><p>The algorithm assumes that no generator is redundant. The result has <span>$2 \binom{p}{n-1}$</span> (with <span>$p$</span> being the number of generators and <span>$n$</span> being the ambient dimension) constraints, which is optimal under this assumption.</p><p>If <span>$p &lt; n$</span> or the generator matrix is not full rank, we fall back to the (slower) computation based on the vertex representation.</p><p><strong>Algorithm</strong></p><p>We follow the algorithm presented in <em>Althoff, Stursberg, Buss: Computing Reachable Sets of Hybrid Systems Using a Combination of Zonotopes and Polytopes. 2009.</em></p><p>The one-dimensional case is not covered by that algorithm; we manually handle this case, assuming that there is only one generator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractZonotope.jl#L452-L486">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(Z::AbstractZonotope{N}; [apply_convex_hull]::Bool=true
             ) where {N&lt;:Real}</code></pre><p>Return the vertices of a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code>                 – zonotopic set</li><li><code>apply_convex_hull</code> – (optional, default: <code>true</code>) if <code>true</code>, post-process the                        computation with the convex hull of the points</li></ul><p><strong>Output</strong></p><p>List of vertices as a vector of vectors.</p><p><strong>Algorithm</strong></p><p>If the zonotopic set has <span>$p$</span> generators, each vertex is the result of summing the center with some linear combination of generators, where the combination factors are <span>$ξ_i ∈ \{-1, 1\}$</span>.</p><p>There are at most <span>$2^p$</span> distinct vertices. Use the flag <code>apply_convex_hull</code> to control whether a convex hull algorithm is applied to the vertices computed by this method; otherwise, redundant vertices may be present.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractZonotope.jl#L385-L410">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.order-Tuple{AbstractZonotope}" href="#LazySets.order-Tuple{AbstractZonotope}"><code>LazySets.order</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">order(Z::AbstractZonotope)</code></pre><p>Return the order of a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotope</li></ul><p><strong>Output</strong></p><p>A rational number representing the order of the zonotope.</p><p><strong>Notes</strong></p><p>The order of a zonotope is defined as the quotient of its number of generators and its dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractZonotope.jl#L195-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.togrep-Tuple{AbstractZonotope}" href="#LazySets.togrep-Tuple{AbstractZonotope}"><code>LazySets.togrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">togrep(Z::AbstractZonotope)</code></pre><p>Return a generator representation of a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotopic set</li></ul><p><strong>Output</strong></p><p>The same set in generator representation. This fallback implementation returns a <code>Zonotope</code>; however, more specific implementations may return other generator representations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractZonotope.jl#L155-L169">source</a></section><h3><a class="nav-anchor" id="Implementations-8" href="#Implementations-8">Implementations</a></h3><ul><li><a href="../sets/Zonotope/#def_Zonotope-1">Zonotope</a></li><li><a href="../sets/LineSegment/#def_LineSegment-1">Line segment (LineSegment)</a></li></ul><h2><a class="nav-anchor" id="def_AbstractHyperrectangle-1" href="#def_AbstractHyperrectangle-1">Hyperrectangles (AbstractHyperrectangle)</a></h2><p>A hyperrectangle is a special centrally symmetric polytope with axis-aligned facets.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractHyperrectangle" href="#LazySets.AbstractHyperrectangle"><code>LazySets.AbstractHyperrectangle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractHyperrectangle{N&lt;:Real} &lt;: AbstractZonotope{N}</code></pre><p>Abstract type for hyperrectangular sets.</p><p><strong>Notes</strong></p><p>See <a href="../sets/Hyperrectangle/#LazySets.Hyperrectangle"><code>Hyperrectangle</code></a> for a standard implementation of this interface.</p><p>Every concrete <code>AbstractHyperrectangle</code> must define the following functions:</p><ul><li><code>radius_hyperrectangle(::AbstractHyperrectangle{N})</code> – return the   hyperrectangle&#39;s radius, which is a full-dimensional vector</li><li><code>radius_hyperrectangle(::AbstractHyperrectangle{N}, i::Int)</code> – return the   hyperrectangle&#39;s radius in the <code>i</code>-th dimension</li><li><code>isflat(::AbstractHyperrectangle{N})</code> – determine whether the   hyperrectangle&#39;s radius is zero in some dimension</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractHyperrectangle)
5-element Array{Any,1}:
 AbstractSingleton
 BallInf
 Hyperrectangle
 Interval
 SymmetricIntervalHull</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHyperrectangle.jl#L12-L38">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">norm(H::AbstractHyperrectangle, [p]::Real=Inf)</code></pre><p>Return the norm of a hyperrectangular set.</p><p>The norm of a hyperrectangular set is defined as the norm of the enclosing ball, of the given <span>$p$</span>-norm, of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p><p><strong>Algorithm</strong></p><p>Recall that the norm is defined as</p><div>\[‖ X ‖ = \max_{x ∈ X} ‖ x ‖_p = max_{x ∈ \text{vertices}(X)} ‖ x ‖_p.\]</div><p>The last equality holds because the optimum of a convex function over a polytope is attained at one of its vertices.</p><p>This implementation uses the fact that the maximum is achieved in the vertex <span>$c + \text{diag}(\text{sign}(c)) r$</span>, for any <span>$p$</span>-norm, hence it suffices to take the <span>$p$</span>-norm of this particular vertex. This statement is proved below. Note that, in particular, there is no need to compute the <span>$p$</span>-norm for <em>each</em> vertex, which can be very expensive.</p><p>If <span>$X$</span> is an axis-aligned hyperrectangle and the <span>$n$</span>-dimensional vectors center and radius of the hyperrectangle are denoted <span>$c$</span> and <span>$r$</span> respectively, then reasoning on the <span>$2^n$</span> vertices we have that:</p><div>\[\max_{x ∈ \text{vertices}(X)} ‖ x ‖_p = \max_{α_1, …, α_n ∈ \{-1, 1\}} (|c_1 + α_1 r_1|^p + ... + |c_n + α_n r_n|^p)^{1/p}.\]</div><p>The function <span>$x ↦ x^p$</span>, <span>$p &gt; 0$</span>, is monotonically increasing and thus the maximum of each term <span>$|c_i + α_i r_i|^p$</span> is given by <span>$|c_i + \text{sign}(c_i) r_i|^p$</span> for each <span>$i$</span>. Hence, <span>$x^* := \text{argmax}_{x ∈ X} ‖ x ‖_p$</span> is the vertex <span>$c + \text{diag}(\text{sign}(c)) r$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHyperrectangle.jl#L328-L373">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius" href="#LazySets.radius"><code>LazySets.radius</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">radius(H::AbstractHyperrectangle, [p]::Real=Inf)</code></pre><p>Return the radius of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p><p><strong>Notes</strong></p><p>The radius is defined as the radius of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center. It is the same for all corners of a hyperrectangular set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHyperrectangle.jl#L379-L398">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a hyperrectangular set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the vertex with biggest values is returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHyperrectangle.jl#L254-L268">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Evaluate the support function of a hyperrectangular set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>Evaluation of the support function in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHyperrectangle.jl#L290-L303">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ H$</span>.</p><p><strong>Algorithm</strong></p><p>Let <span>$H$</span> be an <span>$n$</span>-dimensional hyperrectangular set, <span>$c_i$</span> and <span>$r_i$</span> be the box&#39;s center and radius and <span>$x_i$</span> be the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ H$</span> iff <span>$|c_i - x_i| ≤ r_i$</span> for all <span>$i=1,…,n$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHyperrectangle.jl#L403-L423">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Return the list of vertices of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A list of vertices. Zeros in the radius are correctly handled, i.e., the result does not contain any duplicate vertices.</p><p><strong>Notes</strong></p><p>For high dimensions, it is preferable to develop a <code>vertex_iterator</code> approach.</p><p><strong>Algorithm</strong></p><p>First we identify the dimensions where <code>H</code> is flat, i.e., its radius is zero. We also compute the number of vertices that we have to create.</p><p>Next we create the vertices. We do this by enumerating all vectors <code>v</code> of length <code>n</code> (the dimension of <code>H</code>) with entries <code>-1</code>/<code>0</code>/<code>1</code> and construct the corresponding vertex as follows:</p><div>\[    \text{vertex}(v)(i) = \begin{cases} c(i) + r(i) &amp; v(i) = 1 \\
                                          c(i) &amp; v(i) = 0 \\
                                          c(i) - r(i) &amp; v(i) = -1. \end{cases}\]</div><p>For enumerating the vectors <code>v</code>, we modify the current <code>v</code> from left to right by changing entries <code>-1</code> to <code>1</code>, skipping entries <code>0</code>, and stopping at the first entry <code>1</code> (but changing it to <code>-1</code>). This way we only need to change the vertex in those dimensions where <code>v</code> has changed, which usually is a smaller number than <code>n</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHyperrectangle.jl#L143-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of an axis-aligned hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A list of linear constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHyperrectangle.jl#L225-L237">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.high-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">high(H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Return the higher coordinates of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A vector with the higher coordinates of the hyperrectangular set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHyperrectangle.jl#L439-L451">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},Int64}} where N&lt;:Real" href="#LazySets.high-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},Int64}} where N&lt;:Real"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">high(H::AbstractHyperrectangle{N}, i::Int) where {N&lt;:Real}</code></pre><p>Return the higher coordinate of a hyperrectangular set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The higher coordinate of the hyperrectangular set in the given dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHyperrectangle.jl#L456-L469">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.low-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">low(H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Return the lower coordinates of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A vector with the lower coordinates of the hyperrectangular set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHyperrectangle.jl#L474-L486">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},Int64}} where N&lt;:Real" href="#LazySets.low-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},Int64}} where N&lt;:Real"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">low(H::AbstractHyperrectangle{N}, i::Int) where {N&lt;:Real}</code></pre><p>Return the lower coordinate of a hyperrectangular set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The lower coordinate of the hyperrectangular set in the given dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHyperrectangle.jl#L491-L504">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isflat-Tuple{AbstractHyperrectangle}" href="#LazySets.isflat-Tuple{AbstractHyperrectangle}"><code>LazySets.isflat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isflat(H::AbstractHyperrectangle)</code></pre><p>Determine whether a hyperrectangular set is flat, i.e. whether its radius is zero in some dimension.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the hyperrectangular set is flat.</p><p><strong>Notes</strong></p><p>For robustness with respect to floating-point inputs, this function relies on the result of <code>isapproxzero</code> when applied to the radius in some dimension. Hence, this function depends on the absolute zero tolerance <code>ABSZTOL</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHyperrectangle.jl#L509-L528">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.split-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractArray{Int64,1}}} where N&lt;:Real" href="#Base.split-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractArray{Int64,1}}} where N&lt;:Real"><code>Base.split</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">split(H::AbstractHyperrectangle{N}, num_blocks::AbstractVector{Int}
     ) where {N&lt;:Real}</code></pre><p>Partition a hyperrectangular set into uniform sub-hyperrectangles.</p><p><strong>Input</strong></p><ul><li><code>H</code>          – hyperrectangular set</li><li><code>num_blocks</code> – number of blocks in the partition for each dimension</li></ul><p><strong>Output</strong></p><p>A list of <code>Hyperrectangle</code>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHyperrectangle.jl#L533-L547">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.generators-Tuple{AbstractHyperrectangle}" href="#LazySets.generators-Tuple{AbstractHyperrectangle}"><code>LazySets.generators</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">generators(H::AbstractHyperrectangle)</code></pre><p>Return an iterator over the generators of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>An iterator over the generators of <code>H</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHyperrectangle.jl#L101-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.genmat-Tuple{AbstractHyperrectangle}" href="#LazySets.genmat-Tuple{AbstractHyperrectangle}"><code>LazySets.genmat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>genmat(H::AbstractHyperrectangle)</p><p>Return the generator matrix of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A matrix where each column represents one generator of <code>H</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHyperrectangle.jl#L46-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ngens-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.ngens-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.ngens</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ngens(H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Return the number of generators of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The number of generators.</p><p><strong>Algorithm</strong></p><p>A hyperrectangular set has one generator for each non-flat dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHyperrectangle.jl#L118-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Arrays.rectify-Tuple{AbstractHyperrectangle}" href="#LazySets.Arrays.rectify-Tuple{AbstractHyperrectangle}"><code>LazySets.Arrays.rectify</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rectify(H::AbstractHyperrectangle)</code></pre><p>Concrete rectification of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The <code>Hyperrectangle</code> that corresponds to the rectification of <code>H</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractHyperrectangle.jl#L581-L593">source</a></section><h3><a class="nav-anchor" id="Implementations-9" href="#Implementations-9">Implementations</a></h3><p>Concrete set representations:</p><ul><li><a href="../sets/Hyperrectangle/#def_Hyperrectangle-1">Hyperrectangle</a></li><li><a href="../sets/BallInf/#def_BallInf-1">Infinity-norm ball (BallInf)</a></li><li><a href="../sets/Interval/#def_Interval-1">Interval</a></li></ul><p>Lazy set operations:</p><ul><li><a href="../lazy_operations/SymmetricIntervalHull/#def_SymmetricIntervalHull-1">Symmetric interval hull (SymmetricIntervalHull)</a></li></ul><h2><a class="nav-anchor" id="def_AbstractSingleton-1" href="#def_AbstractSingleton-1">Singletons (AbstractSingleton)</a></h2><p>A singleton is a special hyperrectangle consisting of only one point.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractSingleton" href="#LazySets.AbstractSingleton"><code>LazySets.AbstractSingleton</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractSingleton{N&lt;:Real} &lt;: AbstractHyperrectangle{N}</code></pre><p>Abstract type for sets with a single value.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractSingleton</code> must define the following functions:</p><ul><li><code>element(::AbstractSingleton{N})</code> – return the single element</li><li><code>element(::AbstractSingleton{N}, i::Int)</code> – return the single element&#39;s   entry in the <code>i</code>-th dimension</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractSingleton)
2-element Array{Any,1}:
 Singleton
 ZeroSet</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractSingleton.jl#L8-L26">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The support vector, which is the set&#39;s vector itself, irrespective of the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractSingleton.jl#L284-L298">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Evaluate the support function of a set with a single value in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>Evaluation of the support function in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractSingleton.jl#L303-L316">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ S$</span>.</p><p><strong>Notes</strong></p><p>This implementation performs an exact comparison, which may be insufficient with floating point computations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractSingleton.jl#L321-L339">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>An element of a convex set.</p><p><strong>Algorithm</strong></p><p>An element of the set is obtained by evaluating its support vector along direction <span>$[1, 0, …, 0]$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/LazySet.jl#L395-L412">source</a><div><div><pre><code class="language-julia">an_element(P::AbstractPolyhedron{N}) where {N&lt;:Real}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polyhedron</li></ul><p><strong>Output</strong></p><p>An element of a polyhedron.</p><p><strong>Algorithm</strong></p><p>An element of the polyhedron is obtained by evaluating its support vector along direction <span>$[1, 0, …, 0]$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractPolyhedron_functions.jl#L855-L872">source</a><div><div><pre><code class="language-julia">an_element(P::AbstractCentrallySymmetricPolytope{N}) where {N&lt;:Real}</code></pre><p>Return some element of a centrally symmetric polytope.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric polytope</li></ul><p><strong>Output</strong></p><p>The center of the centrally symmetric polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractCentrallySymmetricPolytope.jl#L60-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.center-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">center(S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Return the center of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The only element of the set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractSingleton.jl#L219-L231">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Return the list of vertices of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A list containing only a single vertex.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractSingleton.jl#L240-L252">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">radius_hyperrectangle(S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Return the box radius of a set with a single value in every dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The zero vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractSingleton.jl#L54-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">radius_hyperrectangle(S::AbstractSingleton{N}, i::Int) where {N&lt;:Real}</code></pre><p>Return the box radius of a set with a single value in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>Zero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractSingleton.jl#L34-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.high-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">high(S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Return the higher coordinates of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A vector with the higher coordinates of the set with a single value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractSingleton.jl#L72-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real" href="#LazySets.high-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">high(S::AbstractSingleton{N}, i::Int) where {N&lt;:Real}</code></pre><p>Return the higher coordinate of a set with a single value in the given dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The higher coordinate of the set with a single value in the given dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractSingleton.jl#L89-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.low-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">low(S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Return the lower coordinates of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A vector with the lower coordinates of the set with a single value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractSingleton.jl#L108-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real" href="#LazySets.low-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">low(S::AbstractSingleton{N}, i::Int) where {N&lt;:Real}</code></pre><p>Return the lower coordinate of a set with a single value in the given dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The lower coordinate of the set with a single value in the given dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractSingleton.jl#L125-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractSingleton{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractSingleton{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Concrete linear map of an abstract singleton.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>S</code> – abstract singleton</li></ul><p><strong>Output</strong></p><p>The abstract singleton of the same type of <span>$S$</span> obtained by applying the linear map to the element in <span>$S$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractSingleton.jl#L257-L271">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.generators-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.generators-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.generators</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">generators(S::AbstractSingleton)</code></pre><p>Return an (empty) iterator over the generators of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>An empty iterator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractSingleton.jl#L177-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.genmat-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.genmat-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.genmat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>genmat(S::AbstractSingleton)</p><p>Return the (empty) generator matrix of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A matrix with no columns representing the generators of <code>S</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractSingleton.jl#L148-L160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ngens-Tuple{AbstractSingleton}" href="#LazySets.ngens-Tuple{AbstractSingleton}"><code>LazySets.ngens</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ngens(S::AbstractSingleton)</code></pre><p>Return the number of generators of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>H</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The number of generators.</p><p><strong>Algorithm</strong></p><p>A set with a single value has no generators, so the result is <span>$0$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractSingleton.jl#L194-L210">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.plot_recipe-Union{Tuple{AbstractSingleton{N}}, Tuple{N}, Tuple{AbstractSingleton{N},N}} where N&lt;:Real" href="#LazySets.plot_recipe-Union{Tuple{AbstractSingleton{N}}, Tuple{N}, Tuple{AbstractSingleton{N},N}} where N&lt;:Real"><code>LazySets.plot_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_recipe(S::AbstractSingleton{N}, [ε]::N=zero(N)) where {N&lt;:Real}</code></pre><p>Convert a singleton to a pair <code>(x, y)</code> of points for plotting.</p><p><strong>Input</strong></p><ul><li><code>S</code> – singleton</li><li><code>ε</code> – (optional, default: <code>0</code>) ignored, used for dispatch</li></ul><p><strong>Output</strong></p><p>A pair <code>(x, y)</code> of one point that can be plotted.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractSingleton.jl#L352-L365">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol,Any},AbstractSingleton{N}}, Tuple{AbstractDict{Symbol,Any},AbstractSingleton{N},N}} where N&lt;:Real" href="#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol,Any},AbstractSingleton{N}}, Tuple{AbstractDict{Symbol,Any},AbstractSingleton{N},N}} where N&lt;:Real"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_singleton(S::AbstractSingleton{N}, [ε]::N=zero(N); ...) where {N&lt;:Real}</code></pre><p>Plot a singleton.</p><p><strong>Input</strong></p><ul><li><code>S</code> – singleton</li><li><code>ε</code> – (optional, default: <code>0</code>) ignored, used for dispatch</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; plot(Singleton([0.5, 1.0]))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Plotting/plot_recipes.jl#L272-L287">source</a></section><h3><a class="nav-anchor" id="Implementations-10" href="#Implementations-10">Implementations</a></h3><ul><li><a href="../sets/Singleton/#def_Singleton-1">Singleton</a></li><li><a href="../sets/ZeroSet/#def_ZeroSet-1">Origin (ZeroSet)</a></li></ul><h2><a class="nav-anchor" id="def_AbstractAffineMap-1" href="#def_AbstractAffineMap-1">Affine maps (AbstractAffineMap)</a></h2><p>An affine map consists of a linear map and a translation.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractAffineMap" href="#LazySets.AbstractAffineMap"><code>LazySets.AbstractAffineMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractAffineMap{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Abstract type for affine maps.</p><p><strong>Notes</strong></p><p>See <a href="../lazy_operations/AffineMap/#LazySets.AffineMap"><code>AffineMap</code></a> for a standard implementation of this interface.</p><p>Every concrete <code>AbstractAffineMap</code> must define the following functions:</p><ul><li><code>matrix(::AbstractAffineMap)</code> – return the linear map</li><li><code>vector(::AbstractAffineMap)</code> – return the affine translation vector</li><li><code>set(::AbstractAffineMap)</code> – return the set that the map is applied to</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractAffineMap)
6-element Array{Any,1}:
 AffineMap
 ExponentialMap
 ExponentialProjectionMap
 LinearMap
 ResetMap
 Translation</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractAffineMap.jl#L6-L30">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractAffineMap}" href="#LazySets.dim-Tuple{AbstractAffineMap}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(am::AbstractAffineMap)</code></pre><p>Return the dimension of an affine map.</p><p><strong>Input</strong></p><ul><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>The dimension of an affine map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractAffineMap.jl#L40-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractAffineMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractAffineMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, am::AbstractAffineMap{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of an affine map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractAffineMap.jl#L57-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractAffineMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractAffineMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, am::AbstractAffineMap{N}) where {N&lt;:Real}</code></pre><p>Return the support function of an affine map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractAffineMap.jl#L76-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{AbstractAffineMap}" href="#LazySets.an_element-Tuple{AbstractAffineMap}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(am::AbstractAffineMap)</code></pre><p>Return some element of an affine map.</p><p><strong>Input</strong></p><ul><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>An element of the affine map. It relies on the <code>an_element</code> function of the wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractAffineMap.jl#L94-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{AbstractAffineMap}" href="#Base.isempty-Tuple{AbstractAffineMap}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(am::AbstractAffineMap)</code></pre><p>Return whether an affine map is empty or not.</p><p><strong>Input</strong></p><ul><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractAffineMap.jl#L112-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{AbstractAffineMap}" href="#LazySets.isbounded-Tuple{AbstractAffineMap}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(am::AbstractAffineMap; cond_tol::Number=DEFAULT_COND_TOL)</code></pre><p>Determine whether an affine map is bounded.</p><p><strong>Input</strong></p><ul><li><code>am</code>       – affine map</li><li><code>cond_tol</code> – (optional) tolerance of matrix condition (used to check whether               the matrix is invertible)</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the affine map is bounded.</p><p><strong>Algorithm</strong></p><p>We first check if the matrix is zero or the wrapped set is bounded. If not, we perform a sufficient check whether the matrix is invertible. If the matrix is invertible, then the map being bounded is equivalent to the wrapped set being bounded, and hence the map is unbounded. Otherwise, we check boundedness via <a href="#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>isbounded_unit_dimensions</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractAffineMap.jl#L129-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractAffineMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractAffineMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, am::AbstractAffineMap{N}) where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in the affine map of a convex set.</p><p><strong>Input</strong></p><ul><li><code>x</code>  – point/vector</li><li><code>am</code> – affine map of a convex set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ am$</span>.</p><p><strong>Algorithm</strong></p><p>Note that <span>$x ∈ M⋅S ⊕ v$</span> iff <span>$M^{-1}⋅(x - v) ∈ S$</span>. This implementation does not explicitly invert the matrix, which is why it also works for non-square matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; am = AffineMap([2.0 0.0; 0.0 1.0], BallInf([1., 1.], 1.), [-1.0, -1.0]);

julia&gt; [5.0, 1.0] ∈ am
false

julia&gt; [3.0, 1.0] ∈ am
true</code></pre><p>An example with a non-square matrix:</p><pre><code class="language-julia-repl">julia&gt; B = BallInf(zeros(4), 1.);

julia&gt; M = [1. 0 0 0; 0 1 0 0]/2;

julia&gt; [0.5, 0.5] ∈ M*B
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractAffineMap.jl#L163-L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{AbstractAffineMap{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{AbstractAffineMap{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(am::AbstractAffineMap{N};
              [apply_convex_hull]::Bool) where {N&lt;:Real}</code></pre><p>Return the list of vertices of a (polyhedral) affine map.</p><p><strong>Input</strong></p><ul><li><code>am</code>                – affine map</li><li><code>apply_convex_hull</code> – (optional, default: <code>true</code>) if <code>true</code>, apply the convex                        hull operation to the list of vertices transformed by                        the affine map</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>This implementation computes all vertices of <code>X</code>, then transforms them through the affine map, i.e. <code>x ↦ M*x + v</code> for each vertex <code>x</code> of <code>X</code>. By default, the convex hull operation is taken before returning this list. For dimensions three or higher, this operation relies on the functionality through the concrete polyhedra library <code>Polyhedra.jl</code>.</p><p>If you are not interested in taking the convex hull of the resulting vertices under the affine map, pass <code>apply_convex_hull=false</code> as a keyword argument.</p><p>Note that we assume that the underlying set <code>X</code> is polyhedral, either concretely or lazily, i.e. there the function <code>vertices_list</code> should be applicable.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractAffineMap.jl#L210-L240">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{AbstractAffineMap{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{AbstractAffineMap{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(am::AbstractAffineMap{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of a (polyhedral) affine map.</p><p><strong>Input</strong></p><ul><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>The list of constraints of the affine map.</p><p><strong>Notes</strong></p><p>We assume that the underlying set <code>X</code> is polyhedral, i.e., offers a method <code>constraints_list(X)</code>.</p><p><strong>Algorithm</strong></p><p>Falls back to the list of constraints of the translation of a lazy linear map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractAffineMap.jl#L262-L283">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractAffineMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractAffineMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, am::AbstractAffineMap{N}) where {N&lt;:Real}</code></pre><p>Return the linear map of a lazy affine map.</p><p><strong>Input</strong></p><ul><li><code>M</code>  – matrix</li><li><code>am</code> – affine map</li></ul><p><strong>Output</strong></p><p>A set corresponding to the linear map of the lazy affine map of a set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/7de3e7ff2a8cd6f51860687a790abbec6cf0d6a8/src/Interfaces/AbstractAffineMap.jl#L289-L302">source</a></section><h3><a class="nav-anchor" id="Implementations-11" href="#Implementations-11">Implementations</a></h3><ul><li><a href="../lazy_operations/AffineMap/#def_AffineMap-1">Affine map (AffineMap)</a></li><li><a href="../lazy_operations/ExponentialMap/#def_ExponentialMap-1">Exponential map (ExponentialMap)</a></li><li><a href="../lazy_operations/LinearMap/#def_LinearMap-1">Linear map (LinearMap)</a></li><li><a href="../lazy_operations/ResetMap/#def_ResetMap-1">Reset map (ResetMap)</a></li><li><a href="../lazy_operations/Translation/#def_Translation-1">Translation</a></li></ul><footer><hr/><a class="previous" href="../../man/lazy_intersections/"><span class="direction">Previous</span><span class="title">Lazy Intersections</span></a><a class="next" href="../sets/Ball1/"><span class="direction">Next</span><span class="title">Ball1</span></a></footer></article></body></html>
