<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Set Interfaces · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/getting_started/">Getting Started</a></li><li><a class="toctext" href="../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="toctext" href="../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="toctext" href="../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="toctext" href="../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="toctext" href="../../man/interval_hulls/">Interval Hulls</a></li><li><a class="toctext" href="../../man/convex_hulls/">Convex Hulls</a></li><li><a class="toctext" href="../../man/set_operations/">Operations on Sets</a></li><li><a class="toctext" href="../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="toctext" href="../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="toctext" href="../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="toctext" href="../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href>Set Interfaces</a><ul class="internal"><li><a class="toctext" href="#LazySet-1">LazySet</a></li><li><a class="toctext" href="#Centrally-symmetric-set-1">Centrally symmetric set</a></li><li><a class="toctext" href="#Polyhedron-1">Polyhedron</a></li></ul></li><li><a class="toctext" href="../representations/">Common Set Representations</a></li><li><a class="toctext" href="../operations/">Common Set Operations</a></li><li><a class="toctext" href="../comparisons/">Comparisons</a></li><li><a class="toctext" href="../conversion/">Conversions between set representations</a></li><li><a class="toctext" href="../binary_functions/">Binary Functions on Sets</a></li><li><a class="toctext" href="../approximations/">Approximations</a></li><li><a class="toctext" href="../utils/">Utility Functions</a></li><li><a class="toctext" href="../parallel/">Parallel</a></li></ul></li><li><a class="toctext" href="../../about/">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Set Interfaces</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/interfaces.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Set Interfaces</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Set-Interfaces-1" href="#Set-Interfaces-1">Set Interfaces</a></h1><p>This section of the manual describes the interfaces for different set types. Every set that fits the description of an interface should also implement it. This helps in several ways:</p><ul><li>avoid code duplicates,</li><li>provide functions for many sets at once,</li><li>allow changes in the source code without changing the API.</li></ul><p>The interface functions are outlined in the interface documentation. See <a href="../representations/#Common-Set-Representations-1">Common Set Representations</a> for implementations of the interfaces.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The naming convention is such that all interface names (with the exception of the main abstract type <code>LazySet</code>) should be preceded by <code>Abstract</code>.</p></div></div><p>The following diagram shows the interface hierarchy.</p><p><img src="../../assets/interfaces.png" alt="../assets/interfaces.png"/></p><ul><li><a href="#Set-Interfaces-1">Set Interfaces</a></li><ul><li><a href="#LazySet-1">LazySet</a></li><ul><li><a href="#Support-function-and-support-vector-1">Support function and support vector</a></li><li><a href="#Other-globally-defined-set-functions-1">Other globally defined set functions</a></li><li><a href="#Set-functions-that-override-Base-functions-1">Set functions that override Base functions</a></li><li><a href="#Aliases-for-set-types-1">Aliases for set types</a></li></ul><li><a href="#Centrally-symmetric-set-1">Centrally symmetric set</a></li><li><a href="#Polyhedron-1">Polyhedron</a></li><ul><li><a href="#Polytope-1">Polytope</a></li><ul><li><a href="#Polygon-1">Polygon</a></li><li><a href="#Centrally-symmetric-polytope-1">Centrally symmetric polytope</a></li></ul></ul></ul></ul><h2><a class="nav-anchor" id="LazySet-1" href="#LazySet-1">LazySet</a></h2><p>Every convex set in this library implements this interface.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.LazySet" href="#LazySets.LazySet"><code>LazySets.LazySet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">LazySet{N}</code></pre><p>Abstract type for convex sets, i.e., sets characterized by a (possibly infinite) intersection of halfspaces, or equivalently, sets <span>$S$</span> such that for any two elements <span>$x, y ∈ S$</span> and <span>$0 ≤ λ ≤ 1$</span> it holds that <span>$λ·x + (1-λ)·y ∈ S$</span>.</p><p><strong>Notes</strong></p><p><code>LazySet</code> types should be parameterized with a type <code>N</code>, typically <code>N&lt;:Real</code>, for using different numeric types.</p><p>Every concrete <code>LazySet</code> must define the following functions:</p><ul><li><code>σ(d::AbstractVector{N}, S::LazySet{N}) where {N&lt;:Real}</code> – the support vector   of <code>S</code> in a given direction <code>d</code>; note that the numeric type <code>N</code> of <code>d</code> and   <code>S</code> must be identical; for some set types <code>N</code> may be more restrictive than   <code>Real</code></li><li><code>dim(S::LazySet)::Int</code> – the ambient dimension of <code>S</code></li></ul><p>The subtypes of <code>LazySet</code> (including abstract interfaces):</p><pre><code class="language-julia-repl">julia&gt; using LazySets: subtypes

julia&gt; subtypes(LazySet, false)
17-element Array{Any,1}:
 AbstractCentrallySymmetric
 AbstractPolyhedron
 CacheMinkowskiSum
 CartesianProduct
 CartesianProductArray
 ConvexHull
 ConvexHullArray
 EmptySet
 ExponentialMap
 ExponentialProjectionMap
 Intersection
 IntersectionArray
 LinearMap
 MinkowskiSum
 MinkowskiSumArray
 ResetMap
 Translation</code></pre><p>If we only consider <em>concrete</em> subtypes, then:</p><p><code>jldoctest julia&gt; LazySets.subtypes(LazySet, true) 37-element Array{Type,1}:  Ball1  Ball2  BallInf  Ballp  CacheMinkowskiSum  CartesianProduct  CartesianProductArray  ConvexHull  ConvexHullArray  Ellipsoid  EmptySet  ExponentialMap  ExponentialProjectionMap  HPolygon  HPolygonOpt  HPolyhedron  HPolytope  HalfSpace  Hyperplane  Hyperrectangle  Intersection  IntersectionArray  Interval  Line  LineSegment  LinearMap  MinkowskiSum  MinkowskiSumArray  ResetMap  Singleton  SymmetricIntervalHull  Translation  Universe  VPolygon  VPolytope  ZeroSet  Zonotope</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LazySet.jl#L22-L110">source</a></section><h3><a class="nav-anchor" id="Support-function-and-support-vector-1" href="#Support-function-and-support-vector-1">Support function and support vector</a></h3><p>Every <code>LazySet</code> type must define a function <code>σ</code> to compute the support vector.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.support_vector" href="#LazySets.support_vector"><code>LazySets.support_vector</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">support_vector</code></pre><p>Alias for the support vector σ.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LazySet.jl#L153-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, S::LazySet{N})::N where {N&lt;:Real}</code></pre><p>Evaluate the support function of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>The support function of the set <code>S</code> for the direction <code>d</code>.</p><p><strong>Notes</strong></p><p>The numeric type of the direction and the set must be identical.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LazySet.jl#L117-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.support_function" href="#LazySets.support_function"><code>LazySets.support_function</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">support_function</code></pre><p>Alias for the support function ρ.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LazySet.jl#L139-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ" href="#LazySets.σ"><code>LazySets.σ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">σ</code></pre><p>Function to compute the support vector σ.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LazySet.jl#L146-L150">source</a></section><h3><a class="nav-anchor" id="Other-globally-defined-set-functions-1" href="#Other-globally-defined-set-functions-1">Other globally defined set functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">norm(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the norm of a convex set. It is the norm of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LazySet.jl#L212-L227">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius" href="#LazySets.radius"><code>LazySets.radius</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">radius(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the radius of a convex set. It is the radius of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LazySet.jl#L236-L251">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.diameter" href="#LazySets.diameter"><code>LazySets.diameter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">diameter(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the diameter of a convex set. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LazySet.jl#L260-L276">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{LazySet}" href="#LazySets.isbounded-Tuple{LazySet}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(S::LazySet)::Bool</code></pre><p>Determine whether a set is bounded.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set is bounded.</p><p><strong>Algorithm</strong></p><p>We check boundedness via <a href="#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>isbounded_unit_dimensions</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LazySet.jl#L160-L176">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.isbounded_unit_dimensions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded_unit_dimensions(S::LazySet{N})::Bool where {N&lt;:Real}</code></pre><p>Determine whether a set is bounded in each unit dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set is bounded in each unit dimension.</p><p><strong>Algorithm</strong></p><p>This function performs <span>$2n$</span> support function checks, where <span>$n$</span> is the ambient dimension of <code>S</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LazySet.jl#L181-L198">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>An element of a convex set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LazySet.jl#L282-L294">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tosimplehrep-Tuple{LazySet}" href="#LazySets.tosimplehrep-Tuple{LazySet}"><code>LazySets.tosimplehrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tosimplehrep(S::LazySet)</code></pre><p>Return the simple H-representation <span>$Ax ≤ b$</span> of a set from its list of linear constraints.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p>The tuple <code>(A, b)</code> where <code>A</code> is the matrix of normal directions and <code>b</code> is the vector of offsets.</p><p><strong>Notes</strong></p><p>This function only works for sets that can be represented exactly by a finite list of linear constraints. This fallback implementation relies on <code>constraints_list(S)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LazySet.jl#L376-L396">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isuniversal-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},Bool}} where N&lt;:Real" href="#LazySets.isuniversal-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},Bool}} where N&lt;:Real"><code>LazySets.isuniversal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isuniversal(X::LazySet{N}, [witness]::Bool=false
           )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</code></pre><p>Check whether a given convex set is universal, and otherwise optionally compute a witness.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – convex set</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$X$</span> is universal</li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$X$</span> is universal</li><li><code>(false, v)</code> iff <span>$X$</span> is not universal and <span>$v ∉ X$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>This is a naive fallback implementation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LazySet.jl#L399-L421">source</a></section><p>The following functions work with general two-dimensional <code>LazySet</code>s, provided that the overapproximation using iterative refinement is available:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{Dict{Symbol,Any},LazySet{N}}, Tuple{Dict{Symbol,Any},LazySet{N},N}} where N&lt;:Real" href="#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{Dict{Symbol,Any},LazySet{N}}, Tuple{Dict{Symbol,Any},LazySet{N},N}} where N&lt;:Real"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_lazyset(X::LazySet{N}, [ε]::N=N(1e-3); ...) where {N&lt;:Real}</code></pre><p>Plot a convex set in two dimensions.</p><p><strong>Input</strong></p><ul><li><code>X</code> – convex set</li><li><code>ε</code> – (optional, default: <code>1e-3</code>) approximation error bound</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; B = BallInf(ones(2), 0.1);

julia&gt; plot(2.0 * B)</code></pre><p>An iterative refinement method is applied to obtain an overapproximation of <code>X</code> in constraint representation, which is then plotted. To improve the accuracy of the iterative refinement, use the second argument using a small value:</p><pre><code class="language-julia">julia&gt; B = Ball2(ones(2), 0.1);

julia&gt; plot(B, 1e-3);

julia&gt; plot(B, 1e-2); # faster than the previous try, but less accurate</code></pre><p><strong>Algorithm</strong></p><p>In a first stage, an overapproximation of the given set to a polygon in constraint representation is computed. The second argument, <code>ε</code>, corresponds to the error in Hausdorff distance between the overapproximating set and <code>X</code>. The default value <code>1e-3</code> is chosen such that the unit ball in the 2-norm is plotted with reasonable accuracy. On the other hand, if you only want to produce a fast box-overapproximation of <code>X</code>, pass <code>ε=Inf</code>.</p><p>In a second stage, the list of vertices of the overapproximation is computed with the <code>vertices_list</code> function of the polygon.</p><p>A post-processing <code>convex_hull</code> is applied to the vertices list to ensure that the shaded area inside the convex hull of the vertices is covered correctly.</p><p><strong>Notes</strong></p><p>This recipe detects if overapproximation is such that the first two vertices returned by <code>vertices_list</code> are the same. In that case, a scatter plot is used (instead of a shape plot). This corner case arises, for example, when lazy linear maps of singletons.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/plot_recipes.jl#L14-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{XN}, Tuple{N}, Tuple{Dict{Symbol,Any},Array{XN,1}}, Tuple{Dict{Symbol,Any},Array{XN,1},N}} where XN&lt;:LazySet{N} where N&lt;:Real" href="#RecipesBase.apply_recipe-Union{Tuple{XN}, Tuple{N}, Tuple{Dict{Symbol,Any},Array{XN,1}}, Tuple{Dict{Symbol,Any},Array{XN,1},N}} where XN&lt;:LazySet{N} where N&lt;:Real"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_lazyset(X::Vector{XN}, ε::N=N(1e-3); ...) where {N&lt;:Real, XN&lt;:LazySet{N}}</code></pre><p>Plot an array of convex sets in two dimensions.</p><p><strong>Input</strong></p><ul><li><code>X</code> – array of convex sets</li><li><code>ε</code> – (optional, default: <code>1e-3</code>) approximation error bound</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; B1 = BallInf(zeros(2), 0.4);

julia&gt; B2 = BallInf(ones(2), 0.4);

julia&gt; plot([B1, B2])</code></pre><p>An iterative refinement method is applied to obtain an overapproximation of each set in <code>X</code> in constraint representation, which is then plotted. To change the default tolerance for the iterative refinement, use the second argument; it applies to all sets in the array.</p><pre><code class="language-julia">julia&gt; B1 = BallInf(zeros(2), 0.4);

julia&gt; B2 = Ball2(ones(2), 0.4);

julia&gt; plot([B1, B2], 1e-1) # faster but less accurate 

julia&gt; plot([B1, B2], 1e-4) # slower but more accurate </code></pre><p><strong>Algorithm</strong></p><p>Refer to the documentation of <code>plot_lazyset(S::LazySet, [ε]::Float64; ...)</code> for further details.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/plot_recipes.jl#L97-L136">source</a></section><h3><a class="nav-anchor" id="Set-functions-that-override-Base-functions-1" href="#Set-functions-that-override-Base-functions-1">Set functions that override Base functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Tuple{LazySet,LazySet}" href="#Base.:==-Tuple{LazySet,LazySet}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">==(X::LazySet, Y::LazySet)</code></pre><p>Return whether two LazySets of the same type are exactly equal by recursively comparing their fields until a mismatch is found.</p><p><strong>Input</strong></p><ul><li><code>X</code> – any <code>LazySet</code></li><li><code>Y</code> – another <code>LazySet</code> of the same type as <code>X</code></li></ul><p><strong>Output</strong></p><ul><li><code>true</code> iff <code>X</code> is equal to <code>Y</code>.</li></ul><p><strong>Notes</strong></p><p>The check is purely syntactic and the sets need to have the same base type. I.e. <code>X::VPolytope == Y::HPolytope</code> returns <code>false</code> even if <code>X</code> and <code>Y</code> represent the same polytope. However <code>X::HPolytope{Int64} == Y::HPolytope{Float64}</code> is a valid comparison.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; HalfSpace([1], 1) == HalfSpace([1], 1)
true

julia&gt; HalfSpace([1], 1) == HalfSpace([1.0], 1.0)
true

julia&gt; Ball1([0.], 1.) == Ball2([0.], 1.)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LazySet.jl#L300-L332">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy-Tuple{LazySet}" href="#Base.copy-Tuple{LazySet}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">copy(S::LazySet)</code></pre><p>Return a deep copy of the given set by copying its values recursively.</p><p><strong>Input</strong></p><ul><li><code>S</code> – any <code>LazySet</code></li></ul><p><strong>Output</strong></p><p>A copy of <code>S</code>.</p><p><strong>Notes</strong></p><p>This function performs a <code>deepcopy</code> of each field in <code>S</code>, resulting in a completely independent object. See the documentation of <code>?deepcopy</code> for further details.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LazySet.jl#L355-L373">source</a></section><h3><a class="nav-anchor" id="Aliases-for-set-types-1" href="#Aliases-for-set-types-1">Aliases for set types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CompactSet" href="#LazySets.CompactSet"><code>LazySets.CompactSet</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">CompactSet</code></pre><p>An alias for compact set types.</p><p><strong>Notes</strong></p><p>Most lazy operations are not captured by this alias because whether their result is compact or not depends on the argument(s).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/aliases.jl#L4-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.NonCompactSet" href="#LazySets.NonCompactSet"><code>LazySets.NonCompactSet</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">NonCompactSet</code></pre><p>An alias for non-compact set types.</p><p><strong>Notes</strong></p><p>Most lazy operations are not captured by this alias because whether their result is non-compact or not depends on the argument(s).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/aliases.jl#L20-L29">source</a></section><h2><a class="nav-anchor" id="Centrally-symmetric-set-1" href="#Centrally-symmetric-set-1">Centrally symmetric set</a></h2><p>Centrally symmetric sets such as balls of different norms are characterized by a center. Note that there is a special interface combination <a href="#Centrally-symmetric-polytope-1">Centrally symmetric polytope</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractCentrallySymmetric" href="#LazySets.AbstractCentrallySymmetric"><code>LazySets.AbstractCentrallySymmetric</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractCentrallySymmetric{N&lt;:Real} &lt;: LazySet{N}</code></pre><p>Abstract type for centrally symmetric sets.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractCentrallySymmetric</code> must define the following functions:</p><ul><li><code>center(::AbstractCentrallySymmetric{N})::Vector{N}</code> – return the center   point</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractCentrallySymmetric)
3-element Array{Any,1}:
 Ball2
 Ballp
 Ellipsoid</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractCentrallySymmetric.jl#L7-L26">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractCentrallySymmetric}" href="#LazySets.dim-Tuple{AbstractCentrallySymmetric}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(S::AbstractCentrallySymmetric)::Int</code></pre><p>Return the ambient dimension of a centrally symmetric set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractCentrallySymmetric.jl#L30-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{AbstractCentrallySymmetric}" href="#LazySets.isbounded-Tuple{AbstractCentrallySymmetric}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(S::AbstractCentrallySymmetric)::Bool</code></pre><p>Determine whether a centrally symmetric set is bounded.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p><code>true</code> (since a set with a unique center must be bounded).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractCentrallySymmetric.jl#L47-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(S::AbstractCentrallySymmetric{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a centrally symmetric set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p>The center of the centrally symmetric set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractCentrallySymmetric.jl#L64-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{AbstractCentrallySymmetric}" href="#Base.isempty-Tuple{AbstractCentrallySymmetric}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(S::AbstractCentrallySymmetric)::Bool</code></pre><p>Return if a centrally symmetric set is empty or not.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractCentrallySymmetric.jl#L81-L93">source</a></section><h2><a class="nav-anchor" id="Polyhedron-1" href="#Polyhedron-1">Polyhedron</a></h2><p>A polyhedron has finitely many facets (<em>H-representation</em>) and is not necessarily bounded.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractPolyhedron" href="#LazySets.AbstractPolyhedron"><code>LazySets.AbstractPolyhedron</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractPolyhedron{N&lt;:Real} &lt;: LazySet{N}</code></pre><p>Abstract type for polyhedral sets, i.e., sets with finitely many flat facets, or equivalently, sets defined as an intersection of a finite number of half-spaces.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolyhedron</code> must define the following functions:</p><ul><li><code>constraints_list(::AbstractPolyhedron{N})::Vector{LinearConstraint{N}}</code> –   return a list of all facet constraints</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolyhedron)
6-element Array{Any,1}:
 AbstractPolytope
 HPolyhedron
 HalfSpace
 Hyperplane
 Line
 Universe</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractPolyhedron.jl#L3-L25">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractPolyhedron{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractPolyhedron{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, P::AbstractPolyhedron{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a polyhedron.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>P</code> – polyhedron</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation checks if the point lies inside each defining half-space.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractPolyhedron_functions.jl#L9-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constrained_dimensions-Tuple{AbstractPolyhedron}" href="#LazySets.constrained_dimensions-Tuple{AbstractPolyhedron}"><code>LazySets.constrained_dimensions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constrained_dimensions(P::AbstractPolyhedron)::Vector{Int} where {N&lt;:Real}</code></pre><p>Return the indices in which a polyhedron is constrained.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polyhedron</li></ul><p><strong>Output</strong></p><p>A vector of ascending indices <code>i</code> such that the polyhedron is constrained in dimension <code>i</code>.</p><p><strong>Examples</strong></p><p>A 2D polyhedron with constraint <span>$x1 ≥ 0$</span> is constrained in dimension 1 only.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractPolyhedron_functions.jl#L39-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolyhedron{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolyhedron{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N},
           P::AbstractPolyhedron{N};
           check_invertibility::Bool=true,
           cond_tol::Number=DEFAULT_COND_TOL,
           use_inv::Bool=!issparse(M)
           ) where {N&lt;:Real}</code></pre><p>Concrete linear map of a polyhedron in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>P</code> – abstract polyhedron</li><li><code>check_invertibility</code> – (optional, deault: <code>true</code>) check if the linear map is                          invertible, in which case this function uses the matrix                          inverse; if the invertibility check fails, or if                          this flag is set to <code>false</code>, use the vertex representation                          to compute the linear map (see below for details)</li><li><code>cond_tol</code> – (optional) tolerance of matrix condition (used to check whether               the matrix is invertible)</li><li><code>use_inv</code>  – (optional, default: <code>false</code> if <code>M</code> is sparse and <code>true</code>               otherwise) whether to compute the full left division through               <code>inv(M)</code>, or to use the left division for each vector; see below </li></ul><p><strong>Output</strong></p><p>The type of the result is &quot;as close as possible&quot; to the the type of <code>P</code>. Let <code>(m, n)</code> be the size of <code>M</code>, where <code>m ≠ n</code> is allowed for rectangular maps.</p><p>To fix the type of the output to something different than the default value, consider post-processing the result of this function with a call to a suitable <code>convert</code> method.</p><p>In particular, the output depends on the type of <code>P</code>, on <code>m</code>, and the algorithm that was used:</p><ul><li><p>If the vertex-based approach was used:</p><ul><li>If <code>P</code> is a <code>VPolygon</code> and <code>m = 2</code> then the output is a <code>VPolygon</code>.</li><li>If <code>P</code> is a <code>VPolytope</code> then the output is a <code>VPolytope</code>.</li><li>Otherwise, the output is an <code>Interval</code> if <code>m = 1</code>, a <code>VPolygon</code> if <code>m = 2</code> and a <code>VPolytope</code> in other cases.</li></ul></li><li><p>If the invertibility criterion was used:</p><ul><li>The types of <code>HalfSpace</code>, <code>Hyperplane</code>, <code>Line</code> and <code>AbstractHPolygon</code> are preserved.</li><li>If <code>P</code> is an <code>AbstractPolytope</code>, then the output is an <code>Interval</code> if <code>m = 1</code>, an <code>HPolygon</code> if <code>m = 2</code> and an <code>HPolytope</code> in other cases.</li><li>Otherwise, the output is an <code>HPolyhedron</code>.</li></ul></li></ul><p><strong>Algorithm</strong></p><p>This function implements two algorithms for the linear map:</p><ul><li>If the matrix <span>$M$</span> is invertible (which we check with a sufficient condition), then <span>$y = M x$</span> implies <span>$x = \text{inv}(M) y$</span> and we transform the constraint system <span>$A x ≤ b$</span> to <span>$A \text{inv}(M) y ≤ b$</span>.</li><li>Otherwise, we transform the polyhedron to vertex representation and apply the map to each vertex, returning a polyhedron in vertex representation. </li></ul><p>Note that the vertex representation (second approach) is only available if the polyhedron is bounded. Hence we check boundedness first.</p><p>To switch off the check for invertibility, set the option <code>check_invertibility=false</code>. If <code>M</code> is not invertible and the polyhedron is unbounded, this function returns an exception.</p><p>The option <code>use_inv</code> lets the user control - in case <code>M</code> is invertible - if the full matrix inverse is computed, or only the left division on the normal vectors. Note that this helps as a workaround when <code>M</code> is a sparse matrix, since the <code>inv</code> function is not available for sparse matrices. In this case, either use the option <code>use_inv=false</code> or convert the type of <code>M</code> as in <code>linear_map(Matrix(M), P)</code>.</p><p>Internally, this function operates at the level of the <code>AbstractPolyhedron</code> interface, but the actual algorithm uses dispatch on the concrete type of <code>P</code>, depending on the algorithm that is used:</p><ul><li><code>_linear_map_vrep(M, P)</code> if the vertex approach is used</li><li><code>_linear_map_hrep(M, P, use_inv)</code> if the invertibility criterion is used</li></ul><p>New subtypes of the interface should write their own <code>_linear_map_vrep</code> (resp. <code>_linear_map_hrep</code>) for special handling of the linear map; otherwise the fallback implementation for <code>AbstractPolyhedron</code> is used (see below).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractPolyhedron_functions.jl#L216-L302">source</a></section><h3><a class="nav-anchor" id="Polytope-1" href="#Polytope-1">Polytope</a></h3><p>A polytope is a bounded set with finitely many vertices (<em>V-representation</em>) resp. facets (<em>H-representation</em>). Note that there is a special interface combination <a href="#Centrally-symmetric-polytope-1">Centrally symmetric polytope</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractPolytope" href="#LazySets.AbstractPolytope"><code>LazySets.AbstractPolytope</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractPolytope{N&lt;:Real} &lt;: AbstractPolyhedron{N}</code></pre><p>Abstract type for polytopic sets, i.e., bounded sets with finitely many flat facets, or equivalently, bounded sets defined as an intersection of a finite number of half-spaces, or equivalently, bounded sets with finitely many vertices.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolytope</code> must define the following functions:</p><ul><li><code>vertices_list(::AbstractPolytope{N})::Vector{Vector{N}}</code> – return a list of   all vertices</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolytope)
4-element Array{Any,1}:
 AbstractCentrallySymmetricPolytope
 AbstractPolygon
 HPolytope
 VPolytope</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractPolytope.jl#L8-L30">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{AbstractPolytope}" href="#LazySets.isbounded-Tuple{AbstractPolytope}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(P::AbstractPolytope)::Bool</code></pre><p>Determine whether a polytopic set is bounded.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polytopic set</li></ul><p><strong>Output</strong></p><p><code>true</code> (since a polytope must be bounded).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractPolytope.jl#L38-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">singleton_list(P::AbstractPolytope{N})::Vector{Singleton{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a polytopic set as a list of singletons.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polytopic set</li></ul><p><strong>Output</strong></p><p>List containing a singleton for each vertex.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractPolytope.jl#L55-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{AbstractPolytope}" href="#Base.isempty-Tuple{AbstractPolytope}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(P::AbstractPolytope)::Bool</code></pre><p>Determine whether a polytope is empty.</p><p><strong>Input</strong></p><ul><li><code>P</code> – abstract polytope</li></ul><p><strong>Output</strong></p><p><code>true</code> if the given polytope contains no vertices, and <code>false</code> otherwise.</p><p><strong>Algorithm</strong></p><p>This algorithm checks whether the <code>vertices_list</code> of the given polytope is empty or not.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractPolytope.jl#L73-L90">source</a></section><p>Plotting abstract polytopes is available too:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{Dict{Symbol,Any},AbstractPolytope{N}}, Tuple{Dict{Symbol,Any},AbstractPolytope{N},N}} where N&lt;:Real" href="#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{Dict{Symbol,Any},AbstractPolytope{N}}, Tuple{Dict{Symbol,Any},AbstractPolytope{N},N}} where N&lt;:Real"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_polytope(P::AbstractPolytope, [ε]::N=zero(N); ...) where {N&lt;:Real}</code></pre><p>Plot a 2D polytope as the convex hull of its vertices.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon or polytope</li><li><code>ε</code> – (optional, default: <code>0</code>) ignored, used for dispatch</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; P = HPolygon([LinearConstraint([1.0, 0.0], 0.6),
                     LinearConstraint([0.0, 1.0], 0.6),
                     LinearConstraint([-1.0, 0.0], -0.4),
                     LinearConstraint([0.0, -1.0], -0.4)]);

julia&gt; plot(P)</code></pre><p>This recipe also applies if the polygon is given in vertex representation:</p><pre><code class="language-julia">julia&gt; P = VPolygon([[0.6, 0.6], [0.4, 0.6], [0.4, 0.4], [0.6, 0.4]]);

julia&gt; plot(P);</code></pre><p><strong>Algorithm</strong></p><p>This function checks that the polytope received is two-dimensional, then computes its vertices accessing its <code>vertices_list</code> function and takes their convex hull. The set is plotted and shaded using the <code>:shape</code> series type from <code>Plots</code>. </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/plot_recipes.jl#L175-L210">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{PN}, Tuple{N}, Tuple{Dict{Symbol,Any},Array{PN,1}}, Tuple{Dict{Symbol,Any},Array{PN,1},N}} where PN&lt;:AbstractPolytope{N} where N&lt;:Real" href="#RecipesBase.apply_recipe-Union{Tuple{PN}, Tuple{N}, Tuple{Dict{Symbol,Any},Array{PN,1}}, Tuple{Dict{Symbol,Any},Array{PN,1},N}} where PN&lt;:AbstractPolytope{N} where N&lt;:Real"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_polytopes(P::Vector{PN}, [ε]::N=zero(N); ...) where {N&lt;:Real, PN&lt;:AbstractPolytope{N}}</code></pre><p>Plot an array of 2D polytopes as the convex hull of their vertices.</p><p><strong>Input</strong></p><ul><li><code>P</code> – vector of polygons or polytopes</li><li><code>ε</code> – (optional, default: <code>0.0</code>) ignored, used for dispatch</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; P = HPolygon([LinearConstraint([1.0, 0.0], 0.6),
                     LinearConstraint([0.0, 1.0], 0.6),
                     LinearConstraint([-1.0, 0.0], -0.4),
                     LinearConstraint([0.0, -1.0], -0.4)]);

julia&gt; plot(P)</code></pre><p>This recipe also applies if the polygon is given in vertex representation:</p><pre><code class="language-julia">julia&gt; P = VPolygon([[0.6, 0.6], [0.4, 0.6], [0.4, 0.4], [0.6, 0.4]]);

julia&gt; plot(P)</code></pre><p><strong>Algorithm</strong></p><p>This function checks that the polytope received is two-dimensional, then computes its vertices accessing its <code>vertices_list</code> function and takes their convex hull. The set is plotted and shaded using the <code>:shape</code> series type from <code>Plots</code>. </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/plot_recipes.jl#L241-L276">source</a></section><h4><a class="nav-anchor" id="Polygon-1" href="#Polygon-1">Polygon</a></h4><p>A polygon is a two-dimensional polytope.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractPolygon" href="#LazySets.AbstractPolygon"><code>LazySets.AbstractPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractPolygon{N&lt;:Real} &lt;: AbstractPolytope{N}</code></pre><p>Abstract type for polygons (i.e., 2D polytopes).</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolygon</code> must define the following functions:</p><ul><li><code>tovrep(::AbstractPolygon{N})::VPolygon{N}</code>         – transform into   V-representation</li><li><code>tohrep(::AbstractPolygon{N})::S where {S&lt;:AbstractHPolygon{N}}</code> – transform   into H-representation</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolygon)
2-element Array{Any,1}:
 AbstractHPolygon
 VPolygon</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractPolygon.jl#L7-L26">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractPolygon}" href="#LazySets.dim-Tuple{AbstractPolygon}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(P::AbstractPolygon)::Int</code></pre><p>Return the ambient dimension of a polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polygon, which is 2.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractPolygon.jl#L33-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolygon{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolygon{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N},
           P::AbstractPolyhedron{N};
           check_invertibility::Bool=true,
           cond_tol::Number=DEFAULT_COND_TOL,
           use_inv::Bool=!issparse(M)
           ) where {N&lt;:Real}</code></pre><p>Concrete linear map of a polyhedron in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>P</code> – abstract polyhedron</li><li><code>check_invertibility</code> – (optional, deault: <code>true</code>) check if the linear map is                          invertible, in which case this function uses the matrix                          inverse; if the invertibility check fails, or if                          this flag is set to <code>false</code>, use the vertex representation                          to compute the linear map (see below for details)</li><li><code>cond_tol</code> – (optional) tolerance of matrix condition (used to check whether               the matrix is invertible)</li><li><code>use_inv</code>  – (optional, default: <code>false</code> if <code>M</code> is sparse and <code>true</code>               otherwise) whether to compute the full left division through               <code>inv(M)</code>, or to use the left division for each vector; see below </li></ul><p><strong>Output</strong></p><p>The type of the result is &quot;as close as possible&quot; to the the type of <code>P</code>. Let <code>(m, n)</code> be the size of <code>M</code>, where <code>m ≠ n</code> is allowed for rectangular maps.</p><p>To fix the type of the output to something different than the default value, consider post-processing the result of this function with a call to a suitable <code>convert</code> method.</p><p>In particular, the output depends on the type of <code>P</code>, on <code>m</code>, and the algorithm that was used:</p><ul><li><p>If the vertex-based approach was used:</p><ul><li>If <code>P</code> is a <code>VPolygon</code> and <code>m = 2</code> then the output is a <code>VPolygon</code>.</li><li>If <code>P</code> is a <code>VPolytope</code> then the output is a <code>VPolytope</code>.</li><li>Otherwise, the output is an <code>Interval</code> if <code>m = 1</code>, a <code>VPolygon</code> if <code>m = 2</code> and a <code>VPolytope</code> in other cases.</li></ul></li><li><p>If the invertibility criterion was used:</p><ul><li>The types of <code>HalfSpace</code>, <code>Hyperplane</code>, <code>Line</code> and <code>AbstractHPolygon</code> are preserved.</li><li>If <code>P</code> is an <code>AbstractPolytope</code>, then the output is an <code>Interval</code> if <code>m = 1</code>, an <code>HPolygon</code> if <code>m = 2</code> and an <code>HPolytope</code> in other cases.</li><li>Otherwise, the output is an <code>HPolyhedron</code>.</li></ul></li></ul><p><strong>Algorithm</strong></p><p>This function implements two algorithms for the linear map:</p><ul><li>If the matrix <span>$M$</span> is invertible (which we check with a sufficient condition), then <span>$y = M x$</span> implies <span>$x = \text{inv}(M) y$</span> and we transform the constraint system <span>$A x ≤ b$</span> to <span>$A \text{inv}(M) y ≤ b$</span>.</li><li>Otherwise, we transform the polyhedron to vertex representation and apply the map to each vertex, returning a polyhedron in vertex representation. </li></ul><p>Note that the vertex representation (second approach) is only available if the polyhedron is bounded. Hence we check boundedness first.</p><p>To switch off the check for invertibility, set the option <code>check_invertibility=false</code>. If <code>M</code> is not invertible and the polyhedron is unbounded, this function returns an exception.</p><p>The option <code>use_inv</code> lets the user control - in case <code>M</code> is invertible - if the full matrix inverse is computed, or only the left division on the normal vectors. Note that this helps as a workaround when <code>M</code> is a sparse matrix, since the <code>inv</code> function is not available for sparse matrices. In this case, either use the option <code>use_inv=false</code> or convert the type of <code>M</code> as in <code>linear_map(Matrix(M), P)</code>.</p><p>Internally, this function operates at the level of the <code>AbstractPolyhedron</code> interface, but the actual algorithm uses dispatch on the concrete type of <code>P</code>, depending on the algorithm that is used:</p><ul><li><code>_linear_map_vrep(M, P)</code> if the vertex approach is used</li><li><code>_linear_map_hrep(M, P, use_inv)</code> if the invertibility criterion is used</li></ul><p>New subtypes of the interface should write their own <code>_linear_map_vrep</code> (resp. <code>_linear_map_hrep</code>) for special handling of the linear map; otherwise the fallback implementation for <code>AbstractPolyhedron</code> is used (see below).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractPolyhedron_functions.jl#L216-L302">source</a></section><h5><a class="nav-anchor" id="HPolygon-1" href="#HPolygon-1">HPolygon</a></h5><p>An HPolygon is a polygon in H-representation (or constraint representation).</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractHPolygon" href="#LazySets.AbstractHPolygon"><code>LazySets.AbstractHPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractHPolygon{N&lt;:Real} &lt;: AbstractPolygon{N}</code></pre><p>Abstract type for polygons in H-representation (i.e., constraints).</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractHPolygon</code> must have the following fields:</p><ul><li><code>constraints::Vector{LinearConstraint{N}}</code> – the constraints</li></ul><p>New subtypes should be added to the <code>convert</code> method in order to be convertible.</p><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractHPolygon)
2-element Array{Any,1}:
 HPolygon
 HPolygonOpt</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHPolygon.jl#L20-L38">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(P::AbstractHPolygon{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>A vertex of the polygon in constraint representation (the first one in the order of the constraints).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHPolygon.jl#L162-L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHPolygon{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHPolygon{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, P::AbstractHPolygon{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given 2D point is contained in a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>x</code> – two-dimensional point/vector</li><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation checks if the point lies on the outside of each edge.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHPolygon.jl#L182-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Union{Tuple{Type{HPOLYGON}}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon" href="#Base.rand-Union{Tuple{Type{HPOLYGON}}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{HPOLYGON}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing,
     [num_constraints]::Int=-1
    )::HPOLYGON{N} where {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Create a random polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPOLYGON</code>        – type for dispatch</li><li><code>N</code>               – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>             – (optional, default: 2) dimension</li><li><code>rng</code>             – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>            – (optional, default: <code>nothing</code>) seed for reseeding</li><li><code>num_constraints</code> – (optional, default: <code>-1</code>) number of constraints of the                      polygon (must be 3 or bigger; see comment below)</li></ul><p><strong>Output</strong></p><p>A random polygon in constraint representation.</p><p><strong>Algorithm</strong></p><p>We create a random polygon in vertex representation and convert it to constraint representation. See <a href="../representations/#Base.rand-Tuple{Type{VPolygon}}"><code>rand(::Type{VPolygon})</code></a>. For non-flat polygons the number of vertices and the number of constraints are identical.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHPolygon.jl#L212-L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tohrep-Union{Tuple{HPOLYGON}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon" href="#LazySets.tohrep-Union{Tuple{HPOLYGON}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon"><code>LazySets.tohrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tohrep(P::HPOLYGON)::HPOLYGON where {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Build a contraint representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>The identity, i.e., the same polygon instance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHPolygon.jl#L63-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tovrep-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.tovrep-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.tovrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tovrep(P::AbstractHPolygon{N})::VPolygon{N} where {N&lt;:Real}</code></pre><p>Build a vertex representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>The same polygon but in vertex representation, a <code>VPolygon</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHPolygon.jl#L45-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.addconstraint!-Union{Tuple{N}, Tuple{AbstractHPolygon{N},HalfSpace{N}}} where N&lt;:Real" href="#LazySets.addconstraint!-Union{Tuple{N}, Tuple{AbstractHPolygon{N},HalfSpace{N}}} where N&lt;:Real"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">addconstraint!(P::AbstractHPolygon{N},
               constraint::LinearConstraint{N};
               [linear_search]::Bool=(length(P.constraints) &lt;
                                      BINARY_SEARCH_THRESHOLD),
               [prune]::Bool=true
              )::Nothing where {N&lt;:Real}</code></pre><p>Add a linear constraint to a polygon in constraint representation, keeping the constraints sorted by their normal directions.</p><p><strong>Input</strong></p><ul><li><code>P</code>             – polygon in constraint representation</li><li><code>constraint</code>    – linear constraint to add</li><li><code>linear_search</code> – (optional, default: <code>length(constraints) &lt;                    BINARY_SEARCH_THRESHOLD</code>) flag to choose between linear                    and binary search</li><li><code>prune</code>         – (optional, default: <code>true</code>) flag for removing redundant                    constraints in the end</li></ul><p><strong>Output</strong></p><p>Nothing.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHPolygon.jl#L372-L396">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.addconstraint!-Union{Tuple{N}, Tuple{Array{HalfSpace{N},1},HalfSpace{N}}} where N&lt;:Real" href="#LazySets.addconstraint!-Union{Tuple{N}, Tuple{Array{HalfSpace{N},1},HalfSpace{N}}} where N&lt;:Real"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">addconstraint!(constraints::Vector{LinearConstraint{N}},
               new_constraint::LinearConstraint{N};
               [linear_search]::Bool=(length(P.constraints) &lt;
                                      BINARY_SEARCH_THRESHOLD),
               [prune]::Bool=true
              )::Nothing where {N&lt;:Real}</code></pre><p>Add a linear constraint to a sorted vector of constrains, keeping the constraints sorted by their normal directions.</p><p><strong>Input</strong></p><ul><li><code>constraints</code>    – vector of linear constraintspolygon in constraint                     representation</li><li><code>new_constraint</code> – linear constraint to add</li><li><code>linear_search</code>  – (optional, default: <code>length(constraints) &lt;                     BINARY_SEARCH_THRESHOLD</code>) flag to choose between linear                     and binary search</li><li><code>prune</code>          – (optional, default: <code>true</code>) flag for removing redundant                     constraints in the end</li></ul><p><strong>Output</strong></p><p>Nothing.</p><p><strong>Algorithm</strong></p><p>If <code>prune</code> is active, we check if the new constraint is redundant. If the constraint is not redundant, we perform the same check to the left and to the right until we find the first constraint that is not redundant.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHPolygon.jl#L407-L438">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isredundant-Union{Tuple{N}, Tuple{HalfSpace{N},HalfSpace{N},HalfSpace{N}}} where N&lt;:Real" href="#LazySets.isredundant-Union{Tuple{N}, Tuple{HalfSpace{N},HalfSpace{N},HalfSpace{N}}} where N&lt;:Real"><code>LazySets.isredundant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isredundant(cmid::LinearConstraint{N}, cright::LinearConstraint{N},
            cleft::LinearConstraint{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a linear constraint is redundant wrt. two surrounding constraints.</p><p><strong>Input</strong></p><ul><li><code>cmid</code>   – linear constraint of concern</li><li><code>cright</code> – linear constraint to the right (clockwise turn)</li><li><code>cleft</code>  – linear constraint to the left (counter-clockwise turn)</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the constraint is redundant.</p><p><strong>Algorithm</strong></p><p>We first check whether the angle between the surrounding constraints is &lt; 180°, which is a necessary condition (unless the direction is identical to one of the other two constraints). If so, we next check if the angle is 0°, in which case the constraint <code>cmid</code> is redundant unless it is strictly tighter than the other two constraints. If the angle is strictly between 0° and 180°, the constraint <code>cmid</code> is redundant if and only if the vertex defined by the other two constraints lies inside the set defined by <code>cmid</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHPolygon.jl#L261-L287">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.remove_redundant_constraints!-Tuple{AbstractHPolygon}" href="#LazySets.remove_redundant_constraints!-Tuple{AbstractHPolygon}"><code>LazySets.remove_redundant_constraints!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">remove_redundant_constraints!(P::AbstractHPolygon)</code></pre><p>Remove all redundant constraints of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>The same polygon with all redundant constraints removed.</p><p><strong>Notes</strong></p><p>Since we only consider bounded polygons and a polygon needs at least three constraints to be bounded, we stop removing redundant constraints if there are three or less constraints left. This means that for non-bounded polygons the result may be unexpected.</p><p><strong>Algorithm</strong></p><p>We go through all consecutive triples of constraints and check if the one in the middle is redundant. For this we assume that the constraints are sorted.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHPolygon.jl#L323-L348">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(P::AbstractHPolygon{N})::Vector{LinearConstraint{N}} where {N&lt;:Real}</code></pre><p>Return the list of constraints defining a polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in H-representation</li></ul><p><strong>Output</strong></p><p>The list of constraints of the polygon.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHPolygon.jl#L141-L153">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}, Tuple{AbstractHPolygon{N},Bool}, Tuple{AbstractHPolygon{N},Bool,Bool}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}, Tuple{AbstractHPolygon{N},Bool}, Tuple{AbstractHPolygon{N},Bool,Bool}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(P::AbstractHPolygon{N},
              apply_convex_hull::Bool=false,
              check_feasibility::Bool=true
             )::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>                 – polygon in constraint representation</li><li><code>apply_convex_hull</code> – (optional, default: <code>false</code>) flag to post-process the                        intersection of constraints with a convex hull</li><li><code>check_feasibility</code> – (optional, default: <code>true</code>) flag to check whether the                        polygon was empty (required for correctness in case of                        empty polygons)</li></ul><p><strong>Output</strong></p><p>List of vertices.</p><p><strong>Algorithm</strong></p><p>We compute each vertex as the intersection of consecutive lines defined by the half-spaces. If <code>check_feasibility</code> is active, we then check if the constraints of the polygon were actually feasible (i.e., they pointed in the <em>right</em> direction). For this we compute the <em>average</em> of all vertices and check membership in each constraint.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHPolygon.jl#L84-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded" href="#LazySets.isbounded"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isbounded(P::AbstractHPolygon, [use_type_assumption]::Bool=true)::Bool</code></pre><p>Determine whether a polygon in constraint representation is bounded.</p><p><strong>Input</strong></p><ul><li><code>P</code>                   – polygon in constraint representation</li><li><code>use_type_assumption</code> – (optional, default: <code>true</code>) flag for ignoring the                          type assumption that polygons are bounded</li></ul><p><strong>Output</strong></p><p><code>true</code> if <code>use_type_assumption</code> is activated. Otherwise, <code>true</code> iff <code>P</code> is bounded.</p><p><strong>Algorithm</strong></p><p>If <code>!use_type_assumption</code>, we convert <code>P</code> to an <code>HPolyhedron</code> <code>P2</code> and then use <code>isbounded(P2)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHPolygon.jl#L565-L585">source</a></section><h4><a class="nav-anchor" id="Centrally-symmetric-polytope-1" href="#Centrally-symmetric-polytope-1">Centrally symmetric polytope</a></h4><p>A centrally symmetric polytope is a combination of two other interfaces: <a href="#Centrally-symmetric-set-1">Centrally symmetric set</a> and <a href="#Polytope-1">Polytope</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractCentrallySymmetricPolytope" href="#LazySets.AbstractCentrallySymmetricPolytope"><code>LazySets.AbstractCentrallySymmetricPolytope</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractCentrallySymmetricPolytope{N&lt;:Real} &lt;: AbstractPolytope{N}</code></pre><p>Abstract type for centrally symmetric, polytopic sets. It combines the <code>AbstractCentrallySymmetric</code> and <code>AbstractPolytope</code> interfaces. Such a type combination is necessary as long as Julia does not support <a href="https://github.com/JuliaLang/julia/issues/5">multiple inheritance</a>.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractCentrallySymmetricPolytope</code> must define the following functions:</p><ul><li>from <code>AbstractCentrallySymmetric</code>:<ul><li><code>center(::AbstractCentrallySymmetricPolytope{N})::Vector{N}</code> – return the  center point</li></ul></li><li>from <code>AbstractPolytope</code>:<ul><li><code>vertices_list(::AbstractCentrallySymmetricPolytope{N})::Vector{Vector{N}}</code>  – return a list of all vertices</li></ul></li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractCentrallySymmetricPolytope)
4-element Array{Any,1}:
 AbstractHyperrectangle
 Ball1
 LineSegment
 Zonotope</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractCentrallySymmetricPolytope.jl#L9-L36">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}" href="#LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(P::AbstractCentrallySymmetricPolytope)::Int</code></pre><p>Return the ambient dimension of a centrally symmetric, polytopic set.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric, polytopic set</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polytopic set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractCentrallySymmetricPolytope.jl#L44-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(P::AbstractCentrallySymmetricPolytope{N})::Vector{N}
    where {N&lt;:Real}</code></pre><p>Return some element of a centrally symmetric polytope.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric polytope</li></ul><p><strong>Output</strong></p><p>The center of the centrally symmetric polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractCentrallySymmetricPolytope.jl#L62-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}" href="#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(P::AbstractCentrallySymmetricPolytope)::Bool</code></pre><p>Return if a centrally symmetric, polytopic set is empty or not.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric, polytopic set</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractCentrallySymmetricPolytope.jl#L81-L93">source</a></section><h5><a class="nav-anchor" id="Hyperrectangle-1" href="#Hyperrectangle-1">Hyperrectangle</a></h5><p>A hyperrectangle is a special centrally symmetric polytope with axis-aligned facets.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractHyperrectangle" href="#LazySets.AbstractHyperrectangle"><code>LazySets.AbstractHyperrectangle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractHyperrectangle{N&lt;:Real} &lt;: AbstractCentrallySymmetricPolytope{N}</code></pre><p>Abstract type for hyperrectangular sets.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractHyperrectangle</code> must define the following functions:</p><ul><li><code>radius_hyperrectangle(::AbstractHyperrectangle{N})::Vector{N}</code> – return the   hyperrectangle&#39;s radius, which is a full-dimensional vector</li><li><code>radius_hyperrectangle(::AbstractHyperrectangle{N}, i::Int)::N</code> – return the   hyperrectangle&#39;s radius in the <code>i</code>-th dimension</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractHyperrectangle)
5-element Array{Any,1}:
 AbstractSingleton
 BallInf
 Hyperrectangle
 Interval
 SymmetricIntervalHull</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHyperrectangle.jl#L9-L31">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">norm(H::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the norm of a hyperrectangular set.</p><p>The norm of a hyperrectangular set is defined as the norm of the enclosing ball, of the given <span>$p$</span>-norm, of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p><p><strong>Algorithm</strong></p><p>Recall that the norm is defined as</p><div>\[‖ X ‖ = \max_{x ∈ X} ‖ x ‖_p = max_{x ∈ \text{vertices}(X)} ‖ x ‖_p.\]</div><p>The last equality holds because the optimum of a convex function over a polytope is attained at one of its vertices.</p><p>This implementation uses the fact that the maximum is achieved in the vertex <span>$c + \text{diag}(\text{sign}(c)) r$</span>, for any <span>$p$</span>-norm, hence it suffices to take the <span>$p$</span>-norm of this particular vertex. This statement is proved below. Note that, in particular, there is no need to compute the <span>$p$</span>-norm for <em>each</em> vertex, which can be very expensive. </p><p>If <span>$X$</span> is an axis-aligned hyperrectangle and the <span>$n$</span>-dimensional vectors center and radius of the hyperrectangle are denoted <span>$c$</span> and <span>$r$</span> respectively, then reasoning on the <span>$2^n$</span> vertices we have that:</p><div>\[\max_{x ∈ \text{vertices}(X)} ‖ x ‖_p = \max_{α_1, …, α_n ∈ \{-1, 1\}} (|c_1 + α_1 r_1|^p + ... + |c_n + α_n r_n|^p)^{1/p}.\]</div><p>The function <span>$x ↦ x^p$</span>, <span>$p &gt; 0$</span>, is monotonically increasing and thus the maximum of each term <span>$|c_i + α_i r_i|^p$</span> is given by <span>$|c_i + \text{sign}(c_i) r_i|^p$</span> for each <span>$i$</span>. Hence, <span>$x^* := \text{argmax}_{x ∈ X} ‖ x ‖_p$</span> is the vertex <span>$c + \text{diag}(\text{sign}(c)) r$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHyperrectangle.jl#L117-L162">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius" href="#LazySets.radius"><code>LazySets.radius</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">radius(H::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the radius of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p><p><strong>Notes</strong></p><p>The radius is defined as the radius of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center. It is the same for all corners of a hyperrectangular set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHyperrectangle.jl#L168-L187">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a hyperrectangular set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the vertex with biggest values is returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHyperrectangle.jl#L96-L110">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, H::AbstractHyperrectangle{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ H$</span>.</p><p><strong>Algorithm</strong></p><p>Let <span>$H$</span> be an <span>$n$</span>-dimensional hyperrectangular set, <span>$c_i$</span> and <span>$r_i$</span> be the box&#39;s center and radius and <span>$x_i$</span> be the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ H$</span> iff <span>$|c_i - x_i| ≤ r_i$</span> for all <span>$i=1,…,n$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHyperrectangle.jl#L192-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(H::AbstractHyperrectangle{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Notes</strong></p><p>For high dimensions, it is preferable to develop a <code>vertex_iterator</code> approach.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHyperrectangle.jl#L39-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(H::AbstractHyperrectangle{N})::Vector{LinearConstraint{N}}
    where {N&lt;:Real}</code></pre><p>Return the list of constraints of an axis-aligned hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A list of linear constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHyperrectangle.jl#L66-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.high-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">high(H::AbstractHyperrectangle{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the higher coordinates of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A vector with the higher coordinates of the hyperrectangular set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHyperrectangle.jl#L228-L240">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},Int64}} where N&lt;:Real" href="#LazySets.high-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},Int64}} where N&lt;:Real"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">high(H::AbstractHyperrectangle{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the higher coordinate of a hyperrectangular set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The higher coordinate of the hyperrectangular set in the given dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHyperrectangle.jl#L245-L258">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.low-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">low(H::AbstractHyperrectangle{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the lower coordinates of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A vector with the lower coordinates of the hyperrectangular set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHyperrectangle.jl#L263-L275">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},Int64}} where N&lt;:Real" href="#LazySets.low-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},Int64}} where N&lt;:Real"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">low(H::AbstractHyperrectangle{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the lower coordinate of a hyperrectangular set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The lower coordinate of the hyperrectangular set in the given dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHyperrectangle.jl#L280-L293">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.split-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractArray{Int64,1}}} where N&lt;:Real" href="#Base.split-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractArray{Int64,1}}} where N&lt;:Real"><code>Base.split</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">split(H::AbstractHyperrectangle{N}, num_blocks::AbstractVector{Int}
     ) where {N&lt;:Real}</code></pre><p>Partition a hyperrectangular set into uniform sub-hyperrectangles.</p><p><strong>Input</strong></p><ul><li><code>H</code>          – hyperrectangular set</li><li><code>num_blocks</code> – number of blocks in the partition for each dimension</li></ul><p><strong>Output</strong></p><p>A list of <code>Hyperrectangle</code>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractHyperrectangle.jl#L298-L312">source</a></section><h5><a class="nav-anchor" id="Singleton-1" href="#Singleton-1">Singleton</a></h5><p>A singleton is a special hyperrectangle consisting of only one point.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractSingleton" href="#LazySets.AbstractSingleton"><code>LazySets.AbstractSingleton</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractSingleton{N&lt;:Real} &lt;: AbstractHyperrectangle{N}</code></pre><p>Abstract type for sets with a single value.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractSingleton</code> must define the following functions:</p><ul><li><code>element(::AbstractSingleton{N})::Vector{N}</code> – return the single element</li><li><code>element(::AbstractSingleton{N}, i::Int)::N</code> – return the single element&#39;s   entry in the <code>i</code>-th dimension</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractSingleton)
2-element Array{Any,1}:
 Singleton
 ZeroSet</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractSingleton.jl#L8-L26">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The support vector, which is the set&#39;s vector itself, irrespective of the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractSingleton.jl#L215-L229">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, S::AbstractSingleton{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ S$</span>.</p><p><strong>Notes</strong></p><p>This implementation performs an exact comparison, which may be insufficient with floating point computations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractSingleton.jl#L235-L253">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>An element of a convex set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LazySet.jl#L282-L294">source</a><div><div><pre><code class="language-julia">an_element(P::AbstractCentrallySymmetricPolytope{N})::Vector{N}
    where {N&lt;:Real}</code></pre><p>Return some element of a centrally symmetric polytope.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric polytope</li></ul><p><strong>Output</strong></p><p>The center of the centrally symmetric polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractCentrallySymmetricPolytope.jl#L62-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.center-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">center(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The only element of the set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractSingleton.jl#L149-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(S::AbstractSingleton{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A list containing only a single vertex.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractSingleton.jl#L170-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">radius_hyperrectangle(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the box radius of a set with a single value in every dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The zero vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractSingleton.jl#L53-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">radius_hyperrectangle(S::AbstractSingleton{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the box radius of a set with a single value in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>Zero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractSingleton.jl#L33-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.high-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">high(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the higher coordinates of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A vector with the higher coordinates of the set with a single value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractSingleton.jl#L72-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real" href="#LazySets.high-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">high(S::AbstractSingleton{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the higher coordinate of a set with a single value in the given dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The higher coordinate of the set with a single value in the given dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractSingleton.jl#L89-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.low-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">low(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the lower coordinates of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A vector with the lower coordinates of the set with a single value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractSingleton.jl#L108-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real" href="#LazySets.low-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">low(S::AbstractSingleton{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the lower coordinate of a set with a single value in the given dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The lower coordinate of the set with a single value in the given dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractSingleton.jl#L125-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractSingleton{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractSingleton{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Concrete linear map of an abstract singleton.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>S</code> – abstract singleton</li></ul><p><strong>Output</strong></p><p>The abstract singleton of the same type of <span>$S$</span> obtained by applying the linear map to the element in <span>$S$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/AbstractSingleton.jl#L188-L202">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{Dict{Symbol,Any},AbstractSingleton{N}}, Tuple{Dict{Symbol,Any},AbstractSingleton{N},N}} where N&lt;:Real" href="#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{Dict{Symbol,Any},AbstractSingleton{N}}, Tuple{Dict{Symbol,Any},AbstractSingleton{N},N}} where N&lt;:Real"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_singleton(S::AbstractSingleton{N}, [ε]::N=zero(N);; ...) where {N&lt;:Real}</code></pre><p>Plot a singleton.</p><p><strong>Input</strong></p><ul><li><code>S</code> – singleton wrapping a point, i.e., a one-element set</li><li><code>ε</code> – (optional, default: <code>0.0</code>) ignored, used for dispatch</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; plot(Singleton([0.5, 1.0]))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/plot_recipes.jl#L313-L328">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{SN}, Tuple{N}, Tuple{Dict{Symbol,Any},Array{SN,1}}, Tuple{Dict{Symbol,Any},Array{SN,1},N}} where SN&lt;:AbstractSingleton{N} where N&lt;:Real" href="#RecipesBase.apply_recipe-Union{Tuple{SN}, Tuple{N}, Tuple{Dict{Symbol,Any},Array{SN,1}}, Tuple{Dict{Symbol,Any},Array{SN,1},N}} where SN&lt;:AbstractSingleton{N} where N&lt;:Real"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_singletons(S::Vector{SN}, ε::N=zero(N); ...) where {N&lt;:Real, SN&lt;:AbstractSingleton{N}}</code></pre><p>Plot a list of singletons.</p><p><strong>Input</strong></p><ul><li><code>S</code> – list of singletons, i.e., a vector of one-element sets</li><li><code>ε</code> – (optional, default: <code>0.0</code>) ignored, used for dispatch</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; plot([Singleton([0.0, 0.0]), Singleton([1., 0]), Singleton([0.5, .5])])</code></pre><p>Three-dimensional singletons can be plotted as well, with this same recipe:</p><pre><code class="language-julia">julia&gt; a, b, c = [0.0, 0, 0], [1.0, 0, 0], [0.0, 1., 0];

julia&gt; plot([Singleton(a), Singleton(b), Singleton(c)])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/plot_recipes.jl#L344-L367">source</a></section><footer><hr/><a class="previous" href="../../man/lazy_intersections/"><span class="direction">Previous</span><span class="title">Lazy Intersections</span></a><a class="next" href="../representations/"><span class="direction">Next</span><span class="title">Common Set Representations</span></a></footer></article></body></html>
