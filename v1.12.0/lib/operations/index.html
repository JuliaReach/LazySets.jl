<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Common Set Operations · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/getting_started/">Getting Started</a></li><li><a class="toctext" href="../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="toctext" href="../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="toctext" href="../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="toctext" href="../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="toctext" href="../../man/interval_hulls/">Interval Hulls</a></li><li><a class="toctext" href="../../man/convex_hulls/">Convex Hulls</a></li><li><a class="toctext" href="../../man/set_operations/">Operations on Sets</a></li><li><a class="toctext" href="../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="toctext" href="../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="toctext" href="../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="toctext" href="../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../interfaces/">Set Interfaces</a></li><li><a class="toctext" href="../representations/">Common Set Representations</a></li><li class="current"><a class="toctext" href>Common Set Operations</a><ul class="internal"><li><a class="toctext" href="#Cartesian-Product-1">Cartesian Product</a></li><li><a class="toctext" href="#Convex-Hull-1">Convex Hull</a></li><li><a class="toctext" href="#Intersection-1">Intersection</a></li><li><a class="toctext" href="#Minkowski-Sum-1">Minkowski Sum</a></li><li><a class="toctext" href="#Maps-1">Maps</a></li><li><a class="toctext" href="#Symmetric-Interval-Hull-1">Symmetric Interval Hull</a></li><li><a class="toctext" href="#Union-1">Union</a></li><li><a class="toctext" href="#Complement-1">Complement</a></li></ul></li><li><a class="toctext" href="../comparisons/">Comparisons</a></li><li><a class="toctext" href="../conversion/">Conversions between set representations</a></li><li><a class="toctext" href="../binary_functions/">Binary Functions on Sets</a></li><li><a class="toctext" href="../approximations/">Approximations</a></li><li><a class="toctext" href="../utils/">Utility Functions</a></li><li><a class="toctext" href="../parallel/">Parallel</a></li></ul></li><li><a class="toctext" href="../../about/">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Common Set Operations</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/operations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Common Set Operations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Common-Set-Operations-1" href="#Common-Set-Operations-1">Common Set Operations</a></h1><p>This section of the manual describes the basic symbolic types describing operations between sets.</p><ul><li><a href="#Common-Set-Operations-1">Common Set Operations</a></li><ul><li><a href="#Cartesian-Product-1">Cartesian Product</a></li><ul><li><a href="#Binary-Cartesian-Product-1">Binary Cartesian Product</a></li><li><a href="#n-ary-Cartesian-Product-1"><span>$n$</span>-ary Cartesian Product</a></li></ul><li><a href="#Convex-Hull-1">Convex Hull</a></li><ul><li><a href="#Binary-Convex-Hull-1">Binary Convex Hull</a></li><li><a href="#n-ary-Convex-Hull-1"><span>$n$</span>-ary Convex Hull</a></li><li><a href="#Convex-Hull-Algorithms-1">Convex Hull Algorithms</a></li></ul><li><a href="#Intersection-1">Intersection</a></li><ul><li><a href="#Binary-Intersection-1">Binary Intersection</a></li><li><a href="#n-ary-Intersection-1"><span>$n$</span>-ary Intersection</a></li></ul><li><a href="#Minkowski-Sum-1">Minkowski Sum</a></li><ul><li><a href="#Binary-Minkowski-Sum-1">Binary Minkowski Sum</a></li><li><a href="#n-ary-Minkowski-Sum-1"><span>$n$</span>-ary Minkowski Sum</a></li><li><a href="#n-ary-Minkowski-Sum-with-cache-1"><span>$n$</span>-ary Minkowski Sum with cache</a></li></ul><li><a href="#Maps-1">Maps</a></li><ul><li><a href="#Linear-Map-1">Linear Map</a></li><li><a href="#Exponential-Map-1">Exponential Map</a></li><li><a href="#Reset-Map-1">Reset Map</a></li></ul><li><a href="#Symmetric-Interval-Hull-1">Symmetric Interval Hull</a></li><ul><li><a href="#Translation-1">Translation</a></li></ul><li><a href="#Union-1">Union</a></li><ul><li><a href="#Binary-Set-Union-1">Binary Set Union</a></li><li><a href="#n-ary-Set-Union-1"><span>$n$</span>-ary Set Union</a></li></ul><li><a href="#Complement-1">Complement</a></li><ul><li><a href="#Binary-Set-Union-2">Binary Set Union</a></li></ul></ul></ul><h2><a class="nav-anchor" id="Cartesian-Product-1" href="#Cartesian-Product-1">Cartesian Product</a></h2><h3><a class="nav-anchor" id="Binary-Cartesian-Product-1" href="#Binary-Cartesian-Product-1">Binary Cartesian Product</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CartesianProduct" href="#LazySets.CartesianProduct"><code>LazySets.CartesianProduct</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CartesianProduct{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents a Cartesian product of two convex sets.</p><p><strong>Fields</strong></p><ul><li><code>X</code> – first convex set</li><li><code>Y</code> – second convex set</li></ul><p><strong>Notes</strong></p><p>The Cartesian product of three elements is obtained recursively. See also <code>CartesianProductArray</code> for an implementation of a Cartesian product of many sets without recursion, instead using an array.</p><p>The <code>EmptySet</code> is the absorbing element for <code>CartesianProduct</code>.</p><p>Constructors:</p><ul><li><p><code>CartesianProduct{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}}(X1::S1, X2::S2)</code> – default constructor</p></li><li><p><code>CartesianProduct(Xarr::Vector{S}) where {S&lt;:LazySet}</code> – constructor from an array of convex sets</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L8-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.:×-Tuple{LazySet,LazySet}" href="#LinearAlgebra.:×-Tuple{LazySet,LazySet}"><code>LinearAlgebra.:×</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">×</code></pre><p>Alias for the binary Cartesian product.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L68-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{LazySet,LazySet}" href="#Base.:*-Tuple{LazySet,LazySet}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">    *(X::LazySet, Y::LazySet)</code></pre><p>Alias for the binary Cartesian product.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L59-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{CartesianProduct}" href="#LazySets.dim-Tuple{CartesianProduct}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(cp::CartesianProduct)::Int</code></pre><p>Return the dimension of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Cartesian product.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L75-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, cp::CartesianProduct{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>The support function in the given direction. If the direction has norm zero, the result depends on the wrapped sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L112-L126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, cp::CartesianProduct{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L92-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{CartesianProduct}" href="#LazySets.isbounded-Tuple{CartesianProduct}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(cp::CartesianProduct)::Bool</code></pre><p>Determine whether a Cartesian product is bounded.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff both wrapped sets are bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L132-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, cp::CartesianProduct{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>x</code>  – point/vector</li><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ cp$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L149-L162">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{CartesianProduct}" href="#Base.isempty-Tuple{CartesianProduct}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(cp::CartesianProduct)::Bool</code></pre><p>Return if a Cartesian product is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the sub-blocks is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L171-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(cp::CartesianProduct{N}
                )::Vector{LinearConstraint{N}} where {N&lt;:Real}</code></pre><p>Return the list of constraints of a (polytopic) Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>A list of constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L188-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(cp::CartesianProduct{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a (polytopic) Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L207-L225">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../representations/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../representations/#LazySets.radius"><code>radius</code></a></li><li><a href="../representations/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h3><a class="nav-anchor" id="n-ary-Cartesian-Product-1" href="#n-ary-Cartesian-Product-1"><span>$n$</span>-ary Cartesian Product</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CartesianProductArray" href="#LazySets.CartesianProductArray"><code>LazySets.CartesianProductArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CartesianProductArray{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the Cartesian product of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><code>array</code> – array of sets</li></ul><p><strong>Notes</strong></p><p>The <code>EmptySet</code> is the absorbing element for <code>CartesianProductArray</code>.</p><p>Constructors:</p><ul><li><p><code>CartesianProductArray(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>CartesianProductArray([n]::Int=0, [N]::Type=Float64)</code> – constructor for an empty product with optional size hint and numeric type</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L247-L266">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{CartesianProductArray}" href="#LazySets.dim-Tuple{CartesianProductArray}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(cpa::CartesianProductArray)::Int</code></pre><p>Return the dimension of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Cartesian product of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L309-L322">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, cp::CartesianProductArray{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a Cartesian product array.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The support function in the given direction. If the direction has norm zero, the result depends on the wrapped sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L353-L367">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, cpa::CartesianProductArray{N}) where {N&lt;:Real}</code></pre><p>Support vector of a Cartesian product array.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the product sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L327-L341">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{CartesianProductArray}" href="#LazySets.isbounded-Tuple{CartesianProductArray}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(cpa::CartesianProductArray)::Bool</code></pre><p>Determine whether a Cartesian product of a finite number of convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff all wrapped sets are bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L379-L392">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, cpa::CartesianProductArray{N}
 )::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>x</code>   – point/vector</li><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ \text{cpa}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L397-L412">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{CartesianProductArray}" href="#Base.isempty-Tuple{CartesianProductArray}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(cpa::CartesianProductArray)::Bool</code></pre><p>Return if a Cartesian product is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the sub-blocks is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L428-L440">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(cpa::CartesianProductArray{N}
                )::Vector{LinearConstraint{N}} where {N&lt;:Real}</code></pre><p>Return the list of constraints of a (polytopic) Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A list of constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L445-L459">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(cpa::CartesianProductArray{N}
             )::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a (polytopic) Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L483-L503">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.array-Union{Tuple{CartesianProductArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real" href="#LazySets.array-Union{Tuple{CartesianProductArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">array(cpa::CartesianProductArray{N, S}
     )::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The array of a Cartesian product of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L290-L303">source</a><div><div><pre><code class="language-none">array(cha::ConvexHullArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p>The array of a convex hull of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L226-L238">source</a><div><div><pre><code class="language-none">array(ia::IntersectionArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of an intersection of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array of an intersection of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L647-L659">source</a><div><div><pre><code class="language-none">array(msa::MinkowskiSumArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Minkowski sum of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The array of a Minkowski sum of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L226-L238">source</a><div><div><pre><code class="language-none">array(cms::CacheMinkowskiSum{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The array of a caching Minkowski sum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L426-L438">source</a><div><div><pre><code class="language-julia">array(cup::UnionSetArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array that holds the union of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L252-L264">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../representations/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../representations/#LazySets.radius"><code>radius</code></a></li><li><a href="../representations/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h2><a class="nav-anchor" id="Convex-Hull-1" href="#Convex-Hull-1">Convex Hull</a></h2><h3><a class="nav-anchor" id="Binary-Convex-Hull-1" href="#Binary-Convex-Hull-1">Binary Convex Hull</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ConvexHull" href="#LazySets.ConvexHull"><code>LazySets.ConvexHull</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ConvexHull{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the convex hull of the union of two convex sets.</p><p><strong>Fields</strong></p><ul><li><code>X</code> – convex set</li><li><code>Y</code> – convex set</li></ul><p><strong>Notes</strong></p><p>The <code>EmptySet</code> is the neutral element for <code>ConvexHull</code>.</p><p><strong>Examples</strong></p><p>Convex hull of two 100-dimensional Euclidean balls:</p><pre><code class="language-julia-repl">julia&gt; b1, b2 = Ball2(zeros(100), 0.1), Ball2(4*ones(100), 0.2);

julia&gt; c = ConvexHull(b1, b2);

julia&gt; typeof(c)
ConvexHull{Float64,Ball2{Float64},Ball2{Float64}}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L10-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CH" href="#LazySets.CH"><code>LazySets.CH</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CH</code></pre><p>Alias for <code>ConvexHull</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L60-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{ConvexHull}" href="#LazySets.dim-Tuple{ConvexHull}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(ch::ConvexHull)::Int</code></pre><p>Return the dimension of a convex hull of two convex sets.</p><p><strong>Input</strong></p><ul><li><code>ch</code> – convex hull of two convex sets</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the convex hull of two convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L67-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHull{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHull{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, ch::ConvexHull{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a convex hull of two convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>ch</code> – convex hull of two convex sets</li></ul><p><strong>Output</strong></p><p>The support function of the convex hull in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L107-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHull{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHull{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, ch::ConvexHull{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a convex hull of two convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>ch</code> – convex hull of two convex sets</li></ul><p><strong>Output</strong></p><p>The support vector of the convex hull in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L84-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{ConvexHull}" href="#LazySets.isbounded-Tuple{ConvexHull}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(ch::ConvexHull)::Bool</code></pre><p>Determine whether a convex hull of two convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>ch</code> – convex hull of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff both wrapped sets are bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L126-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{ConvexHull}" href="#Base.isempty-Tuple{ConvexHull}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(ch::ConvexHull)::Bool</code></pre><p>Return if a convex hull of two convex sets is empty or not.</p><p><strong>Input</strong></p><ul><li><code>ch</code> – convex hull</li></ul><p><strong>Output</strong></p><p><code>true</code> iff both wrapped sets are empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L143-L155">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../representations/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../representations/#LazySets.radius"><code>radius</code></a></li><li><a href="../representations/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h3><a class="nav-anchor" id="n-ary-Convex-Hull-1" href="#n-ary-Convex-Hull-1"><span>$n$</span>-ary Convex Hull</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ConvexHullArray" href="#LazySets.ConvexHullArray"><code>LazySets.ConvexHullArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ConvexHullArray{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the symbolic convex hull of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><code>array</code> – array of sets</li></ul><p><strong>Notes</strong></p><p>The <code>EmptySet</code> is the neutral element for <code>ConvexHullArray</code>.</p><p>Constructors:</p><ul><li><p><code>ConvexHullArray(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>ConvexHullArray([n]::Int=0, [N]::Type=Float64)</code> – constructor for an empty hull with optional size hint and numeric type</p></li></ul><p><strong>Examples</strong></p><p>Convex hull of 100 two-dimensional balls whose centers follows a sinusoidal:</p><pre><code class="language-julia-repl">julia&gt; b = [Ball2([2*pi*i/100, sin(2*pi*i/100)], 0.05) for i in 1:100];

julia&gt; c = ConvexHullArray(b);</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L163-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CHArray" href="#LazySets.CHArray"><code>LazySets.CHArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CHArray</code></pre><p>Alias for <code>ConvexHullArray</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L219-L223">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{ConvexHullArray}" href="#LazySets.dim-Tuple{ConvexHullArray}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(cha::ConvexHullArray)::Int</code></pre><p>Return the dimension of the convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the convex hull of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L243-L255">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHullArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHullArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, cha::ConvexHullArray{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a convex hull array in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p>The support function of the convex hull array in the given direction.</p><p><strong>Algorithm</strong></p><p>This algorihm calculates the maximum over all <span>$ρ(d, X_i)$</span> where the <span>$X_1, …, X_k$</span> are the sets in the array <code>cha</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L286-L304">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHullArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHullArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, cha::ConvexHullArray{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a convex hull array in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cha</code> – convex hull array</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L261-L270">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{ConvexHullArray}" href="#LazySets.isbounded-Tuple{ConvexHullArray}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(cha::ConvexHullArray)::Bool</code></pre><p>Determine whether a convex hull of a finite number of convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff all wrapped sets are bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L309-L322">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.array-Union{Tuple{ConvexHullArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real" href="#LazySets.array-Union{Tuple{ConvexHullArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">array(cpa::CartesianProductArray{N, S}
     )::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The array of a Cartesian product of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L290-L303">source</a><div><div><pre><code class="language-none">array(cha::ConvexHullArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p>The array of a convex hull of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L226-L238">source</a><div><div><pre><code class="language-none">array(ia::IntersectionArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of an intersection of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array of an intersection of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L647-L659">source</a><div><div><pre><code class="language-none">array(msa::MinkowskiSumArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Minkowski sum of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The array of a Minkowski sum of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L226-L238">source</a><div><div><pre><code class="language-none">array(cms::CacheMinkowskiSum{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The array of a caching Minkowski sum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L426-L438">source</a><div><div><pre><code class="language-julia">array(cup::UnionSetArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array that holds the union of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L252-L264">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{ConvexHullArray}" href="#Base.isempty-Tuple{ConvexHullArray}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(cha::ConvexHullArray)::Bool</code></pre><p>Return if a convex hull array is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p><code>true</code> iff all wrapped sets are empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L327-L339">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../representations/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../representations/#LazySets.radius"><code>radius</code></a></li><li><a href="../representations/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h3><a class="nav-anchor" id="Convex-Hull-Algorithms-1" href="#Convex-Hull-Algorithms-1">Convex Hull Algorithms</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.convex_hull" href="#LazySets.convex_hull"><code>LazySets.convex_hull</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">convex_hull(P1::HPoly{N}, P2::HPoly{N};
           [backend]=default_polyhedra_backend(P1, N)) where {N}</code></pre><p>Compute the convex hull of the set union of two polyhedra in H-representation.</p><p><strong>Input</strong></p><ul><li><code>P1</code>         – polyhedron</li><li><code>P2</code>         – another polyhedron</li><li><code>backend</code>    – (optional, default: <code>default_polyhedra_backend(P1, N)</code>)                 the polyhedral computations backend</li></ul><p><strong>Output</strong></p><p>The <code>HPolyhedron</code> (resp. <code>HPolytope</code>) obtained by the concrete convex hull of <code>P1</code> and <code>P2</code>.</p><p><strong>Notes</strong></p><p>For performance reasons, it is suggested to use the <code>CDDLib.Library()</code> backend for the <code>convex_hull</code>.</p><p>For further information on the supported backends see <a href="https://juliapolyhedra.github.io/Polyhedra.jl/">Polyhedra&#39;s documentation</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/HPolyhedron.jl#L434-L459">source</a><div><div><pre><code class="language-julia">convex_hull(P::VPolygon{N}, Q::VPolygon{N};
            [algorithm]::String=&quot;monotone_chain&quot;)::VPolygon{N} where {N&lt;:Real}</code></pre><p>Return the convex hull of two polygons in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>         – polygon in vertex representation</li><li><code>Q</code>         – another polygon in vertex representation</li><li><code>algorithm</code> – (optional, default: &quot;monotone_chain&quot;) the algorithm used to                compute the convex hull</li></ul><p><strong>Output</strong></p><p>A new polygon such that its vertices are the convex hull of the given two polygons.</p><p><strong>Algorithm</strong></p><p>A convex hull algorithm is used to compute the convex hull of the vertices of the given input polygons <code>P</code> and <code>Q</code>; see <code>?convex_hull</code> for details on the available algorithms. The vertices of the output polygon are sorted in counter-clockwise fashion.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/VPolygon.jl#L503-L526">source</a><div><div><pre><code class="language-julia">convex_hull(P1::VPolytope{N}, P2::VPolytope{N};
            [backend]=default_polyhedra_backend(P1, N)) where {N}</code></pre><p>Compute the convex hull of the set union of two polytopes in V-representation.</p><p><strong>Input</strong></p><ul><li><code>P1</code>         – polytope</li><li><code>P2</code>         – another polytope</li><li><code>backend</code>    – (optional, default: <code>nothing</code>) the polyhedral                 computations backend</li></ul><p><strong>Output</strong></p><p>The <code>VPolytope</code> obtained by the concrete convex hull of <code>P1</code> and <code>P2</code>.</p><p><strong>Notes</strong></p><p>This function takes the union of the vertices of each polytope and then relies on a concrete convex hull algorithm. For low dimensions, a specialized implementation for polygons is used. For higher dimensions, <code>convex_hull</code> relies on the polyhedral computations backend that can be specified using the <code>backend</code> keyword argument.</p><p>For performance reasons, it is suggested to use the <code>CDDLib.Library()</code> backend for the <code>convex_hull</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/VPolytope.jl#L315-L341">source</a><div><div><pre><code class="language-none">convex_hull(points::Vector{VN};
            [algorithm]=default_convex_hull_algorithm(points),
            [backend]=nothing
            )::Vector{VN} where {N&lt;:Real, VN&lt;:AbstractVector{N}}</code></pre><p>Compute the convex hull of the given points.</p><p><strong>Input</strong></p><ul><li><code>points</code>    – list of vectors</li><li><code>algorithm</code> – (optional, default: depends on the dimension) the convex hull                algorithm, see valid options below</li><li><code>backend</code>   – (optional, default: <code>&quot;nothing&quot;</code>) polyhedral computation backend                for higher-dimensional point sets</li></ul><p><strong>Output</strong></p><p>The convex hull as a list of vectors with the coordinates of the points.</p><p><strong>Algorithm</strong></p><p>A pre-processing step treats the cases with <code>0</code>, <code>1</code> and <code>2</code> points in any dimension. For more than <code>3</code> points, the algorithm used depends on the dimension.</p><p>For the one-dimensional case we return the minimum and maximum points, in that order.</p><p>The two-dimensional case is handled with a planar convex hull algorithm. The following algorithms are available:</p><ul><li><code>&quot;monotone_chain&quot;</code>        – compute the convex hull of points in the plane                              using Andrew&#39;s monotone chain method</li><li><code>&quot;monotone_chain_sorted&quot;</code> – the same as <code>&quot;monotone_chain&quot;</code> but assuming that                              the points are already sorted in counter-clockwise                              fashion</li></ul><p>See the reference docstring of each of those algorithms for details.</p><p>The higher dimensional case is treated using the concrete polyhedra library <code>Polyhedra</code>, that gives access to libraries such as <code>CDDLib</code> and <code>ConvexHull.jl</code>. These libraries can be chosen from the <code>backend</code> argument.</p><p><strong>Notes</strong></p><p>For the in-place version use <code>convex_hull!</code> instead of <code>convex_hull</code>.</p><p><strong>Examples</strong></p><p>Compute the convex hull of a random set of points:</p><pre><code class="language-julia-repl">julia&gt; points = [randn(2) for i in 1:30]; # 30 random points in 2D

julia&gt; hull = convex_hull(points);

julia&gt; typeof(hull)
Array{Array{Float64,1},1}</code></pre><p>Plot both the random points and the computed convex hull polygon:</p><pre><code class="language-julia-repl">julia&gt; using Plots;

julia&gt; plot([Tuple(pi) for pi in points], seriestype=:scatter);

julia&gt; plot!(VPolygon(hull), alpha=0.2);</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/concrete_convex_hull.jl#L9-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.right_turn" href="#LazySets.right_turn"><code>LazySets.right_turn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">right_turn(O::AbstractVector{N}, A::AbstractVector{N}, B::AbstractVector{N}
          )::N where {N&lt;:Real}</code></pre><p>Determine if the acute angle defined by the three points <code>O</code>, <code>A</code>, <code>B</code> in the plane is a right turn (counter-clockwise) with respect to the center <code>O</code>.</p><p><strong>Input</strong></p><ul><li><code>O</code> – 2D center point</li><li><code>A</code> – 2D one point</li><li><code>B</code> – 2D another point</li></ul><p><strong>Output</strong></p><p>Scalar representing the rotation.</p><p><strong>Algorithm</strong></p><p>The <a href="https://en.wikipedia.org/wiki/Cross_product">cross product</a> is used to determine the sense of rotation. If the result is 0, the points are collinear; if it is positive, the three points constitute a positive angle of rotation around <code>O</code> from <code>A</code> to <code>B</code>; otherwise they constitute a negative angle.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/concrete_convex_hull.jl#L169-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.monotone_chain!" href="#LazySets.monotone_chain!"><code>LazySets.monotone_chain!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">monotone_chain!(points::Vector{VN}; sort::Bool=true
               )::Vector{VN} where {N&lt;:Real, VN&lt;:AbstractVector{N}}</code></pre><p>Compute the convex hull of points in the plane using Andrew&#39;s monotone chain method.</p><p><strong>Input</strong></p><ul><li><code>points</code> – list of 2D vectors; is sorted in-place inside this function</li><li><code>sort</code>   – (optional, default: <code>true</code>) flag for sorting the vertices             lexicographically; sortedness is required for correctness</li></ul><p><strong>Output</strong></p><p>List of vectors containing the 2D coordinates of the corner points of the convex hull.</p><p><strong>Notes</strong></p><p>For large sets of points, it is convenient to use static vectors to get maximum performance. For information on how to convert usual vectors into static vectors, see the type <code>SVector</code> provided by the <a href="http://juliaarrays.github.io/StaticArrays.jl/stable/">StaticArrays</a> package.</p><p><strong>Algorithm</strong></p><p>This function implements Andrew&#39;s monotone chain convex hull algorithm to construct the convex hull of a set of <span>$n$</span> points in the plane in <span>$O(n \log n)$</span> time. For further details see <a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain">Monotone chain</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/concrete_convex_hull.jl#L199-L232">source</a></section><h2><a class="nav-anchor" id="Intersection-1" href="#Intersection-1">Intersection</a></h2><h3><a class="nav-anchor" id="Binary-Intersection-1" href="#Binary-Intersection-1">Binary Intersection</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Intersection" href="#LazySets.Intersection"><code>LazySets.Intersection</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Intersection{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the intersection of two convex sets.</p><p><strong>Fields</strong></p><ul><li><code>X</code>     – convex set</li><li><code>Y</code>     – convex set</li><li><code>cache</code> – internal cache for avoiding recomputation; see            <a href="#LazySets.IntersectionCache"><code>IntersectionCache</code></a></li></ul><p><strong>Examples</strong></p><p>Create an expression, <span>$Z$</span>, which lazily represents the intersection of two squares <span>$X$</span> and <span>$Y$</span>:</p><pre><code class="language-julia-repl">julia&gt; X, Y = BallInf([0,0.], 0.5), BallInf([1,0.], 0.65);

julia&gt; Z = X ∩ Y;

julia&gt; typeof(Z)
Intersection{Float64,BallInf{Float64},BallInf{Float64}}

julia&gt; dim(Z)
2</code></pre><p>We can check if the intersection is empty with <code>isempty</code>:</p><pre><code class="language-julia-repl">julia&gt; isempty(Z)
false</code></pre><p>Do not confuse <code>Intersection</code> with the concrete operation, which is computed with the lowercase <code>intersection</code> function:</p><pre><code class="language-julia-repl">julia&gt; W = intersection(X, Y)
Hyperrectangle{Float64}([0.425, 0.0], [0.075, 0.5])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L48-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∩-Tuple{LazySet,LazySet}" href="#Base.:∩-Tuple{LazySet,LazySet}"><code>Base.:∩</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∩</code></pre><p>Alias for <code>Intersection</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L119-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{Intersection}" href="#LazySets.dim-Tuple{Intersection}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(cap::Intersection)::Int</code></pre><p>Return the dimension of an intersection of two convex sets.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the intersection of two convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L190-L202">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, cap::Intersection{N}) where {N&lt;:Real}</code></pre><p>Return an upper bound on the support function of the intersection of two convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>    – direction</li><li><code>cap</code>  – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p>An uper bound on the support function in the given direction.</p><p><strong>Algorithm</strong></p><p>The support function of an intersection of <span>$X$</span> and <span>$Y$</span> is upper bounded by the minimum of the support functions of <span>$X$</span> and <span>$Y$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L226-L245">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2}}} where S2&lt;:Union{HalfSpace{N}, Hyperplane{N}, Line{N,VN} where VN&lt;:AbstractArray{N,1}} where S1&lt;:LazySet{N} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2}}} where S2&lt;:Union{HalfSpace{N}, Hyperplane{N}, Line{N,VN} where VN&lt;:AbstractArray{N,1}} where S1&lt;:LazySet{N} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N},
  cap::Intersection{N, S1, S2};
  [algorithm]::String=&quot;line_search&quot;,
  [kwargs...]) where {N&lt;:Real,
                      S1&lt;:LazySet{N},
                      S2&lt;:Union{HalfSpace{N}, Hyperplane{N}, Line{N}}}</code></pre><p>Return the support function of the intersection of a compact set and a half-space/hyperplane/line in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>         – direction</p></li><li><p><code>cap</code>       – lazy intersection of a compact set and a half-space/hyperplane/                line</p></li><li><p><code>algorithm</code> – (optional, default: <code>&quot;line_search&quot;</code>): the algorithm to                calculate the support function; valid options are:</p><ul><li><code>&quot;line_search&quot;</code> – solve the associated univariate optimization problem                    using a line search method (either Brent or the                    Golden Section method)</li><li><code>&quot;projection&quot;</code>  – only valid for intersection with a hyperplane;                    evaluates the support function by reducing the problem                    to the 2D intersection of a rank 2 linear                    transformation of the given compact set in the plane                    generated by the given direction <code>d</code> and the                    hyperplane&#39;s normal vector <code>n</code></li><li><code>&quot;simple&quot;</code>      – take the <span>$\min$</span> of the support function evaluation                    of each operand</li></ul></li></ul><p><strong>Output</strong></p><p>The scalar value of the support function of the set <code>cap</code> in the given direction.</p><p><strong>Notes</strong></p><p>It is assumed that the set <code>cap.X</code> is compact.</p><p>Any additional number of arguments to the algorithm backend can be passed as keyword arguments.</p><p><strong>Algorithm</strong></p><p>The algorithms are based on solving the associated optimization problem</p><div>\[\min_\{ λ ∈ D_h \} ρ(ℓ - λa, X) + λb.\]</div><p>where <span>$D_h = \{ λ : λ ≥ 0 \}$</span> if <span>$H$</span> is a half-space or <span>$D_h = \{ λ : λ ∈ \mathbb{R} \}$</span> if <span>$H$</span> is a hyperplane.</p><p>For additional information we refer to:</p><ul><li><a href="https://www.sciencedirect.com/science/article/pii/S1474667015371809">G. Frehse, R. Ray. Flowpipe-Guard Intersection for Reachability Computations with Support Functions</a>.</li><li><a href="https://tel.archives-ouvertes.fr/tel-00422569v2">C. Le Guernic. Reachability Analysis of Hybrid Systems with Linear Continuous Dynamics, PhD thesis</a>.</li><li><a href="https://www.springer.com/us/book/9783540627722">T. Rockafellar, R. Wets. Variational Analysis</a>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L309-L370">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2}}} where S2&lt;:AbstractPolytope{N} where S1&lt;:LazySet{N} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2}}} where S2&lt;:AbstractPolytope{N} where S1&lt;:LazySet{N} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N},
  cap::Intersection{N, S1, S2};
  kwargs...) where {N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:AbstractPolytope{N}}</code></pre><p>Return an upper bound of the intersection between a compact set and a polytope along a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>      – direction</li><li><code>cap</code>    – intersection of a compact set and a polytope</li><li><code>kwargs</code> – additional arguments that are passed to the support function algorithm</li></ul><p><strong>Output</strong></p><p>An upper bound of the support function of the given intersection.</p><p><strong>Algorithm</strong></p><p>The idea is to solve the univariate optimization problem <code>ρ(di, X ∩ Hi)</code> for each half-space in the set <code>P</code> and then take the minimum. This gives an overapproximation of the exact support function.</p><p>This algorithm is inspired from <a href="https://www.sciencedirect.com/science/article/pii/S1474667015371809">G. Frehse, R. Ray. Flowpipe-Guard Intersection for Reachability Computations with Support Functions</a>.</p><p><strong>Notes</strong></p><p>This method relies on having available the <code>constraints_list</code> of the polytope <code>P</code>.</p><p>This method of overapproximation can return a non-empty set even if the original intersection is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L390-L425">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, cap::Intersection{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of an intersection of two convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cap</code> – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L207-L221">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{Intersection}" href="#LazySets.isbounded-Tuple{Intersection}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(cap::Intersection)::Bool</code></pre><p>Determine whether an intersection of two convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the intersection is bounded.</p><p><strong>Algorithm</strong></p><p>We first check if any of the wrapped sets is bounded. Otherwise, we check boundedness via <a href="../interfaces/#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>isbounded_unit_dimensions</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L483-L500">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{Intersection}" href="#Base.isempty-Tuple{Intersection}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(cap::Intersection)::Bool</code></pre><p>Return if the intersection is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the intersection is empty.</p><p><strong>Notes</strong></p><p>The result will be cached, so a second query will be fast.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L563-L579">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, cap::Intersection{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in an intersection of two convex sets.</p><p><strong>Input</strong></p><ul><li><code>x</code>   – point/vector</li><li><code>cap</code> – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ cap$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L508-L521">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(cap::Intersection{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of an intersection of two (polyhedral) sets.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two (polyhedral) sets</li></ul><p><strong>Output</strong></p><p>The list of constraints of the intersection.</p><p><strong>Notes</strong></p><p>We assume that the underlying sets are polyhedral, i.e., offer a method <code>constraints_list</code>.</p><p><strong>Algorithm</strong></p><p>We create the polyhedron by taking the intersection of the <code>constraints_list</code>s of the sets and remove redundant constraints.</p><p>This function ignores the boolean output from the in-place <code>remove_redundant_constraints!</code>, which may inform the user that the constraints are infeasible. In that case, the list of constraints at the moment when the infeasibility was detected is returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L526-L552">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isempty_known-Tuple{Intersection}" href="#LazySets.isempty_known-Tuple{Intersection}"><code>LazySets.isempty_known</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty_known(cap::Intersection)</code></pre><p>Ask whether the status of emptiness is known.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the emptiness status is known. In this case, <code>isempty(cap)</code> can be used to obtain the status.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L130-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.set_isempty!-Tuple{Intersection,Bool}" href="#LazySets.set_isempty!-Tuple{Intersection,Bool}"><code>LazySets.set_isempty!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">set_isempty!(cap::Intersection, isempty::Bool)</code></pre><p>Set the status of emptiness in the cache.</p><p><strong>Input</strong></p><ul><li><code>cap</code>     – intersection of two convex sets</li><li><code>isempty</code> – new status of emptiness</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L148-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.swap-Tuple{Intersection}" href="#LazySets.swap-Tuple{Intersection}"><code>LazySets.swap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">swap(cap::Intersection{N, S1, S2})::Intersection{N} where {N&lt;:Real, S1, S2}</code></pre><p>Return a new <code>Intersection</code> object with the arguments swapped.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p>A new <code>Intersection</code> object with the arguments swapped. The old cache is shared between the old and new objects.</p><p><strong>Notes</strong></p><p>The advantage of using this function instead of manually swapping the arguments is that the cache is shared.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L162-L180">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.use_precise_ρ" href="#LazySets.use_precise_ρ"><code>LazySets.use_precise_ρ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">use_precise_ρ(cap::Intersection{N})::Bool where {N&lt;:Real}</code></pre><p>Determine whether a precise algorithm for computing <span>$ρ$</span> shall be applied.</p><p><strong>Input</strong></p><ul><li><code>cap</code> – intersection of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> if a precise algorithm shall be applied.</p><p><strong>Notes</strong></p><p>The default implementation always returns <code>true</code>.</p><p>If the result is <code>false</code>, a coarse approximation of the support function is returned.</p><p>This function can be overwritten by the user to control the policy.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L283-L304">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets._line_search" href="#LazySets._line_search"><code>LazySets._line_search</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">_line_search(ℓ, X, H; [kwargs...])</code></pre><p>Given a compact and convex set <span>$X$</span> and a halfspace <span>$H = \{x: a^T x ≤ b \}$</span> or a hyperplane <span>$H = \{x: a^T x = b \}$</span>, calculate:</p><div>\[\min_\{ λ ∈ D_h \} ρ(ℓ - λa, X) + λb.\]</div><p>where <span>$D_h = \{ λ : λ ≥ 0 \}$</span> if <span>$H$</span> is a half-space or <span>$D_h = \{ λ : λ ∈ \mathbb{R} \}$</span> if <span>$H$</span> is a hyperplane.</p><p><strong>Input</strong></p><ul><li><code>ℓ</code>           – direction</li><li><code>X</code>           – set</li><li><code>H</code>           – halfspace or hyperplane</li></ul><p><strong>Output</strong></p><p>The tuple <code>(fmin, λmin)</code>, where <code>fmin</code> is the minimum value of the function <span>$f(λ) = ρ(ℓ - λa) + λb$</span> over the feasible set <span>$λ ≥ 0$</span>, and <span>$λmin$</span> is the minimizer.</p><p><strong>Notes</strong></p><p>This function requires the <code>Optim</code> package, and relies on the univariate optimization interface <code>Optim.optimize(...)</code>.</p><p>Additional arguments to the <code>optimize</code> backend can be passed as keyword arguments. The default method is <code>Optim.Brent()</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X = Ball1(zeros(2), 1.0);

julia&gt; H = HalfSpace([-1.0, 0.0], -1.0); # x &gt;= 0 

julia&gt; using Optim

julia&gt; using LazySets: _line_search

julia&gt; _line_search([1.0, 0.0], X, H) # uses Brent&#39;s method by default
(1.0, 999999.9849478417)</code></pre><p>We can specify the upper bound in Brent&#39;s method:</p><pre><code class="language-julia">julia&gt; _line_search([1.0, 0.0], X, H, upper=1e3)
(1.0, 999.9999849478418)</code></pre><p>Instead of using Brent, we use the Golden Section method:</p><pre><code class="language-julia">julia&gt; _line_search([1.0, 0.0], X, H, upper=1e3, method=GoldenSection())
(1.0, 381.9660112501051)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L823-L883">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets._projection" href="#LazySets._projection"><code>LazySets._projection</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">_projection(ℓ, X, H::Union{Hyperplane{N}, Line{N}};
            [lazy_linear_map]=false,
            [lazy_2d_intersection]=true,
            [algorithm_2d_intersection]=nothing,
            [kwargs...]) where {N}</code></pre><p>Given a compact and convex set <span>$X$</span> and a hyperplane <span>$H = \{x: n ⋅ x = γ \}$</span>, calculate the support function of the intersection between the rank-2 projection <span>$Π_{nℓ} X$</span> and the line <span>$Lγ = \{(x, y): x = γ \}$</span>.</p><p><strong>Input</strong></p><ul><li><code>ℓ</code>                    – direction</li><li><code>X</code>                    – set</li><li><code>H</code>                    – hyperplane</li><li><code>lazy_linear_map</code>      – (optional, default: <code>false</code>) to perform the projection                           lazily or concretely</li><li><code>lazy_2d_intersection</code> – (optional, default: <code>true</code>) to perform the 2D                           intersection between the projected set and the line                           lazily or concretely</li><li><code>algorithm_2d_intersection</code> – (optional, default: <code>nothing</code>) if given, fixes the                                support function algorithm used for the intersection                                in 2D; otherwise the default is implied</li></ul><p><strong>Output</strong></p><p>The support function of <span>$X ∩ H$</span> along direction <span>$ℓ$</span>.</p><p><strong>Algorithm</strong></p><p>This projection method is based on Prop. 8.2, page 103, <a href="https://tel.archives-ouvertes.fr/tel-00422569v2">C. Le Guernic. Reachability Analysis of Hybrid Systems with Linear Continuous Dynamics, PhD thesis</a>.</p><p>In the original algorithm, Section 8.2 of Le Guernic&#39;s thesis, the linear map is performed concretely and the intersection is performed lazily (these are the default options in this algorithm, but here the four combinations are available). If the set <span>$X$</span> is a zonotope, its concrete projection is again a zonotope (sometimes called &quot;zonogon&quot;). The intersection between this zonogon and the line can be taken efficiently in a lazy way (see Section 8.2.2 of Le Guernic&#39;s thesis), if one uses dispatch on <code>ρ(y_dir, Sℓ⋂Lγ; kwargs...)</code> given that <code>Sℓ</code> is itself a zonotope.</p><p><strong>Notes</strong></p><p>This function depends itself on the calculation of the support function of another set in two dimensions. Obviously one doesn&#39;t want to use again <code>algorithm=&quot;projection&quot;</code> for this second calculation. The option <code>algorithm_2d_intersection</code> is such that, if it is not given, the default support function algorithm is used (e.g. <code>&quot;line_search&quot;</code>). You can still pass additional arguments to the <code>&quot;line_search&quot;</code> backend through the <code>kwargs</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L923-L975">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, cap::Intersection{N}) where {N}</code></pre><p>Return the concrete linear map of a lazy intersection.</p><p><strong>Input</strong></p><ul><li><code>M</code>   – matrix</li><li><code>cap</code> – lazy intersection</li></ul><p><strong>Output</strong></p><p>The set obtained by applying the given linear map to the lazy intersection.</p><p><strong>Notes</strong></p><p>This function relies on computing <code>cap</code> concretely (i.e. as a set representation), and then applying the linear map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L793-L811">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{Dict{Symbol,Any},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{Dict{Symbol,Any},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},N}} where N&lt;:Real" href="#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{Dict{Symbol,Any},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{Dict{Symbol,Any},Intersection{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N},N}} where N&lt;:Real"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_intersection(X::Intersection{N}, [ε]::N=-one(N); Nφ=40,
                  color=:auto, alpha=0.5) where {N&lt;:Real}</code></pre><p>Plot a lazy intersection.</p><p><strong>Input</strong></p><ul><li><code>X</code>  – lazy intersection</li><li><code>ε</code>  – (optional, default -1) ignored, used only for dispatch</li><li><code>Nφ</code> – (optional, default: <code>40</code>) number of template directions used in the         template overapproximation</li></ul><p><strong>Output</strong></p><p>A plot with the overapproximation of the given lazy intersection.</p><p><strong>Notes</strong></p><p>This function is separated from the main <code>LazySet</code> plot recipe because the iterative refinement is not available for lazy intersections, since it uses the support vector (but see #1187).</p><p>Also note that if the set is a <em>nested</em> intersection, e.g., the lazy linear map, you may have to manually overapproximate this set before plotting (see <code>LazySets.Approximations.overapproximate</code> for details).</p><pre><code class="language-julia">julia&gt; using Polyhedra, LazySets.Approximations

julia&gt; X = rand(Ball2) ∩ rand(Ball2); # lazy intersection

julia&gt; plot(X)</code></pre><p>One can specify the accuracy of the overapproximation of the lazy intersection passing a higher value in <code>Nφ</code>, which stands for the number of polar directions chosen.</p><pre><code class="language-julia">julia&gt; Nφ = 100; # or a bigger number

julia&gt; Po = overapproximate(X, PolarDirections(Nφ));

julia&gt; P = convert(HPolytope, Po) # see issue #1306

julia&gt; plot(P)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/plot_recipes.jl#L649-L696">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../representations/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../representations/#LazySets.radius"><code>radius</code></a></li><li><a href="../representations/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h4><a class="nav-anchor" id="Intersection-cache-1" href="#Intersection-cache-1">Intersection cache</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.IntersectionCache" href="#LazySets.IntersectionCache"><code>LazySets.IntersectionCache</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IntersectionCache</code></pre><p>Container for information cached by a lazy <code>Intersection</code> object.</p><p><strong>Fields</strong></p><ul><li><p><code>isempty</code> – is the intersection empty? There are three possible states,              encoded as <code>Int8</code> values -1, 0, 1:</p><ul><li><span>$-1$</span> - it is currently unknown whether the intersection is empty or not</li><li><span>$0$</span> - intersection is not empty</li><li><span>$1$</span> - intersection is empty</li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L13-L26">source</a></section><h3><a class="nav-anchor" id="n-ary-Intersection-1" href="#n-ary-Intersection-1"><span>$n$</span>-ary Intersection</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.IntersectionArray" href="#LazySets.IntersectionArray"><code>LazySets.IntersectionArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IntersectionArray{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the intersection of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><code>array</code> – array of convex sets</li></ul><p><strong>Notes</strong></p><p>This type assumes that the dimensions of all elements match.</p><p>The <code>EmptySet</code> is the absorbing element for <code>IntersectionArray</code>.</p><p>Constructors:</p><ul><li><p><code>IntersectionArray(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>IntersectionArray([n]::Int=0, [N]::Type=Float64)</code> – constructor for an empty sum with optional size hint and numeric type</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L599-L620">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{IntersectionArray}" href="#LazySets.dim-Tuple{IntersectionArray}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(ia::IntersectionArray)::Int</code></pre><p>Return the dimension of an intersection of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the intersection of a finite number of sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L668-L680">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},IntersectionArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},IntersectionArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, ia::IntersectionArray{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the support vector of an intersection of a finite number of sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the individual sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L685-L700">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{IntersectionArray}" href="#LazySets.isbounded-Tuple{IntersectionArray}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(ia::IntersectionArray)::Bool</code></pre><p>Determine whether an intersection of a finite number of convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the intersection is bounded.</p><p><strong>Algorithm</strong></p><p>We first check if any of the wrapped sets is bounded. Otherwise, we check boundedness via <a href="../interfaces/#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>isbounded_unit_dimensions</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L707-L724">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},IntersectionArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},IntersectionArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, ia::IntersectionArray{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in an intersection of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>x</code>  – point/vector</li><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ ia$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L732-L746">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.array-Union{Tuple{IntersectionArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real" href="#LazySets.array-Union{Tuple{IntersectionArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">array(cpa::CartesianProductArray{N, S}
     )::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The array of a Cartesian product of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L290-L303">source</a><div><div><pre><code class="language-none">array(cha::ConvexHullArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p>The array of a convex hull of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L226-L238">source</a><div><div><pre><code class="language-none">array(ia::IntersectionArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of an intersection of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array of an intersection of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L647-L659">source</a><div><div><pre><code class="language-none">array(msa::MinkowskiSumArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Minkowski sum of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The array of a Minkowski sum of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L226-L238">source</a><div><div><pre><code class="language-none">array(cms::CacheMinkowskiSum{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The array of a caching Minkowski sum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L426-L438">source</a><div><div><pre><code class="language-julia">array(cup::UnionSetArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array that holds the union of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L252-L264">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{IntersectionArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{IntersectionArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(ia::IntersectionArray{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of an intersection of a finite number of (polyhedral) sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of (polyhedral) sets</li></ul><p><strong>Output</strong></p><p>The list of constraints of the intersection.</p><p><strong>Notes</strong></p><p>We assume that the underlying sets are polyhedral, i.e., offer a method <code>constraints_list</code>.</p><p><strong>Algorithm</strong></p><p>We create the polyhedron from the <code>constraints_list</code>s of the sets and remove redundant constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L756-L779">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../representations/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../representations/#LazySets.radius"><code>radius</code></a></li><li><a href="../representations/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h2><a class="nav-anchor" id="Minkowski-Sum-1" href="#Minkowski-Sum-1">Minkowski Sum</a></h2><h3><a class="nav-anchor" id="Binary-Minkowski-Sum-1" href="#Binary-Minkowski-Sum-1">Binary Minkowski Sum</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.MinkowskiSum" href="#LazySets.MinkowskiSum"><code>LazySets.MinkowskiSum</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MinkowskiSum{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the Minkowski sum of two convex sets.</p><p><strong>Fields</strong></p><ul><li><code>X</code> – first convex set</li><li><code>Y</code> – second convex set</li></ul><p><strong>Notes</strong></p><p>The <code>ZeroSet</code> is the neutral element and the <code>EmptySet</code> is the absorbing element for <code>MinkowskiSum</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L10-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.:⊕-Tuple{LazySet,LazySet}" href="#LazySets.:⊕-Tuple{LazySet,LazySet}"><code>LazySets.:⊕</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">⊕(X::LazySet, Y::LazySet)</code></pre><p>Unicode alias constructor ⊕ (<code>oplus</code>) for the lazy Minkowski sum operator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L65-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{LazySet,LazySet}" href="#Base.:+-Tuple{LazySet,LazySet}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">X + Y</code></pre><p>Convenience constructor for Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>X</code> – a convex set</li><li><code>Y</code> – another convex set</li></ul><p><strong>Output</strong></p><p>The symbolic Minkowski sum of <span>$X$</span> and <span>$Y$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L49-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{MinkowskiSum}" href="#LazySets.dim-Tuple{MinkowskiSum}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(ms::MinkowskiSum)::Int</code></pre><p>Return the dimension of a Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>ms</code> – Minkowski sum</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Minkowski sum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L72-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSum{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSum{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, ms::MinkowskiSum{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>ms</code> – Minkowski sum</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p><p><strong>Algorithm</strong></p><p>The support function in direction <span>$d$</span> of the Minkowski sum of two sets <span>$X$</span> and <span>$Y$</span> is the sum of the support functions of <span>$X$</span> and <span>$Y$</span> in direction <span>$d$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L114-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSum{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSum{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, ms::MinkowskiSum{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>ms</code> – Minkowski sum</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.</p><p><strong>Algorithm</strong></p><p>The support vector in direction <span>$d$</span> of the Minkowski sum of two sets <span>$X$</span> and <span>$Y$</span> is the sum of the support vectors of <span>$X$</span> and <span>$Y$</span> in direction <span>$d$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L89-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{MinkowskiSum}" href="#LazySets.isbounded-Tuple{MinkowskiSum}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(ms::MinkowskiSum)::Bool</code></pre><p>Determine whether a Minkowski sum is bounded.</p><p><strong>Input</strong></p><ul><li><code>ms</code> – Minkowski sum</li></ul><p><strong>Output</strong></p><p><code>true</code> iff both wrapped sets are bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L138-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{MinkowskiSum}" href="#Base.isempty-Tuple{MinkowskiSum}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(ms::MinkowskiSum)::Bool</code></pre><p>Return if a Minkowski sum is empty or not.</p><p><strong>Input</strong></p><ul><li><code>ms</code> – Minkowski sum</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the wrapped sets are empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L155-L167">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../representations/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../representations/#LazySets.radius"><code>radius</code></a></li><li><a href="../representations/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h3><a class="nav-anchor" id="n-ary-Minkowski-Sum-1" href="#n-ary-Minkowski-Sum-1"><span>$n$</span>-ary Minkowski Sum</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.MinkowskiSumArray" href="#LazySets.MinkowskiSumArray"><code>LazySets.MinkowskiSumArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MinkowskiSumArray{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the Minkowski sum of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><code>array</code> – array of convex sets</li></ul><p><strong>Notes</strong></p><p>This type assumes that the dimensions of all elements match.</p><p>The <code>ZeroSet</code> is the neutral element and the <code>EmptySet</code> is the absorbing element for <code>MinkowskiSumArray</code>.</p><p>Constructors:</p><ul><li><p><code>MinkowskiSumArray(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>MinkowskiSumArray([n]::Int=0, [N]::Type=Float64)</code> – constructor for an empty sum with optional size hint and numeric type</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L176-L198">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{MinkowskiSumArray}" href="#LazySets.dim-Tuple{MinkowskiSumArray}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(msa::MinkowskiSumArray)::Int</code></pre><p>Return the dimension of a Minkowski sum of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Minkowski sum of a finite number of sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L243-L255">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSumArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSumArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, msa::MinkowskiSumArray{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a Minkowski sum array of a finite number of sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p><p><strong>Algorithm</strong></p><p>The support function of the Minkowski sum of sets is the sum of the support functions of each set. </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L280-L299">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSumArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSumArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, msa::MinkowskiSumArray{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a Minkowski sum of a finite number of sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L260-L275">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{MinkowskiSumArray}" href="#LazySets.isbounded-Tuple{MinkowskiSumArray}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(msa::MinkowskiSumArray)::Bool</code></pre><p>Determine whether a Minkowski sum of a finite number of convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff all wrapped sets are bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L304-L316">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{MinkowskiSumArray}" href="#Base.isempty-Tuple{MinkowskiSumArray}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(msa::MinkowskiSumArray)::Bool</code></pre><p>Return if a Minkowski sum array is empty or not.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the wrapped sets are empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L321-L333">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.array-Union{Tuple{MinkowskiSumArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real" href="#LazySets.array-Union{Tuple{MinkowskiSumArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">array(cpa::CartesianProductArray{N, S}
     )::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The array of a Cartesian product of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L290-L303">source</a><div><div><pre><code class="language-none">array(cha::ConvexHullArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p>The array of a convex hull of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L226-L238">source</a><div><div><pre><code class="language-none">array(ia::IntersectionArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of an intersection of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array of an intersection of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L647-L659">source</a><div><div><pre><code class="language-none">array(msa::MinkowskiSumArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Minkowski sum of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The array of a Minkowski sum of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L226-L238">source</a><div><div><pre><code class="language-none">array(cms::CacheMinkowskiSum{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The array of a caching Minkowski sum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L426-L438">source</a><div><div><pre><code class="language-julia">array(cup::UnionSetArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array that holds the union of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L252-L264">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../representations/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../representations/#LazySets.radius"><code>radius</code></a></li><li><a href="../representations/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h3><a class="nav-anchor" id="n-ary-Minkowski-Sum-with-cache-1" href="#n-ary-Minkowski-Sum-with-cache-1"><span>$n$</span>-ary Minkowski Sum with cache</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CacheMinkowskiSum" href="#LazySets.CacheMinkowskiSum"><code>LazySets.CacheMinkowskiSum</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CacheMinkowskiSum{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the Minkowski sum of a finite number of convex sets. Support vector queries are cached.</p><p><strong>Fields</strong></p><ul><li><code>array</code> – array of convex sets</li><li><code>cache</code> – cache of support vector query results</li></ul><p><strong>Notes</strong></p><p>This type assumes that the dimensions of all elements match.</p><p>The <code>ZeroSet</code> is the neutral element and the <code>EmptySet</code> is the absorbing element for <code>CacheMinkowskiSum</code>.</p><p>The cache (field <code>cache</code>) is implemented as dictionary whose keys are directions and whose values are pairs <code>(k, s)</code> where <code>k</code> is the number of elements in the array <code>array</code> when the support vector was evaluated last time, and <code>s</code> is the support vector that was obtained. Thus this type assumes that <code>array</code> is not modified except by adding new sets at the end.</p><p>Constructors:</p><ul><li><p><code>CacheMinkowskiSum(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>CacheMinkowskiSum([n]::Int=0, [N]::Type=Float64)</code> – constructor for an empty sum with optional size hint and numeric type</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L367-L398">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{CacheMinkowskiSum}" href="#LazySets.dim-Tuple{CacheMinkowskiSum}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(cms::CacheMinkowskiSum)::Int</code></pre><p>Return the dimension of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the caching Minkowski sum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L444-L456">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CacheMinkowskiSum{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CacheMinkowskiSum{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, cms::CacheMinkowskiSum{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a caching Minkowski sum in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.</p><p><strong>Notes</strong></p><p>The result is cached, i.e., any further query with the same direction runs in constant time. When sets are added to the caching Minkowski sum, the query is only performed for the new sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L461-L482">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{CacheMinkowskiSum}" href="#LazySets.isbounded-Tuple{CacheMinkowskiSum}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(cms::CacheMinkowskiSum)::Bool</code></pre><p>Determine whether a caching Minkowski sum is bounded.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p><code>true</code> iff all wrapped sets are bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L508-L520">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{CacheMinkowskiSum}" href="#Base.isempty-Tuple{CacheMinkowskiSum}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(cms::CacheMinkowskiSum)::Bool</code></pre><p>Return if a caching Minkowski sum array is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the wrapped sets are empty.</p><p><strong>Notes</strong></p><p>Forgotten sets cannot be checked anymore. Usually they have been empty because otherwise the support vector query should have crashed before. In that case, the caching Minkowski sum should not be used further.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L525-L544">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.array-Union{Tuple{CacheMinkowskiSum{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real" href="#LazySets.array-Union{Tuple{CacheMinkowskiSum{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">array(cpa::CartesianProductArray{N, S}
     )::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The array of a Cartesian product of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/CartesianProduct.jl#L290-L303">source</a><div><div><pre><code class="language-none">array(cha::ConvexHullArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p>The array of a convex hull of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ConvexHull.jl#L226-L238">source</a><div><div><pre><code class="language-none">array(ia::IntersectionArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of an intersection of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array of an intersection of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Intersection.jl#L647-L659">source</a><div><div><pre><code class="language-none">array(msa::MinkowskiSumArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Minkowski sum of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The array of a Minkowski sum of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L226-L238">source</a><div><div><pre><code class="language-none">array(cms::CacheMinkowskiSum{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The array of a caching Minkowski sum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L426-L438">source</a><div><div><pre><code class="language-julia">array(cup::UnionSetArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array that holds the union of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L252-L264">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.forget_sets!-Tuple{CacheMinkowskiSum}" href="#LazySets.forget_sets!-Tuple{CacheMinkowskiSum}"><code>LazySets.forget_sets!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">forget_sets!(cms::CacheMinkowskiSum)::Int</code></pre><p>Tell a caching Minkowski sum to forget the stored sets (but not the support vectors). Only those sets are forgotten such that for each cached direction the support vector has been computed before.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The number of sets that have been forgotten.</p><p><strong>Notes</strong></p><p>This function should only be used under the assertion that no new directions are queried in the future; otherwise such support vector results will be incorrect.</p><p>This implementation is optimistic and first tries to remove all sets. However, it also checks that for all cached directions the support vector has been computed before. If it finds that this is not the case, the implementation identifies the biggest index <span>$k$</span> such that the above holds for the <span>$k$</span> oldest sets, and then it only removes these. See the example below.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x1 = BallInf(ones(3), 3.); x2 = Ball1(ones(3), 5.);

julia&gt; cms1 = CacheMinkowskiSum(2); cms2 = CacheMinkowskiSum(2);

julia&gt; d = ones(3);

julia&gt; a1 = array(cms1); a2 = array(cms2);

julia&gt; push!(a1, x1); push!(a2, x1);

julia&gt; σ(d, cms1); σ(d, cms2);

julia&gt; push!(a1, x2); push!(a2, x2);

julia&gt; σ(d, cms1);

julia&gt; idx1 = forget_sets!(cms1) # support vector was computed for both sets
2

julia&gt; idx1 = forget_sets!(cms2) # support vector was only computed for first set
1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/MinkowskiSum.jl#L549-L603">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../representations/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../representations/#LazySets.radius"><code>radius</code></a></li><li><a href="../representations/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h2><a class="nav-anchor" id="Maps-1" href="#Maps-1">Maps</a></h2><h3><a class="nav-anchor" id="Linear-Map-1" href="#Linear-Map-1">Linear Map</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.LinearMap" href="#LazySets.LinearMap"><code>LazySets.LinearMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">LinearMap{N&lt;:Real, S&lt;:LazySet{N}, NM, MAT&lt;:AbstractMatrix{NM}} &lt;: LazySet{N}</code></pre><p>Type that represents a linear transformation <span>$M⋅S$</span> of a convex set <span>$S$</span>.</p><p><strong>Fields</strong></p><ul><li><code>M</code> – matrix/linear map</li><li><code>X</code> – convex set</li></ul><p><strong>Notes</strong></p><p>This type is parametric in the elements of the linear map, <code>NM</code>, which is independent of the numeric type of the wrapped set (<code>N</code>). Typically <code>NM = N</code>, but there may be exceptions, e.g., if <code>NM</code> is an interval that holds numbers of type <code>N</code>, where <code>N</code> is a floating point number type such as <code>Float64</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LinearMap.jl#L7-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Union{Tuple{N}, Tuple{AbstractArray{N,2},LazySet{N}}} where N&lt;:Real" href="#Base.:*-Union{Tuple{N}, Tuple{AbstractArray{N,2},LazySet{N}}} where N&lt;:Real"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">    *(M::AbstractMatrix{N}, X::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return the linear map of a convex set.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix/linear map</li><li><code>X</code> – convex set</li></ul><p><strong>Output</strong></p><p>A lazy linear map, i.e. a <code>LinearMap</code> instance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LinearMap.jl#L49-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Union{Tuple{N}, Tuple{N,LazySet{N}}} where N&lt;:Real" href="#Base.:*-Union{Tuple{N}, Tuple{N,LazySet{N}}} where N&lt;:Real"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">    *(α::N, X::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return the linear map of a convex set scaled by a given number.</p><p><strong>Input</strong></p><ul><li><code>α</code> – scalar</li><li><code>X</code> – convex set</li></ul><p><strong>Output</strong></p><p>The lazy linear map of the convex set, <code>X ↦ M * X</code>, such that <code>M</code> is a sparse matrix proportional to the identity and whose non-zero entries equal <code>α</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LinearMap.jl#L73-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Union{Tuple{N}, Tuple{N,LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:*-Union{Tuple{N}, Tuple{N,LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">    *(α::N, lm::LinearMap{N}) where {N&lt;:Real, LM&lt;:LinearMap{N}}</code></pre><p>Return the linear map scaled by a given value.</p><p><strong>Input</strong></p><ul><li><code>α</code>  – scalar</li><li><code>lm</code> – linear map</li></ul><p><strong>Output</strong></p><p>The scaled linear map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LinearMap.jl#L95-L110">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Union{Tuple{N}, Tuple{AbstractArray{N,2},ZeroSet{N}}} where N&lt;:Real" href="#Base.:*-Union{Tuple{N}, Tuple{AbstractArray{N,2},ZeroSet{N}}} where N&lt;:Real"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">    *(M::AbstractMatrix{N}, Z::ZeroSet{N})::ZeroSet{N} where {N&lt;:Real}</code></pre><p>A linear map of a zero set, which is simplified to a zero set (the absorbing element).</p><p><strong>Input</strong></p><ul><li><code>M</code> – abstract matrix</li><li><code>Z</code> – zero set</li></ul><p><strong>Output</strong></p><p>The zero set with the output dimension of the linear map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LinearMap.jl#L115-L131">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LinearMap}" href="#LazySets.dim-Tuple{LinearMap}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(lm::LinearMap)::Int</code></pre><p>Return the dimension of a linear map.</p><p><strong>Input</strong></p><ul><li><code>lm</code> – linear map</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the linear map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LinearMap.jl#L138-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, lm::LinearMap{N}; kwargs...) where {N&lt;:Real}</code></pre><p>Return the support function of the linear map.</p><p><strong>Input</strong></p><ul><li><code>d</code>      – direction</li><li><code>lm</code>     – linear map</li><li><code>kwargs</code> – additional arguments that are passed to the support function             algorithm</li></ul><p><strong>Output</strong></p><p>The support function in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$L = M⋅S$</span>, where <span>$M$</span> is a matrix and <span>$S$</span> is a convex set, it follows that <span>$ρ(d, L) = ρ(M^T d, S)$</span> for any direction <span>$d$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LinearMap.jl#L179-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, lm::LinearMap{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of the linear map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>lm</code> – linear map</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$L = M⋅S$</span>, where <span>$M$</span> is a matrix and <span>$S$</span> is a convex set, it follows that <span>$σ(d, L) = M⋅σ(M^T d, S)$</span> for any direction <span>$d$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LinearMap.jl#L155-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, lm::LinearMap{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a linear map of a convex set.</p><p><strong>Input</strong></p><ul><li><code>x</code>  – point/vector</li><li><code>lm</code> – linear map of a convex set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ lm$</span>.</p><p><strong>Algorithm</strong></p><p>Note that <span>$x ∈ M⋅S$</span> iff <span>$M^{-1}⋅x ∈ S$</span>. This implementation does not explicitly invert the matrix, which is why it also works for non-square matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; lm = LinearMap([2.0 0.0; 0.0 1.0], BallInf([1., 1.], 1.));

julia&gt; ∈([5.0, 1.0], lm)
false
julia&gt; ∈([3.0, 1.0], lm)
true</code></pre><p>An example with non-square matrix:</p><pre><code class="language-julia-repl">julia&gt; B = BallInf(zeros(4), 1.);

julia&gt; M = [1. 0 0 0; 0 1 0 0]/2;

julia&gt; ∈([0.5, 0.5], M*B)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LinearMap.jl#L238-L278">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(lm::LinearMap{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a linear map.</p><p><strong>Input</strong></p><ul><li><code>lm</code> – linear map</li></ul><p><strong>Output</strong></p><p>An element in the linear map. It relies on the <code>an_element</code> function of the wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LinearMap.jl#L283-L296">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{LinearMap}" href="#LazySets.isbounded-Tuple{LinearMap}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(lm::LinearMap; cond_tol::Number=DEFAULT_COND_TOL)::Bool</code></pre><p>Determine whether a linear map is bounded.</p><p><strong>Input</strong></p><ul><li><code>lm</code>       – linear map</li><li><code>cond_tol</code> – (optional) tolerance of matrix condition (used to check whether               the matrix is invertible)</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the linear map is bounded.</p><p><strong>Algorithm</strong></p><p>We first check if the matrix is zero or the wrapped set is bounded. If not, we perform a sufficient check whether the matrix is invertible. If the matrix is invertible, then the map being bounded is equivalent to the wrapped set being bounded, and hence the map is unbounded. Otherwise, we check boundedness via <a href="../interfaces/#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>isbounded_unit_dimensions</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LinearMap.jl#L205-L227">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{LinearMap}" href="#Base.isempty-Tuple{LinearMap}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(lm::LinearMap)::Bool</code></pre><p>Return if a linear map is empty or not.</p><p><strong>Input</strong></p><ul><li><code>lm</code> – linear map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LinearMap.jl#L301-L313">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(lm::LinearMap{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a (polyhedral) linear map.</p><p><strong>Input</strong></p><ul><li><code>lm</code> – linear map</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying set <code>X</code> is polyhedral. Then the result is just the linear map applied to the vertices of <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LinearMap.jl#L318-L335">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(lm::LinearMap{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of a (polyhedral) linear map.</p><p><strong>Input</strong></p><ul><li><code>lm</code> – linear map</li></ul><p><strong>Output</strong></p><p>The list of constraints of the linear map.</p><p><strong>Notes</strong></p><p>We assume that the underlying set <code>X</code> is polyhedral, i.e., offers a method <code>constraints_list(X)</code>.</p><p><strong>Algorithm</strong></p><p>We fall back to a concrete set representation and apply <code>linear_map</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LinearMap.jl#L355-L376">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, lm::LinearMap{N}) where {N&lt;:Real}</code></pre><p>Return the linear map of a lazy linear map.</p><p><strong>Input</strong></p><ul><li><code>M</code>  – matrix</li><li><code>lm</code> – linear map</li></ul><p><strong>Output</strong></p><p>The polytope representing the linear map of the lazy linear map of a set.  </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LinearMap.jl#L381-L394">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.intersection-Union{Tuple{N}, Tuple{LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N},LazySet{N}}} where N&lt;:Real" href="#LazySets.intersection-Union{Tuple{N}, Tuple{LinearMap{N,S,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM where S&lt;:LazySet{N},LazySet{N}}} where N&lt;:Real"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">intersection(L::LinearMap{N}, S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return the intersection of a lazy linear map and a convex set.</p><p><strong>Input</strong></p><ul><li><code>L</code> – linear map</li><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>The polytope obtained by the intersection of <code>l.M * L.X</code> and <code>S</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/concrete_intersection.jl#L668-L681">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../representations/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../representations/#LazySets.radius"><code>radius</code></a></li><li><a href="../representations/#LazySets.diameter"><code>diameter</code></a></li></ul><h3><a class="nav-anchor" id="Exponential-Map-1" href="#Exponential-Map-1">Exponential Map</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ExponentialMap" href="#LazySets.ExponentialMap"><code>LazySets.ExponentialMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ExponentialMap{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the action of an exponential map on a convex set.</p><p><strong>Fields</strong></p><ul><li><code>spmexp</code> – sparse matrix exponential</li><li><code>X</code>      – convex set</li></ul><p><strong>Examples</strong></p><p>The <code>ExponentialMap</code> type is overloaded to the usual times <code>*</code> operator when the linear map is a lazy matrix exponential. For instance,</p><pre><code class="language-julia-repl">julia&gt; A = sprandn(100, 100, 0.1);

julia&gt; E = SparseMatrixExp(A);

julia&gt; B = BallInf(zeros(100), 1.);

julia&gt; M = E * B; # represents the image set: exp(A) * B

julia&gt; M isa ExponentialMap
true

julia&gt; dim(M)
100</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ExponentialMap.jl#L152-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{ExponentialMap}" href="#LazySets.dim-Tuple{ExponentialMap}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(em::ExponentialMap)::Int</code></pre><p>Return the dimension of an exponential map.</p><p><strong>Input</strong></p><ul><li><code>em</code> – an ExponentialMap</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the exponential map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ExponentialMap.jl#L210-L222">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ExponentialMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ExponentialMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, S::LazySet{N})::N where {N&lt;:Real}</code></pre><p>Evaluate the support function of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>The support function of the set <code>S</code> for the direction <code>d</code>.</p><p><strong>Notes</strong></p><p>The numeric type of the direction and the set must be identical.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/LazySet.jl#L117-L134">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>σ(::AbstractVector{N}, ::ExponentialMap{N}) where {N&lt;:Real}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>∈(::AbstractVector{N}, ::ExponentialMap{N}) where {N&lt;:Real}</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{ExponentialMap}" href="#LazySets.isbounded-Tuple{ExponentialMap}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(em::ExponentialMap)::Bool</code></pre><p>Determine whether an exponential map is bounded.</p><p><strong>Input</strong></p><ul><li><code>em</code> – exponential map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the exponential map is bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ExponentialMap.jl#L361-L373">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{ExponentialMap}" href="#Base.isempty-Tuple{ExponentialMap}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(em::ExponentialMap)::Bool</code></pre><p>Return if an exponential map is empty or not.</p><p><strong>Input</strong></p><ul><li><code>em</code> – exponential map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ExponentialMap.jl#L378-L390">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>vertices_list(::ExponentialMap{N}) where {N&lt;:Real}</code>. Check Documenter&#39;s build log for details.</p></div></div><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../representations/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../representations/#LazySets.radius"><code>radius</code></a></li><li><a href="../representations/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ExponentialProjectionMap" href="#LazySets.ExponentialProjectionMap"><code>LazySets.ExponentialProjectionMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ExponentialProjectionMap{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the application of a projection of a sparse matrix exponential to a convex set.</p><p><strong>Fields</strong></p><ul><li><code>spmexp</code> – projection of a sparse matrix exponential</li><li><code>X</code>      – convex set</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ExponentialMap.jl#L415-L425">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{ExponentialProjectionMap}" href="#LazySets.dim-Tuple{ExponentialProjectionMap}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(eprojmap::ExponentialProjectionMap)::Int</code></pre><p>Return the dimension of a projection of an exponential map.</p><p><strong>Input</strong></p><ul><li><code>eprojmap</code> – projection of an exponential map</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the projection of an exponential map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ExponentialMap.jl#L462-L474">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>σ(::AbstractVector{N}, ::ExponentialProjectionMap{N}) where {N&lt;:Real}</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{ExponentialProjectionMap}" href="#LazySets.isbounded-Tuple{ExponentialProjectionMap}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(eprojmap::ExponentialProjectionMap)::Bool</code></pre><p>Determine whether an exponential projection map is bounded.</p><p><strong>Input</strong></p><ul><li><code>eprojmap</code> – exponential projection map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the exponential projection map is bounded.</p><p><strong>Algorithm</strong></p><p>We first check if the left or right projection matrix is zero or the wrapped set is bounded. Otherwise, we check boundedness via <a href="../interfaces/#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>isbounded_unit_dimensions</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ExponentialMap.jl#L524-L542">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{ExponentialProjectionMap}" href="#Base.isempty-Tuple{ExponentialProjectionMap}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(eprojmap::ExponentialProjectionMap)::Bool</code></pre><p>Return if an exponential projection map is empty or not.</p><p><strong>Input</strong></p><ul><li><code>eprojmap</code> – exponential projection map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ExponentialMap.jl#L551-L563">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../representations/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../representations/#LazySets.radius"><code>radius</code></a></li><li><a href="../representations/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.SparseMatrixExp" href="#LazySets.SparseMatrixExp"><code>LazySets.SparseMatrixExp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SparseMatrixExp{N}</code></pre><p>Type that represents the matrix exponential, <span>$\exp(M)$</span>, of a sparse matrix.</p><p><strong>Fields</strong></p><ul><li><code>M</code> – sparse matrix</li></ul><p><strong>Examples</strong></p><p>Take for exammple a random sparse matrix:</p><pre><code class="language-julia-repl">julia&gt; A = sprandn(100, 100, 0.1);

julia&gt; E = SparseMatrixExp(A);

julia&gt; size(E)
(100, 100)</code></pre><p>Now, <code>E</code> is a lazy representation of <span>$\exp(A)$</span>. To compute with <code>E</code>, use <code>get_row</code> and <code>get_column</code> (or <code>get_rows</code> and <code>get_columns</code>; they return row and column vectors (or matrices). For example:</p><pre><code class="language-julia-repl">julia&gt; get_row(E, 10); # compute E[10, :]

julia&gt; get_column(E, 10); # compute E[:, 10]

julia&gt; get_rows(E, [10]); # same as get_row(E, 10) but a 1x100 matrix is returned

julia&gt; get_columns(E, [10]); # same as get_column(E, 10) but a 100x1 matrix is returned</code></pre><p><strong>Notes</strong></p><p>This type is provided for use with very large and very sparse matrices. The evaluation of the exponential matrix action over vectors relies on the <a href="https://github.com/acroy/Expokit.jl">Expokit</a> package.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ExponentialMap.jl#L15-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Union{Tuple{N}, Tuple{SparseMatrixExp{N},LazySet{N}}} where N&lt;:Real" href="#Base.:*-Union{Tuple{N}, Tuple{SparseMatrixExp{N},LazySet{N}}} where N&lt;:Real"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">    *(spmexp::SparseMatrixExp{N},
      X::LazySet{N})::ExponentialMap{N} where {N&lt;:Real}</code></pre><p>Return the exponential map of a convex set from a sparse matrix exponential.</p><p><strong>Input</strong></p><ul><li><code>spmexp</code> – sparse matrix exponential</li><li><code>X</code>      – convex set</li></ul><p><strong>Output</strong></p><p>The exponential map of the convex set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ExponentialMap.jl#L188-L204">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>get_row(::SparseMatrixExp, ::Int)</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ProjectionSparseMatrixExp" href="#LazySets.ProjectionSparseMatrixExp"><code>LazySets.ProjectionSparseMatrixExp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ProjectionSparseMatrixExp{N&lt;:Real}</code></pre><p>Type that represents the projection of a sparse matrix exponential, i.e., <span>$L⋅\exp(M)⋅R$</span> for a given sparse matrix <span>$M$</span>.</p><p><strong>Fields</strong></p><ul><li><code>L</code> – left multiplication matrix</li><li><code>E</code> – sparse matrix exponential</li><li><code>R</code> – right multiplication matrix</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ExponentialMap.jl#L397-L408">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{ProjectionSparseMatrixExp,LazySet}" href="#Base.:*-Tuple{ProjectionSparseMatrixExp,LazySet}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">    *(projspmexp::ProjectionSparseMatrixExp,
      X::LazySet)::ExponentialProjectionMap</code></pre><p>Return the application of a projection of a sparse matrix exponential to a convex set.</p><p><strong>Input</strong></p><ul><li><code>projspmexp</code> – projection of a sparse matrix exponential</li><li><code>X</code>          – convex set</li></ul><p><strong>Output</strong></p><p>The application of the projection of a sparse matrix exponential to the convex set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ExponentialMap.jl#L438-L456">source</a></section><h3><a class="nav-anchor" id="Reset-Map-1" href="#Reset-Map-1">Reset Map</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ResetMap" href="#LazySets.ResetMap"><code>LazySets.ResetMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ResetMap{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents a lazy reset map. A reset map is a special case of an affine map <span>$A x + b, x ∈ X$</span> where the linear map <span>$A$</span> is the identity matrix with zero entries in all reset dimensions, and the translation vector <span>$b$</span> is zero in all other dimensions.</p><p><strong>Fields</strong></p><ul><li><code>X</code>      – convex set</li><li><code>resets</code> – resets (a mapping from an index to a new value)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; X = BallInf([2.0, 2.0, 2.0], 1.0);

julia&gt; r = Dict(1 =&gt; 4.0, 3 =&gt; 0.0);

julia&gt; rm = ResetMap(X, r);
</code></pre><p>Here <code>rm</code> modifies the set <code>X</code> such that <code>x1</code> is reset to 4 and <code>x3</code> is reset to 0, while <code>x2</code> is not modified. Hence <code>rm</code> is equivalent to the set <code>Hyperrectangle([4.0, 2.0, 0.0], [0.0, 1.0, 0.0])</code>, i.e., an axis-aligned line segment embedded in 3D.</p><p>The corresponding affine map <span>$A x + b$</span> would be:</p><div>\[    egin{pmatrix} 0 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 0 nd{pmatrix} x +
    egin{pmatrix} 4 &amp; 0 &amp; 0 nd{pmatrix}\]</div><p>Use the function <code>get_A</code> (resp. <code>get_b</code>) to create the matrix <code>A</code> (resp. vector <code>b</code>) corresponding to a given reset map.</p><p>The (in this case unique) support vector of <code>rm</code> in direction <code>ones(3)</code> is:</p><pre><code class="language-julia-repl">julia&gt; σ(ones(3), rm)
3-element Array{Float64,1}:
 4.0
 3.0
 0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ResetMap.jl#L7-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{ResetMap}" href="#LazySets.dim-Tuple{ResetMap}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(rm::ResetMap)</code></pre><p>Return the dimension of a reset map.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map</li></ul><p><strong>Output</strong></p><p>The dimension of a reset map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ResetMap.jl#L121-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ResetMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ResetMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, rm::ResetMap{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a reset map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>rm</code> – reset map</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p><p><strong>Notes</strong></p><p>We use the usual dot-product definition, but for unbounded sets we redefine the product between <span>$0$</span> and <span>$±∞$</span> as <span>$0$</span>; Julia returns <code>NaN</code> here.</p><pre><code class="language-julia-repl">julia&gt; Inf * 0.0
NaN</code></pre><p>See the discussion <a href="https://math.stackexchange.com/questions/28940/why-is-infty-cdot-0-not-clearly-equal-to-0">here</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ResetMap.jl#L161-L187">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ResetMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ResetMap{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, rm::ResetMap{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a reset map.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>rm</code> – reset map</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ResetMap.jl#L138-L152">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{ResetMap}" href="#LazySets.an_element-Tuple{ResetMap}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(rm::ResetMap)</code></pre><p>Return some element of a reset map.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map</li></ul><p><strong>Output</strong></p><p>An element in the reset map. It relies on the <code>an_element</code> function of the wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ResetMap.jl#L192-L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{ResetMap}" href="#Base.isempty-Tuple{ResetMap}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(rm::ResetMap)::Bool</code></pre><p>Return if a reset map is empty or not.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ResetMap.jl#L210-L222">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.get_A-Union{Tuple{ResetMap{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.get_A-Union{Tuple{ResetMap{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.get_A</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_A(rm::ResetMap{N}) where {N&lt;:Real}</code></pre><p>Return the <span>$A$</span> matrix of the affine map <span>$A x + b, x ∈ X$</span> represented by a reset map.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map</li></ul><p><strong>Output</strong></p><p>The (sparse) square matrix for the affine map <span>$A x + b, x ∈ X$</span> represented by the reset map.</p><p><strong>Algorithm</strong></p><p>We construct the identity matrix and set all entries in the reset dimensions to zero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ResetMap.jl#L62-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.get_b-Union{Tuple{ResetMap{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.get_b-Union{Tuple{ResetMap{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.get_b</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_b(rm::ResetMap{N}) where {N&lt;:Real}</code></pre><p>Return the <span>$b$</span> vector of the affine map <span>$A x + b, x ∈ X$</span> represented by a reset map.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map</li></ul><p><strong>Output</strong></p><p>The (sparse) vector for the affine map <span>$A x + b, x ∈ X$</span> represented by the reset map. The vector contains the reset value for all reset dimensions, and is zero for all other dimensions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ResetMap.jl#L91-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{ResetMap{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{ResetMap{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(rm::ResetMap{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of a polytopic reset map.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map of a polytope</li></ul><p><strong>Output</strong></p><p>The list of constraints of the reset map.</p><p><strong>Notes</strong></p><p>We assume that the underlying set <code>X</code> is a polytope, i.e., is bounded and offers a method <code>constraints_list(X)</code>.</p><p><strong>Algorithm</strong></p><p>We fall back to <code>constraints_list</code> of a <code>LinearMap</code> of the <code>A</code>-matrix in the affine-map view of a reset map. Each reset dimension <span>$i$</span> is projected to zero, expressed by two constraints for each reset dimension. Then it remains to shift these constraints to the new value.</p><p>For instance, if the dimension <span>$5$</span> was reset to <span>$4$</span>, then there will be constraints <span>$x₅ ≤ 0$</span> and <span>$-x₅ ≤ 0$</span>. We then modify the right-hand side of these constraints to <span>$x₅ ≤ 4$</span> and <span>$-x₅ ≤ -4$</span>, respectively.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ResetMap.jl#L227-L257">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{ResetMap{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:AbstractHyperrectangle where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{ResetMap{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:AbstractHyperrectangle where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(rm::ResetMap{N, S}) where
    {N&lt;:Real, S&lt;:AbstractHyperrectangle}</code></pre><p>Return the list of constraints of a hyperrectangular reset map.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map of a hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The list of constraints of the reset map.</p><p><strong>Algorithm</strong></p><p>We iterate through all dimensions. If there is a reset, we construct the corresponding (flat) constraints. Otherwise, we construct the corresponding constraints of the underlying set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/ResetMap.jl#L299-L318">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LazySets.isbounded-Tuple{LinearMap}"><code>isbounded</code></a></li><li><a href="../representations/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../representations/#LazySets.radius"><code>radius</code></a></li><li><a href="../representations/#LazySets.diameter"><code>diameter</code></a></li></ul><h2><a class="nav-anchor" id="Symmetric-Interval-Hull-1" href="#Symmetric-Interval-Hull-1">Symmetric Interval Hull</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.SymmetricIntervalHull" href="#LazySets.SymmetricIntervalHull"><code>LazySets.SymmetricIntervalHull</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SymmetricIntervalHull{N&lt;:Real, S&lt;:LazySet{N}} &lt;: AbstractHyperrectangle{N}</code></pre><p>Type that represents the symmetric interval hull of a convex set.</p><p><strong>Fields</strong></p><ul><li><code>X</code>     – convex set</li><li><code>cache</code> – partial storage of already computed bounds, organized as mapping   from dimension to tuples <code>(bound, valid)</code>, where <code>valid</code> is a flag   indicating if the <code>bound</code> entry has been computed</li></ul><p><strong>Notes</strong></p><p>The symmetric interval hull can be computed with <span>$2n$</span> support vector queries of unit vectors, where <span>$n$</span> is the dimension of the wrapped set (i.e., two queries per dimension). When asking for the support vector for a direction <span>$d$</span>, one needs <span>$2k$</span> such queries, where <span>$k$</span> is the number of non-zero entries in <span>$d$</span>.</p><p>However, if one asks for many support vectors in a loop, the number of computations may exceed <span>$2n$</span>. To be most efficient in such cases, this type stores the intermediately computed bounds in the <code>cache</code> field.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/SymmetricIntervalHull.jl#L4-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{SymmetricIntervalHull}" href="#LazySets.dim-Tuple{SymmetricIntervalHull}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(sih::SymmetricIntervalHull)::Int</code></pre><p>Return the dimension of a symmetric interval hull of a convex set.</p><p><strong>Input</strong></p><ul><li><code>sih</code> – symmetric interval hull of a convex set</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the symmetric interval hull of a convex set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/SymmetricIntervalHull.jl#L139-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},SymmetricIntervalHull{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},SymmetricIntervalHull{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, sih::SymmetricIntervalHull{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a symmetric interval hull of a convex set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>sih</code> – symmetric interval hull of a convex set</li></ul><p><strong>Output</strong></p><p>The support vector of the symmetric interval hull of a convex set in the given direction. If the direction has norm zero, the origin is returned.</p><p><strong>Algorithm</strong></p><p>For each non-zero entry in <code>d</code> we need to either look up the bound (if it has been computed before) or compute it, in which case we store it for future queries. One such computation just asks for the support vector of the underlying set for both the positive and negative unit vector in the respective dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/SymmetricIntervalHull.jl#L156-L180">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Union{Tuple{SymmetricIntervalHull{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.center-Union{Tuple{SymmetricIntervalHull{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">center(sih::SymmetricIntervalHull{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a symmetric interval hull of a convex set.</p><p><strong>Input</strong></p><ul><li><code>sih</code> – symmetric interval hull of a convex set</li></ul><p><strong>Output</strong></p><p>The origin.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/SymmetricIntervalHull.jl#L118-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{SymmetricIntervalHull{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{SymmetricIntervalHull{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">radius_hyperrectangle(sih::SymmetricIntervalHull{N}
                     )::Vector{N} where {N&lt;:Real}</code></pre><p>Return the box radius of a symmetric interval hull of a convex set in every dimension.</p><p><strong>Input</strong></p><ul><li><code>sih</code> – symmetric interval hull of a convex set</li></ul><p><strong>Output</strong></p><p>The box radius of the symmetric interval hull of a convex set.</p><p><strong>Notes</strong></p><p>This function computes the symmetric interval hull explicitly.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/SymmetricIntervalHull.jl#L86-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{SymmetricIntervalHull{N,S} where S&lt;:LazySet{N},Int64}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{SymmetricIntervalHull{N,S} where S&lt;:LazySet{N},Int64}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">radius_hyperrectangle(sih::SymmetricIntervalHull{N},
                      i::Int)::N where {N&lt;:Real}</code></pre><p>Return the box radius of a symmetric interval hull of a convex set in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>sih</code> – symmetric interval hull of a convex set</li><li><code>i</code>   – dimension of interest</li></ul><p><strong>Output</strong></p><p>The radius in the given dimension. If it was computed before, this is just a look-up, otherwise it requires two support vector computations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/SymmetricIntervalHull.jl#L63-L80">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../representations/#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.isbounded-Tuple{AbstractPolytope}"><code>isbounded</code></a></li><li><a href="../interfaces/#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>singleton_list</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolyhedron"><code>AbstractPolyhedron</code></a>:</p><ul><li><a href="../interfaces/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolyhedron{N}}} where N&lt;:Real"><code>linear_map</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractCentrallySymmetricPolytope"><code>AbstractCentrallySymmetricPolytope</code></a>:</p><ul><li><a href="../interfaces/#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}"><code>isempty</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractHyperrectangle"><code>AbstractHyperrectangle</code></a>:</p><ul><li><a href="../interfaces/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>∈</code></a></li><li><a href="../representations/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../representations/#LazySets.radius"><code>radius</code></a></li><li><a href="../interfaces/#LazySets.vertices_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>vertices_list</code></a></li><li><a href="../interfaces/#LazySets.high-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>high</code></a></li><li><a href="../interfaces/#LazySets.low-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>low</code></a></li></ul><h3><a class="nav-anchor" id="Translation-1" href="#Translation-1">Translation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Translation" href="#LazySets.Translation"><code>LazySets.Translation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Translation{N&lt;:Real, VN&lt;:AbstractVector{N}, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents a lazy translation.</p><p>The translation of set <code>X</code> along vector <code>v</code> is the map: </p><div>\[x ↦ x + v,\qquad x ∈ X\]</div><p>A translation is a special case of an affine map <span>$A x + b, x ∈ X$</span> where the linear map <span>$A$</span> is the identity matrix and the translation vector <span>$b = v$</span>.</p><p><strong>Fields</strong></p><ul><li><code>X</code> – convex set</li><li><code>v</code> – vector that defines the translation</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; X = BallInf([2.0, 2.0, 2.0], 1.0);

julia&gt; v = [1.0, 0.0, 0.0]; # translation along dimension 1

julia&gt; tr = Translation(X, v);

julia&gt; typeof(tr)
Translation{Float64,Array{Float64,1},BallInf{Float64}}

julia&gt; tr.X
BallInf{Float64}([2.0, 2.0, 2.0], 1.0)

julia&gt; tr.v
3-element Array{Float64,1}:
 1.0
 0.0
 0.0</code></pre><p>The sum operator <code>+</code> is overloaded to create translations:</p><pre><code class="language-julia-repl">julia&gt; X + v == Translation(X, v)
true</code></pre><p>And so does the Minkowski sum operator, <code>⊕</code>:</p><pre><code class="language-julia-repl">julia&gt; X ⊕ v == Translation(X, v)
true</code></pre><p>The translation of a translation is performed immediately:</p><pre><code class="language-julia-repl">julia&gt; tr = (X+v)+v
Translation{Float64,Array{Float64,1},BallInf{Float64}}(BallInf{Float64}([2.0, 2.0, 2.0], 1.0), [2.0, 0.0, 0.0])

julia&gt; tr.v
3-element Array{Float64,1}:
 2.0
 0.0
 0.0</code></pre><p>The dimension of a translation is obtained with the <code>dim</code> function:</p><pre><code class="language-julia-repl">julia&gt; dim(tr)
3</code></pre><p>For the support vector (resp. support function) along vector <code>d</code>, use <code>σ</code> and <code>ρ</code> respectively:</p><pre><code class="language-julia-repl">julia&gt; σ([1.0, 0.0, 0.0], tr)
3-element Array{Float64,1}:
 5.0
 3.0
 3.0

julia&gt; ρ([1.0, 0.0, 0.0], tr)
5.0</code></pre><p>See the docstring of each of these functions for details.</p><p>The <code>an_element</code> function is useful to obtain an element of a translation:</p><pre><code class="language-julia-repl">julia&gt; e = an_element(tr)
3-element Array{Float64,1}:
 4.0
 2.0
 2.0</code></pre><p>The lazy linear map of a translation is again a translation, since the following simplification rule applies: <span>$M * (X⊕v) = (M*X) ⊕ (M*v)$</span>:</p><pre><code class="language-julia-repl">julia&gt; Q = Matrix(2.0I, 3, 3) * tr;

julia&gt; Q isa Translation &amp;&amp; Q.v == 2 * tr.v
true</code></pre><p>Use the <code>isempty</code> method to query if the translation is empty; it falls back to the <code>isempty</code> method of the wrapped set:</p><pre><code class="language-julia-repl">julia&gt; isempty(tr)
false</code></pre><p>The list of constraints of the translation of a polyhedron (in general, a set whose <code>constraints_list</code> is available) can be computed from a lazy translation:</p><pre><code class="language-julia-repl">julia&gt; constraints_list(tr)
6-element Array{HalfSpace{Float64},1}:
 HalfSpace{Float64}([1.0, 0.0, 0.0], 5.0)
 HalfSpace{Float64}([0.0, 1.0, 0.0], 3.0)
 HalfSpace{Float64}([0.0, 0.0, 1.0], 3.0)
 HalfSpace{Float64}([-1.0, -0.0, -0.0], -3.0)
 HalfSpace{Float64}([-0.0, -1.0, -0.0], -1.0)
 HalfSpace{Float64}([-0.0, -0.0, -1.0], -1.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Translation.jl#L7-L136">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{LazySet,AbstractArray{T,1} where T}" href="#Base.:+-Tuple{LazySet,AbstractArray{T,1} where T}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">+(X::LazySet, v::AbstractVector)</code></pre><p>Convenience constructor for a translation.</p><p><strong>Input</strong></p><ul><li><code>X</code> – convex set</li><li><code>v</code> – vector</li></ul><p><strong>Output</strong></p><p>The symbolic translation of <span>$X$</span> along vector <span>$v$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Translation.jl#L161-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.:⊕-Tuple{LazySet,AbstractArray{T,1} where T}" href="#LazySets.:⊕-Tuple{LazySet,AbstractArray{T,1} where T}"><code>LazySets.:⊕</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">⊕(X::LazySet, v::AbstractVector)</code></pre><p>Unicode alias constructor ⊕ (<code>oplus</code>) for the lazy translation operator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Translation.jl#L180-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{Translation}" href="#LazySets.dim-Tuple{Translation}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(tr::Translation)::Int</code></pre><p>Return the dimension of a translation.</p><p><strong>Input</strong></p><ul><li><code>tr</code> – translation</li></ul><p><strong>Output</strong></p><p>The dimension of a translation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Translation.jl#L194-L206">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, tr::Translation{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a translation.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>tr</code> – translation</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Translation.jl#L231-L244">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, tr::Translation{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a translation.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>tr</code> – translation</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Translation.jl#L212-L226">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{Translation}" href="#LazySets.an_element-Tuple{Translation}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(tr::Translation)</code></pre><p>Return some element of a translation.</p><p><strong>Input</strong></p><ul><li><code>tr</code> – translation</li></ul><p><strong>Output</strong></p><p>An element in the translation.</p><p><strong>Notes</strong></p><p>This function first asks for <code>an_element</code> function of the wrapped set, then translates this element according to the given translation vector. </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Translation.jl#L272-L289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{Translation}" href="#Base.isempty-Tuple{Translation}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(tr::Translation)::Bool</code></pre><p>Return if a translation is empty or not.</p><p><strong>Input</strong></p><ul><li><code>tr</code> – translation</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the wrapped set is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Translation.jl#L294-L306">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{N}, Tuple{Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1},Val{true}}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{N}, Tuple{Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1},Val{true}}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(tr::Translation{N}, ::Val{true}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of the translation of a set.</p><p><strong>Input</strong></p><ul><li><code>tr</code> – lazy translation of a polyhedron</li></ul><p><strong>Output</strong></p><p>The list of constraints of the translation.</p><p><strong>Notes</strong></p><p>We assume that the set wrapped by the lazy translation <code>X</code> offers a method <code>constraints_list(⋅)</code>.</p><p><strong>Algorithm</strong></p><p>Let the translation be defined by the set of points <code>y</code> such that <code>y = x + v</code> for all <code>x ∈ X</code>. Then, each defining halfspace <code>a⋅x ≤ b</code> is transformed to <code>a⋅y ≤ b + a⋅v</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Translation.jl#L311-L334">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.LinearMap-Union{Tuple{N}, Tuple{AbstractArray{N,2},Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.LinearMap-Union{Tuple{N}, Tuple{AbstractArray{N,2},Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.LinearMap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">LinearMap(M::AbstractMatrix{N}, tr::Translation{N}) where {N&lt;:Real}</code></pre><p>Return the lazy linear map of a translation.</p><p><strong>Input</strong></p><ul><li><code>M</code>  – matrix</li><li><code>tr</code> – translation</li></ul><p><strong>Output</strong></p><p>The translation defined by the linear map.</p><p><strong>Notes</strong></p><p>This method defines the simplification rule: <span>$M * (X⊕v) = (M*X) ⊕ (M*v)$</span>, returning a new translation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Translation.jl#L249-L267">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Translation{N,VN,S} where S&lt;:LazySet{N} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, tr::Translation{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in the translation of a convex set.</p><p><strong>Input</strong></p><ul><li><code>x</code>  – point/vector</li><li><code>tr</code> – translation of a convex set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ tr$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation relies on the set membership function for the wrapped set <code>tr.X</code>, since <span>$x ∈ X ⊕ v$</span> iff <span>$x - v ∈ X$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Translation.jl#L353-L371">source</a></section><h2><a class="nav-anchor" id="Union-1" href="#Union-1">Union</a></h2><p>Note that a union of convex sets is generally not convex. Hence these set types are not part of the convex-set family <code>LazySet</code>.</p><h3><a class="nav-anchor" id="Binary-Set-Union-1" href="#Binary-Set-Union-1">Binary Set Union</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.UnionSet" href="#LazySets.UnionSet"><code>LazySets.UnionSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">UnionSet{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}}</code></pre><p>Type that represents the set union of two convex sets.</p><p><strong>Fields</strong></p><ul><li><code>X</code> – convex set</li><li><code>Y</code> – convex set</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L11-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∪-Tuple{LazySet,LazySet}" href="#Base.:∪-Tuple{LazySet,LazySet}"><code>Base.:∪</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∪</code></pre><p>Alias for <code>UnionSet</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L38-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{UnionSet}" href="#LazySets.dim-Tuple{UnionSet}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(cup::UnionSet)::Int</code></pre><p>Return the dimension of the set union of two convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of two convex sets</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the union of two convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L45-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, cup::UnionSet{N}; [algorithm]=&quot;support_vector&quot;) where {N&lt;:Real}</code></pre><p>Return the support vector of the union of two convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>         – direction</li><li><code>cup</code>       – union of two convex sets</li><li><code>algorithm</code> – (optional, default: &quot;support<em>vector&quot;): the algorithm to compute                the support vector; if &quot;support</em>vector&quot;, use the support                vector of each argument; if &quot;support_function&quot; use the support                function of each argument and evaluate the support vector of only                one of them</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>The support vector of the union of two convex sets <span>$X$</span> and <span>$Y$</span> can be obtained as the vector that maximizes the support function of either <span>$X$</span> or <span>$Y$</span>, i.e. it is sufficient to find the <span>$\argmax(ρ(d, X), ρ(d, Y)])$</span> and evaluate its support vector.</p><p>The default implementation, with option <code>algorithm=&quot;support_vector&quot;</code>, computes the support vector of <span>$X$</span> and <span>$Y$</span> and then compares the support function using a dot product. If it happens that the support function can be more efficiently computed (without passing through the support vector), consider using the alternative <code>algorithm=&quot;support_function&quot;</code> implementation, which evaluates the support function of each set directly and then calls only the support vector of either <span>$X$</span> <em>or</em> <span>$Y$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L62-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, cup::UnionSet{N}) where {N&lt;:Real}</code></pre><p>Return the support function of the union of two convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cup</code> – union of two convex sets</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p><p><strong>Algorithm</strong></p><p>The support function of the union of two convex sets <span>$X$</span> and <span>$Y$</span> is the maximum of the support functions of <span>$X$</span> and <span>$Y$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L109-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(cup::UnionSet{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a union of two convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of two convex sets</li></ul><p><strong>Output</strong></p><p>An element in the union of two convex sets.</p><p><strong>Algorithm</strong></p><p>We use <code>an_element</code> on the first wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L133-L149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSet{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, cup::UnionSet{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a union of two convex sets.</p><p><strong>Input</strong></p><ul><li><code>x</code>   – point/vector</li><li><code>cup</code> – union of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ cup$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L154-L167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{UnionSet}" href="#Base.isempty-Tuple{UnionSet}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(cup::UnionSet)::Bool</code></pre><p>Check whether a union of two convex sets is empty.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the union is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L172-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{UnionSet}" href="#LazySets.isbounded-Tuple{UnionSet}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(cup::UnionSet)::Bool</code></pre><p>Determine whether a union of two convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of two convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the union is bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L189-L201">source</a></section><h3><a class="nav-anchor" id="n-ary-Set-Union-1" href="#n-ary-Set-Union-1"><span>$n$</span>-ary Set Union</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.UnionSetArray" href="#LazySets.UnionSetArray"><code>LazySets.UnionSetArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">UnionSetArray{N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Type that represents the set union of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><code>array</code> – array of convex sets</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L210-L218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{UnionSetArray}" href="#LazySets.dim-Tuple{UnionSetArray}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(cup::UnionSetArray)::Int</code></pre><p>Return the dimension of the set union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the union of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L235-L247">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.array-Union{Tuple{UnionSetArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real" href="#LazySets.array-Union{Tuple{UnionSetArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">array(cup::UnionSetArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array that holds the union of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L252-L264">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSetArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSetArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, cup::UnionSetArray{N}; [algorithm]=&quot;support_vector&quot;) where {N&lt;:Real}</code></pre><p>Return the support vector of the union of a finite number of convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>         – direction</li><li><code>cup</code>       – union of a finite number of convex sets</li><li><code>algorithm</code> – (optional, default: &quot;support<em>vector&quot;): the algorithm to compute                the support vector; if &quot;support</em>vector&quot;, use the support                vector of each argument; if &quot;support_function&quot; use the support                function of each argument and evaluate the support vector of only                one of them</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>The support vector of the union of a finite number of convex sets <span>$X₁, X₂, ...$</span> can be obtained as the vector that maximizes the support function, i.e. it is sufficient to find the <span>$\argmax(ρ(d, X₂), ρ(d, X₂), ...])$</span> and evaluate its support vector.</p><p>The default implementation, with option <code>algorithm=&quot;support_vector&quot;</code>, computes the support vector of all <span>$X₁, X₂, ...$</span> and then compares the support function using a dot product. If it happens that the support function can be more efficiently computed (without passing through the support vector), consider using the alternative <code>algorithm=&quot;support_function&quot;</code> implementation, which evaluates the support function of each set directly and then calls only the support vector of one of the <span>$Xᵢ$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L269-L302">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSetArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSetArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, cup::UnionSetArray{N}) where {N&lt;:Real}</code></pre><p>Return the support function of the union of a finite number of convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p><p><strong>Algorithm</strong></p><p>The support function of the union of a finite number of convex sets <span>$X₁, X₂, ...$</span> can be obtained as the maximum of <span>$ρ(d, X₂), ρ(d, X₂), ...$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L319-L338">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{UnionSetArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{UnionSetArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(cup::UnionSetArray{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>An element in the union of a finite number of convex sets.</p><p><strong>Algorithm</strong></p><p>We use <code>an_element</code> on the first wrapped set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L345-L361">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSetArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSetArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, cup::UnionSetArray{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>x</code>   – point/vector</li><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ cup$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L366-L380">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{UnionSetArray}" href="#Base.isempty-Tuple{UnionSetArray}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(cup::UnionSetArray)::Bool</code></pre><p>Check whether a union of a finite number of convex sets is empty.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the union is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L385-L397">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{UnionSetArray}" href="#LazySets.isbounded-Tuple{UnionSetArray}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(cup::UnionSetArray)::Bool</code></pre><p>Determine whether a union of a finite number of convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the union is bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/UnionSet.jl#L402-L414">source</a></section><h2><a class="nav-anchor" id="Complement-1" href="#Complement-1">Complement</a></h2><p>Note that a complement of a convex set is generally not convex. Hence this set type is not part of the convex-set family <code>LazySet</code>.</p><h3><a class="nav-anchor" id="Binary-Set-Union-2" href="#Binary-Set-Union-2">Binary Set Union</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Complement" href="#LazySets.Complement"><code>LazySets.Complement</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Complement{N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Type that represents the complement of a convex set.</p><p><strong>Fields</strong></p><ul><li><code>X</code> – convex set</li></ul><p><strong>Notes</strong></p><p>Since <code>X</code> is assumed to be closed, unless <code>X</code> is empty or the universe, its complement is open (i.e., not closed). Since <code>X</code> is assumed to be closed, unless <code>X</code> is empty, the universe, or a half-space, its complement is not convex.</p><p>The complement of the complement is the original set again.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = BallInf(zeros(2), 1.); C = Complement(B)
Complement{Float64,BallInf{Float64}}(BallInf{Float64}([0.0, 0.0], 1.0))

julia&gt; Complement(C)
BallInf{Float64}([0.0, 0.0], 1.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Complement.jl#L6-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{Complement}" href="#LazySets.dim-Tuple{Complement}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(C::Complement)</code></pre><p>Return the dimension of the complement of a convex set.</p><p><strong>Input</strong></p><ul><li><code>C</code> – complement of a convex set</li></ul><p><strong>Output</strong></p><p>The dimension of the complement of a convex set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Complement.jl#L46-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Complement{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Complement{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, C::Complement{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in the complement of a convex set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>C</code> – complement of a convex set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the vector is contained in the complement.</p><p><strong>Algorithm</strong></p><div>\[    x ∈ X^C ⟺ x ∉ X\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Complement.jl#L63-L82">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{Complement}" href="#Base.isempty-Tuple{Complement}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(C::Complement)::Bool</code></pre><p>Return if the complement of a convex set is empty or not.</p><p><strong>Input</strong></p><ul><li><code>C</code> – complement of a convex set</li></ul><p><strong>Output</strong></p><p><code>false</code> unless the original set is universal.</p><p><strong>Algorithm</strong></p><p>We use the <code>isuniversal</code> method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/18ea53d5c6058f824a78fa14a9dbf747f1ea79bb/src/Complement.jl#L88-L104">source</a></section><footer><hr/><a class="previous" href="../representations/"><span class="direction">Previous</span><span class="title">Common Set Representations</span></a><a class="next" href="../comparisons/"><span class="direction">Next</span><span class="title">Comparisons</span></a></footer></article></body></html>
