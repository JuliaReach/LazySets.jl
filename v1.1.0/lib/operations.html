<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Common Set Operations · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/getting_started.html">Getting Started</a></li><li><a class="toctext" href="../man/polyhedral_approximations.html">Polyhedral Approximations</a></li><li><a class="toctext" href="../man/decompose_example.html">Decomposing an Affine Map</a></li><li><a class="toctext" href="../man/fast_2d_LPs.html">Fast 2D LPs</a></li><li><a class="toctext" href="../man/iterative_refinement.html">Iterative Refinement</a></li><li><a class="toctext" href="../man/interval_hulls.html">Interval Hulls</a></li><li><a class="toctext" href="../man/convex_hulls.html">Convex Hulls</a></li><li><a class="toctext" href="../man/set_operations.html">Operations on Sets</a></li><li><a class="toctext" href="../man/reach_zonotopes.html">A Reachability Algorithm</a></li><li><a class="toctext" href="../man/concrete_polyhedra.html">Concrete Polyhedra</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="interfaces.html">Set Interfaces</a></li><li><a class="toctext" href="representations.html">Common Set Representations</a></li><li class="current"><a class="toctext" href="operations.html">Common Set Operations</a><ul class="internal"><li><a class="toctext" href="#Cartesian-Product-1">Cartesian Product</a></li><li><a class="toctext" href="#Convex-Hull-1">Convex Hull</a></li><li><a class="toctext" href="#Intersection-1">Intersection</a></li><li><a class="toctext" href="#Minkowski-Sum-1">Minkowski Sum</a></li><li><a class="toctext" href="#Maps-1">Maps</a></li><li><a class="toctext" href="#Symmetric-Interval-Hull-1">Symmetric Interval Hull</a></li></ul></li><li><a class="toctext" href="binary_functions.html">Binary Functions on Sets</a></li><li><a class="toctext" href="approximations.html">Approximations</a></li><li><a class="toctext" href="utils.html">Utility Functions</a></li></ul></li><li><a class="toctext" href="../about.html">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="operations.html">Common Set Operations</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/operations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Common Set Operations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Common-Set-Operations-1" href="#Common-Set-Operations-1">Common Set Operations</a></h1><p>This section of the manual describes the basic symbolic types describing operations between sets.</p><ul><li><a href="operations.html#Common-Set-Operations-1">Common Set Operations</a></li><ul><li><a href="operations.html#Cartesian-Product-1">Cartesian Product</a></li><ul><li><a href="operations.html#Binary-Cartesian-Product-1">Binary Cartesian Product</a></li><li><a href="operations.html#n-ary-Cartesian-Product-1"><span>$n$</span>-ary Cartesian Product</a></li></ul><li><a href="operations.html#Convex-Hull-1">Convex Hull</a></li><ul><li><a href="operations.html#Binary-Convex-Hull-1">Binary Convex Hull</a></li><li><a href="operations.html#n-ary-Convex-Hull-1"><span>$n$</span>-ary Convex Hull</a></li><li><a href="operations.html#Convex-Hull-Algorithms-1">Convex Hull Algorithms</a></li></ul><li><a href="operations.html#Intersection-1">Intersection</a></li><li><a href="operations.html#Minkowski-Sum-1">Minkowski Sum</a></li><ul><li><a href="operations.html#Binary-Minkowski-Sum-1">Binary Minkowski Sum</a></li><li><a href="operations.html#n-ary-Minkowski-Sum-1"><span>$n$</span>-ary Minkowski Sum</a></li></ul><li><a href="operations.html#Maps-1">Maps</a></li><ul><li><a href="operations.html#Linear-Map-1">Linear Map</a></li><li><a href="operations.html#Exponential-Map-1">Exponential Map</a></li></ul><li><a href="operations.html#Symmetric-Interval-Hull-1">Symmetric Interval Hull</a></li></ul></ul><h2><a class="nav-anchor" id="Cartesian-Product-1" href="#Cartesian-Product-1">Cartesian Product</a></h2><h3><a class="nav-anchor" id="Binary-Cartesian-Product-1" href="#Binary-Cartesian-Product-1">Binary Cartesian Product</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CartesianProduct" href="#LazySets.CartesianProduct"><code>LazySets.CartesianProduct</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CartesianProduct{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents a Cartesian product of two convex sets.</p><p><strong>Fields</strong></p><ul><li><p><code>X</code> – first convex set</p></li><li><p><code>Y</code> – second convex set</p></li></ul><p><strong>Notes</strong></p><p>The Cartesian product of three elements is obtained recursively. See also <code>CartesianProductArray</code> for an implementation of a Cartesian product of many sets without recursion, instead using an array.</p><ul><li><p><code>CartesianProduct{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}}(X1::S1, X2::S2)</code> – default constructor</p></li><li><p><code>CartesianProduct(Xarr::Vector{S}) where {S&lt;:LazySet}</code> – constructor from an array of convex sets</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/CartesianProduct.jl#L6-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.CartesianProduct{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.CartesianProduct{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(cp::CartesianProduct)::Int</code></pre><p>Return the dimension of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><p><code>cp</code> – Cartesian product</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Cartesian product.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/CartesianProduct.jl#L109-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.CartesianProduct{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.CartesianProduct{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, cp::CartesianProduct)::AbstractVector{&lt;:Real}</code></pre><p>Return the support vector of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>  – direction</p></li><li><p><code>cp</code> – Cartesian product</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the product sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/CartesianProduct.jl#L126-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{LazySets.LazySet{Float64},LazySets.LazySet{Float64}}" href="#Base.:*-Tuple{LazySets.LazySet{Float64},LazySets.LazySet{Float64}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">    *(X::LazySet, Y::LazySet)::CartesianProduct</code></pre><p>Return the Cartesian product of two convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>X</code> – convex set</p></li><li><p><code>Y</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>The Cartesian product of the two convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/CartesianProduct.jl#L47-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.CartesianProduct{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.CartesianProduct{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{&lt;:Real}, cp::CartesianProduct)::Bool</code></pre><p>Check whether a given point is contained in a Cartesian product set.</p><p><strong>Input</strong></p><ul><li><p><code>x</code>  – point/vector</p></li><li><p><code>cp</code> – Cartesian product</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ cp$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/CartesianProduct.jl#L147-L160">source</a></section><h3><a class="nav-anchor" id="n-ary-Cartesian-Product-1" href="#n-ary-Cartesian-Product-1"><span>$n$</span>-ary Cartesian Product</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CartesianProductArray" href="#LazySets.CartesianProductArray"><code>LazySets.CartesianProductArray</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CartesianProductArray{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the Cartesian product of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><p><code>sfarray</code> – array of sets</p></li></ul><p><strong>Notes</strong></p><ul><li><p><code>CartesianProductArray(sfarray::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>CartesianProductArray()</code> – constructor for an empty Cartesian product</p></li><li><p><code>CartesianProductArray(n::Int, [N]::Type=Float64)</code> – constructor for an empty Cartesian product with size hint and numeric type</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/CartesianProduct.jl#L171-L188">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(cpa::CartesianProductArray)::Int</code></pre><p>Return the dimension of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>cpa</code> – Cartesian product array</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Cartesian product of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/CartesianProduct.jl#L310-L323">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, cpa::CartesianProductArray{N, &lt;:LazySet{N}}
 )::AbstractVector{N} where {N&lt;:Real}</code></pre><p>Support vector of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>   – direction</p></li><li><p><code>cpa</code> – Cartesian product array</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the product sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/CartesianProduct.jl#L328-L343">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}},LazySets.LazySet{Float64}}" href="#Base.:*-Tuple{LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}},LazySets.LazySet{Float64}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">    *(X::LazySet, Y::LazySet)::CartesianProduct</code></pre><p>Return the Cartesian product of two convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>X</code> – convex set</p></li><li><p><code>Y</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>The Cartesian product of the two convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/CartesianProduct.jl#L47-L62">source</a><div><pre><code class="language-none">    *(cpa::CartesianProductArray, S::LazySet)::CartesianProductArray</code></pre><p>Multiply a convex set to a Cartesian product of a finite number of convex sets from the right.</p><p><strong>Input</strong></p><ul><li><p><code>cpa</code> – Cartesian product array (is modified)</p></li><li><p><code>S</code>   – convex set</p></li></ul><p><strong>Output</strong></p><p>The modified Cartesian product of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/CartesianProduct.jl#L205-L221">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{LazySets.LazySet{Float64},LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}}}" href="#Base.:*-Tuple{LazySets.LazySet{Float64},LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">    *(X::LazySet, Y::LazySet)::CartesianProduct</code></pre><p>Return the Cartesian product of two convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>X</code> – convex set</p></li><li><p><code>Y</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>The Cartesian product of the two convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/CartesianProduct.jl#L47-L62">source</a><div><pre><code class="language-none">    *(S::LazySet, cpa::CartesianProductArray)::CartesianProductArray</code></pre><p>Multiply a convex set to a Cartesian product of a finite number of convex sets from the left.</p><p><strong>Input</strong></p><ul><li><p><code>S</code>   – convex set</p></li><li><p><code>cpa</code> – Cartesian product array (is modified)</p></li></ul><p><strong>Output</strong></p><p>The modified Cartesian product of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/CartesianProduct.jl#L227-L243">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}},LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}}}" href="#Base.:*-Tuple{LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}},LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">    *(X::LazySet, Y::LazySet)::CartesianProduct</code></pre><p>Return the Cartesian product of two convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>X</code> – convex set</p></li><li><p><code>Y</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>The Cartesian product of the two convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/CartesianProduct.jl#L47-L62">source</a><div><pre><code class="language-none">    *(cpa::CartesianProductArray, S::LazySet)::CartesianProductArray</code></pre><p>Multiply a convex set to a Cartesian product of a finite number of convex sets from the right.</p><p><strong>Input</strong></p><ul><li><p><code>cpa</code> – Cartesian product array (is modified)</p></li><li><p><code>S</code>   – convex set</p></li></ul><p><strong>Output</strong></p><p>The modified Cartesian product of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/CartesianProduct.jl#L205-L221">source</a><div><pre><code class="language-none">    *(S::LazySet, cpa::CartesianProductArray)::CartesianProductArray</code></pre><p>Multiply a convex set to a Cartesian product of a finite number of convex sets from the left.</p><p><strong>Input</strong></p><ul><li><p><code>S</code>   – convex set</p></li><li><p><code>cpa</code> – Cartesian product array (is modified)</p></li></ul><p><strong>Output</strong></p><p>The modified Cartesian product of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/CartesianProduct.jl#L227-L243">source</a><div><pre><code class="language-none">    *(cpa1::CartesianProductArray, cpa2::CartesianProductArray)::CartesianProductArray</code></pre><p>Multiply a finite Cartesian product of convex sets to another finite Cartesian product.</p><p><strong>Input</strong></p><ul><li><p><code>cpa1</code> – first Cartesian product array (is modified)</p></li><li><p><code>cpa2</code> – second Cartesian product array</p></li></ul><p><strong>Output</strong></p><p>The modified first Cartesian product.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/CartesianProduct.jl#L287-L303">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, cpa::CartesianProductArray{N, &lt;:LazySet{N}}
 )::Bool  where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><p><code>x</code>   – point/vector</p></li><li><p><code>cpa</code> – Cartesian product array</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ \text{cpa}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/CartesianProduct.jl#L356-L371">source</a></section><h2><a class="nav-anchor" id="Convex-Hull-1" href="#Convex-Hull-1">Convex Hull</a></h2><h3><a class="nav-anchor" id="Binary-Convex-Hull-1" href="#Binary-Convex-Hull-1">Binary Convex Hull</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ConvexHull" href="#LazySets.ConvexHull"><code>LazySets.ConvexHull</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConvexHull{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the convex hull of the union of two convex sets.</p><p><strong>Fields</strong></p><ul><li><p><code>X</code> – convex set</p></li><li><p><code>Y</code> – convex set</p></li></ul><p><strong>Examples</strong></p><p>Convex hull of two 100-dimensional Euclidean balls:</p><pre><code class="language-julia-repl">julia&gt; b1, b2 = Ball2(zeros(100), 0.1), Ball2(4*ones(100), 0.2);

julia&gt; c = ConvexHull(b1, b2);

julia&gt; typeof(c)
LazySets.ConvexHull{Float64,LazySets.Ball2{Float64},LazySets.Ball2{Float64}}</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ConvexHull.jl#L8-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CH" href="#LazySets.CH"><code>LazySets.CH</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CH</code></pre><p>Alias for <code>ConvexHull</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ConvexHull.jl#L44-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.ConvexHull{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.ConvexHull{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(ch::ConvexHull)::Int</code></pre><p>Return the dimension of a convex hull of two convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>ch</code> – convex hull of two convex sets</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the convex hull of two convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ConvexHull.jl#L86-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.ConvexHull{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.ConvexHull{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, ch::ConvexHull)::AbstractVector{&lt;:Real}</code></pre><p>Return the support vector of a convex hull of two convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>  – direction</p></li><li><p><code>ch</code> – convex hull of two convex sets</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ConvexHull.jl#L103-L113">source</a></section><h3><a class="nav-anchor" id="n-ary-Convex-Hull-1" href="#n-ary-Convex-Hull-1"><span>$n$</span>-ary Convex Hull</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ConvexHullArray" href="#LazySets.ConvexHullArray"><code>LazySets.ConvexHullArray</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConvexHullArray{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the symbolic convex hull of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><p><code>array</code> – array of sets</p></li></ul><p><strong>Examples</strong></p><p>Convex hull of 100 two-dimensional balls whose centers follows a sinusoidal:</p><pre><code class="language-julia-repl">julia&gt; b = [Ball2([2*pi*i/100, sin(2*pi*i/100)], 0.05) for i in 1:100];

julia&gt; c = ConvexHullArray(b);</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ConvexHull.jl#L125-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CHArray" href="#LazySets.CHArray"><code>LazySets.CHArray</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CHArray</code></pre><p>Alias for <code>ConvexHullArray</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ConvexHull.jl#L160-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.ConvexHullArray}" href="#LazySets.dim-Tuple{LazySets.ConvexHullArray}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(cha::ConvexHullArray)::Int</code></pre><p>Return the dimension of the convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>cha</code> – convex hull array</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the convex hull of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ConvexHull.jl#L172-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.ConvexHullArray}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.ConvexHullArray}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, cha::ConvexHullArray)::AbstractVector{&lt;:Real}</code></pre><p>Return the support vector of a convex hull array in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>   – direction</p></li><li><p><code>cha</code> – convex hull array</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ConvexHull.jl#L190-L199">source</a></section><h3><a class="nav-anchor" id="Convex-Hull-Algorithms-1" href="#Convex-Hull-Algorithms-1">Convex Hull Algorithms</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.convex_hull" href="#LazySets.convex_hull"><code>LazySets.convex_hull</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">convex_hull(points::Vector{S}; [algorithm]::String=&quot;monotone_chain&quot;
           )::Vector{S} where {S&lt;:AbstractVector{N}} where {N&lt;:Real}</code></pre><p>Compute the convex hull of points in the plane.</p><p><strong>Input</strong></p><ul><li><p><code>points</code>    – list of 2D vectors</p></li><li><p><code>algorithm</code> – (optional, default: <code>&quot;monotone_chain&quot;</code>) the convex hull                algorithm, valid options are:</p><ul><li><p><code>&quot;monotone_chain&quot;</code></p></li><li><p><code>&quot;monotone_chain_sorted&quot;</code></p></li></ul></li></ul><p><strong>Output</strong></p><p>The convex hull as a list of 2D vectors with the coordinates of the points.</p><p><strong>Examples</strong></p><p>Compute the convex hull of a random set of points:</p><pre><code class="language-julia-repl">julia&gt; points = [randn(2) for i in 1:30]; # 30 random points in 2D

julia&gt; hull = convex_hull(points);

julia&gt; typeof(hull)
Array{Array{Float64,1},1}</code></pre><p>Plot both the random points and the computed convex hull polygon:</p><pre><code class="language-julia-repl">julia&gt; using Plots;

julia&gt; plot([Tuple(pi) for pi in points], seriestype=:scatter);

julia&gt; plot!(VPolygon(hull), alpha=0.2);</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/convex_hull_algorithms.jl#L1-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.convex_hull!" href="#LazySets.convex_hull!"><code>LazySets.convex_hull!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">convex_hull!(points::Vector{S}; [algorithm]::String=&quot;monotone_chain&quot;
            )::Vector{S} where {S&lt;:AbstractVector{N}} where {N&lt;:Real}</code></pre><p>Compute the convex hull of points in the plane, in-place.</p><p><strong>Input</strong></p><ul><li><p><code>points</code>    – list of 2D vectors (is modified)</p></li><li><p><code>algorithm</code> – (optional, default: <code>&quot;monotone_chain&quot;</code>) the convex hull                algorithm; valid options are:</p><ul><li><p><code>&quot;monotone_chain&quot;</code></p></li><li><p><code>&quot;monotone_chain_sorted&quot;</code></p></li></ul></li></ul><p><strong>Output</strong></p><p>The convex hull as a list of 2D vectors with the coordinates of the points.</p><p><strong>Notes</strong></p><p>See the non-modifying version <code>convex_hull</code> for more details.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/convex_hull_algorithms.jl#L48-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.right_turn" href="#LazySets.right_turn"><code>LazySets.right_turn</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">right_turn(O::AbstractVector{N}, A::AbstractVector{N}, B::AbstractVector{N}
          )::N where {N&lt;:Real}</code></pre><p>Determine if the acute angle defined by the three points <code>O</code>, <code>A</code>, <code>B</code> in the plane is a right turn (counter-clockwise) with respect to the center <code>O</code>.</p><p><strong>Input</strong></p><ul><li><p><code>O</code> – 2D center point</p></li><li><p><code>A</code> – 2D one point</p></li><li><p><code>B</code> – 2D another point</p></li></ul><p><strong>Output</strong></p><p>Scalar representing the rotation.</p><p><strong>Algorithm</strong></p><p>The <a href="https://en.wikipedia.org/wiki/Cross_product">cross product</a> is used to determine the sense of rotation. If the result is 0, the points are collinear; if it is positive, the three points constitute a positive angle of rotation around <code>O</code> from <code>A</code> to <code>B</code>; otherwise they constitute a negative angle.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/convex_hull_algorithms.jl#L85-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.monotone_chain!" href="#LazySets.monotone_chain!"><code>LazySets.monotone_chain!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">monotone_chain!(points::Vector{S}; sort::Bool=true
               )::Vector{S} where {S&lt;:AbstractVector{N}} where {N&lt;:Real}</code></pre><p>Compute the convex hull of points in the plane using Andrew&#39;s monotone chain method.</p><p><strong>Input</strong></p><ul><li><p><code>points</code> – list of 2D vectors; is sorted in-place inside this function</p></li><li><p><code>sort</code>   – (optional, default: <code>true</code>) flag for sorting the vertices             lexicographically; sortedness is required for correctness</p></li></ul><p><strong>Output</strong></p><p>List of vectors containing the 2D coordinates of the corner points of the convex hull.</p><p><strong>Notes</strong></p><p>For large sets of points, it is convenient to use static vectors to get maximum performance. For information on how to convert usual vectors into static vectors, see the type <code>SVector</code> provided by the <a href="http://juliaarrays.github.io/StaticArrays.jl/stable/">StaticArrays</a> package.</p><p><strong>Algorithm</strong></p><p>This function implements Andrew&#39;s monotone chain convex hull algorithm to construct the convex hull of a set of <span>$n$</span> points in the plane in <span>$O(n \log n)$</span> time. For further details see <a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain">Monotone chain</a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/convex_hull_algorithms.jl#L115-L148">source</a></section><h2><a class="nav-anchor" id="Intersection-1" href="#Intersection-1">Intersection</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Intersection" href="#LazySets.Intersection"><code>LazySets.Intersection</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Intersection{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the intersection of two convex sets.</p><p><strong>Fields</strong></p><ul><li><p><code>X</code> – convex set</p></li><li><p><code>Y</code> – convex set</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/Intersection.jl#L5-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.Intersection{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.Intersection{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(cap::Intersection)::Int</code></pre><p>Return the dimension of an intersection of two convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>cap</code> – intersection of two convex sets</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the intersection of two convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/Intersection.jl#L76-L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Intersection{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Intersection{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, cap::Intersection)::AbstractVector{&lt;:Real}</code></pre><p>Return the support vector of an intersection of two convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>   – direction</p></li><li><p><code>cap</code> – intersection of two convex sets</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/Intersection.jl#L93-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.Intersection{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.Intersection{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, cap::Intersection{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a intersection of two convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>cap</code> – intersection of two convex sets</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ cap$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/Intersection.jl#L115-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{LazySets.Intersection{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#Base.isempty-Tuple{LazySets.Intersection{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isempty(cap::Intersection)::Bool</code></pre><p>Return if the intersection is empty or not.</p><p><strong>Input</strong></p><ul><li><p><code>cap</code> – intersection of two convex sets</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff the intersection is empty.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/Intersection.jl#L137-L149">source</a></section><h2><a class="nav-anchor" id="Minkowski-Sum-1" href="#Minkowski-Sum-1">Minkowski Sum</a></h2><h3><a class="nav-anchor" id="Binary-Minkowski-Sum-1" href="#Binary-Minkowski-Sum-1">Binary Minkowski Sum</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.MinkowskiSum" href="#LazySets.MinkowskiSum"><code>LazySets.MinkowskiSum</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">MinkowskiSum{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the Minkowski sum of two convex sets.</p><p><strong>Fields</strong></p><ul><li><p><code>X</code> – first convex set</p></li><li><p><code>Y</code> – second convex set</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L6-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.MinkowskiSum{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.MinkowskiSum{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(ms::MinkowskiSum)::Int</code></pre><p>Return the dimension of a Minkowski sum.</p><p><strong>Input</strong></p><ul><li><p><code>ms</code> – Minkowski sum</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Minkowski sum.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L96-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.MinkowskiSum{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.MinkowskiSum{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, ms::MinkowskiSum)::AbstractVector{&lt;:Real}</code></pre><p>Return the support vector of a Minkowski sum.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>  – direction</p></li><li><p><code>ms</code> – Minkowski sum</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L113-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{LazySets.LazySet{Float64},LazySets.LazySet{Float64}}" href="#Base.:+-Tuple{LazySets.LazySet{Float64},LazySets.LazySet{Float64}}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">X + Y</code></pre><p>Convenience constructor for Minkowski sum.</p><p><strong>Input</strong></p><ul><li><p><code>X</code> – a convex set</p></li><li><p><code>Y</code> – another convex set</p></li></ul><p><strong>Output</strong></p><p>The symbolic Minkowski sum of <span>$X$</span> and <span>$Y$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L29-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.:⊕" href="#LazySets.:⊕"><code>LazySets.:⊕</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">⊕(X::LazySet, Y::LazySet)</code></pre><p>Unicode alias constructor <code>oplus</code> for the Minkowski sum operator <code>+(X, Y)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L45-L49">source</a></section><h3><a class="nav-anchor" id="n-ary-Minkowski-Sum-1" href="#n-ary-Minkowski-Sum-1"><span>$n$</span>-ary Minkowski Sum</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.MinkowskiSumArray" href="#LazySets.MinkowskiSumArray"><code>LazySets.MinkowskiSumArray</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">MinkowskiSumArray{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the Minkowski sum of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><p><code>sfarray</code> – array of convex sets</p></li></ul><p><strong>Notes</strong></p><p>This type assumes that the dimensions of all elements match.</p><ul><li><p><code>MinkowskiSumArray(sfarray::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>MinkowskiSumArray()</code> – constructor for an empty sum</p></li><li><p><code>MinkowskiSumArray(n::Int, [N]::Type=Float64)</code> – constructor for an empty sum with size hint and numeric type</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L136-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(msa::MinkowskiSumArray)::Int</code></pre><p>Return the dimension of a Minkowski sum of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><p><code>msa</code> – Minkowski sum array</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Minkowski sum of a finite number of sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L284-L296">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, msa::MinkowskiSumArray)::Vector{&lt;:Real}</code></pre><p>Return the support vector of a Minkowski sum of a finite number of sets in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>   – direction</p></li><li><p><code>msa</code> – Minkowski sum array</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L301-L317">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}},LazySets.LazySet{Float64}}" href="#Base.:+-Tuple{LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}},LazySets.LazySet{Float64}}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">X + Y</code></pre><p>Convenience constructor for Minkowski sum.</p><p><strong>Input</strong></p><ul><li><p><code>X</code> – a convex set</p></li><li><p><code>Y</code> – another convex set</p></li></ul><p><strong>Output</strong></p><p>The symbolic Minkowski sum of <span>$X$</span> and <span>$Y$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L29-L42">source</a><div><pre><code class="language-none">+(msa::MinkowskiSumArray, S::LazySet)::MinkowskiSumArray</code></pre><p>Add a convex set to a Minkowski sum of a finite number of convex sets from the right.</p><p><strong>Input</strong></p><ul><li><p><code>msa</code> – Minkowski sum array (is modified)</p></li><li><p><code>S</code>   – convex set</p></li></ul><p><strong>Output</strong></p><p>The modified Minkowski sum of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L172-L186">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{LazySets.LazySet{Float64},LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}}}" href="#Base.:+-Tuple{LazySets.LazySet{Float64},LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}}}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">X + Y</code></pre><p>Convenience constructor for Minkowski sum.</p><p><strong>Input</strong></p><ul><li><p><code>X</code> – a convex set</p></li><li><p><code>Y</code> – another convex set</p></li></ul><p><strong>Output</strong></p><p>The symbolic Minkowski sum of <span>$X$</span> and <span>$Y$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L29-L42">source</a><div><pre><code class="language-none">+(S::LazySet, msa::MinkowskiSumArray)::MinkowskiSumArray</code></pre><p>Add a convex set to a Minkowski sum of a finite number of convex sets from the left.</p><p><strong>Input</strong></p><ul><li><p><code>S</code>   – convex set</p></li><li><p><code>msa</code> – Minkowski sum array (is modified)</p></li></ul><p><strong>Output</strong></p><p>The modified Minkowski sum of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L192-L206">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}},LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}}}" href="#Base.:+-Tuple{LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}},LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}}}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">X + Y</code></pre><p>Convenience constructor for Minkowski sum.</p><p><strong>Input</strong></p><ul><li><p><code>X</code> – a convex set</p></li><li><p><code>Y</code> – another convex set</p></li></ul><p><strong>Output</strong></p><p>The symbolic Minkowski sum of <span>$X$</span> and <span>$Y$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L29-L42">source</a><div><pre><code class="language-none">+(msa::MinkowskiSumArray, S::LazySet)::MinkowskiSumArray</code></pre><p>Add a convex set to a Minkowski sum of a finite number of convex sets from the right.</p><p><strong>Input</strong></p><ul><li><p><code>msa</code> – Minkowski sum array (is modified)</p></li><li><p><code>S</code>   – convex set</p></li></ul><p><strong>Output</strong></p><p>The modified Minkowski sum of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L172-L186">source</a><div><pre><code class="language-none">+(S::LazySet, msa::MinkowskiSumArray)::MinkowskiSumArray</code></pre><p>Add a convex set to a Minkowski sum of a finite number of convex sets from the left.</p><p><strong>Input</strong></p><ul><li><p><code>S</code>   – convex set</p></li><li><p><code>msa</code> – Minkowski sum array (is modified)</p></li></ul><p><strong>Output</strong></p><p>The modified Minkowski sum of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L192-L206">source</a><div><pre><code class="language-none">+(msa1::MinkowskiSumArray, msa2::MinkowskiSumArray)::MinkowskiSumArray</code></pre><p>Add the elements of a finite Minkowski sum of convex sets to another finite Minkowski sum.</p><p><strong>Input</strong></p><ul><li><p><code>msa1</code> – first Minkowski sum array (is modified)</p></li><li><p><code>msa2</code> – second Minkowski sum array</p></li></ul><p><strong>Output</strong></p><p>The modified first Minkowski sum of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L212-L226">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}},LazySets.ZeroSet{Float64}}" href="#Base.:+-Tuple{LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}},LazySets.ZeroSet{Float64}}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">X + Y</code></pre><p>Convenience constructor for Minkowski sum.</p><p><strong>Input</strong></p><ul><li><p><code>X</code> – a convex set</p></li><li><p><code>Y</code> – another convex set</p></li></ul><p><strong>Output</strong></p><p>The symbolic Minkowski sum of <span>$X$</span> and <span>$Y$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L29-L42">source</a><div><pre><code class="language-none">+(msa::MinkowskiSumArray, S::LazySet)::MinkowskiSumArray</code></pre><p>Add a convex set to a Minkowski sum of a finite number of convex sets from the right.</p><p><strong>Input</strong></p><ul><li><p><code>msa</code> – Minkowski sum array (is modified)</p></li><li><p><code>S</code>   – convex set</p></li></ul><p><strong>Output</strong></p><p>The modified Minkowski sum of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L172-L186">source</a><div><pre><code class="language-none">+(msa::MinkowskiSumArray, Z::ZeroSet)::MinkowskiSumArray</code></pre><p>Returns the original array because addition with an empty set is a no-op.</p><p><strong>Input</strong></p><ul><li><p><code>msa</code> – Minkowski sum array</p></li><li><p><code>Z</code>  – a Zero set</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/MinkowskiSum.jl#L232-L241">source</a></section><h2><a class="nav-anchor" id="Maps-1" href="#Maps-1">Maps</a></h2><h3><a class="nav-anchor" id="Linear-Map-1" href="#Linear-Map-1">Linear Map</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.LinearMap" href="#LazySets.LinearMap"><code>LazySets.LinearMap</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LinearMap{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents a linear transformation <span>$M⋅S$</span> of a convex set <span>$S$</span>.</p><p><strong>Fields</strong></p><ul><li><p><code>M</code>  – matrix/linear map</p></li><li><p><code>sf</code> – convex set</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/LinearMap.jl#L5-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.LinearMap{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.LinearMap{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(lm::LinearMap)::Int</code></pre><p>Return the dimension of a linear map.</p><p><strong>Input</strong></p><ul><li><p><code>lm</code> – linear map</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the linear map.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/LinearMap.jl#L89-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.LinearMap{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.LinearMap{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, lm::LinearMap)::AbstractVector{&lt;:Real}</code></pre><p>Return the support vector of the linear map.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>  – direction</p></li><li><p><code>lm</code> – linear map</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$L = M⋅S$</span>, where <span>$M$</span> is a matrix and <span>$S$</span> is a convex set, it follows that <span>$σ(d, L) = M⋅σ(M^T d, S)$</span> for any direction <span>$d$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/LinearMap.jl#L106-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{AbstractArray{Float64,2},LazySets.LazySet{Float64}}" href="#Base.:*-Tuple{AbstractArray{Float64,2},LazySets.LazySet{Float64}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">    *(M::AbstractMatrix{&lt;:Real}, S::LazySet)</code></pre><p>Return the linear map of a convex set.</p><p><strong>Input</strong></p><ul><li><p><code>M</code> – matrix/linear map</p></li><li><p><code>S</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>If the matrix is null, a <code>ZeroSet</code> is returned; otherwise a lazy linear map.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/LinearMap.jl#L24-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{Float64,LazySets.LazySet{Float64}}" href="#Base.:*-Tuple{Float64,LazySets.LazySet{Float64}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">    *(a::N, X::S)::LinearMap{N, S} where {S&lt;:LazySet{N}} where {N&lt;:Real}</code></pre><p>Return a linear map of a convex set by a scalar value.</p><p><strong>Input</strong></p><ul><li><p><code>a</code> – real scalar</p></li><li><p><code>S</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>The linear map of the convex set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/LinearMap.jl#L49-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.LinearMap{Float64,LazySets.LazySet{Float64}}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.LinearMap{Float64,LazySets.LazySet{Float64}}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, lm::LinearMap{N, &lt;:LazySet})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a linear map of a convex set.</p><p><strong>Input</strong></p><ul><li><p><code>x</code>  – point/vector</p></li><li><p><code>lm</code> – linear map of a convex set</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ lm$</span>.</p><p><strong>Algorithm</strong></p><p>Note that <span>$x ∈ M⋅S$</span> iff <span>$M^{-1}⋅x ∈ S$</span>. This implementation does not explicitly invert the matrix, which is why it also works for non-square matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; lm = LinearMap([2.0 0.0; 0.0 1.0], BallInf([1., 1.], 1.));

julia&gt; ∈([5.0, 1.0], lm)
false
julia&gt; ∈([3.0, 1.0], lm)
true</code></pre><p>An example with non-square matrix:</p><pre><code class="language-julia-repl">julia&gt; B = BallInf(zeros(4), 1.);

julia&gt; M = [1. 0 0 0; 0 1 0 0]/2;

julia&gt; ∈([0.5, 0.5], M*B)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/LinearMap.jl#L130-L170">source</a></section><h3><a class="nav-anchor" id="Exponential-Map-1" href="#Exponential-Map-1">Exponential Map</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ExponentialMap" href="#LazySets.ExponentialMap"><code>LazySets.ExponentialMap</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ExponentialMap{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the action of an exponential map on a convex set.</p><p><strong>Fields</strong></p><ul><li><p><code>spmexp</code> – sparse matrix exponential</p></li><li><p><code>X</code>      – convex set</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ExponentialMap.jl#L91-L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.ExponentialMap{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.ExponentialMap{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(em::ExponentialMap)::Int</code></pre><p>Return the dimension of an exponential map.</p><p><strong>Input</strong></p><ul><li><p><code>em</code> – an ExponentialMap</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the exponential map.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ExponentialMap.jl#L129-L141">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.ExponentialMap{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.ExponentialMap{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, em::ExponentialMap)::AbstractVector{N} where {N&lt;:Real}</code></pre><p>Return the support vector of the exponential map.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>  – direction</p></li><li><p><code>em</code> – exponential map</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$E = \exp(M)⋅S$</span>, where <span>$M$</span> is a matrix and <span>$S$</span> is a convex set, it follows that <span>$σ(d, E) = \exp(M)⋅σ(\exp(M)^T d, S)$</span> for any direction <span>$d$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ExponentialMap.jl#L146-L165">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.ExponentialMap{Float64,LazySets.LazySet{Float64}}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.ExponentialMap{Float64,LazySets.LazySet{Float64}}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, em::ExponentialMap{&lt;:LazySet{N}})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in an exponential map of a convex set.</p><p><strong>Input</strong></p><ul><li><p><code>x</code>  – point/vector</p></li><li><p><code>em</code> – linear map of a convex set</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ em$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation exploits that <span>$x ∈ \exp(M)⋅S$</span> iff <span>$\exp(-M)⋅x ∈ S$</span>. This follows from <span>$\exp(-M)⋅\exp(M) = I$</span> for any <span>$M$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; em = ExponentialMap(SparseMatrixExp(SparseMatrixCSC([2.0 0.0; 0.0 1.0])),
                           BallInf([1., 1.], 1.));

julia&gt; ∈([5.0, 1.0], em)
false
julia&gt; ∈([1.0, 1.0], em)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ExponentialMap.jl#L171-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ExponentialProjectionMap" href="#LazySets.ExponentialProjectionMap"><code>LazySets.ExponentialProjectionMap</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ExponentialProjectionMap{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the application of a projection of a sparse matrix exponential to a convex set.</p><p><strong>Fields</strong></p><ul><li><p><code>spmexp</code> – projection of a sparse matrix exponential</p></li><li><p><code>X</code>      – convex set</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ExponentialMap.jl#L225-L235">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.ExponentialProjectionMap{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.ExponentialProjectionMap{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(eprojmap::ExponentialProjectionMap)::Int</code></pre><p>Return the dimension of a projection of an exponential map.</p><p><strong>Input</strong></p><ul><li><p><code>eprojmap</code> – projection of an exponential map</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the projection of an exponential map.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ExponentialMap.jl#L269-L281">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.ExponentialProjectionMap{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.ExponentialProjectionMap{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N},
  eprojmap::ExponentialProjectionMap)::AbstractVector{N} where {N&lt;:Real}</code></pre><p>Return the support vector of a projection of an exponential map.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>        – direction</p></li><li><p><code>eprojmap</code> – projection of an exponential map</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$S = (L⋅M⋅R)⋅X$</span>, where <span>$L$</span> and <span>$R$</span> are matrices, <span>$M$</span> is a matrix exponential, and <span>$X$</span> is a set, it follows that <span>$σ(d, S) = L⋅M⋅R⋅σ(R^T⋅M^T⋅L^T⋅d, X)$</span> for any direction <span>$d$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ExponentialMap.jl#L286-L307">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.SparseMatrixExp" href="#LazySets.SparseMatrixExp"><code>LazySets.SparseMatrixExp</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SparseMatrixExp{N}</code></pre><p>Type that represents the matrix exponential, <span>$\exp(M)$</span>, of a sparse matrix.</p><p><strong>Fields</strong></p><ul><li><p><code>M</code> – sparse matrix</p></li></ul><p><strong>Notes</strong></p><p>This type is provided for use with very large and very sparse matrices. The evaluation of the exponential matrix action over vectors relies on the <a href="https://github.com/acroy/Expokit.jl">Expokit</a> package.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ExponentialMap.jl#L15-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{LazySets.SparseMatrixExp{Float64},LazySets.LazySet{Float64}}" href="#Base.:*-Tuple{LazySets.SparseMatrixExp{Float64},LazySets.LazySet{Float64}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">    *(spmexp::SparseMatrixExp, X::LazySet)::ExponentialMap</code></pre><p>Return the exponential map of a convex set from a sparse matrix exponential.</p><p><strong>Input</strong></p><ul><li><p><code>spmexp</code> – sparse matrix exponential</p></li><li><p><code>X</code>      – convex set</p></li></ul><p><strong>Output</strong></p><p>The exponential map of the convex set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ExponentialMap.jl#L109-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ProjectionSparseMatrixExp" href="#LazySets.ProjectionSparseMatrixExp"><code>LazySets.ProjectionSparseMatrixExp</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ProjectionSparseMatrixExp{N&lt;:Real}</code></pre><p>Type that represents the projection of a sparse matrix exponential, i.e., <span>$L⋅\exp(M)⋅R$</span> for a given sparse matrix <span>$M$</span>.</p><p><strong>Fields</strong></p><ul><li><p><code>L</code> – left multiplication matrix</p></li><li><p><code>E</code> – sparse matrix exponential</p></li><li><p><code>R</code> – right multiplication matrix</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ExponentialMap.jl#L207-L218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{LazySets.ProjectionSparseMatrixExp{Float64},LazySets.LazySet{Float64}}" href="#Base.:*-Tuple{LazySets.ProjectionSparseMatrixExp{Float64},LazySets.LazySet{Float64}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">    *(projspmexp::ProjectionSparseMatrixExp,
      X::LazySet)::ExponentialProjectionMap</code></pre><p>Return the application of a projection of a sparse matrix exponential to a convex set.</p><p><strong>Input</strong></p><ul><li><p><code>projspmexp</code> – projection of a sparse matrix exponential</p></li><li><p><code>X</code>          – convex set</p></li></ul><p><strong>Output</strong></p><p>The application of the projection of a sparse matrix exponential to the convex set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/ExponentialMap.jl#L245-L263">source</a></section><h2><a class="nav-anchor" id="Symmetric-Interval-Hull-1" href="#Symmetric-Interval-Hull-1">Symmetric Interval Hull</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.SymmetricIntervalHull" href="#LazySets.SymmetricIntervalHull"><code>LazySets.SymmetricIntervalHull</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SymmetricIntervalHull{N&lt;:Real, S&lt;:LazySet{N}} &lt;: AbstractHyperrectangle{N}</code></pre><p>Type that represents the symmetric interval hull of a convex set.</p><p><strong>Fields</strong></p><ul><li><p><code>X</code>     – convex set</p></li><li><p><code>cache</code> – partial storage of already computed bounds, organized as mapping   from dimension to tuples <code>(bound, valid)</code>, where <code>valid</code> is a flag   indicating if the <code>bound</code> entry has been computed</p></li></ul><p><strong>Notes</strong></p><p>The symmetric interval hull can be computed with <span>$2n$</span> support vector queries of unit vectors, where <span>$n$</span> is the dimension of the wrapped set (i.e., two queries per dimension). When asking for the support vector for a direction <span>$d$</span>, one needs <span>$2k$</span> such queries, where <span>$k$</span> is the number of non-zero entries in <span>$d$</span>.</p><p>However, if one asks for many support vectors in a loop, the number of computations may exceed <span>$2n$</span>. To be most efficient in such cases, this type stores the intermediately computed bounds in the <code>cache</code> field.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/SymmetricIntervalHull.jl#L4-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.SymmetricIntervalHull{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.SymmetricIntervalHull{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(P::AbstractPointSymmetricPolytope)::Int</code></pre><p>Return the ambient dimension of a point symmetric set.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – set</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/AbstractPointSymmetricPolytope.jl#L40-L52">source</a><div><pre><code class="language-none">dim(sih::SymmetricIntervalHull)::Int</code></pre><p>Return the dimension of a symmetric interval hull of a convex set.</p><p><strong>Input</strong></p><ul><li><p><code>sih</code> – symmetric interval hull of a convex set</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the symmetric interval hull of a convex set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/SymmetricIntervalHull.jl#L144-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.SymmetricIntervalHull{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.SymmetricIntervalHull{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, H::AbstractHyperrectangle{N}
 )::AbstractVector{N} where {N&lt;:Real}</code></pre><p>Return the support vector of a hyperrectangular set in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>H</code> – hyperrectangular set</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the vertex with biggest values is returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/AbstractHyperrectangle.jl#L63-L78">source</a><div><pre><code class="language-none">σ(d::AbstractVector{N}, sih::SymmetricIntervalHull
 )::AbstractVector{&lt;:Real} where {N&lt;:Real}</code></pre><p>Return the support vector of a symmetric interval hull of a convex set in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>   – direction</p></li><li><p><code>sih</code> – symmetric interval hull of a convex set</p></li></ul><p><strong>Output</strong></p><p>The support vector of the symmetric interval hull of a convex set in the given direction. If the direction has norm zero, the origin is returned.</p><p><strong>Algorithm</strong></p><p>For each non-zero entry in <code>d</code> we need to either look up the bound (if it has been computed before) or compute it, in which case we store it for future queries. One such computation just asks for the support vector of the underlying set for both the positive and negative unit vector in the respective dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/SymmetricIntervalHull.jl#L161-L186">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{LazySets.SymmetricIntervalHull{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.an_element-Tuple{LazySets.SymmetricIntervalHull{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(P::AbstractPointSymmetricPolytope{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a point symmetric polytope.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – point symmetric polytope</p></li></ul><p><strong>Output</strong></p><p>The center of the point symmetric polytope.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/db2f42a903f8b4fdeb9b58ec32b6b7ea7d76757b/src/AbstractPointSymmetricPolytope.jl#L58-L70">source</a></section><footer><hr/><a class="previous" href="representations.html"><span class="direction">Previous</span><span class="title">Common Set Representations</span></a><a class="next" href="binary_functions.html"><span class="direction">Next</span><span class="title">Binary Functions on Sets</span></a></footer></article></body></html>
