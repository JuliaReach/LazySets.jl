var documenterSearchIndex = {"docs":
[{"location":"lib/lazy_operations/Bloating/","page":"Bloating","title":"Bloating","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/lazy_operations/Bloating/#def_Bloating","page":"Bloating","title":"Bloating","text":"","category":"section"},{"location":"lib/lazy_operations/Bloating/","page":"Bloating","title":"Bloating","text":"Bloating\ndim(::Bloating)\nσ(::AbstractVector{N}, ::Bloating{N}) where {N<:AbstractFloat}\nρ(::AbstractVector{N}, ::Bloating{N}) where {N<:AbstractFloat}\nisbounded(::Bloating)\nisempty(::Bloating)\nan_element(::Bloating)","category":"page"},{"location":"lib/lazy_operations/Bloating/#LazySets.Bloating","page":"Bloating","title":"LazySets.Bloating","text":"Bloating{N<:AbstractFloat, S<:LazySet{N}} <:LazySet{N}\n\nType that represents a uniform expansion of a convex set in a given norm (also known as bloating).\n\nFields\n\nX – convex set\nε – (positive) bloating factor\np – p-norm ( 1; default: 2)\n\nNotes\n\nBloating(X, ε, p) is equivalent to the Minkowski sum of X and a ball in the p-norm of radius ε centered in the origin O (i.e., X ⊕ Ballp(p, O, ε)).\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/Bloating/#LazySets.dim-Tuple{Bloating}","page":"Bloating","title":"LazySets.dim","text":"dim(B::Bloating)\n\nReturn the dimension of a bloated convex set.\n\nInput\n\nB – bloated convex set\n\nOutput\n\nThe ambient dimension of the bloated set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Bloating/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Bloating{N,S} where S<:LazySet{N}}} where N<:AbstractFloat","page":"Bloating","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, B::Bloating{N}) where {N<:AbstractFloat}\n\nReturn the support vector of a bloated convex set in a given direction.\n\nInput\n\nd – direction\nB – bloated convex set\n\nOutput\n\nThe support vector of the bloated set in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Bloating/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Bloating{N,S} where S<:LazySet{N}}} where N<:AbstractFloat","page":"Bloating","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, B::Bloating{N}) where {N<:AbstractFloat}\n\nReturn the support function of a bloated convex set in a given direction.\n\nInput\n\nd – direction\nB – bloated convex set\n\nOutput\n\nThe support function of the bloated set in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Bloating/#LazySets.isbounded-Tuple{Bloating}","page":"Bloating","title":"LazySets.isbounded","text":"isbounded(B::Bloating)\n\nDetermine whether a bloated convex set is bounded.\n\nInput\n\nB – bloated convex set\n\nOutput\n\ntrue iff the wrapped set is bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Bloating/#Base.isempty-Tuple{Bloating}","page":"Bloating","title":"Base.isempty","text":"isempty(B::Bloating)\n\nDetermine whether a bloated convex set is empty.\n\nInput\n\nB – bloated convex set\n\nOutput\n\ntrue iff the wrapped set is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Bloating/#LazySets.an_element-Tuple{Bloating}","page":"Bloating","title":"LazySets.an_element","text":"an_element(B::Bloating)\n\nReturn some element of a bloated convex set.\n\nInput\n\nB – bloated convex set\n\nOutput\n\nAn element in the bloated convex set.\n\nAlgorithm\n\nThe implementation returns the result of an_element for the wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/","page":"Ellipsoid","title":"Ellipsoid","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/Ellipsoid/#def_Ellipsoid","page":"Ellipsoid","title":"Ellipsoid","text":"","category":"section"},{"location":"lib/sets/Ellipsoid/","page":"Ellipsoid","title":"Ellipsoid","text":"Ellipsoid\nρ(::AbstractVector{N}, ::Ellipsoid{N}) where {N<:AbstractFloat}\nσ(::AbstractVector{N}, ::Ellipsoid{N}) where {N<:AbstractFloat}\n∈(::AbstractVector{N}, ::Ellipsoid{N}) where {N<:AbstractFloat}\nrand(::Type{Ellipsoid})\ncenter(::Ellipsoid{N}) where {N<:AbstractFloat}\nshape_matrix(::Ellipsoid{N}) where {N<:AbstractFloat}\ntranslate(::Ellipsoid{N}, ::AbstractVector{N}) where {N<:AbstractFloat}","category":"page"},{"location":"lib/sets/Ellipsoid/#LazySets.Ellipsoid","page":"Ellipsoid","title":"LazySets.Ellipsoid","text":"Ellipsoid{N<:AbstractFloat, VN<:AbstractVector{N},\n          MN<:AbstractMatrix{N}} <: AbstractCentrallySymmetric{N}\n\nType that represents an ellipsoid.\n\nIt is defined as the set\n\nE = left x  mathbbR^n  (x-c)^T Q^-1 (x-c)  1 right\n\nwhere c in mathbbR^n is its center and Q in mathbbR^nn its shape matrix, which should be a positive definite matrix. An ellipsoid can also be characterized as the image of a Euclidean ball by an invertible linear transformation. It is the higher-dimensional generalization of an ellipse.\n\nFields\n\ncenter       – center of the ellipsoid\nshape_matrix – real positive definite matrix, i.e. it is equal to its transpose                   and x^mathrmTQx  0 for all nonzero x\n\nNotes\n\nBy default, the inner constructor checks that the given shape matrix is positive definite. Use the flag check_posdef=false to disable this check.\n\nExamples\n\nAn ellipsoid can be created passing its center and shape matrix (which should be positive definite).\n\nFor instance, we create a two-dimensional ellipsoid with center [1, 1]:\n\njulia> using LinearAlgebra\n\njulia> E = Ellipsoid(ones(2), Diagonal([2.0, 0.5]))\nEllipsoid{Float64,Array{Float64,1},Diagonal{Float64,Array{Float64,1}}}([1.0, 1.0], [2.0 0.0; 0.0 0.5])\n\nIf the center is not specified, it is assumed that it is the origin. For instance, a three-dimensional ellipsoid centered at the origin and the shape matrix being the identity can be created with:\n\njulia> E = Ellipsoid(Matrix(1.0I, 3, 3))\nEllipsoid{Float64,Array{Float64,1},Array{Float64,2}}([0.0, 0.0, 0.0], [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])\n\njulia> dim(E)\n3\n\nThe center and shape matrix of the ellipsoid can be retrieved with the functions center and shape_matrix respectively:\n\njulia> center(E)\n3-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\n\njulia> shape_matrix(E)\n3×3 Array{Float64,2}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\nThe function an_element returns some element of the ellipsoid:\n\njulia> an_element(E)\n3-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\n\njulia> an_element(E) ∈ E\ntrue\n\nWe can evaluate its support vector in a given direction, say [1, 1, 1]:\n\njulia> σ(ones(3), E)\n3-element Array{Float64,1}:\n 0.5773502691896258\n 0.5773502691896258\n 0.5773502691896258\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Ellipsoid/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ellipsoid{N,VN,MN} where MN<:AbstractArray{N,2} where VN<:AbstractArray{N,1}}} where N<:AbstractFloat","page":"Ellipsoid","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, E::Ellipsoid{N}) where {N<:AbstractFloat}\n\nReturn the support function of an ellipsoid in a given direction.\n\nInput\n\nd – direction\nE – ellipsoid\n\nOutput\n\nThe support function of the ellipsoid in the given direction.\n\nAlgorithm\n\nThe support value is cᵀ d + Bᵀ d₂ where c is the center and Q = B Bᵀ is the shape matrix of E.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ellipsoid{N,VN,MN} where MN<:AbstractArray{N,2} where VN<:AbstractArray{N,1}}} where N<:AbstractFloat","page":"Ellipsoid","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, E::Ellipsoid{N}) where {N<:AbstractFloat}\n\nReturn the support vector of an ellipsoid in a given direction.\n\nInput\n\nd – direction\nE – ellipsoid\n\nOutput\n\nSupport vector in the given direction.\n\nAlgorithm\n\nLet E be an ellipsoid of center c and shape matrix Q = BB^mathrmT. Its support vector along direction d can be deduced from that of the unit Euclidean ball mathcalB_2 using the algebraic relations for the support vector,\n\nσ_BmathcalB_2  c(d) = c + Bσ_mathcalB_2 (B^mathrmT d)\n= c + dfracQdsqrtd^mathrmTQ d\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ellipsoid{N,VN,MN} where MN<:AbstractArray{N,2} where VN<:AbstractArray{N,1}}} where N<:AbstractFloat","page":"Ellipsoid","title":"Base.:∈","text":"∈(x::AbstractVector{N}, E::Ellipsoid{N}) where {N<:AbstractFloat}\n\nCheck whether a given point is contained in an ellipsoid.\n\nInput\n\nx – point/vector\nE – ellipsoid\n\nOutput\n\ntrue iff x ∈ E.\n\nAlgorithm\n\nThe point x belongs to the ellipsoid of center c and shape matrix Q if and only if\n\n(x-c)^mathrmT Q^-1 (x-c)  1\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/#Base.rand-Tuple{Type{Ellipsoid}}","page":"Ellipsoid","title":"Base.rand","text":"rand(::Type{Ellipsoid}; [N]::Type{<:AbstractFloat}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nCreate a random ellipsoid.\n\nInput\n\nEllipsoid – type for dispatch\nN         – (optional, default: Float64) numeric type\ndim       – (optional, default: 2) dimension\nrng       – (optional, default: GLOBAL_RNG) random number generator\nseed      – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random ellipsoid.\n\nAlgorithm\n\nThe center is a normally distributed vector with entries of mean 0 and standard deviation 1.\n\nThe idea for the shape matrix comes from here. The matrix is symmetric positive definite, but also diagonally dominant.\n\nQ =  frac12(S + S^T) + nI\n\nwhere n = dim (defaults to 2), and S is a n times n random matrix whose coefficients are uniformly distributed in the interval -1 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/#LazySets.center-Union{Tuple{Ellipsoid{N,VN,MN} where MN<:AbstractArray{N,2} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:AbstractFloat","page":"Ellipsoid","title":"LazySets.center","text":"center(E::Ellipsoid{N}) where {N<:AbstractFloat}\n\nReturn the center of the ellipsoid.\n\nInput\n\nE – ellipsoid\n\nOutput\n\nThe center of the ellipsoid.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/#LazySets.shape_matrix-Union{Tuple{Ellipsoid{N,VN,MN} where MN<:AbstractArray{N,2} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:AbstractFloat","page":"Ellipsoid","title":"LazySets.shape_matrix","text":"shape_matrix(E::Ellipsoid{N}) where {N<:AbstractFloat}\n\nReturn the shape matrix of the ellipsoid.\n\nInput\n\nE – ellipsoid\n\nOutput\n\nThe shape matrix of the ellipsoid.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/#LazySets.translate-Union{Tuple{N}, Tuple{Ellipsoid{N,VN,MN} where MN<:AbstractArray{N,2} where VN<:AbstractArray{N,1},AbstractArray{N,1}}} where N<:AbstractFloat","page":"Ellipsoid","title":"LazySets.translate","text":"translate(E::Ellipsoid{N}, v::AbstractVector{N}; share::Bool=false\n         ) where {N<:AbstractFloat}\n\nTranslate (i.e., shift) an ellipsoid by a given vector.\n\nInput\n\nE     – ellipsoid\nv     – translation vector\nshare – (optional, default: false) flag for sharing unmodified parts of            the original set representation\n\nOutput\n\nA translated ellipsoid.\n\nNotes\n\nThe shape matrix is shared with the original ellipsoid if share == true.\n\nAlgorithm\n\nWe add the vector to the center of the ellipsoid.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ellipsoid/","page":"Ellipsoid","title":"Ellipsoid","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Ellipsoid/","page":"Ellipsoid","title":"Ellipsoid","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/sets/Ellipsoid/","page":"Ellipsoid","title":"Ellipsoid","text":"Inherited from AbstractCentrallySymmetric:","category":"page"},{"location":"lib/sets/Ellipsoid/","page":"Ellipsoid","title":"Ellipsoid","text":"dim\nisbounded\nisempty\nisuniversal\nan_element","category":"page"},{"location":"lib/sets/Universe/","page":"Universe","title":"Universe","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/Universe/#def_Universe","page":"Universe","title":"Universe","text":"","category":"section"},{"location":"lib/sets/Universe/","page":"Universe","title":"Universe","text":"Universe\ndim(::Universe)\nρ(::AbstractVector{N}, ::Universe{N}) where {N<:Real}\nσ(::AbstractVector{N}, ::Universe{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::Universe{N}) where {N<:Real}\nrand(::Type{Universe})\nan_element(::Universe{N}) where {N<:Real}\nisempty(::Universe)\nisbounded(::Universe)\nisuniversal(::Universe{N}, ::Bool=false) where {N<:Real}\nnorm(::Universe, ::Real=Inf)\nradius(::Universe, ::Real=Inf)\ndiameter(::Universe, ::Real=Inf)\nconstraints_list(::Universe{N}) where {N<:Real}\nconstrained_dimensions(::Universe)\ntranslate(::Universe{N}, ::AbstractVector{N}) where {N<:Real}","category":"page"},{"location":"lib/sets/Universe/#LazySets.Universe","page":"Universe","title":"LazySets.Universe","text":"Universe{N<:Real} <: AbstractPolyhedron{N}\n\nType that represents the universal set, i.e., the set of all elements.\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Universe/#LazySets.dim-Tuple{Universe}","page":"Universe","title":"LazySets.dim","text":"dim(U::Universe)\n\nReturn the dimension of a universe.\n\nInput\n\nU – universe\n\nOutput\n\nThe dimension of a universe.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Universe{N}}} where N<:Real","page":"Universe","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, U::Universe{N}) where {N<:Real}\n\nReturn the support function of a universe.\n\nInput\n\nd – direction\nU – universe\n\nOutput\n\nThe support function in the given direction.\n\nAlgorithm\n\nIf the direction is all zero, the result is zero. Otherwise, the result is Inf.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Universe{N}}} where N<:Real","page":"Universe","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, U::Universe{N}) where {N<:Real}\n\nReturn the support vector of a universe.\n\nInput\n\nd – direction\nU – universe\n\nOutput\n\nA vector with infinity values, except in dimensions where the direction is zero.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Universe{N}}} where N<:Real","page":"Universe","title":"Base.:∈","text":"∈(x::AbstractVector{N}, U::Universe{N}) where {N<:Real}\n\nCheck whether a given point is contained in a universe.\n\nInput\n\nx – point/vector\nU – universe\n\nOutput\n\nThe output is always true.\n\nExamples\n\njulia> [1.0, 0.0] ∈ Universe(2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#Base.rand-Tuple{Type{Universe}}","page":"Universe","title":"Base.rand","text":"rand(::Type{Universe}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nCreate a universe (note that there is nothing to randomize).\n\nInput\n\nUniverse – type for dispatch\nN        – (optional, default: Float64) numeric type\ndim      – (optional, default: 2) dimension\nrng      – (optional, default: GLOBAL_RNG) random number generator\nseed     – (optional, default: nothing) seed for reseeding\n\nOutput\n\nThe (only) universe of the given numeric type and dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#LazySets.an_element-Union{Tuple{Universe{N}}, Tuple{N}} where N<:Real","page":"Universe","title":"LazySets.an_element","text":"an_element(U::Universe{N}) where {N<:Real}\n\nReturn some element of a universe.\n\nInput\n\nU – universe\n\nOutput\n\nThe origin.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#Base.isempty-Tuple{Universe}","page":"Universe","title":"Base.isempty","text":"isempty(U::Universe)\n\nReturn if a universe is empty or not.\n\nInput\n\nU – universe\n\nOutput\n\nfalse.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#LazySets.isbounded-Tuple{Universe}","page":"Universe","title":"LazySets.isbounded","text":"isbounded(U::Universe)\n\nDetermine whether a universe is bounded.\n\nInput\n\nU – universe\n\nOutput\n\nfalse as the universe is unbounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#LazySets.isuniversal-Union{Tuple{Universe{N}}, Tuple{N}, Tuple{Universe{N},Bool}} where N<:Real","page":"Universe","title":"LazySets.isuniversal","text":"isuniversal(U::Universe{N}, [witness]::Bool=false) where {N<:Real}\n\nCheck whether a universe is universal.\n\nInput\n\nU       – universe\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true\nIf witness option is activated: (true, [])\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#LinearAlgebra.norm","page":"Universe","title":"LinearAlgebra.norm","text":"norm(U::Universe, [p]::Real=Inf)\n\nReturn the norm of a universe. It is the norm of the enclosing ball (of the given p-norm) of minimal volume that is centered in the origin.\n\nInput\n\nU – universe\np – (optional, default: Inf) norm\n\nOutput\n\nAn error.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/Universe/#LazySets.radius","page":"Universe","title":"LazySets.radius","text":"radius(U::Universe, [p]::Real=Inf)\n\nReturn the radius of a universe. It is the radius of the enclosing ball (of the given p-norm) of minimal volume with the same center.\n\nInput\n\nU – universe\np – (optional, default: Inf) norm\n\nOutput\n\nAn error.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/Universe/#LazySets.diameter","page":"Universe","title":"LazySets.diameter","text":"diameter(U::Universe, [p]::Real=Inf)\n\nReturn the diameter of a universe. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given p-norm) of minimal volume with the same center.\n\nInput\n\nU – universe\np – (optional, default: Inf) norm\n\nOutput\n\nAn error.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/Universe/#LazySets.constraints_list-Union{Tuple{Universe{N}}, Tuple{N}} where N<:Real","page":"Universe","title":"LazySets.constraints_list","text":"constraints_list(U::Universe{N}) where {N<:Real}\n\nReturn the list of constraints defining a universe.\n\nInput\n\nU – universe\n\nOutput\n\nThe empty list of constraints, as the universe is unconstrained.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#LazySets.constrained_dimensions-Tuple{Universe}","page":"Universe","title":"LazySets.constrained_dimensions","text":"constrained_dimensions(U::Universe)\n\nReturn the indices in which a universe is constrained.\n\nInput\n\nU – universe\n\nOutput\n\nThe empty vector, as the universe is unconstrained in every dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Universe/#LazySets.translate-Union{Tuple{N}, Tuple{Universe{N},AbstractArray{N,1}}} where N<:Real","page":"Universe","title":"LazySets.translate","text":"translate(U::Universe{N}, v::AbstractVector{N}) where {N<:Real}\n\nTranslate (i.e., shift) a universe by a given vector.\n\nInput\n\nU – universe\nv – translation vector\n\nOutput\n\nThe universe.\n\n\n\n\n\n","category":"method"},{"location":"man/convex_sets/#Introduction-to-Convex-Sets","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"In this section we give a short overview about convex sets supported in this library. Currently we only list the basic convex sets and we refer to this presentation for a short explanation of operations on convex sets and composite set representations that are supported here and that we plan to add in the future.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Pages = [\"convex_sets.md\"]\nDepth = 4","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"using LazySets, Plots, Plots.PlotMeasures, LaTeXStrings\n\nc1 = \"blue\"\nc2 = \"green\"\nc3 = \"red\"\nc4 = \"orange\"\n\nfunction plot_raw()\n    plot(tickfont=font(15, \"Times\"), aspectratio=1, size=(300, 300), leg=false)\nend\n\nfunction plotX(X, ε, modify, color; linecolor=\"black\")\n    if !modify\n        plot_raw()\n    end\n    plot!(X, ε, color=color, alpha=0.7, linecolor=linecolor)\nend\n\nfunction plotX(X, modify, color; linecolor=\"black\")\n    if !modify\n        plot_raw()\n    end\n    plot!(X, color=color, alpha=0.7, linecolor=linecolor)\nend\n\nfunction plot1(X, modify::Bool=false; linecolor=\"black\")\n    plotX(X, modify, c1, linecolor=linecolor)\nend\n\nfunction plot2(X, modify::Bool=false; linecolor=\"black\")\n    plotX(X, modify, c2, linecolor=linecolor)\nend\n\nfunction plot3(X, modify::Bool=false; linecolor=\"black\")\n    plotX(X, modify, c3, linecolor=linecolor)\nend\n\nfunction plot1(X, ε::Float64, modify::Bool=false; linecolor=\"black\")\n    plotX(X, ε, modify, c1, linecolor=linecolor)\nend\n\nfunction plot2(X, ε::Float64, modify::Bool=false; linecolor=\"black\")\n    plotX(X, ε, modify, c2, linecolor=linecolor)\nend\n\nfunction plot3(X, ε::Float64, modify::Bool=false; linecolor=\"black\")\n    plotX(X, ε, modify, c3, linecolor=linecolor)\nend\n\nfunction plot_hyperplane!(x, y, linecolor)\n    plot!(x, y, linecolor=linecolor, arrow=:arrow, width=8)\n    plot!([x[2], x[1]], [y[2], y[1]], linecolor=linecolor, arrow=:arrow, width=8)\nend","category":"page"},{"location":"man/convex_sets/#Basic-convex-sets","page":"Introduction to Convex Sets","title":"Basic convex sets","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"A set X  mathbbR^n is convex if for any two points x, y in X the whole line segment connecting x and y is also contained in X. Formally:","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"    X = λ  x + (1  λ)  y mid x y  X λ  0 1  mathbbR","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Below we show an example of a convex set and a non-convex set.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"pentagon = VPolygon([[1., 2.], [2., 1.], [1.5, 0.], [0.5, 0.], [0., 1.]])\n\nplot_raw()  # hide\nplot!(xlims=(0., 2.), ylims=(0., 2.), xticks=[0., 1., 2.],  # hide\n      yticks=[1., 2.], top_margin=3mm)  # hide\nplot1(pentagon, true)  # hide","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"hourglass = UnionSet(VPolygon([[0., 2.], [1., 0.9], [2, 2.]]),\n                     VPolygon([[0., 0.], [1., 1.1], [2, 0.]]))\n\nplot_raw()  # hide\nplot!(xlims=(0., 2.), ylims=(0., 2.), xticks=[0., 1., 2.],  # hide\n      yticks=[1., 2.], top_margin=3mm)  # hide\nplot3(hourglass, true; linecolor=c3)  # hide","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"The set types used in this example will be explained later. As a quick summary, the set type VPolygon represents a convex polygon as the convex hull of a given list of vertices (as opposed to a representation as the intersection of a given list of linear constraints; for that representation see the set type HPolygon). The UnionSet represents the union of two sets.","category":"page"},{"location":"man/convex_sets/#Empty-set","page":"Introduction to Convex Sets","title":"Empty set","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"The simplest convex set is the empty set.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"dimension = 2\nE = EmptySet(dimension)\n\nplot_raw()  # hide\nplot!(xlims=(0., 2.), ylims=(0., 2.), xticks=[0., 1., 2.],  # hide\n      yticks=[1., 2.], top_margin=3mm)  # hide\nplot1(E, true)  # hide","category":"page"},{"location":"man/convex_sets/#Singleton","page":"Introduction to Convex Sets","title":"Singleton","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"The next simplest convex set is the singleton, which consists of a single point.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"S = Singleton([1.0, 1.0])\n\nplot_raw()  # hide\nplot!(S, markercolor=c2, markersize=10, xlims=(0., 2.), ylims=(0., 2.),  # hide\n      xticks=[0., 1., 2.], yticks=[1., 2.], top_margin=3mm)  # hide","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"As a special case, the library also offers a representation of the singleton consisting of the origin.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"dimension = 2\nZ = ZeroSet(dimension)\n\nplot_raw()  # hide\nplot!(Z, markercolor=c2, markersize=10, xlims=(-1., 1.), ylims=(-1., 1.),  # hide\n      xticks=[-1., 0., 1.], yticks=[-1., 0., 1.], top_margin=3mm)  # hide","category":"page"},{"location":"man/convex_sets/#Unit-balls","page":"Introduction to Convex Sets","title":"Unit balls","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Now we consider sets that represent the unit balls in different p-norms.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"     x = (x_1  x_n) _p = sqrt^px_1^p +  + x_n^p","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Formally, a unit ball is the sets of points x with x_p  1.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Balls for p  1 are convex.","category":"page"},{"location":"man/convex_sets/#Infinity-norm","page":"Introduction to Convex Sets","title":"Infinity norm","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"The unit ball in the infinity norm (p = ) is also called hypercube.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Bi = BallInf([0.0, 0.0], 1.0)\n\nplot_raw()  # hide\nplot!(xlims=(-1., 1.), ylims=(-1., 1.), xticks=[-1., 0., 1.],  # hide\n      yticks=[0., 1.], top_margin=3mm)  # hide\nplot1(Bi, true)  # hide","category":"page"},{"location":"man/convex_sets/#Euclidean-norm","page":"Introduction to Convex Sets","title":"Euclidean norm","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"The unit ball in the Euclidean norm (p = 2) is also called hypersphere.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"B2 = Ball2([0.0, 0.0], 1.0)\n\nplot_raw()  # hide\nplot!(xlims=(-1., 1.), ylims=(-1., 1.), xticks=[-1., 0., 1.],  # hide\n      yticks=[0., 1.], top_margin=3mm)  # hide\nplot2(B2, true)  # hide","category":"page"},{"location":"man/convex_sets/#Manhattan-norm","page":"Introduction to Convex Sets","title":"Manhattan norm","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"The unit ball in the Manhattan norm (p = 1) is also called cross-polytope.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"B1 = Ball1([0.0, 0.0], 1.0)\n\nplot_raw()  # hide\nplot!(xlims=(-1., 1.), ylims=(-1., 1.), xticks=[-1., 0., 1.],  # hide\n      yticks=[0., 1.], top_margin=3mm)  # hide\nplot3(B1, true)  # hide","category":"page"},{"location":"man/convex_sets/#More-unit-balls","page":"Introduction to Convex Sets","title":"More unit balls","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Below we show more exotic example of unit balls for p = 3 42 π.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"B3 = Ballp(3., [0.0, 0.0], 1.0)\n\nplot_raw()  # hide\nplot!(xlims=[-1., 1.], ylims=[-1., 1.], xticks=[-1., 0., 1.],  # hide\n      yticks=[0., 1.])  # hide\nplot1(B3, 1e-5, true)  # hide","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"B42 = Ballp(42., [0.0, 0.0], 1.0)\n\nplot_raw()  # hide\nplot!(xlims=[-1., 1.], ylims=[-1., 1.], xticks=[-1., 0., 1.],  # hide\n      yticks=[0., 1.])  # hide\nplot2(B42, 1e-5, true)  # hide","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Bπ = Ballp(π - 2., [0.0, 0.0], 1.0)\n\nplot_raw()  # hide\nplot!(xlims=[-1., 1.], ylims=[-1., 1.], xticks=[-1., 0., 1.],  # hide\n      yticks=[0., 1.])  # hide\nplot3(Bπ, 1e-5, true)  # hide","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Finally, the following example of the unit ball for p = 23 demonstrates that for p  1 the unit balls are not convex.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"(Image: ../assets/ball_two_thirds.png)","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"[Source: Wikimedia]","category":"page"},{"location":"man/convex_sets/#Unbounded-sets","page":"Introduction to Convex Sets","title":"Unbounded sets","text":"","category":"section"},{"location":"man/convex_sets/#Hyperplane","page":"Introduction to Convex Sets","title":"Hyperplane","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"A hyperplane is the generalization of the line (in 2D) and the plane (in 3D). Formally, a hyperplane is parametric in a normal vector a and a constant b and represents the set of points x satisfying a x = b (where  denotes the dot product).","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Hp = Hyperplane([1.0, 1.0], 1.0)\n\nx = [0., 1.]  # hide\ny = [1., 0.]  # hide\narrow_x = [0.5, 0.7]  # hide\narrow_y = [0.5, 0.7]  # hide\nxa = 0.5  # hide\nya = 0.7  # hide\n\nplot_raw()  # hide\nplot!(xlims=(0., 1.0), ylims=(0., 1.0), xticks=[0., 1.], yticks=[1.],  # hide\n      top_margin=3mm)  # hide\nplot_hyperplane!(x, y, c1)  # hide\nplot!(arrow_x, arrow_y, linecolor=c3, arrow=:arrow, linestyle=:dot, width=8)  # hide\nplot!(annotations=(xa, ya, text(L\"a\", 30)))  # hide","category":"page"},{"location":"man/convex_sets/#Half-space","page":"Introduction to Convex Sets","title":"Half-space","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"A half-space is characterized by a hyperplane and represents all points that lie on one side of that hyperplane. Formally, it is the set of points x satisfying a x  b.","category":"page"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"Hs = HalfSpace([1.0, 1.0], 1.0)\n\nX = VPolygon([[0., 0.], [1., 0.], [0., 1.]])  # hide\n\nplot_raw()  # hide\nplot!(xlims=(0., 1.0), ylims=(0., 1.0), xticks=[0., 1.], yticks=[1.],  # hide\n      top_margin=3mm)  # hide\nplot2(X, true)  # hide\nplot_hyperplane!(x, y, c2)  # hide\nplot!(arrow_x, arrow_y, linecolor=c3, arrow=:arrow, linestyle=:dot, width=8)  # hide\nplot!(annotations=(xa, ya, text(L\"a\", 30)))  # hide","category":"page"},{"location":"man/convex_sets/#Operations-on-convex-sets","page":"Introduction to Convex Sets","title":"Operations on convex sets","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"To be continued...","category":"page"},{"location":"man/convex_sets/#Composite-convex-sets","page":"Introduction to Convex Sets","title":"Composite convex sets","text":"","category":"section"},{"location":"man/convex_sets/","page":"Introduction to Convex Sets","title":"Introduction to Convex Sets","text":"To be continued...","category":"page"},{"location":"lib/interfaces/#Set-Interfaces","page":"Interfaces","title":"Set Interfaces","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"This section of the manual describes the interfaces for different set types. Every set that fits the description of an interface should also implement it. This helps in several ways:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"avoid code duplicates,\nprovide functions for many sets at once,\nallow changes in the source code without changing the API.","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"The interface functions are outlined in the interface documentation. For implementations of the interfaces see the corresponding sub-pages linked in the respective sections.","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"note: Note\nThe naming convention is such that all interface names (with the exception of the main abstract type LazySet) should be preceded by Abstract.","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"The following diagram shows the interface hierarchy.","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"(Image: ../assets/interfaces.png)","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Pages = [\"interfaces.md\"]\nDepth = 3","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/interfaces/#def_LazySet","page":"Interfaces","title":"General sets (LazySet)","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Every convex set in this library implements this interface.","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"LazySet","category":"page"},{"location":"lib/interfaces/#LazySets.LazySet","page":"Interfaces","title":"LazySets.LazySet","text":"LazySet{N}\n\nAbstract type for convex sets, i.e., sets characterized by a (possibly infinite) intersection of halfspaces, or equivalently, sets S such that for any two elements x y  S and 0  λ  1 it holds that λx + (1-λ)y  S.\n\nNotes\n\nLazySet types should be parameterized with a type N, typically N<:Real, for using different numeric types.\n\nEvery concrete LazySet must define the following functions:\n\nσ(d::AbstractVector{N}, S::LazySet{N}) where {N<:Real} – the support vector   of S in a given direction d; note that the numeric type N of d and   S must be identical; for some set types N may be more restrictive than   Real\ndim(S::LazySet) – the ambient dimension of S\n\nThe function\n\nρ(d::AbstractVector{N}, S::LazySet{N}) where {N<:Real} – the support   function of S in a given direction d; note that the numeric type N of   d and S must be identical; for some set types N may be more   restrictive than Real\n\nis optional because there is a fallback implementation relying on σ. However, for unbounded sets (which includes most lazy set types) this fallback cannot be used and an explicit method must be implemented.\n\nThe subtypes of LazySet (including abstract interfaces):\n\njulia> subtypes(LazySet, false)\n14-element Array{Any,1}:\n AbstractAffineMap\n AbstractCentrallySymmetric\n AbstractPolyhedron\n Bloating\n CachedMinkowskiSumArray\n CartesianProduct\n CartesianProductArray\n ConvexHull\n ConvexHullArray\n EmptySet\n Intersection\n IntersectionArray\n MinkowskiSum\n MinkowskiSumArray\n\nIf we only consider concrete subtypes, then:\n\njulia> concrete_subtypes = subtypes(LazySet, true);\n\njulia> length(concrete_subtypes)\n39\n\njulia> println.(concrete_subtypes);\nAffineMap\nBall1\nBall2\nBallInf\nBallp\nBloating\nCachedMinkowskiSumArray\nCartesianProduct\nCartesianProductArray\nConvexHull\nConvexHullArray\nEllipsoid\nEmptySet\nExponentialMap\nExponentialProjectionMap\nHPolygon\nHPolygonOpt\nHPolyhedron\nHPolytope\nHalfSpace\nHyperplane\nHyperrectangle\nIntersection\nIntersectionArray\nInterval\nLine2D\nLineSegment\nLinearMap\nMinkowskiSum\nMinkowskiSumArray\nResetMap\nSingleton\nSymmetricIntervalHull\nTranslation\nUniverse\nVPolygon\nVPolytope\nZeroSet\nZonotope\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/#Support-function-and-support-vector","page":"Interfaces","title":"Support function and support vector","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Every LazySet type must define a function σ to compute the support vector.","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"support_vector\nρ(::AbstractVector{N}, ::LazySet{N}) where {N<:Real}\nsupport_function\nσ","category":"page"},{"location":"lib/interfaces/#LazySets.support_vector","page":"Interfaces","title":"LazySets.support_vector","text":"support_vector\n\nAlias for the support vector σ.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LazySet{N}}} where N<:Real","page":"Interfaces","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, S::LazySet{N}) where {N<:Real}\n\nEvaluate the support function of a set in a given direction.\n\nInput\n\nd – direction\nS – convex set\n\nOutput\n\nThe support function of the set S for the direction d.\n\nNotes\n\nThe numeric type of the direction and the set must be identical.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.support_function","page":"Interfaces","title":"LazySets.support_function","text":"support_function\n\nAlias for the support function ρ.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/#LazySets.σ","page":"Interfaces","title":"LazySets.σ","text":"σ\n\nFunction to compute the support vector σ.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/#Other-globally-defined-set-functions","page":"Interfaces","title":"Other globally defined set functions","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"basetype\nnorm(::LazySet, ::Real=Inf)\nradius(::LazySet, ::Real=Inf)\ndiameter(::LazySet, ::Real=Inf)\nisbounded(::LazySet)\nisbounded_unit_dimensions(::LazySet{N}) where {N<:Real}\nan_element(::LazySet{N}) where {N<:Real}\ntosimplehrep(::LazySet)\nisuniversal(::LazySet{N}, ::Bool=false) where {N<:Real}\naffine_map(M::AbstractMatrix, X::LazySet, v::AbstractVector)\nreflect(::LazySet)\nis_interior_point(::AbstractVector{N}, ::LazySet{N}; p=Inf, ε=_rtol(N)) where {N<:Real}\nisoperationtype(::Type{<:LazySet})\nisoperation(::LazySet)\nisequivalent(::LazySet, ::LazySet)\nisconvextype(::Type{<:LazySet})\nsurface(::LazySet{N}) where {N}\narea(::LazySet{N}) where {N}","category":"page"},{"location":"lib/interfaces/#LazySets.basetype","page":"Interfaces","title":"LazySets.basetype","text":"basetype(T::Type{<:LazySet})\n\nReturn the base type of the given set type (i.e., without type parameters).\n\nInput\n\nT – set type, used for dispatch\n\nOutput\n\nThe base type of T.\n\n\n\n\n\nbasetype(S::LazySet)\n\nReturn the base type of the given set (i.e., without type parameters).\n\nInput\n\nS – set instance, used for dispatch\n\nOutput\n\nThe base type of S.\n\nExamples\n\njulia> z = rand(Zonotope);\n\njulia> basetype(z)\nZonotope\n\njulia> basetype(z + z)\nMinkowskiSum\n\njulia> basetype(LinearMap(rand(2, 2), z + z))\nLinearMap\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/#LinearAlgebra.norm","page":"Interfaces","title":"LinearAlgebra.norm","text":"norm(S::LazySet, [p]::Real=Inf)\n\nReturn the norm of a convex set. It is the norm of the enclosing ball (of the given p-norm) of minimal volume that is centered in the origin.\n\nInput\n\nS – convex set\np – (optional, default: Inf) norm\n\nOutput\n\nA real number representing the norm.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/#LazySets.radius","page":"Interfaces","title":"LazySets.radius","text":"radius(S::LazySet, [p]::Real=Inf)\n\nReturn the radius of a convex set. It is the radius of the enclosing ball (of the given p-norm) of minimal volume with the same center.\n\nInput\n\nS – convex set\np – (optional, default: Inf) norm\n\nOutput\n\nA real number representing the radius.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/#LazySets.diameter","page":"Interfaces","title":"LazySets.diameter","text":"diameter(S::LazySet, [p]::Real=Inf)\n\nReturn the diameter of a convex set. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given p-norm) of minimal volume with the same center.\n\nInput\n\nS – convex set\np – (optional, default: Inf) norm\n\nOutput\n\nA real number representing the diameter.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/#LazySets.isbounded-Tuple{LazySet}","page":"Interfaces","title":"LazySets.isbounded","text":"isbounded(S::LazySet)\n\nDetermine whether a set is bounded.\n\nInput\n\nS – set\n\nOutput\n\ntrue iff the set is bounded.\n\nAlgorithm\n\nWe check boundedness via isbounded_unit_dimensions.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.isbounded_unit_dimensions","text":"isbounded_unit_dimensions(S::LazySet{N}) where {N<:Real}\n\nDetermine whether a set is bounded in each unit dimension.\n\nInput\n\nS – set\n\nOutput\n\ntrue iff the set is bounded in each unit dimension.\n\nAlgorithm\n\nThis function performs 2n support function checks, where n is the ambient dimension of S.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.an_element","text":"an_element(S::LazySet{N}) where {N<:Real}\n\nReturn some element of a convex set.\n\nInput\n\nS – convex set\n\nOutput\n\nAn element of a convex set.\n\nAlgorithm\n\nAn element of the set is obtained by evaluating its support vector along direction 1 0  0.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.tosimplehrep-Tuple{LazySet}","page":"Interfaces","title":"LazySets.tosimplehrep","text":"tosimplehrep(S::LazySet)\n\nReturn the simple H-representation Ax  b of a set from its list of linear constraints.\n\nInput\n\nS – set\n\nOutput\n\nThe tuple (A, b) where A is the matrix of normal directions and b is the vector of offsets.\n\nNotes\n\nThis function only works for sets that can be represented exactly by a finite list of linear constraints. This fallback implementation relies on constraints_list(S).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.isuniversal-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},Bool}} where N<:Real","page":"Interfaces","title":"LazySets.isuniversal","text":"isuniversal(X::LazySet{N}, [witness]::Bool=false) where {N<:Real}\n\nCheck whether a given convex set is universal, and otherwise optionally compute a witness.\n\nInput\n\nX       – convex set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff X is universal\nIf witness option is activated:\n(true, []) iff X is universal\n(false, v) iff X is not universal and v  X\n\nNotes\n\nThis is a naive fallback implementation.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.affine_map-Tuple{AbstractArray{T,2} where T,LazySet,AbstractArray{T,1} where T}","page":"Interfaces","title":"LazySets.affine_map","text":"affine_map(M::AbstractMatrix, X::LazySet, v::AbstractVector)\n\nCompute a concrete affine map.\n\nInput\n\nM – linear map\nX – convex set\nv – translation vector\n\nOutput\n\nA set representing the affine map of X.\n\nAlgorithm\n\nThe implementation applies the functions linear_map and translate.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.reflect-Tuple{LazySet}","page":"Interfaces","title":"LazySets.reflect","text":"reflect(P::LazySet{N}) where {N<:Real}\n\nConcrete reflection of a convex set P, resulting in the reflected set -P.\n\nNote\n\nThis function requires that the list of constraints of the set P is available, i.e. such that it can be written as P = z  ℝⁿ  sᵢᵀz  rᵢ i = 1  N\n\nThis function can be used to implement the alternative definition of the Minkowski Difference, which writes as\n\nA  B = a  b  a  A b  B = A  (-B)\n\nby calling minkowski_sum(A, reflect(B)).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.is_interior_point-Union{Tuple{N}, Tuple{AbstractArray{N,1},LazySet{N}}} where N<:Real","page":"Interfaces","title":"LazySets.is_interior_point","text":"is_interior_point(d::AbstractVector{N}, P::LazySet{N};\n                  p=N(Inf), ε=_rtol(N)) where {N<:Real}\n\nCheck if the point d is contained in the interior of the convex set P.\n\nInput\n\nd  – point\nP  – set\np  – (optional; default: N(Inf)) norm of the ball used to apply the error         tolerance\nε  – (optional; default: _rtol(N)) error tolerance of check\n\nOutput\n\nBoolean which indicates if the point d is contained in P.\n\nAlgorithm\n\nThe implementation checks if a Ballp of norm p with center d and radius ε is contained in the set P. This is a numerical check for d ∈ interior(P) with error tolerance ε.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.isoperationtype-Tuple{Type{#s15} where #s15<:LazySet}","page":"Interfaces","title":"LazySets.isoperationtype","text":"isoperationtype(X::Type{<:LazySet})\n\nCheck whether the given LazySet type is an operation or not.\n\nInput\n\nX – subtype of LazySet\n\nOutput\n\ntrue if the given set type is a set-based operation and false otherwise.\n\nNotes\n\nThe fallback for this function returns an error that isoperationtype is not implemented. Subtypes of LazySet should dispatch on this function as required.\n\nSee also isoperation(X<:LazySet).\n\nExamples\n\njulia> isoperationtype(BallInf)\nfalse\n\njulia> isoperationtype(LinearMap)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.isoperation-Tuple{LazySet}","page":"Interfaces","title":"LazySets.isoperation","text":"isoperation(X::LazySet)\n\nCheck whether the given LazySet is an instance of a set operation or not.\n\nInput\n\nX – a LazySet\n\nOutput\n\ntrue if X is an instance of a set-based operation and false otherwise.\n\nNotes\n\nThe fallback implementation returns whether the set type of the input is an operation or not using isoperationtype.\n\nSee also isoperationtype(X::Type{<:LazySet}).\n\nExamples\n\njulia> B = BallInf([0.0, 0.0], 1.0);\n\njulia> isoperation(B)\nfalse\n\njulia> isoperation(B ⊕ B)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.isequivalent-Tuple{LazySet,LazySet}","page":"Interfaces","title":"LazySets.isequivalent","text":"isequivalent(X::LazySet, Y::LazySet)\n\nReturn whether two LazySets are equal in the mathematical sense, i.e. equivalent.\n\nInput\n\nX – any LazySet\nY – another LazySet\n\nOutput\n\ntrue iff X is equivalent to Y.\n\nAlgorithm\n\nFirst, the check X == Y is performed which returns true if and only if the given sets are of the same type, and have the same values (modulo floating-point tolerance). Otherwise, the double inclusion check X ⊆ Y && Y ⊆ X is used.\n\nExamples\n\njulia> X = BallInf([0.1, 0.2], 0.3);\n\njulia> Y = convert(HPolytope, X);\n\njulia> X == Y\nfalse\n\njulia> isequivalent(X, Y)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.isconvextype-Tuple{Type{#s15} where #s15<:LazySet}","page":"Interfaces","title":"LazySets.isconvextype","text":"isconvextype(X::Type{<:LazySet})\n\nCheck whether the given LazySet type is convex.\n\nInput\n\nX – subtype of LazySet\n\nOutput\n\ntrue if the given set type is guaranteed to be convex by using only type information, and false otherwise.\n\nNotes\n\nSince this operation only acts on types (not on values), it can return false negatives, i.e. there may be instances where the set is convex, even though the answer of this function is false. The examples below illustrate this point.\n\nExamples\n\nA ball in the infinity norm is always convex, hence we get:\n\njulia> isconvextype(BallInf)\ntrue\n\nFor instance, the union (UnionSet) of two sets may in general be either convex or not, since convexity cannot be decided by just using type information. Hence, isconvextype returns false if X is Type{<:UnionSet}.\n\njulia> isconvextype(UnionSet)\nfalse\n\nHowever, the type parameters from the set operations allow to decide convexity in some cases, by falling back to the convexity of the type of its arguments. Consider for instance the lazy intersection. The intersection of two convex sets is always convex, hence we can get:\n\njulia> isconvextype(Intersection{Float64, BallInf{Float64}, BallInf{Float64}})\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.surface-Union{Tuple{LazySet{N}}, Tuple{N}} where N","page":"Interfaces","title":"LazySets.surface","text":"surface(X::LazySet{N}) where {N}\n\nCompute the surface area of a set.\n\nInput\n\nX – set\n\nOutput\n\nA number representing the surface area of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.area-Union{Tuple{LazySet{N}}, Tuple{N}} where N","page":"Interfaces","title":"LazySets.area","text":"area(X::LazySet{N}) where {N}\n\nCompute the area of a two-dimensional polytopic set using the Shoelace formula.\n\nInput\n\nX – two-dimensional set\n\nOutput\n\nA number representing the area of X.\n\nNotes\n\nThis algorithm is applicable to any lazy set X such that its list of vertices, vertices_list, can be computed.\n\nAlgorithm\n\nLet m be the number of vertices of X. The following instances are considered:\n\nm = 0, 1, 2: the output is zero.\nm = 3: the triangle case is computed using the Shoelace formula with 3 points.\nm = 4: the quadrilateral case is obtained by the factored version of the Shoelace          formula with 4 points.\n\nOtherwise, the general Shoelace formula is used; for detals see the wikipedia article Shoelace formula.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Plotting is available for general one- or two-dimensional LazySets, provided that the overapproximation using iterative refinement is available:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"plot_recipe(::LazySet{N}, ::N=N(1e-3)) where {N<:Real}\nRecipesBase.apply_recipe(::AbstractDict{Symbol,Any}, ::LazySet{N}, ::N=N(1e-3)) where {N<:Real}\nRecipesBase.apply_recipe(::AbstractDict{Symbol,Any}, ::AbstractVector{VN}, ::N=N(1e-3), ::Int=40, ::Bool=false) where {N<:Real, VN<:LazySet{N}}","category":"page"},{"location":"lib/interfaces/#LazySets.plot_recipe-Union{Tuple{LazySet{N}}, Tuple{N}, Tuple{LazySet{N},N}} where N<:Real","page":"Interfaces","title":"LazySets.plot_recipe","text":"plot_recipe(X::LazySet{N}, [ε]::N=N(PLOT_PRECISION)) where {N<:Real}\n\nConvert a convex set to a pair (x, y) of points for plotting.\n\nInput\n\nX – convex set\nε – (optional, default: PLOT_PRECISION) approximation error bound\n\nOutput\n\nA pair (x, y) of points that can be plotted.\n\nNotes\n\nPlotting of unbounded sets is not implemented yet (see #576).\n\nAlgorithm\n\nWe first assert that X is bounded.\n\nOne-dimensional sets are converted to an Interval. We do not support three-dimensional or higher-dimensional sets at the moment.\n\nFor two-dimensional sets, we first compute a polygonal overapproximation. The second argument, ε, corresponds to the error in Hausdorff distance between the overapproximating set and X. The default value PLOT_PRECISION is chosen such that the unit ball in the 2-norm is approximated with reasonable accuracy. On the other hand, if you only want to produce a fast box-overapproximation of X, pass ε=Inf. Finally, we use the plot recipe for polygons.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol,Any},LazySet{N}}, Tuple{AbstractDict{Symbol,Any},LazySet{N},N}} where N<:Real","page":"Interfaces","title":"RecipesBase.apply_recipe","text":"plot_lazyset(X::LazySet{N}, [ε]::N=N(PLOT_PRECISION); ...) where {N<:Real}\n\nPlot a convex set.\n\nInput\n\nX – convex set\nε – (optional, default: PLOT_PRECISION) approximation error bound\n\nNotes\n\nSee plot_recipe(::LazySet{<:Real}).\n\nFor polyhedral set types (subtypes of AbstractPolyhedron), the argument ε is ignored.\n\nExamples\n\njulia> B = Ball2(ones(2), 0.1);\n\njulia> plot(B, 1e-3)  # default accuracy value (explicitly given for clarity)\n\njulia> plot(B, 1e-2)  # faster but less accurate than the previous call\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#RecipesBase.apply_recipe-Union{Tuple{VN}, Tuple{N}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1}}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1},N}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1},N,Int64}, Tuple{AbstractDict{Symbol,Any},AbstractArray{VN,1},N,Int64,Bool}} where VN<:LazySet{N} where N<:Real","page":"Interfaces","title":"RecipesBase.apply_recipe","text":"plot_list(list::AbstractVector{VN}, [ε]::N=N(PLOT_PRECISION),\n          [Nφ]::Int=PLOT_POLAR_DIRECTIONS, [fast]::Bool=false; ...)\n    where {N<:Real, VN<:LazySet{N}}\n\nPlot a list of convex sets.\n\nInput\n\nlist – list of convex sets (1D or 2D)\nε    – (optional, default: PLOT_PRECISION) approximation error bound\nNφ   – (optional, default: PLOT_POLAR_DIRECTIONS) number of polar           directions (used to plot lazy intersections)\nfast – (optional, default: false) switch for faster plotting but without           individual plot recipes (see notes below)\n\nNotes\n\nFor each set in the list we apply an individual plot recipe.\n\nThe option fast provides access to a faster plotting scheme where all sets in the list are first converted to polytopes and then plotted in one single run. This, however, is not suitable when plotting flat sets (line segments, singletons) because then the polytope plot recipe does not deliver good results. Hence by default we do not use this option. For plotting a large number of (non-flat) polytopes, we highly advise activating this option.\n\nExamples\n\njulia> B1 = BallInf(zeros(2), 0.4);\n\njulia> B2 = BallInf(ones(2), 0.4);\n\njulia> plot([B1, B2])\n\nSome of the sets in the list may not be plotted precisely but rather overapproximated first. The second argument ε controls the accuracy of this overapproximation.\n\njulia> Bs = [BallInf(zeros(2), 0.4), Ball2(ones(2), 0.4)];\n\njulia> plot(Bs, 1e-3)  # default accuracy value (explicitly given for clarity)\n\njulia> plot(Bs, 1e-2)  # faster but less accurate than the previous call\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"For three-dimensional sets, we support Makie:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"plot3d\nplot3d!","category":"page"},{"location":"lib/interfaces/#LazySets.plot3d","page":"Interfaces","title":"LazySets.plot3d","text":"plot3d(S::LazySet{N}; backend=default_polyhedra_backend(S, N),\n       alpha=1.0, color=:blue, colormap=:viridis, colorrange=nothing,\n       interpolate=false, linewidth=1, overdraw=false, shading=true,\n       transparency=true, visible=true) where {N}\n\nPlot a three-dimensional convex set using Makie.\n\nInput\n\nS            – convex set\nbackend      – (optional, default: default_polyhedra_backend(S, N)) polyhedral                   computations backend \nalpha        – (optional, default: 1.0) float in [0,1]; the alpha or                   transparency value\ncolor        – (optional, default: :blue) Symbol or Colorant; the color                   of the main plot element (markers, lines, etc.) and it can be                   a color symbol/string like :red\ncolormap     – (optional, default: :viridis) the color map of the main plot;                   call available_gradients() to see what gradients are available,                   and it can also be used as [:red, :black]\ncolorrange   – (optional, default: nothing, which falls back to                   Makie.AbstractPlotting.Automatic()) a tuple (min, max)                   where min and max specify the data range to be used for                   indexing the colormap\ninterpolate  – (optional, default: false) a bool for heatmap and images,                   it toggles color interpolation between nearby pixels\nlinewidth    – (optional, default: 1) a number that specifies the width of                   the line in line and linesegments plots\noverdraw     – (optional, default: false)\nshading      – (optional, default: true) a boolean that specifies if shading                   should be on or not (for meshes)\ntransparency – (optional, default: true) if true, the set is transparent                   otherwise it is displayed as a solid object\nvisible      – (optional, default: true) a bool that toggles visibility                   of the plot\n\nFor a complete list of attributes and usage see Makie's documentation.\n\nNotes\n\nThis plot recipe works by computing the list of constraints of S and converting to a polytope in H-representation. Then, this polytope is transformed with Polyhedra.Mesh and it is plotted using the mesh function.\n\nIf the function constraints_list is not applicable to your set S, try overapproximation first; e.g. via\n\njulia> using LazySets.Approximations\n\njulia> Sapprox = overapproximate(S, SphericalDirections(10))\n\njulia> plot3d(Sapprox)\n\nThe number 10 above corresponds to the number of directions considered; for  better resolution use higher values (but it will take longer).\n\nFor efficiency consider using the CDDLib backend, as in\n\njulia> using CDDLib\n\njulia> plot3d(Sapprox, backend=CDDLib.Library())\n\nExamples\n\nThe functionality requires both Polyhedra and Makie; so after loading LazySets, do using Makie, Polyhedra (or using Polyhedra, Makie, the order doesn't matter).\n\njulia> using LazySets, Makie, Polyhedra\n\njulia> plot3d(10. * rand(Hyperrectangle, dim=3))\n\njulia> plot3d!(10. * rand(Hyperrectangle, dim=3), color=:red)\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/#LazySets.plot3d!","page":"Interfaces","title":"LazySets.plot3d!","text":"plot3d!(S::LazySet{N}; backend=default_polyhedra_backend(S, N),\n        alpha=1.0, color=:blue, colormap=:viridis, colorrange=nothing, interpolate=false,\n        linewidth=1, overdraw=false, shading=true, transparency=true, visible=true) where {N}\n\nPlot a three-dimensional convex set using Makie.\n\nInput\n\nSee plot3d for the description of the inputs. For a complete list of attributes and usage see Makie's documentation.\n\nNotes\n\nSee the documentation of plot3d for examples.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/#Set-functions-that-override-Base-functions","page":"Interfaces","title":"Set functions that override Base functions","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"==(::LazySet, ::LazySet)\n≈(::LazySet, ::LazySet)\ncopy(::LazySet)\neltype","category":"page"},{"location":"lib/interfaces/#Base.:==-Tuple{LazySet,LazySet}","page":"Interfaces","title":"Base.:==","text":"==(X::LazySet, Y::LazySet)\n\nReturn whether two LazySets of the same type are exactly equal.\n\nInput\n\nX – any LazySet\nY – another LazySet of the same type as X\n\nOutput\n\ntrue iff X is equal to Y.\n\nNotes\n\nThe check is purely syntactic and the sets need to have the same base type. For instance, X::VPolytope == Y::HPolytope returns false even if X and Y represent the same polytope. However X::HPolytope{Int64} == Y::HPolytope{Float64} is a valid comparison.\n\nAlgorithm\n\nWe recursively compare the fields of X and Y until a mismatch is found.\n\nExamples\n\njulia> HalfSpace([1], 1) == HalfSpace([1], 1)\ntrue\n\njulia> HalfSpace([1], 1) == HalfSpace([1.0], 1.0)\ntrue\n\njulia> Ball1([0.], 1.) == Ball2([0.], 1.)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Base.:≈-Tuple{LazySet,LazySet}","page":"Interfaces","title":"Base.:≈","text":"≈(X::LazySet, Y::LazySet)\n\nReturn whether two LazySets of the same type are approximately equal.\n\nInput\n\nX – any LazySet\nY – another LazySet of the same type as X\n\nOutput\n\ntrue iff X is equal to Y.\n\nNotes\n\nThe check is purely syntactic and the sets need to have the same base type. For instance, X::VPolytope ≈ Y::HPolytope returns false even if X and Y represent the same polytope. However X::HPolytope{Int64} ≈ Y::HPolytope{Float64} is a valid comparison.\n\nAlgorithm\n\nWe recursively compare the fields of X and Y until a mismatch is found.\n\nExamples\n\njulia> HalfSpace([1], 1) ≈ HalfSpace([1], 1)\ntrue\n\njulia> HalfSpace([1], 1) ≈ HalfSpace([1.00000001], 0.99999999)\ntrue\n\njulia> HalfSpace([1], 1) ≈ HalfSpace([1.0], 1.0)\ntrue\n\njulia> Ball1([0.], 1.) ≈ Ball2([0.], 1.)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Base.copy-Tuple{LazySet}","page":"Interfaces","title":"Base.copy","text":"copy(S::LazySet)\n\nReturn a deep copy of the given set by copying its values recursively.\n\nInput\n\nS – any LazySet\n\nOutput\n\nA copy of S.\n\nNotes\n\nThis function performs a deepcopy of each field in S, resulting in a completely independent object. See the documentation of ?deepcopy for further details.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Base.eltype","page":"Interfaces","title":"Base.eltype","text":"eltype(::Type{<:LazySet{N}}) where {N}\n\nReturn the numeric type (N) of the given set type.\n\nInput\n\nT – set type, used for dispatch\n\nOutput\n\nThe numeric type of T.\n\n\n\n\n\neltype(::LazySet{N}) where {N}\n\nReturn the numeric type (N) of the given set.\n\nInput\n\nX – set instance, used for dispatch\n\nOutput\n\nThe numeric type of X.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/#Aliases-for-set-types","page":"Interfaces","title":"Aliases for set types","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"CompactSet\nNonCompactSet","category":"page"},{"location":"lib/interfaces/#LazySets.CompactSet","page":"Interfaces","title":"LazySets.CompactSet","text":"CompactSet\n\nAn alias for compact set types.\n\nNotes\n\nMost lazy operations are not captured by this alias because whether their result is compact or not depends on the argument(s).\n\n\n\n\n\n","category":"constant"},{"location":"lib/interfaces/#LazySets.NonCompactSet","page":"Interfaces","title":"LazySets.NonCompactSet","text":"NonCompactSet\n\nAn alias for non-compact set types.\n\nNotes\n\nMost lazy operations are not captured by this alias because whether their result is non-compact or not depends on the argument(s).\n\n\n\n\n\n","category":"constant"},{"location":"lib/interfaces/#Implementations","page":"Interfaces","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Concrete set representations:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Empty set (EmptySet)\nPolynomial zonotope (PolynomialZonotope)","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Lazy set operations:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Affine map (AffineMap)\nLinear map (LinearMap)\nExponential map (ExponentialMap)\nExponential projection map (ExponentialProjectionMap)\nReset map (ResetMap)\nTranslation\nBloating\nBinary Cartesian product (CartesianProduct)\nn-ary Cartesian product (CartesianProductArray)\nBinary convex hull (ConvexHull)\nn-ary convex hull (ConvexHullArray)\nBinary intersection\nn-ary intersection (IntersectionArray)\nBinary Minkowski sum (MinkowskiSum)\nn-ary Minkowski sum (MinkowskiSumArray)\nn-ary Minkowski sum with cache (CachedMinkowskiSumArray)\nBinary set union (UnionSet)\nn-ary set union (UnionSetArray)\nComplement\nRectification","category":"page"},{"location":"lib/interfaces/#def_AbstractCentrallySymmetric","page":"Interfaces","title":"Centrally symmetric sets (AbstractCentrallySymmetric)","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Centrally symmetric sets such as balls of different norms are characterized by a center. Note that there is a special interface combination Centrally symmetric polytope.","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"AbstractCentrallySymmetric","category":"page"},{"location":"lib/interfaces/#LazySets.AbstractCentrallySymmetric","page":"Interfaces","title":"LazySets.AbstractCentrallySymmetric","text":"AbstractCentrallySymmetric{N<:Real} <: LazySet{N}\n\nAbstract type for centrally symmetric sets.\n\nNotes\n\nEvery concrete AbstractCentrallySymmetric must define the following functions:\n\ncenter(::AbstractCentrallySymmetric{N}) – return the center   point\ncenter(::AbstractCentrallySymmetric{N}, i::Int) – return the center point at index i\n\njulia> subtypes(AbstractCentrallySymmetric)\n3-element Array{Any,1}:\n Ball2\n Ballp\n Ellipsoid\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"dim(::AbstractCentrallySymmetric)\nisbounded(::AbstractCentrallySymmetric)\nisuniversal(::AbstractCentrallySymmetric{N}, ::Bool=false) where {N<:Real}\nan_element(::AbstractCentrallySymmetric{N}) where {N<:Real}\nisempty(::AbstractCentrallySymmetric)\ncenter(::AbstractCentrallySymmetric{N}, ::Int) where {N<:Real}","category":"page"},{"location":"lib/interfaces/#LazySets.dim-Tuple{AbstractCentrallySymmetric}","page":"Interfaces","title":"LazySets.dim","text":"dim(S::AbstractCentrallySymmetric)\n\nReturn the ambient dimension of a centrally symmetric set.\n\nInput\n\nS – set\n\nOutput\n\nThe ambient dimension of the set.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.isbounded-Tuple{AbstractCentrallySymmetric}","page":"Interfaces","title":"LazySets.isbounded","text":"isbounded(S::AbstractCentrallySymmetric)\n\nDetermine whether a centrally symmetric set is bounded.\n\nInput\n\nS – centrally symmetric set\n\nOutput\n\ntrue (since a set with a unique center must be bounded).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.isuniversal-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}, Tuple{AbstractCentrallySymmetric{N},Bool}} where N<:Real","page":"Interfaces","title":"LazySets.isuniversal","text":"isuniversal(S::AbstractCentrallySymmetric{N}, [witness]::Bool=false\n           ) where {N<:Real}\n\nCheck whether a centrally symmetric set is universal.\n\nInput\n\nS       – centrally symmetric set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: false\nIf witness option is activated: (false, v) where v  S\n\nAlgorithm\n\nA witness is obtained by computing the support vector in direction d = [1, 0, …, 0] and adding d on top.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.an_element","text":"an_element(S::AbstractCentrallySymmetric{N}) where {N<:Real}\n\nReturn some element of a centrally symmetric set.\n\nInput\n\nS – centrally symmetric set\n\nOutput\n\nThe center of the centrally symmetric set.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Base.isempty-Tuple{AbstractCentrallySymmetric}","page":"Interfaces","title":"Base.isempty","text":"isempty(S::AbstractCentrallySymmetric)\n\nReturn if a centrally symmetric set is empty or not.\n\nInput\n\nS – centrally symmetric set\n\nOutput\n\nfalse.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.center-Union{Tuple{N}, Tuple{AbstractCentrallySymmetric{N},Int64}} where N<:Real","page":"Interfaces","title":"LazySets.center","text":"center(H::AbstractCentrallySymmetric{N}, i::Int) where {N<:Real}\n\nReturn the center along a given dimension of a centrally symmetric set.\n\nInput\n\nS – centrally symmetric set\ni – dimension of interest\n\nOutput\n\nThe center along a given dimension of the centrally symmetric set.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Implementations-2","page":"Interfaces","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Euclidean-norm ball (Ball2)\nEllipsoid\np-norm ball (Ballp)","category":"page"},{"location":"lib/interfaces/#def_AbstractPolyhedron","page":"Interfaces","title":"Polyhedra (AbstractPolyhedron)","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"A polyhedron has finitely many facets (H-representation) and is not necessarily bounded.","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"AbstractPolyhedron","category":"page"},{"location":"lib/interfaces/#LazySets.AbstractPolyhedron","page":"Interfaces","title":"LazySets.AbstractPolyhedron","text":"AbstractPolyhedron{N<:Real} <: LazySet{N}\n\nAbstract type for compact convex polyhedral sets.\n\nNotes\n\nEvery concrete AbstractPolyhedron must define the following functions:\n\nconstraints_list(::AbstractPolyhedron{N}) – return a list of all facet   constraints\n\njulia> subtypes(AbstractPolyhedron)\n6-element Array{Any,1}:\n AbstractPolytope\n HPolyhedron\n HalfSpace\n Hyperplane\n Line2D\n Universe\n\nPolyhedra are defined as the intersection of a finite number of closed half-spaces. As such, polyhedra are closed and convex but not necessarily bounded. Bounded polyhedra are called polytopes (see AbstractPolytope).\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"∈(::AbstractVector{N}, ::AbstractPolyhedron{N}) where {N<:Real}\nisuniversal(::AbstractPolyhedron{N}, ::Bool=false) where {N<:Real}\nconstrained_dimensions(::AbstractPolyhedron)\nlinear_map(::AbstractMatrix{N}, ::AbstractPolyhedron{N}) where {N<:Real}\nchebyshev_center(::AbstractPolyhedron{N}) where {N<:AbstractFloat}\nan_element(::AbstractPolyhedron{N}) where {N<:Real}\nvertices_list(::AbstractPolyhedron)\nsingleton_list(::AbstractPolyhedron)","category":"page"},{"location":"lib/interfaces/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractPolyhedron{N}}} where N<:Real","page":"Interfaces","title":"Base.:∈","text":"∈(x::AbstractVector{N}, P::AbstractPolyhedron{N}) where {N<:Real}\n\nCheck whether a given point is contained in a polyhedron.\n\nInput\n\nx – point/vector\nP – polyhedron\n\nOutput\n\ntrue iff x  P.\n\nAlgorithm\n\nThis implementation checks if the point lies inside each defining half-space.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.isuniversal-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}, Tuple{AbstractPolyhedron{N},Bool}} where N<:Real","page":"Interfaces","title":"LazySets.isuniversal","text":"isuniversal(P::AbstractPolyhedron{N}, [witness]::Bool=false\n           ) where {N<:Real}\n\nCheck whether a polyhedron is universal.\n\nInput\n\nP       – polyhedron\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff P is universal\nIf witness option is activated:\n(true, []) iff P is universal\n(false, v) iff P is not universal and v  P\n\nAlgorithm\n\nP is universal iff it has no constraints.\n\nA witness is produced using isuniversal(H) where H is the first linear constraint of P.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.constrained_dimensions-Tuple{AbstractPolyhedron}","page":"Interfaces","title":"LazySets.constrained_dimensions","text":"constrained_dimensions(P::AbstractPolyhedron) where {N<:Real}\n\nReturn the indices in which a polyhedron is constrained.\n\nInput\n\nP – polyhedron\n\nOutput\n\nA vector of ascending indices i such that the polyhedron is constrained in dimension i.\n\nExamples\n\nA 2D polyhedron with constraint x1  0 is constrained in dimension 1 only.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolyhedron{N}}} where N<:Real","page":"Interfaces","title":"LazySets.linear_map","text":"linear_map(M::AbstractMatrix{N},\n           P::AbstractPolyhedron{N};\n           [algorithm]::Union{String, Nothing}=nothing,\n           [check_invertibility]::Bool=true,\n           [cond_tol]::Number=DEFAULT_COND_TOL,\n           [inverse]::Union{AbstractMatrix{N}, Nothing}=nothing,\n           [backend]=nothing,\n           [elimination_method]=nothing) where {N<:Real}\n\nConcrete linear map of a polyhedral set.\n\nInput\n\nM         – matrix\nP         – polyhedral set\nalgorithm – (optional; default: nothing) algorithm to be used; for the                description see the Algorithm section below; possible choices are:\n\"inverse\", alias: \"inv\"\n\"inverse_right\", alias: \"inv_right\"\n\"elimination\", alias: \"elim\"\n\"lift\"\n\"vrep\"\ncheck_invertibility – (optional, default: true) if true check whether                          given matrix M is invertible; set to false only                          if you know that M is invertible\ncond_tol  – (optional; default: DEFAULT_COND_TOL) tolerance of matrix                condition (used to check whether the matrix is invertible)\ninverse   – (optional; default: nothing) matrix inverse M⁻¹; use this                option if you have already computed the inverse matrix of M\nbackend   – (optional: default: nothing) polyhedra backend\nelimination_method  – (optional: default: nothing) elimination method for                          the \"elimination\" algorithm\n\nOutput\n\nThe type of the result is \"as close as possible\" to the the type of P. Let (m, n) be the size of M, where m ≠ n is allowed for rectangular maps.\n\nTo fix the type of the output to something different than the default value, consider post-processing the result of this function with a call to a suitable convert method.\n\nIn particular, the output depends on the type of P, on m, and the algorithm that was used:\n\nIf the vertex-based approach was used:\nIf P is a VPolygon and m = 2 then the output is a VPolygon.\nIf P is a VPolytope then the output is a VPolytope.\nOtherwise, the output is an Interval if m = 1, a VPolygon if m = 2 and a VPolytope in other cases.\nIf the invertibility criterion was used:\nThe types of HalfSpace, Hyperplane, Line2D and AbstractHPolygon are preserved.\nIf P is an AbstractPolytope, then the output is an Interval if m = 1, an HPolygon if m = 2 and an HPolytope in other cases.\nOtherwise, the output is an HPolyhedron.\n\nNotes\n\nSince the different linear map algorithms work at the level of constraints (not sets representations), this function uses dispatch on two stages: once the algorithm has been defined, first the helper functions _linear_map_hrep_helper (resp. _linear_map_vrep) are invoked, which dispatch on the set type. Then, each helper function calls the concrete implementation of _linear_map_hrep, which dispatches on the algorithm, and returns a list of constraints.\n\nTo simplify working with different algorithms and options, the types <: AbstractLinearMapAlgorithm are used. These types are singleton type or types that carry only the key data for the given algorithm, such as the matrix inverse or the polyhedra backend.\n\nNew subtypes of the AbstractPolyhedron interface may define their own helper functions _linear_map_vrep, respectively _linear_map_hrep_helper for special handling of the constraints returned by the implementations of _linear_map_hrep; otherwise the fallback implementation for AbstractPolyhedron is used, which instantiates an HPolyhedron.\n\nAlgorithm\n\nThis function mainly implements several approaches for the linear map: inverse, right inverse, transformation to the vertex representation, variable elimination, and variable lifting. Depending on the properties of M and P, one algorithm may be preferable over the other. Details on the algorithms are given in the following subsections.\n\nOtherwise, if the algorithm argument is not specified, a default option is chosen based on heuristics on the types and values of M and P:\n\nIf the \"inverse\" algorithm applies, it is used.\nIf the \"inverse_right\" algorithm applies, it is used.\nOtherwise, if the \"lift\" algorithm applies, it is used.\nOtherwise, the \"elimination\" algorithm is used.\n\nNote that \"inverse\" does not require the external library Polyhedra, and neither does \"inverse_right\". However, the fallback method \"elimination\" requires Polyhedra as well as the library CDDLib.\n\nThe optional keyword arguments inverse and check_invertibility modify the default behavior:\n\nIf an inverse matrix is passed in inverse, the given algorithm is applied, and if none is given, either \"inverse\" or \"inverse_right\" is applied (in that order of preference).\nIf check_invertibility is set to false, the given algorithm is applied, and if none is given, either \"inverse\" or \"inverse_right\" is applied (in that order of preference).\n\nInverse\n\nThis algorithm is invoked with the keyword argument algorithm=\"inverse\" (or algorithm=\"inv\"). The algorithm requires that M is invertible, square, and dense. If you know a priori that M is invertible, set the flag check_invertibility=false, such that no extra checks are done within linear_map. Otherwise, we check the sufficient condition that the condition number of M is not too high. The threshold for the condition number can be modified from its default value, DEFAULT_COND_TOL, by passing a custom cond_tol.\n\nThe algorithm is described next. Assuming that the matrix M is invertible (which we check via a sufficient condition,), y = M x implies x = textinv(M) y and we can transform the polyhedron A x  b to the polyhedron A textinv(M) y  b.\n\nIf the dense condition on M is not fullfilled, there are two suggested workarounds: either transform to dense matrix, i.e. calling linear_map with Matrix(M), or use the \"inverse_right\" algorithm, which does not compute the inverse matrix explicitly, but uses a polyalgorithm; see the documentation of ? for details.\n\nInverse-right\n\nThis algorithm is invoked with the keyword argument algorithm=\"inverse_right\" (or algorithm=\"inv_right\"). This algorithm applies to square and invertible matrices M. The idea is essentially the same as for the \"inverse\" algorithm; the difference is that in \"inverse\" the full matrix inverse is computed, and in \"inverse_right\" only the left division on the normal vectors is used. In particular, \"inverse_right\" is good as a workaround when M is sparse (since the inv function is not available for sparse matrices).\n\nElimination\n\nThis algorithm is invoked with the keyword argument algorithm = \"elimination\" or algorithm = \"elim\". The algorithm applies to any matrix M (invertible or not), and any polyhedron P (bounded or not).\n\nThe idea is described next. If P : Ax <= b and y = Mx denote the polyhedron and the linear map respectively, we consider the vector z = [y, x], write the given equalities and the inequalities, and then eliminate the last x variables (there are length(x) in total) using a call to Polyhedra.eliminate to a backend library that can do variable elimination, typically CDDLib with the BlockElimination() algorithm. In this way we have eliminated the \"old\" variables x and kept the \"new\" or transformed variables \"y\".\n\nThe default elimination method is block elimination. For possible options we refer to the documentation of Polyhedra, projection/elimination.\n\nLift\n\nThis algorithm is invoked with the keyword argument algorithm=\"lift\". The algorithm applies if M is rectangular of size m × n with m > n and full rank (i.e. of rank n).\n\nThe idea is to embed the polyhedron into the m-dimensional space by appending zeros, i.e. extending all constraints of P to m dimensions, and constraining the last m - n dimensions to 0. The matrix resulting matrix is extended to an invertible m × m matrix and the algorithm using the inverse of the linear map is applied. For the technical details of the extension of M to a higher-dimensional invertible matrix, see LazySets.Arrays.extend.\n\nVertex representation\n\nThis algorithm is invoked with the keyword argument algorithm=\"vrep\". The idea is to convert the polyhedron to its vertex representation and apply the linear map to each vertex of P.\n\nThe returned set is a polytope in vertex representation. Note that conversion of the result back to half-space representation is not computed by default, since this may be costly. If you used this algorithm and still want to convert back to half-space representation, apply tohrep to the result of this function. Note that this method only works for bounded polyhedra.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.chebyshev_center-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}} where N<:AbstractFloat","page":"Interfaces","title":"LazySets.chebyshev_center","text":"chebyshev_center(P::AbstractPolyhedron{N};\n                 [get_radius]::Bool=false,\n                 [backend]=default_polyhedra_backend(P, N),\n                 [solver]=default_lp_solver_polyhedra(N; presolve=true)\n                 ) where {N<:AbstractFloat}\n\nCompute the Chebyshev center of a polytope.\n\nInput\n\nP          – polytope\nget_radius – (optional; default: false) option to additionally return the                 radius of the largest ball enclosed by P around the                 Chebyshev center\nbackend    – (optional; default: default_polyhedra_backend(P, N)) the                 backend for polyhedral computations\nsolver     – (optional; default:                 default_lp_solver_polyhedra(N; presolve=true)) the LP                 solver passed to Polyhedra\n\nOutput\n\nIf get_radius is false, the result is the Chebyshev center of P. If get_radius is true, the result is the pair (c, r) where c is the Chebyshev center of P and r is the radius of the largest ball with center c enclosed by P.\n\nNotes\n\nThe Chebyshev center is the center of a largest Euclidean ball enclosed by P. In general, the center of such a ball is not unique (but the radius is).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.an_element-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.an_element","text":"an_element(P::AbstractPolyhedron{N}) where {N<:Real}\n\nReturn some element of a convex set.\n\nInput\n\nP – polyhedron\n\nOutput\n\nAn element of a polyhedron.\n\nAlgorithm\n\nAn element of the polyhedron is obtained by evaluating its support vector along direction 1 0  0.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.vertices_list-Tuple{AbstractPolyhedron}","page":"Interfaces","title":"LazySets.vertices_list","text":"vertices_list(P::AbstractPolyhedron; check_boundedness::Bool=true)\n\nReturn the list of vertices of a polyhedron in constraint representation.\n\nInput\n\nP                 – polyhedron in constraint representation\ncheck_boundedness – (optional, default: true) if true, check whether the                        polyhedron is bounded\n\nOutput\n\nThe list of vertices of P, or an error if P is unbounded.\n\nNotes\n\nThis function returns an error if the polyhedron is unbounded. Otherwise, the polyhedron is converted to an HPolytope and its list of vertices is computed.\n\nExamples\n\njulia> P = HPolyhedron([HalfSpace([1.0, 0.0], 1.0),\n                        HalfSpace([0.0, 1.0], 1.0),\n                        HalfSpace([-1.0, 0.0], 1.0),\n                        HalfSpace([0.0, -1.0], 1.0)]);\n\njulia> length(vertices_list(P))\n4\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.singleton_list-Tuple{AbstractPolyhedron}","page":"Interfaces","title":"LazySets.singleton_list","text":"singleton_list(P::AbstractPolyhedron; check_boundedness::Bool=true)\n\nReturn the vertices of a polyhedron in H-representation as a list of singletons.\n\nInput\n\nP                 – polyhedron in constraint representation\ncheck_boundedness – (optional, default: true) if true, check whether the                        polyhedron is bounded\n\nOutput\n\nThe list of vertices of P, as Singleton, or an error if P is unbounded.\n\nNotes\n\nThis function returns an error if the polyhedron is unbounded. Otherwise, the polyhedron is converted to an HPolytpe and its list of vertices is computed.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Plotting (bounded) polyhedra is available, too:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"plot_recipe(::AbstractPolyhedron{N}, ::N=zero(N)) where {N<:Real}","category":"page"},{"location":"lib/interfaces/#LazySets.plot_recipe-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}, Tuple{AbstractPolyhedron{N},N}} where N<:Real","page":"Interfaces","title":"LazySets.plot_recipe","text":"plot_recipe(P::AbstractPolyhedron{N}, [ε]::N=zero(N)) where {N<:Real}\n\nConvert a (bounded) polyhedron to a pair (x, y) of points for plotting.\n\nInput\n\nP – bounded polyhedron\nε – (optional, default: 0) ignored, used for dispatch\n\nOutput\n\nA pair (x, y) of points that can be plotted.\n\nAlgorithm\n\nWe first assert that P is bounded (i.e., that P is a polytope).\n\nOne-dimensional polytopes are converted to an Interval. Three-dimensional or higher-dimensional polytopes are not supported.\n\nFor two-dimensional polytopes (i.e., polygons) we compute their set of vertices using vertices_list and then plot the convex hull of these vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Implementations-3","page":"Interfaces","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Half-space (HalfSpace)\nPolyhedron in constraint representation (HPolyhedron)\nHyperplane\nLine2D\nUniverse","category":"page"},{"location":"lib/interfaces/#def_AbstractPolytope","page":"Interfaces","title":"Polytopes (AbstractPolytope)","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"A polytope is a bounded set with finitely many vertices (V-representation) resp. facets (H-representation). Note that there is a special interface combination Centrally symmetric polytope.","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"AbstractPolytope","category":"page"},{"location":"lib/interfaces/#LazySets.AbstractPolytope","page":"Interfaces","title":"LazySets.AbstractPolytope","text":"AbstractPolytope{N<:Real} <: AbstractPolyhedron{N}\n\nAbstract type for compact convex polytopic sets.\n\nNotes\n\nEvery concrete AbstractPolytope must define the following functions:\n\nvertices_list(::AbstractPolytope{N}) – return a list of all vertices\n\njulia> subtypes(AbstractPolytope)\n4-element Array{Any,1}:\n AbstractCentrallySymmetricPolytope\n AbstractPolygon\n HPolytope\n VPolytope\n\nA polytope is a bounded polyhedron (see AbstractPolyhedron). Polytopes are compact convex sets with either of the following equivalent properties:\n\nThey are the intersection of a finite number of closed half-spaces.\nThey are the convex hull of finitely many vertices.\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"isbounded(::AbstractPolytope)\nisuniversal(::AbstractPolytope{N}, ::Bool=false) where {N<:Real}\nsingleton_list(::AbstractPolytope{N}) where {N<:Real}\nisempty(::AbstractPolytope)","category":"page"},{"location":"lib/interfaces/#LazySets.isbounded-Tuple{AbstractPolytope}","page":"Interfaces","title":"LazySets.isbounded","text":"isbounded(P::AbstractPolytope)\n\nDetermine whether a polytopic set is bounded.\n\nInput\n\nP – polytopic set\n\nOutput\n\ntrue (since a polytope must be bounded).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.isuniversal-Union{Tuple{AbstractPolytope{N}}, Tuple{N}, Tuple{AbstractPolytope{N},Bool}} where N<:Real","page":"Interfaces","title":"LazySets.isuniversal","text":"isuniversal(P::AbstractPolytope{N}, [witness]::Bool=false\n           ) where {N<:Real}\n\nCheck whether a polyhedron is universal.\n\nInput\n\nP       – polyhedron\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: false\nIf witness option is activated: (false, v) where v  P\n\nAlgorithm\n\nA witness is produced using isuniversal(H) where H is the first linear constraint of P.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.singleton_list","text":"singleton_list(P::AbstractPolytope{N}) where {N<:Real}\n\nReturn the vertices of a polytopic set as a list of singletons.\n\nInput\n\nP – polytopic set\n\nOutput\n\nList containing a singleton for each vertex.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Base.isempty-Tuple{AbstractPolytope}","page":"Interfaces","title":"Base.isempty","text":"isempty(P::AbstractPolytope)\n\nDetermine whether a polytope is empty.\n\nInput\n\nP – abstract polytope\n\nOutput\n\ntrue if the given polytope contains no vertices, and false otherwise.\n\nAlgorithm\n\nThis algorithm checks whether the vertices_list of the given polytope is empty or not.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Implementations-4","page":"Interfaces","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Polytope in constraint representation (HPolytope)\nPolytope in vertex representation (VPolytope)","category":"page"},{"location":"lib/interfaces/#def_AbstractPolygon","page":"Interfaces","title":"Polygons (AbstractPolygon)","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"A polygon is a two-dimensional polytope.","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"AbstractPolygon","category":"page"},{"location":"lib/interfaces/#LazySets.AbstractPolygon","page":"Interfaces","title":"LazySets.AbstractPolygon","text":"AbstractPolygon{N<:Real} <: AbstractPolytope{N}\n\nAbstract type for polygons (i.e., 2D polytopes).\n\nNotes\n\nEvery concrete AbstractPolygon must define the following functions:\n\ntovrep(::AbstractPolygon{N})         – transform into   V-representation\ntohrep(::AbstractPolygon{N}) where {S<:AbstractHPolygon{N}} – transform   into H-representation\n\njulia> subtypes(AbstractPolygon)\n2-element Array{Any,1}:\n AbstractHPolygon\n VPolygon\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"dim(P::AbstractPolygon)\nlinear_map(::AbstractMatrix{N}, P::AbstractPolygon{N}) where {N<:Real}","category":"page"},{"location":"lib/interfaces/#LazySets.dim-Tuple{AbstractPolygon}","page":"Interfaces","title":"LazySets.dim","text":"dim(P::AbstractPolygon)\n\nReturn the ambient dimension of a polygon.\n\nInput\n\nP – polygon\n\nOutput\n\nThe ambient dimension of the polygon, which is 2.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolygon{N}}} where N<:Real","page":"Interfaces","title":"LazySets.linear_map","text":"linear_map(M::AbstractMatrix{N},\n           P::AbstractPolyhedron{N};\n           [algorithm]::Union{String, Nothing}=nothing,\n           [check_invertibility]::Bool=true,\n           [cond_tol]::Number=DEFAULT_COND_TOL,\n           [inverse]::Union{AbstractMatrix{N}, Nothing}=nothing,\n           [backend]=nothing,\n           [elimination_method]=nothing) where {N<:Real}\n\nConcrete linear map of a polyhedral set.\n\nInput\n\nM         – matrix\nP         – polyhedral set\nalgorithm – (optional; default: nothing) algorithm to be used; for the                description see the Algorithm section below; possible choices are:\n\"inverse\", alias: \"inv\"\n\"inverse_right\", alias: \"inv_right\"\n\"elimination\", alias: \"elim\"\n\"lift\"\n\"vrep\"\ncheck_invertibility – (optional, default: true) if true check whether                          given matrix M is invertible; set to false only                          if you know that M is invertible\ncond_tol  – (optional; default: DEFAULT_COND_TOL) tolerance of matrix                condition (used to check whether the matrix is invertible)\ninverse   – (optional; default: nothing) matrix inverse M⁻¹; use this                option if you have already computed the inverse matrix of M\nbackend   – (optional: default: nothing) polyhedra backend\nelimination_method  – (optional: default: nothing) elimination method for                          the \"elimination\" algorithm\n\nOutput\n\nThe type of the result is \"as close as possible\" to the the type of P. Let (m, n) be the size of M, where m ≠ n is allowed for rectangular maps.\n\nTo fix the type of the output to something different than the default value, consider post-processing the result of this function with a call to a suitable convert method.\n\nIn particular, the output depends on the type of P, on m, and the algorithm that was used:\n\nIf the vertex-based approach was used:\nIf P is a VPolygon and m = 2 then the output is a VPolygon.\nIf P is a VPolytope then the output is a VPolytope.\nOtherwise, the output is an Interval if m = 1, a VPolygon if m = 2 and a VPolytope in other cases.\nIf the invertibility criterion was used:\nThe types of HalfSpace, Hyperplane, Line2D and AbstractHPolygon are preserved.\nIf P is an AbstractPolytope, then the output is an Interval if m = 1, an HPolygon if m = 2 and an HPolytope in other cases.\nOtherwise, the output is an HPolyhedron.\n\nNotes\n\nSince the different linear map algorithms work at the level of constraints (not sets representations), this function uses dispatch on two stages: once the algorithm has been defined, first the helper functions _linear_map_hrep_helper (resp. _linear_map_vrep) are invoked, which dispatch on the set type. Then, each helper function calls the concrete implementation of _linear_map_hrep, which dispatches on the algorithm, and returns a list of constraints.\n\nTo simplify working with different algorithms and options, the types <: AbstractLinearMapAlgorithm are used. These types are singleton type or types that carry only the key data for the given algorithm, such as the matrix inverse or the polyhedra backend.\n\nNew subtypes of the AbstractPolyhedron interface may define their own helper functions _linear_map_vrep, respectively _linear_map_hrep_helper for special handling of the constraints returned by the implementations of _linear_map_hrep; otherwise the fallback implementation for AbstractPolyhedron is used, which instantiates an HPolyhedron.\n\nAlgorithm\n\nThis function mainly implements several approaches for the linear map: inverse, right inverse, transformation to the vertex representation, variable elimination, and variable lifting. Depending on the properties of M and P, one algorithm may be preferable over the other. Details on the algorithms are given in the following subsections.\n\nOtherwise, if the algorithm argument is not specified, a default option is chosen based on heuristics on the types and values of M and P:\n\nIf the \"inverse\" algorithm applies, it is used.\nIf the \"inverse_right\" algorithm applies, it is used.\nOtherwise, if the \"lift\" algorithm applies, it is used.\nOtherwise, the \"elimination\" algorithm is used.\n\nNote that \"inverse\" does not require the external library Polyhedra, and neither does \"inverse_right\". However, the fallback method \"elimination\" requires Polyhedra as well as the library CDDLib.\n\nThe optional keyword arguments inverse and check_invertibility modify the default behavior:\n\nIf an inverse matrix is passed in inverse, the given algorithm is applied, and if none is given, either \"inverse\" or \"inverse_right\" is applied (in that order of preference).\nIf check_invertibility is set to false, the given algorithm is applied, and if none is given, either \"inverse\" or \"inverse_right\" is applied (in that order of preference).\n\nInverse\n\nThis algorithm is invoked with the keyword argument algorithm=\"inverse\" (or algorithm=\"inv\"). The algorithm requires that M is invertible, square, and dense. If you know a priori that M is invertible, set the flag check_invertibility=false, such that no extra checks are done within linear_map. Otherwise, we check the sufficient condition that the condition number of M is not too high. The threshold for the condition number can be modified from its default value, DEFAULT_COND_TOL, by passing a custom cond_tol.\n\nThe algorithm is described next. Assuming that the matrix M is invertible (which we check via a sufficient condition,), y = M x implies x = textinv(M) y and we can transform the polyhedron A x  b to the polyhedron A textinv(M) y  b.\n\nIf the dense condition on M is not fullfilled, there are two suggested workarounds: either transform to dense matrix, i.e. calling linear_map with Matrix(M), or use the \"inverse_right\" algorithm, which does not compute the inverse matrix explicitly, but uses a polyalgorithm; see the documentation of ? for details.\n\nInverse-right\n\nThis algorithm is invoked with the keyword argument algorithm=\"inverse_right\" (or algorithm=\"inv_right\"). This algorithm applies to square and invertible matrices M. The idea is essentially the same as for the \"inverse\" algorithm; the difference is that in \"inverse\" the full matrix inverse is computed, and in \"inverse_right\" only the left division on the normal vectors is used. In particular, \"inverse_right\" is good as a workaround when M is sparse (since the inv function is not available for sparse matrices).\n\nElimination\n\nThis algorithm is invoked with the keyword argument algorithm = \"elimination\" or algorithm = \"elim\". The algorithm applies to any matrix M (invertible or not), and any polyhedron P (bounded or not).\n\nThe idea is described next. If P : Ax <= b and y = Mx denote the polyhedron and the linear map respectively, we consider the vector z = [y, x], write the given equalities and the inequalities, and then eliminate the last x variables (there are length(x) in total) using a call to Polyhedra.eliminate to a backend library that can do variable elimination, typically CDDLib with the BlockElimination() algorithm. In this way we have eliminated the \"old\" variables x and kept the \"new\" or transformed variables \"y\".\n\nThe default elimination method is block elimination. For possible options we refer to the documentation of Polyhedra, projection/elimination.\n\nLift\n\nThis algorithm is invoked with the keyword argument algorithm=\"lift\". The algorithm applies if M is rectangular of size m × n with m > n and full rank (i.e. of rank n).\n\nThe idea is to embed the polyhedron into the m-dimensional space by appending zeros, i.e. extending all constraints of P to m dimensions, and constraining the last m - n dimensions to 0. The matrix resulting matrix is extended to an invertible m × m matrix and the algorithm using the inverse of the linear map is applied. For the technical details of the extension of M to a higher-dimensional invertible matrix, see LazySets.Arrays.extend.\n\nVertex representation\n\nThis algorithm is invoked with the keyword argument algorithm=\"vrep\". The idea is to convert the polyhedron to its vertex representation and apply the linear map to each vertex of P.\n\nThe returned set is a polytope in vertex representation. Note that conversion of the result back to half-space representation is not computed by default, since this may be costly. If you used this algorithm and still want to convert back to half-space representation, apply tohrep to the result of this function. Note that this method only works for bounded polyhedra.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"The following helper functions are used for sorting directions:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"LazySets.jump2pi\n<=(::AbstractVector{N}, ::AbstractVector{N}) where {N<:AbstractFloat}\n<=(::AbstractVector{N}, ::AbstractVector{N}) where {N<:Real}\nLazySets.quadrant(::AbstractVector{Real})","category":"page"},{"location":"lib/interfaces/#LazySets.jump2pi","page":"Interfaces","title":"LazySets.jump2pi","text":"jump2pi(x::N) where {N<:AbstractFloat}\n\nReturn x + 2π if x is negative, otherwise return x.\n\nInput\n\nx – real scalar\n\nOutput\n\nx + 2π if x is negative, x otherwise.\n\nExamples\n\njulia> using LazySets: jump2pi\n\njulia> jump2pi(0.0)\n0.0\n\njulia> jump2pi(-0.5)\n5.783185307179586\n\njulia> jump2pi(0.5)\n0.5\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/#Base.:<=-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,1}}} where N<:AbstractFloat","page":"Interfaces","title":"Base.:<=","text":"<=(u::AbstractVector{N}, v::AbstractVector{N}) where {N<:Real}\n\nCompare two 2D vectors by their direction.\n\nInput\n\nu – first 2D direction\nv – second 2D direction\n\nOutput\n\ntrue iff arg(u) 2π  arg(v) 2π.\n\nNotes\n\nThe argument is measured in counter-clockwise fashion, with the 0 being the direction (1, 0).\n\nAlgorithm\n\nThe implementation checks the quadrant of each direction, and compares directions using the right-hand rule (see is_right_turn). In particular, this method does not use the arctangent.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Base.:<=-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,1}}} where N<:Real","page":"Interfaces","title":"Base.:<=","text":"<=(u::AbstractVector{N}, v::AbstractVector{N}) where {N<:Real}\n\nCompare two 2D vectors by their direction.\n\nInput\n\nu – first 2D direction\nv – second 2D direction\n\nOutput\n\ntrue iff arg(u) 2π  arg(v) 2π.\n\nNotes\n\nThe argument is measured in counter-clockwise fashion, with the 0 being the direction (1, 0).\n\nAlgorithm\n\nThe implementation checks the quadrant of each direction, and compares directions using the right-hand rule (see is_right_turn). In particular, this method does not use the arctangent.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.quadrant-Tuple{AbstractArray{Real,1}}","page":"Interfaces","title":"LazySets.quadrant","text":"quadrant(w::AbstractVector{N}) where {N<:Real}\n\nCompute the quadrant where the direction w belongs.\n\nInput\n\nw –  direction\n\nOutput\n\nAn integer from 0 to 3, with the following convention:\n\n     ^\n   1 | 0\n  ---+-->\n   2 | 3\n\nAlgorithm\n\nThe idea is to encode the following logic function: 11  0 01  1 00  2 10  3, according to the convention of above.\n\nThis function is inspired from AGPX's answer in: Sort points in clockwise order?\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Implementations-5","page":"Interfaces","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Polygon in vertex representation (VPolygon)","category":"page"},{"location":"lib/interfaces/#def_AbstractHPolygon","page":"Interfaces","title":"Polygons in constraint representation (AbstractHPolygon)","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"An HPolygon is a polygon in H-representation (or constraint representation).","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"AbstractHPolygon","category":"page"},{"location":"lib/interfaces/#LazySets.AbstractHPolygon","page":"Interfaces","title":"LazySets.AbstractHPolygon","text":"AbstractHPolygon{N<:Real} <: AbstractPolygon{N}\n\nAbstract type for polygons in H-representation (i.e., constraints).\n\nNotes\n\nAll subtypes must satisfy the invariant that constraints are sorted counter-clockwise.\n\nEvery concrete AbstractHPolygon must have the following fields:\n\nconstraints::Vector{LinearConstraint{N, AbstractVector{N}}} – the constraints\n\nNew subtypes should be added to the convert method in order to be convertible.\n\njulia> subtypes(AbstractHPolygon)\n2-element Array{Any,1}:\n HPolygon\n HPolygonOpt\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"an_element(::AbstractHPolygon{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::AbstractHPolygon{N}) where {N<:Real}\nrand(::Type{HPOLYGON}) where {HPOLYGON<:AbstractHPolygon}\ntohrep(::HPOLYGON) where {HPOLYGON<:AbstractHPolygon}\ntovrep(::AbstractHPolygon{N}) where {N<:Real}\naddconstraint!(::AbstractHPolygon{N}, ::LinearConstraint{N}) where {N<:Real}\naddconstraint!(::Vector{LC}, ::LinearConstraint{N}) where {N<:Real, LC<:LinearConstraint{N}}\nnormalize(P::AbstractHPolygon{N}, p=N(2)) where {N<:Real}\nisredundant(::LinearConstraint{N}, ::LinearConstraint{N}, ::LinearConstraint{N}) where {N<:Real}\nremove_redundant_constraints!(::AbstractHPolygon)\nconstraints_list(::AbstractHPolygon{N}) where {N<:Real}\nvertices_list(::AbstractHPolygon{N}) where {N<:Real}\nisbounded(::AbstractHPolygon, ::Bool=true)","category":"page"},{"location":"lib/interfaces/#LazySets.an_element-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.an_element","text":"an_element(P::AbstractHPolygon{N}) where {N<:Real}\n\nReturn some element of a polygon in constraint representation.\n\nInput\n\nP – polygon in constraint representation\n\nOutput\n\nA vertex of the polygon in constraint representation (the first one in the order of the constraints).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHPolygon{N}}} where N<:Real","page":"Interfaces","title":"Base.:∈","text":"∈(x::AbstractVector{N}, P::AbstractHPolygon{N}) where {N<:Real}\n\nCheck whether a given 2D point is contained in a polygon in constraint representation.\n\nInput\n\nx – two-dimensional point/vector\nP – polygon in constraint representation\n\nOutput\n\ntrue iff x  P.\n\nAlgorithm\n\nThis implementation checks if the point lies on the outside of each edge.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Base.rand-Union{Tuple{Type{HPOLYGON}}, Tuple{HPOLYGON}} where HPOLYGON<:AbstractHPolygon","page":"Interfaces","title":"Base.rand","text":"rand(::Type{HPOLYGON}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing,\n     [num_constraints]::Int=-1) where {HPOLYGON<:AbstractHPolygon}\n\nCreate a random polygon in constraint representation.\n\nInput\n\nHPOLYGON        – type for dispatch\nN               – (optional, default: Float64) numeric type\ndim             – (optional, default: 2) dimension\nrng             – (optional, default: GLOBAL_RNG) random number generator\nseed            – (optional, default: nothing) seed for reseeding\nnum_constraints – (optional, default: -1) number of constraints of the                      polygon (must be 3 or bigger; see comment below)\n\nOutput\n\nA random polygon in constraint representation.\n\nAlgorithm\n\nWe create a random polygon in vertex representation and convert it to constraint representation. See rand(::Type{VPolygon}). For non-flat polygons the number of vertices and the number of constraints are identical.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.tohrep-Union{Tuple{HPOLYGON}, Tuple{HPOLYGON}} where HPOLYGON<:AbstractHPolygon","page":"Interfaces","title":"LazySets.tohrep","text":"tohrep(P::HPOLYGON) where {HPOLYGON<:AbstractHPolygon}\n\nBuild a contraint representation of the given polygon.\n\nInput\n\nP – polygon in constraint representation\n\nOutput\n\nThe identity, i.e., the same polygon instance.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.tovrep-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.tovrep","text":"tovrep(P::AbstractHPolygon{N}) where {N<:Real}\n\nBuild a vertex representation of the given polygon.\n\nInput\n\nP – polygon in constraint representation\n\nOutput\n\nThe same polygon but in vertex representation, a VPolygon.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.addconstraint!-Union{Tuple{N}, Tuple{AbstractHPolygon{N},HalfSpace{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Interfaces","title":"LazySets.addconstraint!","text":"addconstraint!(P::AbstractHPolygon{N},\n               constraint::LinearConstraint{N};\n               [linear_search]::Bool=(length(P.constraints) <\n                                      BINARY_SEARCH_THRESHOLD),\n               [prune]::Bool=true) where {N<:Real}\n\nAdd a linear constraint to a polygon in constraint representation, keeping the constraints sorted by their normal directions.\n\nInput\n\nP             – polygon in constraint representation\nconstraint    – linear constraint to add\nlinear_search – (optional, default: length(constraints) <                    BINARY_SEARCH_THRESHOLD) flag to choose between linear                    and binary search\nprune         – (optional, default: true) flag for removing redundant                    constraints in the end\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.addconstraint!-Union{Tuple{LC}, Tuple{N}, Tuple{Array{LC,1},HalfSpace{N,VN} where VN<:AbstractArray{N,1}}} where LC<:(HalfSpace{N,VN} where VN<:AbstractArray{N,1}) where N<:Real","page":"Interfaces","title":"LazySets.addconstraint!","text":"addconstraint!(constraints::Vector{LC},\n               new_constraint::LinearConstraint{N};\n               [linear_search]::Bool=(length(P.constraints) <\n                                      BINARY_SEARCH_THRESHOLD),\n               [prune]::Bool=true\n              ) where {N<:Real, LC<:LinearConstraint{N}}\n\nAdd a linear constraint to a sorted vector of constrains, keeping the constraints sorted by their normal directions.\n\nInput\n\nconstraints    – vector of linear constraintspolygon in constraint                     representation\nnew_constraint – linear constraint to add\nlinear_search  – (optional, default: length(constraints) <                     BINARY_SEARCH_THRESHOLD) flag to choose between linear                     and binary search\nprune          – (optional, default: true) flag for removing redundant                     constraints in the end\n\nAlgorithm\n\nIf prune is active, we check if the new constraint is redundant. If the constraint is not redundant, we perform the same check to the left and to the right until we find the first constraint that is not redundant.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LinearAlgebra.normalize-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}, Tuple{AbstractHPolygon{N},Any}} where N<:Real","page":"Interfaces","title":"LinearAlgebra.normalize","text":"normalize(P::AbstractHPolygon{N}, p=N(2)) where {N<:Real}\n\nNormalize a polygon in constraint representation.\n\nInput\n\nP – polygon in constraint representation\np – (optional, default: 2) norm\n\nOutput\n\nA new polygon in constraint representation whose normal directions a_i are normalized, i.e., such that a_i_p = 1 holds.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.isredundant-Union{Tuple{N}, Tuple{HalfSpace{N,VN} where VN<:AbstractArray{N,1},HalfSpace{N,VN} where VN<:AbstractArray{N,1},HalfSpace{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Interfaces","title":"LazySets.isredundant","text":"isredundant(cmid::LinearConstraint{N}, cright::LinearConstraint{N},\n            cleft::LinearConstraint{N}) where {N<:Real}\n\nCheck whether a linear constraint is redundant wrt. two surrounding constraints.\n\nInput\n\ncmid   – linear constraint of concern\ncright – linear constraint to the right (clockwise turn)\ncleft  – linear constraint to the left (counter-clockwise turn)\n\nOutput\n\ntrue iff the constraint is redundant.\n\nAlgorithm\n\nWe first check whether the angle between the surrounding constraints is < 180°, which is a necessary condition (unless the direction is identical to one of the other two constraints). If so, we next check if the angle is 0°, in which case the constraint cmid is redundant unless it is strictly tighter than the other two constraints. If the angle is strictly between 0° and 180°, the constraint cmid is redundant if and only if the vertex defined by the other two constraints lies inside the set defined by cmid.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.remove_redundant_constraints!-Tuple{AbstractHPolygon}","page":"Interfaces","title":"LazySets.remove_redundant_constraints!","text":"remove_redundant_constraints!(P::AbstractHPolygon)\n\nRemove all redundant constraints of a polygon in constraint representation.\n\nInput\n\nP – polygon in constraint representation\n\nOutput\n\nThe same polygon with all redundant constraints removed.\n\nNotes\n\nSince we only consider bounded polygons and a polygon needs at least three constraints to be bounded, we stop removing redundant constraints if there are three or less constraints left. This means that for non-bounded polygons the result may be unexpected.\n\nAlgorithm\n\nWe go through all consecutive triples of constraints and check if the one in the middle is redundant. For this we assume that the constraints are sorted.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.constraints_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.constraints_list","text":"constraints_list(P::AbstractHPolygon{N}) where {N<:Real}\n\nReturn the list of constraints defining a polygon in H-representation.\n\nInput\n\nP – polygon in H-representation\n\nOutput\n\nThe list of constraints of the polygon. The implementation guarantees that the constraints are sorted counter-clockwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.vertices_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.vertices_list","text":"vertices_list(P::AbstractHPolygon{N};\n              apply_convex_hull::Bool=true,\n              check_feasibility::Bool=true) where {N<:Real}\n\nReturn the list of vertices of a polygon in constraint representation.\n\nInput\n\nP                 – polygon in constraint representation\napply_convex_hull – (optional, default: true) flag to post-process the                        intersection of constraints with a convex hull\ncheck_feasibility – (optional, default: true) flag to check whether the                        polygon was empty (required for correctness in case of                        empty polygons)\n\nOutput\n\nList of vertices.\n\nAlgorithm\n\nWe compute each vertex as the intersection of consecutive lines defined by the half-spaces. If check_feasibility is active, we then check if the constraints of the polygon were actually feasible (i.e., they pointed in the right direction). For this we compute the average of all vertices and check membership in each constraint.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.isbounded","page":"Interfaces","title":"LazySets.isbounded","text":"isbounded(P::AbstractHPolygon, [use_type_assumption]::Bool=true)\n\nDetermine whether a polygon in constraint representation is bounded.\n\nInput\n\nP                   – polygon in constraint representation\nuse_type_assumption – (optional, default: true) flag for ignoring the                          type assumption that polygons are bounded\n\nOutput\n\ntrue if use_type_assumption is activated. Otherwise, true iff P is bounded.\n\nAlgorithm\n\nIf !use_type_assumption, we convert P to an HPolyhedron P2 and then use isbounded(P2).\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/#Implementations-6","page":"Interfaces","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Polygon in constraint representation (HPolygon)\nPolygon in optimized constraint representation (HPolygonOpt)","category":"page"},{"location":"lib/interfaces/#def_AbstractCentrallySymmetricPolytope","page":"Interfaces","title":"Centrally symmetric polytopes (AbstractCentrallySymmetricPolytope)","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"A centrally symmetric polytope is a combination of two other interfaces: Centrally symmetric sets and Polytope.","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"AbstractCentrallySymmetricPolytope","category":"page"},{"location":"lib/interfaces/#LazySets.AbstractCentrallySymmetricPolytope","page":"Interfaces","title":"LazySets.AbstractCentrallySymmetricPolytope","text":"AbstractCentrallySymmetricPolytope{N<:Real} <: AbstractPolytope{N}\n\nAbstract type for centrally symmetric, polytopic sets. It combines the AbstractCentrallySymmetric and AbstractPolytope interfaces. Such a type combination is necessary as long as Julia does not support multiple inheritance.\n\nNotes\n\nEvery concrete AbstractCentrallySymmetricPolytope must define the following functions:\n\nfrom AbstractCentrallySymmetric:\ncenter(::AbstractCentrallySymmetricPolytope{N}) – return the  center point\nfrom AbstractPolytope:\nvertices_list(::AbstractCentrallySymmetricPolytope{N})  – return a list of all vertices\n\njulia> subtypes(AbstractCentrallySymmetricPolytope)\n2-element Array{Any,1}:\n AbstractZonotope\n Ball1\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"dim(::AbstractCentrallySymmetricPolytope)\nan_element(::AbstractCentrallySymmetricPolytope{N}) where {N<:Real}\nisempty(::AbstractCentrallySymmetricPolytope)\nisuniversal(::AbstractCentrallySymmetricPolytope{N}, ::Bool=false) where {N<:Real}\ncenter(::AbstractCentrallySymmetricPolytope{N}, ::Int) where {N<:Real}","category":"page"},{"location":"lib/interfaces/#LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}","page":"Interfaces","title":"LazySets.dim","text":"dim(P::AbstractCentrallySymmetricPolytope)\n\nReturn the ambient dimension of a centrally symmetric, polytopic set.\n\nInput\n\nP – centrally symmetric, polytopic set\n\nOutput\n\nThe ambient dimension of the polytopic set.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.an_element","text":"an_element(P::AbstractCentrallySymmetricPolytope{N}) where {N<:Real}\n\nReturn some element of a centrally symmetric polytope.\n\nInput\n\nP – centrally symmetric polytope\n\nOutput\n\nThe center of the centrally symmetric polytope.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}","page":"Interfaces","title":"Base.isempty","text":"isempty(P::AbstractCentrallySymmetricPolytope)\n\nReturn if a centrally symmetric, polytopic set is empty or not.\n\nInput\n\nP – centrally symmetric, polytopic set\n\nOutput\n\nfalse.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.isuniversal-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}, Tuple{AbstractCentrallySymmetricPolytope{N},Bool}} where N<:Real","page":"Interfaces","title":"LazySets.isuniversal","text":"isuniversal(S::AbstractCentrallySymmetricPolytope{N}, [witness]::Bool=false\n           ) where {N<:Real}\n\nCheck whether a centrally symmetric polytope is universal.\n\nInput\n\nS       – centrally symmetric polytope\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: false\nIf witness option is activated: (false, v) where v  S\n\nAlgorithm\n\nA witness is obtained by computing the support vector in direction d = [1, 0, …, 0] and adding d on top.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.center-Union{Tuple{N}, Tuple{AbstractCentrallySymmetricPolytope{N},Int64}} where N<:Real","page":"Interfaces","title":"LazySets.center","text":"center(H::AbstractCentrallySymmetricPolytope{N}, i::Int) where {N<:Real}\n\nReturn the center along a given dimension of a centrally symmetric polytope.\n\nInput\n\nS – centrally symmetric polytope\ni – dimension of interest\n\nOutput\n\nThe center along a given dimension of the centrally symmetric polytope.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Implementations-7","page":"Interfaces","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Manhattan-norm ball (Ball1)","category":"page"},{"location":"lib/interfaces/#def_AbstractZonotope","page":"Interfaces","title":"Zonotopes (AbstractZonotope)","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"A zonotope is a specific centrally symmetric polytope characterized by a center and a collection of generators.","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"AbstractZonotope","category":"page"},{"location":"lib/interfaces/#LazySets.AbstractZonotope","page":"Interfaces","title":"LazySets.AbstractZonotope","text":"AbstractZonotope{N<:Real} <: AbstractCentrallySymmetricPolytope{N}\n\nAbstract type for zonotopic sets.\n\nNotes\n\nMathematically, a zonotope is defined as the set\n\nZ = left c + _i=1^p ξ_i g_i ξ_i in -1 1  i = 1 p right\n\nwhere c in mathbbR^n is its center and g_i_i=1^p, g_i in mathbbR^n, is the set of generators. This characterization defines a zonotope as the finite Minkowski sum of line segments. Zonotopes can be equivalently described as the image of a unit infinity-norm ball in mathbbR^n by an affine transformation.\n\nSee Zonotope for a standard implementation of this interface.\n\nEvery concrete AbstractZonotope must define the following functions:\n\ngenmat(::AbstractZonotope{N}) – return the generator matrix\ngenerators(::AbstractZonotope{N}) – return an iterator over the generators\n\nSince the functions genmat and generators can be defined in terms of each other, it is sufficient to only genuinely implement one of them and let the implementation of the other function call the fallback implementation genmat_fallback resp. generators_fallback.\n\njulia> subtypes(AbstractZonotope)\n3-element Array{Any,1}:\n AbstractHyperrectangle\n LineSegment\n Zonotope\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"ngens(::AbstractZonotope)\ngenmat_fallback(::AbstractZonotope{N}) where {N<:Real}\ngenerators_fallback(::AbstractZonotope{N}) where {N<:Real}\nρ(::AbstractVector{N}, ::AbstractZonotope{N}) where {N<:Real}\nσ(::AbstractVector{N}, ::AbstractZonotope{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::AbstractZonotope{N}) where {N<:Real}\nlinear_map(::AbstractMatrix{N}, ::AbstractZonotope{N}) where {N<:Real}\ntranslate(::AbstractZonotope{N}, ::AbstractVector{N}) where {N<:Real}\nconstraints_list(::AbstractZonotope{N}) where {N<:Real}\nconstraints_list(::AbstractZonotope{N}; ::Bool=true) where {N<:AbstractFloat}\nvertices_list(::AbstractZonotope{N}) where {N<:Real}\norder(::AbstractZonotope)\ntogrep(::AbstractZonotope)\n⊆(Z::AbstractZonotope{N}, H::AbstractHyperrectangle{N}) where {N<:Real}","category":"page"},{"location":"lib/interfaces/#LazySets.ngens-Tuple{AbstractZonotope}","page":"Interfaces","title":"LazySets.ngens","text":"ngens(Z::AbstractZonotope)\n\nReturn the number of generators of a zonotopic set.\n\nInput\n\nZ – zonotopic set\n\nOutput\n\nAn integer representing the number of generators.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.genmat_fallback-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.genmat_fallback","text":"genmat_fallback(Z::AbstractZonotope{N}) where {N<:Real}\n\nFallback definition of genmat for zonotopic sets.\n\nInput\n\nZ     – zonotopic set\ngens  – (optional; default: generators(Z)) iterator over generators\nngens – (optional; default: nothing) number of generators or nothing if            unknown\n\nOutput\n\nA matrix where each column represents one generator of Z.\n\nNotes\n\nPassing the number of generators is much more efficient as otherwise the generators have to be obtained from the iterator (gens) and stored in an intermediate vector until the final result matrix can be allocated.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.generators_fallback-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.generators_fallback","text":"generators_fallback(Z::AbstractZonotope{N}) where {N<:Real}\n\nFallback definition of generators for zonotopic sets.\n\nInput\n\nZ – zonotopic set\n\nOutput\n\nAn iterator over the generators of Z.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractZonotope{N}}} where N<:Real","page":"Interfaces","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, Z::AbstractZonotope{N}) where {N<:Real}\n\nReturn the support function of a zonotopic set in a given direction.\n\nInput\n\nd – direction\nZ – zonotopic set\n\nOutput\n\nThe support function of the zonotopic set in the given direction.\n\nAlgorithm\n\nThe support value is cᵀ d + Gᵀ d₁ where c is the center and G is the generator matrix of Z.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractZonotope{N}}} where N<:Real","page":"Interfaces","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, Z::AbstractZonotope{N}) where {N<:Real}\n\nReturn the support vector of a zonotopic set in a given direction.\n\nInput\n\nd – direction\nZ – zonotopic set\n\nOutput\n\nA support vector in the given direction. If the direction has norm zero, the vertex with ξ_i = 1    i = 1 p is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractZonotope{N}}} where N<:Real","page":"Interfaces","title":"Base.:∈","text":"∈(x::AbstractVector{N}, Z::AbstractZonotope{N};\n  solver=default_lp_solver(N)) where {N<:Real}\n\nCheck whether a given point is contained in a zonotopic set.\n\nInput\n\nx      – point/vector\nZ      – zonotopic set\nsolver – (optional, default: default_lp_solver(N)) the backend used to             solve the linear program\n\nOutput\n\ntrue iff x  Z.\n\nExamples\n\njulia> Z = Zonotope([1.0, 0.0], [0.1 0.0; 0.0 0.1]);\n\njulia> [1.0, 0.2] ∈ Z\nfalse\njulia> [1.0, 0.1] ∈ Z\ntrue\n\nAlgorithm\n\nThe membership problem is computed by stating and solving the following linear program. Let p and n be the number of generators and ambient dimension, respectively. We consider the minimization of x_0 in the p+1-dimensional space of elements (x_0 ξ_1  ξ_p) constrained to 0  x_0  , ξ_i  -1 1 for all i = 1  p, and such that x-c = Gξ holds. If a feasible solution exists, the optimal value x_0 = 0 is achieved.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractZonotope{N}}} where N<:Real","page":"Interfaces","title":"LazySets.linear_map","text":"linear_map(M::AbstractMatrix{N}, Z::AbstractZonotope{N}) where {N<:Real}\n\nConcrete linear map of a zonotopic set.\n\nInput\n\nM – matrix\nZ – zonotopic set\n\nOutput\n\nThe zonotope obtained by applying the linear map to the center and generators of Z.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.translate-Union{Tuple{N}, Tuple{AbstractZonotope{N},AbstractArray{N,1}}} where N<:Real","page":"Interfaces","title":"LazySets.translate","text":"translate(Z::AbstractZonotope{N}, v::AbstractVector{N}; share::Bool=false\n         ) where {N<:Real}\n\nTranslate (i.e., shift) a zonotope by a given vector.\n\nInput\n\nZ     – zonotope\nv     – translation vector\nshare – (optional, default: false) flag for sharing unmodified parts of            the original set representation\n\nOutput\n\nA translated zonotope.\n\nNotes\n\nThe generator matrix is shared with the original zonotope if share == true.\n\nAlgorithm\n\nWe add the vector to the center of the zonotope.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.constraints_list-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.constraints_list","text":"constraints_list(P::AbstractZonotope{N}) where {N<:Real}\n\nReturn the list of constraints defining a zonotopic set.\n\nInput\n\nZ – zonotopic set\n\nOutput\n\nThe list of constraints of the zonotopic set.\n\nAlgorithm\n\nThis is the (inefficient) fallback implementation for rational numbers. It first computes the vertices and then converts the corresponding polytope to constraint representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.constraints_list-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N<:AbstractFloat","page":"Interfaces","title":"LazySets.constraints_list","text":"constraints_list(Z::AbstractZonotope{N}; check_full_rank::Bool=true\n                ) where {N<:AbstractFloat}\n\nReturn the list of constraints defining a zonotopic set.\n\nInput\n\nZ               – zonotopic set\ncheck_full_rank – (optional; default: true) flag for checking whether the                      generator matrix has full rank\n\nOutput\n\nThe list of constraints of the zonotopic set.\n\nNotes\n\nThe algorithm assumes that no generator is redundant. The result has 2 binompn-1 (with p being the number of generators and n being the ambient dimension) constraints, which is optimal under this assumption.\n\nIf p  n or the generator matrix is not full rank, we fall back to the (slower) computation based on the vertex representation.\n\nAlgorithm\n\nWe follow the algorithm presented in Althoff, Stursberg, Buss: Computing Reachable Sets of Hybrid Systems Using a Combination of Zonotopes and Polytopes. 2009.\n\nThe one-dimensional case is not covered by that algorithm; we manually handle this case, assuming that there is only one generator.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.vertices_list-Union{Tuple{AbstractZonotope{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.vertices_list","text":"vertices_list(Z::AbstractZonotope{N}; [apply_convex_hull]::Bool=true\n             ) where {N<:Real}\n\nReturn the vertices of a zonotopic set.\n\nInput\n\nZ                 – zonotopic set\napply_convex_hull – (optional, default: true) if true, post-process the                        computation with the convex hull of the points\n\nOutput\n\nList of vertices as a vector of vectors.\n\nAlgorithm\n\nIf the zonotopic set has p generators, each vertex is the result of summing the center with some linear combination of generators, where the combination factors are ξ_i  -1 1.\n\nThere are at most 2^p distinct vertices. Use the flag apply_convex_hull to control whether a convex hull algorithm is applied to the vertices computed by this method; otherwise, redundant vertices may be present.\n\nWe use a trick to speed up enumerating vertices of 2-dimensional zonotopic sets with all generators in the first quadrant or third quadrant (same sign). Namely, sort the generators in angle and add them clockwise in increasing order and anticlockwise in decreasing order, the algorithm detail: https://math.stackexchange.com/q/3356460\n\nTo avoid cumulative sum from both directions separately, we build a 2d index matrix to sum generators for both directions in one matrix-vector product.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.order-Tuple{AbstractZonotope}","page":"Interfaces","title":"LazySets.order","text":"order(Z::AbstractZonotope)\n\nReturn the order of a zonotope.\n\nInput\n\nZ – zonotope\n\nOutput\n\nA rational number representing the order of the zonotope.\n\nNotes\n\nThe order of a zonotope is defined as the quotient of its number of generators and its dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.togrep-Tuple{AbstractZonotope}","page":"Interfaces","title":"LazySets.togrep","text":"togrep(Z::AbstractZonotope)\n\nReturn a generator representation of a zonotopic set.\n\nInput\n\nZ – zonotopic set\n\nOutput\n\nThe same set in generator representation. This fallback implementation returns a Zonotope; however, more specific implementations may return other generator representations.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Base.:⊆-Union{Tuple{N}, Tuple{AbstractZonotope{N},AbstractHyperrectangle{N}}} where N<:Real","page":"Interfaces","title":"Base.:⊆","text":"⊆(Z::AbstractZonotope{N}, H::AbstractHyperrectangle{N}) where {N<:Real}\n\nCheck whether a zonotopic set is contained in a hyperrectangular set.\n\nInput\n\nZ – inner zonotopic set\nH – outer hyperrectangular set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\ntrue iff Z  H otherwise false\n\nAlgorithm\n\nAlgorithm based on Lemma 3.1 of [1]\n\n[1] Mitchell, I. M., Budzis, J., & Bolyachevets, A. (2019, April). Invariant,  viability and discriminating kernel under-approximation via zonotope scaling.  In Proceedings of the 22nd ACM International Conference on Hybrid Systems:  Computation and Control (pp. 268-269).\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Implementations-8","page":"Interfaces","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Zonotope\nLine segment (LineSegment)","category":"page"},{"location":"lib/interfaces/#def_AbstractHyperrectangle","page":"Interfaces","title":"Hyperrectangles (AbstractHyperrectangle)","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"A hyperrectangle is a special centrally symmetric polytope with axis-aligned facets.","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"AbstractHyperrectangle","category":"page"},{"location":"lib/interfaces/#LazySets.AbstractHyperrectangle","page":"Interfaces","title":"LazySets.AbstractHyperrectangle","text":"AbstractHyperrectangle{N<:Real} <: AbstractZonotope{N}\n\nAbstract type for hyperrectangular sets.\n\nNotes\n\nSee Hyperrectangle for a standard implementation of this interface.\n\nEvery concrete AbstractHyperrectangle must define the following functions:\n\nradius_hyperrectangle(::AbstractHyperrectangle{N}) – return the   hyperrectangle's radius, which is a full-dimensional vector\nradius_hyperrectangle(::AbstractHyperrectangle{N}, i::Int) – return the   hyperrectangle's radius in the i-th dimension\nisflat(::AbstractHyperrectangle{N}) – determine whether the   hyperrectangle's radius is zero in some dimension\n\njulia> subtypes(AbstractHyperrectangle)\n5-element Array{Any,1}:\n AbstractSingleton\n BallInf\n Hyperrectangle\n Interval\n SymmetricIntervalHull\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"norm(::AbstractHyperrectangle, ::Real=Inf)\nradius(::AbstractHyperrectangle, ::Real=Inf)\nσ(::AbstractVector{N}, ::AbstractHyperrectangle{N}) where {N<:Real}\nρ(::AbstractVector{N}, ::AbstractHyperrectangle{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::AbstractHyperrectangle{N}) where {N<:Real}\nvertices_list(::AbstractHyperrectangle{N}) where {N<:Real}\nconstraints_list(::AbstractHyperrectangle{N}) where {N<:Real}\nhigh(::AbstractHyperrectangle{N}) where {N<:Real}\nhigh(::AbstractHyperrectangle{N}, ::Int) where {N<:Real}\nlow(::AbstractHyperrectangle{N}) where {N<:Real}\nlow(::AbstractHyperrectangle{N}, ::Int) where {N<:Real}\nisflat(::AbstractHyperrectangle)\nsplit(::AbstractHyperrectangle{N}, ::AbstractVector{Int}) where {N<:Real}\ngenerators(::AbstractHyperrectangle)\ngenmat(::AbstractHyperrectangle)\nngens(::AbstractHyperrectangle{N}) where {N<:Real}\nrectify(::AbstractHyperrectangle)","category":"page"},{"location":"lib/interfaces/#LinearAlgebra.norm-2","page":"Interfaces","title":"LinearAlgebra.norm","text":"norm(H::AbstractHyperrectangle, [p]::Real=Inf)\n\nReturn the norm of a hyperrectangular set.\n\nThe norm of a hyperrectangular set is defined as the norm of the enclosing ball, of the given p-norm, of minimal volume that is centered in the origin.\n\nInput\n\nH – hyperrectangular set\np – (optional, default: Inf) norm\n\nOutput\n\nA real number representing the norm.\n\nAlgorithm\n\nRecall that the norm is defined as\n\n X  = max_x  X  x _p = max_x  textvertices(X)  x _p\n\nThe last equality holds because the optimum of a convex function over a polytope is attained at one of its vertices.\n\nThis implementation uses the fact that the maximum is achieved in the vertex c + textdiag(textsign(c)) r, for any p-norm, hence it suffices to take the p-norm of this particular vertex. This statement is proved below. Note that, in particular, there is no need to compute the p-norm for each vertex, which can be very expensive.\n\nIf X is an axis-aligned hyperrectangle and the n-dimensional vectors center and radius of the hyperrectangle are denoted c and r respectively, then reasoning on the 2^n vertices we have that:\n\nmax_x  textvertices(X)  x _p = max_α_1  α_n  -1 1 (c_1 + α_1 r_1^p +  + c_n + α_n r_n^p)^1p\n\nThe function x  x^p, p  0, is monotonically increasing and thus the maximum of each term c_i + α_i r_i^p is given by c_i + textsign(c_i) r_i^p for each i. Hence, x^* = textargmax_x  X  x _p is the vertex c + textdiag(textsign(c)) r.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/#LazySets.radius-2","page":"Interfaces","title":"LazySets.radius","text":"radius(H::AbstractHyperrectangle, [p]::Real=Inf)\n\nReturn the radius of a hyperrectangular set.\n\nInput\n\nH – hyperrectangular set\np – (optional, default: Inf) norm\n\nOutput\n\nA real number representing the radius.\n\nNotes\n\nThe radius is defined as the radius of the enclosing ball of the given p-norm of minimal volume with the same center. It is the same for all corners of a hyperrectangular set.\n\n\n\n\n\n","category":"function"},{"location":"lib/interfaces/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N<:Real","page":"Interfaces","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, H::AbstractHyperrectangle{N}) where {N<:Real}\n\nReturn the support vector of a hyperrectangular set in a given direction.\n\nInput\n\nd – direction\nH – hyperrectangular set\n\nOutput\n\nThe support vector in the given direction. If the direction has norm zero, the vertex with biggest values is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N<:Real","page":"Interfaces","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, H::AbstractHyperrectangle{N}) where {N<:Real}\n\nEvaluate the support function of a hyperrectangular set in a given direction.\n\nInput\n\nd – direction\nH – hyperrectangular set\n\nOutput\n\nEvaluation of the support function in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N<:Real","page":"Interfaces","title":"Base.:∈","text":"∈(x::AbstractVector{N}, H::AbstractHyperrectangle{N}) where {N<:Real}\n\nCheck whether a given point is contained in a hyperrectangular set.\n\nInput\n\nx – point/vector\nH – hyperrectangular set\n\nOutput\n\ntrue iff x  H.\n\nAlgorithm\n\nLet H be an n-dimensional hyperrectangular set, c_i and r_i be the box's center and radius and x_i be the vector x in dimension i, respectively. Then x  H iff c_i - x_i  r_i for all i=1n.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.vertices_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.vertices_list","text":"vertices_list(H::AbstractHyperrectangle{N}) where {N<:Real}\n\nReturn the list of vertices of a hyperrectangular set.\n\nInput\n\nH – hyperrectangular set\n\nOutput\n\nA list of vertices. Zeros in the radius are correctly handled, i.e., the result does not contain any duplicate vertices.\n\nNotes\n\nFor high dimensions, it is preferable to develop a vertex_iterator approach.\n\nAlgorithm\n\nFirst we identify the dimensions where H is flat, i.e., its radius is zero. We also compute the number of vertices that we have to create.\n\nNext we create the vertices. We do this by enumerating all vectors v of length n (the dimension of H) with entries -1/0/1 and construct the corresponding vertex as follows:\n\n    textvertex(v)(i) = begincases c(i) + r(i)  v(i) = 1 \n                                          c(i)  v(i) = 0 \n                                          c(i) - r(i)  v(i) = -1 endcases\n\nFor enumerating the vectors v, we modify the current v from left to right by changing entries -1 to 1, skipping entries 0, and stopping at the first entry 1 (but changing it to -1). This way we only need to change the vertex in those dimensions where v has changed, which usually is a smaller number than n.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.constraints_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.constraints_list","text":"constraints_list(H::AbstractHyperrectangle{N}) where {N<:Real}\n\nReturn the list of constraints of an axis-aligned hyperrectangular set.\n\nInput\n\nH – hyperrectangular set\n\nOutput\n\nA list of linear constraints.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.high-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.high","text":"high(H::AbstractHyperrectangle{N}) where {N<:Real}\n\nReturn the higher coordinates of a hyperrectangular set.\n\nInput\n\nH – hyperrectangular set\n\nOutput\n\nA vector with the higher coordinates of the hyperrectangular set.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.high-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},Int64}} where N<:Real","page":"Interfaces","title":"LazySets.high","text":"high(H::AbstractHyperrectangle{N}, i::Int) where {N<:Real}\n\nReturn the higher coordinate of a hyperrectangular set in a given dimension.\n\nInput\n\nH – hyperrectangular set\ni – dimension of interest\n\nOutput\n\nThe higher coordinate of the hyperrectangular set in the given dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.low-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.low","text":"low(H::AbstractHyperrectangle{N}) where {N<:Real}\n\nReturn the lower coordinates of a hyperrectangular set.\n\nInput\n\nH – hyperrectangular set\n\nOutput\n\nA vector with the lower coordinates of the hyperrectangular set.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.low-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},Int64}} where N<:Real","page":"Interfaces","title":"LazySets.low","text":"low(H::AbstractHyperrectangle{N}, i::Int) where {N<:Real}\n\nReturn the lower coordinate of a hyperrectangular set in a given dimension.\n\nInput\n\nH – hyperrectangular set\ni – dimension of interest\n\nOutput\n\nThe lower coordinate of the hyperrectangular set in the given dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.isflat-Tuple{AbstractHyperrectangle}","page":"Interfaces","title":"LazySets.isflat","text":"isflat(H::AbstractHyperrectangle)\n\nDetermine whether a hyperrectangular set is flat, i.e. whether its radius is zero in some dimension.\n\nInput\n\nH – hyperrectangular set\n\nOutput\n\ntrue iff the hyperrectangular set is flat.\n\nNotes\n\nFor robustness with respect to floating-point inputs, this function relies on the result of isapproxzero when applied to the radius in some dimension. Hence, this function depends on the absolute zero tolerance ABSZTOL.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Base.split-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractArray{Int64,1}}} where N<:Real","page":"Interfaces","title":"Base.split","text":"split(H::AbstractHyperrectangle{N}, num_blocks::AbstractVector{Int}\n     ) where {N<:Real}\n\nPartition a hyperrectangular set into uniform sub-hyperrectangles.\n\nInput\n\nH          – hyperrectangular set\nnum_blocks – number of blocks in the partition for each dimension\n\nOutput\n\nA list of Hyperrectangles.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.generators-Tuple{AbstractHyperrectangle}","page":"Interfaces","title":"LazySets.generators","text":"generators(H::AbstractHyperrectangle)\n\nReturn an iterator over the generators of a hyperrectangular set.\n\nInput\n\nH – hyperrectangular set\n\nOutput\n\nAn iterator over the generators of H.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.genmat-Tuple{AbstractHyperrectangle}","page":"Interfaces","title":"LazySets.genmat","text":"genmat(H::AbstractHyperrectangle)\n\nReturn the generator matrix of a hyperrectangular set.\n\nInput\n\nH – hyperrectangular set\n\nOutput\n\nA matrix where each column represents one generator of H.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.ngens-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.ngens","text":"ngens(H::AbstractHyperrectangle{N}) where {N<:Real}\n\nReturn the number of generators of a hyperrectangular set.\n\nInput\n\nH – hyperrectangular set\n\nOutput\n\nThe number of generators.\n\nAlgorithm\n\nA hyperrectangular set has one generator for each non-flat dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.Arrays.rectify-Tuple{AbstractHyperrectangle}","page":"Interfaces","title":"LazySets.Arrays.rectify","text":"rectify(H::AbstractHyperrectangle)\n\nConcrete rectification of a hyperrectangular set.\n\nInput\n\nH – hyperrectangular set\n\nOutput\n\nThe Hyperrectangle that corresponds to the rectification of H.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Implementations-9","page":"Interfaces","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Concrete set representations:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Hyperrectangle\nInfinity-norm ball (BallInf)\nInterval","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Lazy set operations:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Symmetric interval hull (SymmetricIntervalHull)","category":"page"},{"location":"lib/interfaces/#def_AbstractSingleton","page":"Interfaces","title":"Singletons (AbstractSingleton)","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"A singleton is a special hyperrectangle consisting of only one point.","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"AbstractSingleton","category":"page"},{"location":"lib/interfaces/#LazySets.AbstractSingleton","page":"Interfaces","title":"LazySets.AbstractSingleton","text":"AbstractSingleton{N<:Real} <: AbstractHyperrectangle{N}\n\nAbstract type for sets with a single value.\n\nNotes\n\nEvery concrete AbstractSingleton must define the following functions:\n\nelement(::AbstractSingleton{N}) – return the single element\nelement(::AbstractSingleton{N}, i::Int) – return the single element's   entry in the i-th dimension\n\njulia> subtypes(AbstractSingleton)\n2-element Array{Any,1}:\n Singleton\n ZeroSet\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"σ(::AbstractVector{N}, ::AbstractSingleton{N}) where {N<:Real}\nρ(::AbstractVector{N}, ::AbstractSingleton{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::AbstractSingleton{N}) where {N<:Real}\nan_element(::AbstractSingleton{N}) where {N<:Real}\ncenter(::AbstractSingleton{N}) where {N<:Real}\nvertices_list(::AbstractSingleton{N}) where {N<:Real}\nradius_hyperrectangle(::AbstractSingleton{N}) where {N<:Real}\nradius_hyperrectangle(::AbstractSingleton{N}, ::Int) where {N<:Real}\nhigh(::AbstractSingleton{N}) where {N<:Real}\nhigh(::AbstractSingleton{N}, ::Int) where {N<:Real}\nlow(::AbstractSingleton{N}) where {N<:Real}\nlow(::AbstractSingleton{N}, ::Int) where {N<:Real}\nlinear_map(::AbstractMatrix{N}, ::AbstractSingleton{N}) where {N<:Real}\ngenerators(::AbstractSingleton{N}) where {N<:Real}\ngenmat(::AbstractSingleton{N}) where {N<:Real}\nngens(::AbstractSingleton)\nplot_recipe(::AbstractSingleton{N}, ::N=zero(N)) where {N<:Real}\nRecipesBase.apply_recipe(::AbstractDict{Symbol,Any}, ::AbstractSingleton{N}, ::N=zero(N)) where {N<:Real}","category":"page"},{"location":"lib/interfaces/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N<:Real","page":"Interfaces","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, S::AbstractSingleton{N}) where {N<:Real}\n\nReturn the support vector of a set with a single value.\n\nInput\n\nd – direction\nS – set with a single value\n\nOutput\n\nThe support vector, which is the set's vector itself, irrespective of the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N<:Real","page":"Interfaces","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, S::AbstractSingleton{N}) where {N<:Real}\n\nEvaluate the support function of a set with a single value in a given direction.\n\nInput\n\nd – direction\nS – set with a single value\n\nOutput\n\nEvaluation of the support function in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N<:Real","page":"Interfaces","title":"Base.:∈","text":"∈(x::AbstractVector{N}, S::AbstractSingleton{N}) where {N<:Real}\n\nCheck whether a given point is contained in a set with a single value.\n\nInput\n\nx – point/vector\nS – set with a single value\n\nOutput\n\ntrue iff x  S.\n\nNotes\n\nThis implementation performs an exact comparison, which may be insufficient with floating point computations.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.an_element-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.an_element","text":"an_element(S::LazySet{N}) where {N<:Real}\n\nReturn some element of a convex set.\n\nInput\n\nS – convex set\n\nOutput\n\nAn element of a convex set.\n\nAlgorithm\n\nAn element of the set is obtained by evaluating its support vector along direction 1 0  0.\n\n\n\n\n\nan_element(P::AbstractPolyhedron{N}) where {N<:Real}\n\nReturn some element of a convex set.\n\nInput\n\nP – polyhedron\n\nOutput\n\nAn element of a polyhedron.\n\nAlgorithm\n\nAn element of the polyhedron is obtained by evaluating its support vector along direction 1 0  0.\n\n\n\n\n\nan_element(P::AbstractCentrallySymmetricPolytope{N}) where {N<:Real}\n\nReturn some element of a centrally symmetric polytope.\n\nInput\n\nP – centrally symmetric polytope\n\nOutput\n\nThe center of the centrally symmetric polytope.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.center-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.center","text":"center(S::AbstractSingleton{N}) where {N<:Real}\n\nReturn the center of a set with a single value.\n\nInput\n\nS – set with a single value\n\nOutput\n\nThe only element of the set.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.vertices_list-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.vertices_list","text":"vertices_list(S::AbstractSingleton{N}) where {N<:Real}\n\nReturn the list of vertices of a set with a single value.\n\nInput\n\nS – set with a single value\n\nOutput\n\nA list containing only a single vertex.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.radius_hyperrectangle-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(S::AbstractSingleton{N}) where {N<:Real}\n\nReturn the box radius of a set with a single value in every dimension.\n\nInput\n\nS – set with a single value\n\nOutput\n\nThe zero vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N<:Real","page":"Interfaces","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(S::AbstractSingleton{N}, i::Int) where {N<:Real}\n\nReturn the box radius of a set with a single value in a given dimension.\n\nInput\n\nS – set with a single value\ni – dimension of interest\n\nOutput\n\nZero.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.high-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.high","text":"high(S::AbstractSingleton{N}) where {N<:Real}\n\nReturn the higher coordinates of a set with a single value.\n\nInput\n\nS – set with a single value\n\nOutput\n\nA vector with the higher coordinates of the set with a single value.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.high-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N<:Real","page":"Interfaces","title":"LazySets.high","text":"high(S::AbstractSingleton{N}, i::Int) where {N<:Real}\n\nReturn the higher coordinate of a set with a single value in the given dimension.\n\nInput\n\nS – set with a single value\ni – dimension of interest\n\nOutput\n\nThe higher coordinate of the set with a single value in the given dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.low-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.low","text":"low(S::AbstractSingleton{N}) where {N<:Real}\n\nReturn the lower coordinates of a set with a single value.\n\nInput\n\nS – set with a single value\n\nOutput\n\nA vector with the lower coordinates of the set with a single value.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.low-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N<:Real","page":"Interfaces","title":"LazySets.low","text":"low(S::AbstractSingleton{N}, i::Int) where {N<:Real}\n\nReturn the lower coordinate of a set with a single value in the given dimension.\n\nInput\n\nS – set with a single value\ni – dimension of interest\n\nOutput\n\nThe lower coordinate of the set with a single value in the given dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractSingleton{N}}} where N<:Real","page":"Interfaces","title":"LazySets.linear_map","text":"linear_map(M::AbstractMatrix{N}, S::AbstractSingleton{N}) where {N<:Real}\n\nConcrete linear map of an abstract singleton.\n\nInput\n\nM – matrix\nS – abstract singleton\n\nOutput\n\nThe abstract singleton of the same type of S obtained by applying the linear map to the element in S.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.generators-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.generators","text":"generators(S::AbstractSingleton)\n\nReturn an (empty) iterator over the generators of a set with a single value.\n\nInput\n\nS – set with a single value\n\nOutput\n\nAn empty iterator.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.genmat-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.genmat","text":"genmat(S::AbstractSingleton)\n\nReturn the (empty) generator matrix of a set with a single value.\n\nInput\n\nS – set with a single value\n\nOutput\n\nA matrix with no columns representing the generators of S.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.ngens-Tuple{AbstractSingleton}","page":"Interfaces","title":"LazySets.ngens","text":"ngens(S::AbstractSingleton)\n\nReturn the number of generators of a set with a single value.\n\nInput\n\nH – set with a single value\n\nOutput\n\nThe number of generators.\n\nAlgorithm\n\nA set with a single value has no generators, so the result is 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.plot_recipe-Union{Tuple{AbstractSingleton{N}}, Tuple{N}, Tuple{AbstractSingleton{N},N}} where N<:Real","page":"Interfaces","title":"LazySets.plot_recipe","text":"plot_recipe(S::AbstractSingleton{N}, [ε]::N=zero(N)) where {N<:Real}\n\nConvert a singleton to a pair (x, y) of points for plotting.\n\nInput\n\nS – singleton\nε – (optional, default: 0) ignored, used for dispatch\n\nOutput\n\nA pair (x, y) of one point that can be plotted.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol,Any},AbstractSingleton{N}}, Tuple{AbstractDict{Symbol,Any},AbstractSingleton{N},N}} where N<:Real","page":"Interfaces","title":"RecipesBase.apply_recipe","text":"plot_singleton(S::AbstractSingleton{N}, [ε]::N=zero(N); ...) where {N<:Real}\n\nPlot a singleton.\n\nInput\n\nS – singleton\nε – (optional, default: 0) ignored, used for dispatch\n\nExamples\n\njulia> plot(Singleton([0.5, 1.0]))\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Implementations-10","page":"Interfaces","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Singleton\nOrigin (ZeroSet)","category":"page"},{"location":"lib/interfaces/#def_AbstractAffineMap","page":"Interfaces","title":"Affine maps (AbstractAffineMap)","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"An affine map consists of a linear map and a translation.","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"AbstractAffineMap","category":"page"},{"location":"lib/interfaces/#LazySets.AbstractAffineMap","page":"Interfaces","title":"LazySets.AbstractAffineMap","text":"AbstractAffineMap{N<:Real, S<:LazySet{N}} <: LazySet{N}\n\nAbstract type for affine maps.\n\nNotes\n\nSee AffineMap for a standard implementation of this interface.\n\nEvery concrete AbstractAffineMap must define the following functions:\n\nmatrix(::AbstractAffineMap) – return the linear map\nvector(::AbstractAffineMap) – return the affine translation vector\nset(::AbstractAffineMap) – return the set that the map is applied to\n\njulia> subtypes(AbstractAffineMap)\n6-element Array{Any,1}:\n AffineMap\n ExponentialMap\n ExponentialProjectionMap\n LinearMap\n ResetMap\n Translation\n\n\n\n\n\n","category":"type"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"This interface defines the following functions:","category":"page"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"dim(::AbstractAffineMap)\nσ(::AbstractVector{N}, ::AbstractAffineMap{N}) where {N<:Real}\nρ(::AbstractVector{N}, ::AbstractAffineMap{N}) where {N<:Real}\nan_element(::AbstractAffineMap)\nisempty(::AbstractAffineMap)\nisbounded(::AbstractAffineMap)\n∈(::AbstractVector{N}, ::AbstractAffineMap{N}) where {N<:Real}\nvertices_list(::AbstractAffineMap{N}) where {N<:Real}\nconstraints_list(::AbstractAffineMap{N}) where {N<:Real}\nlinear_map(::AbstractMatrix{N}, ::AbstractAffineMap{N}) where {N<:Real}","category":"page"},{"location":"lib/interfaces/#LazySets.dim-Tuple{AbstractAffineMap}","page":"Interfaces","title":"LazySets.dim","text":"dim(am::AbstractAffineMap)\n\nReturn the dimension of an affine map.\n\nInput\n\nam – affine map\n\nOutput\n\nThe dimension of an affine map.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractAffineMap{N,S} where S<:LazySet{N}}} where N<:Real","page":"Interfaces","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, am::AbstractAffineMap{N}) where {N<:Real}\n\nReturn the support vector of an affine map.\n\nInput\n\nd  – direction\nam – affine map\n\nOutput\n\nThe support vector in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractAffineMap{N,S} where S<:LazySet{N}}} where N<:Real","page":"Interfaces","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, am::AbstractAffineMap{N}) where {N<:Real}\n\nReturn the support function of an affine map.\n\nInput\n\nd  – direction\nam – affine map\n\nOutput\n\nThe support function in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.an_element-Tuple{AbstractAffineMap}","page":"Interfaces","title":"LazySets.an_element","text":"an_element(am::AbstractAffineMap)\n\nReturn some element of an affine map.\n\nInput\n\nam – affine map\n\nOutput\n\nAn element of the affine map. It relies on the an_element function of the wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Base.isempty-Tuple{AbstractAffineMap}","page":"Interfaces","title":"Base.isempty","text":"isempty(am::AbstractAffineMap)\n\nReturn whether an affine map is empty or not.\n\nInput\n\nam – affine map\n\nOutput\n\ntrue iff the wrapped set is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.isbounded-Tuple{AbstractAffineMap}","page":"Interfaces","title":"LazySets.isbounded","text":"isbounded(am::AbstractAffineMap; cond_tol::Number=DEFAULT_COND_TOL)\n\nDetermine whether an affine map is bounded.\n\nInput\n\nam       – affine map\ncond_tol – (optional) tolerance of matrix condition (used to check whether               the matrix is invertible)\n\nOutput\n\ntrue iff the affine map is bounded.\n\nAlgorithm\n\nWe first check if the matrix is zero or the wrapped set is bounded. If not, we perform a sufficient check whether the matrix is invertible. If the matrix is invertible, then the map being bounded is equivalent to the wrapped set being bounded, and hence the map is unbounded. Otherwise, we check boundedness via isbounded_unit_dimensions.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractAffineMap{N,S} where S<:LazySet{N}}} where N<:Real","page":"Interfaces","title":"Base.:∈","text":"∈(x::AbstractVector{N}, am::AbstractAffineMap{N}) where {N<:Real}\n\nCheck whether a given point is contained in the affine map of a convex set.\n\nInput\n\nx  – point/vector\nam – affine map of a convex set\n\nOutput\n\ntrue iff x  am.\n\nAlgorithm\n\nNote that x  MS  v iff M^-1(x - v)  S. This implementation does not explicitly invert the matrix, which is why it also works for non-square matrices.\n\nExamples\n\njulia> am = AffineMap([2.0 0.0; 0.0 1.0], BallInf([1., 1.], 1.), [-1.0, -1.0]);\n\njulia> [5.0, 1.0] ∈ am\nfalse\n\njulia> [3.0, 1.0] ∈ am\ntrue\n\nAn example with a non-square matrix:\n\njulia> B = BallInf(zeros(4), 1.);\n\njulia> M = [1. 0 0 0; 0 1 0 0]/2;\n\njulia> [0.5, 0.5] ∈ M*B\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.vertices_list-Union{Tuple{AbstractAffineMap{N,S} where S<:LazySet{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.vertices_list","text":"vertices_list(am::AbstractAffineMap{N};\n              [apply_convex_hull]::Bool) where {N<:Real}\n\nReturn the list of vertices of a (polyhedral) affine map.\n\nInput\n\nam                – affine map\napply_convex_hull – (optional, default: true) if true, apply the convex                        hull operation to the list of vertices transformed by                        the affine map\n\nOutput\n\nA list of vertices.\n\nAlgorithm\n\nThis implementation computes all vertices of X, then transforms them through the affine map, i.e. x ↦ M*x + v for each vertex x of X. By default, the convex hull operation is taken before returning this list. For dimensions three or higher, this operation relies on the functionality through the concrete polyhedra library Polyhedra.jl.\n\nIf you are not interested in taking the convex hull of the resulting vertices under the affine map, pass apply_convex_hull=false as a keyword argument.\n\nNote that we assume that the underlying set X is polyhedral, either concretely or lazily, i.e. there the function vertices_list should be applicable.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.constraints_list-Union{Tuple{AbstractAffineMap{N,S} where S<:LazySet{N}}, Tuple{N}} where N<:Real","page":"Interfaces","title":"LazySets.constraints_list","text":"constraints_list(am::AbstractAffineMap{N}) where {N<:Real}\n\nReturn the list of constraints of a (polyhedral) affine map.\n\nInput\n\nam – affine map\n\nOutput\n\nThe list of constraints of the affine map.\n\nNotes\n\nWe assume that the underlying set X is polyhedral, i.e., offers a method constraints_list(X).\n\nAlgorithm\n\nFalls back to the list of constraints of the translation of a lazy linear map.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractAffineMap{N,S} where S<:LazySet{N}}} where N<:Real","page":"Interfaces","title":"LazySets.linear_map","text":"linear_map(M::AbstractMatrix{N}, am::AbstractAffineMap{N}) where {N<:Real}\n\nReturn the linear map of a lazy affine map.\n\nInput\n\nM  – matrix\nam – affine map\n\nOutput\n\nA set corresponding to the linear map of the lazy affine map of a set.\n\n\n\n\n\n","category":"method"},{"location":"lib/interfaces/#Implementations-11","page":"Interfaces","title":"Implementations","text":"","category":"section"},{"location":"lib/interfaces/","page":"Interfaces","title":"Interfaces","text":"Affine map (AffineMap)\nExponential map (ExponentialMap)\nLinear map (LinearMap)\nReset map (ResetMap)\nTranslation","category":"page"},{"location":"lib/lazy_operations/ResetMap/","page":"ResetMap","title":"ResetMap","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/lazy_operations/ResetMap/#def_ResetMap","page":"ResetMap","title":"Reset map (ResetMap)","text":"","category":"section"},{"location":"lib/lazy_operations/ResetMap/","page":"ResetMap","title":"ResetMap","text":"ResetMap\ndim(::ResetMap)\nρ(::AbstractVector{N}, ::ResetMap{N}) where {N<:Real}\nσ(::AbstractVector{N}, ::ResetMap{N}) where {N<:Real}\nan_element(::ResetMap)\nmatrix(::ResetMap{N}) where {N<:Real}\nvector(::ResetMap{N}) where {N<:Real}\nconstraints_list(::ResetMap{N}) where {N<:Real}\nconstraints_list(::ResetMap{N, S}) where {N<:Real, S<:AbstractHyperrectangle}","category":"page"},{"location":"lib/lazy_operations/ResetMap/#LazySets.ResetMap","page":"ResetMap","title":"LazySets.ResetMap","text":"ResetMap{N<:Real, S<:LazySet{N}} <: AbstractAffineMap{N, S}\n\nType that represents a lazy reset map. A reset map is a special case of an affine map A x + b x  X where the linear map A is the identity matrix with zero entries in all reset dimensions, and the translation vector b is zero in all other dimensions.\n\nFields\n\nX      – convex set\nresets – resets (a mapping from an index to a new value)\n\nExamples\n\njulia> X = BallInf([2.0, 2.0, 2.0], 1.0);\n\njulia> r = Dict(1 => 4.0, 3 => 0.0);\n\njulia> rm = ResetMap(X, r);\n\n\nHere rm modifies the set X such that x1 is reset to 4 and x3 is reset to 0, while x2 is not modified. Hence rm is equivalent to the set Hyperrectangle([4.0, 2.0, 0.0], [0.0, 1.0, 0.0]), i.e., an axis-aligned line segment embedded in 3D.\n\nThe corresponding affine map A x + b would be:\n\n    eginpmatrix 0  0  0  0  1  0  0  0  0 ndpmatrix x +\n    eginpmatrix 4  0  0 ndpmatrix\n\nUse the function matrix (resp. vector) to create the matrix A (resp. vector b) corresponding to a given reset map.\n\njulia> matrix(rm)\n3×3 LinearAlgebra.Diagonal{Float64,Array{Float64,1}}:\n 0.0   ⋅    ⋅\n  ⋅   1.0   ⋅\n  ⋅    ⋅   0.0\n\njulia> vector(rm)\n3-element SparseArrays.SparseVector{Float64,Int64} with 1 stored entry:\n  [1]  =  4.0\n\nThe application of a ResetMap to a ZeroSet or an EmptySet is simplified automatically.\n\njulia> ResetMap(ZeroSet(3), r)\nSingleton{Float64,SparseArrays.SparseVector{Float64,Int64}}(  [1]  =  4.0)\n\njulia> ResetMap(EmptySet(3), r)\nEmptySet{Float64}(3)\n\nThe (in this case unique) support vector of rm in direction ones(3) is:\n\njulia> σ(ones(3), rm)\n3-element Array{Float64,1}:\n 4.0\n 3.0\n 0.0\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/ResetMap/#LazySets.dim-Tuple{ResetMap}","page":"ResetMap","title":"LazySets.dim","text":"dim(rm::ResetMap)\n\nReturn the dimension of a reset map.\n\nInput\n\nrm – reset map\n\nOutput\n\nThe dimension of a reset map.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ResetMap/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ResetMap{N,S} where S<:LazySet{N}}} where N<:Real","page":"ResetMap","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, rm::ResetMap{N}) where {N<:Real}\n\nReturn the support function of a reset map.\n\nInput\n\nd  – direction\nrm – reset map\n\nOutput\n\nThe support function in the given direction.\n\nNotes\n\nWe use the usual dot-product definition, but for unbounded sets we redefine the product between 0 and  as 0; Julia returns NaN here.\n\njulia> Inf * 0.0\nNaN\n\nSee the discussion here.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ResetMap/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ResetMap{N,S} where S<:LazySet{N}}} where N<:Real","page":"ResetMap","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, rm::ResetMap{N}) where {N<:Real}\n\nReturn the support vector of a reset map.\n\nInput\n\nd  – direction\nrm – reset map\n\nOutput\n\nThe support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ResetMap/#LazySets.an_element-Tuple{ResetMap}","page":"ResetMap","title":"LazySets.an_element","text":"an_element(rm::ResetMap)\n\nReturn some element of a reset map.\n\nInput\n\nrm – reset map\n\nOutput\n\nAn element in the reset map. It relies on the an_element function of the wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ResetMap/#LazySets.matrix-Union{Tuple{ResetMap{N,S} where S<:LazySet{N}}, Tuple{N}} where N<:Real","page":"ResetMap","title":"LazySets.matrix","text":"matrix(rm::ResetMap{N}) where {N<:Real}\n\nReturn the A matrix of the affine map A x + b x  X represented by a reset map.\n\nInput\n\nrm – reset map\n\nOutput\n\nThe (diagonal) matrix for the affine map A x + b x  X represented by the reset map.\n\nAlgorithm\n\nWe construct the identity matrix and set all entries in the reset dimensions to zero.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ResetMap/#LazySets.vector-Union{Tuple{ResetMap{N,S} where S<:LazySet{N}}, Tuple{N}} where N<:Real","page":"ResetMap","title":"LazySets.vector","text":"vector(rm::ResetMap{N}) where {N<:Real}\n\nReturn the b vector of the affine map A x + b x  X represented by a reset map.\n\nInput\n\nrm – reset map\n\nOutput\n\nThe (sparse) vector for the affine map A x + b x  X represented by the reset map. The vector contains the reset value for all reset dimensions, and is zero for all other dimensions.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ResetMap/#LazySets.constraints_list-Union{Tuple{ResetMap{N,S} where S<:LazySet{N}}, Tuple{N}} where N<:Real","page":"ResetMap","title":"LazySets.constraints_list","text":"constraints_list(rm::ResetMap{N}) where {N<:Real}\n\nReturn the list of constraints of a polytopic reset map.\n\nInput\n\nrm – reset map of a polytope\n\nOutput\n\nThe list of constraints of the reset map.\n\nNotes\n\nWe assume that the underlying set X is a polytope, i.e., is bounded and offers a method constraints_list(X).\n\nAlgorithm\n\nWe fall back to constraints_list of a LinearMap of the A-matrix in the affine-map view of a reset map. Each reset dimension i is projected to zero, expressed by two constraints for each reset dimension. Then it remains to shift these constraints to the new value.\n\nFor instance, if the dimension 5 was reset to 4, then there will be constraints x₅  0 and -x₅  0. We then modify the right-hand side of these constraints to x₅  4 and -x₅  -4, respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ResetMap/#LazySets.constraints_list-Union{Tuple{ResetMap{N,S}}, Tuple{S}, Tuple{N}} where S<:AbstractHyperrectangle where N<:Real","page":"ResetMap","title":"LazySets.constraints_list","text":"constraints_list(rm::ResetMap{N, S}) where\n    {N<:Real, S<:AbstractHyperrectangle}\n\nReturn the list of constraints of a hyperrectangular reset map.\n\nInput\n\nrm – reset map of a hyperrectangular set\n\nOutput\n\nThe list of constraints of the reset map.\n\nAlgorithm\n\nWe iterate through all dimensions. If there is a reset, we construct the corresponding (flat) constraints. Otherwise, we construct the corresponding constraints of the underlying set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ResetMap/","page":"ResetMap","title":"ResetMap","text":"Inherited from AbstractAffineMap:","category":"page"},{"location":"lib/lazy_operations/ResetMap/","page":"ResetMap","title":"ResetMap","text":"isempty\nisbounded\n∈\nvertices_list\nlinear_map","category":"page"},{"location":"lib/lazy_operations/ResetMap/","page":"ResetMap","title":"ResetMap","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/ResetMap/","page":"ResetMap","title":"ResetMap","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/BallInf/#def_BallInf","page":"BallInf","title":"Infinity-norm ball (BallInf)","text":"","category":"section"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"BallInf\ncenter(::BallInf{N}) where {N<:Real}\nradius(::BallInf, ::Real=Inf)\nradius_hyperrectangle(::BallInf{N}) where {N<:Real}\nradius_hyperrectangle(::BallInf{N}, ::Int) where {N<:Real}\nisflat(::BallInf)\nrand(::Type{BallInf})\nσ(::AbstractVector{N}, ::BallInf{N}) where {N<:Real}\nρ(::AbstractVector{N}, ::BallInf{N}) where {N<:Real}\ntranslate(::BallInf{N}, ::AbstractVector{N}) where {N<:Real}","category":"page"},{"location":"lib/sets/BallInf/#LazySets.BallInf","page":"BallInf","title":"LazySets.BallInf","text":"BallInf{N<:Real, VN<:AbstractVector{N}} <: AbstractHyperrectangle{N}\n\nType that represents a ball in the infinity norm.\n\nFields\n\ncenter – center of the ball as a real vector\nradius – radius of the ball as a real scalar ( 0)\n\nNotes\n\nMathematically, a ball in the infinity norm is defined as the set\n\nmathcalB_^n(c r) =  x  mathbbR^n   x - c _  r \n\nwhere c  mathbbR^n is its center and r  mathbbR_+ its radius. Here   _ denotes the infinity norm, defined as  x _ = maxlimits_i=1n vert x_i vert for any x  mathbbR^n.\n\nExamples\n\nCreate the two-dimensional unit ball and compute its support function along the positive x=y direction:\n\njulia> B = BallInf(zeros(2), 1.0)\nBallInf{Float64,Array{Float64,1}}([0.0, 0.0], 1.0)\n\njulia> dim(B)\n2\n\njulia> ρ([1., 1.], B)\n2.0\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/BallInf/#LazySets.center-Union{Tuple{BallInf{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"BallInf","title":"LazySets.center","text":"center(B::BallInf{N}) where {N<:Real}\n\nReturn the center of a ball in the infinity norm.\n\nInput\n\nB – ball in the infinity norm\n\nOutput\n\nThe center of the ball in the infinity norm.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#LazySets.radius","page":"BallInf","title":"LazySets.radius","text":"radius(B::BallInf, [p]::Real=Inf)\n\nReturn the radius of a ball in the infinity norm.\n\nInput\n\nB – ball in the infinity norm\np – (optional, default: Inf) norm\n\nOutput\n\nA real number representing the radius.\n\nNotes\n\nThe radius is defined as the radius of the enclosing ball of the given p-norm of minimal volume with the same center.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/BallInf/#LazySets.radius_hyperrectangle-Union{Tuple{BallInf{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"BallInf","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(B::BallInf{N}) where {N<:Real}\n\nReturn the box radius of a ball in the infinity norm, which is the same in every dimension.\n\nInput\n\nB – ball in the infinity norm\n\nOutput\n\nThe box radius of the ball in the infinity norm.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{BallInf{N,VN} where VN<:AbstractArray{N,1},Int64}} where N<:Real","page":"BallInf","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(B::BallInf{N}, i::Int) where {N<:Real}\n\nReturn the box radius of a ball in the infinity norm in a given dimension.\n\nInput\n\nB – ball in the infinity norm\ni – dimension of interest\n\nOutput\n\nThe box radius of the ball in the infinity norm in the given dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#LazySets.isflat-Tuple{BallInf}","page":"BallInf","title":"LazySets.isflat","text":"isflat(B::BallInf)\n\nDetermine whether a ball in the infinity norm is flat, i.e. whether its radius is zero.\n\nInput\n\nB – ball in the infinity norm\n\nOutput\n\ntrue iff the ball is flat.\n\nNotes\n\nFor robustness with respect to floating-point inputs, this function relies on the result of isapproxzero when applied to the radius of the ball. Hence, this function depends on the absolute zero tolerance ABSZTOL.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#Base.rand-Tuple{Type{BallInf}}","page":"BallInf","title":"Base.rand","text":"rand(::Type{BallInf}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nCreate a random ball in the infinity norm.\n\nInput\n\nBallInf – type for dispatch\nN       – (optional, default: Float64) numeric type\ndim     – (optional, default: 2) dimension\nrng     – (optional, default: GLOBAL_RNG) random number generator\nseed    – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random ball in the infinity norm.\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the radius is nonnegative.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},BallInf{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"BallInf","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, B::BallInf{N}) where {N<:Real}\n\nReturn the support vector of a ball in the infinity norm in a given direction.\n\nInput\n\nd – direction\nB – ball in the infinity norm\n\nOutput\n\nThe support vector in the given direction. If the direction has norm zero, the vertex with biggest values is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},BallInf{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"BallInf","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, B::BallInf{N}) where {N<:Real}\n\nEvaluate the support function of a ball in the infinity norm in a given direction.\n\nInput\n\nd – direction\nB – ball in the infinity norm\n\nOutput\n\nEvaluation of the support function in the given direction.\n\nAlgorithm\n\nLet B be a ball in the infinity norm with center c and radius r and let d be the direction of interest. For balls with dimensions less than 30 we use the implementation for AbstractHyperrectangle, taylored to a BallInf, which computes\n\n    _i=1^n d_i * (c_i + textrmsgn(d_i) * r)\n\nwhere textrmsgn(α) = 1 if α  0 and textrmsgn(α) = 1 if α  0.\n\nFor balls of higher dimension, we instead exploit that for a support vector v = σ(d B) = c + textrmsgn(d) * (r  r)ᵀ we have\n\n    ρ(d B) = d v = d c + d textrmsgn(d) * (r  r)ᵀ = d c + r  _i=1^n d_i\n\nwhere   denotes the dot product.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/#LazySets.translate-Union{Tuple{N}, Tuple{BallInf{N,VN} where VN<:AbstractArray{N,1},AbstractArray{N,1}}} where N<:Real","page":"BallInf","title":"LazySets.translate","text":"translate(B::BallInf{N}, v::AbstractVector{N}) where {N<:Real}\n\nTranslate (i.e., shift) a ball in the infinity norm by a given vector.\n\nInput\n\nB – ball in the infinity norm\nv – translation vector\n\nOutput\n\nA translated ball in the infinity norm.\n\nAlgorithm\n\nWe add the vector to the center of the ball.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"diameter","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"isbounded\nisuniversal\nsingleton_list","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"dim\nisempty\nan_element","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"ngens\nlinear_map\norder\ntogrep","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"Inherited from AbstractHyperrectangle:","category":"page"},{"location":"lib/sets/BallInf/","page":"BallInf","title":"BallInf","text":"∈\nnorm\nvertices_list\nhigh\nlow\ngenerators\ngenmat\nconstraints_list","category":"page"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/VPolygon/#def_VPolygon","page":"VPolygon","title":"Polygon in vertex representation (VPolygon)","text":"","category":"section"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"VPolygon\nσ(::AbstractVector{N}, ::VPolygon{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::VPolygon{N}) where {N<:Real}\nan_element(::VPolygon{N}) where {N<:Real}\nrand(::Type{VPolygon})\nvertices_list(::VPolygon{N}) where {N<:Real}\ntohrep(::VPolygon{N}, ::Type{HPOLYGON}=HPolygon) where {N<:Real, HPOLYGON<:AbstractHPolygon}\ntovrep(::VPolygon{N}) where {N<:Real}\nconstraints_list(::VPolygon{N}) where {N<:Real}\ntranslate(::VPolygon{N}, ::AbstractVector{N}) where {N<:Real}\nremove_redundant_vertices(::VPolygon{N}; ::String=\"monotone_chain\") where {N<:Real}\nremove_redundant_vertices!(::VPolygon{N}; ::String=\"monotone_chain\") where {N<:Real}","category":"page"},{"location":"lib/sets/VPolygon/#LazySets.VPolygon","page":"VPolygon","title":"LazySets.VPolygon","text":"VPolygon{N<:Real, VN<:AbstractVector{N}} <: AbstractPolygon{N}\n\nType that represents a polygon by its vertices.\n\nFields\n\nvertices – the list of vertices\n\nNotes\n\nThe constructor of VPolygon runs a convex hull algorithm on its vertices by default, to remove the possibly redundant vertices. The vertices are sorted in counter-clockwise fashion. Use the flag apply_convex_hull=false to skip the computation of the convex hull.\n\nVPolygon(vertices::Vector{Vector{N}};           apply_convex_hull::Bool=true,           algorithm::String=\"monotone_chain\")\n\nExamples\n\nA polygon in vertex representation can be constructed by passing the list of vertices. For example, we can build the right triangle\n\njulia> P = VPolygon([[0, 0], [1, 0], [0, 1]]);\n\njulia> P.vertices\n3-element Array{Array{Int64,1},1}:\n [0, 0]\n [1, 0]\n [0, 1]\n\nAlternatively, a VPolygon can be constructed passing a matrix of vertices, where each column represents a vertex:\n\njulia> M = [0 1 0; 0 0 1.]\n2×3 Array{Float64,2}:\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> P = VPolygon(M);\n\njulia> P.vertices\n3-element Array{Array{Float64,1},1}:\n [0.0, 0.0]\n [1.0, 0.0]\n [0.0, 1.0]\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/VPolygon/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},VPolygon{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"VPolygon","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, P::VPolygon{N}) where {N<:Real}\n\nReturn the support vector of a polygon in a given direction.\n\nInput\n\nd – direction\nP – polygon in vertex representation\n\nOutput\n\nThe support vector in the given direction. If the direction has norm zero, the first vertex is returned.\n\nAlgorithm\n\nThis implementation uses a binary search algorithm when the polygon has more than ten vertices and a brute-force search when it has ten or less. For the brute-force search, it compares the projection of each vector along the given direction and runs in O(n) where n is the number of vertices. For the binary search the algorithm runs in O(log n). We follow this implementation based on an algorithm described in [1].\n\n[1] Joseph O'Rourke, Computational Geometry in C (2nd Edition)\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},VPolygon{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"VPolygon","title":"Base.:∈","text":"∈(x::AbstractVector{N}, P::VPolygon{N}) where {N<:Real}\n\nCheck whether a given point is contained in a polygon in vertex representation.\n\nInput\n\nx – point/vector\nP – polygon in vertex representation\n\nOutput\n\ntrue iff x  P.\n\nAlgorithm\n\nThis implementation exploits that the polygon's vertices are sorted in counter-clockwise fashion. Under this assumption we can just check if the vertex lies on the left of each edge, using the dot product.\n\nExamples\n\njulia> P = VPolygon([[2.0, 3.0], [3.0, 1.0], [5.0, 1.0], [4.0, 5.0]];\n                    apply_convex_hull=false);\n\njulia> [4.5, 3.1] ∈ P\nfalse\njulia> [4.5, 3.0] ∈ P\ntrue\njulia> [4.4, 3.4] ∈ P  #  point lies on the edge\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.an_element-Union{Tuple{VPolygon{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"VPolygon","title":"LazySets.an_element","text":"an_element(P::VPolygon{N}) where {N<:Real}\n\nReturn some element of a polygon in vertex representation.\n\nInput\n\nP – polygon in vertex representation\n\nOutput\n\nThe first vertex of the polygon in vertex representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#Base.rand-Tuple{Type{VPolygon}}","page":"VPolygon","title":"Base.rand","text":"rand(::Type{VPolygon}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nCreate a random polygon in vertex representation.\n\nInput\n\nVPolygon     – type for dispatch\nN            – (optional, default: Float64) numeric type\ndim          – (optional, default: 2) dimension\nrng          – (optional, default: GLOBAL_RNG) random number generator\nseed         – (optional, default: nothing) seed for reseeding\nnum_vertices – (optional, default: -1) number of vertices of the                   polygon (see comment below)\n\nOutput\n\nA random polygon in vertex representation.\n\nAlgorithm\n\nWe follow the idea here based on P. Valtr. Probability that n random points are in convex position. There is also a nice video available here.\n\nThe number of vertices can be controlled with the argument num_vertices. For a negative value we choose a random number in the range 3:10.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.vertices_list-Union{Tuple{VPolygon{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"VPolygon","title":"LazySets.vertices_list","text":"vertices_list(P::VPolygon{N}) where {N<:Real}\n\nReturn the list of vertices of a convex polygon in vertex representation.\n\nInput\n\nP – a polygon vertex representation\n\nOutput\n\nList of vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.tohrep-Union{Tuple{VPolygon{N,VN} where VN<:AbstractArray{N,1}}, Tuple{HPOLYGON}, Tuple{N}, Tuple{VPolygon{N,VN} where VN<:AbstractArray{N,1},Type{HPOLYGON}}} where HPOLYGON<:AbstractHPolygon where N<:Real","page":"VPolygon","title":"LazySets.tohrep","text":"tohrep(P::VPolygon{N}, ::Type{HPOLYGON}=HPolygon\n      ) where {N<:Real, HPOLYGON<:AbstractHPolygon}\n\nBuild a constraint representation of the given polygon.\n\nInput\n\nP        – polygon in vertex representation\nHPOLYGON – (optional, default: HPolygon) type of target polygon\n\nOutput\n\nThe same polygon but in constraint representation, an AbstractHPolygon.\n\nAlgorithm\n\nThe algorithms consists of adding an edge for each consecutive pair of vertices. Since the vertices are already ordered in counter-clockwise fashion (CWW), the constraints will be sorted automatically (CCW) if we start with the first edge between the first and second vertex.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.tovrep-Union{Tuple{VPolygon{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"VPolygon","title":"LazySets.tovrep","text":"tovrep(P::VPolygon{N}) where {N<:Real}\n\nBuild a vertex representation of the given polygon.\n\nInput\n\nP – polygon in vertex representation\n\nOutput\n\nThe identity, i.e., the same polygon instance.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.constraints_list-Union{Tuple{VPolygon{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"VPolygon","title":"LazySets.constraints_list","text":"constraints_list(P::VPolygon{N}) where {N<:Real}\n\nReturn the list of constraints defining a polygon in V-representation.\n\nInput\n\nP – polygon in V-representation\n\nOutput\n\nThe list of constraints of the polygon.\n\nAlgorithm\n\nFirst the H-representation of P is computed, then its list of constraints is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.translate-Union{Tuple{N}, Tuple{VPolygon{N,VN} where VN<:AbstractArray{N,1},AbstractArray{N,1}}} where N<:Real","page":"VPolygon","title":"LazySets.translate","text":"translate(P::VPolygon{N}, v::AbstractVector{N}) where {N<:Real}\n\nTranslate (i.e., shift) a polygon in vertex representation by a given vector.\n\nInput\n\nP – polygon in vertex representation\nv – translation vector\n\nOutput\n\nA translated polygon in vertex representation.\n\nAlgorithm\n\nWe add the vector to each vertex of the polygon.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.remove_redundant_vertices-Union{Tuple{VPolygon{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"VPolygon","title":"LazySets.remove_redundant_vertices","text":"remove_redundant_vertices(P::VPolygon{N};\n                          [algorithm]::String=\"monotone_chain\") where {N<:Real}\n\nReturn the polygon obtained by removing the redundant vertices of the given polygon.\n\nInput\n\nP         – polygon in vertex representation\nalgorithm – (optional, default: \"monotone_chain\") the algorithm used to                compute the convex hull\n\nOutput\n\nA new polygon such that its vertices are the convex hull of the given polygon.\n\nAlgorithm\n\nA convex hull algorithm is used to compute the convex hull of the vertices of the given input polygon P; see ?convex_hull for details on the available algorithms. The vertices of the output polygon are sorted in counter-clockwise fashion.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/#LazySets.remove_redundant_vertices!-Union{Tuple{VPolygon{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"VPolygon","title":"LazySets.remove_redundant_vertices!","text":"remove_redundant_vertices!(P::VPolygon{N};\n                           [algorithm]::String=\"monotone_chain\") where {N<:Real}\n\nRemove the redundant vertices of the given polygon.\n\nInput\n\nP         – polygon in vertex representation\nalgorithm – (optional, default: \"monotone_chain\") the algorithm used to                compute the convex hull\n\nOutput\n\nA new polygon such that its vertices are the convex hull of the given polygon.\n\nAlgorithm\n\nA convex hull algorithm is used to compute the convex hull of the vertices of the given input polygon P; see ?convex_hull for details on the available algorithms. The vertices of the output polygon are sorted in counter-clockwise fashion.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"isbounded\nisempty\nisuniversal\nsingleton_list\nlinear_map","category":"page"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"Inherited from AbstractPolygon:","category":"page"},{"location":"lib/sets/VPolygon/","page":"VPolygon","title":"VPolygon","text":"dim","category":"page"},{"location":"man/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"In this section we review the recommended setup to start working with this package.","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Pages = [\"getting_started.md\"]","category":"page"},{"location":"man/getting_started/#Setup","page":"Getting Started","title":"Setup","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"This package requires Julia v0.6 or later. Refer to the official documentation on how to install it for your system. Below we explain the steps for setting up LazySets on your system and checking that it builds correctly.","category":"page"},{"location":"man/getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"To install LazySets, use the following command inside Julia's REPL:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Pkg.add(\"LazySets\")","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"or replace add by clone if you want to develop the code. The full list of dependencies (which are automatically installed) is specified in the REQUIRE file.","category":"page"},{"location":"man/getting_started/#Building-the-package","page":"Getting Started","title":"Building the package","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Use the following command from Julia's REPL:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using LazySets","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"This should precompile the package and make it available afterward.","category":"page"},{"location":"man/getting_started/#Optional-dependencies","page":"Getting Started","title":"Optional dependencies","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Some optional dependencies, such as Expokit.jl (a package that provides lazy matrix exponentiation routines), are not installed by default. When loading the corresponding packages in addition, new functionality in LazySets is added automatically (a feature that is possible through the Requires package).","category":"page"},{"location":"man/getting_started/#Workflow-tips","page":"Getting Started","title":"Workflow tips","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"There are different ways to use Julia: from the terminal, from the Julia REPL, from IJulia (i.e., Jupyter notebook), from Juno, etc. If you do not have a preferred choice, we recommend using LazySets through IJulia; one reason is that the visualization is conveniently embedded into the notebook, and it can be exported into different formats, among other benefits. On the other hand, for development purposes you probably want to use the REPL or the Juno environment.","category":"page"},{"location":"man/getting_started/#Updating","page":"Getting Started","title":"Updating","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"After working with LazySets for some time, you may want to get the newest version. For this you can use the following command (e.g., from the REPL):","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Pkg.checkout(\"LazySets\")","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"That will check out the latest version in the master branch, and precompile it the next time you enter a session and execute using LazySets.","category":"page"},{"location":"lib/lazy_operations/UnionSet/","page":"UnionSet","title":"UnionSet","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/lazy_operations/UnionSet/#Union","page":"UnionSet","title":"Union","text":"","category":"section"},{"location":"lib/lazy_operations/UnionSet/","page":"UnionSet","title":"UnionSet","text":"Note that the union of convex sets is generally not convex. Hence these set types are not part of the convex-set family LazySet.","category":"page"},{"location":"lib/lazy_operations/UnionSet/#def_UnionSet","page":"UnionSet","title":"Binary set union (UnionSet)","text":"","category":"section"},{"location":"lib/lazy_operations/UnionSet/","page":"UnionSet","title":"UnionSet","text":"UnionSet\n∪(::LazySet, ::LazySet)\nswap(::UnionSet)\ndim(::UnionSet)\nσ(::AbstractVector{N}, ::UnionSet{N}; algorithm=\"support_vector\") where {N<:Real}\nρ(::AbstractVector{N}, ::UnionSet{N}) where {N<:Real}\nan_element(::UnionSet{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::UnionSet{N}) where {N<:Real}\nisempty(::UnionSet)\nisbounded(::UnionSet)\nvertices_list(::UnionSet)","category":"page"},{"location":"lib/lazy_operations/UnionSet/#LazySets.UnionSet","page":"UnionSet","title":"LazySets.UnionSet","text":"UnionSet{N<:Real, S1<:LazySet{N}, S2<:LazySet{N}}\n\nType that represents the set union of two convex sets.\n\nFields\n\nX – convex set\nY – convex set\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/UnionSet/#Base.:∪-Tuple{LazySet,LazySet}","page":"UnionSet","title":"Base.:∪","text":"∪\n\nAlias for UnionSet.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.swap-Tuple{UnionSet}","page":"UnionSet","title":"LazySets.swap","text":"swap(cup::UnionSet)\n\nReturn a new UnionSet object with the arguments swapped.\n\nInput\n\ncup – union of two convex sets\n\nOutput\n\nA new UnionSet object with the arguments swapped.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.dim-Tuple{UnionSet}","page":"UnionSet","title":"LazySets.dim","text":"dim(cup::UnionSet)\n\nReturn the dimension of the set union of two convex sets.\n\nInput\n\ncup – union of two convex sets\n\nOutput\n\nThe ambient dimension of the union of two convex sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSet{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}} where N<:Real","page":"UnionSet","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, cup::UnionSet{N}; [algorithm]=\"support_vector\") where {N<:Real}\n\nReturn the support vector of the union of two convex sets in a given direction.\n\nInput\n\nd         – direction\ncup       – union of two convex sets\nalgorithm – (optional, default: \"supportvector\"): the algorithm to compute                the support vector; if \"supportvector\", use the support                vector of each argument; if \"support_function\" use the support                function of each argument and evaluate the support vector of only                one of them\n\nOutput\n\nThe support vector in the given direction.\n\nAlgorithm\n\nThe support vector of the union of two convex sets X and Y can be obtained as the vector that maximizes the support function of either X or Y, i.e. it is sufficient to find the argmax(ρ(d X) ρ(d Y)) and evaluate its support vector.\n\nThe default implementation, with option algorithm=\"support_vector\", computes the support vector of X and Y and then compares the support function using a dot product. If it happens that the support function can be more efficiently computed (without passing through the support vector), consider using the alternative algorithm=\"support_function\" implementation, which evaluates the support function of each set directly and then calls only the support vector of either X or Y.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSet{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}} where N<:Real","page":"UnionSet","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, cup::UnionSet{N}) where {N<:Real}\n\nReturn the support function of the union of two convex sets in a given direction.\n\nInput\n\nd   – direction\ncup – union of two convex sets\n\nOutput\n\nThe support function in the given direction.\n\nAlgorithm\n\nThe support function of the union of two convex sets X and Y is the maximum of the support functions of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.an_element-Union{Tuple{UnionSet{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}, Tuple{N}} where N<:Real","page":"UnionSet","title":"LazySets.an_element","text":"an_element(cup::UnionSet{N}) where {N<:Real}\n\nReturn some element of a union of two convex sets.\n\nInput\n\ncup – union of two convex sets\n\nOutput\n\nAn element in the union of two convex sets.\n\nAlgorithm\n\nWe use an_element on the first wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSet{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}} where N<:Real","page":"UnionSet","title":"Base.:∈","text":"∈(x::AbstractVector{N}, cup::UnionSet{N}) where {N<:Real}\n\nCheck whether a given point is contained in a union of two convex sets.\n\nInput\n\nx   – point/vector\ncup – union of two convex sets\n\nOutput\n\ntrue iff x  cup.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#Base.isempty-Tuple{UnionSet}","page":"UnionSet","title":"Base.isempty","text":"isempty(cup::UnionSet)\n\nCheck whether a union of two convex sets is empty.\n\nInput\n\ncup – union of two convex sets\n\nOutput\n\ntrue iff the union is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.isbounded-Tuple{UnionSet}","page":"UnionSet","title":"LazySets.isbounded","text":"isbounded(cup::UnionSet)\n\nDetermine whether a union of two convex sets is bounded.\n\nInput\n\ncup – union of two convex sets\n\nOutput\n\ntrue iff the union is bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.vertices_list-Tuple{UnionSet}","page":"UnionSet","title":"LazySets.vertices_list","text":"vertices_list(cup::UnionSet; apply_convex_hull::Bool=false, backend=nothing)\n\nReturn the list of vertices of a union of two convex sets.\n\nInput\n\ncup               – union of two convex sets\napply_convex_hull – (optional, default: false) if true, post-process                        the vertices using a convex-hull algorithm\nbackend           – (optional, default: nothing) backend for computing                        the convex hull (see argument apply_convex_hull)\n\nOutput\n\nThe list of vertices, possibly reduced to the list of vertices of the convex hull.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#def_UnionSetArray","page":"UnionSet","title":"n-ary set union (UnionSetArray)","text":"","category":"section"},{"location":"lib/lazy_operations/UnionSet/","page":"UnionSet","title":"UnionSet","text":"UnionSetArray\ndim(::UnionSetArray)\narray(::UnionSetArray{N, S}) where {N<:Real, S<:LazySet{N}}\nσ(::AbstractVector{N}, ::UnionSetArray{N}; algorithm=\"support_vector\") where {N<:Real}\nρ(::AbstractVector{N}, ::UnionSetArray{N}) where {N<:Real}\nan_element(::UnionSetArray{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::UnionSetArray{N}) where {N<:Real}\nisempty(::UnionSetArray)\nisbounded(::UnionSetArray)\nvertices_list(::UnionSetArray)","category":"page"},{"location":"lib/lazy_operations/UnionSet/#LazySets.UnionSetArray","page":"UnionSet","title":"LazySets.UnionSetArray","text":"UnionSetArray{N<:Real, S<:LazySet{N}}\n\nType that represents the set union of a finite number of convex sets.\n\nFields\n\narray – array of convex sets\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/UnionSet/#LazySets.dim-Tuple{UnionSetArray}","page":"UnionSet","title":"LazySets.dim","text":"dim(cup::UnionSetArray)\n\nReturn the dimension of the set union of a finite number of convex sets.\n\nInput\n\ncup – union of a finite number of convex sets\n\nOutput\n\nThe ambient dimension of the union of a finite number of convex sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.array-Union{Tuple{UnionSetArray{N,S}}, Tuple{S}, Tuple{N}} where S<:LazySet{N} where N<:Real","page":"UnionSet","title":"LazySets.array","text":"array(cup::UnionSetArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a union of a finite number of convex sets.\n\nInput\n\ncup – union of a finite number of convex sets\n\nOutput\n\nThe array that holds the union of a finite number of convex sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSetArray{N,S} where S<:LazySet{N}}} where N<:Real","page":"UnionSet","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, cup::UnionSetArray{N}; [algorithm]=\"support_vector\") where {N<:Real}\n\nReturn the support vector of the union of a finite number of convex sets in a given direction.\n\nInput\n\nd         – direction\ncup       – union of a finite number of convex sets\nalgorithm – (optional, default: \"supportvector\"): the algorithm to compute               the support vector; if \"supportvector\", use the support               vector of each argument; if \"support_function\" use the support               function of each argument and evaluate the support vector of only               one of them\n\nOutput\n\nThe support vector in the given direction.\n\nAlgorithm\n\nThe support vector of the union of a finite number of convex sets X₁ X₂  can be obtained as the vector that maximizes the support function, i.e. it is sufficient to find the argmax(ρ(d X₂) ρ(d X₂) ) and evaluate its support vector.\n\nThe default implementation, with option algorithm=\"support_vector\", computes the support vector of all X₁ X₂  and then compares the support function using a dot product. If it happens that the support function can be more efficiently computed (without passing through the support vector), consider using the alternative algorithm=\"support_function\" implementation, which evaluates the support function of each set directly and then calls only the support vector of one of the Xᵢ.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSetArray{N,S} where S<:LazySet{N}}} where N<:Real","page":"UnionSet","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, cup::UnionSetArray{N}) where {N<:Real}\n\nReturn the support function of the union of a finite number of convex sets in a given direction.\n\nInput\n\nd   – direction\ncup – union of a finite number of convex sets\n\nOutput\n\nThe support function in the given direction.\n\nAlgorithm\n\nThe support function of the union of a finite number of convex sets X₁ X₂  can be obtained as the maximum of ρ(d X₂) ρ(d X₂) .\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.an_element-Union{Tuple{UnionSetArray{N,S} where S<:LazySet{N}}, Tuple{N}} where N<:Real","page":"UnionSet","title":"LazySets.an_element","text":"an_element(cup::UnionSetArray{N}) where {N<:Real}\n\nReturn some element of a union of a finite number of convex sets.\n\nInput\n\ncup – union of a finite number of convex sets\n\nOutput\n\nAn element in the union of a finite number of convex sets.\n\nAlgorithm\n\nWe use an_element on the first wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},UnionSetArray{N,S} where S<:LazySet{N}}} where N<:Real","page":"UnionSet","title":"Base.:∈","text":"∈(x::AbstractVector{N}, cup::UnionSetArray{N}) where {N<:Real}\n\nCheck whether a given point is contained in a union of a finite number of convex sets.\n\nInput\n\nx   – point/vector\ncup – union of a finite number of convex sets\n\nOutput\n\ntrue iff x  cup.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#Base.isempty-Tuple{UnionSetArray}","page":"UnionSet","title":"Base.isempty","text":"isempty(cup::UnionSetArray)\n\nCheck whether a union of a finite number of convex sets is empty.\n\nInput\n\ncup – union of a finite number of convex sets\n\nOutput\n\ntrue iff the union is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.isbounded-Tuple{UnionSetArray}","page":"UnionSet","title":"LazySets.isbounded","text":"isbounded(cup::UnionSetArray)\n\nDetermine whether a union of a finite number of convex sets is bounded.\n\nInput\n\ncup – union of a finite number of convex sets\n\nOutput\n\ntrue iff the union is bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/UnionSet/#LazySets.vertices_list-Tuple{UnionSetArray}","page":"UnionSet","title":"LazySets.vertices_list","text":"vertices_list(cup::UnionSetArray; apply_convex_hull::Bool=false,\n              backend=nothing)\n\nReturn the list of vertices of a union of a finite number of convex sets.\n\nInput\n\ncup               – union of a finite number of convex sets\napply_convex_hull – (optional, default: false) if true, post-process                        the vertices using a convex-hull algorithm\nbackend           – (optional, default: nothing) backend for computing                        the convex hull (see argument apply_convex_hull)\n\nOutput\n\nThe list of vertices, possibly reduced to the list of vertices of the convex hull.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Conversion-between-set-representations","page":"Conversions between set representations","title":"Conversion between set representations","text":"","category":"section"},{"location":"lib/conversion/","page":"Conversions between set representations","title":"Conversions between set representations","text":"This section of the manual lists the conversion functions between set representations.","category":"page"},{"location":"lib/conversion/","page":"Conversions between set representations","title":"Conversions between set representations","text":"Pages = [\"conversion.md\"]\nDepth = 3","category":"page"},{"location":"lib/conversion/","page":"Conversions between set representations","title":"Conversions between set representations","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/conversion/","page":"Conversions between set representations","title":"Conversions between set representations","text":"convert(::Type{HPOLYGON1}, ::HPOLYGON2) where {HPOLYGON1<:AbstractHPolygon, HPOLYGON2<:AbstractHPolygon}\nconvert(::Type{HPOLYGON}, ::VPolygon) where {HPOLYGON<:AbstractHPolygon}\nconvert(::Type{Hyperrectangle}, ::AbstractHyperrectangle)\nconvert(::Type{Interval}, ::AbstractHyperrectangle)\nconvert(::Type{Interval}, ::LazySet{N}) where {N<:Real}\nconvert(::Type{Hyperrectangle}, cpa::CartesianProductArray{N, HN}) where {N<:Real, HN<:AbstractHyperrectangle{N}}\nconvert(::Type{Hyperrectangle}, cpa::CartesianProductArray{N, Interval{N}}) where {N<:Real}\nconvert(::Type{HPOLYGON}, ::AbstractHyperrectangle) where {HPOLYGON<:AbstractHPolygon}\nconvert(::Type{HPOLYGON}, ::HPolytope{N, VN}) where {N<:Real, VN<:AbstractVector{N}, HPOLYGON<:AbstractHPolygon}\nconvert(::Type{HPOLYGON}, ::AbstractSingleton{N}) where {N<:Real, HPOLYGON<:AbstractHPolygon}\nconvert(::Type{HPOLYGON}, ::LineSegment{N}) where {N<:Real, HPOLYGON<:AbstractHPolygon}\nconvert(::Type{HPolyhedron}, ::AbstractPolytope)\nconvert(::Type{HPolytope}, ::AbstractHPolygon)\nconvert(::Type{HPolytope}, ::AbstractHyperrectangle)\nconvert(::Type{HPolytope}, ::AbstractPolytope)\nconvert(::Type{HPolytope}, ::VPolytope)\nconvert(::Type{VPolygon}, ::AbstractHPolygon)\nconvert(::Type{VPolygon}, ::AbstractPolytope)\nconvert(::Type{VPolytope}, ::AbstractPolytope)\nconvert(::Type{VPolytope}, ::HPolytope)\nconvert(::Type{Zonotope}, ::AbstractHyperrectangle{N}) where {N}\nconvert(::Type{Zonotope}, ::AbstractZonotope)\nconvert(::Type{IntervalArithmetic.IntervalBox}, ::AbstractHyperrectangle)\nconvert(::Type{Hyperrectangle}, ::IntervalArithmetic.IntervalBox)\nconvert(::Type{Zonotope}, ::CartesianProduct{N, ZN1, ZN2}) where {N<:Real, ZN1<:AbstractZonotope{N}, ZN2<:AbstractZonotope{N}}\nconvert(::Type{Hyperrectangle}, ::CartesianProduct{N, HN1, HN2}) where {N<:Real, HN1<:AbstractHyperrectangle{N}, HN2<:AbstractHyperrectangle{N}}\nconvert(::Type{Zonotope}, ::CartesianProduct{N, HN1, HN2}) where {N<:Real, HN1<:AbstractHyperrectangle{N}, HN2<:AbstractHyperrectangle{N}}\nconvert(::Type{Zonotope}, ::CartesianProductArray{N, HN}) where {N<:Real, HN<:AbstractHyperrectangle{N}}\nconvert(::Type{Zonotope}, ::LinearMap{N, ZN}) where {N, ZN<:AbstractZonotope{N}}\nconvert(::Type{Zonotope}, ::LinearMap{N, CartesianProduct{N, HN1, HN2}}) where {N, HN1<:AbstractHyperrectangle{N}, HN2<:AbstractHyperrectangle{N}}\nconvert(::Type{Zonotope}, ::LinearMap{N, CartesianProductArray{N, HN}}) where {N, HN<:AbstractHyperrectangle{N}}\nconvert(::Type{CartesianProduct{N, Interval{N}, Interval{N}}}, ::AbstractHyperrectangle{N}) where {N<:Real}\nconvert(::Type{CartesianProductArray{N, Interval{N}}}, ::AbstractHyperrectangle{N}) where {N<:Real}\nconvert(::Type{Hyperrectangle}, ::Rectification{N, AH}) where {N<:Real, AH<:AbstractHyperrectangle{N}}\nconvert(::Type{Interval}, ::Rectification{N, IN}) where {N<:Real, IN<:Interval{N}}\nconvert(::Type{IntervalArithmetic.Interval}, ::Interval)\nconvert(::Type{Interval}, ::IntervalArithmetic.Interval)\nconvert(::Type{VPolytope}, ::ConvexHullArray{N, Singleton{N, VT}}) where {N, VT}\nconvert(::Type{VPolygon}, ::ConvexHullArray{N, Singleton{N, VT}}) where {N, VT}\nconvert(::Type{MinkowskiSumArray}, ::MinkowskiSum{N, ST, MinkowskiSumArray{N, ST}}) where {N, ST}\nconvert(::Type{Interval}, ::MinkowskiSum{N, IT, IT}) where {N, IT<:Interval{N}}","category":"page"},{"location":"lib/conversion/#Base.convert-Union{Tuple{HPOLYGON2}, Tuple{HPOLYGON1}, Tuple{Type{HPOLYGON1},HPOLYGON2}} where HPOLYGON2<:AbstractHPolygon where HPOLYGON1<:AbstractHPolygon","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{HPOLYGON1},\n        P::HPOLYGON2) where {HPOLYGON1<:AbstractHPolygon,\n                             HPOLYGON2<:AbstractHPolygon}\n\nConvert between polygon types in H-representation.\n\nInput\n\ntype – target type\nP    – source polygon\n\nOutput\n\nThe polygon represented as the target type.\n\nNotes\n\nWe need the Union type for HPOLYGON1 because the target type must be concrete.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON},VPolygon}} where HPOLYGON<:AbstractHPolygon","page":"Conversions between set representations","title":"Base.convert","text":"convert(T::Type{HPOLYGON}, P::VPolygon) where {HPOLYGON<:AbstractHPolygon}\n\nConverts a polygon in vertex representation to a polygon in constraint representation.\n\nInput\n\nHPOLYGON – type used for dispatch\nP        – polygon in vertex representation\n\nOutput\n\nA polygon in constraint representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{Hyperrectangle},AbstractHyperrectangle}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Hyperrectangle}, H::AbstractHyperrectangle)\n\nConvert a hyperrectangular set to a hyperrectangle.\n\nInput\n\nHyperrectangle – hyperrectangle type, used for dispatch\nH              – hyperrectangular set\n\nOutput\n\nA hyperrectangle.\n\nExamples\n\njulia> convert(Hyperrectangle, Interval(0.0, 1.0))\nHyperrectangle{Float64,Array{Float64,1},Array{Float64,1}}([0.5], [0.5])\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{Interval},AbstractHyperrectangle}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Interval}, H::AbstractHyperrectangle)\n\nConverts a hyperrectangular set to an interval.\n\nInput\n\nInterval – interval type, used for dispatch\nH        – hyperrectangular set\n\nOutput\n\nAn interval.\n\nExamples\n\njulia> convert(Interval, Hyperrectangle([0.5], [0.5]))\nInterval{Float64,IntervalArithmetic.Interval{Float64}}([0, 1])\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{N}, Tuple{Type{Interval},LazySet{N}}} where N<:Real","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Interval}, S::LazySet{N}) where {N<:Real}\n\nConverts a convex set to an interval.\n\nInput\n\nInterval – interval type, used for dispatch\nS        – convex set\n\nOutput\n\nAn interval.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProductArray{N,HN}}} where HN<:AbstractHyperrectangle{N} where N<:Real","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Hyperrectangle},\n        cpa::CartesianProductArray{N, HN}) where {N<:Real, HN<:AbstractHyperrectangle{N}}\n\nConverts the cartesian product of a finite number of hyperrectangular sets to a single hyperrectangle.\n\nInput\n\nHyperrectangle – type used for dispatch\nS              – cartesian product array of hyperrectangular set\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nThis implementation uses the center and radius_hyperrectangle methods of AbstractHyperrectangle.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProductArray{N,Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}}} where N<:Real","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Hyperrectangle},\n        cpa::CartesianProductArray{N, Interval{N}}) where {N<:Real}\n\nConverts the cartesian product of a finite number of intervals to a single hyperrectangle.\n\nInput\n\nHyperrectangle – type used for dispatch\nS              – cartesian product array of intervals\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nThis implementation uses the min and max methods of Interval to reduce the allocatons and improve performance (see LazySets#1143).\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON},AbstractHyperrectangle}} where HPOLYGON<:AbstractHPolygon","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{HPOLYGON}, H::AbstractHyperrectangle) where\n    {HPOLYGON<:AbstractHPolygon}\n\nConverts a hyperrectangular set to a polygon in constraint representation.\n\nInput\n\nHPOLYGON  – type used for dispatch\nH         – hyperrectangular set\n\nOutput\n\nA polygon in constraint representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{HPOLYGON}, Tuple{VN}, Tuple{N}, Tuple{Type{HPOLYGON},HPolytope{N,VN}}} where HPOLYGON<:AbstractHPolygon where VN<:AbstractArray{N,1} where N<:Real","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{HPOLYGON}, P::HPolytope{N, VN};\n        prune::Bool=true) where {N<:Real, VN<:AbstractVector{N}, HPOLYGON<:AbstractHPolygon}\n\nConvert from 2D polytope in H-representation to polygon in H-representation.\n\nInput\n\ntype  – target type\nP     – source polytope (must be 2D)\nprune – (optional, default: true) flag for removing redundant            constraints in the end\n\nOutput\n\nThe 2D polytope represented as polygon.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON},AbstractSingleton{N}}} where HPOLYGON<:AbstractHPolygon where N<:Real","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{HPOLYGON}, S::AbstractSingleton{N}\n       ) where {N<:Real, HPOLYGON<:AbstractHPolygon}\n\nConvert from singleton to polygon in H-representation.\n\nInput\n\ntype – target type\nS    – singleton\n\nOutput\n\nA polygon in constraint representation with the minimal number of constraints (three).\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON},LineSegment{N,VN} where VN<:AbstractArray{N,1}}} where HPOLYGON<:AbstractHPolygon where N<:Real","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{HPOLYGON}, L::LineSegment{N}\n      ) where {N<:Real, HPOLYGON<:AbstractHPolygon}\n\nConvert from line segment to polygon in H-representation.\n\nInput\n\ntype  – target type\nL     – line segment\nprune – (optional, default: false) flag for removing redundant            constraints in the end\n\nOutput\n\nA flat polygon in constraint representation with the minimal number of constraints (four).\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{HPolyhedron},AbstractPolytope}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{HPolyhedron}, P::AbstractPolytope)\n\nConvert a polytopic set to a polyhedron in H-representation.\n\nInput\n\ntype – target type\nP    – source polytope\n\nOutput\n\nThe given polytope represented as a polyhedron in constraint representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{HPolytope},AbstractHPolygon}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{HPolytope}, P::AbstractHPolygon)\n\nConvert from polygon in H-representation to polytope in H-representation.\n\nInput\n\ntype – target type\nP    – source polygon\n\nOutput\n\nThe polygon represented as 2D polytope.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{HPolytope},AbstractHyperrectangle}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{HPolytope}, H::AbstractHyperrectangle)\n\nConverts a hyperrectangular set to a polytope in constraint representation.\n\nInput\n\nHPolytope – type used for dispatch\nH         – hyperrectangular set\n\nOutput\n\nA polytope in constraint representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{HPolytope},AbstractPolytope}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{HPolytope}, P::AbstractPolytope)\n\nConvert a polytopic set to a polytope in H-representation.\n\nInput\n\ntype – target type\nP    – source polytope\n\nOutput\n\nThe given polytope represented as a polytope in constraint representation.\n\nAlgorithm\n\nFirst the list of constraints of P is computed, then the corresponding HPolytope is created.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{HPolytope},VPolytope}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{HPolytope}, P::VPolytope)\n\nConvert from polytope in V-representation to polytope in H-representation.\n\nInput\n\ntype – target type\nP    – source polytope\n\nOutput\n\nThe polytope in the dual representation.\n\nAlgorithm\n\nThe tohrep function is invoked. It requires the Polyhedra package.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{VPolygon},AbstractHPolygon}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{VPolygon}, P::AbstractHPolygon)\n\nConverts a polygon in constraint representation to a polygon in vertex representation.\n\nInput\n\nVPolygon – type used for dispatch\nP        – polygon in constraint representation\n\nOutput\n\nA polygon in vertex representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{VPolygon},AbstractPolytope}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{VPolygon}, P::AbstractPolytope)\n\nConvert polytopic set to polygon in V-representation.\n\nInput\n\ntype – target type\nP    – source polytope\n\nOutput\n\nThe 2D polytope represented as a polygon.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{VPolytope},AbstractPolytope}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{VPolytope}, P::AbstractPolytope)\n\nConvert polytopic type to polytope in V-representation.\n\nInput\n\ntype – target type\nP    – source polytope\n\nOutput\n\nThe set P represented as a VPolytope.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{VPolytope},HPolytope}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{VPolytope}, P::HPolytope)\n\nConvert from polytope in H-representation to polytope in V-representation.\n\nInput\n\ntype – target type\nP    – source polytope\n\nOutput\n\nThe polytope in the dual representation.\n\nAlgorithm\n\nThe tovrep function is invoked. It requires the Polyhedra package.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{N}, Tuple{Type{Zonotope},AbstractHyperrectangle{N}}} where N","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Zonotope}, H::AbstractHyperrectangle)\n\nConverts a hyperrectangular set to a zonotope.\n\nInput\n\nZonotope – type, used for dispatch\nH        – hyperrectangular set\n\nOutput\n\nA zonotope.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{Zonotope},AbstractZonotope}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Zonotope}, Z::AbstractZonotope)\n\nConverts a zonotopic set to a zonotope.\n\nInput\n\nZonotope – type, used for dispatch\nH        – zonotopic set\n\nOutput\n\nA zonotope.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{IntervalArithmetic.IntervalBox},AbstractHyperrectangle}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{IntervalArithmetic.IntervalBox}, H::AbstractHyperrectangle)\n\nConverts a hyperrectangular set to an IntervalBox from IntervalArithmetic.\n\nInput\n\nIntervalBox – type used for dispatch\nH           – hyperrectangular set\n\nOutput\n\nAn IntervalBox.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{Hyperrectangle},IntervalArithmetic.IntervalBox}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Hyperrectangle}, IB::IntervalArithmetic.IntervalBox)\n\nConverts an IntervalBox from IntervalArithmetic to a hyperrectangular set.\n\nInput\n\nHyperrectangle – type used for dispatch\nIB             – interval box\n\nOutput\n\nA Hyperrectangle.\n\nNotes\n\nIntervalArithmetic.IntervalBox uses static vectors to store each component interval, hence the resulting Hyperrectangle has its center and radius represented as a static vector (SArray).\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{ZN2}, Tuple{ZN1}, Tuple{N}, Tuple{Type{Zonotope},CartesianProduct{N,ZN1,ZN2}}} where ZN2<:AbstractZonotope{N} where ZN1<:AbstractZonotope{N} where N<:Real","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Zonotope}, cp::CartesianProduct{N, ZN1, ZN2}\n       ) where {N<:Real, ZN1<:AbstractZonotope{N}, ZN2<:AbstractZonotope{N}}\n\nConverts the cartesian product of two zonotopes to a new zonotope.\n\nInput\n\nZonotope – type used for dispatch\nS        – cartesian product of two zonotopes\n\nOutput\n\nA zonotope.\n\nAlgorithm\n\nThe cartesian product is obtained by:\n\nConcatenating the centers of each input zonotope.\nArranging the generators in block-diagional fashion, and filled with zeros in the off-diagonal; for this reason, the generator matrix of the returned zonotope is built as a sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProduct{N,HN1,HN2}}} where HN2<:AbstractHyperrectangle{N} where HN1<:AbstractHyperrectangle{N} where N<:Real","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Hyperrectangle},\n        cp::CartesianProduct{N, HN1, HN2}) where {N<:Real, HN1<:AbstractHyperrectangle{N}, HN2<:AbstractHyperrectangle{N}}\n\nConverts the cartesian product of two hyperrectangular sets to a single hyperrectangle.\n\nInput\n\nHyperrectangle – type used for dispatch\nS              – cartesian product of two hyperrectangular sets\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nThe result is obtained by concatenating the center and radius of each hyperrectangle. This implementation uses the center and radius_hyperrectangle methods of AbstractHyperrectangle.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope},CartesianProduct{N,HN1,HN2}}} where HN2<:AbstractHyperrectangle{N} where HN1<:AbstractHyperrectangle{N} where N<:Real","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Zonotope}, cp::CartesianProduct{N, HN1, HN2}) where {N<:Real,\n    HN1<:AbstractHyperrectangle{N}, HN2<:AbstractHyperrectangle{N}}\n\nConverts the cartesian product of two hyperrectangular sets to a zonotope.\n\nInput\n\nZonotope – type, used for dispatch\ncp       – cartesian product of two hyperrectangular sets\n\nOutput\n\nThis method falls back to the conversion of the cartesian product to a single hyperrectangle, and then from a hyperrectangle to a zonotope.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope},CartesianProductArray{N,HN}}} where HN<:AbstractHyperrectangle{N} where N<:Real","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Zonotope}, cpa::CartesianProductArray{N, HN})\n    where {N<:Real, HN<:AbstractHyperrectangle{N}}\n\nConverts the cartesian product array of hyperrectangular sets to a zonotope.\n\nInput\n\nZonotope – type, used for dispatch\ncpa      – cartesian product array of hyperrectangular sets\n\nOutput\n\nA zonotope.\n\nAlgorithm\n\nThis method falls back to the conversion of the cartesian product to a single hyperrectangle, and then from a hyperrectangle to a zonotope.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{ZN}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,ZN,NM,MAT} where MAT<:AbstractArray{NM,2} where NM}} where ZN<:AbstractZonotope{N} where N","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Zonotope}, S::LinearMap{N, ZN}\n       ) where {N, ZN<:AbstractZonotope{N}}\n\nConverts the lazy linear map of a zonotopic set to a zonotope.\n\nInput\n\nZonotope – type, used for dispatch\nS        – linear map of a zonotopic set\n\nOutput\n\nA zonotope.\n\nAlgorithm\n\nThis method first applies the (concrete) linear map to the zonotopic set and then converts the result to a Zonotope type.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,CartesianProduct{N,HN1,HN2},NM,MAT} where MAT<:AbstractArray{NM,2} where NM}} where HN2<:AbstractHyperrectangle{N} where HN1<:AbstractHyperrectangle{N} where N","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Zonotope}, S::LinearMap{N, CartesianProduct{N, HN1, HN2}}\n       ) where {N, HN1<:AbstractHyperrectangle{N},\n                HN2<:AbstractHyperrectangle{N}}\n\nConverts the lazy linear map of the cartesian product of two hyperrectangular sets to a zonotope.\n\nInput\n\nZonotope – type, used for dispatch\nS        – linear map of the cartesian product of hyperrectangular sets\n\nOutput\n\nA zonotope.\n\nAlgorithm\n\nThis method first converts the cartesian product to a zonotope, and then applies the (concrete) linear map to the zonotope.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,CartesianProductArray{N,HN},NM,MAT} where MAT<:AbstractArray{NM,2} where NM}} where HN<:AbstractHyperrectangle{N} where N","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Zonotope},S::LinearMap{N, CartesianProductArray{N, HN}}\n       ) where {N, HN<:AbstractHyperrectangle{N}}\n\nConverts the lazy linear map of the cartesian product of a finite number of hyperrectangular sets to a zonotope.\n\nInput\n\nZonotope – type, used for dispatch\nS        – linear map of a CartesianProductArray of hyperrectangular sets\n\nOutput\n\nA zonotope.\n\nAlgorithm\n\nThis method first converts the cartesian product array to a zonotope, and then applies the (concrete) linear map to the zonotope.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProduct{N,Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N},Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}},AbstractHyperrectangle{N}}} where N<:Real","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{CartesianProduct{N, Interval{N}, Interval{N}}},\n        H::AbstractHyperrectangle{N}) where {N<:Real}\n\nConverts a two-dimensional hyperrectangle to the cartesian product of two intervals.\n\nInput\n\nCartesianProduct – type used for dispatch\nH                – hyperrectangle\n\nOutput\n\nThe cartesian product of two intervals.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProductArray{N,Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}},AbstractHyperrectangle{N}}} where N<:Real","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{CartesianProductArray{N, Interval{N}}},\n        H::AbstractHyperrectangle{N}) where {N<:Real}\n\nConverts a hyperrectangle to the cartesian product array of intervals.\n\nInput\n\nCartesianProductArray – type used for dispatch\nH                     – hyperrectangle\n\nOutput\n\nThe cartesian product of a finite number of intervals.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{AH}, Tuple{N}, Tuple{Type{Hyperrectangle},Rectification{N,AH}}} where AH<:AbstractHyperrectangle{N} where N<:Real","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Hyperrectangle}, r::Rectification{N, AH})\n    where {N<:Real, AH<:AbstractHyperrectangle{N}}\n\nConverts a rectification of a hyperrectangle to a hyperrectangle.\n\nInput\n\nHyperrectangle – type used for dispatch\nr              – rectification of a hyperrectangle\n\nOutput\n\nA Hyperrectangle.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{IN}, Tuple{N}, Tuple{Type{Interval},Rectification{N,IN}}} where IN<:(Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}) where N<:Real","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Interval},\n        r::Rectification{N, IN}) where {N<:Real, IN<:Interval{N}}\n\nConverts a rectification of an interval to an interval.\n\nInput\n\nInterval – type used for dispatch\nr        – rectification of an interval\n\nOutput\n\nAn Interval.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{IntervalArithmetic.Interval},Interval}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{IntervalArithmetic.Interval}, x::Interval)\n\nConverts a LazySets interval to an Interval from IntervalArithmetic.\n\nInput\n\nInterval – type used for dispatch, from IntervalArithmetic\nx        – interval (LazySets.Interval)\n\nOutput\n\nAn IntervalArithmetic.Interval.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Tuple{Type{Interval},IntervalArithmetic.Interval}","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Interval}, x::IntervalArithmetic.Interval)\n\nConverts an Interval from IntervalArithmetic to an interval in LazySets.\n\nInput\n\nInterval – type used for dispatch\nx        – interval (IntervalArithmetic.Interval)\n\nOutput\n\nA LazySets.Interval.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{VT}, Tuple{N}, Tuple{Type{VPolytope},ConvexHullArray{N,Singleton{N,VT}}}} where VT where N","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{VPolytope},\n        X::ConvexHullArray{N, Singleton{N, VT}}) where {N, VT}\n\nConverts the convex hull array of singletons to a polytope in V-representation.\n\nInput\n\nVPolytope – type used for dispatch\nX         – convex hull array of singletons\n\nOutput\n\nA polytope in vertex representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{VT}, Tuple{N}, Tuple{Type{VPolygon},ConvexHullArray{N,Singleton{N,VT}}}} where VT where N","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{VPolygon},\n        X::ConvexHullArray{N, Singleton{N, VT}}) where {N, VT}\n\nConverts the convex hull array of singletons to a polygon in V-representation.\n\nInput\n\nVPolygon  – type used for dispatch\nX         – convex hull array of singletons\n\nOutput\n\nA polygon in vertex representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{ST}, Tuple{N}, Tuple{Type{MinkowskiSumArray},MinkowskiSum{N,ST,MinkowskiSumArray{N,ST}}}} where ST where N","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{MinkowskiSumArray},\n        X::MinkowskiSum{N, ST, MinkowskiSumArray{N, ST}}) where {N, ST}\n\nConverts the Minkowski sum of a Minkowski sum array to a Minkowski sum array.\n\nInput\n\nMinkowskiSumArray  – type used for dispatch\nX                  – Minkowski sum of a Minkowski sum array\n\nOutput\n\nA Minkowski sum array.\n\n\n\n\n\n","category":"method"},{"location":"lib/conversion/#Base.convert-Union{Tuple{IT}, Tuple{N}, Tuple{Type{Interval},MinkowskiSum{N,IT,IT}}} where IT<:(Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}) where N","page":"Conversions between set representations","title":"Base.convert","text":"convert(::Type{Interval}, x::MinkowskiSum{N, IT, IT}) where {N, IT<:Interval{N}}\n\nConverts the Minkowski sum of two intervals into an interval.\n\nInput\n\nInterval – type used for dispatch\nx        – Minkowski sum of a pair of intervals\n\nOutput\n\nAn interval.\n\n\n\n\n\n","category":"method"},{"location":"man/convex_hulls/#Convex-Hulls","page":"Convex Hulls","title":"Convex Hulls","text":"","category":"section"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"In this section we illustrate the convex hull operation. We give examples of the symbolic implementation, and the concrete convex hull in low dimensions. We show how to test if a point lies in the convex hull of a set of points in the plane using LazySets. Moreover, we give examples of creating the convex hull of sets whose vertices are represented as static vectors, which can dramatically improve performance in many use cases. Finally, we give an example of creating the convex hull of points in higher dimensions.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Pages = [\"convex_hulls.md\"]\nDepth = 3","category":"page"},{"location":"man/convex_hulls/#Symbolic-convex-hull","page":"Convex Hulls","title":"Symbolic convex hull","text":"","category":"section"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"The lazy convex hull, ConvexHull, is the binary operator that implements the convex hull of the union between two convex sets.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"using Plots, LazySets\n\nA = 1/sqrt(2.) * [1 -1; 1 1]\nBn = n -> BallInf(ones(n), 0.2)\n\nX = Bn(2)\nY = CH(X, exp(A) * X)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"The name CH is an alias for ConvexHull, so you can use both interchangeably. This type is parametric in the operands's types.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"p = plot(X, 1e-2, color=\"blue\")\nplot!(p, exp(A) * X, color=\"green\")\nplot!(p, Y, color=\"red\", alpha=0.2)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"We can as well work with a 100-dimensional set:","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"using SparseArrays\n\nX = Bn(100)\nA = blockdiag([sparse(A) for i in 1:50]...)\nY = CH(X, exp(Matrix(A)) * X)\n\ndim(Y)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"To take the convex hull of a large number of sets, there is the n-ary type ConvexHullArray. For instance, below we create a collection of balls b via list comprehension, and pass them to create a new ConvexHullArray instance.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"b = [Ball2([2*pi*i/100, sin(2*pi*i/100)], 0.05) for i in 1:100];\nc = ConvexHullArray(b);\n\nplot(c, alpha=0.1, color=\"blue\")\nplot!(b, alpha=0.5, color=\"red\")","category":"page"},{"location":"man/convex_hulls/#D-convex-hull","page":"Convex Hulls","title":"2D convex hull","text":"","category":"section"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"In two dimensions the convex_hull function computes the concrete convex hull of a set of points.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"points = N -> [randn(2) for i in 1:N]\nv = points(30)\nhull = convex_hull(v)\ntypeof(hull), length(v), length(hull)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Notice that the output is a vector of floating point numbers representing the coordinates of the points, and that the number of points in the convex hull has decreased.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"We can plot both the random points and the polygon generated by the convex hull with the plot function:","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"p = plot([Singleton(vi) for vi in v])\nplot!(p, VPolygon(hull), alpha=0.2)","category":"page"},{"location":"man/convex_hulls/#Test-point-in-convex-hull","page":"Convex Hulls","title":"Test point in convex hull","text":"","category":"section"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"One can check whether a point lies inside or outside of a convex hull efficiently in two dimensions, using the fact that the output of convex_hull returns the points ordered in counter-clockwise fashion.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"note: Note\nTo check if a point p::AbstractVector is in another set, e.g. a polygon in vertex representation V, use p ∈ V. However, if you are working with a Singleton, which is a set with one element, use set inclusion ⊆. The following example illustrates this difference.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"julia> Singleton(v[1]) ∈ VPolygon(hull)\nERROR: cannot make a point-in-set check if the left-hand side is a set; either\ncheck for set inclusion, as in `S ⊆ X`, or check for membership, as in\n`element(S) ∈ X` (the results are equivalent but the implementations may differ)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"As the error suggests, either use element to access the element of the singleton and check if it belongs to the right-hand side set:","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"element(Singleton(v[1])) ∈ VPolygon(hull)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Or use set inclusion between the singleton and the right-hand side set:","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Singleton(v[1]) ⊆ VPolygon(hull)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Let us note that one can also make the point-in-convex-hull test by solving a feasibility problem; actually, this is the fallback implementation used for in any dimension. However, the specialized approach in 2D is more efficient.","category":"page"},{"location":"man/convex_hulls/#Using-static-vectors","page":"Convex Hulls","title":"Using static vectors","text":"","category":"section"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Usual vectors are such that you can push! and pop! without changing its type: the size is not a static property. Vectors of fixed size, among other types, are provided by the StaticArrays.jl package from the JuliaArrays ecosystem. Using static arrays for vectors of \"small\" dimension can dramatically improve performance.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Since the convex hull algorithm supports any AbstractVector, it can be applied with static vectors. The following example illustrates this fact.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"v = points(1000)\nconvex_hull(points(3)) # warm-up\n\n@time convex_hull(v)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Now working with static vectors:","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"using StaticArrays\n\nconvex_hull([@SVector(rand(2)) for i in 1:3]) # warm-up\n\nv_static = [SVector{2, Float64}(vi) for vi in v]\n@time convex_hull(v_static)","category":"page"},{"location":"man/convex_hulls/#Higher-dimensional-convex-hull","page":"Convex Hulls","title":"Higher-dimensional convex hull","text":"","category":"section"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"One can compute the convex hull of points in higher dimensions using convex_hull. The appropriate algorithm is decided based on the dimensionality of the given points.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"using Polyhedra\n\nv = [randn(3) for _ in 1:30]\nhull = convex_hull(v)\ntypeof(hull), length(v), length(hull)","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Here, convex_hull is now using the concrete polyhedra library Polyhedra, hence it needs to be loaded beforehand.","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"One can check whether a point belongs to the convex hull using ∈ as follows:","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"P = VPolytope(hull)\nx = sum(hull)/length(hull)\n\nx ∈ P","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Here x ∈ P solves a feasibility problem; see the docs of ?∈ for details. Equivalently, using set inclusion:","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"Singleton(x) ⊆ P","category":"page"},{"location":"man/convex_hulls/","page":"Convex Hulls","title":"Convex Hulls","text":"If no additional arguments are passed, convex_hull uses the default polyhedra library from default_polyhedra_backend for the given input; different options can be passed through the backend keyword; see the Julia polyhedra website for all the available backends.","category":"page"},{"location":"lib/binary_functions/#Binary-Functions-on-Sets","page":"Concrete Operations","title":"Binary Functions on Sets","text":"","category":"section"},{"location":"lib/binary_functions/","page":"Concrete Operations","title":"Concrete Operations","text":"This section of the manual describes the binary functions for set types.","category":"page"},{"location":"lib/binary_functions/","page":"Concrete Operations","title":"Concrete Operations","text":"Pages = [\"binary_functions.md\"]\nDepth = 3","category":"page"},{"location":"lib/binary_functions/","page":"Concrete Operations","title":"Concrete Operations","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/binary_functions/#Cartesian-product","page":"Concrete Operations","title":"Cartesian product","text":"","category":"section"},{"location":"lib/binary_functions/","page":"Concrete Operations","title":"Concrete Operations","text":"cartesian_product(::HPoly{N}, ::HPoly{N}) where {N<:Real}\ncartesian_product(::VPolytope{N}, ::VPolytope{N}) where N","category":"page"},{"location":"lib/binary_functions/#LazySets.cartesian_product-Union{Tuple{N}, Tuple{Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}},Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}}}} where N<:Real","page":"Concrete Operations","title":"LazySets.cartesian_product","text":"cartesian_product(P1::HPoly{N}, P2::HPoly{N};\n                  [backend]=default_polyhedra_backend(P1, N)\n                 ) where {N<:Real}\n\nCompute the Cartesian product of two polyhedra in H-representaion.\n\nInput\n\nP1         – polyhedron\nP2         – another polyhedron\nbackend    – (optional, default: default_polyhedra_backend(P1, N))                 the polyhedral computations backend\n\nOutput\n\nThe polyhedron obtained by the concrete cartesian product of P1 and P2.\n\nNotes\n\nFor further information on the supported backends see Polyhedra's documentation.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.cartesian_product-Union{Tuple{N}, Tuple{VPolytope{N,VN} where VN<:AbstractArray{N,1},VPolytope{N,VN} where VN<:AbstractArray{N,1}}} where N","page":"Concrete Operations","title":"LazySets.cartesian_product","text":"cartesian_product(P1::VPolytope{N}, P2::VPolytope{N};\n                  [backend]=default_polyhedra_backend(P1, N)) where {N}\n\nCompute the Cartesian product of two polytopes in V-representation.\n\nInput\n\nP1      – polytope\nP2      – another polytope\nbackend – (optional, default: default_polyhedra_backend(P1, N)) the              backend for polyhedral computations; see Polyhedra's              documentation for further              information\n\nOutput\n\nThe VPolytope obtained by the concrete Cartesian product of P1 and P2.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Check-for-emptiness-of-intersection","page":"Concrete Operations","title":"Check for emptiness of intersection","text":"","category":"section"},{"location":"lib/binary_functions/","page":"Concrete Operations","title":"Concrete Operations","text":"isdisjoint\nis_intersection_empty(::LazySet{N}, ::LazySet{N}, ::Bool=false) where {N<:Real}\nis_intersection_empty(::AbstractHyperrectangle{N}, ::AbstractHyperrectangle{N}, ::Bool=false) where {N<:Real}\nis_intersection_empty(::LazySet{N}, ::AbstractSingleton{N}, ::Bool=false) where {N<:Real}\nis_intersection_empty(::AbstractHyperrectangle{N}, ::AbstractSingleton{N}, ::Bool=false) where {N<:Real}\nis_intersection_empty(::AbstractSingleton{N}, ::AbstractSingleton{N}, ::Bool=false) where {N<:Real}\nis_intersection_empty(::Zonotope{N}, ::Hyperplane{N}, ::Bool=false) where {N<:Real}\nis_intersection_empty(::Ball2{N}, ::Ball2{N}, ::Bool=false) where {N<:AbstractFloat}\nis_intersection_empty(::LineSegment{N}, ::LineSegment{N}, ::Bool=false) where {N<:Real}\nis_intersection_empty(::LazySet{N}, ::Union{Hyperplane{N}, Line2D{N}}, ::Bool=false) where {N<:Real}\nis_intersection_empty(::LazySet{N}, ::HalfSpace{N}, ::Bool=false) where {N<:Real}\nis_intersection_empty(::HalfSpace{N}, ::HalfSpace{N}, ::Bool=false) where {N<:Real}\nis_intersection_empty(::AbstractPolyhedron{N}, ::LazySet{N}, ::Bool=false) where {N<:Real}\nis_intersection_empty(::UnionSet{N}, ::LazySet{N}, ::Bool=false) where {N<:Real}\nis_intersection_empty(::UnionSetArray{N}, ::LazySet{N}, ::Bool=false) where {N<:Real}\nis_intersection_empty(::Universe{N}, ::LazySet{N}, ::Bool=false) where {N<:Real}\nis_intersection_empty(::Complement{N}, ::LazySet{N}, ::Bool=false) where {N<:Real}\nis_intersection_empty(::Zonotope{N}, ::Zonotope{N}, ::Bool=false) where {N<:Real}\nis_intersection_empty(::Interval{N}, ::Interval{N}, ::Bool=false) where {N<:Real}\nis_intersection_empty(::CartesianProductArray{N}, ::AbstractPolyhedron{N}) where {N<:Real}\nis_intersection_empty(::CartesianProductArray{N}, ::CartesianProductArray{N}) where {N<:Real}\nis_intersection_empty(::CartesianProductArray{N}, ::AbstractHyperrectangle{N}, ::Bool=false) where {N<:Real}","category":"page"},{"location":"lib/binary_functions/#LazySets.isdisjoint","page":"Concrete Operations","title":"LazySets.isdisjoint","text":"is_intersection_empty(X::LazySet{N},\n                      Y::LazySet{N},\n                      witness::Bool=false\n                      ) where {N<:Real}\n\nCheck whether two sets do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nX       – set\nY       – another set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff X  Y = \nIf witness option is activated:\n(true, []) iff X  Y = \n(false, v) iff X  Y   and v  X  Y\n\nAlgorithm\n\nThis is a fallback implementation that computes the concrete intersection, intersection, of the given sets.\n\nA witness is constructed using the an_element implementation of the result.\n\n\n\n\n\nis_intersection_empty(H1::AbstractHyperrectangle{N},\n                      H2::AbstractHyperrectangle{N},\n                      witness::Bool=false\n                     ) where {N<:Real}\n\nCheck whether two hyperrectangles do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nH1 – first hyperrectangle\nH2 – second hyperrectangle\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff H1  H2 = \nIf witness option is activated:\n(true, []) iff H1  H2 = \n(false, v) iff H1  H2   and v  H1  H2\n\nAlgorithm\n\nH1  H2   iff c_2 - c_1  r_1 + r_2, where  is taken component-wise.\n\nA witness is computed by starting in one center and moving toward the other center for as long as the minimum of the radius and the center distance. In other words, the witness is the point in H1 that is closest to the center of H2.\n\n\n\n\n\nis_intersection_empty(I1::Interval{N}, I2::Interval{N}, witness::Bool=false) where {N<:Real}\n\nCheck whether two intervals do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nI1      – first interval\nI2      – second interval\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff I1  I2 = \nIf witness option is activated:\n(true, []) iff I1  I2 = \n(false, v) iff I1  I2   and v  I1  I2\n\nAlgorithm\n\nI1  I2   iff there is a gap between the left-most point of the second interval and the left-most point of the first interval, or vice-versa.\n\nA witness is computed by taking the maximum over the left-most points of each interval, which is guaranteed to belong to the intersection.\n\n\n\n\n\nis_intersection_empty(X::LazySet{N},\n                      S::AbstractSingleton{N},\n                      witness::Bool=false\n                     ) where {N<:Real}\n\nCheck whether a convex set and a singleton do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nX       – convex set\nS       – singleton\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff S  X = \nIf witness option is activated:\n(true, []) iff S  X = \n(false, v) iff S  X   and v = element(S)  S  X\n\nAlgorithm\n\nS  X =  iff element(S)  X.\n\n\n\n\n\nis_intersection_empty(S1::AbstractSingleton{N},\n                      S2::AbstractSingleton{N},\n                      witness::Bool=false\n                     ) where {N<:Real}\n\nCheck whether two singletons do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nS1 – first singleton\nS2 – second singleton\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff S1  S2 = \nIf witness option is activated:\n(true, []) iff S1  S2 = \n(false, v) iff S1  S2   and v = element(S1)  S1  S2\n\nAlgorithm\n\nS1  S2 =  iff S1  S2.\n\n\n\n\n\nis_intersection_empty(H::AbstractHyperrectangle{N},\n                      S::AbstractSingleton{N},\n                      witness::Bool=false\n                     ) where {N<:Real}\n\nCheck whether a hyperrectangle and a singleton do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nH – hyperrectangle\nS – singleton\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff H  S = \nIf witness option is activated:\n(true, []) iff H  S = \n(false, v) iff H  S   and v = element(S)  H  S\n\nAlgorithm\n\nH  S =  iff element(S)  H.\n\n\n\n\n\nis_intersection_empty(B1::Ball2{N},\n                      B2::Ball2{N},\n                      witness::Bool=false\n                     ) where {N<:AbstractFloat}\n\nCheck whether two balls in the 2-norm do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nB1 – first ball in the 2-norm\nB2 – second ball in the 2-norm\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff B1  B2 = \nIf witness option is activated:\n(true, []) iff B1  B2 = \n(false, v) iff B1  B2   and v  B1  B2\n\nAlgorithm\n\nB1  B2 =  iff  c_2 - c_1 _2  r_1 + r_2.\n\nA witness is computed depending on the smaller/bigger ball (to break ties, choose B1 for the smaller ball) as follows.\n\nIf the smaller ball's center is contained in the bigger ball, we return it.\nOtherwise start in the smaller ball's center and move toward the other center until hitting the smaller ball's border. In other words, the witness is the point in the smaller ball that is closest to the center of the bigger ball.\n\n\n\n\n\nis_intersection_empty(Z::Zonotope{N}, H::Hyperplane{N}, witness::Bool=false\n                     ) where {N<:Real}\n\nCheck whether a zonotope and a hyperplane do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nZ – zonotope\nH – hyperplane\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff Z  H = \nIf witness option is activated:\n(true, []) iff Z  H = \n(false, v) iff Z  H   and v  Z  H\n\nAlgorithm\n\nZ  H =  iff (b - ac)  left  _i=1^p ag_i right, where a, b are the hyperplane coefficients, c is the zonotope's center, and g_i are the zonotope's generators.\n\nFor witness production we fall back to a less efficient implementation for general sets as the first argument.\n\n\n\n\n\nis_intersection_empty(Z1::Zonotope{N}, Z2::Zonotope{N}, witness::Bool=false\n                     ) where {N<:Real}\n\nCheck whether two zonotopes do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nZ1      – zonotope\nZ2      – zonotope\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff Z1  Z2 = \nIf witness option is activated:\n(true, []) iff Z1  Z2 = \n(false, v) iff Z1  Z2   and v  Z1  Z2\n\nAlgorithm\n\nZ1  Z2   iff c_1 - c_2  Z(0 (g_1 g_2)) where c_i and g_i are the center and generators of zonotope Zi and Z(c g) represents the zonotope with center c and generators g.\n\n\n\n\n\nis_intersection_empty(ls1::LineSegment{N},\n                      ls2::LineSegment{N},\n                      witness::Bool=false\n                     ) where {N<:Real}\n\nCheck whether two line segments do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nls1 – first line segment\nls2 – second line segment\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff ls1  ls2 = \nIf witness option is activated:\n(true, []) iff ls1  ls2 = \n(false, v) iff ls1  ls2   and v  ls1  ls2\n\nAlgorithm\n\nThe algorithm is inspired from here, which again is the special 2D case of a 3D algorithm by Ronald Goldman's article on the Intersection of two lines in three-space in Graphics Gems, Andrew S. (ed.), 1990.\n\nWe first check if the two line segments are parallel, and if so, if they are collinear. In the latter case, we check containment of any of the end points in the other line segment. Otherwise the lines are not parallel, so we can solve an equation of the intersection point, if it exists.\n\n\n\n\n\nis_intersection_empty(X::LazySet{N},\n                      hp::Union{Hyperplane{N}, Line2D{N}},\n                      [witness]::Bool=false\n                     ) where {N<:Real}\n\nCheck whether a compact set an a hyperplane do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nX       – compact set\nhp      – hyperplane\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff X  hp = \nIf witness option is activated:\n(true, []) iff X  hp = \n(false, v) iff X  hp   and v  X  hp\n\nNotes\n\nWe assume that X is compact. Otherwise, the support vector queries may fail.\n\nAlgorithm\n\nA compact convex set intersects with a hyperplane iff the support function in the negative resp. positive direction of the hyperplane's normal vector a is to the left resp. right of the hyperplane's constraint b:\n\n-ρ(-a)  b  ρ(a)\n\nFor witness generation, we compute a line connecting the support vectors to the left and right, and then take the intersection of the line with the hyperplane. We follow this algorithm for the line-hyperplane intersection.\n\n\n\n\n\nis_intersection_empty(X::LazySet{N},\n                      hs::HalfSpace{N},\n                      [witness]::Bool=false\n                     ) where {N<:Real}\n\nCheck whether a compact set an a half-space do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nX       – compact set\nhs      – half-space\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff X  hs = \nIf witness option is activated:\n(true, []) iff X  hs = \n(false, v) iff X  hs   and v  X  hs\n\nNotes\n\nWe assume that X is compact. Otherwise, the support vector queries may fail.\n\nAlgorithm\n\nA compact convex set intersects with a half-space iff the support vector in the negative direction of the half-space's normal vector a is contained in the half-space: σ(-a)  hs. The support vector is thus also a witness.\n\nOptional keyword arguments can be passed to the ρ function. In particular, if X is a lazy intersection, options can be passed to the line search algorithm.\n\n\n\n\n\nis_intersection_empty(hs1::HalfSpace{N},\n                      hs2::HalfSpace{N},\n                      [witness]::Bool=false\n                     ) where {N<:Real}\n\nCheck whether two half-spaces do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nhs1     – half-space\nhs2     – half-space\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff hs1  hs2 = \nIf witness option is activated:\n(true, []) iff hs1  hs2 = \n(false, v) iff hs1  hs2   and v  hs1  hs2\n\nAlgorithm\n\nTwo half-spaces do not intersect if and only if their normal vectors point in the opposite direction and there is a gap between the two defining hyperplanes.\n\nThe latter can be checked as follows: Let hs_1  a_1x = b_1 and hs2  a_2x = b_2. Then we already know that a_2 = -ka_1 for some positive scaling factor k. Let x_1 be a point on the defining hyperplane of hs_1. We construct a line segment from x_1 to the point x_2 on the defining hyperplane of hs_2 by shooting a ray from x_1 with direction a_1. Thus we look for a factor s such that (x_1 + sa_1)a_2 = b_2. This gives us s = (b_2 - x_1a_2)  (-k a_1a_1). The gap exists if and only if s is positive.\n\nIf the normal vectors do not point in opposite directions, then the defining hyperplanes intersect and we can produce a witness as follows. All points x in this intersection satisfy a_1x = b_1 and a_2x = b_2. Thus we have (a_1 + a_2)x = b_1+b_2. We now find a dimension where a_1 + a_2 is non-zero, say, i. Then the result is a vector with one non-zero entry in dimension i, defined as 0  0 (b_1 + b_2)(a_1i + a_2i) 0  0. Such a dimension i always exists.\n\n\n\n\n\nis_intersection_empty(P::AbstractPolyhedron{N},\n                      X::LazySet{N},\n                      witness::Bool=false;\n                      solver=default_lp_solver(N)\n                     ) where {N<:Real}\n\nCheck whether two polyhedra do not intersect.\n\nInput\n\nP         – polyhedron\nX         – another set (see the Notes section below)\nwitness   – (optional, default: false) compute a witness if activated\nsolver    – (optional, default: default_lp_solver(N)) the backend used to                solve the linear program\nalgorithm – (optional, default: \"exact\") algorithm keyword, one of:                * \"exact\" (exact, uses a feasibility LP)                *\"sufficient\" (sufficient, uses half-space checks)\n\nOutput\n\nIf witness option is deactivated: true iff P  X = \nIf witness option is activated:\n(true, []) iff P  X = \n(false, v) iff P  X   and v  P  X\n\nNotes\n\nFor algorithm == \"exact\", we assume that constraints_list(X) is defined. For algorithm == \"sufficient\", witness production is not supported.\n\nAlgorithm\n\nFor algorithm == \"exact\", see isempty(P::HPoly, ::Bool).\n\nFor algorithm == \"sufficient\", we rely on the intersection check between the set X and each constraint in P. This means one support function evaluation of X for each constraint of P. With the sufficiency algorithm, this function may return false even in the case where the intersection is empty. On the other hand, if the algorithm returns true, then it is guaranteed that the intersection is empty.\n\n\n\n\n\nis_intersection_empty(cup::UnionSet{N}, X::LazySet{N},\n                      [witness]::Bool=false) where {N<:Real}\n\nCheck whether a union of two convex sets and another set do not intersect.\n\nInput\n\ncup – union of two convex sets\nX   – another set\n\nOutput\n\ntrue iff textcup  X = .\n\n\n\n\n\nis_intersection_empty(cup::UnionSetArray{N}, X::LazySet{N},\n                      [witness]::Bool=false) where {N<:Real}\n\nCheck whether a union of a finite number of convex sets and another set do not intersect.\n\nInput\n\ncup – union of a finite number of convex sets\nX   – another set\n\nOutput\n\ntrue iff textcup  X = .\n\n\n\n\n\nis_intersection_empty(U::Universe{N}, X::LazySet{N},\n                      [witness]::Bool=false) where {N<:Real}\n\nCheck whether a universe and another set do not intersect.\n\nInput\n\nU – universe\nX – another set\n\nOutput\n\ntrue iff X  .\n\n\n\n\n\nis_intersection_empty(C::Complement{N},\n                      X::LazySet{N},\n                      [witness]::Bool=false\n                     ) where {N<:Real}\n\nCheck whether the complement of a convex set and another set do not intersect.\n\nInput\n\nC – complement of a convex set\nX – convex set\n\nOutput\n\nIf witness option is deactivated: true iff X  C = \nIf witness option is activated:\n(true, []) iff X  C = \n(false, v) iff X  C   and v  X  C\n\nAlgorithm\n\nWe fall back to X ⊆ C.X, which can be justified as follows:\n\n    X  Y^C =   X  Y\n\n\n\n\n\nis_intersection_empty(cpa::CartesianProductArray{N},\n                      P::AbstractPolyhedron{N}) where {N<:Real}\n\nCheck whether a polytopic Cartesian product array intersects with a polyhedron.\n\nInput\n\ncpa – Cartesian product array of polytopes\nP   – polyhedron\n\nOutput\n\ntrue iff textcpa  Y = .\n\nAlgorithm\n\nWe first identify the blocks of cpa in which P is constrained. Then we project cpa to those blocks and convert the result to an HPolytope Q. Finally we determine whether Q and the projected P intersect.\n\n\n\n\n\nis_intersection_empty(X::CartesianProductArray{N},\n                      Y::CartesianProductArray{N}) where {N<:Real}\n\nCheck whether two Cartesian products of a finite number of convex sets do not intersect.\n\nInput\n\nX – Cartesian product array of convex sets\nY – Cartesian product array of convex sets\n\nOutput\n\ntrue iff X  Y = .\n\n\n\n\n\nis_intersection_empty(cpa::CartesianProductArray{N},\n                      H::AbstractHyperrectangle{N}) where {N<:Real}\n\nCheck whether a Cartesian product of a finite number of convex sets and a hyperrectangular set do not intersect, and otherwise optionally compute a witness.\n\nInput\n\ncpa     – Cartesian product of a finite number of convex sets\nH       – hyperrectangular set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff cpa  H = \nIf witness option is activated:\n(true, []) iff cpa  H = \n(false, v) iff cpa  H   and v  cpa  H\n\nAlgorithm\n\nThe sets cpa and H are disjoint if and only if at least one block of cpa and the corresponding projection of H are disjoint. We perform these checks sequentially.\n\n\n\n\n\n","category":"function"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{LazySet{N},LazySet{N}}, Tuple{LazySet{N},LazySet{N},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(X::LazySet{N},\n                      Y::LazySet{N},\n                      witness::Bool=false\n                      ) where {N<:Real}\n\nCheck whether two sets do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nX       – set\nY       – another set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff X  Y = \nIf witness option is activated:\n(true, []) iff X  Y = \n(false, v) iff X  Y   and v  X  Y\n\nAlgorithm\n\nThis is a fallback implementation that computes the concrete intersection, intersection, of the given sets.\n\nA witness is constructed using the an_element implementation of the result.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N}}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(H1::AbstractHyperrectangle{N},\n                      H2::AbstractHyperrectangle{N},\n                      witness::Bool=false\n                     ) where {N<:Real}\n\nCheck whether two hyperrectangles do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nH1 – first hyperrectangle\nH2 – second hyperrectangle\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff H1  H2 = \nIf witness option is activated:\n(true, []) iff H1  H2 = \n(false, v) iff H1  H2   and v  H1  H2\n\nAlgorithm\n\nH1  H2   iff c_2 - c_1  r_1 + r_2, where  is taken component-wise.\n\nA witness is computed by starting in one center and moving toward the other center for as long as the minimum of the radius and the center distance. In other words, the witness is the point in H1 that is closest to the center of H2.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{LazySet{N},AbstractSingleton{N}}, Tuple{LazySet{N},AbstractSingleton{N},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(X::LazySet{N},\n                      S::AbstractSingleton{N},\n                      witness::Bool=false\n                     ) where {N<:Real}\n\nCheck whether a convex set and a singleton do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nX       – convex set\nS       – singleton\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff S  X = \nIf witness option is activated:\n(true, []) iff S  X = \n(false, v) iff S  X   and v = element(S)  S  X\n\nAlgorithm\n\nS  X =  iff element(S)  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractSingleton{N}}, Tuple{AbstractHyperrectangle{N},AbstractSingleton{N},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(H::AbstractHyperrectangle{N},\n                      S::AbstractSingleton{N},\n                      witness::Bool=false\n                     ) where {N<:Real}\n\nCheck whether a hyperrectangle and a singleton do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nH – hyperrectangle\nS – singleton\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff H  S = \nIf witness option is activated:\n(true, []) iff H  S = \n(false, v) iff H  S   and v = element(S)  H  S\n\nAlgorithm\n\nH  S =  iff element(S)  H.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{AbstractSingleton{N},AbstractSingleton{N}}, Tuple{AbstractSingleton{N},AbstractSingleton{N},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(S1::AbstractSingleton{N},\n                      S2::AbstractSingleton{N},\n                      witness::Bool=false\n                     ) where {N<:Real}\n\nCheck whether two singletons do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nS1 – first singleton\nS2 – second singleton\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff S1  S2 = \nIf witness option is activated:\n(true, []) iff S1  S2 = \n(false, v) iff S1  S2   and v = element(S1)  S1  S2\n\nAlgorithm\n\nS1  S2 =  iff S1  S2.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{Zonotope{N,VN,MN} where MN<:AbstractArray{N,2} where VN<:AbstractArray{N,1},Hyperplane{N,VN} where VN<:AbstractArray{N,1}}, Tuple{Zonotope{N,VN,MN} where MN<:AbstractArray{N,2} where VN<:AbstractArray{N,1},Hyperplane{N,VN} where VN<:AbstractArray{N,1},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(Z::Zonotope{N}, H::Hyperplane{N}, witness::Bool=false\n                     ) where {N<:Real}\n\nCheck whether a zonotope and a hyperplane do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nZ – zonotope\nH – hyperplane\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff Z  H = \nIf witness option is activated:\n(true, []) iff Z  H = \n(false, v) iff Z  H   and v  Z  H\n\nAlgorithm\n\nZ  H =  iff (b - ac)  left  _i=1^p ag_i right, where a, b are the hyperplane coefficients, c is the zonotope's center, and g_i are the zonotope's generators.\n\nFor witness production we fall back to a less efficient implementation for general sets as the first argument.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{Ball2{N,VN} where VN<:AbstractArray{N,1},Ball2{N,VN} where VN<:AbstractArray{N,1}}, Tuple{Ball2{N,VN} where VN<:AbstractArray{N,1},Ball2{N,VN} where VN<:AbstractArray{N,1},Bool}} where N<:AbstractFloat","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(B1::Ball2{N},\n                      B2::Ball2{N},\n                      witness::Bool=false\n                     ) where {N<:AbstractFloat}\n\nCheck whether two balls in the 2-norm do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nB1 – first ball in the 2-norm\nB2 – second ball in the 2-norm\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff B1  B2 = \nIf witness option is activated:\n(true, []) iff B1  B2 = \n(false, v) iff B1  B2   and v  B1  B2\n\nAlgorithm\n\nB1  B2 =  iff  c_2 - c_1 _2  r_1 + r_2.\n\nA witness is computed depending on the smaller/bigger ball (to break ties, choose B1 for the smaller ball) as follows.\n\nIf the smaller ball's center is contained in the bigger ball, we return it.\nOtherwise start in the smaller ball's center and move toward the other center until hitting the smaller ball's border. In other words, the witness is the point in the smaller ball that is closest to the center of the bigger ball.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{LineSegment{N,VN} where VN<:AbstractArray{N,1},LineSegment{N,VN} where VN<:AbstractArray{N,1}}, Tuple{LineSegment{N,VN} where VN<:AbstractArray{N,1},LineSegment{N,VN} where VN<:AbstractArray{N,1},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(ls1::LineSegment{N},\n                      ls2::LineSegment{N},\n                      witness::Bool=false\n                     ) where {N<:Real}\n\nCheck whether two line segments do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nls1 – first line segment\nls2 – second line segment\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff ls1  ls2 = \nIf witness option is activated:\n(true, []) iff ls1  ls2 = \n(false, v) iff ls1  ls2   and v  ls1  ls2\n\nAlgorithm\n\nThe algorithm is inspired from here, which again is the special 2D case of a 3D algorithm by Ronald Goldman's article on the Intersection of two lines in three-space in Graphics Gems, Andrew S. (ed.), 1990.\n\nWe first check if the two line segments are parallel, and if so, if they are collinear. In the latter case, we check containment of any of the end points in the other line segment. Otherwise the lines are not parallel, so we can solve an equation of the intersection point, if it exists.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{LazySet{N},Union{Hyperplane{N,VN} where VN<:AbstractArray{N,1}, Line2D{N,VN} where VN<:AbstractArray{N,1}}}, Tuple{LazySet{N},Union{Hyperplane{N,VN} where VN<:AbstractArray{N,1}, Line2D{N,VN} where VN<:AbstractArray{N,1}},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(X::LazySet{N},\n                      hp::Union{Hyperplane{N}, Line2D{N}},\n                      [witness]::Bool=false\n                     ) where {N<:Real}\n\nCheck whether a compact set an a hyperplane do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nX       – compact set\nhp      – hyperplane\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff X  hp = \nIf witness option is activated:\n(true, []) iff X  hp = \n(false, v) iff X  hp   and v  X  hp\n\nNotes\n\nWe assume that X is compact. Otherwise, the support vector queries may fail.\n\nAlgorithm\n\nA compact convex set intersects with a hyperplane iff the support function in the negative resp. positive direction of the hyperplane's normal vector a is to the left resp. right of the hyperplane's constraint b:\n\n-ρ(-a)  b  ρ(a)\n\nFor witness generation, we compute a line connecting the support vectors to the left and right, and then take the intersection of the line with the hyperplane. We follow this algorithm for the line-hyperplane intersection.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{LazySet{N},HalfSpace{N,VN} where VN<:AbstractArray{N,1}}, Tuple{LazySet{N},HalfSpace{N,VN} where VN<:AbstractArray{N,1},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(X::LazySet{N},\n                      hs::HalfSpace{N},\n                      [witness]::Bool=false\n                     ) where {N<:Real}\n\nCheck whether a compact set an a half-space do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nX       – compact set\nhs      – half-space\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff X  hs = \nIf witness option is activated:\n(true, []) iff X  hs = \n(false, v) iff X  hs   and v  X  hs\n\nNotes\n\nWe assume that X is compact. Otherwise, the support vector queries may fail.\n\nAlgorithm\n\nA compact convex set intersects with a half-space iff the support vector in the negative direction of the half-space's normal vector a is contained in the half-space: σ(-a)  hs. The support vector is thus also a witness.\n\nOptional keyword arguments can be passed to the ρ function. In particular, if X is a lazy intersection, options can be passed to the line search algorithm.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{HalfSpace{N,VN} where VN<:AbstractArray{N,1},HalfSpace{N,VN} where VN<:AbstractArray{N,1}}, Tuple{HalfSpace{N,VN} where VN<:AbstractArray{N,1},HalfSpace{N,VN} where VN<:AbstractArray{N,1},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(hs1::HalfSpace{N},\n                      hs2::HalfSpace{N},\n                      [witness]::Bool=false\n                     ) where {N<:Real}\n\nCheck whether two half-spaces do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nhs1     – half-space\nhs2     – half-space\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff hs1  hs2 = \nIf witness option is activated:\n(true, []) iff hs1  hs2 = \n(false, v) iff hs1  hs2   and v  hs1  hs2\n\nAlgorithm\n\nTwo half-spaces do not intersect if and only if their normal vectors point in the opposite direction and there is a gap between the two defining hyperplanes.\n\nThe latter can be checked as follows: Let hs_1  a_1x = b_1 and hs2  a_2x = b_2. Then we already know that a_2 = -ka_1 for some positive scaling factor k. Let x_1 be a point on the defining hyperplane of hs_1. We construct a line segment from x_1 to the point x_2 on the defining hyperplane of hs_2 by shooting a ray from x_1 with direction a_1. Thus we look for a factor s such that (x_1 + sa_1)a_2 = b_2. This gives us s = (b_2 - x_1a_2)  (-k a_1a_1). The gap exists if and only if s is positive.\n\nIf the normal vectors do not point in opposite directions, then the defining hyperplanes intersect and we can produce a witness as follows. All points x in this intersection satisfy a_1x = b_1 and a_2x = b_2. Thus we have (a_1 + a_2)x = b_1+b_2. We now find a dimension where a_1 + a_2 is non-zero, say, i. Then the result is a vector with one non-zero entry in dimension i, defined as 0  0 (b_1 + b_2)(a_1i + a_2i) 0  0. Such a dimension i always exists.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{AbstractPolyhedron{N},LazySet{N}}, Tuple{AbstractPolyhedron{N},LazySet{N},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(P::AbstractPolyhedron{N},\n                      X::LazySet{N},\n                      witness::Bool=false;\n                      solver=default_lp_solver(N)\n                     ) where {N<:Real}\n\nCheck whether two polyhedra do not intersect.\n\nInput\n\nP         – polyhedron\nX         – another set (see the Notes section below)\nwitness   – (optional, default: false) compute a witness if activated\nsolver    – (optional, default: default_lp_solver(N)) the backend used to                solve the linear program\nalgorithm – (optional, default: \"exact\") algorithm keyword, one of:                * \"exact\" (exact, uses a feasibility LP)                *\"sufficient\" (sufficient, uses half-space checks)\n\nOutput\n\nIf witness option is deactivated: true iff P  X = \nIf witness option is activated:\n(true, []) iff P  X = \n(false, v) iff P  X   and v  P  X\n\nNotes\n\nFor algorithm == \"exact\", we assume that constraints_list(X) is defined. For algorithm == \"sufficient\", witness production is not supported.\n\nAlgorithm\n\nFor algorithm == \"exact\", see isempty(P::HPoly, ::Bool).\n\nFor algorithm == \"sufficient\", we rely on the intersection check between the set X and each constraint in P. This means one support function evaluation of X for each constraint of P. With the sufficiency algorithm, this function may return false even in the case where the intersection is empty. On the other hand, if the algorithm returns true, then it is guaranteed that the intersection is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{UnionSet{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N},LazySet{N}}, Tuple{UnionSet{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N},LazySet{N},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(cup::UnionSet{N}, X::LazySet{N},\n                      [witness]::Bool=false) where {N<:Real}\n\nCheck whether a union of two convex sets and another set do not intersect.\n\nInput\n\ncup – union of two convex sets\nX   – another set\n\nOutput\n\ntrue iff textcup  X = .\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{UnionSetArray{N,S} where S<:LazySet{N},LazySet{N}}, Tuple{UnionSetArray{N,S} where S<:LazySet{N},LazySet{N},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(cup::UnionSetArray{N}, X::LazySet{N},\n                      [witness]::Bool=false) where {N<:Real}\n\nCheck whether a union of a finite number of convex sets and another set do not intersect.\n\nInput\n\ncup – union of a finite number of convex sets\nX   – another set\n\nOutput\n\ntrue iff textcup  X = .\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{Universe{N},LazySet{N}}, Tuple{Universe{N},LazySet{N},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(U::Universe{N}, X::LazySet{N},\n                      [witness]::Bool=false) where {N<:Real}\n\nCheck whether a universe and another set do not intersect.\n\nInput\n\nU – universe\nX – another set\n\nOutput\n\ntrue iff X  .\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{Complement{N,S} where S<:LazySet{N},LazySet{N}}, Tuple{Complement{N,S} where S<:LazySet{N},LazySet{N},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(C::Complement{N},\n                      X::LazySet{N},\n                      [witness]::Bool=false\n                     ) where {N<:Real}\n\nCheck whether the complement of a convex set and another set do not intersect.\n\nInput\n\nC – complement of a convex set\nX – convex set\n\nOutput\n\nIf witness option is deactivated: true iff X  C = \nIf witness option is activated:\n(true, []) iff X  C = \n(false, v) iff X  C   and v  X  C\n\nAlgorithm\n\nWe fall back to X ⊆ C.X, which can be justified as follows:\n\n    X  Y^C =   X  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{Zonotope{N,VN,MN} where MN<:AbstractArray{N,2} where VN<:AbstractArray{N,1},Zonotope{N,VN,MN} where MN<:AbstractArray{N,2} where VN<:AbstractArray{N,1}}, Tuple{Zonotope{N,VN,MN} where MN<:AbstractArray{N,2} where VN<:AbstractArray{N,1},Zonotope{N,VN,MN} where MN<:AbstractArray{N,2} where VN<:AbstractArray{N,1},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(Z1::Zonotope{N}, Z2::Zonotope{N}, witness::Bool=false\n                     ) where {N<:Real}\n\nCheck whether two zonotopes do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nZ1      – zonotope\nZ2      – zonotope\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff Z1  Z2 = \nIf witness option is activated:\n(true, []) iff Z1  Z2 = \n(false, v) iff Z1  Z2   and v  Z1  Z2\n\nAlgorithm\n\nZ1  Z2   iff c_1 - c_2  Z(0 (g_1 g_2)) where c_i and g_i are the center and generators of zonotope Zi and Z(c g) represents the zonotope with center c and generators g.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N},Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}, Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N},Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(I1::Interval{N}, I2::Interval{N}, witness::Bool=false) where {N<:Real}\n\nCheck whether two intervals do not intersect, and otherwise optionally compute a witness.\n\nInput\n\nI1      – first interval\nI2      – second interval\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff I1  I2 = \nIf witness option is activated:\n(true, []) iff I1  I2 = \n(false, v) iff I1  I2   and v  I1  I2\n\nAlgorithm\n\nI1  I2   iff there is a gap between the left-most point of the second interval and the left-most point of the first interval, or vice-versa.\n\nA witness is computed by taking the maximum over the left-most points of each interval, which is guaranteed to belong to the intersection.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S<:LazySet{N},AbstractPolyhedron{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(cpa::CartesianProductArray{N},\n                      P::AbstractPolyhedron{N}) where {N<:Real}\n\nCheck whether a polytopic Cartesian product array intersects with a polyhedron.\n\nInput\n\ncpa – Cartesian product array of polytopes\nP   – polyhedron\n\nOutput\n\ntrue iff textcpa  Y = .\n\nAlgorithm\n\nWe first identify the blocks of cpa in which P is constrained. Then we project cpa to those blocks and convert the result to an HPolytope Q. Finally we determine whether Q and the projected P intersect.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S<:LazySet{N},CartesianProductArray{N,S} where S<:LazySet{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(X::CartesianProductArray{N},\n                      Y::CartesianProductArray{N}) where {N<:Real}\n\nCheck whether two Cartesian products of a finite number of convex sets do not intersect.\n\nInput\n\nX – Cartesian product array of convex sets\nY – Cartesian product array of convex sets\n\nOutput\n\ntrue iff X  Y = .\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.is_intersection_empty-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S<:LazySet{N},AbstractHyperrectangle{N}}, Tuple{CartesianProductArray{N,S} where S<:LazySet{N},AbstractHyperrectangle{N},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.is_intersection_empty","text":"is_intersection_empty(cpa::CartesianProductArray{N},\n                      H::AbstractHyperrectangle{N}) where {N<:Real}\n\nCheck whether a Cartesian product of a finite number of convex sets and a hyperrectangular set do not intersect, and otherwise optionally compute a witness.\n\nInput\n\ncpa     – Cartesian product of a finite number of convex sets\nH       – hyperrectangular set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff cpa  H = \nIf witness option is activated:\n(true, []) iff cpa  H = \n(false, v) iff cpa  H   and v  cpa  H\n\nAlgorithm\n\nThe sets cpa and H are disjoint if and only if at least one block of cpa and the corresponding projection of H are disjoint. We perform these checks sequentially.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Convex-hull","page":"Concrete Operations","title":"Convex hull","text":"","category":"section"},{"location":"lib/binary_functions/","page":"Concrete Operations","title":"Concrete Operations","text":"convex_hull(::LazySet{N}, ::LazySet{N}) where {N<:Real}\nconvex_hull(::HPoly{N}, ::HPoly{N}) where {N<:Real}\nconvex_hull(::VPolytope{N}, ::VPolytope{N}) where {N<:Real}\nconvex_hull(::VPolygon{N}, ::VPolygon{N}) where {N<:Real}\nconvex_hull(::Vector{VN}) where {N<:Real, VN<:AbstractVector{N}}\nmonotone_chain!","category":"page"},{"location":"lib/binary_functions/#LazySets.convex_hull-Union{Tuple{N}, Tuple{LazySet{N},LazySet{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.convex_hull","text":"convex_hull(X::LazySet{N}, Y::LazySet{N}; [algorithm]=nothing,\n            [backend]=nothing, [solver]=nothing) where {N<:Real}\n\nCompute the convex hull of the given convex sets.\n\nInput\n\nX         – convex set\nY         – convex set\nalgorithm – (optional, default: nothing) the convex-hull algorithm\nbackend   – (optional, default: nothing) backend for polyhedral                computations (used for higher-dimensional sets)\nsolver    – (optional, default: nothing) the linear-programming solver                used in the backend\n\nOutput\n\nIf the input sets are one-dimensional, the result is an Interval. If the input sets are two-dimensional, the result is a VPolygon. Otherwise the result is a VPolytope.\n\nAlgorithm\n\nOne-dimensional sets are resolved by using overapproximate with an Interval (which is exact). For higher-dimensional sets, we compute the vertices of both X and Y using vertices_list and then compute the convex hull of the union of those vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.convex_hull-Union{Tuple{N}, Tuple{Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}},Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}}}} where N<:Real","page":"Concrete Operations","title":"LazySets.convex_hull","text":"convex_hull(P1::HPoly{N}, P2::HPoly{N};\n           [backend]=default_polyhedra_backend(P1, N)) where {N<:Real}\n\nCompute the convex hull of the set union of two polyhedra in H-representation.\n\nInput\n\nP1         – polyhedron\nP2         – another polyhedron\nbackend    – (optional, default: default_polyhedra_backend(P1, N))                 the polyhedral computations backend\n\nOutput\n\nThe HPolyhedron (resp. HPolytope) obtained by the concrete convex hull of P1 and P2.\n\nNotes\n\nFor performance reasons, it is suggested to use the CDDLib.Library() backend for the convex_hull.\n\nFor further information on the supported backends see Polyhedra's documentation.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.convex_hull-Union{Tuple{N}, Tuple{VPolytope{N,VN} where VN<:AbstractArray{N,1},VPolytope{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Concrete Operations","title":"LazySets.convex_hull","text":"convex_hull(P1::VPolytope{N}, P2::VPolytope{N};\n            [backend]=default_polyhedra_backend(P1, N)) where {N<:Real}\n\nCompute the convex hull of the set union of two polytopes in V-representation.\n\nInput\n\nP1         – polytope\nP2         – another polytope\nbackend    – (optional, default: nothing) the polyhedral                 computations backend\n\nOutput\n\nThe VPolytope obtained by the concrete convex hull of P1 and P2.\n\nNotes\n\nThis function takes the union of the vertices of each polytope and then relies on a concrete convex hull algorithm. For low dimensions, a specialized implementation for polygons is used. For higher dimensions, convex_hull relies on the polyhedral computations backend that can be specified using the backend keyword argument.\n\nFor performance reasons, it is suggested to use the CDDLib.Library() backend for the convex_hull.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.convex_hull-Union{Tuple{N}, Tuple{VPolygon{N,VN} where VN<:AbstractArray{N,1},VPolygon{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Concrete Operations","title":"LazySets.convex_hull","text":"convex_hull(P::VPolygon{N}, Q::VPolygon{N};\n            [algorithm]::String=\"monotone_chain\") where {N<:Real}\n\nReturn the convex hull of two polygons in vertex representation.\n\nInput\n\nP         – polygon in vertex representation\nQ         – another polygon in vertex representation\nalgorithm – (optional, default: \"monotone_chain\") the algorithm used to                compute the convex hull\n\nOutput\n\nA new polygon such that its vertices are the convex hull of the given two polygons.\n\nAlgorithm\n\nA convex hull algorithm is used to compute the convex hull of the vertices of the given input polygons P and Q; see ?convex_hull for details on the available algorithms. The vertices of the output polygon are sorted in counter-clockwise fashion.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.convex_hull-Union{Tuple{Array{VN,1}}, Tuple{VN}, Tuple{N}} where VN<:AbstractArray{N,1} where N<:Real","page":"Concrete Operations","title":"LazySets.convex_hull","text":"convex_hull(points::Vector{VN};\n            [algorithm]=nothing,\n            [backend]=nothing,\n            [solver]=nothing\n            ) where {N<:Real, VN<:AbstractVector{N}}\n\nCompute the convex hull of the given points.\n\nInput\n\npoints    – list of vectors\nalgorithm – (optional, default: nothing) the convex-hull algorithm; see                below for valid options\nbackend   – (optional, default: nothing) polyhedral computation backend                for higher-dimensional point sets\nsolver    – (optional, default: nothing) the linear-programming solver                used in the backend\n\nOutput\n\nThe convex hull as a list of vectors with the coordinates of the points.\n\nAlgorithm\n\nA pre-processing step treats the cases with up to two points for one dimension and up to four points for two dimensions. For more points in one resp. two dimensions, we use more general algorithms.\n\nFor the one-dimensional case we return the minimum and maximum points, in that order.\n\nThe two-dimensional case is handled with a planar convex hull algorithm. The following algorithms are available:\n\n\"monotone_chain\"        – compute the convex hull of points in the plane                              using Andrew's monotone chain method\n\"monotone_chain_sorted\" – the same as \"monotone_chain\" but assuming that                              the points are already sorted in counter-clockwise                              fashion\n\nSee the reference docstring of each of those algorithms for details.\n\nThe higher dimensional case is treated using the concrete polyhedra library Polyhedra, that gives access to libraries such as CDDLib and ConvexHull.jl. These libraries can be chosen from the backend argument.\n\nNotes\n\nFor the in-place version use convex_hull! instead of convex_hull.\n\nExamples\n\nCompute the convex hull of a random set of points:\n\njulia> points = [randn(2) for i in 1:30]; # 30 random points in 2D\n\njulia> hull = convex_hull(points);\n\njulia> typeof(hull)\nArray{Array{Float64,1},1}\n\nPlot both the random points and the computed convex hull polygon:\n\njulia> using Plots;\n\njulia> plot([Tuple(pi) for pi in points], seriestype=:scatter);\n\njulia> plot!(VPolygon(hull), alpha=0.2);\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.monotone_chain!","page":"Concrete Operations","title":"LazySets.monotone_chain!","text":"monotone_chain!(points::Vector{VN}; sort::Bool=true\n               ) where {N<:Real, VN<:AbstractVector{N}}\n\nCompute the convex hull of points in the plane using Andrew's monotone chain method.\n\nInput\n\npoints – list of 2D vectors; is sorted in-place inside this function\nsort   – (optional, default: true) flag for sorting the vertices             lexicographically; sortedness is required for correctness\n\nOutput\n\nList of vectors containing the 2D coordinates of the corner points of the convex hull.\n\nNotes\n\nFor large sets of points, it is convenient to use static vectors to get maximum performance. For information on how to convert usual vectors into static vectors, see the type SVector provided by the StaticArrays package.\n\nAlgorithm\n\nThis function implements Andrew's monotone chain convex hull algorithm to construct the convex hull of a set of n points in the plane in O(n log n) time. For further details see Monotone chain\n\n\n\n\n\n","category":"function"},{"location":"lib/binary_functions/#Intersection-of-two-sets","page":"Concrete Operations","title":"Intersection of two sets","text":"","category":"section"},{"location":"lib/binary_functions/","page":"Concrete Operations","title":"Concrete Operations","text":"intersection(::AbstractSingleton{N}, ::LazySet{N}) where {N<:Real}\nintersection(::Line2D{N}, ::Line2D{N}) where {N<:Real}\nintersection(::AbstractHyperrectangle{N}, ::AbstractHyperrectangle{N}) where {N<:Real}\nintersection(::Interval{N}, ::Interval{N}) where {N<:Real}\nintersection(::Interval{N}, ::HalfSpace{N}) where {N<:Real}\nintersection(::Interval{N}, ::Hyperplane{N}) where {N<:Real}\nintersection(::Interval{N}, ::LazySet{N}) where {N<:Real}\nintersection(::AbstractHPolygon{N}, ::AbstractHPolygon{N}, ::Bool=true) where {N<:Real}\nintersection(::AbstractPolyhedron{N}, ::AbstractPolyhedron{N}) where {N<:Real}\nintersection(::Union{VPolytope{N}, VPolygon{N}}, ::Union{VPolytope{N}, VPolygon{N}}) where {N<:Real}\nintersection(::UnionSet{N}, ::LazySet{N}) where {N<:Real}\nintersection(::UnionSetArray{N}, ::LazySet{N}) where {N<:Real}\nintersection(::Universe{N}, ::LazySet{N}) where {N<:Real}\nintersection(::AbstractPolyhedron{N}, ::ResetMap{N}) where {N<:Real}\nintersection(::CartesianProductArray{N}, ::CartesianProductArray{N}) where {N<:Real}\nintersection(::LinearMap{N}, ::LazySet{N}) where {N<:Real}\nintersection(::CartesianProductArray{N}, ::AbstractPolyhedron{N}) where {N<:Real}","category":"page"},{"location":"lib/binary_functions/#LazySets.intersection-Union{Tuple{N}, Tuple{AbstractSingleton{N},LazySet{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.intersection","text":"intersection(S::AbstractSingleton{N},\n             X::LazySet{N}\n            ) where {N<:Real}\n\nReturn the intersection of a singleton with another set.\n\nInput\n\nS – singleton\nX – another set\n\nOutput\n\nIf the sets intersect, the result is S. Otherwise, the result is the empty set.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.intersection-Union{Tuple{N}, Tuple{Line2D{N,VN} where VN<:AbstractArray{N,1},Line2D{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Concrete Operations","title":"LazySets.intersection","text":"intersection(L1::Line2D{N}, L2::Line2D{N}\n            ) where {N<:Real}\n\nReturn the intersection of two 2D lines.\n\nInput\n\nL1 – first line\nL2 – second line\n\nOutput\n\nIf the lines are identical, the result is the first line. If the lines are parallel and not identical, the result is the empty set. Otherwise the result is the only intersection point.\n\nAlgorithm\n\nWe first check whether the lines are parallel. If not, we use Cramer's rule to compute the intersection point.\n\nExamples\n\nThe line y = -x + 1 intersected with the line y = x:\n\njulia> intersection(Line2D([-1., 1.], 0.), Line2D([1., 1.], 1.))\nSingleton{Float64,Array{Float64,1}}([0.5, 0.5])\n\njulia> intersection(Line2D([1., 1.], 1.), Line2D([1., 1.], 1.))\nLine2D{Float64,Array{Float64,1}}([1.0, 1.0], 1.0)\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.intersection-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.intersection","text":"intersection(H1::AbstractHyperrectangle{N},\n             H2::AbstractHyperrectangle{N}\n            ) where {N<:Real}\n\nReturn the intersection of two hyperrectangles.\n\nInput\n\nH1 – first hyperrectangle\nH2 – second hyperrectangle\n\nOutput\n\nIf the hyperrectangles do not intersect, the result is the empty set. Otherwise the result is the hyperrectangle that describes the intersection.\n\nAlgorithm\n\nIn each isolated direction i we compute the rightmost left border and the leftmost right border of the hyperrectangles. If these borders contradict, then the intersection is empty. Otherwise the result uses these borders in each dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.intersection-Union{Tuple{N}, Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N},Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.intersection","text":"intersection(x::Interval{N}, y::Interval{N}\n            ) where {N<:Real}\n\nReturn the intersection of two intervals.\n\nInput\n\nx – first interval\ny – second interval\n\nOutput\n\nIf the intervals do not intersect, the result is the empty set. Otherwise the result is the interval that describes the intersection.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.intersection-Union{Tuple{N}, Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N},HalfSpace{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Concrete Operations","title":"LazySets.intersection","text":"intersection(X::Interval{N}, hs::HalfSpace{N}\n            ) where {N<:Real}\n\nCompute the intersection of an interval and a half-space.\n\nInput\n\nX  – interval\nhs – half-space\n\nOutput\n\nIf the sets do not intersect, the result is the empty set. If the interval is fully contained in the half-space, the result is the original interval. Otherwise the result is the interval that describes the intersection.\n\nAlgorithm\n\nWe first handle the special case that the normal vector a of hs is close to zero. Then we distinguish the cases that hs is a lower or an upper bound.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.intersection-Union{Tuple{N}, Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N},Hyperplane{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Concrete Operations","title":"LazySets.intersection","text":"intersection(X::Interval{N}, hp::Hyperplane{N}\n            ) where {N<:Real}\n\nCompute the intersection of an interval and a hyperplane.\n\nInput\n\nX  – interval\nhp – hyperplane\n\nOutput\n\nIf the sets do not intersect, the result is the empty set. Otherwise the result is the singleton that describes the intersection.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.intersection-Union{Tuple{N}, Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N},LazySet{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.intersection","text":"intersection(X::Interval{N}, Y::LazySet{N}\n            ) where {N<:Real}\n\nCompute the intersection of an interval and a convex set.\n\nInput\n\nX – interval\nY – convex set\n\nOutput\n\nIf the sets do not intersect, the result is the empty set. Otherwise the result is the interval that describes the intersection, which may be of type Singleton if the intersection is very small.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.intersection-Union{Tuple{N}, Tuple{AbstractHPolygon{N},AbstractHPolygon{N}}, Tuple{AbstractHPolygon{N},AbstractHPolygon{N},Bool}} where N<:Real","page":"Concrete Operations","title":"LazySets.intersection","text":"intersection(P1::AbstractHPolygon{N},\n             P2::AbstractHPolygon{N},\n             [prune]::Bool=true\n            ) where {N<:Real}\n\nReturn the intersection of two polygons in constraint representation.\n\nInput\n\nP1    – first polygon\nP2    – second polygon\nprune – (optional, default: true) flag for removing redundant constraints\n\nOutput\n\nIf the polygons do not intersect, the result is the empty set. Otherwise the result is the polygon that describes the intersection.\n\nAlgorithm\n\nWe just combine the constraints of both polygons. To obtain a linear-time algorithm, we interleave the constraints. If there are two constraints with the same normal vector, we choose the tighter one.\n\nRedundancy of constraints is checked with remove_redundant_constraints!(::AbstractHPolygon).\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.intersection-Union{Tuple{N}, Tuple{AbstractPolyhedron{N},AbstractPolyhedron{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.intersection","text":"intersection(P1::AbstractPolyhedron{N},\n             P2::AbstractPolyhedron{N};\n             backend=default_lp_solver(N)) where {N<:Real}\n\nCompute the intersection of two polyhedra.\n\nInput\n\nP1      – polyhedron\nP2      – polyhedron\nbackend – (optional, default: default_lp_solver(N)) the LP solver used              for the removal of redundant constraints; see the Notes section              below for details\n\nOutput\n\nAn HPolyhedron resulting from the intersection of P1 and P2, with the redundant constraints removed, or an empty set if the intersection is empty. If one of the arguments is a polytope, the result is an HPolytope instead.\n\nNotes\n\nThe default value of the solver backend is default_lp_solver(N) and it is used to run a feasiblity LP to remove the redundant constraints of the intersection.\n\nIf you want to use the Polyhedra library, pass an appropriate backend. For example, to use the default Polyhedra library use default_polyhedra_backend(P, N) or use CDDLib.Library() for the CDD library.\n\nThere are some shortcomings of the removal of constraints using the default Polyhedra library; see e.g. #1038 and Polyhedra#146. It is safer to check for emptiness of intersection before calling this function in those cases.\n\nAlgorithm\n\nThis implementation unifies the constraints of the two sets obtained from the constraints_list method.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.intersection-Union{Tuple{N}, Tuple{Union{VPolygon{N,VN} where VN<:AbstractArray{N,1}, VPolytope{N,VN} where VN<:AbstractArray{N,1}},Union{VPolygon{N,VN} where VN<:AbstractArray{N,1}, VPolytope{N,VN} where VN<:AbstractArray{N,1}}}} where N<:Real","page":"Concrete Operations","title":"LazySets.intersection","text":"intersection(P1::Union{VPolytope{N}, VPolygon{N}},\n             P2::Union{VPolytope{N}, VPolygon{N}};\n             [backend]=default_polyhedra_backend(P1, N),\n             [prunefunc]=removevredundancy!) where {N<:Real}\n\nCompute the intersection of two polytopes in vertex representation.\n\nInput\n\nP1        – polytope in vertex representation\nP2        – polytope in vertex representation\nbackend   – (optional, default: default_polyhedra_backend(P1, N)) the                backend for polyhedral computations\nprunefunc – (optional, default: removevredundancy!) function to prune                the vertices of the result\n\nOutput\n\nA VPolygon if both arguments are VPolygons, and a VPolytope otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.intersection-Union{Tuple{N}, Tuple{UnionSet{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N},LazySet{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.intersection","text":"intersection(cup::UnionSet{N}, X::LazySet{N}) where {N<:Real}\n\nReturn the intersection of a union of two convex sets and another convex set.\n\nInput\n\ncup – union of two convex sets\nX   – convex set\n\nOutput\n\nThe union of the pairwise intersections, expressed as a UnionSet. If one of those sets is empty, only the other set is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.intersection-Union{Tuple{N}, Tuple{UnionSetArray{N,S} where S<:LazySet{N},LazySet{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.intersection","text":"intersection(cup::UnionSetArray{N}, X::LazySet{N}) where {N<:Real}\n\nReturn the intersection of a union of a finite number of convex sets and another convex set.\n\nInput\n\ncup – union of a finite number of convex sets\nX   – convex set\n\nOutput\n\nThe union of the pairwise intersections, expressed as a UnionSetArray.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.intersection-Union{Tuple{N}, Tuple{Universe{N},LazySet{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.intersection","text":"intersection(U::Universe{N}, X::LazySet{N}) where {N<:Real}\n\nReturn the intersection of a universe and a convex set.\n\nInput\n\nU – universe\nX – convex set\n\nOutput\n\nThe set X.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.intersection-Union{Tuple{N}, Tuple{AbstractPolyhedron{N},ResetMap{N,S} where S<:LazySet{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.intersection","text":"intersection(P::AbstractPolyhedron{N}, rm::ResetMap{N}) where {N<:Real}\n\nReturn the intersection of a polyhedron and a polyhedral reset map.\n\nInput\n\nP  – polyhedron\nrm – polyhedral reset map\n\nOutput\n\nA polyhedron.\n\nNotes\n\nWe assume that rm is polyhedral, i.e., has a constraints_list method defined.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.intersection-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S<:LazySet{N},CartesianProductArray{N,S} where S<:LazySet{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.intersection","text":"    intersection(X::CartesianProductArray{N}, Y::CartesianProductArray{N})\n\nReturn the intersection between cartesian products of a finite number of convex sets.\n\nInput\n\nX – cartesian product of a finite number of convex sets\nY – cartesian product of a finite number of convex sets\n\nOutput\n\nThe decomposed set which represents concrete intersection between X and Y\n\nAlgorithm\n\nThis algorithm intersect corresponding blocks between sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.intersection-Union{Tuple{N}, Tuple{LinearMap{N,S,NM,MAT} where MAT<:AbstractArray{NM,2} where NM where S<:LazySet{N},LazySet{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.intersection","text":"intersection(L::LinearMap{N}, S::LazySet{N}) where {N<:Real}\n\nReturn the intersection of a lazy linear map and a convex set.\n\nInput\n\nL – linear map\nS – convex set\n\nOutput\n\nThe polytope obtained by the intersection of l.M * L.X and S.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.intersection-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S<:LazySet{N},AbstractPolyhedron{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.intersection","text":"intersection(cpa::CartesianProductArray{N}, P::AbstractPolyhedron{N}\n            ) where {N<:Real}\n\nCompute the intersection of a Cartesian product of a finite number of polyhedral sets with a polyhedron.\n\nInput\n\ncpa – Cartesian product of a finite number of polyhedral sets\nP   – polyhedron\n\nOutput\n\nA Cartesian product of a finite number of polyhedral sets. See the Algorithm section below for details about the structure.\n\nNotes\n\nThe restriction to polyhedral sets in cpa only applies to the blocks that are actually intersected with P (see the Algorithm section below for details). All other blocks are not considered by the intersection and remain identical.\n\nAlgorithm\n\nThe underlying idea of the algorithm is to exploit the unconstrained dimensions of P. Without loss of generality, assume that cpa has the structure X  Y  Z such that only the dimensions of Y are constrained in P, and denoting a suitable projection of P to the dimensions of Y with P_Y, we have the following equivalence:\n\n    (X  Y  Z)  P = X  (Y  P_Y)  Z\n\nNote that Y may still consist of many blocks. However, due to the structural restriction of a Cartesian product, we cannot break down this set further even if P_Y is still unconstrained in some dimensions of blocks in Y. This would require a restructuring of the dimensions. Consider this example:\n\n    Y = 0 1  1 2  2 3\n    P_Y = x₁ + x₃  2\n    Y  P_Y = 0  x₁  1  x₂  2  2  x₃  x₁ + x₃  2\n\nEven though the constraints of dimension x₂ are decoupled from the rest, due to the last constraint the Cartesian product cannot be broken down further. In particular, the result Y  P_Y is a polyhedron in this implementation.\n\nNow we explain the implementation of the above idea. We first identify the dimensions in which P is constrained. Then we identify the block dimensions of X  Y  Z such that Y has minimal dimension. Finally, we convert Y to a polyhedron and intersect it with a suitable projection of P.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Minkowski-sum","page":"Concrete Operations","title":"Minkowski sum","text":"","category":"section"},{"location":"lib/binary_functions/","page":"Concrete Operations","title":"Concrete Operations","text":"minkowski_sum(::LazySet{N}, ::LazySet{N}) where {N<:Real}\nminkowski_sum(::AbstractPolyhedron{N}, ::AbstractPolyhedron{N}) where {N<:Real}\nminkowski_sum(::VPolytope{N}, ::VPolytope{N}) where {N<:Real}\nminkowski_sum(::AbstractHyperrectangle{N}, ::AbstractHyperrectangle{N}) where {N<:Real}\nminkowski_sum(::AbstractZonotope{N}, ::AbstractZonotope{N}) where {N<:Real}\nminkowski_sum(::VPolygon{N}, ::VPolygon{N}) where {N<:Real}\nminkowski_sum(::PolynomialZonotope, ::Zonotope)\nminkowski_sum(::Interval, ::Interval)","category":"page"},{"location":"lib/binary_functions/#LazySets.minkowski_sum-Union{Tuple{N}, Tuple{LazySet{N},LazySet{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.minkowski_sum","text":"minkowski_sum(P::LazySet{N}, Q::LazySet{N};\n              [backend]=nothing,\n              [algorithm]=nothing,\n              [prune]=true) where {N<:Real}\n\nConcrete Minkowski sum for a pair of lazy sets using their constraint representation.\n\nInput\n\nP         – lazy set\nQ         – another lazy set\nbackend   – (optional, default: nothing) polyhedral computations backend\nalgorithm – (optional, default: nothing) algorithm to compute the elimination                of variables; available options are Polyhedra.FourierMotzkin,                Polyhedra.BlockElimination, and Polyhedra.ProjectGenerators\nprune     – (optional, default: true) if true, apply a post-processing algorithm                to remove redundant constraints\n\nOutput\n\nAn HPolytope that corresponds to the Minkowski sum of P and Q if both P and Q are bounded; otherwise an HPolyhedron.\n\nNotes\n\nThis function requires that the list of constraints of both lazy sets P and Q can be obtained. After obtaining the respective lists of constraints, the minkowski_sum fucntion for polyhedral sets is used. For details see minkowski_sum(::VPolytope, ::VPolytope).\n\nThis method requires Polyhedra and CDDLib, so you have to do:\n\njulia> using LazySets, Polyhedra, CDDLib\n\njulia> ...\n\njulia> minkowski_sum(P, Q)\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.minkowski_sum-Union{Tuple{N}, Tuple{AbstractPolyhedron{N},AbstractPolyhedron{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.minkowski_sum","text":"minkowski_sum(P::AbstractPolyhedron{N}, Q::AbstractPolyhedron{N};\n              [backend]=nothing,\n              [algorithm]=nothing,\n              [prune]=true) where {N<:Real}\n\nCompute the Minkowski sum between two polyhedra in constraint representation.\n\nInput\n\nP         – polyhedron in constraint representation\nQ         – another polyhedron in constraint representation\nbackend   – (optional, default: nothing) polyhedral computations backend\nalgorithm – (optional, default: nothing) algorithm to compute the elimination                of variables; available options are Polyhedra.FourierMotzkin,                Polyhedra.BlockElimination, and Polyhedra.ProjectGenerators\nprune     – (optional, default: true) if true, apply a post-processing algorithm                to remove redundant constraints\n\nOutput\n\nA polyhedron in H-representation that corresponds to the Minkowski sum of P and Q.\n\nNotes\n\nThis method requires Polyhedra and CDDLib, so you have to do:\n\njulia> using LazySets, Polyhedra, CDDLib\n\njulia> ...\n\njulia> minkowski_sum(P, Q)\n\nAlgorithm\n\nThis function implements the concrete Minkowski sum by projection and variable elimination as detailed in [1]. The idea is that if we write P and Q in simple H-representation, that is, P = x  mathbbR^n  Ax  b  and Q = x  mathbbR^n  Cx  d , then their Minkowski sum can be seen as the projection onto the first n-dimensional coordinates of the polyhedron\n\n    beginpmatrix 0  A  C  -C endpmatrix binomxy  inombd\n\nThis is seen by noting that P  Q corresponds to the set of points x  mathbbR^n such that x = y + z with Ay  b and Cz  d; hence it follows that Ay  b and C(x-y)  d, and the inequality displayed above follows by considering the 2n-dimensional space binomxy. The reduction from 2n to n variables is performed using an elimination algorithm as described next.\n\nThe elimination of variables depends on the concrete polyhedra library Polyhedra, which itself uses CDDLib for variable elimination. The available algorithms are:\n\nPolyhedra.FourierMotzkin   – computation of the projection by computing the                                 H-representation and applying the Fourier-Motzkin                                 elimination algorithm to it\nPolyhedra.BlockElimination – computation of the projection by computing the                                 H-representation and applying the block elimination                                 algorithm to it\nPolyhedra.ProjectGenerators – computation of the projection by computing the                                  V-representation\n\n[1] Kvasnica, Michal. \"Minkowski addition of convex polytopes.\" (2005): 1-10.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.minkowski_sum-Union{Tuple{N}, Tuple{VPolytope{N,VN} where VN<:AbstractArray{N,1},VPolytope{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Concrete Operations","title":"LazySets.minkowski_sum","text":"minkowski_sum(P1::VPolytope{N}, P2::VPolytope{N};\n              [apply_convex_hull]=true,\n              [backend]=nothing,\n              [solver]=nothing) where {N<:Real}\n\nCompute the Minkowski sum between two polytopes in vertex representation.\n\nInput\n\nP1                – polytope\nP2                – another polytope\napply_convex_hull – (optional, default: true) if true, post-process the                        pairwise sums using a convex hull algorithm\nbackend           – (optional, default: nothing) the backend for                        polyhedral computations used to post-process with a                        convex hull; see default_polyhedra_backend(P1, N)\nsolver            – (optional, default: nothing) the backend used to                        solve the linear program; see                        default_lp_solver_polyhedra(N)\n\nOutput\n\nA new polytope in vertex representation whose vertices are the convex hull of the sum of all possible sums of vertices of P1 and P2.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.minkowski_sum-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.minkowski_sum","text":"minkowski_sum(H1::AbstractHyperrectangle{N}, H2::AbstractHyperrectangle{N})\n    where {N<:Real}\n\nConcrete Minkowski sum of a pair of hyperrectangular sets.\n\nInput\n\nH1 – hyperrectangular set\nH2 – hyperrectangular set\n\nOutput\n\nA Hyperrectangle corresponding to the concrete Minkowski sum of H1 and H2.\n\nAlgorithm\n\nThe resulting hyperrectangle is obtained by summing up the centers and radiuses of H1 and H2.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.minkowski_sum-Union{Tuple{N}, Tuple{AbstractZonotope{N},AbstractZonotope{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.minkowski_sum","text":"minkowski_sum(Z1::AbstractZonotope{N}, Z2::AbstractZonotope{N}) where {N<:Real}\n\nConcrete Minkowski sum of a pair of zonotopic sets.\n\nInput\n\nZ1 – zonotopic set\nZ2 – zonotopic set\n\nOutput\n\nA Zonotope corresponding to the concrete Minkowski sum of Z1 and Z2.\n\nAlgorithm\n\nThe resulting zonotope is obtained by summing up the centers and concatenating the generators of Z1 and Z2.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.minkowski_sum-Union{Tuple{N}, Tuple{VPolygon{N,VN} where VN<:AbstractArray{N,1},VPolygon{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Concrete Operations","title":"LazySets.minkowski_sum","text":"minkowski_sum(P::VPolygon{N}, Q::VPolygon{N}) where {N<:Real}\n\nThe Minkowski Sum of two polygon in vertex representation.\n\nInput\n\nP – polygon in vertex representation\nQ – another polygon in vertex representation\n\nOutput\n\nA polygon in vertex representation.\n\nAlgorithm\n\nWe treat each edge of the polygons as a vector, attaching them in polar order (attaching the tail of the next vector to the head of the previous vector). The resulting polygonal chain will be a polygon, which is the Minkowski sum of the given polygons. This algorithm assumes that the vertices of P and Q are sorted in counter-clockwise fashion and has linear complexity O(m+n) where m and n are the number of vertices of P and Q respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.minkowski_sum-Tuple{PolynomialZonotope,Zonotope}","page":"Concrete Operations","title":"LazySets.minkowski_sum","text":"minkowski_sum(pz::PolynomialZonotope, z::Zonotope)\n\nReturn the Minkowski sum of a polynomial zonotope and a usual zonotope.\n\nInput\n\npz – polynomial zonotope\nz  – usual zonotope\n\nOutput\n\nPolynomial zonotope such that its center is the sum of the centers of pz and z and its generators is the matrix that results by concatenating them.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.minkowski_sum-Tuple{Interval,Interval}","page":"Concrete Operations","title":"LazySets.minkowski_sum","text":"minkowski_sum(x::Interval, y::Interval)\n\nConcrete Minkowski sum of a pair of intervals.\n\nInput\n\nx – hyperrectangular set\ny – hyperrectangular set\n\nOutput\n\nAn Interval corresponding to the concrete Minkowski sum of x and y.\n\nAlgorithm\n\nThe function takes the sum of x and y following the rules of interval arithmetic.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Minkowski-difference","page":"Concrete Operations","title":"Minkowski difference","text":"","category":"section"},{"location":"lib/binary_functions/","page":"Concrete Operations","title":"Concrete Operations","text":"minkowski_difference(::LazySet{N}, ::LazySet{N}) where {N<:Real}\npontryagin_difference","category":"page"},{"location":"lib/binary_functions/#LazySets.minkowski_difference-Union{Tuple{N}, Tuple{LazySet{N},LazySet{N}}} where N<:Real","page":"Concrete Operations","title":"LazySets.minkowski_difference","text":"minkowski_difference(P::LazySet{N}, Q::LazySet{N}) where {N<:Real}\n\nConcrete Minkowski difference (geometric difference) for a pair of convex sets.\n\nInput\n\nP – polytopic set\nQ – compact convex set that is subtracted from P\n\nOutput\n\nAn HPolytope that corresponds to the Minkowski difference of P minus Q if P is bounded, and an HPolyhedron if P is unbounded.\n\nNotes\n\nThis function requires that the list of constraints of the set P is available and that the set Q is bounded.\n\nAlgorithm\n\nThis function implements Theorem 2.3 in [1], which we state next.\n\nSuppose P is a polyhedron\n\nP = z  ℝ^n sᵢᵀz  rᵢi = 1  N\n\nwhere sᵢ  ℝ^n sᵢ  0, and rᵢ  ℝ. Assume ρ(sᵢQ) is defined for i = 1  N. Then,\n\nP  Q = z  ℝ^n sᵢᵀz  rᵢ - ρ(sᵢQ)i = 1  N\n\nwhere  is defined as P  Q = z  ℝ^n z + v  P  v  Q and is called the Minkowski difference (also referenced as Pontryagin difference, or geometric difference). It is denoted in [1] as the operation P ~ Q.\n\n[1] Ilya Kolmanovsky and Elmer G. Gilbert (1997). Theory and computation of disturbance invariant sets for discrete-time linear systems. Mathematical Problems in Engineering Volume 4, Issue 4, Pages 317-367.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.pontryagin_difference","page":"Concrete Operations","title":"LazySets.pontryagin_difference","text":"pontryagin_difference(P::LazySet{N}, Q::LazySet{N}) where {N<:Real}\n\nAn alias for the function minkowski_difference.\n\nNotes\n\nDue to inconsistent naming conventions, both the name Minkowski difference and Pontryagin difference are used to refer to the geometric difference of two sets.\n\n\n\n\n\n","category":"function"},{"location":"lib/binary_functions/#Subset-check","page":"Concrete Operations","title":"Subset check","text":"","category":"section"},{"location":"lib/binary_functions/","page":"Concrete Operations","title":"Concrete Operations","text":"⊆(::LazySet{N}, ::LazySet{N}, ::Bool=false) where {N<:Real}\n⊆(::LazySet{N}, ::AbstractHyperrectangle{N}, ::Bool=false) where {N<:Real}\n⊆(::AbstractPolytope{N}, ::LazySet{N}, ::Bool=false) where {N<:Real}\n⊆(::AbstractPolytope{N}, ::AbstractHyperrectangle, ::Bool=false) where {N<:Real}\n⊆(::AbstractHyperrectangle{N}, ::AbstractHyperrectangle{N}, ::Bool=false) where {N<:Real}\n⊆(::LazySet{N}, ::AbstractPolyhedron{N}, ::Bool=false) where {N<:Real}\n⊆(::AbstractSingleton{N}, ::LazySet{N}, ::Bool=false) where {N<:Real}\n⊆(::AbstractSingleton{N}, ::AbstractHyperrectangle{N}, ::Bool=false) where {N<:Real}\n⊆(::AbstractSingleton{N}, ::AbstractSingleton{N}, ::Bool=false) where {N<:Real}\n⊆(::Ball2{N}, ::Ball2{N}, ::Bool=false) where {N<:AbstractFloat}\n⊆(::Union{Ball2{N}, Ballp{N}}, ::AbstractSingleton{N}, ::Bool=false) where {N<:AbstractFloat}\n⊆(::LineSegment{N}, ::LazySet{N}, ::Bool=false) where {N<:Real}\n⊆(::LineSegment{N}, ::AbstractHyperrectangle{N}, ::Bool=false) where {N<:Real}\n⊆(::Interval, ::Interval)\n⊆(::EmptySet{N}, ::LazySet{N}, ::Bool=false) where {N<:Real}\n⊆(::LazySet{N}, ::EmptySet{N}, ::Bool=false) where {N<:Real}\n⊆(::UnionSet{N}, ::LazySet{N}, ::Bool=false) where {N<:Real}\n⊆(::UnionSetArray{N}, ::LazySet{N}, ::Bool=false) where {N<:Real}\n⊆(::LazySet{N}, ::Universe{N}, ::Bool=false) where {N<:Real}\n⊆(::Universe{N}, ::LazySet{N}, ::Bool=false) where {N<:Real}\n⊆(::LazySet{N}, ::Complement{N}, ::Bool=false) where {N<:Real}\n⊆(::CartesianProductArray{N}, ::CartesianProductArray{N}, ::Bool=false) where {N<:Real}","category":"page"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{LazySet{N},LazySet{N}}, Tuple{LazySet{N},LazySet{N},Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(X::LazySet{N}, P::LazySet{N}, [witness]::Bool=false) where {N<:Real}\n\nCheck whether a convex set is contained in a polyhedral set, and if not, optionally compute a witness.\n\nInput\n\nX       – inner convex set\nY       – outer polyhedral set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff X  P\nIf witness option is activated:\n(true, []) iff X  P\n(false, v) iff X  P and v  X setminus P\n\nNotes\n\nWe require that constraints_list(P) is available.\n\nAlgorithm\n\nWe check inclusion of X in every constraint of P.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{LazySet{N},AbstractHyperrectangle{N}}, Tuple{LazySet{N},AbstractHyperrectangle{N},Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(S::LazySet{N}, H::AbstractHyperrectangle{N}, [witness]::Bool=false\n ) where {N<:Real}\n\nCheck whether a convex set is contained in a hyperrectangular set, and if not, optionally compute a witness.\n\nInput\n\nS – inner convex set\nH – outer hyperrectangular set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff S  H\nIf witness option is activated:\n(true, []) iff S  H\n(false, v) iff S  H and v  S setminus H\n\nAlgorithm\n\nS  H iff operatornameihull(S)  H, where  operatornameihull is the interval hull operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{AbstractPolytope{N},LazySet{N}}, Tuple{AbstractPolytope{N},LazySet{N},Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(P::AbstractPolytope{N}, S::LazySet{N}, [witness]::Bool=false;\n  algorithm=_default_issubset(P, S)) where {N<:Real}\n\nCheck whether a polytope is contained in a convex set, and if not, optionally compute a witness.\n\nInput\n\nP – inner polytope\nS – outer convex set\nwitness   – (optional, default: false) compute a witness if activated\nalgorithm – (optional, default: \"constraints\" if the constraints list of S                is available, otherwise \"vertices\") algorithm for the inclusion                check; available options are:\n\"constraints\", using the list of constraints of P and support function evaluations of S\n\"vertices\", using the list of vertices of P and membership evaluations of S\n\nOutput\n\nIf witness option is deactivated: true iff P  S\nIf witness option is activated:\n(true, []) iff P  S\n(false, v) iff P  S and v  P setminus S\n\nAlgorithm\n\nSince S is convex, P  S iff v_i  S for all vertices v_i of P.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{AbstractPolytope{N},AbstractHyperrectangle}, Tuple{AbstractPolytope{N},AbstractHyperrectangle,Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(P::AbstractPolytope{N}, H::AbstractHyperrectangle, [witness]::Bool=false\n ) where {N<:Real}\n\nCheck whether a polytope is contained in a hyperrectangular set, and if not, optionally compute a witness.\n\nInput\n\nP – inner polytope\nH – outer hyperrectangular set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff P  H\nIf witness option is activated:\n(true, []) iff P  H\n(false, v) iff P  H and v  P setminus H\n\nNotes\n\nThis copy-pasted method just exists to avoid method ambiguities.\n\nAlgorithm\n\nSince H is convex, P  H iff v_i  H for all vertices v_i of P.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N}}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N},Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(H1::AbstractHyperrectangle{N},\n  H2::AbstractHyperrectangle{N},\n  [witness]::Bool=false\n ) where {N<:Real}\n\nCheck whether a given hyperrectangular set is contained in another hyperrectangular set, and if not, optionally compute a witness.\n\nInput\n\nH1 – inner hyperrectangular set\nH2 – outer hyperrectangular set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff H1  H2\nIf witness option is activated:\n(true, []) iff H1  H2\n(false, v) iff H1  H2 and v  H1 setminus H2\n\nAlgorithm\n\nH1  H2 iff c_1 + r_1  c_2 + r_2  c_1 - r_1  c_2 - r_2 iff r_1 - r_2  c_1 - c_2  -(r_1 - r_2), where  is taken component-wise.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{LazySet{N},AbstractPolyhedron{N}}, Tuple{LazySet{N},AbstractPolyhedron{N},Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(X::LazySet{N},\n  P::AbstractPolyhedron{N},\n  witness::Bool=false\n ) where {N<:Real}\n\nCheck whether a convex set is contained in a polyhedron, and if not, optionally compute a witness.\n\nInput\n\nX – inner convex set\nP – outer polyhedron (including a half-space)\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff X  P\nIf witness option is activated:\n(true, []) iff X  P\n(false, v) iff X  P and v  P setminus X\n\nAlgorithm\n\nSince X is convex, we can compare the support function of X and P in each direction of the constraints of P.\n\nFor witness generation, we use the support vector in the first direction where the above check fails.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{AbstractSingleton{N},LazySet{N}}, Tuple{AbstractSingleton{N},LazySet{N},Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(S::AbstractSingleton{N}, set::LazySet{N}, [witness]::Bool=false\n ) where {N<:Real}\n\nCheck whether a given set with a single value is contained in a convex set, and if not, optionally compute a witness.\n\nInput\n\nS   – inner set with a single value\nset – outer convex set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff S  textset\nIf witness option is activated:\n(true, []) iff S  textset\n(false, v) iff S  textset and v  S setminus textset\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{AbstractSingleton{N},AbstractHyperrectangle{N}}, Tuple{AbstractSingleton{N},AbstractHyperrectangle{N},Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(S::AbstractSingleton{N},\n  H::AbstractHyperrectangle{N},\n  [witness]::Bool=false\n ) where {N<:Real}\n\nCheck whether a given set with a single value is contained in a hyperrectangular set, and if not, optionally compute a witness.\n\nInput\n\nS – inner set with a single value\nH – outer hyperrectangular set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff S  H\nIf witness option is activated:\n(true, []) iff S  H\n(false, v) iff S  H and v  S setminus H\n\nNotes\n\nThis copy-pasted method just exists to avoid method ambiguities.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{AbstractSingleton{N},AbstractSingleton{N}}, Tuple{AbstractSingleton{N},AbstractSingleton{N},Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(S1::AbstractSingleton{N},\n  S2::AbstractSingleton{N},\n  [witness]::Bool=false\n ) where {N<:Real}\n\nCheck whether a given set with a single value is contained in another set with a single value, and if not, optionally compute a witness.\n\nInput\n\nS1 – inner set with a single value\nS2 – outer set with a single value\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff S1  S2 iff S1 == S2\nIf witness option is activated:\n(true, []) iff S1  S2\n(false, v) iff S1  S2 and v  S1 setminus S2\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{Ball2{N,VN} where VN<:AbstractArray{N,1},Ball2{N,VN} where VN<:AbstractArray{N,1}}, Tuple{Ball2{N,VN} where VN<:AbstractArray{N,1},Ball2{N,VN} where VN<:AbstractArray{N,1},Bool}} where N<:AbstractFloat","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(B1::Ball2{N}, B2::Ball2{N}, [witness]::Bool=false\n ) where {N<:AbstractFloat}\n\nCheck whether a ball in the 2-norm is contained in another ball in the 2-norm, and if not, optionally compute a witness.\n\nInput\n\nB1 – inner ball in the 2-norm\nB2 – outer ball in the 2-norm\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff B1  B2\nIf witness option is activated:\n(true, []) iff B1  B2\n(false, v) iff B1  B2 and v  B1 setminus B2\n\nAlgorithm\n\nB1  B2 iff  c_1 - c_2 _2 + r_1  r_2\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{Union{Ball2{N,VN} where VN<:AbstractArray{N,1}, Ballp{N,VN} where VN<:AbstractArray{N,1}},AbstractSingleton{N}}, Tuple{Union{Ball2{N,VN} where VN<:AbstractArray{N,1}, Ballp{N,VN} where VN<:AbstractArray{N,1}},AbstractSingleton{N},Bool}} where N<:AbstractFloat","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(B::Union{Ball2{N}, Ballp{N}},\n  S::AbstractSingleton{N},\n  [witness]::Bool=false\n ) where {N<:AbstractFloat}\n\nCheck whether a ball in the 2-norm or p-norm is contained in a set with a single value, and if not, optionally compute a witness.\n\nInput\n\nB – inner ball in the 2-norm or p-norm\nS – outer set with a single value\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff B  S\nIf witness option is activated:\n(true, []) iff B  S\n(false, v) iff B  S and v  B setminus S\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{LineSegment{N,VN} where VN<:AbstractArray{N,1},LazySet{N}}, Tuple{LineSegment{N,VN} where VN<:AbstractArray{N,1},LazySet{N},Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(L::LineSegment{N}, S::LazySet{N}, [witness]::Bool=false\n ) where {N<:Real}\n\nCheck whether a line segment is contained in a convex set, and if not, optionally compute a witness.\n\nInput\n\nL – inner line segment\nS – outer convex set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff L  S\nIf witness option is activated:\n(true, []) iff L  S\n(false, v) iff L  S and v  L setminus S\n\nAlgorithm\n\nSince S is convex, L  S iff p  S and q  S, where p q are the end points of L.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{LineSegment{N,VN} where VN<:AbstractArray{N,1},AbstractHyperrectangle{N}}, Tuple{LineSegment{N,VN} where VN<:AbstractArray{N,1},AbstractHyperrectangle{N},Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(L::LineSegment{N}, H::AbstractHyperrectangle{N}, [witness]::Bool=false\n ) where {N<:Real}\n\nCheck whether a line segment is contained in a hyperrectangular set, and if not, optionally compute a witness.\n\nInput\n\nL – inner line segment\nH – outer hyperrectangular set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff L  H\nIf witness option is activated:\n(true, []) iff L  H\n(false, v) iff L  H and v  L setminus H\n\nNotes\n\nThis copy-pasted method just exists to avoid method ambiguities.\n\nAlgorithm\n\nSince H is convex, L  H iff p  H and q  H, where p q are the end points of L.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Tuple{Interval,Interval}","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(x::Interval, y::Interval)\n\nCheck whether an interval is contained in another interval.\n\nInput\n\nx – interval\ny – interval\n\nOutput\n\ntrue iff x  y.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{EmptySet{N},LazySet{N}}, Tuple{EmptySet{N},LazySet{N},Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(∅::EmptySet{N}, X::LazySet{N}, [witness]::Bool=false\n ) where {N<:Real}\n\nCheck whether an empty set is contained in another set.\n\nInput\n\n∅       – empty set\nX       – another set\nwitness – (optional, default: false) compute a witness if activated              (ignored, just kept for interface reasons)\n\nOutput\n\ntrue.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{LazySet{N},EmptySet{N}}, Tuple{LazySet{N},EmptySet{N},Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(X::LazySet{N}, ∅::EmptySet{N}, [witness]::Bool=false\n ) where {N<:Real}\n\nCheck whether a set is contained in an empty set.\n\nInput\n\nX       – another set\n∅       – empty set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\ntrue iff X is empty.\n\nAlgorithm\n\nWe rely on isempty(X) for the emptiness check and on an_element(X) for witness production.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{UnionSet{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N},LazySet{N}}, Tuple{UnionSet{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N},LazySet{N},Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(cup::UnionSet{N}, X::LazySet{N}, [witness]::Bool=false\n ) where {N<:Real}\n\nCheck whether a union of two convex sets is contained in another set.\n\nInput\n\ncup     – union of two convex sets\nX       – another set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff textcup  X\nIf witness option is activated:\n(true, []) iff textcup  X\n(false, v) iff textcup notsubseteq X and v  textcup setminus X\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{UnionSetArray{N,S} where S<:LazySet{N},LazySet{N}}, Tuple{UnionSetArray{N,S} where S<:LazySet{N},LazySet{N},Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(cup::UnionSetArray{N}, X::LazySet{N}, [witness]::Bool=false\n ) where {N<:Real}\n\nCheck whether a union of a finite number of convex sets is contained in another set.\n\nInput\n\ncup     – union of a finite number of convex sets\nX       – another set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff textcup  X\nIf witness option is activated:\n(true, []) iff textcup  X\n(false, v) iff textcup notsubseteq X and v  textcup setminus X\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{LazySet{N},Universe{N}}, Tuple{LazySet{N},Universe{N},Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(X::LazySet{N}, U::Universe{N}, [witness]::Bool=false\n ) where {N<:Real}\n\nCheck whether a convex set is contained in a universe.\n\nInput\n\nU       – universe\nX       – convex set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true\nIf witness option is activated: (true, [])\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{Universe{N},LazySet{N}}, Tuple{Universe{N},LazySet{N},Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(U::Universe{N}, X::LazySet{N}, [witness]::Bool=false\n ) where {N<:Real}\n\nCheck whether a universe is contained in another convex set, and otherwise optionally compute a witness.\n\nInput\n\nU       – universe\nX       – convex set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff U  X\nIf witness option is activated:\n(true, []) iff U  X\n(false, v) iff U notsubseteq X and v  U setminus X\n\nAlgorithm\n\nWe fall back to isuniversal(X).\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{LazySet{N},Complement{N,S} where S<:LazySet{N}}, Tuple{LazySet{N},Complement{N,S} where S<:LazySet{N},Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(X::LazySet{N}, C::Complement{N}, [witness]::Bool=false\n ) where {N<:Real}\n\nCheck whether a convex set is contained in the complement of another convex set, and otherwise optionally compute a witness.\n\nInput\n\nX       – convex set\nC       – complement of a convex set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: true iff X  C\nIf witness option is activated:\n(true, []) iff X  C\n(false, v) iff X notsubseteq C and v  X setminus C\n\nAlgorithm\n\nWe fall back to isdisjoint(X, C.X), which can be justified as follows.\n\n    X  Y^C  X  Y = \n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Base.:⊆-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S<:LazySet{N},CartesianProductArray{N,S} where S<:LazySet{N}}, Tuple{CartesianProductArray{N,S} where S<:LazySet{N},CartesianProductArray{N,S} where S<:LazySet{N},Bool}} where N<:Real","page":"Concrete Operations","title":"Base.:⊆","text":"⊆(X::CartesianProductArray{N}, Y::CartesianProductArray{N},\n  witness::Bool=false; check_block_equality::Bool=true\n ) where {N<:Real}\n\nCheck whether a Cartesian product of finitely many convex sets is contained in another Cartesian product of finitely many convex sets, and otherwise optionally compute a witness.\n\nInput\n\nX       – Cartesian product of finitely many convex sets\nY       – Cartesian product of finitely many convex sets\nwitness – (optional, default: false) compute a witness if activated\ncheck_block_equality – (optional, default: true) flag for checking that              the block structure of the two sets is identical\n\nOutput\n\nIf witness option is deactivated: true iff X  Y\nIf witness option is activated:\n(true, []) iff X  Y\n(false, v) iff X notsubseteq Y and v  X setminus Y\n\nNotes\n\nThis algorithm requires that the two Cartesian products share the same block structure. Depending on the value of check_block_equality, we check this property.\n\nAlgorithm\n\nWe check for inclusion for each block of the Cartesian products.\n\nFor witness production, we obtain a witness in one of the blocks. We then construct a high-dimensional witness by obtaining any point in the other blocks (using an_element) and concatenating these points.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#Set-difference","page":"Concrete Operations","title":"Set difference","text":"","category":"section"},{"location":"lib/binary_functions/","page":"Concrete Operations","title":"Concrete Operations","text":"\\(::LazySet, ::LazySet)\ndifference(::IN, ::IN) where {N, IN<:Interval{N}}\ndifference(::AbstractHyperrectangle{N}, ::AbstractHyperrectangle{N}) where {N}","category":"page"},{"location":"lib/binary_functions/#Base.:\\-Tuple{LazySet,LazySet}","page":"Concrete Operations","title":"Base.:\\","text":"\\(X::LazySet, Y::LazySet)\n\nConvenience alias for set difference.\n\nInput\n\nX – a set\nY – another set\n\nOutput\n\nThe set difference between X and Y.\n\nNotes\n\nIf X and Y are intervals, X \\ Y is used in some libraries to denote the left division, as the example below shows. However, it should not be confused with the set difference. For example,\n\njulia> X = Interval(0, 2); Y = Interval(1, 4);\n\njulia> X \\ Y   # computing the set difference\nLazySets.Interval{Float64,IntervalArithmetic.Interval{Float64}}([0, 1])\n\njulia> X.dat \\ Y.dat  # computing the left division\n[0.5, ∞]\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.difference-Union{Tuple{IN}, Tuple{N}, Tuple{IN,IN}} where IN<:(Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}) where N","page":"Concrete Operations","title":"LazySets.difference","text":"difference(I1::IN, I2::IN) where {N, IN<:Interval{N}}\n\nReturn the set difference between the given intervals.\n\nThe set difference is defined as:\n\n    I₁ setminus I₂ = x x  I₁ text and  x  I₂ \n\nThe backslash symbol, \\, can be used as an alias.\n\nInput\n\nI1 – first interval\nI2 – second interval\n\nOutput\n\nDepending on the position of the intervals, the output is one of the following:\n\nAn EmptySet.\nAn Interval.\nA UnionSet of two Interval sets.\n\nAlgorithm\n\nLet I₁ = a b and I₂ = c d be intervals. Their set difference is I₁ setminus I₂ = x x  I₁ text and  x  I₂  and depending on their position three different results may occur:\n\nIf I₁ and I₂ do not overlap, i.e. if their intersection is empty, then the set difference is just I₁.\nOtherwise, let I₁₂ = I₁ ∩ I₂ and assume that it is not empty, then either I₁₂ splits I₁ into one interval or into two intervals. The latter case happens when the inclusion is strict on both ends of I₂.\n\nTo check for strict inclusion, we assume that the inclusion is strict and then check if the resulting intervals that cover I₁ (one to its left and one to its right, let them be Ileft and Iright), obtained by intersection with I₂, are flat or not. Three cases may arise:\n\nIf both Ileft and Iright are flat then it means that I₁ = I₂, then the set difference is the empty set.\nIf only Ileft is flat, then the remaining interval not covered by I₂ is Iright. In a similar manner, if only Iright is flat, then Ileft is returned.\nFinally, if none of the intervals is flat, then I₂ is strictly contained in I₁ and the set union of Ileft and Iright is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/binary_functions/#LazySets.difference-Union{Tuple{N}, Tuple{AbstractHyperrectangle{N},AbstractHyperrectangle{N}}} where N","page":"Concrete Operations","title":"LazySets.difference","text":"difference(X::AbstractHyperrectangle{N}, Y::AbstractHyperrectangle{N}) where {N}\n\nReturn the set difference between the given hyperrectangular sets.\n\nInput\n\nX – first hyperrectangular set\nY – second hyperrectangular set\n\nThe set difference is defined as:\n\n    X setminus Y = x x  X text and  x  Y \n\nOutput\n\nA UnionSetArray consisting of the union of hyperrectangles. Note that this union is in general not convex.\n\nAlgorithm\n\nThis function calls the implementation in IntervalArithmetic.setdiff.\n\nNotes\n\nThe backslash symbol, \\, can be used as an alias.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/","page":"CartesianProduct","title":"CartesianProduct","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/lazy_operations/CartesianProduct/#Cartesian-product","page":"CartesianProduct","title":"Cartesian product","text":"","category":"section"},{"location":"lib/lazy_operations/CartesianProduct/#def_CartesianProduct","page":"CartesianProduct","title":"Binary Cartesian product (CartesianProduct)","text":"","category":"section"},{"location":"lib/lazy_operations/CartesianProduct/","page":"CartesianProduct","title":"CartesianProduct","text":"CartesianProduct\n×(::LazySet, ::LazySet)\n*(::LazySet, ::LazySet)\nswap(::CartesianProduct)\ndim(::CartesianProduct)\nρ(::AbstractVector{N}, ::CartesianProduct{N}) where {N<:Real}\nσ(::AbstractVector{N}, ::CartesianProduct{N}) where {N<:Real}\nisbounded(::CartesianProduct)\n∈(::AbstractVector{N}, ::CartesianProduct{N}) where {N<:Real}\nisempty(::CartesianProduct)\nconstraints_list(::CartesianProduct{N}) where {N<:Real}\nvertices_list(::CartesianProduct{N}) where {N<:Real}\nlinear_map(M::AbstractMatrix{N}, cp::CartesianProduct{N}) where {N<:Real}","category":"page"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.CartesianProduct","page":"CartesianProduct","title":"LazySets.CartesianProduct","text":"CartesianProduct{N<:Real, S1<:LazySet{N}, S2<:LazySet{N}} <: LazySet{N}\n\nType that represents a Cartesian product of two convex sets.\n\nFields\n\nX – first convex set\nY – second convex set\n\nNotes\n\nThe Cartesian product of three elements is obtained recursively. See also CartesianProductArray for an implementation of a Cartesian product of many sets without recursion, instead using an array.\n\nThe EmptySet is the absorbing element for CartesianProduct.\n\nExamples\n\nThe Cartesian product between two sets X and Y can be constructed either using CartesianProduct(X, Y) or the short-cut notation X × Y:\n\njulia> I1 = Interval(0, 1);\n\njulia> I2 = Interval(2, 4);\n\njulia> I12 = I1 × I2;\n\njulia> typeof(I12)\nCartesianProduct{Float64,Interval{Float64,IntervalArithmetic.Interval{Float64}},Interval{Float64,IntervalArithmetic.Interval{Float64}}}\n\nA hyperrectangle is the cartesian product of intervals, so we can convert I12 exactly to a Hyperrectangle type:\n\njulia> convert(Hyperrectangle, I12)\nHyperrectangle{Float64,Array{Float64,1},Array{Float64,1}}([0.5, 3.0], [0.5, 1.0])\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/CartesianProduct/#LinearAlgebra.:×-Tuple{LazySet,LazySet}","page":"CartesianProduct","title":"LinearAlgebra.:×","text":"×\n\nAlias for the binary Cartesian product.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#Base.:*-Tuple{LazySet,LazySet}","page":"CartesianProduct","title":"Base.:*","text":"    *(X::LazySet, Y::LazySet)\n\nAlias for the binary Cartesian product.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.swap-Tuple{CartesianProduct}","page":"CartesianProduct","title":"LazySets.swap","text":"swap(cp::CartesianProduct)\n\nReturn a new CartesianProduct object with the arguments swapped.\n\nInput\n\ncp – Cartesian product of two convex sets\n\nOutput\n\nA new CartesianProduct object with the arguments swapped.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.dim-Tuple{CartesianProduct}","page":"CartesianProduct","title":"LazySets.dim","text":"dim(cp::CartesianProduct)\n\nReturn the dimension of a Cartesian product.\n\nInput\n\ncp – Cartesian product\n\nOutput\n\nThe ambient dimension of the Cartesian product.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}} where N<:Real","page":"CartesianProduct","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, cp::CartesianProduct{N}) where {N<:Real}\n\nReturn the support function of a Cartesian product.\n\nInput\n\nd  – direction\ncp – Cartesian product\n\nOutput\n\nThe support function in the given direction. If the direction has norm zero, the result depends on the wrapped sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}} where N<:Real","page":"CartesianProduct","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, cp::CartesianProduct{N}) where {N<:Real}\n\nReturn the support vector of a Cartesian product.\n\nInput\n\nd  – direction\ncp – Cartesian product\n\nOutput\n\nThe support vector in the given direction. If the direction has norm zero, the result depends on the wrapped sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.isbounded-Tuple{CartesianProduct}","page":"CartesianProduct","title":"LazySets.isbounded","text":"isbounded(cp::CartesianProduct)\n\nDetermine whether a Cartesian product is bounded.\n\nInput\n\ncp – Cartesian product\n\nOutput\n\ntrue iff both wrapped sets are bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}} where N<:Real","page":"CartesianProduct","title":"Base.:∈","text":"∈(x::AbstractVector{N}, cp::CartesianProduct{N}) where {N<:Real}\n\nCheck whether a given point is contained in a Cartesian product.\n\nInput\n\nx  – point/vector\ncp – Cartesian product\n\nOutput\n\ntrue iff x  cp.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#Base.isempty-Tuple{CartesianProduct}","page":"CartesianProduct","title":"Base.isempty","text":"isempty(cp::CartesianProduct)\n\nReturn if a Cartesian product is empty or not.\n\nInput\n\ncp – Cartesian product\n\nOutput\n\ntrue iff any of the sub-blocks is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.constraints_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}, Tuple{N}} where N<:Real","page":"CartesianProduct","title":"LazySets.constraints_list","text":"constraints_list(cp::CartesianProduct{N}) where {N<:Real}\n\nReturn the list of constraints of a (polyhedral) Cartesian product.\n\nInput\n\ncp – Cartesian product\n\nOutput\n\nA list of constraints.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.vertices_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}, Tuple{N}} where N<:Real","page":"CartesianProduct","title":"LazySets.vertices_list","text":"vertices_list(cp::CartesianProduct{N}) where {N<:Real}\n\nReturn the list of vertices of a (polytopic) Cartesian product.\n\nInput\n\ncp – Cartesian product\n\nOutput\n\nA list of vertices.\n\nAlgorithm\n\nWe assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},CartesianProduct{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}} where N<:Real","page":"CartesianProduct","title":"LazySets.linear_map","text":"linear_map(M::AbstractMatrix{N}, cp::CartesianProduct{N}) where {N<:Real}\n\nConcrete linear map of a (polyhedral) Cartesian product.\n\nInput\n\nM  – matrix\ncp – Cartesian product of two convex sets\n\nOutput\n\nA polytope if cp is bounded and a polyhedron otherwise.\n\nAlgorithm\n\nWe convert the Cartesian product to constraint representation and then call linear_map on the corresponding polyhedron.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/","page":"CartesianProduct","title":"CartesianProduct","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/CartesianProduct/","page":"CartesianProduct","title":"CartesianProduct","text":"norm\nradius\ndiameter\nan_element","category":"page"},{"location":"lib/lazy_operations/CartesianProduct/#def_CartesianProductArray","page":"CartesianProduct","title":"n-ary Cartesian product (CartesianProductArray)","text":"","category":"section"},{"location":"lib/lazy_operations/CartesianProduct/","page":"CartesianProduct","title":"CartesianProduct","text":"CartesianProductArray\ndim(::CartesianProductArray)\nρ(::AbstractVector{N}, ::CartesianProductArray{N}) where {N<:Real}\nσ(::AbstractVector{N}, ::CartesianProductArray{N}) where {N<:Real}\nisbounded(::CartesianProductArray)\n∈(::AbstractVector{N}, ::CartesianProductArray{N}) where {N<:Real}\nisempty(::CartesianProductArray)\nconstraints_list(::CartesianProductArray{N}) where {N<:Real}\nvertices_list(::CartesianProductArray{N}) where {N<:Real}\nlinear_map(M::AbstractMatrix{N}, cpa::CartesianProductArray{N}) where {N<:Real}\narray(::CartesianProductArray{N, S}) where {N<:Real, S<:LazySet{N}}\nblock_structure(cpa::CartesianProductArray{N}) where {N}\nblock_to_dimension_indices(cpa::CartesianProductArray{N}, vars::Vector{Int}) where {N}\nsubstitute_blocks(low_dim_cpa::CartesianProductArray{N}, orig_cpa::CartesianProductArray{N},\nblocks::Vector{Tuple{Int,Int}}) where {N}","category":"page"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.CartesianProductArray","page":"CartesianProduct","title":"LazySets.CartesianProductArray","text":"CartesianProductArray{N<:Real, S<:LazySet{N}} <: LazySet{N}\n\nType that represents the Cartesian product of a finite number of convex sets.\n\nFields\n\narray – array of sets\n\nNotes\n\nThe EmptySet is the absorbing element for CartesianProductArray.\n\nConstructors:\n\nCartesianProductArray(array::Vector{<:LazySet}) – default constructor\nCartesianProductArray([n]::Int=0, [N]::Type=Float64)\n\n– constructor for an empty product with optional size hint and numeric type\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.dim-Tuple{CartesianProductArray}","page":"CartesianProduct","title":"LazySets.dim","text":"dim(cpa::CartesianProductArray)\n\nReturn the dimension of a Cartesian product of a finite number of convex sets.\n\nInput\n\ncpa – Cartesian product array\n\nOutput\n\nThe ambient dimension of the Cartesian product of a finite number of convex sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S<:LazySet{N}}} where N<:Real","page":"CartesianProduct","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, cp::CartesianProductArray{N}) where {N<:Real}\n\nReturn the support function of a Cartesian product array.\n\nInput\n\nd   – direction\ncpa – Cartesian product array\n\nOutput\n\nThe support function in the given direction. If the direction has norm zero, the result depends on the wrapped sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S<:LazySet{N}}} where N<:Real","page":"CartesianProduct","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, cpa::CartesianProductArray{N}) where {N<:Real}\n\nSupport vector of a Cartesian product array.\n\nInput\n\nd   – direction\ncpa – Cartesian product array\n\nOutput\n\nThe support vector in the given direction. If the direction has norm zero, the result depends on the product sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.isbounded-Tuple{CartesianProductArray}","page":"CartesianProduct","title":"LazySets.isbounded","text":"isbounded(cpa::CartesianProductArray)\n\nDetermine whether a Cartesian product of a finite number of convex sets is bounded.\n\nInput\n\ncpa – Cartesian product of a finite number of convex sets\n\nOutput\n\ntrue iff all wrapped sets are bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S<:LazySet{N}}} where N<:Real","page":"CartesianProduct","title":"Base.:∈","text":"∈(x::AbstractVector{N}, cpa::CartesianProductArray{N}) where {N<:Real}\n\nCheck whether a given point is contained in a Cartesian product of a finite number of sets.\n\nInput\n\nx   – point/vector\ncpa – Cartesian product array\n\nOutput\n\ntrue iff x  textcpa.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#Base.isempty-Tuple{CartesianProductArray}","page":"CartesianProduct","title":"Base.isempty","text":"isempty(cpa::CartesianProductArray)\n\nReturn if a Cartesian product is empty or not.\n\nInput\n\ncp – Cartesian product\n\nOutput\n\ntrue iff any of the sub-blocks is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.constraints_list-Union{Tuple{CartesianProductArray{N,S} where S<:LazySet{N}}, Tuple{N}} where N<:Real","page":"CartesianProduct","title":"LazySets.constraints_list","text":"constraints_list(cpa::CartesianProductArray{N}) where {N<:Real}\n\nReturn the list of constraints of a (polyhedral) Cartesian product of a finite number of sets.\n\nInput\n\ncpa – Cartesian product array\n\nOutput\n\nA list of constraints.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.vertices_list-Union{Tuple{CartesianProductArray{N,S} where S<:LazySet{N}}, Tuple{N}} where N<:Real","page":"CartesianProduct","title":"LazySets.vertices_list","text":"vertices_list(cpa::CartesianProductArray{N}) where {N<:Real}\n\nReturn the list of vertices of a (polytopic) Cartesian product of a finite number of sets.\n\nInput\n\ncpa – Cartesian product array\n\nOutput\n\nA list of vertices.\n\nAlgorithm\n\nWe assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},CartesianProductArray{N,S} where S<:LazySet{N}}} where N<:Real","page":"CartesianProduct","title":"LazySets.linear_map","text":"linear_map(M::AbstractMatrix{N}, cpa::CartesianProductArray{N}              ) where {N<:Real}\n\nConcrete linear map of a Cartesian product of a finite number of convex sets.\n\nInput\n\nM   – matrix\ncpa – Cartesian product of a finite number of convex sets\n\nOutput\n\nA polytope.\n\nAlgorithm\n\nWe check if the matrix is invertible. If so, we convert the Cartesian product to constraint representation. Otherwise, we convert the Cartesian product to vertex representation. In both cases, we then call linear_map on the resulting polytope.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.array-Union{Tuple{CartesianProductArray{N,S}}, Tuple{S}, Tuple{N}} where S<:LazySet{N} where N<:Real","page":"CartesianProduct","title":"LazySets.array","text":"array(cpa::CartesianProductArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a Cartesian product of a finite number of convex sets.\n\nInput\n\ncpa – Cartesian product array\n\nOutput\n\nThe array of a Cartesian product of a finite number of convex sets.\n\n\n\n\n\narray(cha::ConvexHullArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a convex hull of a finite number of convex sets.\n\nInput\n\ncha – convex hull array\n\nOutput\n\nThe array of a convex hull of a finite number of convex sets.\n\n\n\n\n\narray(ia::IntersectionArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of an intersection of a finite number of convex sets.\n\nInput\n\nia – intersection of a finite number of convex sets\n\nOutput\n\nThe array of an intersection of a finite number of convex sets.\n\n\n\n\n\narray(msa::MinkowskiSumArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a Minkowski sum of a finite number of convex sets.\n\nInput\n\nmsa – Minkowski sum array\n\nOutput\n\nThe array of a Minkowski sum of a finite number of convex sets.\n\n\n\n\n\narray(cms::CachedMinkowskiSumArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a caching Minkowski sum.\n\nInput\n\ncms – caching Minkowski sum\n\nOutput\n\nThe array of a caching Minkowski sum.\n\n\n\n\n\narray(cup::UnionSetArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a union of a finite number of convex sets.\n\nInput\n\ncup – union of a finite number of convex sets\n\nOutput\n\nThe array that holds the union of a finite number of convex sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.block_structure-Union{Tuple{CartesianProductArray{N,S} where S<:LazySet{N}}, Tuple{N}} where N","page":"CartesianProduct","title":"LazySets.block_structure","text":"block_structure(cpa::CartesianProductArray{N}) where {N}\n\nReturns an array containing the dimension ranges of each block in a CartesianProductArray.\n\nInput\n\ncpa – Cartesian product array\n\nOutput\n\nA vector of ranges\n\nExample\n\njulia> using LazySets: block_structure\n\njulia> cpa = CartesianProductArray([BallInf(zeros(n), 1.0) for n in [3, 1, 2]]);\n\njulia> block_structure(cpa)\n3-element Array{UnitRange{Int64},1}:\n 1:3\n 4:4\n 5:6\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.block_to_dimension_indices-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S<:LazySet{N},Array{Int64,1}}} where N","page":"CartesianProduct","title":"LazySets.block_to_dimension_indices","text":"blocktodimension_indices(cpa::CartesianProductArray{N}, vars::Vector{Int}) where {N}\n\nReturns a vector mapping block index i to tuple (f, l) such that either f = l = -1 or f is the first dimension index and l is the last dimension index of the i-th block, depending on whether one of the block's dimension indices is specified in vars.\n\nInput\n\ncpa – Cartesian product array\nvars – list containing the variables of interest, sorted in ascending order\n\nOutput\n\n(i) A vector of tuples, where values in tuple relate to range of dimensions in the i-th block. (ii) Number of constrained blocks\n\nExample\n\njulia> using LazySets: block_to_dimension_indices\n\njulia> cpa = CartesianProductArray([BallInf(zeros(n), 1.0) for n in [1, 3, 2, 3]]);\n\njulia> m, k = block_to_dimension_indices(cpa, [2, 4, 8]);\n\njulia> m\n4-element Array{Tuple{Int64,Int64},1}:\n (-1, -1)\n (2, 4)\n (-1, -1)\n (7, 9)\n\njulia> k\n2\n\nThis vector represents the mapping \"second block from dimension 2 to dimension 4, fourth block from dimension 7 to dimension 9.\" These blocks contain the dimensions specified in [2, 4, 8]. Number of constrained variables here is 2 (2nd and 4th blocks)\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/#LazySets.substitute_blocks-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S<:LazySet{N},CartesianProductArray{N,S} where S<:LazySet{N},Array{Tuple{Int64,Int64},1}}} where N","page":"CartesianProduct","title":"LazySets.substitute_blocks","text":"substituteblocks(lowdimcpa::CartesianProductArray{N},                         origcpa::CartesianProductArray{N},                           blocks::Vector{Tuple{Int,Int}}) where {N}\n\nReturn merged Cartesian Product Array between original CPA and some low-dimensional CPA, which represents updated subset of variables in specified blocks.\n\nInput\n\nlow_dim_cpa – low-dimensional cartesian product array\norig_cpa – original high-dimensional Cartesian product array\nblocks – index of the first variable in each block of orig_cpa\n\nOutput\n\nMerged cartesian product array\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/CartesianProduct/","page":"CartesianProduct","title":"CartesianProduct","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/CartesianProduct/","page":"CartesianProduct","title":"CartesianProduct","text":"norm\nradius\ndiameter\nan_element","category":"page"},{"location":"man/concrete_polyhedra/#Concrete-Polyhedra","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"","category":"section"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"The focus of LazySets.jl is to wrap set representations and operations into specialized types, delaying the evaluation of the result of an expression until it is necessary. However, sometimes it is desirable to perform an explicit computation. For concrete operations with polyhedra we rely on the polyhedra manipulation library Polyhedra.jl.","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"Polyhedra.jl provides a unified interface to well-known implementations of polyhedral computations (which we also call backends) such as CDD or LRS. See the complete list in the documentation of Polyhedra.jl. This is a great advantage because we can easily use a library that supports floating point arithmetic, rational arithmetic, multiple precision, etc. The libraries also include projection and elimination of variables through Fourier-Motzkin. If you are interested in specific numeric types different from the default Float64, such as Float32, these may not be supported by the backend, in which case Julia may automatically promote to, e.g., Float64. As an example, CDD (which is used via the wrapper package CDDLib.jl) can only be used with numeric type Float64 for floating-point arithmetic and with numeric type Rational{BigInt} for exact arithmetic.","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"Below we give examples of operations that are performed using Polyhedra.jl.","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"Pages = [\"concrete_polyhedra.md\"]\nDepth = 3","category":"page"},{"location":"man/concrete_polyhedra/#Creating-polyhedra","page":"Concrete Polyhedra","title":"Creating polyhedra","text":"","category":"section"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"To use the Polyhedra.jl interface, you need to load the package with using Polyhedra. Let's create an H-representation object:","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"using Plots, LazySets, Polyhedra, LinearAlgebra\n\nA = [1. 1;1 -1;-1 0]\nb = [1.,0,0]\nH = Polyhedra.hrep(A, b)","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"It is used to instantiate a new polyhedron:","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"p = polyhedron(H)","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"Now, p is of the generic type Polyhedra.SimplePolyhedron{2,Float64, ...}, where 2 states for its ambient dimension, and Float64 the numeric field. The remaining fields specify the type of representation:","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"typeof(p)","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"Observe that we can use a particular backend, such as the CDD library:","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"using CDDLib\n\np = polyhedron(H, CDDLib.Library())","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"On the other hand, a LazySets.HPolytope object can be constructed from p:","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"x = HPolytope(p)\nx.constraints","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"Conversely, from a HPolytope we can build a polyhedron:","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"y = polyhedron(x)\ntypeof(y)","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"Moreover, you can specify the backend with an extra argument. For instance, we can use an exact representation through the Library(:exact):","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"A, b = Rational{Int}[1 1;1 -1;-1 0], Rational{Int}[1,0,0]\np = HPolytope(A, b)\n\npolyhedron(p; backend=CDDLib.Library(:exact))","category":"page"},{"location":"man/concrete_polyhedra/#Methods","page":"Concrete Polyhedra","title":"Methods","text":"","category":"section"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"The utility methods available are convex hull, intersection and cartesian product. The dual representation as a list of vertices can be obtained with the vertices_list function.","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"p = HPolytope([LinearConstraint([1.0, 0.0], 1.0),\n               LinearConstraint([0.0, 1.0], 1.0),\n               LinearConstraint([-1.0, 0.0], 1.0),\n               LinearConstraint([0.0, -1.0], 1.0)])\n\nconstraints_list(p)","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"vertices_list(p)","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"For example, the concrete intersection of two polytopes is performed with the intersection method.","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"E = Ellipsoid(ones(2), Diagonal([2.0, 0.5]))\nB = Ball1([2.5, 1.5], .8)\n\nimport LazySets.Approximations.overapproximate\npolyoverapprox(x) = HPolytope(overapproximate(x, 1e-3).constraints)\n\nEpoly = polyoverapprox(E)\nBpoly = polyoverapprox(B)\nX = intersection(Epoly, Bpoly)\n\nplot(E, 1e-3, aspectratio=1, alpha=0.4)\nplot!(B, 1e-3, alpha=0.4)\nplot!(X, 1e-3, alpha=0.4, color=\"black\")","category":"page"},{"location":"man/concrete_polyhedra/#Projections","page":"Concrete Polyhedra","title":"Projections","text":"","category":"section"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"Projection of high-dimensional polyhedra and elimination of variables can be performed with the eliminate function, which supports three types of methods: :FourierMotzkin, :BlockElimination and :ProjectGenerators.","category":"page"},{"location":"man/concrete_polyhedra/","page":"Concrete Polyhedra","title":"Concrete Polyhedra","text":"For further details, see the documentation of Polyhedra.jl.","category":"page"},{"location":"man/parallel_approximations/#Parallel-Approximations","page":"Parallel Approximations","title":"Parallel Approximations","text":"","category":"section"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"A subset of the approximation algorithms are implemented in parallel in the  LazySets.Parallel module. In order to use parallel versions of the algorithms, you can write:","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"using LazySets\nimport LazySets.Parallel\n\n# call a method implemented in parallel, for example:\nS = Ball2(ones(100), 1.0)\nParallel.box_approximation(S)","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"Note that after importing or using LazySets.Parallel, the version of the function used must be fully qualified, eg. LazySets.Approximations.box_approximation for the sequential version or LazySets.Parallel.box_approximation for the parallel version.","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"The parallelization strategy that is available uses processes. To set the number of processes N, use the flag -p N at julia startup. For example, do","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"$ julia -p 4","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"to launch 4 additional local worker julia processes. Use the keyword auto, as in","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"$ julia -p auto","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"to launch as many workers as the number of local CPU cores.","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"Pages = [\"parallel_approximations.md\"]\nDepth = 3","category":"page"},{"location":"man/parallel_approximations/#Parallel-interval-hulls","page":"Parallel Approximations","title":"Parallel interval hulls","text":"","category":"section"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"As an illustration of the symmetric interval hull approximation of a nested lazy set computed in parallel, consider the following calculation. It arises in the discretization of set-based ODEs, and is defined below for an artificial example of a tridiagonal matrix of order n, where n is a positive integer.","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"using LazySets, Expokit\nusing SparseArrays, LinearAlgebra\n\n# define an nxn tridiagonal matrix\nA(n) = sparse(diagm(0 => fill(0.05, n), -1 => fill(-1, n-1), 1 => fill(-1, n-1)))\n\n# step size and initial set\nδ = 0.1\nX0(n) = Ball2(ones(n), 0.1)\n\n# input coefficients matrix (nx2 matrix with coefficients from -1 to 1)\nb(n) = vcat(range(-1, stop=1, length=n))\nB(n) = [b(n) b(n)] \nU = BallInf(zeros(2), 1.2)\n\n# lazy matrix exponential\neAδ(n) = SparseMatrixExp(A(n) * δ)\n\n# set that we want to overapproximate with an interval hull\nY(n) = ConvexHull(eAδ(n) * X0(n) ⊕ (δ * B(n) * U), X0(n))","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"The set Y(n) is parametric in the system's dimension n, to facilitate benchmarking. We will explore the computational cost as the dimension n increases, and compare the sequential algorithm with the parallel algorithm.","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"Given the lazy set Y(n), we want to calculate the symmetric interval hull, which corresponds to finding the smallest n-dimensional hyperrectangle that contains the set Y(n) and is symmetric with respect to the origin. Notice that this operation is inherently parallel, since one can evaluate the support function of Y independently in each dimension from 1 to n.","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"The sequential algorithm returns the following execution times. We use the @btime macro from the BenchmarkTools package to have a more accurate timing than @time; the $n argument is used for interpolation of the arguments (if you are not behchmarking, pass n to symmetric_interval_hull, as usual).","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"using BenchmarkTools\n\nfor n in [50, 100, 500, 1000]\n    @btime res = Approximations.symmetric_interval_hull(Y($n));\nend\n\n  59.103 ms (11554 allocations: 25.89 MiB)\n  129.453 ms (23118 allocations: 54.16 MiB)\n  1.943 s (115530 allocations: 381.26 MiB)\n  10.017 s (232506 allocations: 1.01 GiB)","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"For the parallel benchmark, we start Julia with 4 processes with the command $ julia -p 4 and call LazySets.Parallel.symmetric_interval_hull(Y(n)). ","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"import LazySets.Parallel\n\nfor n in [50, 100, 500, 1000]\n    @btime LazySets.Parallel.symmetric_interval_hull($Y($n));\nend\n\n  6.846 ms (2550 allocations: 160.59 KiB)\n  13.544 ms (3528 allocations: 271.94 KiB)\n  387.556 ms (11155 allocations: 2.51 MiB)\n  2.638 s (22156 allocations: 8.77 MiB)","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"In the following table we summarize the speedup.","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"n Sequential (s) Parallel p=4 (s) Speedup\n50 0.059 0.007 8.42\n100 0.129 0.013 9.92\n500 1.94 0.387 4.96\n1000 10.0 2.64 3.79","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"The results in this section were obtained with a standard MacBook Pro laptop with the following specifications:","category":"page"},{"location":"man/parallel_approximations/","page":"Parallel Approximations","title":"Parallel Approximations","text":"julia> versioninfo()\nJulia Version 1.0.2\nCommit d789231e99 (2018-11-08 20:11 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin14.5.0)\n  CPU: Intel(R) Core(TM) i7-4770HQ CPU @ 2.20GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-6.0.0 (ORCJIT, haswell)","category":"page"},{"location":"lib/lazy_operations/Translation/","page":"Translation","title":"Translation","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/lazy_operations/Translation/#def_Translation","page":"Translation","title":"Translation","text":"","category":"section"},{"location":"lib/lazy_operations/Translation/","page":"Translation","title":"Translation","text":"Translation\n+(X::LazySet, v::AbstractVector)\n⊕(X::LazySet, v::AbstractVector)\nρ(::AbstractVector{N}, ::Translation{N}) where {N<:Real}\nσ(::AbstractVector{N}, ::Translation{N}) where {N<:Real}\nan_element(::Translation)\nconstraints_list(::Translation{N}) where {N<:Real}\nlinear_map(::AbstractMatrix{N}, ::Translation{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::Translation{N}) where {N<:Real}","category":"page"},{"location":"lib/lazy_operations/Translation/#LazySets.Translation","page":"Translation","title":"LazySets.Translation","text":"Translation{N<:Real, VN<:AbstractVector{N},\n            S<:LazySet{N}} <: AbstractAffineMap{N, S}\n\nType that represents a lazy translation.\n\nThe translation of set X along vector v is the map:\n\nx  x + vqquad x  X\n\nA translation is a special case of an affine map A x + b x  X where the linear map A is the identity matrix and the translation vector b = v.\n\nFields\n\nX – convex set\nv – vector that defines the translation\n\nExample\n\njulia> X = BallInf([2.0, 2.0, 2.0], 1.0);\n\njulia> v = [1.0, 0.0, 0.0]; # translation along dimension 1\n\njulia> tr = Translation(X, v);\n\njulia> typeof(tr)\nTranslation{Float64,Array{Float64,1},BallInf{Float64,Array{Float64,1}}}\n\njulia> tr.X\nBallInf{Float64,Array{Float64,1}}([2.0, 2.0, 2.0], 1.0)\n\njulia> tr.v\n3-element Array{Float64,1}:\n 1.0\n 0.0\n 0.0\n\nThe sum operator + is overloaded to create translations:\n\njulia> X + v == Translation(X, v)\ntrue\n\nAnd so does the Minkowski sum operator, ⊕:\n\njulia> X ⊕ v == Translation(X, v)\ntrue\n\nThe translation of a translation is performed immediately:\n\njulia> tr = (X+v)+v\nTranslation{Float64,Array{Float64,1},BallInf{Float64,Array{Float64,1}}}(BallInf{Float64,Array{Float64,1}}([2.0, 2.0, 2.0], 1.0), [2.0, 0.0, 0.0])\n\njulia> tr.v\n3-element Array{Float64,1}:\n 2.0\n 0.0\n 0.0\n\nThe dimension of a translation is obtained with the dim function:\n\njulia> dim(tr)\n3\n\nFor the support vector (resp. support function) along vector d, use σ and ρ respectively:\n\njulia> σ([1.0, 0.0, 0.0], tr)\n3-element Array{Float64,1}:\n 5.0\n 3.0\n 3.0\n\njulia> ρ([1.0, 0.0, 0.0], tr)\n5.0\n\nSee the docstring of each of these functions for details.\n\nThe an_element function is useful to obtain an element of a translation:\n\njulia> e = an_element(tr)\n3-element Array{Float64,1}:\n 4.0\n 2.0\n 2.0\n\nThe lazy linear map of a translation is an affine map, since the following simplification rule applies: M * (X  v) = (M * X)  (M * v):\n\njulia> using LinearAlgebra: I\n\njulia> M = Matrix(2.0I, 3, 3);\n\njulia> Q = M * tr;\n\njulia> Q isa AffineMap && Q.M == M && Q.X == tr.X && Q.v == 2 * tr.v\ntrue\n\nUse the isempty method to query if the translation is empty; it falls back to the isempty method of the wrapped set:\n\njulia> isempty(tr)\nfalse\n\nThe list of constraints of the translation of a polyhedron (in general, a set whose constraints_list is available) can be computed from a lazy translation:\n\njulia> constraints_list(tr)\n6-element Array{HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}},1}:\n HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([1.0, 0.0, 0.0], 5.0)\n HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([0.0, 1.0, 0.0], 3.0)\n HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([0.0, 0.0, 1.0], 3.0)\n HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([-1.0, 0.0, 0.0], -3.0)\n HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([0.0, -1.0, 0.0], -1.0)\n HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([0.0, 0.0, -1.0], -1.0)\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/Translation/#Base.:+-Tuple{LazySet,AbstractArray{T,1} where T}","page":"Translation","title":"Base.:+","text":"+(X::LazySet, v::AbstractVector)\n\nConvenience constructor for a translation.\n\nInput\n\nX – convex set\nv – vector\n\nOutput\n\nThe symbolic translation of X along vector v.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Translation/#LazySets.:⊕-Tuple{LazySet,AbstractArray{T,1} where T}","page":"Translation","title":"LazySets.:⊕","text":"⊕(X::LazySet, v::AbstractVector)\n\nUnicode alias constructor ⊕ (oplus) for the lazy translation operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Translation/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Translation{N,VN,S} where S<:LazySet{N} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Translation","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, tr::Translation{N}) where {N<:Real}\n\nReturn the support function of a translation.\n\nInput\n\nd  – direction\ntr – translation\n\nOutput\n\nThe support function in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Translation/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Translation{N,VN,S} where S<:LazySet{N} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Translation","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, tr::Translation{N}) where {N<:Real}\n\nReturn the support vector of a translation.\n\nInput\n\nd  – direction\ntr – translation\n\nOutput\n\nThe support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Translation/#LazySets.an_element-Tuple{Translation}","page":"Translation","title":"LazySets.an_element","text":"an_element(tr::Translation)\n\nReturn some element of a translation.\n\nInput\n\ntr – translation\n\nOutput\n\nAn element in the translation.\n\nNotes\n\nThis function first asks for an_element function of the wrapped set, then translates this element according to the given translation vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Translation/#LazySets.constraints_list-Union{Tuple{Translation{N,VN,S} where S<:LazySet{N} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"Translation","title":"LazySets.constraints_list","text":"constraints_list(tr::Translation{N}) where {N<:Real}\n\nReturn the list of constraints of the translation of a set.\n\nInput\n\ntr – lazy translation of a polyhedron\n\nOutput\n\nThe list of constraints of the translation.\n\nNotes\n\nWe assume that the set wrapped by the lazy translation X offers a method constraints_list(⋅).\n\nAlgorithm\n\nLet the translation be defined by the set of points y such that y = x + v for all x ∈ X. Then, each defining halfspace a⋅x ≤ b is transformed to a⋅y ≤ b + a⋅v.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Translation/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},Translation{N,VN,S} where S<:LazySet{N} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Translation","title":"LazySets.linear_map","text":"linear_map(M::AbstractMatrix{N}, tr::Translation{N}) where {N<:Real}\n\nConcrete linear map of a polyhedron in constraint representation.\n\nInput\n\nM  – matrix\ntr – translation of a convex set\n\nOutput\n\nA concrete set corresponding to the linear map. The type of the result depends on the type of the set wrapped by tr.\n\nAlgorithm\n\nWe compute translate(linear_map(M, tr.X), M * tr.v).\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Translation/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Translation{N,VN,S} where S<:LazySet{N} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Translation","title":"Base.:∈","text":"∈(x::AbstractVector{N}, tr::Translation{N}) where {N<:Real}\n\nCheck whether a given point is contained in the translation of a convex set.\n\nInput\n\nx  – point/vector\ntr – translation of a convex set\n\nOutput\n\ntrue iff x  tr.\n\nAlgorithm\n\nThis implementation relies on the set membership function for the wrapped set tr.X, since x  X  v iff x - v  X.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Translation/","page":"Translation","title":"Translation","text":"Inherited from AbstractAffineMap:","category":"page"},{"location":"lib/lazy_operations/Translation/","page":"Translation","title":"Translation","text":"dim\nisempty\nisbounded\nvertices_list","category":"page"},{"location":"lib/lazy_operations/Translation/","page":"Translation","title":"Translation","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/Translation/","page":"Translation","title":"Translation","text":"norm\nradius\ndiameter","category":"page"},{"location":"man/polyhedral_approximations/#Polyhedral-Approximations","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"","category":"section"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"In this section we review the mathematical notation and results from convex geometry that are used throughout LazySets.","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"Pages = [\"polyhedral_approximations.md\"]\nDepth = 3","category":"page"},{"location":"man/polyhedral_approximations/#Preliminaries","page":"Polyhedral Approximations","title":"Preliminaries","text":"","category":"section"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"Let us introduce some notation. Let mathbbI_n be the identity matrix of dimension ntimes n. For p geq 1, the p-norm of an n-dimensional vector x in mathbbR^n is denoted Vert x Vert_p.","category":"page"},{"location":"man/polyhedral_approximations/#Support-Function","page":"Polyhedral Approximations","title":"Support Function","text":"","category":"section"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"The support function is a basic notion for approximating convex sets. Let mathcalX subset mathbbR^n be a compact convex set. The support function of mathcalX is the function rho_mathcalX  mathbbR^nto mathbbR, defined as","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"rho_mathcalX(ell) = maxlimits_x in mathcalX ell^mathrmT x","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"We recall the following elementary properties of the support function.","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"Proposition. For all compact convex sets mathcalX, mathcalY in mathbbR^n, for all ntimes n real matrices M, all scalars lambda, and all vectors ell in mathbbR^n, we have:","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"beginalign*\nquad rho_lambdamathcalX (ell) = rho_mathcalX (lambda ell)\ntext and  rho_lambdamathcalX (ell) = lambda rho_mathcalX (ell) text if  lambda  0 tag11 1mm\n\nquad rho_MmathcalX (ell) = rho_mathcalX (M^mathrmT ell) tag12 1mm\n\nquad rho_mathcalX oplus mathcalY (ell) = rho_mathcalX (ell) + rho_mathcalY (ell) tag13 1mm\n\nquad rho_mathcalX times mathcalY (ell) = ell^mathrmT sigma_mathcalX times mathcalY(ell) = rho_mathcalX(ell_1^mathrmT) + rho_mathcalY(ell_2^mathrmT) tag14 1mm\n\nquad rho_mathrmCH(mathcalXcupmathcalY) (ell) = max (rho_mathcalX (ell) rho_mathcalY (ell)) tag15\nendalign*","category":"page"},{"location":"man/polyhedral_approximations/#Support-Vector","page":"Polyhedral Approximations","title":"Support Vector","text":"","category":"section"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"The farthest points of mathcalX in the direction ell are the support vectors denoted sigma_mathcalX(ell). These points correspond to the optimal points for the support function, i.e.,","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"sigma_mathcalX(ell) =  x in mathcalX  ell^mathrmT x  = rho_mathcalX(ell)  ","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"Since all support vectors in a given direction evaluate to the same value of the support function, we often speak of the support vector, where the choice of any support vector is implied.","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"(Image: Illustration of the support function and the support vector)","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"Proposition 2. Under the same conditions as in Proposition 1, the following hold:","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"beginalign*\nquad sigma_lambdamathcalX (ell) = lambda sigma_mathcalX (lambda ell) tag21 1mm\n\nquad sigma_MmathcalX (ell) = Msigma_mathcalX (M^mathrmT ell) tag22 1mm\n\nquad sigma_mathcalX oplus mathcalY (ell) = sigma_mathcalX (ell) oplus sigma_mathcalY (ell) tag23 1mm\n\nquad sigma_mathcalX times mathcalY (ell) = (sigma_mathcalX(ell_1) sigma_mathcalY(ell_2)) text where  ell = (ell_1 ell_2) tag24 1mm\n\nquad sigma_mathrmCH(mathcalXcupmathcalY) (ell) =\ntextargmax_x y (ell^mathrmT x ell^mathrmT y)\ntext where  x in sigma_mathcalX(ell) y in sigma_mathcalY(ell) tag25\nendalign*","category":"page"},{"location":"man/polyhedral_approximations/#Polyhedral-approximation-of-a-convex-set","page":"Polyhedral Approximations","title":"Polyhedral approximation of a convex set","text":"","category":"section"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"The projection of a set into a low dimensional space (a special case of M mathcalX) can be conveniently evaluated using support functions, since sigma_MmathcalX(ell) = sigma_mathcalX(M^Tell). Moreover, for some classical convex sets such as unit balls in the infinity norm, in the 2-norm, or polyhedra in constraint representation, the support functions can be efficiently computed. For example, the support function of the unit ball mathcalB_p^n is rho_mathcalB_p^n(ell) = VertellVert_fracpp-1","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"Given directions ell_1ldotsell_m, a tight overapproximation of mathcalX is the outer polyhedron given by the constraints","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"beginequation*\nquad bigwedge_i ell_i^T x leq rho_mathcalX(ell_i) tag3\nendequation*","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"For instance, a bounding box involves evaluating the support function in 2n directions. To quantify this, we use the following distance measure.","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"A set mathcalhatX is within Hausdorff distance varepsilon of mathcalX if and only if","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"mathcalhatX subseteq mathcalX oplus varepsilonmathcalB_p^n\ntext and  mathcalX subseteq mathcalhatX oplus\nvarepsilonmathcalB_p^n","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"The infimum varepsilon geq 0 that satisfies the above equation is called the Hausdorff distance between mathcalX and mathcalhatX with respect to the p-norm, and is denoted d_H^pbigl(mathcalXmathcalhatXbigr).","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"Another useful characterization of the Hausdorff distance is the following. Let mathcalX mathcalY subset mathbbR^n be polytopes. Then","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"d^p_H(mathcalX mathcalY) = max_ell in mathcalB_p^n\nleftrho_mathcalY(ell) - rho_mathcalX(ell)right","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"In the special case mathcalX subseteq mathcalY, the absolute value can be removed.","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"By adding directions using Kamenev's algorithm (s. below), the outer polyhedron in (3) is within Hausdorff distance varepsilon VertXVert_p for mathcalOleft(frac1varepsilon^n-1right) directions, and this bound is optimal. It follows that accurate outer polyhedral approximations are possible only in low dimensions. For n=2, the bound can be lowered to mathcalOleft(frac1sqrtvarepsilonright) directions, which is particularly efficient and the reason why we chose to decompose the system into subsystems of dimension 2.","category":"page"},{"location":"man/polyhedral_approximations/#Kamenev's-algorithm","page":"Polyhedral Approximations","title":"Kamenev's algorithm","text":"","category":"section"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"An overapproximation of the projections of a polyhedron given in constraint form can be obtained using Kamenev's algorithm; this is a particularly effective algorithm in two dimensions. Kamenev's algorithm proceeds as follows. Starting with at least n linearly independent template directions, compute an outer approximation. From the corresponding support vectors, compute an inner approximation, as the convex hull of the support vectors. Now compute the facet normals of the inner approximation, and the distance between the facets of the inner and the vertices of the outer approximation. Finally, pick the facet normal with the largest distance, and add it to the template directions. This procedure is repeated until the distance is smaller than the desired error.","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"For more details we refer to","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"Kamenev, G. K. (1996). An algorithm for approximating polyhedra. Computational Mathematics and Mathematical Physics, 36(4), 533–544,","category":"page"},{"location":"man/polyhedral_approximations/","page":"Polyhedral Approximations","title":"Polyhedral Approximations","text":"Lotov, A. V., & Pospelov, A. I. (2008). The modified method of refined bounds for polyhedral approximation of convex polytopes. Computational Mathematics and Mathematical Physics, 48(6), 933-941 .","category":"page"},{"location":"man/reach_zonotopes/#A-Reachability-Algorithm-Using-Zonotopes","page":"A Reachability Algorithm","title":"A Reachability Algorithm Using Zonotopes","text":"","category":"section"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"Pages = [\"reach_zonotopes.md\"]\nDepth = 3","category":"page"},{"location":"man/reach_zonotopes/#Introduction","page":"A Reachability Algorithm","title":"Introduction","text":"","category":"section"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"In this section we present an algorithm implemented using LazySets that computes the reach sets of an affine ordinary differential equation (ODE). This algorithm is from A. Girard's \"Reachability of uncertain linear systems using zonotopes, HSCC. Vol. 5. 2005. We have chosen this algorithm for the purpose of illustration of a complete application of LazySets.","category":"page"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"Let us introduce some notation. Consider the continuous initial set-valued problem (IVP)","category":"page"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"    x(t) = A x(t) + u(t)","category":"page"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"in the time interval t  0 T, where:","category":"page"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"A is a real matrix of order n,\nu(t) is a non-deterministic input such that Vert u(t) Vert_  μ for all t,\nx(0)  mathcalX_0, where mathcalX_0 is a convex set.","category":"page"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"Given a step size δ, Algorithm1 returns a sequence of sets that overapproximates the states reachable by any trajectory of this IVP.","category":"page"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"We present the algorithm parametric in the option to compute the sets in a lazy or in a concrete way. If the parameter lazy is true, the implementation constructs a LinearMap wrapper (represented as a multiplication * of a matrix and a set) and a MinkowskiSum wrapper (represented as a sum ⊕ of two sets). If the parameter lazy is false, the implementation calls the concrete counterparts linear_map and minkowski_sum.","category":"page"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"For further applications of LazySets in reachability analysis, we refer to the library JuliaReach/Reachability.jl.","category":"page"},{"location":"man/reach_zonotopes/#Algorithm","page":"A Reachability Algorithm","title":"Algorithm","text":"","category":"section"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"using Plots, LazySets, LinearAlgebra, SparseArrays\n\nfunction Algorithm1(A, X0, δ, μ, T; lazy::Bool=false)\n    # bloating factors\n    Anorm = norm(A, Inf)\n    α = (exp(δ * Anorm) - 1 - δ * Anorm) / norm(X0, Inf)\n    β = (exp(δ * Anorm) - 1) * μ / Anorm\n\n    # discretized system\n    n = size(A, 1)\n    ϕ = exp(δ * A)\n    N = floor(Int, T / δ)\n\n    # preallocate arrays\n    Q = Vector{LazySet{Float64}}(undef, N)\n    R = Vector{LazySet{Float64}}(undef, N)\n\n    # initial reach set in the time interval [0, δ]\n    ϕp = (I+ϕ) / 2\n    ϕm = (I-ϕ) / 2\n    c = X0.center\n    Q1_generators = hcat(ϕp * X0.generators, ϕm * c, ϕm * X0.generators)\n    Q[1] = lazy ?\n        Zonotope(ϕp * c, Q1_generators) ⊕ BallInf(zeros(n), α + β) :\n        minkowski_sum(Zonotope(ϕp * c, Q1_generators), BallInf(zeros(n), α + β))\n    R[1] = Q[1]\n\n    # set recurrence for [δ, 2δ], ..., [(N-1)δ, Nδ]\n    ballβ = BallInf(zeros(n), β)\n    for i in 2:N\n        Q[i] = lazy ?\n            ϕ * Q[i-1] ⊕ ballβ :\n            minkowski_sum(linear_map(ϕ, Q[i-1]), ballβ)\n        R[i] = Q[i]\n    end\n    return R\nend\nnothing # hide","category":"page"},{"location":"man/reach_zonotopes/#Projection","page":"A Reachability Algorithm","title":"Projection","text":"","category":"section"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"function project(R, vars, n)\n    # projection matrix\n    M = sparse(1:2, vars, [1., 1.], 2, n)\n    return [M * Ri for Ri in R]\nend\nnothing # hide","category":"page"},{"location":"man/reach_zonotopes/#Example-1","page":"A Reachability Algorithm","title":"Example 1","text":"","category":"section"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"A = [-1 -4; 4 -1]\nX0 = Zonotope([1.0, 0.0], Matrix(0.1*I, 2, 2))\nμ = 0.05\nδ = 0.02\nT = 2.\n\nR = Algorithm1(A, X0, δ, μ, 2 * δ); # warm-up\n\nR = Algorithm1(A, X0, δ, μ, T)\n\nplot(R, 1e-2, 0, true; fillalpha=0.1)","category":"page"},{"location":"man/reach_zonotopes/#Example-2","page":"A Reachability Algorithm","title":"Example 2","text":"","category":"section"},{"location":"man/reach_zonotopes/","page":"A Reachability Algorithm","title":"A Reachability Algorithm","text":"A = Matrix{Float64}([-1 -4 0 0 0;\n                      4 -1 0 0 0;\n                      0 0 -3 1 0;\n                      0 0 -1 -3 0;\n                      0 0 0 0 -2])\nX0 = Zonotope([1.0, 0.0, 0.0, 0.0, 0.0], Matrix(0.1*I, 5, 5))\nμ = 0.01\nδ = 0.005\nT = 1.\n\nR = Algorithm1(A, X0, δ, μ, 2 * δ); # warm-up\n\nR = Algorithm1(A, X0, δ, μ, T)\nRproj = project(R, [1, 3], 5)\n\nplot(Rproj, 1e-2, 0, true; fillalpha=0.1, xlabel=\"x1\", ylabel=\"x3\")","category":"page"},{"location":"lib/lazy_operations/ConvexHull/","page":"ConvexHull","title":"ConvexHull","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/lazy_operations/ConvexHull/#Convex-hull","page":"ConvexHull","title":"Convex hull","text":"","category":"section"},{"location":"lib/lazy_operations/ConvexHull/#def_ConvexHull","page":"ConvexHull","title":"Binary convex hull (ConvexHull)","text":"","category":"section"},{"location":"lib/lazy_operations/ConvexHull/","page":"ConvexHull","title":"ConvexHull","text":"ConvexHull\nCH\nswap(::ConvexHull)\ndim(::ConvexHull)\nρ(::AbstractVector{N}, ::ConvexHull{N}) where {N<:Real}\nσ(::AbstractVector{N}, ::ConvexHull{N}) where {N<:Real}\nisbounded(::ConvexHull)\nisempty(::ConvexHull)\nvertices_list(::ConvexHull)","category":"page"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.ConvexHull","page":"ConvexHull","title":"LazySets.ConvexHull","text":"ConvexHull{N<:Real, S1<:LazySet{N}, S2<:LazySet{N}} <: LazySet{N}\n\nType that represents the convex hull of the union of two convex sets.\n\nFields\n\nX – convex set\nY – convex set\n\nNotes\n\nThe EmptySet is the neutral element for ConvexHull.\n\nExamples\n\nConvex hull of two 100-dimensional Euclidean balls:\n\njulia> b1, b2 = Ball2(zeros(100), 0.1), Ball2(4*ones(100), 0.2);\n\njulia> c = ConvexHull(b1, b2);\n\njulia> typeof(c)\nConvexHull{Float64,Ball2{Float64,Array{Float64,1}},Ball2{Float64,Array{Float64,1}}}\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.CH","page":"ConvexHull","title":"LazySets.CH","text":"CH\n\nAlias for ConvexHull.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.swap-Tuple{ConvexHull}","page":"ConvexHull","title":"LazySets.swap","text":"swap(ch::ConvexHull)\n\nReturn a new ConvexHull object with the arguments swapped.\n\nInput\n\nch – convex hull of two convex sets\n\nOutput\n\nA new ConvexHull object with the arguments swapped.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.dim-Tuple{ConvexHull}","page":"ConvexHull","title":"LazySets.dim","text":"dim(ch::ConvexHull)\n\nReturn the dimension of a convex hull of two convex sets.\n\nInput\n\nch – convex hull of two convex sets\n\nOutput\n\nThe ambient dimension of the convex hull of two convex sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHull{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}} where N<:Real","page":"ConvexHull","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, ch::ConvexHull{N}) where {N<:Real}\n\nReturn the support function of a convex hull of two convex sets in a given direction.\n\nInput\n\nd  – direction\nch – convex hull of two convex sets\n\nOutput\n\nThe support function of the convex hull in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHull{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}} where N<:Real","page":"ConvexHull","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, ch::ConvexHull{N}) where {N<:Real}\n\nReturn the support vector of a convex hull of two convex sets in a given direction.\n\nInput\n\nd  – direction\nch – convex hull of two convex sets\n\nOutput\n\nThe support vector of the convex hull in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.isbounded-Tuple{ConvexHull}","page":"ConvexHull","title":"LazySets.isbounded","text":"isbounded(ch::ConvexHull)\n\nDetermine whether a convex hull of two convex sets is bounded.\n\nInput\n\nch – convex hull of two convex sets\n\nOutput\n\ntrue iff both wrapped sets are bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#Base.isempty-Tuple{ConvexHull}","page":"ConvexHull","title":"Base.isempty","text":"isempty(ch::ConvexHull)\n\nReturn if a convex hull of two convex sets is empty or not.\n\nInput\n\nch – convex hull\n\nOutput\n\ntrue iff both wrapped sets are empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.vertices_list-Tuple{ConvexHull}","page":"ConvexHull","title":"LazySets.vertices_list","text":"vertices_list(ch::ConvexHull; apply_convex_hull::Bool=true, backend=nothing)\n\nReturn the list of vertices of the convex hull of two convex sets.\n\nInput\n\nch               – convex hull of two convex sets\napply_convex_hull – (optional, default: true) if true, post-process the                        vertices using a convex-hull algorithm\nbackend           – (optional, default: nothing) backend for computing                        the convex hull (see argument apply_convex_hull)\n\nOutput\n\nThe list of vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/","page":"ConvexHull","title":"ConvexHull","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/ConvexHull/","page":"ConvexHull","title":"ConvexHull","text":"norm\nradius\ndiameter\nan_element","category":"page"},{"location":"lib/lazy_operations/ConvexHull/#def_ConvexHullArray","page":"ConvexHull","title":"n-ary convex hull (ConvexHullArray)","text":"","category":"section"},{"location":"lib/lazy_operations/ConvexHull/","page":"ConvexHull","title":"ConvexHull","text":"ConvexHullArray\nCHArray\ndim(::ConvexHullArray)\nρ(::AbstractVector{N}, ::ConvexHullArray{N}) where {N<:Real}\nσ(::AbstractVector{N}, ::ConvexHullArray{N}) where {N<:Real}\nisbounded(::ConvexHullArray)\narray(::ConvexHullArray{N, S}) where {N<:Real, S<:LazySet{N}}\nisempty(::ConvexHullArray)\nvertices_list(::ConvexHullArray)","category":"page"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.ConvexHullArray","page":"ConvexHull","title":"LazySets.ConvexHullArray","text":"ConvexHullArray{N<:Real, S<:LazySet{N}} <: LazySet{N}\n\nType that represents the symbolic convex hull of a finite number of convex sets.\n\nFields\n\narray – array of sets\n\nNotes\n\nThe EmptySet is the neutral element for ConvexHullArray.\n\nConstructors:\n\nConvexHullArray(array::Vector{<:LazySet}) – default constructor\nConvexHullArray([n]::Int=0, [N]::Type=Float64) – constructor for an empty hull with optional size hint and numeric type\n\nExamples\n\nConvex hull of 100 two-dimensional balls whose centers follows a sinusoidal:\n\njulia> b = [Ball2([2*pi*i/100, sin(2*pi*i/100)], 0.05) for i in 1:100];\n\njulia> c = ConvexHullArray(b);\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.CHArray","page":"ConvexHull","title":"LazySets.CHArray","text":"CHArray\n\nAlias for ConvexHullArray.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.dim-Tuple{ConvexHullArray}","page":"ConvexHull","title":"LazySets.dim","text":"dim(cha::ConvexHullArray)\n\nReturn the dimension of the convex hull of a finite number of convex sets.\n\nInput\n\ncha – convex hull array\n\nOutput\n\nThe ambient dimension of the convex hull of a finite number of convex sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHullArray{N,S} where S<:LazySet{N}}} where N<:Real","page":"ConvexHull","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, cha::ConvexHullArray{N}) where {N<:Real}\n\nReturn the support function of a convex hull array in a given direction.\n\nInput\n\nd   – direction\ncha – convex hull array\n\nOutput\n\nThe support function of the convex hull array in the given direction.\n\nAlgorithm\n\nThis algorihm calculates the maximum over all ρ(d X_i) where the X_1  X_k are the sets in the array cha.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ConvexHullArray{N,S} where S<:LazySet{N}}} where N<:Real","page":"ConvexHull","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, cha::ConvexHullArray{N}) where {N<:Real}\n\nReturn the support vector of a convex hull array in a given direction.\n\nInput\n\nd   – direction\ncha – convex hull array\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.isbounded-Tuple{ConvexHullArray}","page":"ConvexHull","title":"LazySets.isbounded","text":"isbounded(cha::ConvexHullArray)\n\nDetermine whether a convex hull of a finite number of convex sets is bounded.\n\nInput\n\ncha – convex hull of a finite number of convex sets\n\nOutput\n\ntrue iff all wrapped sets are bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.array-Union{Tuple{ConvexHullArray{N,S}}, Tuple{S}, Tuple{N}} where S<:LazySet{N} where N<:Real","page":"ConvexHull","title":"LazySets.array","text":"array(cpa::CartesianProductArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a Cartesian product of a finite number of convex sets.\n\nInput\n\ncpa – Cartesian product array\n\nOutput\n\nThe array of a Cartesian product of a finite number of convex sets.\n\n\n\n\n\narray(cha::ConvexHullArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a convex hull of a finite number of convex sets.\n\nInput\n\ncha – convex hull array\n\nOutput\n\nThe array of a convex hull of a finite number of convex sets.\n\n\n\n\n\narray(ia::IntersectionArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of an intersection of a finite number of convex sets.\n\nInput\n\nia – intersection of a finite number of convex sets\n\nOutput\n\nThe array of an intersection of a finite number of convex sets.\n\n\n\n\n\narray(msa::MinkowskiSumArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a Minkowski sum of a finite number of convex sets.\n\nInput\n\nmsa – Minkowski sum array\n\nOutput\n\nThe array of a Minkowski sum of a finite number of convex sets.\n\n\n\n\n\narray(cms::CachedMinkowskiSumArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a caching Minkowski sum.\n\nInput\n\ncms – caching Minkowski sum\n\nOutput\n\nThe array of a caching Minkowski sum.\n\n\n\n\n\narray(cup::UnionSetArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a union of a finite number of convex sets.\n\nInput\n\ncup – union of a finite number of convex sets\n\nOutput\n\nThe array that holds the union of a finite number of convex sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#Base.isempty-Tuple{ConvexHullArray}","page":"ConvexHull","title":"Base.isempty","text":"isempty(cha::ConvexHullArray)\n\nReturn if a convex hull array is empty or not.\n\nInput\n\ncha – convex hull array\n\nOutput\n\ntrue iff all wrapped sets are empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/#LazySets.vertices_list-Tuple{ConvexHullArray}","page":"ConvexHull","title":"LazySets.vertices_list","text":"vertices_list(cha::ConvexHullArray; apply_convex_hull::Bool=true,\n              backend=nothing)\n\nReturn the list of vertices of the convex hull of a finite number of convex sets.\n\nInput\n\ncha               – convex hull of a finite number of convex sets\napply_convex_hull – (optional, default: true) if true, post-process the                        vertices using a convex-hull algorithm\nbackend           – (optional, default: nothing) backend for computing                        the convex hull (see argument apply_convex_hull)\n\nOutput\n\nThe list of vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ConvexHull/","page":"ConvexHull","title":"ConvexHull","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/ConvexHull/","page":"ConvexHull","title":"ConvexHull","text":"norm\nradius\ndiameter\nan_element","category":"page"},{"location":"man/set_operations/#Operations-on-sets","page":"Operations on Sets","title":"Operations on sets","text":"","category":"section"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"In this section we show which typical set operations this library supports.","category":"page"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"Pages = [\"set_operations.md\"]\nDepth = 3","category":"page"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"We use the following four sets for illustration.","category":"page"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"using LazySets, LazySets.Approximations, Plots\nB1 = Ball1(-ones(2), 1.)\nB2 = Ball2(ones(2), 1.)\nBI = BallInf(zeros(2), 1.)\nH = Hyperrectangle(ones(2), ones(2))\nsets = [B1, B2, BI, H]\n\nfunction plot_sets(sets)\n    for S in sets\n        println(S)\n        plot!(S, 1e-2, fillalpha=0.1)\n    end\nend\n\nfunction plot_points(points, prefix)\n    for i in eachindex(points)\n        p = points[i]\n        num_occur = length(findfirst(x -> x == p, points[1:i]))\n        x = p[1]\n        y = p[2]\n        if num_occur == 1\n            x += 0.15\n        elseif num_occur == 2\n            y += 0.15\n        elseif num_occur == 3\n            x -= 0.15\n        else\n            y -= 0.15\n        end\n        plot!(Singleton(p))\n        plot!(annotations=(x, y, text(\"$(prefix)$(i)\")))\n    end\nend\n\nplot1 = plot()\nplot_sets(sets)\nplot1","category":"page"},{"location":"man/set_operations/#Unary-operations","page":"Operations on Sets","title":"Unary operations","text":"","category":"section"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"The following table lists all operations that take one convex set as argument in the columns. In the rows we list all set types, both the interfaces (where we abbreviate the Abstract prefix), the basic set types, and the lazy set operations, each sorted alphabetically. The table entries have the following meaning.","category":"page"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"\"x\" indicates that the operation is implemented for the respective set type.\n\"i\" indicates that the operation is inherited from a supertype.\n\"(·)\" indicates that the operation is partly implemented/inherited.","category":"page"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"type ↓ \\ operation → dim ρ σ an_element ∈ isempty isbounded linear_map translate norm radius diameter\nInterfaces            \nLazySet  x  x   x     x\nAPolytope  i  i  x x x    i\nACentrallySymmetric x i  x  x x     i\nACentrallySymmetricPolytope i i  i  x i i    i\nAPolygon x i  i  i i i    i\nAHyperrectangle i i x i x i i i  x x i\nAHPolygon i i  x x i i i    i\nASingleton i i x i x i i x  i i i\n            \nBasic set types            \nBall1 i i x i x i i i x   i\nBall2 i i x i x i i  x   i\nBallInf i i i i i i i i x i x i\nBallp i i x i x i i  x   i\nEllipsoid i x x i x i i  x   i\nEmptySet x i x x x x x  x x x x\nHalfSpace x x x x x x x  x   i\nHPolygon/HPolygonOpt i i x i i i i i x   i\nHPolyhedron x x x i x x x x x   i\nHPolytope x x x i x x i x x   i\nHyperplane x x x x x x x  x   i\nHyperrectangle i i i i i i i i x i i i\nInterval x i x x x i i i x i i i\nLine2D x i x x x x x  x   i\nLineSegment x i x x x i i i x   i\nSingleton i i i i i i i i x i i i\nUniverse x x x x x x x  x x x x\nVPolygon i i x x x i i x x   i\nVPolytope x i x i x i i x x   i\nZeroSet x i x i x i i x x i i i\nZonotope i x x i x i i x x   i\n            \nLazy set operation types            \nCartesianProduct x x x i x x x     i\nCartesianProductArray x x x i x x x     i\nConvexHull x x x i  x x     i\nConvexHullArray x x x i  x x     i\nExponentialMap x x x i x x x     i\nExponentialProjectionMap x i x i  x x     i\nIntersection x x  i x x x     i\nIntersectionArray x i  i x  x     i\nLinearMap x x x x x x x     i\nMinkowskiSum x x x i  x x     i\nMinkowskiSumArray x x x i  x x     i\nCachedMinkowskiSumArray x i x i  x x     i\nResetMap x x x x  x      i\nSymmetricIntervalHull x i x i i i i i  i i i\nTranslation x x x x x x  x    i\n            \nNon-convex operations            \nComplement x    x x      \nRectification x i (x) x x x x     \nUnionSet x x x x x x x     \nUnionSetArray x x x x x x x     ","category":"page"},{"location":"man/set_operations/#dim","page":"Operations on Sets","title":"dim","text":"","category":"section"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"This function returns the dimension of the set.","category":"page"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"dim(B1), dim(B2), dim(BI), dim(H)","category":"page"},{"location":"man/set_operations/#ρ/σ","page":"Operations on Sets","title":"ρ/σ","text":"","category":"section"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"These functions return the support function resp. the support vector of the set.","category":"page"},{"location":"man/set_operations/#an_element","page":"Operations on Sets","title":"an_element","text":"","category":"section"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"This function returns some element in the set. Consecutive calls to this function typically return the same element.","category":"page"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"an_element(B1), an_element(B2), an_element(BI), an_element(H)","category":"page"},{"location":"man/set_operations/#","page":"Operations on Sets","title":"∈","text":"","category":"section"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"This function checks containment of a given vector in the set. The operator can be used in infix notation (v ∈ S) and in inverse operand order (S ∋ v). Alias: in","category":"page"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"p1 = [1.5, 1.5]\np2 = [0.1, 0.1]\np3 = [-0.9, -0.8]\npoints = [p1, p2, p3]\n\nfor p in [p1, p2, p3]\n    println(\"$p ∈ (B1, B2, BI, H)? ($(p ∈ B1), $(p ∈ B2), $(p ∈ BI), $(p ∈ H))\")\nend","category":"page"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"plot1 = plot()\nplot_sets(sets)\nplot_points(points, \"p\")\nplot1","category":"page"},{"location":"man/set_operations/#isempty","page":"Operations on Sets","title":"isempty","text":"","category":"section"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"This function checks if the set is empty.","category":"page"},{"location":"man/set_operations/#linear_map","page":"Operations on Sets","title":"linear_map","text":"","category":"section"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"This function applies a concrete linear map to the set. The resulting set may be of a different type.","category":"page"},{"location":"man/set_operations/#norm","page":"Operations on Sets","title":"norm","text":"","category":"section"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"This function returns the norm of a set. It is defined as the norm of the enclosing ball (of the given norm) of minimal volume centered in the origin.","category":"page"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"# print 1-norm, 2-norm, and infinity norm (if available)\nprintln((\"-\", \"-\", norm(B1, Inf)))\nprintln((\"-\", \"-\", norm(B2, Inf)))\nprintln((norm(BI, 1), norm(BI, 2), norm(BI, Inf)))\nprintln((norm(H, 1), norm(H, 2), norm(H, Inf)))","category":"page"},{"location":"man/set_operations/#radius","page":"Operations on Sets","title":"radius","text":"","category":"section"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"This function returns the radius of a set. It is defined as the radius of the enclosing ball (of the given norm) of minimal volume with the same center.","category":"page"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"radius(B1), radius(B2), radius(BI), radius(H)","category":"page"},{"location":"man/set_operations/#diameter","page":"Operations on Sets","title":"diameter","text":"","category":"section"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"This function returns the diameter of a set. It is defined as the diameter of the enclosing ball (of the given norm) of minimal volume with the same center. The implementation is inherited for all set types if the norm is the infinity norm, in which case the result is defined as twice the radius.","category":"page"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"diameter(B1), diameter(B2), diameter(BI), diameter(H)","category":"page"},{"location":"man/set_operations/#Binary-operations","page":"Operations on Sets","title":"Binary operations","text":"","category":"section"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"The following table lists all operations that take two convex set as argument in the entries. In the rows we list all set types, both the interfaces (where we abbreviate the Abstract prefix), the basic set types, and the lazy set operations, each sorted alphabetically. In the columns we also list the operations, but abbreviated. The table entries consist of subsets of the following list of operations.","category":"page"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"\"⊆\" stands for the subset check issubset.\n\"⊎\" stands for the disjointness check isdisjoint.\n\"∩\" stands for the concrete intersection operation intersection.\n\"C\" stands for the conversion operation convert.\n\"-\" indicates that the two types' dimensionality constraints are incompatible.\nA suffix \"i\" indicates that the operation is inherited from a supertype.","category":"page"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"type ↓ \\ type → LazyS APtop ACSym ACSPt APgon AHrec AHPgn ASing Ball1 Ball2 BInf Ballp Ellip Empty HalfS HPgon HPhed HPtop Hplan Hrect Itrvl Line2D LineS Singl Universe VPgon VPtop ZeroS Zonot CP CPA CH CHA EMap EPM Itsct ItscA LiMap MS MSA CMS ReMap SIH Transl UnionSet UnionSArr Complem\nInterfaces                                               \nLazySet ⊎ ⊆  ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆  ⊎i ⊆i ⊎ ⊆i ⊎  ∩ ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆  ⊎ ⊆i ⊎i ⊆  ⊎ ⊆i ⊎ ⊆i ⊎ ⊆i ⊎i ⊆i ⊎i ⊎ ⊆i ⊎i ⊆i ⊎i ∩i ⊆  ⊎  ∩ ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎  ∩ ⊎  ∩ ⊆  ⊎\nAPolytope ⊆  ⊎i ⊆i ⊎i ∩ ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩ ⊆i ⊎i ∩ ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆  ⊎  ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nACentrallySymmetric ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nACentrallySymmetricPolytope ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nAPolygon ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i - ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nAHyperrectangle ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎  ∩ ⊆i ⊎i ∩i ⊆i ⊎  ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nAHPolygon ⊆i ⊎ ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩ ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i - ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i C ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nASingleton ⊆  ⊎  ∩ ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎  ∩i ⊆i ⊎i ∩i ⊆  ⊎  ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎  ∩ ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i  ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\n               ⊎                                \nBasic set types               ⊎                                \nBall1 ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nBall2 ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆  ⊎i ∩i ⊆i ⊎i ⊆ ⊎ ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆  ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆  ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nBallInf ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nBallp ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆  ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆  ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆  ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nEllipsoid ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nEmptySet ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆  ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nHalfSpace ⊎ ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎ ⊆i ⊎i ⊆i ⊎i ∩ ⊆i ⊎i ∩ ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎  ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nHPolygon/HPolygonOpt ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i C ⊆i ⊎i ∩i C ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i C ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ∩i C ⊆i ⊎i ⊆i ⊎i ∩i Ci - ⊆i ⊎i ⊆i ⊎i ∩i C ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nHPolyhedron ⊎ ⊆i ⊎i ∩  C ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊎i ⊆i ⊎i ∩i Ci ⊎i ⊎i ⊎i ⊆i ⊎i ∩ ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩ ⊆i ⊎i ∩  Ci ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩  Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ∩i Ci ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nHPolytope ⊆i ⊎ ⊆i ⊎i ∩  C ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i C ⊆i ⊎i ∩i C ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩ ⊆i ⊎i ∩i C ⊆i ⊎i ∩ ⊆i ⊎i ∩  Ci ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩  C ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nHyperplane ⊎ ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎  ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎ ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nHyperrectangle ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i C ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nInterval ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i - ⊆i ⊎i ∩i - ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i - ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i - - ⊆i ⊎i ∩i ⊆i ⊎i ∩i - ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nLine2D ⊎ ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i - ⊎i ∩ ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎  ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nLineSegment ⊆  ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i - ⊆i ⊎i ⊆i ⊎  ∩i ⊆i ⊎i ∩i ⊆  ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nSingleton ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nUniverse ⊆  ⊎  ∩ ⊆  ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎  ∩ ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎i ∩i ⊆i ⊎  ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎  ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎  ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆  ⊎  ∩ ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nVPolygon ⊆i ⊎i ⊆i ⊎i ∩i C ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i C ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ∩i Ci - ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nVPolytope ⊆i ⊎i ⊆i ⊎i ∩i C ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩ ⊆i ⊎i ∩  C ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩  Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nZeroSet ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nZonotope ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i C ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎ ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i Ci ⊆i ⊎  ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i Ci ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\n               ⊎                                \nLazy set operation types               ⊎                                \nCartesianProduct ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nCartesianProductArray ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆  ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nConvexHull ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nConvexHullArray ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nExponentialMap ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nExponentialProjectionMap ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nIntersection ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nIntersectionArray ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nLinearMap ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nMinkowskiSum ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nMinkowskiSumArray ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nCachedMinkowskiSumArray ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nResetMap ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nSymmetricIntervalHull ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nTranslation ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ⊆i ⊎i ⊆i ⊎i ∩i ⊆i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊆i ⊎i ⊎i ⊎i ∩i ⊎i ∩i ⊆i ⊎i\nUnionSet ⊆  ⊎  ∩ ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊎ ⊎ \nUnionSetArray ⊆  ⊎  ∩ ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊆i ⊎i ∩i ⊎ ⊎ \nComplement ⊎ ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i ⊎i   ","category":"page"},{"location":"man/set_operations/#-2","page":"Operations on Sets","title":"⊆","text":"","category":"section"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"This function checks whether a set is a subset of another set. It can optionally produce a witness if the subset relation does not hold. The operator can be used in infix notation (X ⊆ S). Alias: issubset","category":"page"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"println(B1 ⊆ B2)\nw1 = ⊆(B1, B2, true)[2]\nprintln(B1 ⊆ BI)\nw2 = ⊆(B1, BI, true)[2]\nprintln(B1 ⊆ H)\nw3 = ⊆(B1, H, true)[2]\n# 'B2 ⊆ B1' is not supported yet\n# w11 = ⊆(B2, B1, true)[2]\nprintln(B2 ⊆ BI)\nw4 = ⊆(B2, BI, true)[2]\nprintln(B2 ⊆ H)\nprintln(BI ⊆ B1)\nw5 = ⊆(BI, B1, true)[2]\nprintln(BI ⊆ B2)\nw6 = ⊆(BI, B2, true)[2]\nprintln(BI ⊆ H)\nw7 = ⊆(BI, H, true)[2]\nprintln(H ⊆ B1)\nw8 = ⊆(H, B1, true)[2]\nprintln(H ⊆ B2)\nw9 = ⊆(H, B2, true)[2]\nprintln(H ⊆ BI)\nw10 = ⊆(H, BI, true)[2];","category":"page"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"witnesses = [w1, w2, w3, w4, w5, w6, w7, w8, w9, w10]\n\nplot1 = plot()\nplot_sets(sets)\nplot_points(witnesses, \"w\")\nplot1","category":"page"},{"location":"man/set_operations/#is_intersection_empty","page":"Operations on Sets","title":"is_intersection_empty","text":"","category":"section"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"This function checks whether the intersection of two sets is empty. It can optionally produce a witness if the intersection is nonempty.","category":"page"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"println(is_intersection_empty(BI, H))\nw1 = is_intersection_empty(BI, H, true)[2]\n# none of the other combinations are supported yet\n# is_intersection_empty(B1, B2)\n# is_intersection_empty(B1, BI)\n# is_intersection_empty(B1, H)\n# w2 = is_intersection_empty(B1, H, true)[2]\n# is_intersection_empty(B2, BI)\n# is_intersection_empty(B2, H)","category":"page"},{"location":"man/set_operations/","page":"Operations on Sets","title":"Operations on Sets","text":"witnesses = [w1]\n\nplot1 = plot()\nplot_sets(sets)\nplot_points(witnesses, \"w\")\nplot1","category":"page"},{"location":"lib/sets/Ball2/","page":"Ball2","title":"Ball2","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/Ball2/#def_Ball2","page":"Ball2","title":"Euclidean-norm ball (Ball2)","text":"","category":"section"},{"location":"lib/sets/Ball2/","page":"Ball2","title":"Ball2","text":"Ball2\nσ(::AbstractVector{N}, ::Ball2{N}) where {N<:AbstractFloat}\n∈(::AbstractVector{N}, ::Ball2{N}) where {N<:AbstractFloat}\ncenter(::Ball2{N}) where {N<:AbstractFloat}\nrand(::Type{Ball2})\nsample(::Ball2{N}, ::Int) where {N<:AbstractFloat}\ntranslate(::Ball2{N}, ::AbstractVector{N}) where {N<:AbstractFloat}\nchebyshev_center(::Ball2{N}) where {N<:AbstractFloat}\nvolume(::Ball2{N}) where {N<:AbstractFloat}","category":"page"},{"location":"lib/sets/Ball2/#LazySets.Ball2","page":"Ball2","title":"LazySets.Ball2","text":"Ball2{N<:AbstractFloat, VN<:AbstractVector{N}} <: AbstractCentrallySymmetric{N}\n\nType that represents a ball in the 2-norm.\n\nFields\n\ncenter – center of the ball as a real vector\nradius – radius of the ball as a real scalar ( 0)\n\nNotes\n\nMathematically, a ball in the 2-norm is defined as the set\n\nmathcalB_2^n(c r) =  x  mathbbR^n   x - c _2  r \n\nwhere c  mathbbR^n is its center and r  mathbbR_+ its radius. Here   _2 denotes the Euclidean norm (also known as 2-norm), defined as  x _2 = left( sumlimits_i=1^n x_i^2 right)^12 for any x  mathbbR^n.\n\nExamples\n\nCreate a five-dimensional ball B in the 2-norm centered at the origin with radius 0.5:\n\njulia> B = Ball2(zeros(5), 0.5)\nBall2{Float64,Array{Float64,1}}([0.0, 0.0, 0.0, 0.0, 0.0], 0.5)\n\njulia> dim(B)\n5\n\nEvaluate B's support vector in the direction 12345:\n\njulia> σ([1.,2.,3.,4.,5.], B)\n5-element Array{Float64,1}:\n 0.06741998624632421\n 0.13483997249264842\n 0.20225995873897262\n 0.26967994498529685\n 0.3370999312316211\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Ball2/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ball2{N,VN} where VN<:AbstractArray{N,1}}} where N<:AbstractFloat","page":"Ball2","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, B::Ball2{N}) where {N<:AbstractFloat}\n\nReturn the support vector of a 2-norm ball in a given direction.\n\nInput\n\nd – direction\nB – ball in the 2-norm\n\nOutput\n\nThe support vector in the given direction. If the direction has norm zero, the origin is returned.\n\nNotes\n\nLet c and r be the center and radius of a ball B in the 2-norm, respectively. For nonzero direction d we have\n\nσ_B(d) = c + r fracdd_2\n\nThis function requires computing the 2-norm of the input direction, which is performed in the given precision of the numeric datatype of both the direction and the set. Exact inputs are not supported.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ball2{N,VN} where VN<:AbstractArray{N,1}}} where N<:AbstractFloat","page":"Ball2","title":"Base.:∈","text":"∈(x::AbstractVector{N}, B::Ball2{N}) where {N<:AbstractFloat}\n\nCheck whether a given point is contained in a ball in the 2-norm.\n\nInput\n\nx – point/vector\nB – ball in the 2-norm\n\nOutput\n\ntrue iff x  B.\n\nNotes\n\nThis implementation is worst-case optimized, i.e., it is optimistic and first computes (see below) the whole sum before comparing to the radius. In applications where the point is typically far away from the ball, a fail-fast implementation with interleaved comparisons could be more efficient.\n\nAlgorithm\n\nLet B be an n-dimensional ball in the 2-norm with radius r and let c_i and x_i be the ball's center and the vector x in dimension i, respectively. Then x  B iff left( _i=1^n c_i - x_i^2 right)^12  r.\n\nExamples\n\njulia> B = Ball2([1., 1.], sqrt(0.5))\nBall2{Float64,Array{Float64,1}}([1.0, 1.0], 0.7071067811865476)\n\njulia> [.5, 1.6] ∈ B\nfalse\n\njulia> [.5, 1.5] ∈ B\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#LazySets.center-Union{Tuple{Ball2{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:AbstractFloat","page":"Ball2","title":"LazySets.center","text":"center(B::Ball2{N}) where {N<:AbstractFloat}\n\nReturn the center of a ball in the 2-norm.\n\nInput\n\nB – ball in the 2-norm\n\nOutput\n\nThe center of the ball in the 2-norm.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#Base.rand-Tuple{Type{Ball2}}","page":"Ball2","title":"Base.rand","text":"rand(::Type{Ball2}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nCreate a random ball in the 2-norm.\n\nInput\n\nBall2 – type for dispatch\nN     – (optional, default: Float64) numeric type\ndim   – (optional, default: 2) dimension\nrng   – (optional, default: GLOBAL_RNG) random number generator\nseed  – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random ball in the 2-norm.\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the radius is nonnegative.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#LazySets.sample-Union{Tuple{N}, Tuple{Ball2{N,VN} where VN<:AbstractArray{N,1},Int64}} where N<:AbstractFloat","page":"Ball2","title":"LazySets.sample","text":"sample(B::Ball2{N, VN}, nsamples::Int=1;\n       [rng]::AbstractRNG=GLOBAL_RNG,\n       [seed]::Union{Int, Nothing}=nothing) where {N<:AbstractFloat, VN<:AbstractVector{N}}\n\nReturn samples from a uniform distribution on the given ball in the 2-norm.\n\nInput\n\nB        – ball in the 2-norm\nnsamples – (optional, default: 1) number of samples\nrng      – (optional, default: GLOBAL_RNG) random number generator\nseed     – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA linear array of nsamples elements drawn from a uniform distribution in B.\n\nAlgorithm\n\nRandom sampling with uniform distribution in B is computed using Muller's method of normalized Gaussians. This function requires the package Distributions. See _sample_unit_nball_muller! for implementation details.\n\n\n\n\n\nsample(X::LazySet{N}, num_samples::Int;\n       [sampler]=nothing,\n       [rng]::AbstractRNG=GLOBAL_RNG,\n       [seed]::Union{Int, Nothing}=nothing) where {N}\n\nSampling of an arbitrary bounded set X.\n\nInput\n\nX           – (bounded) set to be sampled\nnum_samples – number of random samples\nsampler     – sampler used (default: nothing, which falls back to                  RejectionSampler)\nrng         – (optional, default: GLOBAL_RNG) random number generator\nseed        – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA vector of num_samples vectors. If num_samples is not passed, the result is just one sample (not wrapped in a vector).\n\nAlgorithm\n\nSee the documentation of the respective Sampler.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#LazySets.translate-Union{Tuple{N}, Tuple{Ball2{N,VN} where VN<:AbstractArray{N,1},AbstractArray{N,1}}} where N<:AbstractFloat","page":"Ball2","title":"LazySets.translate","text":"translate(B::Ball2{N}, v::AbstractVector{N}) where {N<:AbstractFloat}\n\nTranslate (i.e., shift) a ball in the 2-norm by a given vector.\n\nInput\n\nB – ball in the 2-norm\nv – translation vector\n\nOutput\n\nA translated ball in the 2-norm.\n\nAlgorithm\n\nWe add the vector to the center of the ball.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#LazySets.chebyshev_center-Union{Tuple{Ball2{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:AbstractFloat","page":"Ball2","title":"LazySets.chebyshev_center","text":"chebyshev_center(B::Ball2{N}; compute_radius::Bool=false\n                ) where {N<:AbstractFloat}\n\nCompute the Chebyshev center of a ball in the 2-norm.\n\nInput\n\nB              – ball in the 2-norm\ncompute_radius – (optional; default: false) option to additionally return                     the radius of the largest ball enclosed by B around the                     Chebyshev center\n\nOutput\n\nIf compute_radius is false, the result is the Chebyshev center of B. If compute_radius is true, the result is the pair (c, r) where c is the Chebyshev center of B and r is the radius of the largest ball with center c enclosed by B.\n\nNotes\n\nThe Chebyshev center of a ball in the 2-norm is just the center of the ball.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/#LazySets.volume-Union{Tuple{Ball2{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:AbstractFloat","page":"Ball2","title":"LazySets.volume","text":"volume(B::Ball2{N}) where {N<:AbstractFloat}\n\nReturn the volume of a ball in the 2-norm.\n\nInput\n\nB – ball in the 2-norm\n\nOutput\n\nThe volume of B.\n\nAlgorithm\n\nThis function implements the well-known formula for the volume of an n-dimensional ball using factorials. For details see the wikipedia article Volume of an n-ball.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball2/","page":"Ball2","title":"Ball2","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Ball2/","page":"Ball2","title":"Ball2","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/sets/Ball2/","page":"Ball2","title":"Ball2","text":"Inherited from AbstractCentrallySymmetric:","category":"page"},{"location":"lib/sets/Ball2/","page":"Ball2","title":"Ball2","text":"dim\nisbounded\nisempty\nisuniversal\nan_element","category":"page"},{"location":"man/decompose_example/#Decomposing-an-Affine-Map","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"","category":"section"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"In this section we present an illustrative example of the decomposed image of a linear map.","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Pages = [\"decompose_example.md\"]\nDepth = 3","category":"page"},{"location":"man/decompose_example/#Preliminaries:-Polygon,-Linear-Map,-and-Plotting","page":"Decomposing an Affine Map","title":"Preliminaries: Polygon, Linear Map, and Plotting","text":"","category":"section"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Consider the matrix-valued function Φ(θ) = beginpmatrix cos (θ)  -sin (θ)  sin (θ)  cos (θ) endpmatrix, θ  π π.","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"using LazySets, LazySets.Approximations, Plots\n\nΦ(theta) = [cos(theta) -sin(theta); sin(theta) cos(theta)]","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Now define an arbitrary convex polygon with five vertices with operatornameCH denoting the convex hull operation,","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"mathcalX = operatornameCHbig( (1 05) (11 02) (14 03) (17 05) (14 08) big)","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"This set can be defined as:","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"X = VPolygon([[1.0, 0.5], [1.1, 0.2], [1.4, 0.3], [1.7, 0.5], [1.4, 0.8]])","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"note: Note\nYou can as well define the convex hull of the one element sets (singletons) viaC = CHArray([Singleton([1.0, 0.5]), Singleton([1.1, 0.2]), Singleton([1.4, 0.3]), Singleton([1.7, 0.5]), Singleton([1.4, 0.8])])Observe that C is just a lazy convex hull, whereas X is a polygon in vertex representation.","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Applying the linear map Φ(π4)  mathcalX, we get a new polygon mathcalX which is the counter-clockwise turn of mathcalX by θ triangleq 45. In this package the linear map is not computed explicitly but only wrapped in a LinearMap instance.","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Xp = Φ(pi/4) * X\n\ntypeof(Xp)","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Let us plot the two polygons, mathcalX in green and mathcalX in blue.","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"example = plot(X, color=\"green\")\n\nplot!(example, Xp, 1e-2, color=\"blue\")","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Note that we have passed 1e-2 as additional argument for the LinearMap set (mathcalX) because by default such a set is just plotted as its box (or hyperrectangle) approximation. The value 1e-2 is the precision up to which the set is (over-)approximated with a polygon, which in this case is sufficient to obtain the actual set again. If such value is not specified, it defaults to 1e-3.","category":"page"},{"location":"man/decompose_example/#Cartesian-Decomposition","page":"Decomposing an Affine Map","title":"Cartesian Decomposition","text":"","category":"section"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Next we want to decompose mathcalX into a Cartesian product of intervals. That is, we project it to the x-axis and y-axis and then compose these intervals again: hatmathcalX = hatmathcalX_1 times hatmathcalX_2.","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Xhat = overapproximate(X)  # approximation of X with an axis-aligned polygon\n\nplot!(example, Xhat, color=\"gray\", alpha=0.3)","category":"page"},{"location":"man/decompose_example/#Decomposed-Image-of-a-Linear-Map","page":"Decomposing an Affine Map","title":"Decomposed Image of a Linear Map","text":"","category":"section"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Now let us compute the linear map for the box approximation, and let us call it mathcalY = Φ(π4)  hatmathcalX. This will be a diamond-like shape (the box turned by 45°).","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Y = Φ(pi/4) * Xhat\n\nplot!(example, Y, color=\"yellow\", alpha=0.3)","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"However, we want our approximation be again a Cartesian product of intervals, so we have to overapproximate this diamond-like shape again: hatmathcalY = hatmathcalX = hatmathcalX_1 times hatmathcalX_2","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"Xhatp = overapproximate(Y)\n\nplot!(example, Xhatp, color=\"gray\", alpha=0.3)","category":"page"},{"location":"man/decompose_example/","page":"Decomposing an Affine Map","title":"Decomposing an Affine Map","text":"As we can see, the resulting box hatmathcalX is not a tight overapproximation of mathcalX. We can, however, gain precision by reducing the angle by which we turn the set, e.g., making two smaller turns. Why not try it out?","category":"page"},{"location":"#LazySets.jl","page":"Home","title":"LazySets.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = LazySets","category":"page"},{"location":"","page":"Home","title":"Home","text":"LazySets is a Julia package for calculus with convex sets.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The aim is to provide a scalable library for solving complex set-based problems, such as those encountered in differential inclusions or reachability analysis techniques in the domain of formal verification. Typically, one is confronted with a set-based recurrence with a given initial set and/or input sets, and for visualization purposes the final result has to be obtained through an adequate projection onto low-dimensions. This library implements types to construct set formulas and methods to efficiently and accurately approximate the projection in low-dimensions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In this package we describe convex sets lazily (i.e., symbolically). This way we provide an exact but abstract representation, in principle for any common convex set class or operation between sets. Concrete information is obtained through evaluating the set in specific directions. More precisely, each concrete subtype mathcalX of the abstract type LazySet exports a method to calculate its support vector σ(d mathcalX) in a given (arbitrary) direction d in mathbbR^n. Representing sets exactly but lazily has the advantage of being able to perform only the required operations on-demand.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For very long sequences of computations (e.g., set-based recurrences with tens of thousands of elements), it is useful to combine both lazy and concrete representations such as polyhedral approximations. All this is easy to do with LazySets. Moreover, we provide a specialized module for handling Cartesian decomposition of two-dimensional projections. The projection can be taken to the desired precision using an iterative refinement method.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let mathcalX_0 subset mathbbR^1000 be the Euclidean ball of center (1 ldots 1) and radius 01 in dimension n=1000. Given a real matrix A in mathbbR^1000 times 1000, suppose that we are interested in the equation","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathcalY = CH(e^A δ mathcalX_0  δ BmathcalU mathcalX_0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where CH is the convex hull operator,  denotes Minkowski sum, mathcalU is a ball in the infinity norm centered at zero and radius 12, and B is a linear map of the appropriate dimensions. This equation typically arises in the study of discrete approximation models for reachability of continuous systems, see for example SpaceEx: Scalable verification of hybrid systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For concreteness, we take A to be a random matrix with probability 1 of any entry being nonzero. Suppose that the input set mathcalU is two-dimensional, and that the linear map B is random. Finally, let δ = 0.1. Using LazySets, we can define this problem as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using LazySets, SparseArrays\n\njulia> A = sprandn(1000, 1000, 0.01);\n\njulia> δ = 0.1;\n\njulia> X0 = Ball2(ones(1000), 0.1);\n\njulia> B = randn(1000, 2);\n\njulia> U = BallInf(zeros(2), 1.2);","category":"page"},{"location":"","page":"Home","title":"Home","text":"The @time macro shows that building mathcalY with LazySets is instantaneous.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Y = CH(SparseMatrixExp(A * δ) * X0 + δ * B * U, X0);","category":"page"},{"location":"","page":"Home","title":"Home","text":"By asking for the concrete type of Y, we see that it has a convex hull type, parameterized by the types of its arguments, corresponding to the mathematical formulation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> basetype(Y)\nConvexHull","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now suppose that we are interested in observing the projection of mathcalY onto the variables number 1 and 500. First we define the 21000 projection matrix and apply it to mathcalY as a linear map (i.e., from the left). Second, we use the overapproximate method:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> proj_mat = [[1. zeros(1, 999)]; [zeros(1, 499) 1. zeros(1, 500)]];\n\njulia> res = Approximations.overapproximate(proj_mat * Y);","category":"page"},{"location":"","page":"Home","title":"Home","text":"We have calculated a box overapproximation of the exact projection onto the (x_1 x_500) plane. Notice that it takes about 0.064 seconds for the whole operation, allocating less than 10MB of RAM. Let us note that if the set operations were done explicitly, this would be much (!) slower. For instance, already the explicit computation of the matrix exponential would have cost 10x more, and allocated around 300MB. For even higher n, an evaluation will probably run out of RAM. But this is doable with LazySets because the action of the matrix exponential on the set is only evaluated along the directions of interest. Similar comments apply to the Minkowski sum above.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can visualize the result using plot, as shown below (left-most plot).","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: assets/example_ch.png)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the second and third plots, we have used a refined method that allows to specify a prescribed accuracy for the projection (in terms of the Hausdorff distance). For the theoretical background, see this reference. It can be passed as a second argument to overapproximate.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Error tol. time (s) memory (MB)\n∞ (no refinement) 0.022 5.27\n1e-1 0.051 7.91\n1e-3 0.17 30.3","category":"page"},{"location":"","page":"Home","title":"Home","text":"This table shows the runtime and memory consumption for different error tolerances, and the results are shown in three plots of above, from left to right. When passing to a smaller tolerance, the corners connecting edges are more \"rounded\", at the expense of computational resources, since more support vectors have to be evaluated.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The core functionality of LazySets is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lazy (i.e., symbolic) types for several classes of convex sets such as balls in different norms, polygons in constraint or vertex representation, zonotopes, special types such as lines and linear constraints, hyperrectangles, and high-dimensional polyhedra.\nLazy implementations for most commonly used set operations, e.g., Minkowski sum, Cartesian product, convex hull and interval hull approximations, and linear and exponential maps.","category":"page"},{"location":"","page":"Home","title":"Home","text":"On top of the previous basic type representations and operations, LazySets can be used to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Efficiently evaluate the support vector of nested lazy sets.\nCartesian decomposition of lazy sets using two-dimensional projections.\nFast overapproximation of an exact set using a polyhedral approximation, to the desired accuracy.\nExtensive visualization capabilities through the Plots.jl framework.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/getting_started.md\",\n    \"man/polyhedral_approximations.md\",\n    \"man/decompose_example.md\",\n    \"man/fast_2d_LPs.md\",\n    \"man/iterative_refinement.md\",\n    \"man/interval_hulls.md\",\n    \"man/convex_hulls.md\",\n    \"man/set_operations.md\",\n    \"man/reach_zonotopes.md\",\n    \"man/reach_zonotopes_hybrid.md\",\n    \"man/concrete_polyhedra.md\",\n    \"man/parallel_approximations.md\",\n    \"man/lazy_intersections.md\"\n]\nDepth = 2","category":"page"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/interfaces.md\",\n    \"lib/sets/Hyperrectangle.md\",\n    \"lib/sets/BallInf.md\",\n    \"lib/sets/Interval.md\",\n    \"lib/sets/Singleton.md\",\n    \"lib/sets/ZeroSet.md\",\n    \"lib/sets/HalfSpace.md\",\n    \"lib/sets/HPolyhedron.md\",\n    \"lib/sets/Hyperplane.md\",\n    \"lib/sets/Line2D.md\",\n    \"lib/sets/Universe.md\",\n    \"lib/sets/HPolytope.md\",\n    \"lib/sets/VPolytope.md\",\n    \"lib/sets/HPolygon.md\",\n    \"lib/sets/HPolygonOpt.md\",\n    \"lib/sets/VPolygon.md\",\n    \"lib/sets/Zonotope.md\",\n    \"lib/sets/LineSegment.md\",\n    \"lib/sets/Ball1.md\",\n    \"lib/sets/EmptySet.md\",\n    \"lib/sets/Ball2.md\",\n    \"lib/sets/Ellipsoid.md\",\n    \"lib/sets/Ballp.md\",\n    \"lib/sets/PolynomialZonotope.md\",\n    \"lib/lazy_operations/Bloating.md\",\n    \"lib/lazy_operations/CartesianProduct.md\",\n    \"lib/lazy_operations/ConvexHull.md\",\n    \"lib/lazy_operations/Intersection.md\",\n    \"lib/lazy_operations/MinkowskiSum.md\",\n    \"lib/lazy_operations/LinearMap.md\",\n    \"lib/lazy_operations/ExponentialMap.md\",\n    \"lib/lazy_operations/ResetMap.md\",\n    \"lib/lazy_operations/Translation.md\",\n    \"lib/lazy_operations/AffineMap.md\",\n    \"lib/lazy_operations/SymmetricIntervalHull.md\",\n    \"lib/lazy_operations/UnionSet.md\",\n    \"lib/lazy_operations/Complement.md\",\n    \"lib/lazy_operations/Rectification.md\",\n    \"lib/comparisons.md\",\n    \"lib/conversion.md\",\n    \"lib/binary_functions.md\",\n    \"lib/approximations.md\",\n    \"lib/utils.md\",\n    \"lib/parallel.md\"\n]\nDepth = 2","category":"page"},{"location":"lib/sets/EmptySet/","page":"EmptySet","title":"EmptySet","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/EmptySet/#def_EmptySet","page":"EmptySet","title":"Empty set (EmptySet)","text":"","category":"section"},{"location":"lib/sets/EmptySet/","page":"EmptySet","title":"EmptySet","text":"EmptySet\n∅\ndim(::EmptySet)\nσ(::AbstractVector{N}, ::EmptySet{N}) where {N<:Real}\nρ(::AbstractVector{N}, ::EmptySet{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::EmptySet{N}) where {N<:Real}\nan_element(::EmptySet)\nrand(::Type{EmptySet})\nisbounded(::EmptySet)\nisempty(::EmptySet)\nisuniversal(::EmptySet{N}, ::Bool=false) where {N<:Real}\nnorm(::EmptySet, ::Real=Inf)\nradius(::EmptySet, ::Real=Inf)\ndiameter(::EmptySet, ::Real=Inf)\nlinear_map(::AbstractMatrix{N}, ::EmptySet{N}) where {N}\ntranslate(::EmptySet{N}, ::AbstractVector{N}) where {N<:Real}\nplot_recipe(::EmptySet{N}, ::N=zero(N)) where {N<:Real}\nRecipesBase.apply_recipe(::AbstractDict{Symbol,Any}, ::EmptySet{N}, ::N=zero(N)) where {N<:Real}","category":"page"},{"location":"lib/sets/EmptySet/#LazySets.EmptySet","page":"EmptySet","title":"LazySets.EmptySet","text":"EmptySet{N<:Real} <: LazySet{N}\n\nType that represents the empty set, i.e., the set with no elements.\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/EmptySet/#LazySets.∅","page":"EmptySet","title":"LazySets.∅","text":"∅\n\nAlias for EmptySet{Float64}.\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/EmptySet/#LazySets.dim-Tuple{EmptySet}","page":"EmptySet","title":"LazySets.dim","text":"dim(∅::EmptySet)\n\nReturn the dimension of an empty set.\n\nInput\n\n∅ – an empty set\n\nOutput\n\nThe dimension of the empty set.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},EmptySet{N}}} where N<:Real","page":"EmptySet","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, ∅::EmptySet{N}) where {N<:Real}\n\nReturn the support vector of an empty set.\n\nInput\n\nd – direction\n∅ – empty set\n\nOutput\n\nAn error.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},EmptySet{N}}} where N<:Real","page":"EmptySet","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, ∅::EmptySet{N}) where {N<:Real}\n\nEvaluate the support function of an empty set in a given direction.\n\nInput\n\nd – direction\n∅ – empty set\n\nOutput\n\nAn error.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},EmptySet{N}}} where N<:Real","page":"EmptySet","title":"Base.:∈","text":"∈(x::AbstractVector{N}, ∅::EmptySet{N}) where {N<:Real}\n\nCheck whether a given point is contained in an empty set.\n\nInput\n\nx – point/vector\n∅ – empty set\n\nOutput\n\nThe output is always false.\n\nExamples\n\njulia> [1.0, 0.0] ∈ ∅(2)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/#LazySets.an_element-Tuple{EmptySet}","page":"EmptySet","title":"LazySets.an_element","text":"an_element(∅::EmptySet)\n\nReturn some element of an empty set.\n\nInput\n\n∅ – empty set\n\nOutput\n\nAn error.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/#Base.rand-Tuple{Type{EmptySet}}","page":"EmptySet","title":"Base.rand","text":"rand(::Type{EmptySet}; [N]::Type{<:Real}=Float64, [dim]::Int=0,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nCreate an empty set (note that there is nothing to randomize).\n\nInput\n\nEmptySet – type for dispatch\nN        – (optional, default: Float64) numeric type\ndim      – (optional, default: 2) dimension\nrng      – (optional, default: GLOBAL_RNG) random number generator\nseed     – (optional, default: nothing) seed for reseeding\n\nOutput\n\nThe (only) empty set of the given numeric type and dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/#LazySets.isbounded-Tuple{EmptySet}","page":"EmptySet","title":"LazySets.isbounded","text":"isbounded(∅::EmptySet)\n\nDetermine whether an empty set is bounded.\n\nInput\n\n∅ – empty set\n\nOutput\n\ntrue.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/#Base.isempty-Tuple{EmptySet}","page":"EmptySet","title":"Base.isempty","text":"isempty(∅::EmptySet)\n\nReturn if the empty set is empty or not.\n\nInput\n\n∅ – empty set\n\nOutput\n\ntrue.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/#LazySets.isuniversal-Union{Tuple{EmptySet{N}}, Tuple{N}, Tuple{EmptySet{N},Bool}} where N<:Real","page":"EmptySet","title":"LazySets.isuniversal","text":"isuniversal(∅::EmptySet{N}, [witness]::Bool=false) where {N<:Real}\n\nCheck whether an empty is universal.\n\nInput\n\n∅       – empty set\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: false\nIf witness option is activated: (false, v) where v  S, although we currently throw an error\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/#LinearAlgebra.norm","page":"EmptySet","title":"LinearAlgebra.norm","text":"norm(S::EmptySet, [p]::Real=Inf)\n\nReturn the norm of an empty set. It is the norm of the enclosing ball (of the given p-norm) of minimal volume that is centered in the origin.\n\nInput\n\nS – empty set\np – (optional, default: Inf) norm\n\nOutput\n\nAn error.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/EmptySet/#LazySets.radius","page":"EmptySet","title":"LazySets.radius","text":"radius(S::EmptySet, [p]::Real=Inf)\n\nReturn the radius of an empty set. It is the radius of the enclosing ball (of the given p-norm) of minimal volume with the same center.\n\nInput\n\nS – empty set\np – (optional, default: Inf) norm\n\nOutput\n\nAn error.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/EmptySet/#LazySets.diameter","page":"EmptySet","title":"LazySets.diameter","text":"diameter(S::EmptySet, [p]::Real=Inf)\n\nReturn the diameter of an empty set. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given p-norm) of minimal volume with the same center.\n\nInput\n\nS – empty set\np – (optional, default: Inf) norm\n\nOutput\n\nAn error.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/EmptySet/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},EmptySet{N}}} where N","page":"EmptySet","title":"LazySets.linear_map","text":"linear_map(M::AbstractMatrix{N}, ∅::EmptySet{N}) where {N}\n\nReturn the linear map of an empty set.\n\nInput\n\nM – matrix\n∅ – empty set\n\nOutput\n\nThe empty set.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/#LazySets.translate-Union{Tuple{N}, Tuple{EmptySet{N},AbstractArray{N,1}}} where N<:Real","page":"EmptySet","title":"LazySets.translate","text":"translate(∅::EmptySet{N}, v::AbstractVector{N}) where {N<:Real}\n\nTranslate (i.e., shift) an empty set by a given vector.\n\nInput\n\n∅ – empty set\nv – translation vector\n\nOutput\n\nThe empty set.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/#LazySets.plot_recipe-Union{Tuple{EmptySet{N}}, Tuple{N}, Tuple{EmptySet{N},N}} where N<:Real","page":"EmptySet","title":"LazySets.plot_recipe","text":"plot_recipe(∅::EmptySet{N}, [ε]::N=zero(N)) where {N<:Real}\n\nConvert an empty set to a sequence of points for plotting. In the special case of an empty set, we define the sequence as nothing.\n\nInput\n\n∅ – empty set\nε – (optional, default: 0) ignored, used for dispatch\n\nOutput\n\nnothing.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol,Any},EmptySet{N}}, Tuple{AbstractDict{Symbol,Any},EmptySet{N},N}} where N<:Real","page":"EmptySet","title":"RecipesBase.apply_recipe","text":"plot_emptyset(∅::EmptySet, [ε]::N=zero(N); ...)\n\nPlot an empty set.\n\nInput\n\n∅ – empty set\nε – (optional, default: 0) ignored, used for dispatch\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/EmptySet/","page":"EmptySet","title":"EmptySet","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/EmptySet/","page":"EmptySet","title":"EmptySet","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/comparisons/#Comparisons","page":"Comparisons","title":"Comparisons","text":"","category":"section"},{"location":"lib/comparisons/","page":"Comparisons","title":"Comparisons","text":"This section of the manual lists the comparison functions in floating point between scalars and between vectors.","category":"page"},{"location":"lib/comparisons/","page":"Comparisons","title":"Comparisons","text":"Pages = [\"comparisons.md\"]\nDepth = 3","category":"page"},{"location":"lib/comparisons/","page":"Comparisons","title":"Comparisons","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/comparisons/#Tolerance-type","page":"Comparisons","title":"Tolerance type","text":"","category":"section"},{"location":"lib/comparisons/","page":"Comparisons","title":"Comparisons","text":"Tolerance","category":"page"},{"location":"lib/comparisons/#LazySets.Tolerance","page":"Comparisons","title":"LazySets.Tolerance","text":"Tolerance{N<:Number}\n\nType that represents the tolerances for a given numeric type.\n\nFields\n\nrtol – relative tolerance\nztol – zero tolerance or absolute tolerance for comparison against zero\natol – absolute tolerance\n\nNotes\n\nThe type Tolerance, parametric in the numeric type N, is used to store default values for numeric comparisons. It is mutable and setting the value of a field affects the getter functions hence it can be used to fix the tolerance globally in LazySets.\n\nDefault values are defined for the most commonly used numeric types, and for those cases when other numeric types are needed one can extend the default values as explained next.\n\nThe cases Float64 and Rational are special in the sense that they are the most commonly used types in applications. Getting and setting default tolerances is achieved with the functions _rtol and set_rtol (and similarly for the other tolerances); the implementation creates an instance of Tolerance{Float64} (resp. Tolerance{Rational}) and sets some default values. Again since Tolerance is mutable, setting a value is possible e.g. set_rtol(Type{Float64}, ε) for some floating-point ε.\n\nFor all other cases, a dictionary mapping numeric types to instances of Tolerance for that numeric type is used. For floating-point types, a default value has been defined through default_tolerance as follows:\n\ndefault_tolerance(N::Type{<:AbstractFloat}) = Tolerance(Base.rtoldefault(N), sqrt(eps(N)), zero(N))\n\nHence to set a single tolerance (either rtol, ztol or atol) for a given floating-point type, use the corresponding set_rtol function, while the values which have not been set will be pulled from default_tolerance. If you would like to define the three default values at once, or are computing with a non floating-point numeric type, you can just extend default_tolerance(N::Type{<:Number}).\n\n\n\n\n\n","category":"type"},{"location":"lib/comparisons/#Approximate-inequality","page":"Comparisons","title":"Approximate inequality","text":"","category":"section"},{"location":"lib/comparisons/","page":"Comparisons","title":"Comparisons","text":"_leq(x::N, y::N; kwargs...) where {N<:Real}\n_leq(x::N, y::M; kwargs...) where {N<:Real, M<:Real}\n_geq(x::Real, y::Real; kwargs...)\n_leq(x::N, y::N; rtol::Real=Base.rtoldefault(N), ztol::Real=ABSZTOL(N), atol::Real=zero(N)) where {N<:AbstractFloat}","category":"page"},{"location":"lib/comparisons/#LazySets._leq-Union{Tuple{N}, Tuple{N,N}} where N<:Real","page":"Comparisons","title":"LazySets._leq","text":"_leq(x::N, y::N; [kwargs...]) where {N<:Real}\n\nDetermine if x is smaller than or equal to y.\n\nInput\n\nx      – number\ny      – another number (of the same numeric type as x)\nkwargs – not used\n\nOutput\n\nA boolean that is true iff x <= y.\n\nAlgorithm\n\nThis is a fallback implementation for numbers of type Real. If the arguments are floating point numbers, see _leq(x::AbstractFloat, y::AbstractFloat).\n\n\n\n\n\n","category":"method"},{"location":"lib/comparisons/#LazySets._leq-Union{Tuple{M}, Tuple{N}, Tuple{N,M}} where M<:Real where N<:Real","page":"Comparisons","title":"LazySets._leq","text":"_leq(x::N, y::M; [kwargs...]) where {N<:Real, M<:Real}\n\nDetermine if x is smaller than or equal to y.\n\nInput\n\nx      – number\ny      – another number (of possibly different numeric type than x)\nkwargs – optional arguments; see ?_leq for the available options\n\nOutput\n\nA boolean that is true iff x <= y.\n\nAlgorithm\n\nThis implementation calls Julia's promote(x, y) function, which converts all arguments to a common numeric type, returning them as a tuple. The conversion is such that the common type to which the values are converted can represent them as faithfully as possible.\n\n\n\n\n\n","category":"method"},{"location":"lib/comparisons/#LazySets._geq-Tuple{Real,Real}","page":"Comparisons","title":"LazySets._geq","text":"_geq(x::Real, y::Real; [kwargs...])\n\nDetermine if x is greater than or equal to y.\n\nInput\n\nx – number\ny – another number (of possibly different numeric type than x)\n\nOutput\n\nA boolean that is true iff x >= y.\n\nAlgorithm\n\nThis function falls back to _leq(y, x), with type promotion if needed. See the documentation of _leq for further details.\n\n\n\n\n\n","category":"method"},{"location":"lib/comparisons/#LazySets._leq-Union{Tuple{N}, Tuple{N,N}} where N<:AbstractFloat","page":"Comparisons","title":"LazySets._leq","text":"_leq(x::N, y::N;\n     rtol::Real=_rtol(N),\n     ztol::Real=_ztol(N),\n     atol::Real=_atol(N)) where {N<:AbstractFloat}\n\nDetermine if x is smaller than or equal to y.\n\nInput\n\nx    – number\ny    – another number (of the same numeric type as x)\nrtol – (optional, default: _rtol(N)) relative tolerance\nztol – (optional, default: _ztol(N)) absolute tolerance for comparison           against zero\natol – (optional, default: _atol(N)) absolute tolerance\n\nOutput\n\nA boolean that is true iff x <= y.\n\nAlgorithm\n\nThe x <= y comparison is split into x < y or x ≈ y; the latter is implemented by extending Juila's built-in isapprox(x, y) with an absolute tolerance that is used to compare against zero.\n\n\n\n\n\n","category":"method"},{"location":"lib/comparisons/#Approximate-equality","page":"Comparisons","title":"Approximate equality","text":"","category":"section"},{"location":"lib/comparisons/","page":"Comparisons","title":"Comparisons","text":"_isapprox(x::N, y::N; rtol::Real=Base.rtoldefault(N), ztol::Real=ABSZTOL(N), atol::Real=zero(N)) where {N<:AbstractFloat}\nisapproxzero(x::Real; kwargs...)\nisapproxzero(x::N; ztol::Real=ABSZTOL(N)) where {N<:AbstractFloat}","category":"page"},{"location":"lib/comparisons/#LazySets._isapprox-Union{Tuple{N}, Tuple{N,N}} where N<:AbstractFloat","page":"Comparisons","title":"LazySets._isapprox","text":"_isapprox(x::N, y::N;\n          rtol::Real=_rtol(N),\n          ztol::Real=_ztol(N),\n          atol::Real=_atol(N)) where {N<:Real}\n\nDetermine if x is approximately equal to y.\n\nInput\n\nx    – number\ny    – another number (of the same numeric type as x)\nrtol – (optional, default: _rtol(N)) relative tolerance\nztol – (optional, default: _ztol(N)) absolute tolerance for comparison           against zero\natol – (optional, default: _atol(N)) absolute tolerance\n\nOutput\n\nA boolean that is true iff x ≈ y.\n\nAlgorithm\n\nWe first check if x and y are both approximately zero, using isapproxzero(x, y). If that fails, we check if x ≈ y, using Julia's isapprox(x, y). In the latter check we use atol absolute tolerance and rtol relative tolerance.\n\nComparing to zero with default tolerances is a special case in Julia's isapprox, see the last paragraph in ?isapprox. This function tries to combine isapprox with its default values and a branch for x ≈ y ≈ 0 which includes x == y == 0 but also admits a tolerance ztol.\n\nNote that if x = ztol and y = -ztol, then |x-y| = 2*ztol and still _isapprox returns true.\n\n\n\n\n\n","category":"method"},{"location":"lib/comparisons/#LazySets.isapproxzero-Tuple{Real}","page":"Comparisons","title":"LazySets.isapproxzero","text":"isapproxzero(x::N; ztol::Real=_ztol(N)) where {N<:Real}\n\nDetermine if x is approximately zero.\n\nInput\n\nx    – number\nztol – (optional, default: _ztol(N)) tolerance against zero\n\nOutput\n\nA boolean that is true iff x ≈ 0.\n\nAlgorithm\n\nIt is considered that x ≈ 0 whenever x (in absolute value) is smaller than the tolerance for zero, ztol.\n\n\n\n\n\n","category":"method"},{"location":"lib/comparisons/#LazySets.isapproxzero-Union{Tuple{N}, Tuple{N}} where N<:AbstractFloat","page":"Comparisons","title":"LazySets.isapproxzero","text":"isapproxzero(x::N; ztol::Real=_ztol(N)) where {N<:Real}\n\nDetermine if x is approximately zero.\n\nInput\n\nx    – number\nztol – (optional, default: _ztol(N)) tolerance against zero\n\nOutput\n\nA boolean that is true iff x ≈ 0.\n\nAlgorithm\n\nIt is considered that x ≈ 0 whenever x (in absolute value) is smaller than the tolerance for zero, ztol.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/ZeroSet/#def_ZeroSet","page":"ZeroSet","title":"Origin (ZeroSet)","text":"","category":"section"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"ZeroSet\ndim(::ZeroSet)\nσ(::AbstractVector{N}, ::ZeroSet{N}) where {N<:Real}\nρ(::AbstractVector{N}, ::ZeroSet{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::ZeroSet{N}) where {N<:Real}\nrand(::Type{ZeroSet})\nelement(::ZeroSet{N}) where {N<:Real}\nelement(::ZeroSet{N}, ::Int) where {N<:Real}\nlinear_map(::AbstractMatrix{N}, ::ZeroSet{N}) where {N<:Real}\ntranslate(::ZeroSet{N}, ::AbstractVector{N}) where {N<:Real}\ncenter(::ZeroSet{N}, ::Int) where {N<:Real}","category":"page"},{"location":"lib/sets/ZeroSet/#LazySets.ZeroSet","page":"ZeroSet","title":"LazySets.ZeroSet","text":"ZeroSet{N<:Real} <: AbstractSingleton{N}\n\nType that represents the zero set, i.e., the set that only contains the origin.\n\nFields\n\ndim – the ambient dimension of this zero set\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/ZeroSet/#LazySets.dim-Tuple{ZeroSet}","page":"ZeroSet","title":"LazySets.dim","text":"dim(Z::ZeroSet)\n\nReturn the ambient dimension of this zero set.\n\nInput\n\nZ – a zero set, i.e., a set that only contains the origin\n\nOutput\n\nThe ambient dimension of the zero set.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/ZeroSet/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ZeroSet{N}}} where N<:Real","page":"ZeroSet","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, Z::ZeroSet{N}) where {N<:Real}\n\nReturn the support vector of a zero set.\n\nInput\n\nd – direction\nZ – a zero set, i.e., a set that only contains the origin\n\nOutput\n\nThe returned value is the origin since it is the only point that belongs to this set.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/ZeroSet/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ZeroSet{N}}} where N<:Real","page":"ZeroSet","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, Z::ZeroSet{N}) where {N<:Real}\n\nEvaluate the support function of a zero set in a given direction.\n\nInput\n\nd – direction\nZ – a zero set, i.e., a set that only contains the origin\n\nOutput\n\n0.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/ZeroSet/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},ZeroSet{N}}} where N<:Real","page":"ZeroSet","title":"Base.:∈","text":"∈(x::AbstractVector{N}, Z::ZeroSet{N}) where {N<:Real}\n\nCheck whether a given point is contained in a zero set.\n\nInput\n\nx – point/vector\nZ – zero set\n\nOutput\n\ntrue iff x  Z.\n\nExamples\n\njulia> Z = ZeroSet(2);\n\njulia> [1.0, 0.0] ∈ Z\nfalse\njulia> [0.0, 0.0] ∈ Z\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/ZeroSet/#Base.rand-Tuple{Type{ZeroSet}}","page":"ZeroSet","title":"Base.rand","text":"rand(::Type{ZeroSet}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nCreate a zero set (note that there is nothing to randomize).\n\nInput\n\nZeroSet – type for dispatch\nN       – (optional, default: Float64) numeric type\ndim     – (optional, default: 2) dimension\nrng     – (optional, default: GLOBAL_RNG) random number generator\nseed    – (optional, default: nothing) seed for reseeding\n\nOutput\n\nThe (only) zero set of the given numeric type and dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/ZeroSet/#LazySets.element-Union{Tuple{ZeroSet{N}}, Tuple{N}} where N<:Real","page":"ZeroSet","title":"LazySets.element","text":"element(S::ZeroSet{N}) where {N<:Real}\n\nReturn the element of a zero set.\n\nInput\n\nS – zero set\n\nOutput\n\nThe element of the zero set, i.e., a zero vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/ZeroSet/#LazySets.element-Union{Tuple{N}, Tuple{ZeroSet{N},Int64}} where N<:Real","page":"ZeroSet","title":"LazySets.element","text":"element(S::ZeroSet{N}, ::Int) where {N<:Real}\n\nReturn the i-th entry of the element of a zero set.\n\nInput\n\nS – zero set\ni – dimension\n\nOutput\n\nThe i-th entry of the element of the zero set, i.e., 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/ZeroSet/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},ZeroSet{N}}} where N<:Real","page":"ZeroSet","title":"LazySets.linear_map","text":"linear_map(M::AbstractMatrix{N}, Z::ZeroSet{N}) where {N<:Real}\n\nConcrete linear map of a zero set.\n\nInput\n\nM – matrix\nZ – zero set\n\nOutput\n\nThe zero set whose dimension matches the output dimension of the given matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/ZeroSet/#LazySets.translate-Union{Tuple{N}, Tuple{ZeroSet{N},AbstractArray{N,1}}} where N<:Real","page":"ZeroSet","title":"LazySets.translate","text":"translate(Z::ZeroSet{N}, v::AbstractVector{N}) where {N<:Real}\n\nTranslate (i.e., shift) a zero set by a given vector.\n\nInput\n\nZ – zero set\nv – translation vector\n\nOutput\n\nA singleton containing the vector v.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/ZeroSet/#LazySets.center-Union{Tuple{N}, Tuple{ZeroSet{N},Int64}} where N<:Real","page":"ZeroSet","title":"LazySets.center","text":"center(Z::ZeroSet{N}, i::Int) where {N<:Real}\n\nReturn the center along a given dimension of a zero set.\n\nInput\n\nZ – zero set\ni – dimension of interest\n\nOutput\n\nThe center along a given dimension of the zero set.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"diameter","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"isbounded\nisuniversal\nsingleton_list","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"isempty","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"ngens\norder\ntogrep","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"Inherited from AbstractHyperrectangle:","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"norm\nradius\nhigh\nlow\nconstraints_list","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"Inherited from AbstractSingleton:","category":"page"},{"location":"lib/sets/ZeroSet/","page":"ZeroSet","title":"ZeroSet","text":"radius_hyperrectangle\nradius_hyperrectangle\nvertices_list\ncenter\nan_element\ngenerators\ngenmat","category":"page"},{"location":"man/iterative_refinement/#Iterative-Refinement","page":"Iterative Refinement","title":"Iterative Refinement","text":"","category":"section"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"This section of the manual describes an approximation method for an arbitrary two-dimensional convex set S and a given error bound ε using support vectors. The basic idea is to add new supporting directions whenever the approximation error is still bigger than ε.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Pages = [\"iterative_refinement.md\"]\nDepth = 3","category":"page"},{"location":"man/iterative_refinement/#Local-approximations","page":"Iterative Refinement","title":"Local approximations","text":"","category":"section"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"The polygonal approximation of an arbitrary lazy convex set S is represented by a list of local approximations or refinements. More precisely, a local approximation is a triple (p_1 p_2 q), where:","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"p_1 and p_2 belong to S\nthe segments (p_1 q) and (p_2 q) belong to support lines of S","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Since S is assumed to be convex, the segment (p_1 p_2) is inside S. Taking each support line (p_1 q) of a given list of local approximations of S, we can build a polygon in constraint representation that overapproximates S.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"The type LocalApproximation{N} implements a local approximation; it is parametric in the numeric type N, and also contains additional information regarding the quality of the approximation: The refinable field is a boolean that is true whenever the approximation can be improved, and err is an upper bound on the exact Hausdorff distance of the approximation with respect to the exact set S.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Given the unit ball in the 2-norm, below we plot the local approximation along the East and North directions.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"using Plots, LazySets, LazySets.Approximations\n\nb = Ball2(zeros(2), 1.)\n\nplot(b, 1e-3, aspectratio=1, alpha=0.3, legend=false)\n\nplot!(Singleton([1.0, 0.0]), annotations=(1.1, 0.1, text(\"p1\")), color=\"green\")\nplot!(Singleton([0.0, 1.0]), annotations=(0.1, 1.1, text(\"p2\")), color=\"green\")\nplot!(Singleton([1.0, 1.0]), annotations=(1.09, 1.1, text(\"q\")))\nplot!(Singleton([0.0, 0.0]), annotations=(0.1, 0.0, text(\"0\")), color=\"green\")\nplot!(annotations=(1.4, 0.1, text(\"d1\")))\nplot!(annotations=(0.1, 1.4, text(\"d2\")))\nplot!(annotations=(0.75, 0.8, text(\"ndir\")))\n\nplot!(x->x, x->1., -0.8, 1.3, line=1, color=\"black\", linestyle=:dash)\nplot!(x->1., x->x, -0.8, 1.3, line=1, color=\"black\", linestyle=:dash)\nplot!(x->x+1, x->0., 0.0, 0.4, line=1, color=\"red\", linestyle=:solid, arrow=true)\nplot!(x->0., x->x+1, 0.0, 0.4, line=1, color=\"red\", linestyle=:solid, arrow=true)\nplot!(x->-x, x->x+1, -1.2, .2, line=1., color=\"black\", linestyle=:dashdot)\nplot!(x->x+.6, x->x+.6, -.1, .08, line=1, color=\"red\", linestyle=:solid, arrow=true)","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"We can instantiate and append this approximation to a fresh PolygonalOverapproximation object, which is a type that wraps a set and a list of LocalApproximations. The approximation is refinable, since it can be \"split\" along ndir, where ndir is the direction normal to the line (p_1 p_2) (shown dash-dotted in the figure), providing two approximations which are closer to the given set in Hausdorff distance.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"import LazySets.Approximations:PolygonalOverapproximation, addapproximation!\n\nΩ = PolygonalOverapproximation(b)\np1, d1, p2, d2 = [1.0, 0.0], [1.0, 0.0], [0.0, 1.0], [0.0, 1.0]\napprox_EAST_NORTH = addapproximation!(Ω, p1, d1, p2, d2)\n\napprox_EAST_NORTH.refinable","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"The associated error is sqrt2-10414213, which is the distance between the point q and the intersection between the line (0 q) and the circle. Actually this point corresponds to the support vector of the set b along ndir.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"approx_EAST_NORTH.err","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"The refined approximation is computed next.","category":"page"},{"location":"man/iterative_refinement/#Refinement","page":"Iterative Refinement","title":"Refinement","text":"","category":"section"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Basically, the refinement step consists of splitting the local approximation (p_1 p_2 q) into two local approximations (p_1 s q) and (s p_2 q), where s is the support vector of S along ndir.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"To illustrate this, first let's add the remaining three approximations to Ω along the canonical directions, to build a box overapproximation of b.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"import LazySets.Approximations: refine, tohrep\n\nplot(b, 1e-3, aspectratio=1, alpha=0.3)\n\n# initialize box directions\nDIR_EAST, DIR_NORTH, DIR_WEST, DIR_SOUTH = [1., 0.], [0., 1.], [-1., 0.], [0., -1.]\npe, pn, pw, ps = σ(DIR_EAST, b), σ(DIR_NORTH, b), σ(DIR_WEST, b), σ(DIR_SOUTH, b)\n\nΩ = PolygonalOverapproximation(b)\naddapproximation!(Ω, ps, DIR_SOUTH, pe, DIR_EAST)\naddapproximation!(Ω, pw, DIR_WEST, ps, DIR_SOUTH)\naddapproximation!(Ω, pn, DIR_NORTH, pw, DIR_WEST)\naddapproximation!(Ω, pe, DIR_EAST, pn, DIR_NORTH)\n\nplot!(tohrep(Ω), alpha=0.2, color=\"orange\")","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Next we refine the first approximation of the list.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"approx = pop!(Ω.approx_stack)\n(r1, r2) = refine(approx, Ω.S)\npush!(Ω.approx_stack, r2)\npush!(Ω.approx_stack, r1)\n\nplot(b, 1e-3, aspectratio=1, alpha=0.3)\nplot!(tohrep(Ω), alpha=0.2, color=\"orange\")","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"We call r1 and r2 the right and left approximations respectively, since they are saved in counter-clockwise order. We can check that the first two approximations are still refinable.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Ω.approx_stack[end].refinable,  Ω.approx_stack[end-1].refinable","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Hence, we can make again a refinement of that approximation.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"approx = pop!(Ω.approx_stack)\n(r1, r2) = refine(approx, Ω.S)\npush!(Ω.approx_stack, r2)\npush!(Ω.approx_stack, r1)\n\nplot(b, 1e-3, aspectratio=1, alpha=0.3)\nplot!(tohrep(Ω), alpha=0.2, color=\"orange\")","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"The criterion for an approximation being refinable is that we can properly define a normal direction ndir. This boils down to checking for the following \"degenerate\" cases:","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"p_1 and p_2 overlap.\np_1 and q overlap.\np_2 and q overlap.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Moreover, we include the condition approx_error > TOL where TOL is the floating point epsilon in the given numerical precision.","category":"page"},{"location":"man/iterative_refinement/#Algorithm","page":"Iterative Refinement","title":"Algorithm","text":"","category":"section"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Having presented the individual steps, we give the pseudocode of the iterative refinement algorithm, see approximate(S, ε).","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"The algorithm consists of the following steps:","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Initialization. The approximation is initialized with box directions, i.e. it starts with four LocalApproximation objects. Let i=1.\nRefinement loop. If the local approximation at index i has an error greater than the threshold ε, then refine. Otherwise, increment i <- i+1.\nRedundancy check. Insert the refined right approximation at position i, and check whether the left approximation is redundant or not with respect to the one at position i+1. Checking for redundancy amounts to checking for overlap of both p1 and q. Then, either substitute at i+1 or insert (keeping the approximation at i+1) depending on the redundancy check.\nStopping criterion. Terminate if the index i exceeds the current length of the approximations list; otherwise continue with step 2.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Observe that the algorithm finishes when all approximations are such that their associated error is smaller than ε, hence the Hausdorff distance between S and its polygonal overapproximation is no greater than ε.","category":"page"},{"location":"man/iterative_refinement/#Example","page":"Iterative Refinement","title":"Example","text":"","category":"section"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"As a final example consider the iterative refinement of the ball b for different values of the approximation threshold ε.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"import LazySets.Approximations:overapproximate, approximate\n\np0 = plot(b, 1e-6, aspectratio=1)\np1 = plot!(p0, overapproximate(b, 1.), alpha=0.4, aspectratio=1)\n\np0 = plot(b, 1e-6, aspectratio=1)\np2 = plot!(p0, overapproximate(b, 0.1), alpha=0.4, aspectratio=1)\n\np0 = plot(b, 1e-6, aspectratio=1)\np3 = plot!(p0, overapproximate(b, 0.01), alpha=0.4, aspectratio=1)\n\nplot(p1, p2, p3, layout=(1, 3))","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"Meanwhile, the number of constraints of the polygonal overapproximation increases, in this example by a power of 2 when the error is divided by a factor 10.","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"h = ε ->  length(approximate(b, ε).constraints)\nh(1.), h(0.1), h(0.01)","category":"page"},{"location":"man/iterative_refinement/","page":"Iterative Refinement","title":"Iterative Refinement","text":"note: Note\nActually, the plotting function for an arbitrary LazySet plot(...), called recipe in the context of Plots.jl, is such that it receives a numeric argument ε and the routine itself calls overapproximate. However, some sets such as abstract polygons have their own plotting recipe and hence do not require the error threshold, since they are plotted exactly as the convex hull of their vertices.","category":"page"},{"location":"about/#About","page":"About","title":"About","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"This page contains some general information about this project, and recommendations about contributing.","category":"page"},{"location":"about/","page":"About","title":"About","text":"Pages = [\"about.md\"]","category":"page"},{"location":"about/#Contributing","page":"About","title":"Contributing","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"If you like this package, consider contributing!","category":"page"},{"location":"about/","page":"About","title":"About","text":"Creating an issue in the LazySets GitHub issue tracker to report a bug, open a discussion about existing functionality, or suggesting new functionality is appreciated.","category":"page"},{"location":"about/","page":"About","title":"About","text":"If you have written code and would like it to be peer reviewed and added to the library, you can fork the repository and send a pull request (see below). Typical contributions include fixing a bug, adding a new feature or improving the documentation (either in source code or the online manual).","category":"page"},{"location":"about/","page":"About","title":"About","text":"You are also welcome to get in touch with us in the JuliaReach gitter chat.","category":"page"},{"location":"about/","page":"About","title":"About","text":"Below we detail some general comments about contributing to this package. The JuliaReach Developer's Documentation describes coding guidelines; take a look when in doubt about the coding style that is expected for the code that is finally merged into the library.","category":"page"},{"location":"about/#Branches-and-pull-requests-(PR)","page":"About","title":"Branches and pull requests (PR)","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"We use a standard pull request policy: You work in a private branch and eventually add a pull request, which is then reviewed by other programmers and merged into the master branch.","category":"page"},{"location":"about/","page":"About","title":"About","text":"Each pull request should be pushed in a new branch with the name of the author followed by a descriptive name, e.g., mforets/my_feature. If the branch is associated to a previous discussion in one issue, we use the name of the issue for easier lookup, e.g., mforets/7.","category":"page"},{"location":"about/#Unit-testing-and-continuous-integration-(CI)","page":"About","title":"Unit testing and continuous integration (CI)","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"This project is synchronized with Travis CI such that each PR gets tested before merging (and the build is automatically triggered after each new commit). For the maintainability of this project, it is important to understand and fix the failing doctests if they exist.","category":"page"},{"location":"about/","page":"About","title":"About","text":"When you modify code in this package, you should make sure that all unit tests pass. To run the unit tests locally, you should do:","category":"page"},{"location":"about/","page":"About","title":"About","text":"$ julia --color=yes test/runtests.jl","category":"page"},{"location":"about/","page":"About","title":"About","text":"Alternatively, you can achieve the same from inside the REPL using the following command:","category":"page"},{"location":"about/","page":"About","title":"About","text":"julia> Pkg.test(\"LazySets\")","category":"page"},{"location":"about/","page":"About","title":"About","text":"We also advise adding new unit tests when adding new features to ensure long-term support of your contributions.","category":"page"},{"location":"about/#Contributing-to-the-documentation","page":"About","title":"Contributing to the documentation","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"New functions and types should be documented according to the JuliaReach Developer's Documentation.","category":"page"},{"location":"about/","page":"About","title":"About","text":"You can view the source code documentation from inside the REPL by typing ? followed by the name of the type or function. For example, the following command will print the documentation of the LazySet type:","category":"page"},{"location":"about/","page":"About","title":"About","text":"julia> ?LazySet","category":"page"},{"location":"about/","page":"About","title":"About","text":"The documentation you are currently reading is written in Markdown, and it relies on the package Documenter.jl to produce the HTML layout. The sources for creating this documentation are found in docs/src. You can easily include the documentation that you wrote for your functions or types there (see the source code or Documenter's guidefor examples).","category":"page"},{"location":"about/","page":"About","title":"About","text":"To generate the documentation locally, run make.jl, e.g., by executing the following command in the terminal:","category":"page"},{"location":"about/","page":"About","title":"About","text":"$ julia --color=yes docs/make.jl","category":"page"},{"location":"about/","page":"About","title":"About","text":"Note that this also runs all doctests which will take some time.","category":"page"},{"location":"about/#Related-projects","page":"About","title":"Related projects","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"The project 3PLIB is a Java Library developed by Frédéric Viry, and it is one of the previous works that led to the creation of LazySets.jl. 3PLIB is specialized to planar projections of convex polyhedra. It was initially created to embed this feature in Java applications, and also provides a backend for visualization of high-dimensional reach set approximations computed with SpaceEx.","category":"page"},{"location":"about/#Credits","page":"About","title":"Credits","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"Here we list the names of the maintainers of the LazySets.jl library, as well as past and present contributors (in alphabetic order).","category":"page"},{"location":"about/#Core-developers","page":"About","title":"Core developers","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"Marcelo Forets, Universidad de la República\nChristian Schilling, IST Austria","category":"page"},{"location":"about/#Contributors","page":"About","title":"Contributors","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"Tomer Arnon, Stanford University\nSebastián Guadalupe, Universidad de la República\nKostiantyn Potomkin, Australian National University\nFrédéric Viry, CERFACS, France\nUeli Wechsler, ETH Zurich","category":"page"},{"location":"about/#Acknowledgements","page":"About","title":"Acknowledgements","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"We are grateful to the following persons for enlightening discussions: ","category":"page"},{"location":"about/","page":"About","title":"About","text":"Sergiy Bogomolov\nGoran Frehse ","category":"page"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/Ball1/#def_Ball1","page":"Ball1","title":"Manhattan-norm ball (Ball1)","text":"","category":"section"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"Ball1\nσ(::AbstractVector{N}, ::Ball1{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::Ball1{N}, ::Bool=false) where {N<:Real}\nvertices_list(::Ball1{N, VN}) where {N<:Real, VN<:AbstractVector{N}}\ncenter(::Ball1{N}) where {N<:Real}\nrand(::Type{Ball1})\nconstraints_list(::Ball1{N}) where {N<:Real}\ntranslate(::Ball1{N}, ::AbstractVector{N}) where {N<:Real}","category":"page"},{"location":"lib/sets/Ball1/#LazySets.Ball1","page":"Ball1","title":"LazySets.Ball1","text":"Ball1{N<:Real, VN<:AbstractVector{N}} <: AbstractCentrallySymmetricPolytope{N}\n\nType that represents a ball in the 1-norm (also known as the Manhattan norm). The ball is also known as a cross-polytope.\n\nIt is defined as the set\n\nmathcalB_1^n(c r) =  x  mathbbR^n  _i=1^n c_i - x_i  r \n\nwhere c  mathbbR^n is its center and r  mathbbR_+ its radius.\n\nFields\n\ncenter – center of the ball as a real vector\nradius – radius of the ball as a scalar ( 0)\n\nExamples\n\nUnit ball in the 1-norm in the plane:\n\njulia> B = Ball1(zeros(2), 1.)\nBall1{Float64,Array{Float64,1}}([0.0, 0.0], 1.0)\njulia> dim(B)\n2\n\nWe evaluate the support vector in the East direction:\n\njulia> σ([0.,1], B)\n2-element Array{Float64,1}:\n 0.0\n 1.0\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Ball1/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ball1{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Ball1","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, B::Ball1{N}) where {N<:Real}\n\nReturn the support vector of a ball in the 1-norm in a given direction.\n\nInput\n\nd – direction\nB – ball in the 1-norm\n\nOutput\n\nSupport vector in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ball1{N,VN} where VN<:AbstractArray{N,1}}, Tuple{AbstractArray{N,1},Ball1{N,VN} where VN<:AbstractArray{N,1},Bool}} where N<:Real","page":"Ball1","title":"Base.:∈","text":"∈(x::AbstractVector{N}, B::Ball1{N}, [failfast]::Bool=false) where {N<:Real}\n\nCheck whether a given point is contained in a ball in the 1-norm.\n\nInput\n\nx – point/vector\nB – ball in the 1-norm\nfailfast – (optional, default: false) optimization for negative answer\n\nOutput\n\ntrue iff x  B.\n\nNotes\n\nThe default behavior (failfast == false) is worst-case optimized, i.e., the implementation is optimistic and first computes (see below) the whole sum before comparing to the radius. In applications where the point is typically far away from the ball, the option failfast == true terminates faster.\n\nAlgorithm\n\nLet B be an n-dimensional ball in the 1-norm with radius r and let c_i and x_i be the ball's center and the vector x in dimension i, respectively. Then x  B iff _i=1^n c_i - x_i  r.\n\nExamples\n\njulia> B = Ball1([1., 1.], 1.);\n\njulia> [.5, -.5] ∈ B\nfalse\njulia> [.5, 1.5] ∈ B\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/#LazySets.vertices_list-Union{Tuple{Ball1{N,VN}}, Tuple{VN}, Tuple{N}} where VN<:AbstractArray{N,1} where N<:Real","page":"Ball1","title":"LazySets.vertices_list","text":"vertices_list(B::Ball1{N, VN}) where {N<:Real, VN<:AbstractVector{N}}\n\nReturn the list of vertices of a ball in the 1-norm.\n\nInput\n\nB – ball in the 1-norm\n\nOutput\n\nA list containing the vertices of the ball in the 1-norm.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/#LazySets.center-Union{Tuple{Ball1{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"Ball1","title":"LazySets.center","text":"center(B::Ball1{N}) where {N<:Real}\n\nReturn the center of a ball in the 1-norm.\n\nInput\n\nB – ball in the 1-norm\n\nOutput\n\nThe center of the ball in the 1-norm.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/#Base.rand-Tuple{Type{Ball1}}","page":"Ball1","title":"Base.rand","text":"rand(::Type{Ball1}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing\n    )\n\nCreate a random ball in the 1-norm.\n\nInput\n\nBall1 – type for dispatch\nN     – (optional, default: Float64) numeric type\ndim   – (optional, default: 2) dimension\nrng   – (optional, default: GLOBAL_RNG) random number generator\nseed  – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random ball in the 1-norm.\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the radius is nonnegative.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/#LazySets.constraints_list-Union{Tuple{Ball1{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"Ball1","title":"LazySets.constraints_list","text":"constraints_list(P::Ball1{N}) where {N<:Real}\n\nReturn the list of constraints defining a ball in the 1-norm.\n\nInput\n\nB – ball in the 1-norm\n\nOutput\n\nThe list of constraints of the ball.\n\nAlgorithm\n\nThe constraints can be defined as d_i^T (x-c)  r for all d_i, where d_i is a vector with elements 1 or -1 in n dimensions. To span all possible d_i, the function Iterators.product is used.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/#LazySets.translate-Union{Tuple{N}, Tuple{Ball1{N,VN} where VN<:AbstractArray{N,1},AbstractArray{N,1}}} where N<:Real","page":"Ball1","title":"LazySets.translate","text":"translate(B::Ball1{N}, v::AbstractVector{N}) where {N<:Real}\n\nTranslate (i.e., shift) a ball in the 1-norm by a given vector.\n\nInput\n\nB – ball in the 1-norm\nv – translation vector\n\nOutput\n\nA translated ball in the 1-norm.\n\nAlgorithm\n\nWe add the vector to the center of the ball.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"isbounded\nisuniversal\nsingleton_list","category":"page"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/sets/Ball1/","page":"Ball1","title":"Ball1","text":"dim\nisempty\nan_element","category":"page"},{"location":"man/fast_2d_LPs/#Fast-2D-LPs","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"","category":"section"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"In this section we explain the implementation of the support vector for the case of convex polygons.","category":"page"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"Pages = [\"fast_2d_LPs.md\"]\nDepth = 3","category":"page"},{"location":"man/fast_2d_LPs/#Introduction","page":"Fast 2D LPs","title":"Introduction","text":"","category":"section"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"Since vectors in the plane can be ordered by the angle with respect to the positive real axis, we can efficiently evaluate the support vector of a polygon in constraint representation by comparing normal directions, provided that its edges are ordered.","category":"page"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"This is illustrated in the following picture.","category":"page"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"(Image: ../assets/intuition2dlp.png)","category":"page"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"If the normal directions of the polygon are ordered, the support vector in any direction always lies between two consecutive edges, a_i+1 preceq ell preceq a_i. Here we use the symbol preceq to compare directions, where the increasing direction is counter-clockwise.","category":"page"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"The following lemma provides an algorithm to find the support vector.","category":"page"},{"location":"man/fast_2d_LPs/#Lemma","page":"Fast 2D LPs","title":"Lemma","text":"","category":"section"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"Let mathcalX be a polygon described by m linear constraints a_i^T x leq b_i, ordered by the normal vectors (a_i), i.e., a_i preceq a_i+1 for all i in 1ldotsm, where we identify a_m+1 with a_1. Let ell in mathbbR^2 setminus mathbf0_2. Then there exists i in 1dotsm such that a_i preceq ell preceq a_i+1 and every optimal solution barx of the linear program rho_mathcalX(ell) = max ell^T x  x in mathcalX satisfies barx in x  a_i^T x leq b_i cap x  a_i+1^T x leq b_i+1","category":"page"},{"location":"man/fast_2d_LPs/#Algorithm","page":"Fast 2D LPs","title":"Algorithm","text":"","category":"section"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"First define a <= b as the comparison of directions using polar angles, with 0 being the direction (1, 0).","category":"page"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"Now assume that the constraints in a polytope mathcalX are given as a_i x + b_i.","category":"page"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"The following pseudocode explains how to find barx.","category":"page"},{"location":"man/fast_2d_LPs/","page":"Fast 2D LPs","title":"Fast 2D LPs","text":"σ(d, X):\n    let i be the smallest index such that a_{i-1} <= d and a_i > d\n    return the vertex at the intersection of constraints i and i-1","category":"page"},{"location":"lib/lazy_operations/AffineMap/","page":"AffineMap","title":"AffineMap","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/lazy_operations/AffineMap/#def_AffineMap","page":"AffineMap","title":"Affine map (AffineMap)","text":"","category":"section"},{"location":"lib/lazy_operations/AffineMap/","page":"AffineMap","title":"AffineMap","text":"AffineMap","category":"page"},{"location":"lib/lazy_operations/AffineMap/#LazySets.AffineMap","page":"AffineMap","title":"LazySets.AffineMap","text":"AffineMap{N<:Real, S<:LazySet{N}, NM, MAT<:AbstractMatrix{NM},\n          VN<:AbstractVector{NM}} <: AbstractAffineMap{N, S}\n\nType that represents an affine transformation MX  v of a convex set X.\n\nFields\n\nM – matrix/linear map\nX – convex set\nv – translation vector\n\nNotes\n\nAn affine map is the composition of a linear map and a translation. This type is parametric in the coefficients of the linear map, NM, which may be different from the numeric type of the wrapped set (N). However, the numeric type of the translation vector should be NM.\n\nExamples\n\nFor the examples we create a 32 matrix, a two-dimensional unit square, and a three-dimensional vector. Then we combine them in an AffineMap.\n\njulia> A = [1 2; 1 3; 1 4]; X = BallInf([0, 0], 1); b2 = [1, 2]; b3 = [1, 2, 3];\n\njulia> AffineMap(A, X, b3)\nAffineMap{Int64,BallInf{Int64,Array{Int64,1}},Int64,Array{Int64,2},Array{Int64,1}}([1 2; 1 3; 1 4], BallInf{Int64,Array{Int64,1}}([0, 0], 1), [1, 2, 3])\n\nFor convenience, A does not need to be a matrix but we also allow to use UniformScalings resp. scalars (interpreted as a scaling, i.e., a scaled identity matrix). Scaling by 1 is ignored and simplified to a pure Translation.\n\njulia> using LinearAlgebra\n\njulia> am = AffineMap(2I, X, b2)\nAffineMap{Int64,BallInf{Int64,Array{Int64,1}},Int64,Diagonal{Int64,Array{Int64,1}},Array{Int64,1}}([2 0; 0 2], BallInf{Int64,Array{Int64,1}}([0, 0], 1), [1, 2])\n\njulia> AffineMap(2, X, b2) == am\ntrue\n\njulia> AffineMap(1, X, b2)\nTranslation{Int64,Array{Int64,1},BallInf{Int64,Array{Int64,1}}}(BallInf{Int64,Array{Int64,1}}([0, 0], 1), [1, 2])\n\nApplying a linear map to an AffineMap object combines the two maps into a new AffineMap instance. Again we can make use of the conversion for convenience.\n\njulia> B = [2 0; 0 2]; am2 = B * am\nAffineMap{Int64,BallInf{Int64,Array{Int64,1}},Int64,Array{Int64,2},Array{Int64,1}}([4 0; 0 4], BallInf{Int64,Array{Int64,1}}([0, 0], 1), [2, 4])\n\njulia> 2 * am == am2\ntrue\n\nThe application of an AffineMap to a ZeroSet or an EmptySet is simplified automatically.\n\njulia> AffineMap(A, ZeroSet{Int}(2), b3)\nSingleton{Int64,Array{Int64,1}}([1, 2, 3])\n\njulia> AffineMap(A, EmptySet{Int}(2), b3)\nEmptySet{Int64}(2)\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/AffineMap/","page":"AffineMap","title":"AffineMap","text":"Inherited from AbstractAffineMap:","category":"page"},{"location":"lib/lazy_operations/AffineMap/","page":"AffineMap","title":"AffineMap","text":"dim\nσ\nρ\nan_element\nisempty\nisbounded\n∈\nvertices_list\nconstraints_list\nlinear_map","category":"page"},{"location":"man/reach_zonotopes_hybrid/#A-Hybrid-Reachability-Algorithm-Using-Zonotopes","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm Using Zonotopes","text":"","category":"section"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"Pages = [\"reach_zonotopes_hybrid.md\"]\nDepth = 3","category":"page"},{"location":"man/reach_zonotopes_hybrid/#Introduction","page":"A Hybrid Reachability Algorithm","title":"Introduction","text":"","category":"section"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"In this section we present an algorithm implemented using LazySets that computes the reach sets of a hybrid system of linear ordinary differential equations (ODE). This algorithm is an extension of the one presented in A Reachability Algorithm Using Zonotopes.","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"We consider a simple case here where modes do not have invariants and transitions do not have updates. In set-based analysis like ours, it may make sense to take a transition as soon as one state in the current set of states can take it. Note that this is not equivalent to must semantics of hybrid automata (also called urgent transitions), which is defined on single trajectories. We also offer the usual may transitions interpretation.","category":"page"},{"location":"man/reach_zonotopes_hybrid/#Hybrid-algorithm","page":"A Hybrid Reachability Algorithm","title":"Hybrid algorithm","text":"","category":"section"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"The hybrid algorithm maintains a queue of triples (m X t) where m is a mode, X is a set of states, and t is a time point. For each element in the queue the algorithm calls the Continuous algorithm to compute the reachable states in the current mode m, starting in the current states X at time t. The result is a flowpipe, i.e., a sequence of sets of states. For each of those sets we check intersection with the guards of m's outgoing transitions. Depending on the transition semantics, we add the discrete successors to the queue and continue with the next iteration until the queue is empty.","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"using Plots, LazySets, LinearAlgebra\n\nfunction reach_hybrid(As, Ts, init, δ, μ, T, max_order, instant_transitions)\n    # initialize queue with initial mode and states at time t=0\n    queue = Vector{Tuple{Zonotope, Integer, Float64}}(undef, 1)\n    queue[1] = (init[1], init[2], 0.0)\n\n    res = Tuple{LazySet, Int}[]\n    while !isempty(queue)\n        init, loc, t = pop!(queue)\n        println(\"currently in location $loc at time $t\")\n        R = reach_continuous(As[loc], init, δ, μ, T-t, max_order)\n        found_transition = false\n        for i in 1:length(R)-1\n            S = R[i]\n            push!(res, (S, loc))\n            for (guard, tgt_loc) in Ts[loc]\n                if !is_intersection_empty(S, guard)\n                    new_t = t + δ * i\n                    push!(queue, (S, tgt_loc, new_t))\n                    found_transition = true\n                    println(\"transition $loc -> $tgt_loc at time $new_t\")\n                end\n            end\n            if instant_transitions && found_transition\n                break\n            end\n        end\n        if !instant_transitions || !found_transition && length(R) > 0\n            push!(res, (R[end], loc))\n        end\n    end\n    return res\nend\nnothing # hide","category":"page"},{"location":"man/reach_zonotopes_hybrid/#Continuous-algorithm","page":"A Hybrid Reachability Algorithm","title":"Continuous algorithm","text":"","category":"section"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"This is basically the same implementation as outlined in the section A Reachability Algorithm Using Zonotopes, only that this time we use concrete operations on zonotopes.","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"function reach_continuous(A, X0, δ, μ, T, max_order)\n    # bloating factors\n    Anorm = norm(A, Inf)\n    α = (exp(δ*Anorm) - 1 - δ*Anorm)/norm(X0, Inf)\n    β = (exp(δ*Anorm) - 1)*μ/Anorm\n\n    # discretized system\n    n = size(A, 1)\n    ϕ = exp(δ*A)\n    N = floor(Int, T/δ)\n\n    # preallocate array\n    R = Vector{LazySet}(undef, N)\n    if N == 0\n        return R\n    end\n\n    # initial reach set in the time interval [0, δ]\n    ϕp = (I+ϕ)/2\n    ϕm = (I-ϕ)/2\n    c = X0.center\n    gens = hcat(ϕp * X0.generators, ϕm * c, ϕm * X0.generators)\n    R[1] = minkowski_sum(Zonotope(ϕp * c, gens),\n                         Zonotope(zeros(n), Matrix((α + β)*I, n, n)))\n    if order(R[1]) > max_order\n        R[1] = reduce_order(R[1], max_order)\n    end\n\n    # set recurrence for [δ, 2δ], ..., [(N-1)δ, Nδ]\n    ballβ = Zonotope(zeros(n), Matrix(β*I, n, n))\n    for i in 2:N\n        R[i] = minkowski_sum(linear_map(ϕ, R[i-1]), ballβ)\n        if order(R[i]) > max_order\n            R[i] = reduce_order(R[i], max_order)\n        end\n    end\n    return R\nend\nnothing # hide","category":"page"},{"location":"man/reach_zonotopes_hybrid/#Plotting-results","page":"A Hybrid Reachability Algorithm","title":"Plotting results","text":"","category":"section"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"For illustration purposes it is helpful to plot the flowpipes in different colors, depending on the current mode. The following function does that for 2-mode models.","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"function plot_res(res)\n    p = plot()\n    for i in 1:length(res)\n        if res[i][2] == 1\n            c = \"blue\"\n        elseif res[i][2] == 2\n            c = \"red\"\n        end\n        plot!(p, reduce_order(res[i][1], 2), color=c, alpha=0.1)\n    end\n    return p\nend\nnothing # hide","category":"page"},{"location":"man/reach_zonotopes_hybrid/#Example","page":"A Hybrid Reachability Algorithm","title":"Example","text":"","category":"section"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"We consider an extension of the example presented in Reachability of uncertain linear systems using zonotopes, A. Girard, HSCC. Vol. 5. 2005 to a hybrid system with two modes ell_i, i = 1 2, with initial states 09 11 times -01 01 and uncertain inputs from a set u with mu = Vert u Vert_infty = 0001.","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"The dynamics matrices A_i are defined as follows:","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"\tA_1 = beginpmatrix -1  -4  4  -1 endpmatrix qquad A_2 = beginpmatrix 1  4  -4  -1 endpmatrix","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"We add a transition t_i from mode ell_i to ell_3-i with a hyperplane guard g_i:","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"\tg_1 triangleq x_1 = -05 qquad g_2 triangleq x_2 = -03","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"LazySets offers an order reduction function for zonotopes, which we used here with an upper bound of 10 generators. We plot the reachable states for the time interval 0 4 and time step δ = 0001.","category":"page"},{"location":"man/reach_zonotopes_hybrid/","page":"A Hybrid Reachability Algorithm","title":"A Hybrid Reachability Algorithm","text":"    # dynamics\n    A1 = [-1 -4; 4 -1]\n    A2 = [1 4; -4 -1]\n    As = [A1, A2]\n\n    # transitions\n    t1 = [(Hyperplane([1., 0.], -0.5), 2)]\n    t2 = [(Hyperplane([0., 1.], -0.3), 1)]\n    Ts = [t1, t2]\n\n    # initial condition\n    X0 = Zonotope([1.0, 0.0], Matrix(0.1*I, 2, 2))\n    init_loc = 1\n    init = (X0, init_loc)\n\n    # input uncertainty\n    μ = 0.001\n\n    # discretization step\n    δ = 0.001\n\n    # time bound\n    T = 4.\n\n    # maximum order of zonotopes\n    max_order = 10\n\n    # take transitions only the first time they are enabled?\n    instant_transitions = true\n\n    # run analysis\n    res = reach_hybrid(As, Ts, init, δ, μ, T, max_order, instant_transitions)\n\n    # plot result\n    plot_res(res)","category":"page"},{"location":"man/lazy_intersections/#Lazy-Intersections","page":"Lazy Intersections","title":"Lazy Intersections","text":"","category":"section"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"In this section we illustrate the use of lazy intersection in LazySets. We will use the ellipsoid set type.","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"Pages = [\"lazy_intersections.md\"]\nDepth = 3","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"An ellipsoid E can be created by giving its center c and its shape matrix Q, which should be positive definite, i.e. its eigenvalues must be positive. Mathematically, it is the set","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"    E =  x  mathbbR^n  (x-c)Q^-1(x-c)  1","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"Let's make two rotated ellipsoids and plot them in the same pair of axes.","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"using Plots, LazySets\n\nE₁ = Ellipsoid(zeros(2), [1 0; 0 2.])\nE₂ = Ellipsoid(ones(2), [2 0; 0 1.])\n\npell = plot(E₁, aspectratio=1)\npell = plot!(pell, E₂)","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"note: Note\nThe accuracy to which this set is plotted can be controlled by passing a numerical argument as in plot(E₁, 1e-3, aspectratio=1). Here, 1e-3 stands for an upper-bound on the error, measured in terms of the Hausdorff distance between the ellipsoid and the polygonal overapproximation which is actually computed for display.","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"Now let's take the lazy intersection of the ellipses:","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"Z = E₁ ∩ E₂\ntypeof(Z)","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"On the other hand, the concrete intersection of sets, called intersection in LazySets, is not yet available for ellipsoids:","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"hasmethod(intersection, Tuple{typeof(E₁), typeof(E₂)})","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"So how can we work with the intersection of the ellipsoids?","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"One way is to overapproximate them by polygons (or polytopes in higher dims) and then take their intersection, because this function is defined, whose return type is again a HPolytope:","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"hasmethod(intersection, Tuple{HPolytope{Float64}, HPolytope{Float64}})","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"import LazySets.Approximations.overapproximate\n\n# the parameter epsilon controls the accuracy of the iterative refinement,\n# with respect to the Hausdorff distance\nH₁(ε) = overapproximate(E₁, HPolygon, ε)\nH₂(ε) = overapproximate(E₂, HPolygon, ε)\n\n# using the concrete hpolytope-hpolytope intersection here\nHint(ε) = intersection(convert.(HPolytope, [H₁(ε), H₂(ε)])...);","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"pell = plot(E₁, aspectratio=1)\npell = plot!(pell, E₂)\npεsmaller = plot!(pell, convert(HPolygon, Hint(0.5)), alpha=.4)\n\npell = plot(E₁, aspectratio=1)\npell = plot!(pell, E₂)\npεbigger = plot!(pell, convert(HPolygon, Hint(0.05)), alpha=.4)\n\nplot(pεsmaller, pεbigger, layout=(1, 2))","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"Note how dividing the varepsilon threshold by 10 makes the polygonal overapproximation of the intersection tighter.","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"Yet another approach is to directly query the directions of the lazy intersection E₁ ∩ E₂. We can overapproximate using template directions, such as a box, an octagon, or other.","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"The idea behind the template overapproximation method is to use the property that the support function of the intersection of two convex sets is upper bounded by the min of the support function of each set. We can see in the following experiments that the resulting set is quite tight.","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"using Polyhedra\n\n# overapproximate the lazy intersection using a box\nXbox = overapproximate(E₁ ∩ E₂, BoxDirections(2))\n\n# overapproximate the lazy intersection using octagonal directions\nXoct = overapproximate(E₁ ∩ E₂, OctDirections(2))\n\npell = plot(E₁, aspectratio=1)\npell = plot!(pell, E₂)\npbox = plot!(pell, Xbox, alpha=.4)\n\npell = plot(E₁, aspectratio=1)\npell = plot!(pell, E₂)\npoct = plot!(pell, Xoct, alpha=.4)\n\nplot(pbox, poct, layout=(1, 2))","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"Using support function evaluations over a set of fixed directions is in general more efficient than iterative refinement, but the drawback is that one does not have control on the overapproximation error. Moreover, iterative refinement is currently only available in two dimensions, but overapproximation with template directions can be used in any dimension.","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"Let's time it!","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"using BenchmarkTools\n\n@btime overapproximate($E₁ ∩ $E₂, BoxDirections(2))\n@btime overapproximate($E₁ ∩ $E₂, OctDirections(2));","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"We can work with higher dimensional ellipsoids as well:","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"using LinearAlgebra\n\n# a random ellipsoid in n-dimensions\nfunction rand_ellipsoid(n)\n    A = rand(n,n)\n    Q = (A+transpose(A))/2 + n * I\n    Ellipsoid(rand(n), Q)\nend;","category":"page"},{"location":"man/lazy_intersections/","page":"Lazy Intersections","title":"Lazy Intersections","text":"for n in [2, 5, 50, 100]\n    println(\"\\nn = $n\\n\")\n    global E₁, E₂ = rand_ellipsoid(n), rand_ellipsoid(n)\n\n    # overapproximate the lazy intersection using an n-dimensional box\n    @btime overapproximate($E₁ ∩ $E₂, BoxDirections($n))\n    \n    # overapproximate the lazy intersection using octagonal directions in R^n\n    @btime overapproximate($E₁ ∩ $E₂, OctDirections($n))\nend;","category":"page"},{"location":"lib/parallel/#Parallel","page":"Parallel","title":"Parallel","text":"","category":"section"},{"location":"lib/parallel/","page":"Parallel","title":"Parallel","text":"This section of the manual describes the parallel implementation of some algorithms in the LazySets library. These algorithms are implemented in the LazySets.Parallel module.","category":"page"},{"location":"lib/parallel/","page":"Parallel","title":"Parallel","text":"Pages = [\"parallel.md\"]\nDepth = 3","category":"page"},{"location":"lib/parallel/","page":"Parallel","title":"Parallel","text":"CurrentModule = LazySets.Parallel","category":"page"},{"location":"lib/parallel/","page":"Parallel","title":"Parallel","text":"Parallel","category":"page"},{"location":"lib/parallel/#LazySets.Parallel","page":"Parallel","title":"LazySets.Parallel","text":"Module Parallel.jl – LazySets algorithms that are parallelized.\n\n\n\n\n\n","category":"module"},{"location":"lib/parallel/#Box-approximations","page":"Parallel","title":"Box approximations","text":"","category":"section"},{"location":"lib/parallel/","page":"Parallel","title":"Parallel","text":"LazySets.Parallel.interval_hull\nLazySets.Parallel.box_approximation\nLazySets.Parallel.symmetric_interval_hull\nLazySets.Parallel.box_approximation_symmetric\nLazySets.Parallel.box_approximation_helper_parallel\nLazySets.Parallel.process_chunk!","category":"page"},{"location":"lib/parallel/#LazySets.Parallel.interval_hull","page":"Parallel","title":"LazySets.Parallel.interval_hull","text":"interval_hull\n\nAlias for box_approximation.\n\n\n\n\n\n","category":"function"},{"location":"lib/parallel/#LazySets.Parallel.box_approximation","page":"Parallel","title":"LazySets.Parallel.box_approximation","text":"box_approximation(S::LazySet{N}) where {N<:Real}\n\nOverapproximation a convex set by a tight hyperrectangle using a parallel algorithm.\n\nInput\n\nS – convex set\n\nOutput\n\nA tight hyperrectangle.\n\nAlgorithm\n\nThe center of the hyperrectangle is obtained by averaging the support function of the given set in the canonical directions, and the lengths of the sides can be recovered from the distance among support functions in the same directions.\n\n\n\n\n\n","category":"function"},{"location":"lib/parallel/#LazySets.Parallel.symmetric_interval_hull","page":"Parallel","title":"LazySets.Parallel.symmetric_interval_hull","text":"symmetric_interval_hull\n\nAlias for box_approximation_symmetric.\n\n\n\n\n\n","category":"function"},{"location":"lib/parallel/#LazySets.Parallel.box_approximation_symmetric","page":"Parallel","title":"LazySets.Parallel.box_approximation_symmetric","text":"box_approximation_symmetric(S::LazySet{N}) where {N<:Real}\n\nOverapproximate a convex set by a tight hyperrectangle centered in the origin, using a parallel algorithm.\n\nInput\n\nS – convex set\n\nOutput\n\nA tight hyperrectangle centered in the origin.\n\nAlgorithm\n\nThe center of the box is the origin, and the radius is obtained by computing the maximum value of the support function evaluated at the canonical directions.\n\n\n\n\n\n","category":"function"},{"location":"lib/parallel/#LazySets.Parallel.box_approximation_helper_parallel","page":"Parallel","title":"LazySets.Parallel.box_approximation_helper_parallel","text":"box_approximation_helper_parallel(S::LazySet{N}) where {N<:Real}\n\nParallel implementation for the common code of box_approximation and box_approximation_symmetric.\n\nInput\n\nS – convex set\n\nOutput\n\nA tuple containing the data that is needed to construct a tightly overapproximating hyperrectangle.\n\nc – center\nr – radius\n\nAlgorithm\n\nThe center of the hyperrectangle is obtained by averaging the support function of the given convex set in the canonical directions. The lengths of the sides can be recovered from the distance among support functions in the same directions.\n\nThe same load is distributed among all available workers, see distribute_task!.\n\n\n\n\n\n","category":"function"},{"location":"lib/parallel/#LazySets.Parallel.process_chunk!","page":"Parallel","title":"LazySets.Parallel.process_chunk!","text":"process_chunk!(S::LazySet{N},\n               irange::UnitRange{Int},\n               c::SharedVector{N}, r::SharedVector{N}) where {N<:Real}\n\nKernel to process a given chunk \n\nInput\n\nc      – shared vector with the center of the hyperrectangle\nr      – shared vector with the center of the hyperrectangle\nS      – set\nirange – indices range of the given worker\n\nAlgorithm\n\nThe center of the hyperrectangle is obtained by averaging the support function of the given convex set in the canonical directions. The lengths of the sides can be recovered from the distance among support functions in the same directions.\n\nThe load for each worker is passed through the irange argument. By default, the same load is distributed among all available workers. For details see distribute_task!.\n\n\n\n\n\n","category":"function"},{"location":"lib/parallel/#Distributed-functions","page":"Parallel","title":"Distributed functions","text":"","category":"section"},{"location":"lib/parallel/","page":"Parallel","title":"Parallel","text":"LazySets.Parallel.assign_chunk!\nLazySets.Parallel.distribute_task!\nLazySets.Parallel._prange","category":"page"},{"location":"lib/parallel/#LazySets.Parallel.assign_chunk!","page":"Parallel","title":"LazySets.Parallel.assign_chunk!","text":"assign_chunk!(S::LazySet{N}, v::SharedVector{N}...) where {N<:Real}\n\nReturn the function that assigns the work for each process.\n\nInput\n\nS – convex set\nv – variable number of shared vectors\n\nOutput\n\nThe function process_chunk! that equally distributes the load for each worker.\n\nNotes\n\nUse this function to distribute a given task acting on a set S and a pool v of shared vectors. The tasks are equally distributed among the number of processes.\n\nSee also distribute_task!.\n\n\n\n\n\n","category":"function"},{"location":"lib/parallel/#LazySets.Parallel.distribute_task!","page":"Parallel","title":"LazySets.Parallel.distribute_task!","text":"distribute_task!(S::LazySet{N}, v::SharedVector{N}...) where {N<:Real}\n\nDistribute the assignment of each chunk among the available processes.\n\nInput\n\nS – convex set\nv – variable number of shared vectors\n\nOutput\n\nNothing.\n\nNotes\n\nUse this function to distribute a given task acting on a set S and a pool v of shared vectors.\n\nThe task for each processor is distributed through remotecall_wait using a function assign_chunk! that should be defined elsewhere. The vectors v contain one or more shared vectors in which the values of the task are written.\n\nTypically, the function assign_chunk! is a wrapper around some problem-specific process_chunk! function.\n\n\n\n\n\n","category":"function"},{"location":"lib/parallel/#LazySets.Parallel._prange","page":"Parallel","title":"LazySets.Parallel._prange","text":"_prange(v::SharedVector{N}) where {N<:Real}\n\nReturns the indexes assigned to a process.\n\nInput\n\nv – shared vector of length n\n\nOutput\n\nThe indices range assigned to each process.\n\nNotes\n\nThe indices are assigned such that the vector is equally distributed among the processes. If the worker is not assigned a piece, the unit range 1:0 is returned.\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/#Exponential-map","page":"ExponentialMap","title":"Exponential map","text":"","category":"section"},{"location":"lib/lazy_operations/ExponentialMap/#def_ExponentialMap","page":"ExponentialMap","title":"Exponential map (ExponentialMap)","text":"","category":"section"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"ExponentialMap\ndim(::ExponentialMap)\nρ(::AbstractVector{N}, ::ExponentialMap{N}) where {N<:Real}\nσ(::AbstractVector{N}, ::ExponentialMap{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::ExponentialMap{N}) where {N<:Real}\nisbounded(::ExponentialMap)\nvertices_list(::ExponentialMap{N}) where {N<:Real}","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.ExponentialMap","page":"ExponentialMap","title":"LazySets.ExponentialMap","text":"ExponentialMap{N<:Real, S<:LazySet{N}} <: AbstractAffineMap{N, S}\n\nType that represents the action of an exponential map on a convex set.\n\nFields\n\nspmexp – sparse matrix exponential\nX      – convex set\n\nExamples\n\nThe ExponentialMap type is overloaded to the usual times * operator when the linear map is a lazy matrix exponential. For instance,\n\njulia> using SparseArrays\n\njulia> A = sprandn(100, 100, 0.1);\n\njulia> E = SparseMatrixExp(A);\n\njulia> B = BallInf(zeros(100), 1.);\n\njulia> M = E * B; # represents the image set: exp(A) * B\n\njulia> M isa ExponentialMap\ntrue\n\njulia> dim(M)\n100\n\nThe application of an ExponentialMap to a ZeroSet or an EmptySet is simplified automatically.\n\njulia> E * ZeroSet(100)\nZeroSet{Float64}(100)\n\njulia> E * EmptySet(2)\nEmptySet{Float64}(2)\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.dim-Tuple{ExponentialMap}","page":"ExponentialMap","title":"LazySets.dim","text":"dim(em::ExponentialMap)\n\nReturn the dimension of an exponential map.\n\nInput\n\nem – an ExponentialMap\n\nOutput\n\nThe ambient dimension of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ExponentialMap{N,S} where S<:LazySet{N}}} where N<:Real","page":"ExponentialMap","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, em::ExponentialMap{N}) where {N<:Real}\n\nReturn the support function of the exponential map.\n\nInput\n\nd  – direction\nem – exponential map\n\nOutput\n\nThe support function in the given direction.\n\nNotes\n\nIf E = exp(M)S, where M is a matrix and S is a convex set, it follows that ρ(d E) = ρ(exp(M)^T d S) for any direction d.\n\nWe allow sparse direction vectors, but will convert them to dense vectors to be able to use expmv.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ExponentialMap{N,S} where S<:LazySet{N}}} where N<:Real","page":"ExponentialMap","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, em::ExponentialMap{N}) where {N<:Real}\n\nReturn the support vector of the exponential map.\n\nInput\n\nd  – direction\nem – exponential map\n\nOutput\n\nThe support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\nNotes\n\nIf E = exp(M)S, where M is a matrix and S is a convex set, it follows that σ(d E) = exp(M)σ(exp(M)^T d S) for any direction d.\n\nWe allow sparse direction vectors, but will convert them to dense vectors to be able to use expmv.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},ExponentialMap{N,S} where S<:LazySet{N}}} where N<:Real","page":"ExponentialMap","title":"Base.:∈","text":"∈(x::AbstractVector{N}, em::ExponentialMap{N}) where {N<:Real}\n\nCheck whether a given point is contained in an exponential map of a convex set.\n\nInput\n\nx  – point/vector\nem – exponential map of a convex set\n\nOutput\n\ntrue iff x  em.\n\nAlgorithm\n\nThis implementation exploits that x  exp(M)S iff exp(-M)x  S. This follows from exp(-M)exp(M) = I for any M.\n\nExamples\n\njulia> using SparseArrays\n\njulia> em = ExponentialMap(\n        SparseMatrixExp(sparse([1, 2], [1, 2], [2.0, 1.0], 2, 2)),\n        BallInf([1., 1.], 1.));\n\njulia> [-1.0, 1.0] ∈ em\nfalse\njulia> [1.0, 1.0] ∈ em\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.isbounded-Tuple{ExponentialMap}","page":"ExponentialMap","title":"LazySets.isbounded","text":"isbounded(em::ExponentialMap)\n\nDetermine whether an exponential map is bounded.\n\nInput\n\nem – exponential map\n\nOutput\n\ntrue iff the exponential map is bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.vertices_list-Union{Tuple{ExponentialMap{N,S} where S<:LazySet{N}}, Tuple{N}} where N<:Real","page":"ExponentialMap","title":"LazySets.vertices_list","text":"vertices_list(em::ExponentialMap{N}) where {N<:Real}\n\nReturn the list of vertices of a (polytopic) exponential map.\n\nInput\n\nem – exponential map\n\nOutput\n\nA list of vertices.\n\nAlgorithm\n\nWe assume that the underlying set X is polytopic. Then the result is just the exponential map applied to the vertices of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"Inherited from AbstractAffineMap:","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"an_element\nisempty\nconstraints_list\nlinear_map","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/#Sparse-matrix-exponential","page":"ExponentialMap","title":"Sparse matrix exponential","text":"","category":"section"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"SparseMatrixExp\n*(::SparseMatrixExp{N}, ::LazySet{N}) where {N<:Real}\nget_row(::SparseMatrixExp, ::Int)","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.SparseMatrixExp","page":"ExponentialMap","title":"LazySets.SparseMatrixExp","text":"SparseMatrixExp{N}\n\nType that represents the matrix exponential, exp(M), of a sparse matrix.\n\nFields\n\nM – sparse matrix; it should be square\n\nExamples\n\nTake for example a random sparse matrix of dimensions 100  100 and with occupation probability 01:\n\njulia> using SparseArrays\n\njulia> A = sprandn(100, 100, 0.1);\n\njulia> using Expokit\n\njulia> E = SparseMatrixExp(A);\n\njulia> size(E)\n(100, 100)\n\nHere E is a lazy representation of exp(A). To compute with E, use get_row and get_column resp. get_rows and get_columns. These functions return row and column vectors (or matrices). For example:\n\njulia> get_row(E, 10); # compute E[10, :]\n\njulia> get_column(E, 10); # compute E[:, 10]\n\njulia> get_rows(E, [10]); # same as get_row(E, 10) but a 1x100 matrix is returned\n\njulia> get_columns(E, [10]); # same as get_column(E, 10) but a 100x1 matrix is returned\n\nNotes\n\nThis type is provided for use with very large and very sparse matrices. The evaluation of the exponential matrix action over vectors relies on the Expokit package. Hence, you will have to install and load this optional dependency to have access to the functionality of SparseMatrixExp.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/ExponentialMap/#Base.:*-Union{Tuple{N}, Tuple{SparseMatrixExp{N,MN} where MN<:(SparseArrays.AbstractSparseArray{N,Ti,2} where Ti),LazySet{N}}} where N<:Real","page":"ExponentialMap","title":"Base.:*","text":"    *(spmexp::SparseMatrixExp{N}, X::LazySet{N}) where {N<:Real}\n\nReturn the exponential map of a convex set from a sparse matrix exponential.\n\nInput\n\nspmexp – sparse matrix exponential\nX      – convex set\n\nOutput\n\nThe exponential map of the convex set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.get_row-Tuple{SparseMatrixExp,Int64}","page":"ExponentialMap","title":"LazySets.get_row","text":"get_row(spmexp::SparseMatrixExp{N}, i::Int) where {N}\n\nReturn a single row of a sparse matrix exponential.\n\nInput\n\nspmexp – sparse matrix exponential\ni      – row index\n\nOutput\n\nA row vector corresponding to the ith row of the matrix exponential.\n\nNotes\n\nThis function uses Julia's transpose function to create the result. The result is of type Transpose; in Julia versions older than v0.7, the result was of type RowVector.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#def_ExponentialProjectionMap","page":"ExponentialMap","title":"Exponential projection map (ExponentialProjectionMap)","text":"","category":"section"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"ExponentialProjectionMap\ndim(::ExponentialProjectionMap)\nσ(::AbstractVector{N}, ::ExponentialProjectionMap{N}) where {N<:Real}\nisbounded(::ExponentialProjectionMap)","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.ExponentialProjectionMap","page":"ExponentialMap","title":"LazySets.ExponentialProjectionMap","text":"ExponentialProjectionMap{N<:Real, S<:LazySet{N}} <: AbstractAffineMap{N, S}\n\nType that represents the application of a projection of a sparse matrix exponential to a convex set.\n\nFields\n\nspmexp – projection of a sparse matrix exponential\nX      – convex set\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.dim-Tuple{ExponentialProjectionMap}","page":"ExponentialMap","title":"LazySets.dim","text":"dim(eprojmap::ExponentialProjectionMap)\n\nReturn the dimension of a projection of an exponential map.\n\nInput\n\neprojmap – projection of an exponential map\n\nOutput\n\nThe ambient dimension of the projection of an exponential map.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ExponentialProjectionMap{N,S} where S<:LazySet{N}}} where N<:Real","page":"ExponentialMap","title":"LazySets.σ","text":"σ(d::AbstractVector{N},\n  eprojmap::ExponentialProjectionMap{N}) where {N<:Real}\n\nReturn the support vector of a projection of an exponential map.\n\nInput\n\nd        – direction\neprojmap – projection of an exponential map\n\nOutput\n\nThe support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\nNotes\n\nIf S = (LMR)X, where L and R are matrices, M is a matrix exponential, and X is a set, it follows that σ(d S) = LMRσ(R^TM^TL^Td X) for any direction d.\n\nWe allow sparse direction vectors, but will convert them to dense vectors to be able to use expmv.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.isbounded-Tuple{ExponentialProjectionMap}","page":"ExponentialMap","title":"LazySets.isbounded","text":"isbounded(eprojmap::ExponentialProjectionMap)\n\nDetermine whether an exponential projection map is bounded.\n\nInput\n\neprojmap – exponential projection map\n\nOutput\n\ntrue iff the exponential projection map is bounded.\n\nAlgorithm\n\nWe first check if the left or right projection matrix is zero or the wrapped set is bounded. Otherwise, we check boundedness via isbounded_unit_dimensions.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"Inherited from AbstractAffineMap:","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"an_element\nisempty\n∈\nvertices_list\nconstraints_list\nlinear_map","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/#Projection-of-a-sparse-matrix-exponential","page":"ExponentialMap","title":"Projection of a sparse matrix exponential","text":"","category":"section"},{"location":"lib/lazy_operations/ExponentialMap/","page":"ExponentialMap","title":"ExponentialMap","text":"ProjectionSparseMatrixExp\n*(::ProjectionSparseMatrixExp, ::LazySet)","category":"page"},{"location":"lib/lazy_operations/ExponentialMap/#LazySets.ProjectionSparseMatrixExp","page":"ExponentialMap","title":"LazySets.ProjectionSparseMatrixExp","text":"ProjectionSparseMatrixExp{N<:Real}\n\nType that represents the projection of a sparse matrix exponential, i.e., Lexp(M)R for a given sparse matrix M.\n\nFields\n\nL – left multiplication matrix\nE – sparse matrix exponential\nR – right multiplication matrix\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/ExponentialMap/#Base.:*-Tuple{ProjectionSparseMatrixExp,LazySet}","page":"ExponentialMap","title":"Base.:*","text":"    *(projspmexp::ProjectionSparseMatrixExp, X::LazySet)\n\nReturn the application of a projection of a sparse matrix exponential to a convex set.\n\nInput\n\nprojspmexp – projection of a sparse matrix exponential\nX          – convex set\n\nOutput\n\nThe application of the projection of a sparse matrix exponential to the convex set.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/LineSegment/#def_LineSegment","page":"LineSegment","title":"Line segment (LineSegment)","text":"","category":"section"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"LineSegment\ndim(::LineSegment)\nσ(::AbstractVector{N}, ::LineSegment{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::LineSegment{N}) where {N<:Real}\ncenter(::LineSegment{N}) where {N<:Real}\nan_element(::LineSegment{N}) where {N<:Real}\nrand(::Type{LineSegment})\nhalfspace_left(::LineSegment)\nhalfspace_right(::LineSegment)\nvertices_list(::LineSegment{N}) where {N<:Real}\nconstraints_list(::LineSegment{N}) where {N<:Real}\ntranslate(::LineSegment{N}, ::AbstractVector{N}) where {N<:Real}\ngenerators(::LineSegment{N}) where {N<:Real}\ngenmat(::LineSegment)\nplot_recipe(::LineSegment{N}, ::N=zero(N)) where {N<:Real}\nRecipesBase.apply_recipe(::AbstractDict{Symbol,Any}, ::Union{LineSegment{N}, Interval{N}}, ::N=zero(N)) where {N<:Real}","category":"page"},{"location":"lib/sets/LineSegment/#LazySets.LineSegment","page":"LineSegment","title":"LazySets.LineSegment","text":"LineSegment{N<:Real, VN<:AbstractVector{N}} <: AbstractZonotope{N}\n\nType that represents a line segment in 2D between two points p and q.\n\nFields\n\np – first point\nq – second point\n\nExamples\n\nA line segment along the x = y diagonal:\n\njulia> s = LineSegment([0., 0], [1., 1.])\nLineSegment{Float64,Array{Float64,1}}([0.0, 0.0], [1.0, 1.0])\n\njulia> dim(s)\n2\n\nUse plot(s) to plot the extreme points of s and the line segment joining them. Membership test is computed with ∈ (in):\n\njulia> [0., 0] ∈ s && [.25, .25] ∈ s && [1., 1] ∈ s && [.5, .25] ∉ s\ntrue\n\nWe can check the intersection with another line segment, and optionally compute a witness (which is just the common point in this case):\n\njulia> sn = LineSegment([1., 0], [0., 1.])\nLineSegment{Float64,Array{Float64,1}}([1.0, 0.0], [0.0, 1.0])\n\njulia> isempty(s ∩ sn)\nfalse\n\njulia> is_intersection_empty(s, sn, true)\n(false, [0.5, 0.5])\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/LineSegment/#LazySets.dim-Tuple{LineSegment}","page":"LineSegment","title":"LazySets.dim","text":"dim(L::LineSegment)\n\nReturn the ambient dimension of a line segment.\n\nInput\n\nL – line segment\n\nOutput\n\nThe ambient dimension of the line segment, which is 2.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LineSegment{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"LineSegment","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, L::LineSegment{N}) where {N<:Real}\n\nReturn the support vector of a line segment in a given direction.\n\nInput\n\nd – direction\nL – line segment\n\nOutput\n\nThe support vector in the given direction.\n\nAlgorithm\n\nIf the angle between the vector q - p and d is bigger than 90° and less than 270° (measured in counter-clockwise order), the result is p, otherwise it is q. If the angle is exactly 90° or 270°, or if the direction has norm zero, this implementation returns q.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},LineSegment{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"LineSegment","title":"Base.:∈","text":"∈(x::AbstractVector{N}, L::LineSegment{N}) where {N<:Real}\n\nCheck whether a given point is contained in a line segment.\n\nInput\n\nx – point/vector\nL – line segment\n\nOutput\n\ntrue iff x  L.\n\nAlgorithm\n\nLet L = (p q) be the line segment with extremes p and q, and let x be the given point.\n\nA necessary condition for x  (p q) is that the three points are aligned, thus their cross product should be zero.\nIt remains to check that x belongs to the box approximation of L. This amounts to comparing each coordinate with those of the extremes p and q.\n\nNotes\n\nThe algorithm is inspired from here.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.center-Union{Tuple{LineSegment{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"LineSegment","title":"LazySets.center","text":"center(L::LineSegment{N}) where {N<:Real}\n\nReturn the center of a line segment.\n\nInput\n\nL – line segment\n\nOutput\n\nThe center of the line segment.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.an_element-Union{Tuple{LineSegment{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"LineSegment","title":"LazySets.an_element","text":"an_element(L::LineSegment{N}) where {N<:Real}\n\nReturn some element of a line segment.\n\nInput\n\nL – line segment\n\nOutput\n\nThe first vertex of the line segment.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#Base.rand-Tuple{Type{LineSegment}}","page":"LineSegment","title":"Base.rand","text":"rand(::Type{LineSegment}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nCreate a random line segment.\n\nInput\n\nLineSegment – type for dispatch\nN           – (optional, default: Float64) numeric type\ndim         – (optional, default: 2) dimension\nrng         – (optional, default: GLOBAL_RNG) random number generator\nseed        – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random line segment.\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.halfspace_left-Tuple{LineSegment}","page":"LineSegment","title":"LazySets.halfspace_left","text":"halfspace_left(L::LineSegment)\n\nReturn a half-space describing the 'left' of a two-dimensional line segment through two points.\n\nInput\n\nL – line segment\n\nOutput\n\nThe half-space whose boundary goes through the two points p and q and which describes the left-hand side of the directed line segment pq.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.halfspace_right-Tuple{LineSegment}","page":"LineSegment","title":"LazySets.halfspace_right","text":"halfspace_right(L::LineSegment)\n\nReturn a half-space describing the 'right' of a two-dimensional line segment through two points.\n\nInput\n\nL – line segment\n\nOutput\n\nThe half-space whose boundary goes through the two points p and q and which describes the right-hand side of the directed line segment pq.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.vertices_list-Union{Tuple{LineSegment{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"LineSegment","title":"LazySets.vertices_list","text":"vertices_list(L::LineSegment{N}) where {N<:Real}\n\nReturn the list of vertices of a line segment.\n\nInput\n\nL – line segment\n\nOutput\n\nThe list of end points of the line segment.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.constraints_list-Union{Tuple{LineSegment{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"LineSegment","title":"LazySets.constraints_list","text":"constraints_list(L::LineSegment{N}) where {N<:Real}\n\nReturn the list of constraints defining a line segment in 2D.\n\nInput\n\nL – line segment\n\nOutput\n\nA vector of constraints that define the line segment.\n\nAlgorithm\n\nL is defined by 4 constraints. In this algorithm, the first two constraints are returned by halfspace_right and halfspace_left, and the other two are obtained by considering the vector normal to the line segment that passes through each opposite vertex.\n\nNotes\n\nThis function returns a vector of halfspaces. It does not return equality constraints.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.translate-Union{Tuple{N}, Tuple{LineSegment{N,VN} where VN<:AbstractArray{N,1},AbstractArray{N,1}}} where N<:Real","page":"LineSegment","title":"LazySets.translate","text":"translate(L::LineSegment{N}, v::AbstractVector{N}) where {N<:Real}\n\nTranslate (i.e., shift) a line segment by a given vector.\n\nInput\n\nL – line segment\nv – translation vector\n\nOutput\n\nA translated line segment.\n\nAlgorithm\n\nWe add the vector to both defining points of the line segment.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.generators-Union{Tuple{LineSegment{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"LineSegment","title":"LazySets.generators","text":"generators(L::LineSegment{N}) where {N<:Real}\n\nReturn an iterator over the (single) generator of a line segment.\n\nInput\n\nL – line segment\n\nOutput\n\nA one-element iterator over the generator of L.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.genmat-Tuple{LineSegment}","page":"LineSegment","title":"LazySets.genmat","text":"genmat(L::LineSegment)\n\nReturn the generator matrix of a line segment.\n\nInput\n\nL – line segment\n\nOutput\n\nA matrix with a single column representing the generator of L.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#LazySets.plot_recipe-Union{Tuple{LineSegment{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}, Tuple{LineSegment{N,VN} where VN<:AbstractArray{N,1},N}} where N<:Real","page":"LineSegment","title":"LazySets.plot_recipe","text":"plot_recipe(L::LineSegment{N}, [ε]::N=zero(N)) where {N<:Real}\n\nConvert a line segment to a pair (x, y) of points for plotting.\n\nInput\n\nL – line segment\nε – (optional, default: 0) ignored, used for dispatch\n\nOutput\n\nA pair (x, y) of two points that can be plotted.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol,Any},Union{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}, LineSegment{N,VN} where VN<:AbstractArray{N,1}}}, Tuple{AbstractDict{Symbol,Any},Union{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}, LineSegment{N,VN} where VN<:AbstractArray{N,1}},N}} where N<:Real","page":"LineSegment","title":"RecipesBase.apply_recipe","text":"plot_linesegment(X::Union{Interval{N}, LineSegment{N}}, [ε]::N=zero(N); ...)\n    where {N<:Real}\n\nPlot a line segment or an interval.\n\nInput\n\nX – line segment or interval\nε – (optional, default: 0) ignored, used for dispatch\n\nExamples\n\njulia> L = LineSegment([0., 0.], [1., 1.]);\n\njulia> plot(L)\n\nTo control the color of the line, use the linecolor keyword argument, and to control the color of the end points, use the markercolor keyword argument. To control the width, use linewidth.\n\njulia> plot(L, markercolor=\"green\", linecolor=\"red\", linewidth=2.)\n\nTo omit the markers, use markershape=:none. You also need to pass a value for seriestype=:path explicitly (this seems to be an external bug).\n\njulia> plot(L, seriestype=:path, markershape=:none)\n\nA shorter alternative is to pass marker=0, but this may result in small dots as markers based on the plotting backend.\n\njulia> plot(L, marker=0)\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"isbounded\nisuniversal","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"isempty","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/sets/LineSegment/","page":"LineSegment","title":"LineSegment","text":"ngens\nlinear_map\norder\ntogrep","category":"page"},{"location":"lib/sets/PolynomialZonotope/","page":"PolynomialZonotope","title":"PolynomialZonotope","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/PolynomialZonotope/#def_PolynomialZonotope","page":"PolynomialZonotope","title":"Polynomial zonotope (PolynomialZonotope)","text":"","category":"section"},{"location":"lib/sets/PolynomialZonotope/","page":"PolynomialZonotope","title":"PolynomialZonotope","text":"PolynomialZonotope\ndim(::PolynomialZonotope)\nσ(::AbstractVector{N}, ::PolynomialZonotope{N}) where {N}\nρ(::AbstractVector{N}, ::PolynomialZonotope{N}) where {N}\npolynomial_order(pz::PolynomialZonotope)\norder(::PolynomialZonotope)\nlinear_map(::Matrix, ::PolynomialZonotope)\nscale(::Number, ::PolynomialZonotope)","category":"page"},{"location":"lib/sets/PolynomialZonotope/#LazySets.PolynomialZonotope","page":"PolynomialZonotope","title":"LazySets.PolynomialZonotope","text":"PolynomialZonotope{N}\n\nType that represents a polynomial zonotope.\n\nFields\n\nc  – starting point\nE  – matrix of multi-indexed generators such that all indices have the same value\nF  – matrix of multi-indexed generators such that not all indices have the same value\nG  – matrix of single-indexed generators\n\nNotes\n\nPolynomial zonotopes were introduced by M. Althoff in [1] and have been applied as a non-convex set representation in the reachability problem of nonlinear ODEs.\n\nMathematically, a polynomial zonotope is defined as the tuple (c E F G), where:\n\nc  mathbbR^n is the starting point (in some particular cases it corresponds to the center of a usual zonotope),\nE = E^1  E^η is an n  p  η(η+1)2 matrix with column-blocks\n\nE^i = f^(i 1 1  1)  f^(i p p  p) qquad i = 1 η\n\ncalled the matrix of multi-indexed generators with equal indices, where each f^(i k_1 k_2  k_i) is an n-vector,\n\nF = F^2  F^η is a matrix with column-blocks\n\nF^i = f^(i 1 1  1 2) f^(i 1 1  1 3)  f^(i 1 1  1 p) \nf^(i 1 1  2 2) f^(i 1 1  2 3)  f^(i 1 1  2 p) \nf^(i 1 1  3 3)  qquad i = 1 η\n\ncalled the matrix of multi-indexed generators with unequal indices (or, more accurately, not-all-equal indices), where each f^(i k_1 k_2  k_i) is an n-vector,\n\nG = G^1  G^q is an n  q matrix with columns\n\nG^i = g^(i) qquad i = 1 q\n\ncalled the matrix of single-indexed generators, where each g^(i) is an n-vector.\n\nThe polynomial zonotope (c E F G) defines the set:\n\nmathcalPZ = left c + _j=1^p β_j f^(1 j) + _j=1^p _k=j^p β_j β_k f^(2 j k) + \n+  + _j=1^p _k=j^p  _m=ℓ^p β_j β_k  β_m f^(η j k  m) + \n+ _i=1^q γ_i g^(i) qquad β_i γ_i  -1 1 right\n\nwhere the number of factors in the final product, β_j β_k  β_m, corresponds to the polynomial order η.\n\n[1] M. Althoff in Reachability analysis of nonlinear systems using conservative     polynomialization and non-convex sets, Hybrid Systems: Computation and     Control, 2013, pp. 173–182.\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/PolynomialZonotope/#LazySets.dim-Tuple{PolynomialZonotope}","page":"PolynomialZonotope","title":"LazySets.dim","text":"dim(pz::PolynomialZonotope)\n\nReturn the ambient dimension of a polynomial zonotope.\n\nInput\n\npz – polynomial zonotope\n\nOutput\n\nAn integer representing the ambient dimension of the polynomial zonotope.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/PolynomialZonotope/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},PolynomialZonotope{N}}} where N","page":"PolynomialZonotope","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, pz::PolynomialZonotope{N}) where {N}\n\nReturn the support vector of a polynomial zonotope along direction d.\n\nInput\n\nd  – direction\npz – polynomial zonotope\n\nOutput\n\nVector representing the support vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/PolynomialZonotope/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},PolynomialZonotope{N}}} where N","page":"PolynomialZonotope","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, pz::PolynomialZonotope{N}) where {N}\n\nReturn the support function of a polynomial zonotope along direction d.\n\nInput\n\nd  – direction\npz – polynomial zonotope\n\nOutput\n\nValue of the support function.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/PolynomialZonotope/#LazySets.polynomial_order-Tuple{PolynomialZonotope}","page":"PolynomialZonotope","title":"LazySets.polynomial_order","text":"polynomial_order(pz::PolynomialZonotope)\n\nPolynomial order of a polynomial zonotope.\n\nInput\n\npz – polynomial zonotope\n\nOutput\n\nThe polynomial order, defined as the maximal power of the scale factors β_i. Usually denoted η.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/PolynomialZonotope/#LazySets.order-Tuple{PolynomialZonotope}","page":"PolynomialZonotope","title":"LazySets.order","text":"order(pz::PolynomialZonotope)\n\nOrder of a polynomial zonotope.\n\nInput\n\npz – polynomial zonotope\n\nOutput\n\nThe order, a rational number defined as the total number of generators divided by the ambient dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/PolynomialZonotope/#LazySets.linear_map-Tuple{Array{T,2} where T,PolynomialZonotope}","page":"PolynomialZonotope","title":"LazySets.linear_map","text":"linear_map(M::Matrix, pz::PolynomialZonotope)\n\nReturn the linear map of a polynomial zonotope.\n\nInput\n\nM  – matrix\npz – polynomial zonotope\n\nOutput\n\nPolynomial zonotope such that its starting point and generators are those of pz multiplied by the matrix M.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/PolynomialZonotope/#LazySets.scale-Tuple{Number,PolynomialZonotope}","page":"PolynomialZonotope","title":"LazySets.scale","text":"scale(α::Number, pz::PolynomialZonotope)\n\nReturn a polynomial zonotope modified by a scale factor.\n\nInput\n\nα  – polynomial zonotope\npz – polynomial zonotope\n\nOutput\n\nPolynomial zonotope such that its center and generators are multiples of those of pz by a factor α.\n\n\n\n\n\n","category":"method"},{"location":"lib/approximations/#Approximations","page":"Approximations","title":"Approximations","text":"","category":"section"},{"location":"lib/approximations/","page":"Approximations","title":"Approximations","text":"This section of the manual describes the Cartesian decomposition algorithms and the approximation of high-dimensional convex sets using projections.","category":"page"},{"location":"lib/approximations/","page":"Approximations","title":"Approximations","text":"Pages = [\"approximations.md\"]\nDepth = 3","category":"page"},{"location":"lib/approximations/","page":"Approximations","title":"Approximations","text":"CurrentModule = LazySets.Approximations","category":"page"},{"location":"lib/approximations/","page":"Approximations","title":"Approximations","text":"Approximations","category":"page"},{"location":"lib/approximations/#LazySets.Approximations","page":"Approximations","title":"LazySets.Approximations","text":"Module Approximations.jl – polygonal approximation of convex sets through support vectors.\n\n\n\n\n\n","category":"module"},{"location":"lib/approximations/#Cartesian-Decomposition","page":"Approximations","title":"Cartesian Decomposition","text":"","category":"section"},{"location":"lib/approximations/","page":"Approximations","title":"Approximations","text":"decompose\nproject","category":"page"},{"location":"lib/approximations/#LazySets.Approximations.decompose","page":"Approximations","title":"LazySets.Approximations.decompose","text":"decompose(S::LazySet{N},\n          partition::AbstractVector{<:AbstractVector{Int}},\n          block_options\n         ) where {N<:Real}\n\nDecompose a high-dimensional set into a Cartesian product of overapproximations of the projections over the specified subspaces.\n\nInput\n\nS             – set\npartition     – vector of blocks (i.e., of vectors of integers) (see the                    Notes below)\nblock_options – mapping from block indices in partition to a                    corresponding overapproximation option; we only require                    access via [⋅] (but see also the Notes below)\n\nOutput\n\nA CartesianProductArray containing the low-dimensional approximated projections.\n\nAlgorithm\n\nFor each block a specific project method is called, dispatching on the corresponding overapproximation option.\n\nNotes\n\nThe argument partition requires some discussion. Typically, the list of blocks should form a partition of the set 1 dots n represented as a list of consecutive blocks, where n is the ambient dimension of set S.\n\nHowever, technically there is no problem if the blocks are not consecutive, blocks are missing, blocks occur more than once, or blocks are overlapping. This function will, however, stick to the order of blocks, so the resulting set must be interpreted with care in such cases. One use case is the need of a projection consisting of several blocks.\n\nFor convenience, the argument block_options can also be given as a single option instead of a mapping, which is then interpreted as the option for all blocks.\n\nExamples\n\nThis function supports different options: one can specify the target set, the degree of accuracy, and template directions. These options are exemplified below, where we use the following example.\n\njulia> using LazySets.Approximations: decompose\n\njulia> S = Ball2(zeros(4), 1.);  # set to be decomposed (4D 2-norm unit ball)\n\njulia> P2d = [1:2, 3:4];  # a partition with two blocks of size two\n\njulia> P1d = [[1], [2], [3], [4]];  # a partition with four blocks of size one\n\nDifferent set types\n\nWe can decompose using polygons in constraint representation:\n\njulia> all([ai isa HPolygon for ai in array(decompose(S, P2d, HPolygon))])\ntrue\n\nFor decomposition into 1D subspaces, we can use Interval:\n\njulia> all([ai isa Interval for ai in array(decompose(S, P1d, Interval))])\ntrue\n\nHowever, if you need to specify different set types for different blocks, the interface presented so far does not apply. See the paragraph Advanced input for different block approximations below for how to do that.\n\nRefining the decomposition I: ε-close approximation\n\nThe ε option can be used to refine a decomposition, i.e., obtain a more accurate result. We use the Iterative refinement algorithm from the Approximations module.\n\nTo illustrate this, consider again the set S from above. We decompose into two 2D polygons. Using smaller ε implies a better precision, thus more constraints in each 2D decomposition. In the following example, we look at the number of constraints in the first block.\n\njulia> d(ε, bi) = array(decompose(S, P2d, (HPolygon => ε)))[bi]\nd (generic function with 1 method)\n\njulia> [length(constraints_list(d(ε, 1))) for ε in [Inf, 0.1, 0.01]]\n3-element Array{Int64,1}:\n  4\n  8\n 32\n\nRefining the decomposition II: template polyhedra\n\nAnother way to refine a decomposition is by using template polyhedra. The idea is to specify a set of template directions and then to compute on each block the polytopic overapproximation obtained by evaluating the support function of the given input set over the template directions.\n\nFor example, octagonal 2D approximations of the set S are obtained with:\n\njulia> using LazySets.Approximations: OctDirections\n\njulia> B = decompose(S, P2d, OctDirections);\n\njulia> length(B.array) == 2 && all(dim(bi) == 2 for bi in B.array)\ntrue\n\nSee Template directions for the available template directions. Note that, in contrast to the polygonal ε-close approximation from above, this method can be applied to blocks of any size.\n\njulia> B = decompose(S, [1:4], OctDirections);\n\njulia> length(B.array) == 1 && dim(B.array[1]) == 4\ntrue\n\nAdvanced input for different block approximations\n\nInstead of defining the approximation option uniformly for each block, we can define different approximations for different blocks. The third argument has to be a mapping from block index (in the partition) to the corresponding approximation option.\n\nFor example:\n\njulia> res = array(decompose(S, P2d, Dict(1 => Hyperrectangle, 2 => 0.1)));\n\njulia> typeof(res[1]), typeof(res[2])\n(Hyperrectangle{Float64,Array{Float64,1},Array{Float64,1}}, HPolygon{Float64,Array{Float64,1}})\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/#LazySets.Approximations.project","page":"Approximations","title":"LazySets.Approximations.project","text":"project(S::LazySet{N},\n        block::AbstractVector{Int},\n        [::Nothing=nothing],\n        [n]::Int=dim(S)\n       ) where {N<:Real}\n\nProject a high-dimensional set to a given block by using a concrete linear map.\n\nInput\n\nS       – set\nblock   – block structure - a vector with the dimensions of interest\nnothing – (default: nothing) used for dispatch\nn       – (optional, default: dim(S)) ambient dimension of the set S\n\nOutput\n\nA set representing the projection of the set S to block block.\n\nAlgorithm\n\nWe apply the function linear_map.\n\n\n\n\n\nproject(S::LazySet{N},\n        block::AbstractVector{Int},\n        set_type::Type{<:LinearMap},\n        [n]::Int=dim(S)\n       ) where {N<:Real}\n\nProject a high-dimensional set to a given block by using a lazy linear map.\n\nInput\n\nS         – set\nblock     – block structure - a vector with the dimensions of interest\nLinearMap – used for dispatch\nn         – (optional, default: dim(S)) ambient dimension of the set S\n\nOutput\n\nA lazy LinearMap representing the projection of the set S to block block.\n\n\n\n\n\nproject(S::LazySet{N},\n        block::AbstractVector{Int},\n        set_type::Type{<:LazySet},\n        [n]::Int=dim(S)\n       ) where {N<:Real}\n\nProject a high-dimensional set to a given block and set type, possibly involving an overapproximation.\n\nInput\n\nS        – set\nblock    – block structure - a vector with the dimensions of interest\nset_type – target set type\nn        – (optional, default: dim(S)) ambient dimension of the set S\n\nOutput\n\nA set of type set_type representing an overapproximation of the projection of S.\n\nAlgorithm\n\nProject the set S with M⋅S, where M is the identity matrix in the block\n\ncoordinates and zero otherwise.\n\nOverapproximate the projected lazy set using overapproximate and\n\nset_type.\n\n\n\n\n\nproject(S::LazySet{N},\n        block::AbstractVector{Int},\n        set_type_and_precision::Pair{<:UnionAll, <:Real},\n        [n]::Int=dim(S)\n       ) where {N<:Real}\n\nProject a high-dimensional set to a given block and set type with a certified error bound.\n\nInput\n\nS     – set\nblock – block structure - a vector with the dimensions of interest\nset_type_and_precision – pair (T, ε) of a target set type T and an                             error bound ε for approximation\nn     – (optional, default: dim(S)) ambient dimension of the set S\n\nOutput\n\nA set representing the epsilon-close approximation of the projection of S.\n\nNotes\n\nCurrently we only support HPolygon as set type, which implies that the set must be two-dimensional.\n\nAlgorithm\n\nProject the set S with M⋅S, where M is the identity matrix in the block\n\ncoordinates and zero otherwise.\n\nOverapproximate the projected lazy set with the given error bound ε.\n\n\n\n\n\nproject(S::LazySet{N},\n        block::AbstractVector{Int},\n        ε::Real,\n        [n]::Int=dim(S)\n       ) where {N<:Real}\n\nProject a high-dimensional set to a given block and set type with a certified error bound.\n\nInput\n\nS     – set\nblock – block structure - a vector with the dimensions of interest\nε     – error bound for approximation\nn     – (optional, default: dim(S)) ambient dimension of the set S\n\nOutput\n\nA set representing the epsilon-close approximation of the projection of S.\n\nAlgorithm\n\nProject the set S with M⋅S, where M is the identity matrix in the block\n\ncoordinates and zero otherwise.\n\nOverapproximate the projected lazy set with the given error bound ε.\n\nThe target set type is chosen automatically.\n\n\n\n\n\nproject(S::LazySet{N},\n        block::AbstractVector{Int},\n        directions::Type{<:AbstractDirections},\n        [n]::Int\n       ) where {N<:Real}\n\nProject a high-dimensional set to a given block using template directions.\n\nInput\n\nS          – set\nblock      – block structure - a vector with the dimensions of interest\ndirections – template directions\nn          – (optional, default: dim(S)) ambient dimension of the set S\n\nOutput\n\nThe template direction approximation of the projection of S.\n\n\n\n\n\nproject(H::HalfSpace{N}, block::AbstractVector{Int})\n\nConcrete projection of a half-space.\n\nInput\n\nH        – set\nblock    – block structure, a vector with the dimensions of interest\n\nOutput\n\nA set representing the projection of the half-space H on the dimensions specified by block.\n\nAlgorithm\n\nIf the unconstrained dimensions of H are a subset of the block variables, the projection is applied to the normal direction of H. Otherwise, the projection results in the universal set.\n\nThe latter can be seen as follows. Without loss of generality consider a projection onto a single and constrained dimension xₖ (projections in multiple dimensions can be modeled as repeated one-dimensional projections). We can write the projection as an existentially quantified linear constraint:\n\n    xₖ a₁x₁ +  + aₖxₖ +  + aₙxₙ  b\n\nSince aₖ  0, there is always a value for xₖ that satisfies the constraint for any valuation of the other variables.\n\nExamples\n\nConsider the half-space x + y + 0z  1, whose ambient dimension is 3. The (trivial) projection in the three dimensions is achieved letting the block of variables to be [1, 2, 3]:\n\njulia> H = HalfSpace([1.0, 1.0, 0.0], 1.0)\nHalfSpace{Float64,Array{Float64,1}}([1.0, 1.0, 0.0], 1.0)\n\njulia> project(H, [1, 2, 3])\nHalfSpace{Float64,Array{Float64,1}}([1.0, 1.0, 0.0], 1.0)\n\nProjecting along dimensions 1 and 2 only:\n\njulia> project(H, [1, 2])\nHalfSpace{Float64,Array{Float64,1}}([1.0, 1.0], 1.0)\n\nIn general, use the call syntax project(H, constrained_dimensions(H)) to return the half-space projected on the dimensions where it is constrained only:\n\njulia> project(H, constrained_dimensions(H))\nHalfSpace{Float64,Array{Float64,1}}([1.0, 1.0], 1.0)\n\nIf a constrained dimension is projected, we get the universal set of the dimension corresponding to the projection.\n\njulia> project(H, [1, 3])\nUniverse{Float64}(2)\n\njulia> project(H, [1])\nUniverse{Float64}(1)\n\n\n\n\n\nproject(P::AbstractPolyhedron{N}, block::AbstractVector{Int}) where {N}\n\nConcrete projection of a polyhedral set.\n\nInput\n\nP        – set\nblock    – block structure, a vector with the dimensions of interest\n\nOutput\n\nA polyhedron representing the projection of P on the dimensions specified by block. If P was bounded, the result is an HPolytope; otherwise the result is an HPolyhedron.\n\nAlgorithm\n\nIf the unconstrained dimensions of P are a subset of the block variables, each half-sace c of P is transformed to HalfSpace(c.a[block], c.b).\nIn the general case, we compute the concrete linear map of the projection matrix associated to the given block structure.\n\nExamples\n\nConsider the four-dimensional cross-polytope (unit ball in the 1-norm):\n\njulia> P = Ball1(zeros(4), 1.0);\n\nAll dimensions are constrained, and computing the (trivial) projection on the whole space behaves as expected:\n\njulia> constrained_dimensions(P)\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> P_1234 = project(P, [1, 2, 3, 4]);\n\njulia> P_1234 == convert(HPolytope, P)\ntrue\n\nEach constraint of the cross polytope is constrained in all dimensions.\n\nNow let's take a ball in the infinity norm and remove some constraints:\n\njulia> B = BallInf(zeros(4), 1.0);\n\njulia> c = constraints_list(B)[1:2]\n2-element Array{HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}},1}:\n HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([1.0, 0.0, 0.0, 0.0], 1.0)\n HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([0.0, 1.0, 0.0, 0.0], 1.0)\n\njulia> P = HPolyhedron(c);\n\njulia> constrained_dimensions(P)\n2-element Array{Int64,1}:\n 1\n 2\n\nFinally we take the concrete projection onto variables 1 and 2:\n\njulia> project(P, [1, 2]) |> constraints_list\n2-element Array{HalfSpace{Float64,Array{Float64,1}},1}:\n HalfSpace{Float64,Array{Float64,1}}([1.0, 0.0], 1.0)\n HalfSpace{Float64,Array{Float64,1}}([0.0, 1.0], 1.0)\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/#Convenience-functions","page":"Approximations","title":"Convenience functions","text":"","category":"section"},{"location":"lib/approximations/","page":"Approximations","title":"Approximations","text":"uniform_partition","category":"page"},{"location":"lib/approximations/#LazySets.Approximations.uniform_partition","page":"Approximations","title":"LazySets.Approximations.uniform_partition","text":" uniform_partition(n::Int, block_size::Int)\n\nCompute a uniform block partition of the given size.\n\nInput\n\nn          – number of dimensions of the partition\nblock_size – size of each block\n\nOutput\n\nA vector of ranges, Vector{UnitRange{Int}}, such that the size of each block is the same, if possible.\n\nExamples\n\nIf the number of dimensions n is 2, we have two options: either two blocks of size 1 or one block of size 2:\n\njulia> LazySets.Approximations.uniform_partition(2, 1)\n2-element Array{UnitRange{Int64},1}:\n 1:1\n 2:2\n\njulia> LazySets.Approximations.uniform_partition(2, 2)\n1-element Array{UnitRange{Int64},1}:\n 1:2\n\nIf the block size argument is not compatible with (i.e. does not divide) n, the output is filled with one block of the size needed to reach n:\n\njulia> LazySets.Approximations.uniform_partition(3, 1)\n3-element Array{UnitRange{Int64},1}:\n 1:1\n 2:2\n 3:3\n\njulia> LazySets.Approximations.uniform_partition(3, 2)\n2-element Array{UnitRange{Int64},1}:\n 1:2\n 3:3\n\njulia> LazySets.Approximations.uniform_partition(10, 6)\n2-element Array{UnitRange{Int64},1}:\n 1:6\n 7:10\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/#Overapproximations","page":"Approximations","title":"Overapproximations","text":"","category":"section"},{"location":"lib/approximations/","page":"Approximations","title":"Approximations","text":"overapproximate","category":"page"},{"location":"lib/approximations/#LazySets.Approximations.overapproximate","page":"Approximations","title":"LazySets.Approximations.overapproximate","text":"overapproximate(X::S, ::Type{S}, args...) where {S<:LazySet}\n\nOverapproximating a set of type S with type S is a no-op.\n\nInput\n\nX       – set\nType{S} – target set type\nargs    – further arguments (ignored)\n\nOutput\n\nThe input set.\n\n\n\n\n\noverapproximate(S::LazySet{N},\n                ::Type{<:HPolygon},\n                [ε]::Real=Inf) where {N<:Real}\n\nReturn an approximation of a given 2D set using iterative refinement.\n\nInput\n\nS        – convex set, assumed to be two-dimensional\nHPolygon – type for dispatch\nε        – (optional, default: Inf) error tolerance\n\nOutput\n\nA polygon in constraint representation.\n\nNotes\n\nThe result is always a convex overapproximation of the input set.\n\nIf no error tolerance ε is given, or is Inf, the result is a box-shaped polygon. For convex input sets, the result is an ε-close approximation as a polygon, with respect to the Hausdorff distance.\n\n\n\n\n\noverapproximate(S::LazySet, ε::Real)\n\nAlias for overapproximate(S, HPolygon, ε).\n\n\n\n\n\noverapproximate(S::LazySet, Type{<:Hyperrectangle})\n\nReturn an approximation of a given set as a hyperrectangle.\n\nInput\n\nS              – set\nHyperrectangle – type for dispatch\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nThe center of the hyperrectangle is obtained by averaging the support function of the given set in the canonical directions, and the lengths of the sides can be recovered from the distance among support functions in the same directions.\n\n\n\n\n\noverapproximate(S::CartesianProductArray{N, <:AbstractHyperrectangle{N}},\n                ::Type{<:Hyperrectangle}) where {N<:Real}\n\nReturn a tight overapproximation of the Cartesian product array of a finite number of convex sets with and hyperrectangle.\n\nInput\n\nS              – Cartesian product array of a finite number of convex set\nHyperrectangle – type for dispatch\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nThis method falls back to the corresponding convert method. Since the sets wrapped by the Cartesian product array are hyperrectangles, it can be done efficiently without overapproximation.\n\n\n\n\n\noverapproximate(S::CartesianProduct{N, <:AbstractHyperrectangle{N}, <:AbstractHyperrectangle{N}},\n                ::Type{<:Hyperrectangle}) where {N<:Real}\n\nReturn a tight overapproximation of the Cartesian product of two hyperrectangles by a new hyperrectangle.\n\nInput\n\nS              – Cartesian product of two hyperrectangular sets\nHyperrectangle – type for dispatch\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nThis method falls back to the corresponding convert method. Since the sets wrapped by the Cartesian product are hyperrectangles, it can be done efficiently without overapproximation.\n\n\n\n\n\noverapproximate(lm::LinearMap{N, <:AbstractHyperrectangle{N}},\n                ::Type{<:Hyperrectangle}) where {N}\n\nReturn a tight overapproximation of the linear map of a hyperrectangular set using a hyperrectangle.\n\nInput\n\nS              – linear map of a hyperrectangular set\nHyperrectangle – type for dispatch\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nIf c and r denote the center and vector radius of a hyperrectangle H, a tight hyperrectangular overapproximation of M * H is obtained by transforming c ↦ M*c and r ↦ abs.(M) * r, where abs.(⋅) denotes the element-wise absolute value operator.\n\n\n\n\n\noverapproximate(r::Rectification{N}, ::Type{<:Hyperrectangle}\n               ) where {N<:Real}\n\nOverapproximate the rectification of a convex set by a tight hyperrectangle.\n\nInput\n\nr              – rectification of a convex set\nHyperrectangle – type for dispatch\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nBox approximation and rectification distribute. Hence we first check whether the wrapped set is empty. If so, we return the empty set. Otherwise, we compute the box approximation of the wrapped set, rectify the resulting box (which is simple), and finally convert the resulting set to a box.\n\n\n\n\n\noverapproximate(S::LazySet)\n\nAlias for overapproximate(S, Hyperrectangle).\n\n\n\n\n\noverapproximate(S::LazySet{N}, ::Type{<:BallInf}) where {N<:Real}\n\nOverapproximate a convex set by a tight ball in the infinity norm.\n\nInput\n\nS       – convex set\nBallInf – type for dispatch\n\nOutput\n\nA tight ball in the infinity norm.\n\nAlgorithm\n\nThe center and radius of the box are obtained by evaluating the support function of the given convex set along the canonical directions.\n\n\n\n\n\noverapproximate(X::ConvexHull{N, <:AbstractZonotope{N}, <:AbstractZonotope{N}},\n                ::Type{<:Zonotope}) where {N<:Real}\n\nOverapproximate the convex hull of two zonotopes.\n\nInput\n\nX         – convex hull of two zonotopes\nZonotope  – type for dispatch\nalgorithm – (optional; default: \"mean\") choice of algorithm; possible                values are \"mean\" and \"join\"\n\nOutput\n\nA zonotope Z such that X  Z.\n\nAlgorithm\n\nThe algorithm can be controlled by the parameter algorithm. Note that the results of the two implemented algorithms are generally incomparable.\n\n'mean' method\n\nIf algorithm == \"mean\", we choose the method proposed in [1]. The convex hull of two zonotopes Z₁ and Z₂ of the same order, which we write\n\nZ_j = c^(j) g^(j)_1  g^(j)_p\n\nfor j = 1 2, can be overapproximated as follows:\n\nCH(Z_1 Z_2)  frac12c^(1)+c^(2) g^(1)_1+g^(2)_1 \ng^(1)_p+g^(2)_p c^(1)-c^(2) g^(1)_1-g^(2)_1  g^(1)_p-g^(2)_p\n\nIf the zonotope order is not the same, this algorithm calls reduce_order to reduce the order to the minimum of the arguments.\n\nIt should be noted that the output zonotope is not necessarily the minimal enclosing zonotope, which is in general expensive in high dimensions. This is further investigated in [2].\n\n'join' method\n\nIf algorithm == \"join\", we choose the method proposed in [3, Definition 1]. The convex hull X of two zonotopes Z₁ and Z₂ is overapproximated by a zonotope Z₃ such that the box approximation of X is identical with the box approximation of Z₃. Let (X) denote the box approximation of X. The center of Z₃ is the center of (X).\n\nThe generator construction consists of two phases. In the first phase, we construct generators g as a combination of one generator from Z₁, say, g₁, with another generator from Z₂, say, g₂. The entry of g in the i-th dimension is given as\n\n    gi = argmin_min(g₁i g₂i)  x  max(g₁i g₂i) x\n\nIf g is the zero vector, it can be omitted.\n\nIn the second phase, we construct another generator for each dimension. These generators are scaled unit vectors. The following formula defines the sum of all those generators.\n\n    sup((X)) - c - _g g\n\nwhere c is the center of the new zonotope and the gs are the generators constructed in the first phase.\n\nReferences\n\n[1] Reachability of Uncertain Linear Systems Using Zonotopes, A. Girard.     HSCC 2005.\n\n[2] Zonotopes as bounding volumes, L. J. Guibas et al, Proc. of Symposium on     Discrete Algorithms, pp. 803-812.\n\n[3] The zonotope abstract domain Taylor1+. K. Ghorbal, E. Goubault, S. Putot.     CAV 2009.\n\n\n\n\n\noverapproximate(lm::LinearMap{N, <:AbstractZonotope{N}},\n                ::Type{<:Zonotope}) where {N<:Real}\n\nOverapproximate a lazy linear map of a zonotopic set with a zonotope.\n\nInput\n\nlm       – lazy linear map of a zonotopic set\nZonotope – type for dispatch\n\nOutput\n\nThe tight zonotope corresponding to lm.\n\n\n\n\n\noverapproximate(Z::AbstractZonotope, ::Type{<:Hyperrectangle})\n\nReturn a tight overapproximation of a zonotope with an axis-aligned box.\n\nInput\n\nZ              – zonotope\nHyperrectangle – type for dispatch\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nThis function implements the method in [Section 5.1.2, 1]. A zonotope Z = c G can be overapproximated tightly by an axis-aligned box (i.e. a Hyperrectangle) such that its center is c and the radius along dimension i is the column-sum of the absolute values of the i-th row of G for i = 1 p, where p is the number of generators of Z.\n\n[1] Althoff, M., Stursberg, O., & Buss, M. (2010). Computing reachable sets of hybrid systems using a combination of zonotopes and polytopes. Nonlinear analysis: hybrid systems, 4(2), 233-249.\n\n\n\n\n\noverapproximate(X::LazySet{N}, dir::AbstractDirections{N}) where {N}\n\nOverapproximating a set with template directions.\n\nInput\n\nX   – set\ndir – (concrete) direction representation\n\nOutput\n\nA polyhedron overapproximating the set X with the directions from dir. If the directions are known to be bounded, the result is an HPolytope, otherwise the result is an HPolyhedron.\n\n\n\n\n\noverapproximate(X::LazySet{N}, dir::Type{<:AbstractDirections}) where {N}\n\nOverapproximating a set with template directions.\n\nInput\n\nX   – set\ndir – type of direction representation\n\nOutput\n\nA polyhedron overapproximating the set X with the directions from dir. If the directions are known to be bounded, the result is an HPolytope, otherwise the result is an HPolyhedron.\n\n\n\n\n\noverapproximate(S::LazySet{N}, ::Type{<:Interval}) where {N<:Real}\n\nReturn the overapproximation of a unidimensional set with an interval.\n\nInput\n\nS        – one-dimensional set\nInterval – type for dispatch\n\nOutput\n\nAn interval.\n\nAlgorithm\n\nWe use two support-function evaluations.\n\n\n\n\n\noverapproximate(cap::Intersection{N}, ::Type{<:Interval}) where {N<:Real}\n\nReturn the overapproximation of a unidimensional intersection with an interval.\n\nInput\n\ncap      – one-dimensional lazy intersection\nInterval – type for dispatch\n\nOutput\n\nAn interval.\n\nAlgorithm\n\nThe algorithm recursively overapproximates the two intersected sets with intervals and then intersects these.\n\n\n\n\n\noverapproximate(cap::IntersectionArray{N}, ::Type{<:Interval}) where {N<:Real}\n\nReturn the overapproximation of a unidimensional intersection with an interval.\n\nInput\n\ncap      – one-dimensional lazy intersection\nInterval – type for dispatch\n\nOutput\n\nAn interval.\n\nAlgorithm\n\nThe algorithm recursively overapproximates the two intersected sets with intervals and then intersects these.\n\n\n\n\n\noverapproximate(cap::Intersection{N, <:LazySet, <:AbstractPolyhedron{N}},\n                dir::AbstractDirections{N};\n                kwargs...\n               ) where {N<:Real}\n\nReturn the overapproximation of the intersection between a compact set and a polytope given a set of template directions.\n\nInput\n\ncap         – intersection of a compact set and a polytope\ndir         – template directions\nkwargs      – additional arguments that are passed to the support function                  algorithm\n\nOutput\n\nA polytope in H-representation such that the normal direction of each half-space is given by an element of dir.\n\nAlgorithm\n\nLet di be a direction drawn from the set of template directions dir. Let X be the compact set and let P be the polytope. We overapproximate the set X ∩ H with a polytope in constraint representation using a given set of template directions dir.\n\nThe idea is to solve the univariate optimization problem ρ(di, X ∩ Hi) for each half-space in the set P and then take the minimum. This gives an overapproximation of the exact support function.\n\nThis algorithm is inspired from G. Frehse, R. Ray. Flowpipe-Guard Intersection for Reachability Computations with Support Functions.\n\nNotes\n\nThis method relies on having available the constraints_list of the polytope P.\n\nThis method of overapproximations can return a non-empty set even if the original intersection is empty.\n\n\n\n\n\noverapproximate(cap::Intersection{N, <:HalfSpace{N}, <:AbstractPolytope{N}},\n                dir::AbstractDirections{N};\n                [kwargs]...\n               ) where {N<:Real}\n\nReturn the overapproximation of the intersection between a half-space and a polytope given a set of template directions.\n\nInput\n\ncap         – intersection of a half-space and a polytope\ndir         – template directions\nkwargs      – additional arguments that are passed to the support function                  algorithm\n\nOutput\n\nA polytope in H-representation such that the normal direction of each half-space is given by an element of dir.\n\n\n\n\n\noverapproximate(lm::LinearMap{N, <:CartesianProductArray{N}},\n                ::Type{CartesianProductArray{N, S}}\n               ) where {N, S<:LazySet{N}}\n\nDecompose a lazy linear map of a Cartesian product array while keeping the original block structure.\n\nInput\n\nlm                    – lazy linear map of Cartesian product array\nCartesianProductArray – type for dispatch\n\nOutput\n\nA CartesianProductArray representing the decomposed linear map.\n\n\n\n\n\noverapproximate(lm::LinearMap{N, <:CartesianProductArray{N}},\n                ::Type{<:CartesianProductArray},\n                dir::Type{<:AbstractDirections}) where {N}\n\nDecompose a lazy linear map of a Cartesian product array with template directions while keeping the original block structure.\n\nInput\n\nlm                    – lazy linear map of a Cartesian product array\nCartesianProductArray – type for dispatch\ndir                   – template directions for overapproximation\n\nOutput\n\nA CartesianProductArray representing the decomposed linear map.\n\n\n\n\n\noverapproximate(lm::LinearMap{N, <:CartesianProductArray{N}},\n                ::Type{<:CartesianProductArray},\n                set_type::Type{<:LazySet}) where {N}\n\nDecompose a lazy linear map of a Cartesian product array with a given set type while keeping the original block structure.\n\nInput\n\nlm                    – lazy linear map of a Cartesian product array\nCartesianProductArray – type for dispatch\nset_type              – set type for overapproximation\n\nOutput\n\nA CartesianProductArray representing the decomposed linear map.\n\n\n\n\n\noverapproximate(rm::ResetMap{N, <:CartesianProductArray{N}},\n                ::Type{<:CartesianProductArray}, oa) where {N}\n\nOverapproximate a reset map (that only resets to zero) of a Cartesian product by a new Cartesian product.\n\nInput\n\nrm                    – reset map\nCartesianProductArray – type for dispatch\noa                    – overapproximation option\n\nOutput\n\nA Cartesian product with the same block structure.\n\nNotes\n\nThis implementation currently only supports resets to zero.\n\nAlgorithm\n\nWe convert the ResetMap into a LinearMap and then call the corresponding overapproximation method.\n\n\n\n\n\noverapproximate(cap::Intersection{N,\n                                  <:CartesianProductArray{N},\n                                  <:AbstractPolyhedron{N}},\n                ::Type{CartesianProductArray}, oa) where {N}\n\nReturn the intersection of the Cartesian product of a finite number of convex sets and a polyhedron.\n\nInput\n\ncap                   – lazy intersection of a Cartesian product array and a polyhedron\nCartesianProductArray – type for dispatch\noa                    – overapproximation option\n\nOutput\n\nA CartesianProductArray that overapproximates the intersection of cpa and P.\n\nAlgorithm\n\nThe intersection only needs to be computed in the blocks of cpa that are constrained in P. Hence we first collect those constrained blocks in a lower-dimensional Cartesian product array and then convert to an HPolytope X. Then we take the intersection of X and the projection of Y onto the corresponding dimensions. (This projection is purely syntactic and exact.) Finally we decompose the result again and plug together the unaffected old blocks and the newly computed blocks. The result is a CartesianProductArray with the same block structure as in X.\n\n\n\n\n\noverapproximate(Z::Zonotope{N}, ::Type{<:Zonotope}, r::Union{Integer, Rational}) where {N<:Real}\n\nReduce the order of a zonotope by overapproximating with a zonotope with less generators.\n\nInput\n\nZ – zonotope\nZonotope – desired type for dispatch\nr – desired order\n\nOutput\n\nA new zonotope with less generators, if possible.\n\nAlgorithm\n\nThis function implements the algorithm described in A. Girard's Reachability of Uncertain Linear Systems Using Zonotopes, HSCC. Vol. 5. 2005.\n\nIf the desired order is smaller than one, the zonotope is not reduced.\n\n\n\n\n\noverapproximate(am::AbstractAffineMap{N, <:AbstractHyperrectangle{N}},\n                ::Type{<:Hyperrectangle}) where {N}\n\nOverapproximate the affine map of a hyperrectangular set using a hyperrectangle.\n\nInput\n\nam             – affine map of a hyperrectangular set\nHyperrectangle – type for dispatch\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nIf c and r denote the center and vector radius of a hyperrectangle H and v the translation vector, a tight hyperrectangular overapproximation of M * H + v is obtained by transforming c ↦ M*c+v and r ↦ abs.(M) * r, where abs.(⋅) denotes the element-wise absolute value operator.\n\n\n\n\n\noverapproximate(X::LazySet{N}, ::Type{<:Zonotope},\n                dir::AbstractDirections{N};\n                solver=default_lp_solver(N)) where {N<:Real}\n\nOverapproximate a polytopic set with a zonotope of minimal total generator sum using only generators in the given directions.\n\nInput\n\nX        – polytopic set\nZonotope – type for dispatch\ndir      – directions used for the generators\nsolver   – (optional, default: default_lp_solver(N)) the backend used to               solve the linear program\n\nOutput\n\nA zonotope that overapproximates X and uses at most the directions provided in dir (redundant directions will be ignored). Under this constraint, the zonotope has the minimal sum of generator vectors.\n\nNotes\n\nThe algorithm only requires one representative of each generator direction and their additive inverse (e.g. only one of [1, 0] and [-1, 0]) and assumes that the directions are normalized. We preprocess the directions in that respect.\n\nAlgorithm\n\nWe solve a linear program parametric in the vertices v_j of X and the directions d_k in dir presented in Section 4.2 in [1], adapting the notation to the one used in this library.\n\n    min sum_k=1^l α_k \n    st \n    c + sum_k=1^l b_kj * d_k = v_j quad forall j \n    -α_k  b_kj  α_k quad forall k j \n    α_k  0 quad forall k\n\nThe resulting zonotope has center c and generators α_k · d_k.\n\nNote that the first type of side constraints is vector-based and that the nonnegativity constraints (last type) are not stated explicitly in [1].\n\n[1] Zonotopes as bounding volumes, L. J. Guibas et al, Proc. of Symposium on     Discrete Algorithms, pp. 803-812.\n\n\n\n\n\noverapproximate(r::Rectification{N, <:AbstractZonotope{N}}, ::Type{<:Zonotope}) where {N}\n\nOverapproximation of the rectification of a zonotopic set.\n\nInput\n\nr – lazy rectification of a zonotopic set\nZonotope – type for dispatch\n\nOutput\n\nA zonotope overapproximation of the set obtained by rectifying Z.\n\nAlgorithm\n\nThis function implements [Theorem 3.1, 1].\n\n[1] Singh, G., Gehr, T., Mirman, M., Püschel, M., & Vechev, M. (2018). Fast and effective robustness certification. In Advances in Neural Information Processing Systems (pp. 10802-10813).\n\n\n\n\n\noverapproximate(CHA::ConvexHullArray{N, <:AbstractZonotope{N}}, ::Type{<:Zonotope}) where {N}\n\nOverapproximation of the convex hull array of zonotopic sets.\n\nInput\n\nCHA – convex hull array of zonotopic sets\nZonotope – type for dispatch\n\nOutput\n\nA zonotope overapproximation of the convex hull array of zonotopic sets.\n\nAlgorithm\n\nThis function iteratively applies the overapproximation algorithm for the convex hull of two zonotopes to the given array of zonotopes.\n\n\n\n\n\noverapproximate(vTM::Vector{TaylorModel1{T, S}},\n                ::Type{<:Zonotope}) where {T, S}\n\nOverapproximate a taylor model in one variable with a zonotope.\n\nInput\n\nvTM      – TaylorModel1\nZonotope –  type for dispatch\n\nOutput\n\nA zonotope that overapproximates the range of the given taylor model.\n\nExamples\n\nIf the polynomials are linear, this functions exactly transforms to a zonotope. However, the nonlinear case necessarily introduces overapproximation error. Consider the linear case first:\n\njulia> using LazySets, TaylorModels\n\njulia> const IA = IntervalArithmetic;\n\njulia> I = IA.Interval(-0.5, 0.5) # interval remainder\n[-0.5, 0.5]\n\njulia> x₀ = IA.Interval(0.0) # expansion point\n[0, 0]\n\njulia> D = IA.Interval(-3.0, 1.0)\n[-3, 1]\n\njulia> p1 = Taylor1([2.0, 1.0], 2) # define a linear polynomial\n 2.0 + 1.0 t + 𝒪(t³)\n\njulia> p2 = Taylor1([0.9, 3.0], 2) # define another linear polynomial\n 0.9 + 3.0 t + 𝒪(t³)\n\njulia> vTM = [TaylorModel1(pi, I, x₀, D) for pi in [p1, p2]]\n2-element Array{TaylorModel1{Float64,Float64},1}:\n 2.0 + 1.0 t + [-0.5, 0.5]\n 0.9 + 3.0 t + [-0.5, 0.5]\n\nHere, vTM is a taylor model vector, since each component is a taylor model in one variable (TaylorModel1). Using overapproximate(vTM, Zonotope) we can compute its associated zonotope in generator representation:\n\njulia> using LazySets.Approximations\n\njulia> Z = overapproximate(vTM, Zonotope);\n\njulia> center(Z)\n2-element Array{Float64,1}:\n  1.0\n -2.1\n\njulia> Matrix(genmat(Z))\n2×3 Array{Float64,2}:\n 2.0  0.5  0.0\n 6.0  0.0  0.5\n\nNote how the generators of this zonotope mainly consist of two pieces: one comes from the linear part of the polynomials, and another one that corresponds to the interval remainder. This conversion gives the same upper and lower bounds as the range evaluation using interval arithmetic:\n\njulia> X = box_approximation(Z)\nHyperrectangle{Float64}([1.0, -2.1], [2.5, 6.5])\n\njulia> Y = evaluate(vTM[1], vTM[1].dom) × evaluate(vTM[2], vTM[2].dom)\n[-1.5, 3.5] × [-8.60001, 4.40001]\n\njulia> H = convert(Hyperrectangle, Y) # this IntevalBox is the same as X\nHyperrectangle{Float64}([1.0, -2.1], [2.5, 6.5])\n\nHowever, the zonotope returns better results if we want to approximate the TM, since it is not axis-aligned:\n\njulia> d = [-0.35, 0.93];\n\njulia> ρ(d, Z) < ρ(d, X)\ntrue\n\nThis function also works if the polynomials are non-linear; for example suppose that we add a third polynomial with a quadratic term:\n\njulia> p3 = Taylor1([0.9, 3.0, 1.0], 3);\n\njulia> vTM = [TaylorModel1(pi, I, x₀, D) for pi in [p1, p2, p3]]\n3-element Array{TaylorModel1{Float64,Float64},1}:\n           2.0 + 1.0 t + [-0.5, 0.5]\n           0.9 + 3.0 t + [-0.5, 0.5]\n  0.9 + 3.0 t + 1.0 t² + [-0.5, 0.5]\n\njulia> Z = overapproximate(vTM, Zonotope);\n\njulia> center(Z)\n3-element Array{Float64,1}:\n  1.0\n -2.1\n  0.8999999999999999\n\njulia> Matrix(genmat(Z))\n3×4 Array{Float64,2}:\n 2.0  0.5  0.0  0.0\n 6.0  0.0  0.5  0.0\n 6.0  0.0  0.0  6.5\n\nThe fourth and last generator corresponds to the addition between the interval remainder and the box overapproximation of the nonlinear part of p3 over the domain.\n\nAlgorithm\n\nLet textvTM = (p I) be a vector of m taylor models, where I is the interval remainder in mathbbR^m. Let p_lin (resp. p_nonlin) correspond to the linear (resp. nonlinear) part of each scalar polynomial.\n\nThe range of textvTM can be enclosed by a zonotope with center c and matrix of generators G, Z = c G, by performing a conservative linearization of textvTM:\n\n    vTM = (p I) = (p_lin  p_nonlin  I + textInt(p_nonlin))\n\nThis algorithm proceeds in two steps:\n\n1- Conservatively linearize textvTM as above and compute a box    overapproximation of the nonlinear part. 2- Transform the linear taylor model to a zonotope exactly through variable    normalization onto the symmetric intervals -1 1.\n\n\n\n\n\noverapproximate(vTM::Vector{TaylorModelN{N, T, S}},\n                ::Type{<:Zonotope}) where {N,T, S}\n\nOverapproximate a multivariate taylor model with a zonotope.\n\nInput\n\nvTM      – TaylorModelN\nZonotope – type for dispatch\n\nOutput\n\nA zonotope that overapproximates the range of the given taylor model.\n\nExamples\n\nConsider a vector of two 2-dimensional taylor models of order 2 and 4 respectively.\n\njulia> using LazySets, LazySets.Approximations, TaylorModels\n\njulia> const IA = IntervalArithmetic;\n\njulia> x₁, x₂ = set_variables(Float64, [\"x₁\", \"x₂\"], order=8)\n2-element Array{TaylorN{Float64},1}:\n  1.0 x₁ + 𝒪(‖x‖⁹)\n  1.0 x₂ + 𝒪(‖x‖⁹)\n\njulia> x₀ = IntervalBox(0..0, 2) # expansion point\n[0, 0] × [0, 0]\n\njulia> Dx₁ = IA.Interval(0.0, 3.0) # domain for x₁\n[0, 3]\n\njulia> Dx₂ = IA.Interval(-1.0, 1.0) # domain for x₂\n[-1, 1]\n\njulia> D = Dx₁ × Dx₂ # take the Cartesian product of the domain on each variable\n[0, 3] × [-1, 1]\n\njulia> r = IA.Interval(-0.5, 0.5) # interval remainder\n[-0.5, 0.5]\n\njulia> p1 = 1 + x₁^2 - x₂\n 1.0 - 1.0 x₂ + 1.0 x₁² + 𝒪(‖x‖⁹)\n\njulia> p2 = x₂^3 + 3x₁^4 + x₁ + 1\n 1.0 + 1.0 x₁ + 1.0 x₂³ + 3.0 x₁⁴ + 𝒪(‖x‖⁹)\n\njulia> vTM = [TaylorModelN(pi, r, x₀, D) for pi in [p1, p2]]\n2-element Array{TaylorModelN{2,Float64,Float64},1}:\n             1.0 - 1.0 x₂ + 1.0 x₁² + [-0.5, 0.5]\n   1.0 + 1.0 x₁ + 1.0 x₂³ + 3.0 x₁⁴ + [-0.5, 0.5]\n\njulia> Z = overapproximate(vTM, Zonotope);\n\njulia> center(Z)\n2-element Array{Float64,1}:\n   5.5\n 124.0\n\njulia> Matrix(genmat(Z))\n2×4 Array{Float64,2}:\n 0.0  -1.0  5.0    0.0\n 1.5   0.0  0.0  123.0\n\nAlgorithm\n\nWe refer to the algorithm description for the univariate case.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/#Underapproximations","page":"Approximations","title":"Underapproximations","text":"","category":"section"},{"location":"lib/approximations/","page":"Approximations","title":"Approximations","text":"underapproximate","category":"page"},{"location":"lib/approximations/#LazySets.Approximations.underapproximate","page":"Approximations","title":"LazySets.Approximations.underapproximate","text":"underapproximate(X::LazySet{N}, dirs::AbstractDirections;\n                [apply_convex_hull]::Bool=false) where {N<:Real}\n\nCompute the underapproximation of a convex set by sampling support vectors.\n\nInput\n\nX                 – set\ndirs              – directions\napply_convex_hull – (optional, default: false) if true, post-process                        the support vectors with a convex hull operation\n\nOutput\n\nThe VPolytope obtained by taking the convex hull of the support vectors of X along the directions determined by dirs.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/#Box-Approximations","page":"Approximations","title":"Box Approximations","text":"","category":"section"},{"location":"lib/approximations/","page":"Approximations","title":"Approximations","text":"ballinf_approximation\nbox_approximation\ninterval_hull\nbox_approximation_symmetric\nsymmetric_interval_hull\nbox_approximation_helper","category":"page"},{"location":"lib/approximations/#LazySets.Approximations.ballinf_approximation","page":"Approximations","title":"LazySets.Approximations.ballinf_approximation","text":"ballinf_approximation(S::LazySet{N}) where {N<:Real}\n\nOverapproximate a convex set by a tight ball in the infinity norm.\n\nInput\n\nS – convex set\n\nOutput\n\nA tight ball in the infinity norm.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/#LazySets.Approximations.box_approximation","page":"Approximations","title":"LazySets.Approximations.box_approximation","text":"box_approximation(S::LazySet{N}) where {N<:Real}\n\nOverapproximate a convex set by a tight hyperrectangle.\n\nInput\n\nS – convex set\n\nOutput\n\nA tight hyperrectangle.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/#LazySets.Approximations.interval_hull","page":"Approximations","title":"LazySets.Approximations.interval_hull","text":"interval_hull\n\nAlias for box_approximation.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/#LazySets.Approximations.box_approximation_symmetric","page":"Approximations","title":"LazySets.Approximations.box_approximation_symmetric","text":"box_approximation_symmetric(S::LazySet{N}) where {N<:Real}\n\nOverapproximate a convex set by a tight hyperrectangle centered in the origin.\n\nInput\n\nS – convex set\n\nOutput\n\nA tight hyperrectangle centered in the origin.\n\nAlgorithm\n\nThe center of the box is the origin, and the radius is obtained by computing the maximum value of the support function evaluated at the canonical directions.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/#LazySets.Approximations.symmetric_interval_hull","page":"Approximations","title":"LazySets.Approximations.symmetric_interval_hull","text":"symmetric_interval_hull\n\nAlias for box_approximation_symmetric.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/#LazySets.Approximations.box_approximation_helper","page":"Approximations","title":"LazySets.Approximations.box_approximation_helper","text":"box_approximation_helper(S::LazySet{N}) where {N<:Real}\n\nCommon code of box_approximation and box_approximation_symmetric.\n\nInput\n\nS – convex set\n\nOutput\n\nA tuple containing the data that is needed to construct a tightly overapproximating hyperrectangle.\n\nc – center\nr – radius\n\nAlgorithm\n\nThe center of the hyperrectangle is obtained by averaging the support function of the given convex set in the canonical directions. The lengths of the sides can be recovered from the distance among support functions in the same directions.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/#Iterative-refinement","page":"Approximations","title":"Iterative refinement","text":"","category":"section"},{"location":"lib/approximations/","page":"Approximations","title":"Approximations","text":"LocalApproximation\nPolygonalOverapproximation\nnew_approx(S::LazySet, p1::VN, d1::VN,\n           p2::VN, d2::VN) where {N<:AbstractFloat, VN<:AbstractVector{N}}\naddapproximation!(Ω::PolygonalOverapproximation, p1::VN, d1::VN, p2::VN, d2::VN) where {N<:Real, VN<:AbstractVector{N}}\nrefine(::LocalApproximation, ::LazySet)\ntohrep(::PolygonalOverapproximation)\napproximate(S::LazySet{N}, ε::N) where {N<:AbstractFloat}\nconstraint(::LocalApproximation)","category":"page"},{"location":"lib/approximations/#LazySets.Approximations.LocalApproximation","page":"Approximations","title":"LazySets.Approximations.LocalApproximation","text":"LocalApproximation{N<:Real, VN<:AbstractVector{N}}\n\nType that represents a local approximation in 2D.\n\nFields\n\np1        – first inner point\nd1        – first direction\np2        – second inner point\nd2        – second direction\nq         – intersection of the lines l1 ⟂ d1 at p1 and l2 ⟂ d2 at p2\nrefinable – states if this approximation is refinable\nerr       – error upper bound\n\nNotes\n\nThe criteria for being refinable are determined in the method new_approx.\n\n\n\n\n\n","category":"type"},{"location":"lib/approximations/#LazySets.Approximations.PolygonalOverapproximation","page":"Approximations","title":"LazySets.Approximations.PolygonalOverapproximation","text":"PolygonalOverapproximation{N<:Real, SN<:LazySet{N}, VN<:AbstractVector{N}}\n\nType that represents the polygonal approximation of a convex set.\n\nFields\n\nS            – convex set\napprox_stack – stack of local approximations that still need to be examined\nconstraints  – vector of linear constraints that are already finalized                   (i.e., they satisfy the given error bound)\n\n\n\n\n\n","category":"type"},{"location":"lib/approximations/#LazySets.Approximations.new_approx-Union{Tuple{VN}, Tuple{N}, Tuple{LazySet,VN,VN,VN,VN}} where VN<:AbstractArray{N,1} where N<:AbstractFloat","page":"Approximations","title":"LazySets.Approximations.new_approx","text":"new_approx(S::LazySet, p1::VN, d1::VN,\n           p2::VN, d2::VN) where {N<:AbstractFloat, VN<:AbstractVector{N}}\n\nCreate a LocalApproximation instance for the given excerpt of a polygonal approximation.\n\nInput\n\nS  – convex set\np1 – first inner point\nd1 – first direction\np2 – second inner point\nd2 – second direction\n\nOutput\n\nA local approximation of S in the given directions.\n\n\n\n\n\n","category":"method"},{"location":"lib/approximations/#LazySets.Approximations.addapproximation!-Union{Tuple{VN}, Tuple{N}, Tuple{LazySets.Approximations.PolygonalOverapproximation,VN,VN,VN,VN}} where VN<:AbstractArray{N,1} where N<:Real","page":"Approximations","title":"LazySets.Approximations.addapproximation!","text":"addapproximation!(Ω::PolygonalOverapproximation, p1::VN, d1::VN,\n                  p2::VN, d2::VN) where {N<:Real, VN<:AbstractVector{N}}\n\nInput\n\nΩ  – polygonal overapproximation of a convex set\np1 – first inner point\nd1 – first direction\np2 – second inner point\nd2 – second direction\n\nOutput\n\nThe list of local approximations in Ω of the set Ω.S is updated in-place and the new approximation is returned by this function.\n\n\n\n\n\n","category":"method"},{"location":"lib/approximations/#LazySets.Approximations.refine-Tuple{LazySets.Approximations.LocalApproximation,LazySet}","page":"Approximations","title":"LazySets.Approximations.refine","text":"refine(approx::LocalApproximation, S::LazySet)\n\nRefine a given local approximation of the polygonal approximation of a convex set by splitting along the normal direction of the approximation.\n\nInput\n\napprox – local approximation to be refined\nS      – 2D convex set\n\nOutput\n\nThe tuple consisting of the refined right and left local approximations.\n\n\n\n\n\n","category":"method"},{"location":"lib/approximations/#LazySets.Approximations.tohrep-Tuple{LazySets.Approximations.PolygonalOverapproximation}","page":"Approximations","title":"LazySets.Approximations.tohrep","text":"tohrep(Ω::PolygonalOverapproximation)\n\nConvert a polygonal overapproximation into a concrete polygon.\n\nInput\n\nΩ – polygonal overapproximation of a convex set\n\nOutput\n\nA polygon in constraint representation.\n\nAlgorithm\n\nInternally we keep the constraints sorted. Hence we do not need to use addconstraint! when creating the HPolygon.\n\n\n\n\n\n","category":"method"},{"location":"lib/approximations/#LazySets.Approximations.approximate-Union{Tuple{N}, Tuple{LazySet{N},N}} where N<:AbstractFloat","page":"Approximations","title":"LazySets.Approximations.approximate","text":"approximate(S::LazySet{N}, ε::N) where {N<:AbstractFloat}\n\nReturn an ε-close approximation of the given 2D convex set (in terms of Hausdorff distance) as an inner and an outer approximation composed by sorted local Approximation2D.\n\nInput\n\nS – 2D convex set\nε – error bound\n\nOutput\n\nAn ε-close approximation of the given 2D convex set.\n\n\n\n\n\n","category":"method"},{"location":"lib/approximations/#LazySets.Approximations.constraint-Tuple{LazySets.Approximations.LocalApproximation}","page":"Approximations","title":"LazySets.Approximations.constraint","text":"constraint(approx::LocalApproximation)\n\nConvert a local approximation to a linear constraint.\n\nInput\n\napprox – local approximation\n\nOutput\n\nA linear constraint.\n\n\n\n\n\n","category":"method"},{"location":"lib/approximations/#Template-directions","page":"Approximations","title":"Template directions","text":"","category":"section"},{"location":"lib/approximations/","page":"Approximations","title":"Approximations","text":"AbstractDirections\nisbounding\nisnormalized\nBoxDirections\nOctDirections\nBoxDiagDirections\nPolarDirections\nSphericalDirections\nCustomDirections","category":"page"},{"location":"lib/approximations/#LazySets.Approximations.AbstractDirections","page":"Approximations","title":"LazySets.Approximations.AbstractDirections","text":"AbstractDirections{N, VN}\n\nAbstract type for template direction representations.\n\nNotes\n\nThis type is parameterzed by N and VN, where:\n\nN stands for the numeric type\nVN stands for the vector type with coefficients of type N\n\nEach subtype is an iterator over a set of prescribed directions.\n\nAll subtypes should implement the standard iterator methods from Base, namely Base.length (returns the number of directions in the template), and Base.iterate. Moreover, the following methods should be implemented:\n\ndim    – return the ambient dimension of the template\neltype – return the type of each vector in the template\n\nOptionally, subtypes may implement:\n\nisbounding   – (defaults to false) return true if an overapproximation with                   a list of template directions results in a bounded set, given a                   bounded input set, and false otherwise\nisnormalized – (defaults to false) returns true if each direction in the                   given template has norm one w.r.t. the usual vector 2-norm\n\n\n\n\n\n","category":"type"},{"location":"lib/approximations/#LazySets.Approximations.isbounding","page":"Approximations","title":"LazySets.Approximations.isbounding","text":"isbounding(ad::Type{<:AbstractDirections})\n\nChecks if an overapproximation with a list of template directions results in a bounded set, given a bounded input set.\n\nInput\n\nad – template directions\n\nOutput\n\nGiven a bounded set X, we can construct an outer approximation of X by using the template directions ad as normal vectors of the facets. If this function returns true, then the result is again a bounded set (i.e., a polytope). Note that the result does not depend on the specific shape of X, as long as X is bounded.\n\nNotes\n\nBy default, this function returns false in order to be conservative. Custom subtypes of AbstractDirections should hence add a method for this function.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/#LazySets.Approximations.isnormalized","page":"Approximations","title":"LazySets.Approximations.isnormalized","text":"isnormalized(ad::Type{<:AbstractDirections})\n\nReturns whether the given template directions is normalized with respect to the 2-norm.\n\nInput\n\nad – template directions\n\nOutput\n\ntrue if the 2-norm of each element in ad is one and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/#LazySets.Approximations.BoxDirections","page":"Approximations","title":"LazySets.Approximations.BoxDirections","text":"BoxDirections{N, VN} <: AbstractDirections{N, VN}\n\nBox directions representation.\n\nFields\n\nn – dimension\n\nNotes\n\nBox directions can be seen as the vectors where only one entry is ±1, and all other entries are 0. In dimension n, there are 2n such directions.\n\nThe default vector representation used in this template is a LazySets.Arrays.SingleEntryVector, although other implementations can be used such as a regular Vector and a sparse vector, SparseVector.\n\nExamples\n\nThe template can be constructed by passing the dimension. For example, in dimension two,\n\njulia> dirs = BoxDirections(2)\nBoxDirections{Float64,LazySets.Arrays.SingleEntryVector{Float64}}(2)\n\njulia> length(dirs)\n4\n\nBy default, each direction is represented in this iterator as a SingleEntryVector, i.e. a vector with only one non-zero element,\n\njulia> eltype(dirs)\nLazySets.Arrays.SingleEntryVector{Float64}\n\nIn two dimensions, the directions defined by BoxDirections are normal to the facets of a box.\n\njulia> collect(dirs)\n4-element Array{LazySets.Arrays.SingleEntryVector{Float64},1}:\n [1.0, 0.0]\n [0.0, 1.0]\n [0.0, -1.0]\n [-1.0, 0.0]\n\nThe numeric type can be specified as well:\n\njulia> BoxDirections{Rational{Int}}(10)\nBoxDirections{Rational{Int64},LazySets.Arrays.SingleEntryVector{Rational{Int64}}}(10)\n\njulia> length(ans)\n20\n\n\n\n\n\n","category":"type"},{"location":"lib/approximations/#LazySets.Approximations.OctDirections","page":"Approximations","title":"LazySets.Approximations.OctDirections","text":"OctDirections{N, VN} <: AbstractDirections{N, VN}\n\nOctagon directions representation.\n\nFields\n\nn – dimension\n\nNotes\n\nOctagon directions consist of all vectors that are zero almost everywhere except in two dimensions i, j (possibly i = j) where it is 1. In dimension n, there are 2n^2 such directions.\n\nExamples\n\nThe template can be constructed by passing the dimension. For example, in dimension two,\n\njulia> dirs = OctDirections(2)\nOctDirections{Float64,SparseArrays.SparseVector{Float64,Int64}}(2)\n\njulia> length(dirs) # number of directions\n8\n\nBy default, each direction is represented in this iterator as a sparse vector:\n\njulia> eltype(dirs)\nSparseArrays.SparseVector{Float64,Int64}\n\nIn two dimensions, the directions defined by OctDirections are normal to the facets of an octagon.\n\njulia> first(dirs)\n2-element SparseArrays.SparseVector{Float64,Int64} with 2 stored entries:\n  [1]  =  1.0\n  [2]  =  1.0\n\njulia> Vector.(collect(dirs))\n8-element Array{Array{Float64,1},1}:\n [1.0, 1.0]\n [1.0, -1.0]\n [-1.0, 1.0]\n [-1.0, -1.0]\n [1.0, 0.0]\n [0.0, 1.0]\n [0.0, -1.0]\n [-1.0, 0.0]\n\nThe numeric type can be specified as well:\n\njulia> OctDirections{Rational{Int}}(10)\nOctDirections{Rational{Int64},SparseArrays.SparseVector{Rational{Int64},Int64}}(10)\n\njulia> length(ans)\n200\n\n\n\n\n\n","category":"type"},{"location":"lib/approximations/#LazySets.Approximations.BoxDiagDirections","page":"Approximations","title":"LazySets.Approximations.BoxDiagDirections","text":"BoxDiagDirections{N, VN} <: AbstractDirections{N, VN}\n\nBox-diagonal directions representation.\n\nFields\n\nn – dimension\n\nNotes\n\nBox-diagonal directions can be seen as the union of diagonal directions (all entries are ±1) and box directions (one entry is ±1, all other entries are 0). The iterator first enumerates all diagonal directions, and then all box directions. In dimension n, there are in total 2^n + 2n such directions.\n\nExamples\n\nThe template can be constructed by passing the dimension. For example, in dimension two,\n\njulia> dirs = BoxDiagDirections(2)\nBoxDiagDirections{Float64,Array{Float64,1}}(2)\n\njulia> length(dirs) # number of directions\n8\n\nBy default, each direction is represented in this iterator as a regular vector:\n\njulia> eltype(dirs)\nArray{Float64,1}\n\nIn two dimensions, the directions defined by BoxDiagDirections are normal to the facets of an octagon.\n\njulia> collect(dirs)\n8-element Array{Array{Float64,1},1}:\n [1.0, 1.0]\n [-1.0, 1.0]\n [1.0, -1.0]\n [-1.0, -1.0]\n [1.0, 0.0]\n [0.0, 1.0]\n [0.0, -1.0]\n [-1.0, 0.0]\n\nThe numeric type can be specified as well:\n\njulia> BoxDiagDirections{Rational{Int}}(10)\nBoxDiagDirections{Rational{Int64},Array{Rational{Int64},1}}(10)\n\njulia> length(ans)\n1044\n\n\n\n\n\n","category":"type"},{"location":"lib/approximations/#LazySets.Approximations.PolarDirections","page":"Approximations","title":"LazySets.Approximations.PolarDirections","text":"PolarDirections{N<:AbstractFloat, VN<:AbstractVector{N}} <: AbstractDirections{N, VN}\n\nPolar directions representation.\n\nFields\n\nNφ – length of the partition of the polar angle\n\nNotes\n\nThe PolarDirections constructor provides a sample of the unit sphere in mathbbR^2, which is parameterized by the polar angle φ  Dφ = 0 2π; see the wikipedia entry Polar coordinate system for details.\n\nThe integer argument Nφ defines how many samples of Dφ are taken. The Cartesian components of each direction are obtained with\n\ncos(φᵢ) sin(φᵢ)\n\nExamples\n\nThe integer passed as an argument is used to discretize φ:\n\njulia> pd = PolarDirections(2);\n\njulia> pd.stack\n2-element Array{Array{Float64,1},1}:\n [1.0, 0.0]\n [-1.0, 1.2246467991473532e-16]\n\njulia> length(pd)\n2\n\n\n\n\n\n","category":"type"},{"location":"lib/approximations/#LazySets.Approximations.SphericalDirections","page":"Approximations","title":"LazySets.Approximations.SphericalDirections","text":"SphericalDirections{N<:AbstractFloat, VN<:AbstractVector{N}} <: AbstractDirections{N, VN}\n\nSpherical directions representation.\n\nFields\n\nNθ    – length of the partition of the azimuthal angle\nNφ    – length of the partition of the polar angle\nstack – list of computed directions\n\nNotes\n\nThe SphericalDirections constructor provides a sample of the unit sphere in mathbbR^3, which is parameterized by the azimuthal and polar angles θ  Dθ = 0 π and φ  Dφ = 0 2π respectively, see the wikipedia entry Spherical coordinate system for details.\n\nThe integer arguments Nθ and Nφ define how many samples along the domains Dθ and Dφ respectively are taken. The Cartesian components of each direction are obtained with\n\nsin(θᵢ)*cos(φᵢ) sin(θᵢ)*sin(φᵢ) cos(θᵢ)\n\nThe north and south poles are treated separately so that those points are not considered more than once.\n\nExamples\n\nA SphericalDirections template can be built in different ways. If you pass only one integer, the same value is used to discretize both θ and φ:\n\njulia> sd = SphericalDirections(3);\n\njulia> sd.Nθ, sd.Nφ\n(3, 3)\n\njulia> length(sd)\n4\n\nPass two integers to control the discretization in θ and in φ separately:\n\njulia> sd = SphericalDirections(4, 5);\n\njulia> length(sd)\n10\n\njulia> sd = SphericalDirections(4, 8);\n\njulia> length(sd)\n16\n\n\n\n\n\n","category":"type"},{"location":"lib/approximations/#LazySets.Approximations.CustomDirections","page":"Approximations","title":"LazySets.Approximations.CustomDirections","text":"CustomDirections{N, VN<:AbstractVector{N}} <: AbstractDirections{N, VN}\n\nUser-defined template directions.\n\nFields\n\ndirections – list of template directions\nn          – dimension\nisbounding – boundedness status\n\nNotes\n\nThis struct is a wrapper type for a set of user-defined directions which are iterated over. It has fields for the list of directions, the set dimension, and (boolean) cache fields for the boundedness and normalization properties. The latter are checked by default upon construction.\n\nTo check boundedness, we overapproximate the unit ball in the infinity norm using the given directions and check if the resulting set is bounded.\n\nThe dimension will also be determined automatically, unless the empty vector is passed (in which case the optional argument n needs to be specified).\n\nExamples\n\nCreating a template with box directions in dimension two:\n\njulia> dirs = CustomDirections([[1.0, 0.0], [-1.0, 0.0], [0.0, 1.0], [0.0, -1.0]]);\n\njulia> dirs.directions\n4-element Array{Array{Float64,1},1}:\n [1.0, 0.0]\n [-1.0, 0.0]\n [0.0, 1.0]\n [0.0, -1.0]\n\njulia> LazySets.Approximations.isbounding(dirs)\ntrue\n\njulia> LazySets.Approximations.isnormalized(dirs)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"lib/approximations/","page":"Approximations","title":"Approximations","text":"See also overapproximate(X::LazySet, dir::AbstractDirections)::HPolytope.","category":"page"},{"location":"lib/approximations/#Distances","page":"Approximations","title":"Distances","text":"","category":"section"},{"location":"lib/approximations/#Infimum-distance","page":"Approximations","title":"Infimum distance","text":"","category":"section"},{"location":"lib/approximations/","page":"Approximations","title":"Approximations","text":"distance","category":"page"},{"location":"lib/approximations/#LazySets.Approximations.distance","page":"Approximations","title":"LazySets.Approximations.distance","text":"distance(H1::AbstractHyperrectangle{N}, H2::AbstractHyperrectangle{N};\n         p::Real=2) where {N<:Real}\n\nCompute the standard distance between two hyperrectangular sets, defined as\n\n    inf_x in H_1 y in H_2  d(x y) \n\nInput\n\nH1 – hyperrectangular set\nH2 – hyperrectangular set\np  – (optional; default: 2) value of the p-norm\n\nOutput\n\nThe distance, which is zero if the sets intersect and otherwise the p-norm of the shortest line segment between any pair of points.\n\nNotes\n\nSee also hausdorff_distance for an alternative distance notion.\n\n\n\n\n\n","category":"function"},{"location":"lib/approximations/#Hausdorff-distance","page":"Approximations","title":"Hausdorff distance","text":"","category":"section"},{"location":"lib/approximations/","page":"Approximations","title":"Approximations","text":"hausdorff_distance","category":"page"},{"location":"lib/approximations/#LazySets.Approximations.hausdorff_distance","page":"Approximations","title":"LazySets.Approximations.hausdorff_distance","text":"hausdorff_distance(X::LazySet{N}, Y::LazySet{N}; [p]::N=N(Inf),\n                   [ε]::N=N(1e-3)) where {N<:Real}\n\nCompute the Hausdorff distance between two convex sets up to a given threshold.\n\nInput\n\nX – convex set\nY – convex set\np – (optional, default: Inf) norm parameter of the Hausdorff distance\nε – (optional, default: 1e-3) precision threshold; the true Hausdorff        distance may diverge from the result by at most this value\n\nOutput\n\nA value from the ε-neighborhood of the Hausdorff distance between X and Y.\n\nNotes\n\nGiven a p-norm, the Hausdorff distance d_H^p(X Y) between sets X and Y is defined as follows:\n\n    d_H^p(X Y) = infδ  0 mid Y  X  δ 𝐵_p^n text and  X  Y  δ 𝐵_p^n\n\nHere 𝐵_p^n is the n-dimensional unit ball in the p-norm.\n\nThe implementation may internally rely on the support function of X and Y; hence any imprecision in the implementation of the support function may affect the result. At the time of writing, the only set type with imprecise support function is the lazy Intersection.\n\nAlgorithm\n\nWe perform binary search for bounding the Hausdorff distance in an interval l u, where initially l is 0 and u is described below. The binary search terminates when u - l  ε, i.e., the interval becomes sufficiently small.\n\nTo find an upper bound u, we start with the heuristics of taking the biggest distance in the axis-parallel directions. As long as this bound does not work, we increase the bound by 2.\n\nGiven a value δ, to check whether the sets are within Hausdorff distance δ, we simply check the inclusions given above, where on the right-hand side we use a lazy MinkowskiSum with a Ballp centered in the origin.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/","page":"Utility Functions","title":"Utility Functions","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/utils/#Utility-functions","page":"Utility Functions","title":"Utility functions","text":"","category":"section"},{"location":"lib/utils/#Arrays-module","page":"Utility Functions","title":"Arrays module","text":"","category":"section"},{"location":"lib/utils/","page":"Utility Functions","title":"Utility Functions","text":"Arrays\ncross_product(::AbstractMatrix{N}) where {N<:Real}\nnonzero_columns\ndot_zero\nhasfullrowrank\ninner\nis_cyclic_permutation\nisinvertible\nispermutation\nis_right_turn\nissquare\nnonzero_indices\nremove_duplicates_sorted!\nremove_zero_columns\nright_turn\nsamedir\nSingleEntryVector\nto_negative_vector\n_up\n_dr\n_above\nminmax\narg_minmax\nextend\nprojection_matrix\nLazySets.Arrays._vector_type\nLazySets.Arrays._matrix_type","category":"page"},{"location":"lib/utils/#LazySets.Arrays","page":"Utility Functions","title":"LazySets.Arrays","text":"Module Arrays.jl – Auxiliary machinery for vectors and matrices.\n\n\n\n\n\n","category":"module"},{"location":"lib/utils/#LazySets.Arrays.cross_product-Union{Tuple{AbstractArray{N,2}}, Tuple{N}} where N<:Real","page":"Utility Functions","title":"LazySets.Arrays.cross_product","text":"cross_product(M::AbstractMatrix{N}) where {N<:Real}\n\nCompute the high-dimensional cross product of n-1 n-dimensional vectors.\n\nInput\n\nM – n  n - 1-dimensional matrix\n\nOutput\n\nA vector.\n\nAlgorithm\n\nThe cross product is defined as follows:\n\nleft dots (-1)^n+1 det(M^i) dots right^T\n\nwhere M^i is defined as M with the i-th row removed. See Althoff, Stursberg, Buss: Computing Reachable Sets of Hybrid Systems Using a Combination of Zonotopes and Polytopes. 2009.\n\n\n\n\n\n","category":"method"},{"location":"lib/utils/#LazySets.Arrays.nonzero_columns","page":"Utility Functions","title":"LazySets.Arrays.nonzero_columns","text":"nonzero_columns(A::AbstractMatrix)\n\nReturn all columns that have at least one non-zero entry.\n\nInput\n\nA – matrix\n\nOutput\n\nA vector of indices.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays.dot_zero","page":"Utility Functions","title":"LazySets.Arrays.dot_zero","text":"dot_zero(x::AbstractVector{N}, y::AbstractVector{N}) where{N<:Real}\n\nDot product with preference for zero value in the presence of infinity values.\n\nInput\n\nx – first vector\ny – second vector\n\nOutput\n\nThe dot product of x and y, but with the rule that 0 * Inf == 0.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays.hasfullrowrank","page":"Utility Functions","title":"LazySets.Arrays.hasfullrowrank","text":"hasfullrowrank(M::AbstractMatrix)\n\nCheck whether a matrix has full row rank.\n\nInput\n\nM – matrix\n\nOutput\n\ntrue iff the matrix has full row rank.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays.inner","page":"Utility Functions","title":"LazySets.Arrays.inner","text":"inner(x::AbstractVector{N}, A::AbstractMatrix{N}, y::AbstractVector{N}\n     ) where {N}\n\nCompute the inner product xᵀ A y.\n\nInput\n\nx – vector on the left\nA – matrix\ny – vector on the right\n\nOutput\n\nThe (scalar) result of the multiplication.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays.is_cyclic_permutation","page":"Utility Functions","title":"LazySets.Arrays.is_cyclic_permutation","text":"is_cyclic_permutation(candidate::AbstractVector, paragon::AbstractVector)\n\nChecks if the elements in candidate are a cyclic permutation of the elements in paragon.\n\nInput\n\ncandidate – candidate vector\nparagon   – paragon vector\n\nOutput\n\nA boolean indicating if the elements of candidate are in the same order as in paragon or any of its cyclic permutations.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays.isinvertible","page":"Utility Functions","title":"LazySets.Arrays.isinvertible","text":"isinvertible(M::Matrix; [cond_tol]::Number=DEFAULT_COND_TOL)\n\nA sufficient check of a matrix being invertible (or nonsingular).\n\nInput\n\nM        – matrix\ncond_tol – (optional, default: DEFAULT_COND_TOL) tolerance of matrix               condition\n\nOutput\n\nIf the result is true, M is invertible. If the result is false, the matrix is non-square or this function could not conclude.\n\nAlgorithm\n\nWe check whether the matrix is square and whether the matrix condition number cond(M) is below some prescribed tolerance.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.ispermutation","page":"Utility Functions","title":"LazySets.ispermutation","text":"ispermutation(u::AbstractVector{T}, v::AbstractVector) where {T}\n\nCheck that two vectors contain the same elements up to reordering.\n\nInput\n\nu – first vector\nv – second vector\n\nOutput\n\ntrue iff the vectors are identical up to reordering.\n\nExamples\n\njulia> LazySets.ispermutation([1, 2, 2], [2, 2, 1])\ntrue\n\njulia> LazySets.ispermutation([1, 2, 2], [1, 1, 2])\nfalse\n\nNotes\n\nContainment check is performed using LazySets._in(e, v), so in the case of floating point numbers, the precision to which the check is made is determined by the type of elements in v. See _in and _isapprox for more information.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays.is_right_turn","page":"Utility Functions","title":"LazySets.Arrays.is_right_turn","text":"is_right_turn([O::AbstractVector{N}=[0, 0]], u::AbstractVector{N},\n              v::AbstractVector{N}) where {N<:Real}\n\nDetermine whether the acute angle defined by three 2D points O, u, v in the plane is a right turn (< 180° counter-clockwise) with respect to the center O. Determine if the acute angle defined by two 2D vectors is a right turn (< 180° counter-clockwise) with respect to the center O.\n\nInput\n\nO – (optional; default: [0, 0]) 2D center point\nu – first 2D direction\nv – second 2D direction\n\nOutput\n\ntrue iff the vectors constitute a right turn.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays.issquare","page":"Utility Functions","title":"LazySets.Arrays.issquare","text":"issquare(M::AbstractMatrix)\n\nCheck whether a matrix is square.\n\nInput\n\nM – matrix\n\nOutput\n\ntrue iff the matrix is square.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays.nonzero_indices","page":"Utility Functions","title":"LazySets.Arrays.nonzero_indices","text":"nonzero_indices(v::AbstractVector{N}) where {N<:Real}\n\nReturn the indices in which a vector is non-zero.\n\nInput\n\nv – vector\n\nOutput\n\nA vector of ascending indices i such that the vector is non-zero in dimension i.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays.remove_duplicates_sorted!","page":"Utility Functions","title":"LazySets.Arrays.remove_duplicates_sorted!","text":"remove_duplicates_sorted!(v::AbstractVector)\n\nRemove duplicate entries in a sorted vector.\n\nInput\n\nv – sorted vector\n\nOutput\n\nThe input vector without duplicates.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays.remove_zero_columns","page":"Utility Functions","title":"LazySets.Arrays.remove_zero_columns","text":"remove_zero_columns(A::AbstractMatrix)\n\nReturn a matrix with all columns containing only zero entries removed.\n\nInput\n\nA – matrix\n\nOutput\n\nThe original matrix A if it contains no zero columns or otherwise a new matrix where those columns have been removed.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays.right_turn","page":"Utility Functions","title":"LazySets.Arrays.right_turn","text":"right_turn([O::AbstractVector{N}=[0, 0]], u::AbstractVector{N},\n           v::AbstractVector{N}) where {N<:Real}\n\nCompute a scalar that determines whether the acute angle defined by three 2D points O, u, v in the plane is a right turn (< 180° counter-clockwise) with respect to the center O.\n\nInput\n\nO – (optional; default: [0, 0]) 2D center point\nu – first 2D point\nv – second 2D point\n\nOutput\n\nA scalar representing the rotation. If the result is 0, the points are collinear; if it is positive, the points constitute a positive angle of rotation around O from u to v; otherwise they constitute a negative angle.\n\nAlgorithm\n\nThe cross product is used to determine the sense of rotation.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays.samedir","page":"Utility Functions","title":"LazySets.Arrays.samedir","text":"samedir(u::AbstractVector{N}, v::AbstractVector{N}) where {N<:Real}\n\nCheck whether two vectors point in the same direction.\n\nInput\n\nu – first vector\nv – second vector\n\nOutput\n\n(true, k) iff the vectors are identical up to a positive scaling factor k, and (false, 0) otherwise.\n\nExamples\n\njulia> using LazySets: samedir\n\njulia> samedir([1, 2, 3], [2, 4, 6])\n(true, 0.5)\n\njulia> samedir([1, 2, 3], [3, 2, 1])\n(false, 0)\n\njulia> samedir([1, 2, 3], [-1, -2, -3])\n(false, 0)\n\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays.SingleEntryVector","page":"Utility Functions","title":"LazySets.Arrays.SingleEntryVector","text":"SingleEntryVector{N} <: AbstractVector{N}\n\nA lazy unit vector with arbitrary one-element.\n\nFields\n\ni – index of non-zero entry\nn – vector length\nv – non-zero entry\n\n\n\n\n\n","category":"type"},{"location":"lib/utils/#LazySets.Arrays.to_negative_vector","page":"Utility Functions","title":"LazySets.Arrays.to_negative_vector","text":"to_negative_vector(v::AbstractVector{N}) where {N}\n\nNegate a vector and convert to type Vector.\n\nInput\n\nv – vector\n\nOutput\n\nA Vector equivalent to -v.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays._up","page":"Utility Functions","title":"LazySets.Arrays._up","text":"_up(u::AbstractVector, v::AbstractVector)\n\nChecks if the given vector is pointing towards the given direction.\n\nInput\n\nu – direction\nv – vector\n\nOutput\n\nA boolean indicating if the vector is pointing towards the direction.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays._dr","page":"Utility Functions","title":"LazySets.Arrays._dr","text":"_dr(u::AbstractVector, Vi::AbstractVector, Vj::AbstractVector)\n\nReturns the direction of the difference of the given vectors.\n\nInput\n\nu – direction\nVi – first vector\nVj – second vector\n\nOutput\n\nA number indicating the direction of the difference of the given vectors.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays._above","page":"Utility Functions","title":"LazySets.Arrays._above","text":"_above(u::AbstractVector, Vi::AbstractVector, Vj::AbstractVector)\n\nChecks if the difference of the given vectors is pointing towards the given direction.\n\nInput\n\nu – direction\nVi – first vector\nVj – second vector\n\nOutput\n\nA boolean indicating if the difference of the given vectors is pointing towards the given direction.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.minmax","page":"Utility Functions","title":"LazySets.minmax","text":"minmax(A, B, C)\n\nCompute the minimum and maximum of three numbers A, B, C.\n\nInput\n\nA – first number\nB – second number\nC – third number\n\nOutput\n\nThe minimum and maximum of three given numbers.\n\nExamples\n\njulia> LazySets.minmax(1.4, 52.4, -5.2)\n(-5.2, 52.4)\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.arg_minmax","page":"Utility Functions","title":"LazySets.arg_minmax","text":"arg_minmax(A, B, C)\n\nCompute the index (1, 2, 3) of the minimum and maximum of three numbers A, B, C.\n\nInput\n\nA – first number\nB – second number\nC – third number\n\nOutput\n\nThe index of the minimum and maximum of the three given numbers.\n\nExamples\n\njulia> LazySets.arg_minmax(1.4, 52.4, -5.2)\n(3, 2)\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays.extend","page":"Utility Functions","title":"LazySets.Arrays.extend","text":"extend(M::AbstractMatrix; check_rank=true)\n\nReturn an invertible extension of M whose first n columns span the column space of M, assuming that size(M) = (m, n), m > n and the rank of M is n.\n\nInput\n\nM          – rectangular m × n matrix with m > n and full rank (i.e. its                 rank is n)\ncheck_rank – (optional, default: true) if true, check the rank assumption,                 otherwise do not perform this check\n\nOutput\n\nThe tuple (Mext, inv_Mext), where Mext is a square m × m invertible matrix that extends M, i.e. in the sense that Mext = [M | Q2], and the rank of Mext is m. Here, inv_Mext is the inverse of Mext.\n\nAlgorithm\n\nFirst we compute the QR decomposition of M to extract a suitable subspace of column vectors (Q2) that are orthogonal to the column span of M. Then we observe that the inverse of the extended matrix Mext = [M | Q2] is [R⁻¹Qᵀ; Q2ᵀ].\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays.projection_matrix","page":"Utility Functions","title":"LazySets.Arrays.projection_matrix","text":"projection_matrix(block::AbstractVector{Int}, n::Int, [N]::DataType=Float64)\n\nReturn the projection matrix associated to the given block of variables.\n\nInput\n\nblock – integer vector with the variables of interest\nn     – integer representing the ambient dimension\nN     – (optional, default: Float64) number type\n\nOutput\n\nA sparse matrix that corresponds to the projection onto the variables in block.\n\nExamples\n\njulia> using LazySets: projection_matrix\n\njulia> projection_matrix([1, 3], 4)\n2×4 SparseArrays.SparseMatrixCSC{Float64,Int64} with 2 stored entries:\n  [1, 1]  =  1.0\n  [2, 3]  =  1.0\n\njulia> Matrix(ans)\n2×4 Array{Float64,2}:\n 1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays._vector_type","page":"Utility Functions","title":"LazySets.Arrays._vector_type","text":"_vector_type(T)\n\nReturn a corresponding vector type with respect to type T.\n\nInput\n\nT – vector or matrix type\n\nOutput\n\nA vector type that corresponds in some sense (see Notes below) to T.\n\nNotes\n\nIf T is a sparse vector or a sparse matrix, the corresponding type is also a sparse vector.\nIf T is a regular vector (i.e. Vector) or a regular matrix (i.e. Matrix), the corresponding type is also a regular vector.\nOtherwise, the corresponding type is a regular vector.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays._matrix_type","page":"Utility Functions","title":"LazySets.Arrays._matrix_type","text":"_matrix_type(T)\n\nReturn a corresponding matrix type with respect to type T.\n\nInput\n\nT – vector or matrix type\n\nOutput\n\nA matrix type that corresponds in some sense (see Notes below) to T.\n\nNotes\n\nIf T is a sparse vector or a sparse matrix, the corresponding type is also a sparse matrix.\nIf T is a regular vector (i.e. Vector) or a regular matrix (i.e. Matrix), the corresponding type is also a regular matrix.\nOtherwise, the corresponding type is a regular matrix.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#Functions-and-Macros","page":"Utility Functions","title":"Functions and Macros","text":"","category":"section"},{"location":"lib/utils/","page":"Utility Functions","title":"Utility Functions","text":"an_element_helper\nbinary_search_constraints\nget_radius!\nis_tighter_same_dir_2D\nsign_cadlag\n_leq_trig\n_random_zero_sum_vector\nrectify\nrequire(::Symbol)\nreseed\nsame_block_structure\nsubstitute\nsubstitute!\nσ_helper\nget_constrained_lowdimset\n@neutral\n@absorbing\n@neutral_absorbing\n@declare_array_version\n@array_neutral\n@array_absorbing","category":"page"},{"location":"lib/utils/#LazySets.an_element_helper","page":"Utility Functions","title":"LazySets.an_element_helper","text":"an_element_helper(hp::Hyperplane{N},\n                  [nonzero_entry_a]::Int) where {N<:Real}\n\nHelper function that computes an element on a hyperplane's hyperplane.\n\nInput\n\nhp – hyperplane\nnonzero_entry_a – (optional, default: computes the first index) index i                      such that hp.a[i] is different from 0\n\nOutput\n\nAn element on a hyperplane.\n\nAlgorithm\n\nWe compute the point on the hyperplane as follows:\n\nWe already found a nonzero entry of a in dimension, say, i.\nWe set xi = b  ai.\nWe set xj = 0 for all j  i.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.binary_search_constraints","page":"Utility Functions","title":"LazySets.binary_search_constraints","text":"binary_search_constraints(d::AbstractVector{N},\n                          constraints::Vector{<:LinearConstraint{N}},\n                          n::Int,\n                          k::Int;\n                          [choose_lower]::Bool=false) where {N}\n\nPerforms a binary search in the constraints.\n\nInput\n\nd            – direction\nconstraints  – constraints\nn            – number of constraints\nk            – start index\nchoose_lower – (optional, default: false) flag for choosing the lower                   index (see the 'Output' section)\n\nOutput\n\nIn the default setting, the result is the smallest index k such that d <= constraints[k], or n+1 if no such k exists. If the choose_lower flag is set, the result is the largest index k such that constraints[k] < d, which is equivalent to being k-1 in the normal setting.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.get_radius!","page":"Utility Functions","title":"LazySets.get_radius!","text":"get_radius!(sih::SymmetricIntervalHull{N},\n            i::Int,\n            n::Int=dim(sih)) where {N<:Real}\n\nCompute the radius of a symmetric interval hull of a convex set in a given dimension.\n\nInput\n\nsih – symmetric interval hull of a convex set\ni   – dimension in which the radius should be computed\nn   – (optional, default: dim(sih)) set dimension\n\nOutput\n\nThe radius of a symmetric interval hull of a convex set in a given dimension.\n\nAlgorithm\n\nWe ask for the support vector of the underlying set for both the positive and negative unit vector in the dimension i.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.is_tighter_same_dir_2D","page":"Utility Functions","title":"LazySets.is_tighter_same_dir_2D","text":"is_tighter_same_dir_2D(c1::LinearConstraint{N},\n                       c2::LinearConstraint{N}) where {N<:Real}\n\nCheck if the first of two two-dimensional constraints with equivalent normal direction is tighter.\n\nInput\n\nc1     – first linear constraint\nc2     – second linear constraint\nstrict – (optional; default: false) check for strictly tighter             constraints?\n\nOutput\n\ntrue iff the first constraint is tighter.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.sign_cadlag","page":"Utility Functions","title":"LazySets.sign_cadlag","text":"sign_cadlag(x::N) where {N<:Real}\n\nThis function works like the sign function but is 1 for input 0.\n\nInput\n\nx – real scalar\n\nOutput\n\n1 if x  0, -1 otherwise.\n\nNotes\n\nThis is the sign function right-continuous at zero (see càdlàg function). It can be used with vector-valued arguments via the dot operator.\n\nExamples\n\njulia> LazySets.sign_cadlag.([-0.6, 1.3, 0.0])\n3-element Array{Float64,1}:\n -1.0\n  1.0\n  1.0\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets._leq_trig","page":"Utility Functions","title":"LazySets._leq_trig","text":"_leq_trig(u::AbstractVector{N}, v::AbstractVector{N}) where {N<:AbstractFloat}\n\nCompares two 2D vectors by their direction.\n\nInput\n\nu –  first 2D direction\nv –  second 2D direction\n\nOutput\n\ntrue iff arg(u) 2π  arg(v) 2π.\n\nNotes\n\nThe argument is measured in counter-clockwise fashion, with the 0 being the direction (1, 0).\n\nAlgorithm\n\nThe implementation uses the arctangent function with sign, atan, which for two arguments implements the atan2 function.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets._random_zero_sum_vector","page":"Utility Functions","title":"LazySets._random_zero_sum_vector","text":"_random_zero_sum_vector(rng::AbstractRNG, N::Type{<:Real}, n::Int)\n\nCreate a random vector with entries whose sum is zero.\n\nInput\n\nrng – random number generator\nN   – numeric type\nn   – length of vector\n\nOutput\n\nA random vector of random numbers such that all positive entries come first and all negative entries come last, and such that the total sum is zero.\n\nAlgorithm\n\nThis is a preprocessing step of the algorithm here based on P. Valtr. Probability that n random points are in convex position.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Arrays.rectify","page":"Utility Functions","title":"LazySets.Arrays.rectify","text":"rectify(x::AbstractVector{N}) where {N<:Real}\n\nRectify a vector, i.e., take the element-wise maximum with zero.\n\nInput\n\nx – vector\n\nOutput\n\nA copy of the vector where each negative entry is replaced by zero.\n\n\n\n\n\nrectify(H::AbstractHyperrectangle)\n\nConcrete rectification of a hyperrectangular set.\n\nInput\n\nH – hyperrectangular set\n\nOutput\n\nThe Hyperrectangle that corresponds to the rectification of H.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.require-Tuple{Symbol}","page":"Utility Functions","title":"LazySets.require","text":"require(package::Symbol; fun_name::String=\"\", explanation::String=\"\")\n\nHelper method to check for optional packages and printing an error message.\n\nInput\n\npackage     – symbol of the package name\nfun_name    – (optional; default: \"\") name of the function that requires                  the package\nexplanation – (optional; default: \"\") additional explanation in the error                  message\n\nOutput\n\nIf the package is loaded, this function has no effect. Otherwise it prints an error message.\n\nAlgorithm\n\nThis function uses @assert and hence loses its ability to print an error message if assertions are deactivated.\n\n\n\n\n\n","category":"method"},{"location":"lib/utils/#LazySets.reseed","page":"Utility Functions","title":"LazySets.reseed","text":"reseed(rng::AbstractRNG, seed::Union{Int, Nothing})\n\nReset the RNG seed if the seed argument is a number.\n\nInput\n\nrng  – random number generator\nseed – seed for reseeding\n\nOutput\n\nThe input RNG if the seed is nothing, and a reseeded RNG otherwise.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.same_block_structure","page":"Utility Functions","title":"LazySets.same_block_structure","text":"sameblockstructure(x::AbstractVector{S1}, y::AbstractVector{S2}                        ) where {S1<:LazySet, S2<:LazySet}\n\nCheck whether two vectors of sets have the same block structure, i.e., the i-th entry in the vectors have the same dimension.\n\nInput\n\nx – first vector\ny – second vector\n\nOutput\n\ntrue iff the vectors have the same block structure.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.substitute","page":"Utility Functions","title":"LazySets.substitute","text":"substitute(substitution::Dict{Int, T}, x::AbstractVector{T}) where {T}\n\nApply a substitution to a given vector.\n\nInput\n\nsubstitution – substitution (a mapping from an index to a new value)\nx            – vector\n\nOutput\n\nA fresh vector corresponding to x after substitution was applied.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.substitute!","page":"Utility Functions","title":"LazySets.substitute!","text":"substitute!(substitution::Dict{Int, T}, x::AbstractVector{T}) where {T}\n\nApply a substitution to a given vector.\n\nInput\n\nsubstitution – substitution (a mapping from an index to a new value)\nx            – vector (modified in this function)\n\nOutput\n\nThe same (but see the Notes below) vector x but after substitution was applied.\n\nNotes\n\nThe vector x is modified in-place if it has type Vector or SparseVector. Otherwise, we first create a new Vector from it.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.σ_helper","page":"Utility Functions","title":"LazySets.σ_helper","text":"    σ_helper(d::AbstractVector{N},\n             hp::Hyperplane{N};\n             error_unbounded::Bool=true,\n             [halfspace]::Bool=false) where {N<:Real}\n\nReturn the support vector of a hyperplane.\n\nInput\n\nd         – direction\nhp        – hyperplane\nerror_unbounded – (optional, default: true) true if an error should be                thrown whenever the set is                unbounded in the given direction\nhalfspace – (optional, default: false) true if the support vector                should be computed for a half-space\n\nOutput\n\nA pair (v, b) where v is a vector and b is a Boolean flag.\n\nThe flag b is false in one of the following cases:\n\nThe direction has norm zero.\nThe direction is the hyperplane's normal direction.\nThe direction is the opposite of the hyperplane's normal direction and\n\nhalfspace is false. In all these cases, v is any point on the hyperplane.\n\nOtherwise, the flag b is true, the set is unbounded in the given direction, and v is any vector.\n\nIf error_unbounded is true and the set is unbounded in the given direction, this function throws an error instead of returning.\n\nNotes\n\nFor correctness, consider the weak duality of LPs: If the primal is unbounded, then the dual is infeasible. Since there is only a single constraint, the feasible set of the dual problem is hp.a ⋅ y == d, y >= 0 (with objective function hp.b ⋅ y). It is easy to see that this problem is infeasible whenever a is not parallel to d.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.get_constrained_lowdimset","page":"Utility Functions","title":"LazySets.get_constrained_lowdimset","text":"get_constrained_lowdimset(cpa::CartesianProductArray{N, S},\n                          P::AbstractPolyhedron{N}\n                         ) where {N<:Real, S<:LazySet{N}}\n\nPreprocess step for intersection between Cartesian product array and polyhedron. Returns low-dimensional a CartesianProductArray in the constrained dimensions of the original cpa, constrained variables and variables in corresponding blocks, original block structure of low-dimensional set and list of constrained blocks.\n\nInput\n\ncpa – Cartesian product array of convex sets\nP   – polyhedron\n\nOutput\n\nA tuple of low-dimensional set, list of constrained dimensions, original block structure of low-dimensional set and corresponding blocks indices.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.@neutral","page":"Utility Functions","title":"LazySets.@neutral","text":"@neutral(SET, NEUT)\n\nCreate functions to make a lazy set operation commutative with a given neutral element set type.\n\nInput\n\nSET  – lazy set operation type\nNEUT – set type for neutral element\n\nOutput\n\nNothing.\n\nNotes\n\nThis macro generates four functions (possibly two more if @absorbing has been used in advance) (possibly two or four more if @declare_array_version has been used in advance).\n\nExamples\n\n@neutral(MinkowskiSum, N) creates at least the following functions:\n\nneutral(::MinkowskiSum) = N\nMinkowskiSum(X, N) = X\nMinkowskiSum(N, X) = X\nMinkowskiSum(N, N) = N\n\n\n\n\n\n","category":"macro"},{"location":"lib/utils/#LazySets.@absorbing","page":"Utility Functions","title":"LazySets.@absorbing","text":"@absorbing(SET, ABS)\n\nCreate functions to make a lazy set operation commutative with a given absorbing element set type.\n\nInput\n\nSET – lazy set operation type\nABS – set type for absorbing element\n\nOutput\n\nNothing.\n\nNotes\n\nThis macro generates four functions (possibly two more if @neutral has been used in advance) (possibly two or four more if @declare_array_version has been used in advance).\n\nExamples\n\n@absorbing(MinkowskiSum, A) creates at least the following functions:\n\nabsorbing(::MinkowskiSum) = A\nMinkowskiSum(X, A) = A\nMinkowskiSum(A, X) = A\nMinkowskiSum(A, A) = A\n\n\n\n\n\n","category":"macro"},{"location":"lib/utils/#LazySets.@neutral_absorbing","page":"Utility Functions","title":"LazySets.@neutral_absorbing","text":"@neutral_absorbing(SET, NEUT, ABS)\n\nCreate two functions to avoid method ambiguties for a lazy set operation with respect to neutral and absorbing element set types.\n\nInput\n\nSET  – lazy set operation type\nNEUT – set type for neutral element\nABS  – set type for absorbing element\n\nOutput\n\nA quoted expression containing the function definitions.\n\nExamples\n\n@neutral_absorbing(MinkowskiSum, N, A) creates the following functions as quoted expressions:\n\nMinkowskiSum(N, A) = A\nMinkowskiSum(A, N) = A\n\n\n\n\n\n","category":"macro"},{"location":"lib/utils/#LazySets.@declare_array_version","page":"Utility Functions","title":"LazySets.@declare_array_version","text":"@declare_array_version(SET, SETARR)\n\nCreate functions to connect a lazy set operation with its array set type.\n\nInput\n\nSET    – lazy set operation type\nSETARR – array set type\n\nOutput\n\nNothing.\n\nNotes\n\nThis macro generates six functions (and possibly up to eight more if @neutral/@absorbing has been used in advance for the base and/or array set type).\n\nExamples\n\n@declare_array_version(MinkowskiSum, MinkowskiSumArray) creates at least the following functions:\n\narray_constructor(::MinkowskiSum) = MinkowskiSumArray\nis_array_constructor(::MinkowskiSumArray) = true\nMinkowskiSum!(X, Y)\nMinkowskiSum!(X, arr)\nMinkowskiSum!(arr, X)\nMinkowskiSum!(arr1, arr2)\n\n\n\n\n\n","category":"macro"},{"location":"lib/utils/#LazySets.@array_neutral","page":"Utility Functions","title":"LazySets.@array_neutral","text":"@array_neutral(FUN, NEUT, SETARR)\n\nCreate two functions to avoid method ambiguities for a lazy set operation with respect to the neutral element set type and the array set type.\n\nInput\n\nFUN     – function name\nNEUT    – set type for neutral element\nSETARR  – array set type\n\nOutput\n\nA quoted expression containing the function definitions.\n\nExamples\n\n@array_neutral(MinkowskiSum, N, ARR) creates the following functions as quoted expressions:\n\nMinkowskiSum(N, ARR) = ARR\nMinkowskiSum(ARR, N) = ARR\n\n\n\n\n\n","category":"macro"},{"location":"lib/utils/#LazySets.@array_absorbing","page":"Utility Functions","title":"LazySets.@array_absorbing","text":"@array_absorbing(FUN, ABS, SETARR)\n\nCreate two functions to avoid method ambiguities for a lazy set operation with respect to the absorbing element set type and the array set type.\n\nInput\n\nFUN     – function name\nABS     – set type for absorbing element\nSETARR  – array set type\n\nOutput\n\nA quoted expression containing the function definitions.\n\nExamples\n\n@array_absorbing(MinkowskiSum, ABS, ARR) creates the following functions as quoted expressions:\n\nMinkowskiSum(ABS, ARR) = ABS\nMinkowskiSum(ARR, ABS) = ABS\n\n\n\n\n\n","category":"macro"},{"location":"lib/utils/#Types","page":"Utility Functions","title":"Types","text":"","category":"section"},{"location":"lib/utils/","page":"Utility Functions","title":"Utility Functions","text":"CachedPair\nStrictlyIncreasingIndices","category":"page"},{"location":"lib/utils/#LazySets.CachedPair","page":"Utility Functions","title":"LazySets.CachedPair","text":"CachedPair{N}\n\nA mutable pair of an index and a vector.\n\nFields\n\nidx – index\nvec – vector\n\n\n\n\n\n","category":"type"},{"location":"lib/utils/#LazySets.StrictlyIncreasingIndices","page":"Utility Functions","title":"LazySets.StrictlyIncreasingIndices","text":"StrictlyIncreasingIndices\n\nIterator over the vectors of m strictly increasing indices from 1 to n.\n\nFields\n\nn – size of the index domain\nm – number of indices to choose (resp. length of the vectors)\n\nNotes\n\nThe vectors are modified in-place.\n\nThe iterator ranges over binomnm (n choose m) possible vectors.\n\nThis implementation results in a lexicographic order with the last index growing first.\n\nExamples\n\njulia> for v in LazySets.StrictlyIncreasingIndices(4, 2)\n           println(v)\n       end\n[1, 2]\n[1, 3]\n[1, 4]\n[2, 3]\n[2, 4]\n[3, 4]\n\n\n\n\n\n","category":"type"},{"location":"lib/utils/#Inspection-of-set-interfaces","page":"Utility Functions","title":"Inspection of set interfaces","text":"","category":"section"},{"location":"lib/utils/","page":"Utility Functions","title":"Utility Functions","text":"LazySets.subtypes(::Any, ::Bool)\nimplementing_sets","category":"page"},{"location":"lib/utils/#InteractiveUtils.subtypes-Tuple{Any,Bool}","page":"Utility Functions","title":"InteractiveUtils.subtypes","text":"subtypes(interface, concrete::Bool)\n\nReturn the concrete subtypes of a given interface.\n\nInput\n\ninterface – an abstract type, usually a set interface\nconcrete  – if true, seek further the inner abstract subtypes of the given                interface, otherwise return only the direct subtypes of interface\n\nOutput\n\nA list with the subtypes of the abstract type interface, sorted alphabetically.\n\nExamples\n\nConsider the AbstractPolytope interface. If we include the abstract subtypes of this interface,\n\njulia> using LazySets: subtypes\n\njulia> subtypes(AbstractPolytope, false)\n4-element Array{Any,1}:\n AbstractCentrallySymmetricPolytope\n AbstractPolygon\n HPolytope\n VPolytope\n\nWe can use this function to obtain the concrete subtypes of AbstractCentrallySymmetricPolytope and AbstractPolygon (further until all concrete types are obtained), using the concrete flag:\n\njulia> subtypes(AbstractPolytope, true)\n14-element Array{Type,1}:\n Ball1\n BallInf\n HPolygon\n HPolygonOpt\n HPolytope\n Hyperrectangle\n Interval\n LineSegment\n Singleton\n SymmetricIntervalHull\n VPolygon\n VPolytope\n ZeroSet\n Zonotope\n\n\n\n\n\n","category":"method"},{"location":"lib/utils/#LazySets.implementing_sets","page":"Utility Functions","title":"LazySets.implementing_sets","text":"implementing_sets(op::Function;\n                  signature::Tuple{Vector{Type}, Int}=(Type[], 1),\n                  type_args=Float64, binary::Bool=false)\n\nCompute a dictionary containing information about availability of (unary or binary) concrete set operations.\n\nInput\n\nop        – set operation (respectively its Function object)\nsignature – (optional, default: Type[]) the type signature of the                function without the LazySet type(s) (see also the index                option and the Examples section below)\nindex     – (optional, default: 1) index of the set type in the signature                in the unary case (see the binary option)\ntype_args – (optional, default: Float64) type arguments added to the                LazySet(s) when searching for available methods; valid                inputs are a type or nothing, and in the unary case (see the                binary option) it can also be a list of types\nbinary    – (optional, default: false) flag indicating whether op is a                binary function (true) or a unary function (false)\n\nOutput\n\nA dictionary with three keys each mapping to a list:\n\n\"available\" – This list contains all set types such that there exists an                  implementation of op.\n\"missing\"   – This list contains all set types such that there does not                  exist an implementation of op. Note that this is the                  complement of the \"available\" list.\n\"specific\"  – This list contains all set types such that there exists a                  type-specific implementation. Note that those set types also                  occur in the \"available\" list.\n\nIn the unary case, the lists contain set types. In the binary case, the lists contain pairs of set types.\n\nExamples\n\njulia> using LazySets: implementing_sets\n\njulia> dict = implementing_sets(tovrep);\n\njulia> dict[\"available\"]  # tovrep is only available for polyhedral set types\n6-element Array{Type,1}:\n HPolygon\n HPolygonOpt\n HPolyhedron\n HPolytope\n VPolygon\n VPolytope\n\njulia> dict = implementing_sets(σ; signature=Type[AbstractVector{Float64}], index=2);\n\njulia> dict[\"missing\"]  # every set type implements function σ\n0-element Array{Type,1}\n\njulia> N = Rational{Int};  # restriction of the number type\n\njulia> dict = implementing_sets(σ; signature=Type[AbstractVector{N}], index=2, type_args=N);\n\njulia> dict[\"missing\"]  # some set types are not available with number type N\n4-element Array{Type,1}:\n Ball2\n Ballp\n Bloating\n Ellipsoid\n\njulia> dict = LazySets.implementing_sets(convex_hull; binary=true);  # binary case\n\njulia> (HPolytope, HPolytope) ∈ dict[\"available\"]  # dict contains pairs now\ntrue\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#Sampling","page":"Utility Functions","title":"Sampling","text":"","category":"section"},{"location":"lib/utils/","page":"Utility Functions","title":"Utility Functions","text":"_sample_unit_nsphere_muller!\n_sample_unit_nball_muller!\nsample\nLazySets.Sampler\nLazySets.RejectionSampler{S<:LazySet, D<:Distribution}\nLazySets._sample!","category":"page"},{"location":"lib/utils/#LazySets._sample_unit_nsphere_muller!","page":"Utility Functions","title":"LazySets._sample_unit_nsphere_muller!","text":"_sample_unit_nsphere_muller!(D::Vector{Vector{N}}, n::Int, p::Int;\n                             rng::AbstractRNG=GLOBAL_RNG,\n                             seed::Union{Int, Nothing}=nothing) where {N}\n\nDraw samples from a uniform distribution on an n-dimensional unit sphere using Muller's method.\n\nInput\n\nD    – output, vector of points\nn    – dimension of the sphere\np    – number of random samples\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA vector of nsamples vectors.\n\nAlgorithm\n\nThis function implements Muller's method of normalised Gaussians [1] to uniformly sample over the n-dimensional sphere S^n (which is the bounding surface of the n-dimensional unit ball).\n\nGiven n canonical Gaussian random variables Z₁ Z₂  Z_n, the distribution of the vectors\n\ndfrac1αleft(z₁ z₂  z_nright)^T\n\nwhere α = sqrtz₁² + z₂² +  + z_n², is uniform over S^n.\n\n[1] Muller, Mervin E. A note on a method for generating points uniformly on     n-dimensional spheres. Communications of the ACM 2.4 (1959): 19-20.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets._sample_unit_nball_muller!","page":"Utility Functions","title":"LazySets._sample_unit_nball_muller!","text":"_sample_unit_nball_muller!(D::Vector{Vector{N}}, n::Int, p::Int;\n                           rng::AbstractRNG=GLOBAL_RNG,\n                           seed::Union{Int, Nothing}=nothing) where {N}\n\nDraw samples from a uniform distribution on an n-dimensional unit ball using Muller's method.\n\nInput\n\nD    – output, vector of points\nn    – dimension of the ball\np    – number of random samples\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA vector of nsamples vectors.\n\nAlgorithm\n\nThis function implements Muller's method of normalised Gaussians [1] to sample from the interior of the ball.\n\nGiven n Gaussian random variables Z₁ Z₂  Z_n and a uniformly distributed random variable r with support in 0 1, the distribution of the vectors\n\ndfracr^1nα left(z₁ z₂  z_nright)^T\n\nwhere α = sqrtz₁² + z₂² +  + z_n², is uniform over the n-dimensional unit ball.\n\n[1] Muller, Mervin E. A note on a method for generating points uniformly on     n-dimensional spheres. Communications of the ACM 2.4 (1959): 19-20.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.sample","page":"Utility Functions","title":"LazySets.sample","text":"sample(B::Ball2{N, VN}, nsamples::Int=1;\n       [rng]::AbstractRNG=GLOBAL_RNG,\n       [seed]::Union{Int, Nothing}=nothing) where {N<:AbstractFloat, VN<:AbstractVector{N}}\n\nReturn samples from a uniform distribution on the given ball in the 2-norm.\n\nInput\n\nB        – ball in the 2-norm\nnsamples – (optional, default: 1) number of samples\nrng      – (optional, default: GLOBAL_RNG) random number generator\nseed     – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA linear array of nsamples elements drawn from a uniform distribution in B.\n\nAlgorithm\n\nRandom sampling with uniform distribution in B is computed using Muller's method of normalized Gaussians. This function requires the package Distributions. See _sample_unit_nball_muller! for implementation details.\n\n\n\n\n\nsample(X::LazySet{N}, num_samples::Int;\n       [sampler]=nothing,\n       [rng]::AbstractRNG=GLOBAL_RNG,\n       [seed]::Union{Int, Nothing}=nothing) where {N}\n\nSampling of an arbitrary bounded set X.\n\nInput\n\nX           – (bounded) set to be sampled\nnum_samples – number of random samples\nsampler     – sampler used (default: nothing, which falls back to                  RejectionSampler)\nrng         – (optional, default: GLOBAL_RNG) random number generator\nseed        – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA vector of num_samples vectors. If num_samples is not passed, the result is just one sample (not wrapped in a vector).\n\nAlgorithm\n\nSee the documentation of the respective Sampler.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#LazySets.Sampler","page":"Utility Functions","title":"LazySets.Sampler","text":"Sampler\n\nAbstract type for defining new sample methods.\n\nNotes\n\nAll subtypes should implement a _sample! method.\n\n\n\n\n\n","category":"type"},{"location":"lib/utils/#LazySets.RejectionSampler","page":"Utility Functions","title":"LazySets.RejectionSampler","text":"RejectionSampler{S<:LazySet, D<:Distribution} <: Sampler\n\nType used for rejection sampling of an arbitrary LazySet X.\n\nFields\n\nX          – (bounded) set to be sampled\nbox_approx – Distribution from which the sample is drawn\n\nAlgorithm\n\nDraw a sample x from a uniform distribution of a box-overapproximation of the original set X in all n dimensions. The function rejects a drawn sample x and redraws as long as the sample is not contained in the original set X, i.e., x  X.\n\n\n\n\n\n","category":"type"},{"location":"lib/utils/#LazySets._sample!","page":"Utility Functions","title":"LazySets._sample!","text":"_sample!(D::Vector{Vector{N}},\n         sampler::RejectionSampler;\n         rng::AbstractRNG=GLOBAL_RNG,\n         seed::Union{Int, Nothing}=nothing) where {N<:Real}\n\nSample points using rejection sampling.\n\nInput\n\nD           – output, vector of points\nsampler     – Sampler from which the points are sampled\nrng         – (optional, default: GLOBAL_RNG) random number generator\nseed        – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA vector of num_samples vectors.\n\n\n\n\n\n","category":"function"},{"location":"lib/utils/#Volume","page":"Utility Functions","title":"Volume","text":"","category":"section"},{"location":"lib/utils/","page":"Utility Functions","title":"Utility Functions","text":"volume","category":"page"},{"location":"lib/utils/#LazySets.volume","page":"Utility Functions","title":"LazySets.volume","text":"volume(H::AbstractHyperrectangle{N}) where {N<:Real}\n\nReturn the volume of a hyperrectangular set.\n\nInput\n\nH – hyperrectangular set\n\nOutput\n\nThe volume of H.\n\nAlgorithm\n\nThe volume of the n-dimensional hyperrectangle H with vector radius r is 2ⁿ ᵢ rᵢ where rᵢ denotes the i-th component of r.\n\n\n\n\n\nvolume(B::Ball2{N}) where {N<:AbstractFloat}\n\nReturn the volume of a ball in the 2-norm.\n\nInput\n\nB – ball in the 2-norm\n\nOutput\n\nThe volume of B.\n\nAlgorithm\n\nThis function implements the well-known formula for the volume of an n-dimensional ball using factorials. For details see the wikipedia article Volume of an n-ball.\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/Intersection/","page":"Intersection","title":"Intersection","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/lazy_operations/Intersection/#Intersection","page":"Intersection","title":"Intersection","text":"","category":"section"},{"location":"lib/lazy_operations/Intersection/#def_Intersection","page":"Intersection","title":"Binary intersection (Intersection)","text":"","category":"section"},{"location":"lib/lazy_operations/Intersection/","page":"Intersection","title":"Intersection","text":"Intersection\n∩(::LazySet, ::LazySet)\ndim(::Intersection)\nρ(::AbstractVector{N}, ::Intersection{N}) where {N<:Real}\nρ(::AbstractVector{N}, ::Intersection{N, S1, S2}) where {N<:Real, S1<:LazySet{N}, S2<:Union{HalfSpace{N}, Hyperplane{N}, Line2D{N}}}\nρ(::AbstractVector{N}, ::Intersection{N, S1, S2}) where {N<:Real, S1<:LazySet{N}, S2<:AbstractPolyhedron{N}}\nρ(::AbstractVector{N}, ::Intersection{N, S1, S2}) where {N<:Real, S1<:AbstractPolyhedron{N}, S2<:AbstractPolyhedron{N}}\nσ(::AbstractVector{N}, ::Intersection{N}) where {N<:Real}\nisbounded(::Intersection)\nisempty(::Intersection)\n∈(::AbstractVector{N}, ::Intersection{N}) where {N<:Real}\nconstraints_list(::Intersection{N}) where {N<:Real}\nisempty_known(::Intersection)\nset_isempty!(::Intersection, ::Bool)\nswap(::Intersection{N, S1, S2}) where {N<:Real, S1, S2}\nuse_precise_ρ\n_line_search\n_projection\nlinear_map(::AbstractMatrix{N}, ::Intersection{N}) where {N}\nplot_recipe(::Intersection{N}, ::N=zero(N), ::Int=40) where {N<:Real}\nRecipesBase.apply_recipe(::AbstractDict{Symbol,Any}, ::Intersection{N}, ::N=zero(N), ::Int=40) where {N<:Real}","category":"page"},{"location":"lib/lazy_operations/Intersection/#LazySets.Intersection","page":"Intersection","title":"LazySets.Intersection","text":"Intersection{N<:Real, S1<:LazySet{N}, S2<:LazySet{N}} <: LazySet{N}\n\nType that represents the intersection of two convex sets.\n\nFields\n\nX     – convex set\nY     – convex set\ncache – internal cache for avoiding recomputation; see            IntersectionCache\n\nExamples\n\nCreate an expression, Z, which lazily represents the intersection of two squares X and Y:\n\njulia> X, Y = BallInf([0,0.], 0.5), BallInf([1,0.], 0.75);\n\njulia> Z = X ∩ Y;\n\njulia> typeof(Z)\nIntersection{Float64,BallInf{Float64,Array{Float64,1}},BallInf{Float64,Array{Float64,1}}}\n\njulia> dim(Z)\n2\n\nWe can check if the intersection is empty with isempty:\n\njulia> isempty(Z)\nfalse\n\nDo not confuse Intersection with the concrete operation, which is computed with the lowercase intersection function:\n\njulia> W = intersection(X, Y)\nHyperrectangle{Float64,Array{Float64,1},Array{Float64,1}}([0.375, 0.0], [0.125, 0.5])\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/Intersection/#Base.:∩-Tuple{LazySet,LazySet}","page":"Intersection","title":"Base.:∩","text":"∩\n\nAlias for Intersection.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.dim-Tuple{Intersection}","page":"Intersection","title":"LazySets.dim","text":"dim(cap::Intersection)\n\nReturn the dimension of an intersection of two convex sets.\n\nInput\n\ncap – intersection of two convex sets\n\nOutput\n\nThe ambient dimension of the intersection of two convex sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}} where N<:Real","page":"Intersection","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, cap::Intersection{N}) where {N<:Real}\n\nReturn an upper bound on the support function of the intersection of two convex sets in a given direction.\n\nInput\n\nd    – direction\ncap  – intersection of two convex sets\n\nOutput\n\nAn uper bound on the support function in the given direction.\n\nAlgorithm\n\nThe support function of an intersection of X and Y is upper bounded by the minimum of the support functions of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2}}} where S2<:Union{HalfSpace{N,VN} where VN<:AbstractArray{N,1}, Hyperplane{N,VN} where VN<:AbstractArray{N,1}, Line2D{N,VN} where VN<:AbstractArray{N,1}} where S1<:LazySet{N} where N<:Real","page":"Intersection","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N},\n  cap::Intersection{N, S1, S2};\n  [algorithm]::String=\"line_search\",\n  [kwargs...]) where {N<:Real,\n                      S1<:LazySet{N},\n                      S2<:Union{HalfSpace{N}, Hyperplane{N}, Line2D{N}}}\n\nReturn the support function of the intersection of a compact set and a half-space/hyperplane/line in a given direction.\n\nInput\n\nd         – direction\ncap       – lazy intersection of a compact set and a half-space/hyperplane/                line\nalgorithm – (optional, default: \"line_search\"): the algorithm to                calculate the support function; valid options are:\n\"line_search\" – solve the associated univariate optimization problem                    using a line search method (either Brent or the                    Golden Section method)\n\"projection\"  – only valid for intersection with a hyperplane;                    evaluates the support function by reducing the problem                    to the 2D intersection of a rank 2 linear                    transformation of the given compact set in the plane                    generated by the given direction d and the                    hyperplane's normal vector n\n\"simple\"      – take the min of the support function evaluation                    of each operand\n\nOutput\n\nThe scalar value of the support function of the set cap in the given direction.\n\nNotes\n\nIt is assumed that the set cap.X is compact.\n\nAny additional number of arguments to the algorithm backend can be passed as keyword arguments.\n\nAlgorithm\n\nThe algorithms are based on solving the associated optimization problem\n\nmin_λ  D_h ρ(ℓ - λa X) + λb\n\nwhere D_h =  λ  λ  0  if H is a half-space or D_h =  λ  λ  mathbbR  if H is a hyperplane.\n\nFor additional information we refer to:\n\nG. Frehse, R. Ray. Flowpipe-Guard Intersection for Reachability Computations with Support Functions.\nC. Le Guernic. Reachability Analysis of Hybrid Systems with Linear Continuous Dynamics, PhD thesis.\nT. Rockafellar, R. Wets. Variational Analysis.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2}}} where S2<:AbstractPolyhedron{N} where S1<:LazySet{N} where N<:Real","page":"Intersection","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, cap::Intersection{N, S1, S2}; kwargs...)\n    where {N<:Real, S1<:LazySet{N}, S2<:AbstractPolyhedron{N}}\n\nReturn an upper bound on the support function of the intersection between a compact set and a polyhedron along a given direction.\n\nInput\n\nd      – direction\ncap    – intersection of a compact set and a polyhedron\nkwargs – additional arguments that are passed to the support-function             algorithm\n\nOutput\n\nAn upper bound of the support function of the given intersection.\n\nAlgorithm\n\nThe idea is to solve the univariate optimization problem ρ(di, X ∩ Hi) for each half-space in the set P and then take the minimum. This gives an overapproximation of the exact support function.\n\nThis algorithm is inspired from G. Frehse, R. Ray. Flowpipe-Guard Intersection for Reachability Computations with Support Functions.\n\nNotes\n\nThis method relies on the constraints_list of the polyhedron.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.ρ-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2}}} where S2<:AbstractPolyhedron{N} where S1<:AbstractPolyhedron{N} where N<:Real","page":"Intersection","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, cap::Intersection{N, S1, S2}; kwargs...\n ) where {N<:Real, S1<:AbstractPolyhedron{N}, S2<:AbstractPolyhedron{N}}\n\nReturn an upper bound on the support function of the intersection between two polyhedral sets.\n\nInput\n\nd      – direction\ncap    – intersection of two polyhedral sets\nkwargs – additional arguments that are passed to the support-function             algorithm\n\nOutput\n\nThe support function for the given direction.\n\nAlgorithm\n\nWe combine the constraints of the two polyhedra to a new HPolyhedron, for which we then evaluate the support function.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}} where N<:Real","page":"Intersection","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, cap::Intersection{N}) where {N<:Real}\n\nReturn the support vector of an intersection of two convex sets in a given direction.\n\nInput\n\nd   – direction\ncap – intersection of two convex sets\n\nOutput\n\nThe support vector in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.isbounded-Tuple{Intersection}","page":"Intersection","title":"LazySets.isbounded","text":"isbounded(cap::Intersection)\n\nDetermine whether an intersection of two convex sets is bounded.\n\nInput\n\ncap – intersection of two convex sets\n\nOutput\n\ntrue iff the intersection is bounded.\n\nAlgorithm\n\nWe first check if any of the wrapped sets is bounded. Otherwise, we check boundedness via isbounded_unit_dimensions.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#Base.isempty-Tuple{Intersection}","page":"Intersection","title":"Base.isempty","text":"isempty(cap::Intersection)\n\nReturn if the intersection is empty or not.\n\nInput\n\ncap – intersection of two convex sets\n\nOutput\n\ntrue iff the intersection is empty.\n\nNotes\n\nThe result will be cached, so a second query will be fast.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Intersection{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}} where N<:Real","page":"Intersection","title":"Base.:∈","text":"∈(x::AbstractVector{N}, cap::Intersection{N}) where {N<:Real}\n\nCheck whether a given point is contained in an intersection of two convex sets.\n\nInput\n\nx   – point/vector\ncap – intersection of two convex sets\n\nOutput\n\ntrue iff x  cap.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.constraints_list-Union{Tuple{Intersection{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}, Tuple{N}} where N<:Real","page":"Intersection","title":"LazySets.constraints_list","text":"constraints_list(cap::Intersection{N}) where {N<:Real}\n\nReturn the list of constraints of an intersection of two (polyhedral) sets.\n\nInput\n\ncap – intersection of two (polyhedral) sets\n\nOutput\n\nThe list of constraints of the intersection.\n\nNotes\n\nWe assume that the underlying sets are polyhedral, i.e., offer a method constraints_list.\n\nAlgorithm\n\nWe create the polyhedron by taking the intersection of the constraints_lists of the sets and remove redundant constraints.\n\nThis function ignores the boolean output from the in-place remove_redundant_constraints!, which may inform the user that the constraints are infeasible. In that case, the list of constraints at the moment when the infeasibility was detected is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.isempty_known-Tuple{Intersection}","page":"Intersection","title":"LazySets.isempty_known","text":"isempty_known(cap::Intersection)\n\nAsk whether the status of emptiness is known.\n\nInput\n\ncap – intersection of two convex sets\n\nOutput\n\ntrue iff the emptiness status is known. In this case, isempty(cap) can be used to obtain the status.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.set_isempty!-Tuple{Intersection,Bool}","page":"Intersection","title":"LazySets.set_isempty!","text":"set_isempty!(cap::Intersection, isempty::Bool)\n\nSet the status of emptiness in the cache.\n\nInput\n\ncap     – intersection of two convex sets\nisempty – new status of emptiness\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.swap-Union{Tuple{Intersection{N,S1,S2}}, Tuple{S2}, Tuple{S1}, Tuple{N}} where S2 where S1 where N<:Real","page":"Intersection","title":"LazySets.swap","text":"swap(cap::Intersection{N, S1, S2}) where {N<:Real, S1, S2}\n\nReturn a new Intersection object with the arguments swapped.\n\nInput\n\ncap – intersection of two convex sets\n\nOutput\n\nA new Intersection object with the arguments swapped. The old cache is shared between the old and new objects.\n\nNotes\n\nThe advantage of using this function instead of manually swapping the arguments is that the cache is shared.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.use_precise_ρ","page":"Intersection","title":"LazySets.use_precise_ρ","text":"use_precise_ρ(cap::Intersection{N}) where {N<:Real}\n\nDetermine whether a precise algorithm for computing ρ shall be applied.\n\nInput\n\ncap – intersection of two convex sets\n\nOutput\n\ntrue if a precise algorithm shall be applied.\n\nNotes\n\nThe default implementation always returns true.\n\nIf the result is false, a coarse approximation of the support function is returned.\n\nThis function can be overwritten by the user to control the policy.\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/Intersection/#LazySets._line_search","page":"Intersection","title":"LazySets._line_search","text":"_line_search(ℓ, X, H::Union{<:HalfSpace, <:Hyperplane, <:Line2D}; [kwargs...])\n\nGiven a compact and convex set X and a halfspace H = x a^T x  b  or a hyperplane H = x a^T x = b , calculate:\n\nmin_λ  D_h ρ(ℓ - λa X) + λb\n\nwhere D_h =  λ  λ  0  if H is a half-space or D_h =  λ  λ  mathbbR  if H is a hyperplane.\n\nInput\n\nℓ           – direction\nX           – set\nH           – halfspace or hyperplane\n\nOutput\n\nThe tuple (fmin, λmin), where fmin is the minimum value of the function f(λ) = ρ(ℓ - λa) + λb over the feasible set λ  0, and λmin is the minimizer.\n\nNotes\n\nThis function requires the Optim package, and relies on the univariate optimization interface Optim.optimize(...).\n\nAdditional arguments to the optimize backend can be passed as keyword arguments. The default method is Optim.Brent().\n\nExamples\n\njulia> X = Ball1(zeros(2), 1.0);\n\njulia> H = HalfSpace([-1.0, 0.0], -1.0);  # x >= 1\n\njulia> using Optim\n\njulia> using LazySets: _line_search\n\njulia> v = _line_search([1.0, 0.0], X, H);  # uses Brent's method by default\n\njulia> v[1]\n1.0\n\nWe can specify the upper bound in Brent's method:\n\njulia> v = _line_search([1.0, 0.0], X, H, upper=1e3);\n\njulia> v[1]\n1.0\n\nInstead of Brent's method we can use the Golden Section method:\n\njulia> v = _line_search([1.0, 0.0], X, H, upper=1e3, method=GoldenSection());\n\njulia> v[1]\n1.0\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/Intersection/#LazySets._projection","page":"Intersection","title":"LazySets._projection","text":"_projection(ℓ, X, H::Union{Hyperplane{N}, Line2D{N}};\n            [lazy_linear_map]=false,\n            [lazy_2d_intersection]=true,\n            [algorithm_2d_intersection]=nothing,\n            [kwargs...]) where {N}\n\nGiven a compact and convex set X and a hyperplane H = x n  x = γ , calculate the support function of the intersection between the rank-2 projection Π_nℓ X and the line Lγ = (x y) x = γ .\n\nInput\n\nℓ                    – direction\nX                    – set\nH                    – hyperplane\nlazy_linear_map      – (optional, default: false) to perform the projection                           lazily or concretely\nlazy_2d_intersection – (optional, default: true) to perform the 2D                           intersection between the projected set and the line                           lazily or concretely\nalgorithm_2d_intersection – (optional, default: nothing) if given, fixes the                                support function algorithm used for the intersection                                in 2D; otherwise the default is implied\n\nOutput\n\nThe support function of X  H along direction ℓ.\n\nAlgorithm\n\nThis projection method is based on Prop. 8.2, page 103, C. Le Guernic. Reachability Analysis of Hybrid Systems with Linear Continuous Dynamics, PhD thesis.\n\nIn the original algorithm, Section 8.2 of Le Guernic's thesis, the linear map is performed concretely and the intersection is performed lazily (these are the default options in this algorithm, but here the four combinations are available). If the set X is a zonotope, its concrete projection is again a zonotope (sometimes called \"zonogon\"). The intersection between this zonogon and the line can be taken efficiently in a lazy way (see Section 8.2.2 of Le Guernic's thesis), if one uses dispatch on ρ(y_dir, Sℓ⋂Lγ; kwargs...) given that Sℓ is itself a zonotope.\n\nNotes\n\nThis function depends itself on the calculation of the support function of another set in two dimensions. Obviously one doesn't want to use again algorithm=\"projection\" for this second calculation. The option algorithm_2d_intersection is such that, if it is not given, the default support function algorithm is used (e.g. \"line_search\"). You can still pass additional arguments to the \"line_search\" backend through the kwargs.\n\n\n\n\n\n","category":"function"},{"location":"lib/lazy_operations/Intersection/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},Intersection{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}} where N","page":"Intersection","title":"LazySets.linear_map","text":"linear_map(M::AbstractMatrix{N}, cap::Intersection{N}) where {N}\n\nReturn the concrete linear map of a lazy intersection.\n\nInput\n\nM   – matrix\ncap – lazy intersection\n\nOutput\n\nThe set obtained by applying the given linear map to the lazy intersection.\n\nNotes\n\nThis function relies on computing cap concretely (i.e. as a set representation), and then applying the linear map.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.plot_recipe-Union{Tuple{Intersection{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}, Tuple{N}, Tuple{Intersection{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N},N}, Tuple{Intersection{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N},N,Int64}} where N<:Real","page":"Intersection","title":"LazySets.plot_recipe","text":"plot_recipe(cap::Intersection{N}, [ε]::N=-one(N),\n            [Nφ]::Int=PLOT_POLAR_DIRECTIONS) where {N<:Real}\n\nConvert a lazy intersection to a pair (x, y) of points for plotting.\n\nInput\n\ncap  – lazy intersection\nε    – (optional, default 0) ignored, used for dispatch\nNφ   – (optional, default: PLOT_POLAR_DIRECTIONS) number of polar           directions used in the template overapproximation\n\nOutput\n\nA pair (x, y) of points that can be plotted.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{AbstractDict{Symbol,Any},Intersection{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}, Tuple{AbstractDict{Symbol,Any},Intersection{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N},N}, Tuple{AbstractDict{Symbol,Any},Intersection{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N},N,Int64}} where N<:Real","page":"Intersection","title":"RecipesBase.apply_recipe","text":"plot_intersection(cap::Intersection{N}, [ε]::N=zero(N),\n                  [Nφ]::Int=PLOT_POLAR_DIRECTIONS) where {N<:Real}\n\nPlot a lazy intersection.\n\nInput\n\ncap  – lazy intersection\nε    – (optional, default 0) ignored, used for dispatch\nNφ   – (optional, default: PLOT_POLAR_DIRECTIONS) number of polar           directions used in the template overapproximation\n\nNotes\n\nThis function is separated from the main LazySet plot recipe because iterative refinement is not available for lazy intersections (since it uses the support vector (but see #1187)).\n\nAlso note that if the set is a nested intersection, you may have to manually overapproximate this set before plotting (see LazySets.Approximations.overapproximate for details).\n\nExamples\n\njulia> using LazySets.Approximations\n\njulia> X = Ball2(zeros(2), 1.) ∩ Ball2(ones(2), 1.5);  # lazy intersection\n\njulia> plot(X)\n\nYou can specify the accuracy of the overapproximation of the lazy intersection by passing a higher value for Nφ, which stands for the number of polar directions used in the overapproximation. This number can also be passed to the plot function directly.\n\njulia> plot(overapproximate(X, PolarDirections(100)))\n\njulia> plot(X, -1., 100)  # equivalent to the above line\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/","page":"Intersection","title":"Intersection","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/Intersection/","page":"Intersection","title":"Intersection","text":"norm\nradius\ndiameter\nan_element","category":"page"},{"location":"lib/lazy_operations/Intersection/#Intersection-cache","page":"Intersection","title":"Intersection cache","text":"","category":"section"},{"location":"lib/lazy_operations/Intersection/","page":"Intersection","title":"Intersection","text":"IntersectionCache","category":"page"},{"location":"lib/lazy_operations/Intersection/#LazySets.IntersectionCache","page":"Intersection","title":"LazySets.IntersectionCache","text":"IntersectionCache\n\nContainer for information cached by a lazy Intersection object.\n\nFields\n\nisempty – is the intersection empty? There are three possible states,              encoded as Int8 values -1, 0, 1:\n-1 - it is currently unknown whether the intersection is empty or not\n0 - intersection is not empty\n1 - intersection is empty\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/Intersection/#def_IntersectionArray","page":"Intersection","title":"n-ary intersection (IntersectionArray)","text":"","category":"section"},{"location":"lib/lazy_operations/Intersection/","page":"Intersection","title":"Intersection","text":"IntersectionArray\ndim(::IntersectionArray)\nσ(::AbstractVector{N}, ::IntersectionArray{N}) where {N<:Real}\nisbounded(::IntersectionArray)\n∈(::AbstractVector{N}, ::IntersectionArray{N}) where {N<:Real}\narray(::IntersectionArray{N, S}) where {N<:Real, S<:LazySet{N}}\nconstraints_list(::IntersectionArray{N}) where {N<:Real}","category":"page"},{"location":"lib/lazy_operations/Intersection/#LazySets.IntersectionArray","page":"Intersection","title":"LazySets.IntersectionArray","text":"IntersectionArray{N<:Real, S<:LazySet{N}} <: LazySet{N}\n\nType that represents the intersection of a finite number of convex sets.\n\nFields\n\narray – array of convex sets\n\nNotes\n\nThis type assumes that the dimensions of all elements match.\n\nThe EmptySet is the absorbing element for IntersectionArray.\n\nConstructors:\n\nIntersectionArray(array::Vector{<:LazySet}) – default constructor\nIntersectionArray([n]::Int=0, [N]::Type=Float64)\n\n– constructor for an empty sum with optional size hint and numeric type\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/Intersection/#LazySets.dim-Tuple{IntersectionArray}","page":"Intersection","title":"LazySets.dim","text":"dim(ia::IntersectionArray)\n\nReturn the dimension of an intersection of a finite number of sets.\n\nInput\n\nia – intersection of a finite number of convex sets\n\nOutput\n\nThe ambient dimension of the intersection of a finite number of sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},IntersectionArray{N,S} where S<:LazySet{N}}} where N<:Real","page":"Intersection","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, ia::IntersectionArray{N}) where {N<:Real}\n\nReturn the support vector of an intersection of a finite number of sets in a given direction.\n\nInput\n\nd  – direction\nia – intersection of a finite number of convex sets\n\nOutput\n\nThe support vector in the given direction. If the direction has norm zero, the result depends on the individual sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.isbounded-Tuple{IntersectionArray}","page":"Intersection","title":"LazySets.isbounded","text":"isbounded(ia::IntersectionArray)\n\nDetermine whether an intersection of a finite number of convex sets is bounded.\n\nInput\n\nia – intersection of a finite number of convex sets\n\nOutput\n\ntrue iff the intersection is bounded.\n\nAlgorithm\n\nWe first check if any of the wrapped sets is bounded. Otherwise, we check boundedness via isbounded_unit_dimensions.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},IntersectionArray{N,S} where S<:LazySet{N}}} where N<:Real","page":"Intersection","title":"Base.:∈","text":"∈(x::AbstractVector{N}, ia::IntersectionArray{N}) where {N<:Real}\n\nCheck whether a given point is contained in an intersection of a finite number of convex sets.\n\nInput\n\nx  – point/vector\nia – intersection of a finite number of convex sets\n\nOutput\n\ntrue iff x  ia.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.array-Union{Tuple{IntersectionArray{N,S}}, Tuple{S}, Tuple{N}} where S<:LazySet{N} where N<:Real","page":"Intersection","title":"LazySets.array","text":"array(cpa::CartesianProductArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a Cartesian product of a finite number of convex sets.\n\nInput\n\ncpa – Cartesian product array\n\nOutput\n\nThe array of a Cartesian product of a finite number of convex sets.\n\n\n\n\n\narray(cha::ConvexHullArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a convex hull of a finite number of convex sets.\n\nInput\n\ncha – convex hull array\n\nOutput\n\nThe array of a convex hull of a finite number of convex sets.\n\n\n\n\n\narray(ia::IntersectionArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of an intersection of a finite number of convex sets.\n\nInput\n\nia – intersection of a finite number of convex sets\n\nOutput\n\nThe array of an intersection of a finite number of convex sets.\n\n\n\n\n\narray(msa::MinkowskiSumArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a Minkowski sum of a finite number of convex sets.\n\nInput\n\nmsa – Minkowski sum array\n\nOutput\n\nThe array of a Minkowski sum of a finite number of convex sets.\n\n\n\n\n\narray(cms::CachedMinkowskiSumArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a caching Minkowski sum.\n\nInput\n\ncms – caching Minkowski sum\n\nOutput\n\nThe array of a caching Minkowski sum.\n\n\n\n\n\narray(cup::UnionSetArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a union of a finite number of convex sets.\n\nInput\n\ncup – union of a finite number of convex sets\n\nOutput\n\nThe array that holds the union of a finite number of convex sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/#LazySets.constraints_list-Union{Tuple{IntersectionArray{N,S} where S<:LazySet{N}}, Tuple{N}} where N<:Real","page":"Intersection","title":"LazySets.constraints_list","text":"constraints_list(ia::IntersectionArray{N}) where {N<:Real}\n\nReturn the list of constraints of an intersection of a finite number of (polyhedral) sets.\n\nInput\n\nia – intersection of a finite number of (polyhedral) sets\n\nOutput\n\nThe list of constraints of the intersection.\n\nNotes\n\nWe assume that the underlying sets are polyhedral, i.e., offer a method constraints_list.\n\nAlgorithm\n\nWe create the polyhedron from the constraints_lists of the sets and remove redundant constraints.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Intersection/","page":"Intersection","title":"Intersection","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/Intersection/","page":"Intersection","title":"Intersection","text":"norm\nradius\ndiameter\nan_element","category":"page"},{"location":"lib/lazy_operations/MinkowskiSum/","page":"MinkowskiSum","title":"MinkowskiSum","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/lazy_operations/MinkowskiSum/#Minkowski-sum","page":"MinkowskiSum","title":"Minkowski sum","text":"","category":"section"},{"location":"lib/lazy_operations/MinkowskiSum/#def_MinkowskiSum","page":"MinkowskiSum","title":"Binary Minkowski sum (MinkowskiSum)","text":"","category":"section"},{"location":"lib/lazy_operations/MinkowskiSum/","page":"MinkowskiSum","title":"MinkowskiSum","text":"MinkowskiSum\n⊕(::LazySet, ::LazySet)\n+(::LazySet, ::LazySet)\nswap(::MinkowskiSum)\ndim(::MinkowskiSum)\nρ(::AbstractVector{N}, ::MinkowskiSum{N}) where {N<:Real}\nσ(::AbstractVector{N}, ::MinkowskiSum{N}) where {N<:Real}\nisbounded(::MinkowskiSum)\nisempty(::MinkowskiSum)\nconstraints_list(::MinkowskiSum)\n∈(::AbstractVector{N}, ::MinkowskiSum{N, S1, S2}) where {N, S1<:AbstractSingleton, S2<:LazySet}\nvertices_list(MS::MinkowskiSum{N, Z1, Z2}) where{N<:Real, Z1<:AbstractZonotope{N}, Z2<:AbstractZonotope{N}}","category":"page"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.MinkowskiSum","page":"MinkowskiSum","title":"LazySets.MinkowskiSum","text":"MinkowskiSum{N<:Real, S1<:LazySet{N}, S2<:LazySet{N}} <: LazySet{N}\n\nType that represents the Minkowski sum of two convex sets.\n\nFields\n\nX – first convex set\nY – second convex set\n\nNotes\n\nThe ZeroSet is the neutral element and the EmptySet is the absorbing element for MinkowskiSum.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.:⊕-Tuple{LazySet,LazySet}","page":"MinkowskiSum","title":"LazySets.:⊕","text":"⊕(X::LazySet, Y::LazySet)\n\nUnicode alias constructor ⊕ (oplus) for the lazy Minkowski sum operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#Base.:+-Tuple{LazySet,LazySet}","page":"MinkowskiSum","title":"Base.:+","text":"X + Y\n\nConvenience constructor for Minkowski sum.\n\nInput\n\nX – a convex set\nY – another convex set\n\nOutput\n\nThe symbolic Minkowski sum of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.swap-Tuple{MinkowskiSum}","page":"MinkowskiSum","title":"LazySets.swap","text":"swap(ms::MinkowskiSum)\n\nReturn a new MinkowskiSum object with the arguments swapped.\n\nInput\n\nms – Minkowski sum of two convex sets\n\nOutput\n\nA new MinkowskiSum object with the arguments swapped.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.dim-Tuple{MinkowskiSum}","page":"MinkowskiSum","title":"LazySets.dim","text":"dim(ms::MinkowskiSum)\n\nReturn the dimension of a Minkowski sum.\n\nInput\n\nms – Minkowski sum\n\nOutput\n\nThe ambient dimension of the Minkowski sum.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSum{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}} where N<:Real","page":"MinkowskiSum","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, ms::MinkowskiSum{N}) where {N<:Real}\n\nReturn the support function of a Minkowski sum.\n\nInput\n\nd  – direction\nms – Minkowski sum\n\nOutput\n\nThe support function in the given direction.\n\nAlgorithm\n\nThe support function in direction d of the Minkowski sum of two sets X and Y is the sum of the support functions of X and Y in direction d.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSum{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N}}} where N<:Real","page":"MinkowskiSum","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, ms::MinkowskiSum{N}) where {N<:Real}\n\nReturn the support vector of a Minkowski sum.\n\nInput\n\nd  – direction\nms – Minkowski sum\n\nOutput\n\nThe support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.\n\nAlgorithm\n\nThe support vector in direction d of the Minkowski sum of two sets X and Y is the sum of the support vectors of X and Y in direction d.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.isbounded-Tuple{MinkowskiSum}","page":"MinkowskiSum","title":"LazySets.isbounded","text":"isbounded(ms::MinkowskiSum)\n\nDetermine whether a Minkowski sum is bounded.\n\nInput\n\nms – Minkowski sum\n\nOutput\n\ntrue iff both wrapped sets are bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#Base.isempty-Tuple{MinkowskiSum}","page":"MinkowskiSum","title":"Base.isempty","text":"isempty(ms::MinkowskiSum)\n\nReturn if a Minkowski sum is empty or not.\n\nInput\n\nms – Minkowski sum\n\nOutput\n\ntrue iff any of the wrapped sets are empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.constraints_list-Tuple{MinkowskiSum}","page":"MinkowskiSum","title":"LazySets.constraints_list","text":"constraints_list(ms::MinkowskiSum)\n\nReturn the list of constraints of a lazy Minkowski sum of two polyhedral sets.\n\nInput\n\nms – Minkowski sum of two polyhedral sets\n\nOutput\n\nThe list of constraints of the Minkowski sum.\n\nAlgorithm\n\nWe compute a concrete set representation via minkowski_sum and call constraints_list on the result.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#Base.:∈-Union{Tuple{S2}, Tuple{S1}, Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSum{N,S1,S2}}} where S2<:LazySet where S1<:AbstractSingleton where N","page":"MinkowskiSum","title":"Base.:∈","text":"∈(x::AbstractVector{N}, ms::MinkowskiSum{N, <:AbstractSingleton, <:LazySet}) where {N}\n\nCheck whether a given point is contained in the Minkowski sum of a singleton and a set.\n\nInput\n\nx  – point\nms – lazy Minkowski sum of a singleton and a set\n\nOutput\n\ntrue iff x  ms.\n\nAlgorithm\n\nNote that x  (S  P), where S is a singleton set, S = s and P is a set, if and only if (x-s)  P.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.vertices_list-Union{Tuple{MinkowskiSum{N,Z1,Z2}}, Tuple{Z2}, Tuple{Z1}, Tuple{N}} where Z2<:AbstractZonotope{N} where Z1<:AbstractZonotope{N} where N<:Real","page":"MinkowskiSum","title":"LazySets.vertices_list","text":"vertices_list(ms::MinkowskiSum{N, Z1, Z2}) where {N<:Real, Z1<:AbstractZonotope{N}, Z2<:AbstractZonotope{N}}\n\nReturn the list of vertices for the Minkowski sum of two zonotopic sets.\n\nInput\n\nms – Minkowski sum of two zonotopic sets\n\nOutput\n\nThe list of vertices of the Minkowski sum of two zonotopic sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/","page":"MinkowskiSum","title":"MinkowskiSum","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/MinkowskiSum/","page":"MinkowskiSum","title":"MinkowskiSum","text":"norm\nradius\ndiameter\nan_element","category":"page"},{"location":"lib/lazy_operations/MinkowskiSum/#def_MinkowskiSumArray","page":"MinkowskiSum","title":"n-ary Minkowski sum (MinkowskiSumArray)","text":"","category":"section"},{"location":"lib/lazy_operations/MinkowskiSum/","page":"MinkowskiSum","title":"MinkowskiSum","text":"MinkowskiSumArray\ndim(::MinkowskiSumArray)\nρ(::AbstractVector{N}, ::MinkowskiSumArray{N}) where {N<:Real}\nσ(::AbstractVector{N}, ::MinkowskiSumArray{N}) where {N<:Real}\nisbounded(::MinkowskiSumArray)\nisempty(::MinkowskiSumArray)\narray(::MinkowskiSumArray{N, S}) where {N<:Real, S<:LazySet{N}}","category":"page"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.MinkowskiSumArray","page":"MinkowskiSum","title":"LazySets.MinkowskiSumArray","text":"MinkowskiSumArray{N<:Real, S<:LazySet{N}} <: LazySet{N}\n\nType that represents the Minkowski sum of a finite number of convex sets.\n\nFields\n\narray – array of convex sets\n\nNotes\n\nThis type assumes that the dimensions of all elements match.\n\nThe ZeroSet is the neutral element and the EmptySet is the absorbing element for MinkowskiSumArray.\n\nConstructors:\n\nMinkowskiSumArray(array::Vector{<:LazySet}) – default constructor\nMinkowskiSumArray([n]::Int=0, [N]::Type=Float64)\n\n– constructor for an empty sum with optional size hint and numeric type\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.dim-Tuple{MinkowskiSumArray}","page":"MinkowskiSum","title":"LazySets.dim","text":"dim(msa::MinkowskiSumArray)\n\nReturn the dimension of a Minkowski sum of a finite number of sets.\n\nInput\n\nmsa – Minkowski sum array\n\nOutput\n\nThe ambient dimension of the Minkowski sum of a finite number of sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSumArray{N,S} where S<:LazySet{N}}} where N<:Real","page":"MinkowskiSum","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, msa::MinkowskiSumArray{N}) where {N<:Real}\n\nReturn the support function of a Minkowski sum array of a finite number of sets in a given direction.\n\nInput\n\nd   – direction\nmsa – Minkowski sum array\n\nOutput\n\nThe support function in the given direction.\n\nAlgorithm\n\nThe support function of the Minkowski sum of sets is the sum of the support functions of each set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},MinkowskiSumArray{N,S} where S<:LazySet{N}}} where N<:Real","page":"MinkowskiSum","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, msa::MinkowskiSumArray{N}) where {N<:Real}\n\nReturn the support vector of a Minkowski sum of a finite number of sets in a given direction.\n\nInput\n\nd   – direction\nmsa – Minkowski sum array\n\nOutput\n\nThe support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.isbounded-Tuple{MinkowskiSumArray}","page":"MinkowskiSum","title":"LazySets.isbounded","text":"isbounded(msa::MinkowskiSumArray)\n\nDetermine whether a Minkowski sum of a finite number of convex sets is bounded.\n\nInput\n\nmsa – Minkowski sum of a finite number of convex sets\n\nOutput\n\ntrue iff all wrapped sets are bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#Base.isempty-Tuple{MinkowskiSumArray}","page":"MinkowskiSum","title":"Base.isempty","text":"isempty(msa::MinkowskiSumArray)\n\nReturn if a Minkowski sum array is empty or not.\n\nInput\n\nmsa – Minkowski sum array\n\nOutput\n\ntrue iff any of the wrapped sets are empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.array-Union{Tuple{MinkowskiSumArray{N,S}}, Tuple{S}, Tuple{N}} where S<:LazySet{N} where N<:Real","page":"MinkowskiSum","title":"LazySets.array","text":"array(cpa::CartesianProductArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a Cartesian product of a finite number of convex sets.\n\nInput\n\ncpa – Cartesian product array\n\nOutput\n\nThe array of a Cartesian product of a finite number of convex sets.\n\n\n\n\n\narray(cha::ConvexHullArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a convex hull of a finite number of convex sets.\n\nInput\n\ncha – convex hull array\n\nOutput\n\nThe array of a convex hull of a finite number of convex sets.\n\n\n\n\n\narray(ia::IntersectionArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of an intersection of a finite number of convex sets.\n\nInput\n\nia – intersection of a finite number of convex sets\n\nOutput\n\nThe array of an intersection of a finite number of convex sets.\n\n\n\n\n\narray(msa::MinkowskiSumArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a Minkowski sum of a finite number of convex sets.\n\nInput\n\nmsa – Minkowski sum array\n\nOutput\n\nThe array of a Minkowski sum of a finite number of convex sets.\n\n\n\n\n\narray(cms::CachedMinkowskiSumArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a caching Minkowski sum.\n\nInput\n\ncms – caching Minkowski sum\n\nOutput\n\nThe array of a caching Minkowski sum.\n\n\n\n\n\narray(cup::UnionSetArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a union of a finite number of convex sets.\n\nInput\n\ncup – union of a finite number of convex sets\n\nOutput\n\nThe array that holds the union of a finite number of convex sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/","page":"MinkowskiSum","title":"MinkowskiSum","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/MinkowskiSum/","page":"MinkowskiSum","title":"MinkowskiSum","text":"norm\nradius\ndiameter\nan_element","category":"page"},{"location":"lib/lazy_operations/MinkowskiSum/#def_CachedMinkowskiSumArray","page":"MinkowskiSum","title":"n-ary Minkowski sum with cache (CachedMinkowskiSumArray)","text":"","category":"section"},{"location":"lib/lazy_operations/MinkowskiSum/","page":"MinkowskiSum","title":"MinkowskiSum","text":"CachedMinkowskiSumArray\ndim(::CachedMinkowskiSumArray)\nσ(::AbstractVector{N}, ::CachedMinkowskiSumArray{N}) where {N<:Real}\nisbounded(::CachedMinkowskiSumArray)\nisempty(::CachedMinkowskiSumArray)\narray(::CachedMinkowskiSumArray{N, S}) where {N<:Real, S<:LazySet{N}}\nforget_sets!(::CachedMinkowskiSumArray)","category":"page"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.CachedMinkowskiSumArray","page":"MinkowskiSum","title":"LazySets.CachedMinkowskiSumArray","text":"CachedMinkowskiSumArray{N<:Real, S<:LazySet{N}} <: LazySet{N}\n\nType that represents the Minkowski sum of a finite number of convex sets. Support vector queries are cached.\n\nFields\n\narray – array of convex sets\ncache – cache of support vector query results\n\nNotes\n\nThis type assumes that the dimensions of all elements match.\n\nThe ZeroSet is the neutral element and the EmptySet is the absorbing element for CachedMinkowskiSumArray.\n\nThe cache (field cache) is implemented as dictionary whose keys are directions and whose values are pairs (k, s) where k is the number of elements in the array array when the support vector was evaluated last time, and s is the support vector that was obtained. Thus this type assumes that array is not modified except by adding new sets at the end.\n\nConstructors:\n\nCachedMinkowskiSumArray(array::Vector{<:LazySet}) – default constructor\nCachedMinkowskiSumArray([n]::Int=0, [N]::Type=Float64) – constructor for an empty sum with optional size hint and numeric type\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.dim-Tuple{CachedMinkowskiSumArray}","page":"MinkowskiSum","title":"LazySets.dim","text":"dim(cms::CachedMinkowskiSumArray)\n\nReturn the dimension of a caching Minkowski sum.\n\nInput\n\ncms – caching Minkowski sum\n\nOutput\n\nThe ambient dimension of the caching Minkowski sum.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CachedMinkowskiSumArray{N,S} where S<:LazySet{N}}} where N<:Real","page":"MinkowskiSum","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, cms::CachedMinkowskiSumArray{N}) where {N<:Real}\n\nReturn the support vector of a caching Minkowski sum in a given direction.\n\nInput\n\nd   – direction\ncms – caching Minkowski sum\n\nOutput\n\nThe support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.\n\nNotes\n\nThe result is cached, i.e., any further query with the same direction runs in constant time. When sets are added to the caching Minkowski sum, the query is only performed for the new sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.isbounded-Tuple{CachedMinkowskiSumArray}","page":"MinkowskiSum","title":"LazySets.isbounded","text":"isbounded(cms::CachedMinkowskiSumArray)\n\nDetermine whether a caching Minkowski sum is bounded.\n\nInput\n\ncms – caching Minkowski sum\n\nOutput\n\ntrue iff all wrapped sets are bounded.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#Base.isempty-Tuple{CachedMinkowskiSumArray}","page":"MinkowskiSum","title":"Base.isempty","text":"isempty(cms::CachedMinkowskiSumArray)\n\nReturn if a caching Minkowski sum array is empty or not.\n\nInput\n\ncms – caching Minkowski sum\n\nOutput\n\ntrue iff any of the wrapped sets are empty.\n\nNotes\n\nForgotten sets cannot be checked anymore. Usually they have been empty because otherwise the support vector query should have crashed before. In that case, the caching Minkowski sum should not be used further.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.array-Union{Tuple{CachedMinkowskiSumArray{N,S}}, Tuple{S}, Tuple{N}} where S<:LazySet{N} where N<:Real","page":"MinkowskiSum","title":"LazySets.array","text":"array(cpa::CartesianProductArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a Cartesian product of a finite number of convex sets.\n\nInput\n\ncpa – Cartesian product array\n\nOutput\n\nThe array of a Cartesian product of a finite number of convex sets.\n\n\n\n\n\narray(cha::ConvexHullArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a convex hull of a finite number of convex sets.\n\nInput\n\ncha – convex hull array\n\nOutput\n\nThe array of a convex hull of a finite number of convex sets.\n\n\n\n\n\narray(ia::IntersectionArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of an intersection of a finite number of convex sets.\n\nInput\n\nia – intersection of a finite number of convex sets\n\nOutput\n\nThe array of an intersection of a finite number of convex sets.\n\n\n\n\n\narray(msa::MinkowskiSumArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a Minkowski sum of a finite number of convex sets.\n\nInput\n\nmsa – Minkowski sum array\n\nOutput\n\nThe array of a Minkowski sum of a finite number of convex sets.\n\n\n\n\n\narray(cms::CachedMinkowskiSumArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a caching Minkowski sum.\n\nInput\n\ncms – caching Minkowski sum\n\nOutput\n\nThe array of a caching Minkowski sum.\n\n\n\n\n\narray(cup::UnionSetArray{N, S}) where {N<:Real, S<:LazySet{N}}\n\nReturn the array of a union of a finite number of convex sets.\n\nInput\n\ncup – union of a finite number of convex sets\n\nOutput\n\nThe array that holds the union of a finite number of convex sets.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/#LazySets.forget_sets!-Tuple{CachedMinkowskiSumArray}","page":"MinkowskiSum","title":"LazySets.forget_sets!","text":"forget_sets!(cms::CachedMinkowskiSumArray)\n\nTell a caching Minkowski sum to forget the stored sets (but not the support vectors). Only those sets are forgotten such that for each cached direction the support vector has been computed before.\n\nInput\n\ncms – caching Minkowski sum\n\nOutput\n\nThe number of sets that have been forgotten.\n\nNotes\n\nThis function should only be used under the assertion that no new directions are queried in the future; otherwise such support vector results will be incorrect.\n\nThis implementation is optimistic and first tries to remove all sets. However, it also checks that for all cached directions the support vector has been computed before. If it finds that this is not the case, the implementation identifies the biggest index k such that the above holds for the k oldest sets, and then it only removes these. See the example below.\n\nExamples\n\njulia> x1 = BallInf(ones(3), 3.); x2 = Ball1(ones(3), 5.);\n\njulia> cms1 = CachedMinkowskiSumArray(2); cms2 = CachedMinkowskiSumArray(2);\n\njulia> d = ones(3);\n\njulia> a1 = array(cms1); a2 = array(cms2);\n\njulia> push!(a1, x1); push!(a2, x1);\n\njulia> σ(d, cms1); σ(d, cms2);\n\njulia> push!(a1, x2); push!(a2, x2);\n\njulia> σ(d, cms1);\n\njulia> idx1 = forget_sets!(cms1) # support vector was computed for both sets\n2\n\njulia> idx1 = forget_sets!(cms2) # support vector was only computed for first set\n1\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/MinkowskiSum/","page":"MinkowskiSum","title":"MinkowskiSum","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/MinkowskiSum/","page":"MinkowskiSum","title":"MinkowskiSum","text":"norm\nradius\ndiameter\nan_element","category":"page"},{"location":"lib/lazy_operations/Complement/","page":"Complement","title":"Complement","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/lazy_operations/Complement/#def_Complement","page":"Complement","title":"Complement","text":"","category":"section"},{"location":"lib/lazy_operations/Complement/","page":"Complement","title":"Complement","text":"Note that the complement of a convex set is generally not convex. Hence this set type is not part of the convex-set family LazySet.","category":"page"},{"location":"lib/lazy_operations/Complement/","page":"Complement","title":"Complement","text":"Complement\ndim(::Complement)\n∈(::AbstractVector{N}, ::Complement{N}) where {N<:Real}\nisempty(::Complement)","category":"page"},{"location":"lib/lazy_operations/Complement/#LazySets.Complement","page":"Complement","title":"LazySets.Complement","text":"Complement{N<:Real, S<:LazySet{N}}\n\nType that represents the complement of a convex set.\n\nFields\n\nX – convex set\n\nNotes\n\nSince X is assumed to be closed, unless X is empty or the universe, its complement is open (i.e., not closed). Since X is assumed to be closed, unless X is empty, the universe, or a half-space, its complement is not convex.\n\nThe complement of the complement is the original set again.\n\nExamples\n\njulia> B = BallInf(zeros(2), 1.);\n\njulia> C = Complement(B)\nComplement{Float64,BallInf{Float64,Array{Float64,1}}}(BallInf{Float64,Array{Float64,1}}([0.0, 0.0], 1.0))\n\njulia> Complement(C)\nBallInf{Float64,Array{Float64,1}}([0.0, 0.0], 1.0)\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/Complement/#LazySets.dim-Tuple{Complement}","page":"Complement","title":"LazySets.dim","text":"dim(C::Complement)\n\nReturn the dimension of the complement of a convex set.\n\nInput\n\nC – complement of a convex set\n\nOutput\n\nThe dimension of the complement of a convex set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Complement/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Complement{N,S} where S<:LazySet{N}}} where N<:Real","page":"Complement","title":"Base.:∈","text":"∈(x::AbstractVector{N}, C::Complement{N}) where {N<:Real}\n\nCheck whether a given point is contained in the complement of a convex set.\n\nInput\n\nx – point/vector\nC – complement of a convex set\n\nOutput\n\ntrue iff the vector is contained in the complement.\n\nAlgorithm\n\n    x  X^C  x  X\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Complement/#Base.isempty-Tuple{Complement}","page":"Complement","title":"Base.isempty","text":"isempty(C::Complement)\n\nReturn if the complement of a convex set is empty or not.\n\nInput\n\nC – complement of a convex set\n\nOutput\n\nfalse unless the original set is universal.\n\nAlgorithm\n\nWe use the isuniversal method.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ballp/","page":"Ballp","title":"Ballp","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/Ballp/#def_Ballp","page":"Ballp","title":"p-norm ball (Ballp)","text":"","category":"section"},{"location":"lib/sets/Ballp/","page":"Ballp","title":"Ballp","text":"Ballp\nσ(::AbstractVector{N}, ::Ballp{N}) where {N<:AbstractFloat}\n∈(::AbstractVector{N}, ::Ballp{N}) where {N<:AbstractFloat}\ncenter(::Ballp{N}) where {N<:AbstractFloat}\nrand(::Type{Ballp})\ntranslate(::Ballp{N}, ::AbstractVector{N}) where {N<:AbstractFloat}","category":"page"},{"location":"lib/sets/Ballp/#LazySets.Ballp","page":"Ballp","title":"LazySets.Ballp","text":"Ballp{N<:AbstractFloat, VN<:AbstractVector{N}} <: AbstractCentrallySymmetric{N}\n\nType that represents a ball in the p-norm, for 1  p  .\n\nIt is defined as the set\n\nmathcalB_p^n(c r) =  x  mathbbR^n   x - c _p  r \n\nwhere c  mathbbR^n is its center and r  mathbbR_+ its radius. Here   _p for 1  p   denotes the vector p-norm, defined as  x _p = left( sumlimits_i=1^n x_i^p right)^1p for any x  mathbbR^n.\n\nFields\n\np      – norm as a real scalar\ncenter – center of the ball as a real vector\nradius – radius of the ball as a scalar ( 0)\n\nNotes\n\nThe special cases p=1, p=2 and p= fall back to the specialized types Ball1, Ball2 and BallInf, respectively.\n\nExamples\n\nA five-dimensional ball in the p=32 norm centered at the origin of radius 0.5:\n\njulia> B = Ballp(3/2, zeros(5), 0.5)\nBallp{Float64,Array{Float64,1}}(1.5, [0.0, 0.0, 0.0, 0.0, 0.0], 0.5)\n\njulia> dim(B)\n5\n\nWe evaluate the support vector in direction 125:\n\njulia> σ([1., 2, 3, 4, 5], B)\n5-element Array{Float64,1}:\n 0.013516004434607558\n 0.05406401773843023\n 0.12164403991146802\n 0.21625607095372093\n 0.33790011086518895\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Ballp/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ballp{N,VN} where VN<:AbstractArray{N,1}}} where N<:AbstractFloat","page":"Ballp","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, B::Ballp{N}) where {N<:AbstractFloat}\n\nReturn the support vector of a Ballp in a given direction.\n\nInput\n\nd – direction\nB – ball in the p-norm\n\nOutput\n\nThe support vector in the given direction. If the direction has norm zero, the center of the ball is returned.\n\nAlgorithm\n\nThe support vector of the unit ball in the p-norm along direction d is:\n\nσ_mathcalB_p^n(0 1)(d) = dfractildevtildev_q\n\nwhere tildev_i = fracd_i^qd_i if d_i  0 and tildev_i = 0 otherwise, for all i=1n, and q is the conjugate number of p. By the affine transformation x = rtildex + c, one obtains that the support vector of mathcalB_p^n(c r) is\n\nσ_mathcalB_p^n(c r)(d) = dfracvv_q\n\nwhere v_i = c_i + rfracd_i^qd_i if d_i  0 and v_i = 0 otherwise, for all i = 1  n.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ballp/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ballp{N,VN} where VN<:AbstractArray{N,1}}} where N<:AbstractFloat","page":"Ballp","title":"Base.:∈","text":"∈(x::AbstractVector{N}, B::Ballp{N}) where {N<:AbstractFloat}\n\nCheck whether a given point is contained in a ball in the p-norm.\n\nInput\n\nx – point/vector\nB – ball in the p-norm\n\nOutput\n\ntrue iff x  B.\n\nNotes\n\nThis implementation is worst-case optimized, i.e., it is optimistic and first computes (see below) the whole sum before comparing to the radius. In applications where the point is typically far away from the ball, a fail-fast implementation with interleaved comparisons could be more efficient.\n\nAlgorithm\n\nLet B be an n-dimensional ball in the p-norm with radius r and let c_i and x_i be the ball's center and the vector x in dimension i, respectively. Then x  B iff left( _i=1^n c_i - x_i^p right)^1p  r.\n\nExamples\n\njulia> B = Ballp(1.5, [1., 1.], 1.)\nBallp{Float64,Array{Float64,1}}(1.5, [1.0, 1.0], 1.0)\n\njulia> [.5, -.5] ∈ B\nfalse\n\njulia> [.5, 1.5] ∈ B\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ballp/#LazySets.center-Union{Tuple{Ballp{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:AbstractFloat","page":"Ballp","title":"LazySets.center","text":"center(B::Ballp{N}) where {N<:AbstractFloat}\n\nReturn the center of a ball in the p-norm.\n\nInput\n\nB – ball in the p-norm\n\nOutput\n\nThe center of the ball in the p-norm.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ballp/#Base.rand-Tuple{Type{Ballp}}","page":"Ballp","title":"Base.rand","text":"rand(::Type{Ballp}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nCreate a random ball in the p-norm.\n\nInput\n\nBallp – type for dispatch\nN     – (optional, default: Float64) numeric type\ndim   – (optional, default: 2) dimension\nrng   – (optional, default: GLOBAL_RNG) random number generator\nseed  – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random ball in the p-norm.\n\nAlgorithm\n\nThe center and radius are normally distributed with mean 0 and standard deviation 1. Additionally, the radius is nonnegative. The p-norm is a normally distributed number ≥ 1 with mean 1 and standard deviation 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ballp/#LazySets.translate-Union{Tuple{N}, Tuple{Ballp{N,VN} where VN<:AbstractArray{N,1},AbstractArray{N,1}}} where N<:AbstractFloat","page":"Ballp","title":"LazySets.translate","text":"translate(B::Ballp{N}, v::AbstractVector{N}) where {N<:AbstractFloat}\n\nTranslate (i.e., shift) a ball in the p-norm by a given vector.\n\nInput\n\nB – ball in the p-norm\nv – translation vector\n\nOutput\n\nA translated ball in the p- norm.\n\nAlgorithm\n\nWe add the vector to the center of the ball.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Ballp/","page":"Ballp","title":"Ballp","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Ballp/","page":"Ballp","title":"Ballp","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/sets/Ballp/","page":"Ballp","title":"Ballp","text":"Inherited from AbstractCentrallySymmetric:","category":"page"},{"location":"lib/sets/Ballp/","page":"Ballp","title":"Ballp","text":"dim\nisbounded\nisempty\nisuniversal\nan_element","category":"page"},{"location":"lib/lazy_operations/Rectification/","page":"Rectification","title":"Rectification","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/lazy_operations/Rectification/#def_Rectification","page":"Rectification","title":"Rectification","text":"","category":"section"},{"location":"lib/lazy_operations/Rectification/","page":"Rectification","title":"Rectification","text":"Note that the rectification of a convex set is generally not convex. Hence this set type is not part of the convex-set family LazySet.","category":"page"},{"location":"lib/lazy_operations/Rectification/","page":"Rectification","title":"Rectification","text":"Rectification\nset(::Rectification)\ndim(::Rectification)\nσ(::AbstractVector{N}, ::Rectification{N}) where {N<:Real}\nσ(::AbstractVector{N}, ::Rectification{N, <:AbstractHyperrectangle{N}}) where {N<:Real}\nσ(::AbstractVector{N}, ::Rectification{N, <:CartesianProduct{N}}) where {N<:Real}\nσ(::AbstractVector{N}, ::Rectification{N, <:CartesianProductArray{N}}) where {N<:Real}\nρ(::AbstractVector{N}, ::Rectification{N}) where {N<:Real}\nan_element(::Rectification{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::Rectification{N}) where {N<:Real}\nisempty(::Rectification)\nisbounded(::Rectification{N}) where {N<:Real}\nto_union_of_projections(::Rectification{N}, ::Bool=false) where {N<:Real}","category":"page"},{"location":"lib/lazy_operations/Rectification/#LazySets.Rectification","page":"Rectification","title":"LazySets.Rectification","text":"Rectification{N<:Real, S<:LazySet{N}}\n\nType that represents the rectification of a convex set.\n\nFields\n\nX     – convex set\ncache – storage of information computed before\n\nNotes\n\nGiven a vector v = (v_1  v_n), its rectification is defined as textrectify(v) = (v_1  v_n) such that v_i = max(v_i 0) for each i = 1  n.\n\nThe extension to a set X is defined elementwise:\n\n    textrectify(X) = textrectify(x) mid x  X\n\nThe rectification of a convex set X is not necessarily convex. It can be expressed exactly as the union of the intersection of X with the nonnegative orthant and the projection of the intersection of X with each other orthant. This can be seen as follows.\n\nFirst we observe that rectification distributes with union.\n\n    textrectify(X_1    X_m) = _j textrectify(X_j)\n\nNext we express X as the union of the intersection of X with each orthant O.\n\n    X = _j (X  O_j)\n\nThus we have\n\n    textrectify(X) = textrectify((X  O_1)    (X  O_m)) = _j textrectify(X  O_j)\n\nClearly, textrectify(X  O_j) = X if O_j is the nonnegative orthant.\n\nFor example, consider a two-dimensional case and call the orthants O_1  O_4 in clockwise fashion, starting with the nonnegative orthant. We conclude that\n\n    textrectify(X) = (X  O_1)  textrectify(X  O_2)  textrectify(X  O_3)  textrectify(X  O_4)\n\nThe rectification of the intersection in the nonpositive orthant, textrectify(X  O_3), is either the empty set or the singleton containing the origin. The rectification of X  O_2 and X  O_4 both result in flat 1-dimensional line segments on the corresponding hyperplane of O_1.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/Rectification/#LazySets.set-Tuple{Rectification}","page":"Rectification","title":"LazySets.set","text":"set(r::Rectification)\n\nReturn the original set of a rectification.\n\nInput\n\nr – rectification\n\nOutput\n\nThe original set of the rectification.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#LazySets.dim-Tuple{Rectification}","page":"Rectification","title":"LazySets.dim","text":"dim(r::Rectification)\n\nReturn the dimension of a rectification.\n\nInput\n\nr – rectification\n\nOutput\n\nThe ambient dimension of the rectification.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,S} where S<:LazySet{N}}} where N<:Real","page":"Rectification","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, r::Rectification{N}) where {N<:Real}\n\nReturn the support vector of a rectification.\n\nInput\n\nd – direction\nr – rectification\n\nOutput\n\nThe support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,#s15} where #s15<:AbstractHyperrectangle{N}}} where N<:Real","page":"Rectification","title":"LazySets.σ","text":"σ(d::AbstractVector{N},\n  r::Rectification{N, <:AbstractHyperrectangle{N}}) where {N<:Real}\n\nReturn the support vector of the rectification of a hyperrectangular set.\n\nInput\n\nd – direction\nr – rectification of a hyperrectangular set\n\nOutput\n\nThe support vector in the given direction.\n\nAlgorithm\n\nLet r() be the rectification of a vector respectively a set, and let H be a hyperrectangle. Then σ_r(H)(d) = r(σ_H(d)).\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,#s15} where #s15<:(CartesianProduct{N,S1,S2} where S2<:LazySet{N} where S1<:LazySet{N})}} where N<:Real","page":"Rectification","title":"LazySets.σ","text":"σ(d::AbstractVector{N},\n  r::Rectification{N, <:CartesianProduct{N}}) where {N<:Real}\n\nReturn the support vector of the rectification of a Cartesian product of two convex sets.\n\nInput\n\nd – direction\nr – rectification of a Cartesian product of two convex sets\n\nOutput\n\nThe support vector in the given direction.\n\nAlgorithm\n\nRectification distributes with the Cartesian product. Let r() be the rectification of a set. We can just query the support vector for r(X) and r(Y) recursively: σ_r(X  Y)(d) = σ_r(X)(d_X)  σ_r(Y)(d_Y), where x  y concatenates vectors x and y.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,#s15} where #s15<:(CartesianProductArray{N,S} where S<:LazySet{N})}} where N<:Real","page":"Rectification","title":"LazySets.σ","text":"σ(d::AbstractVector{N},\n  r::Rectification{N, <:CartesianProductArray{N}}) where {N<:Real}\n\nReturn the support vector of the rectification of a Cartesian product of a finite number of convex sets.\n\nInput\n\nd – direction\nr – rectification of a Cartesian product of a finite number of convex sets\n\nOutput\n\nThe support vector in the given direction.\n\nAlgorithm\n\nRectification distributes with the Cartesian product. Let r() be the rectification of a set. We can just query the support vector for each subspace recursively: σ_r(X_1    X_m)(d) = σ_r(X_1)(d_X_1)    σ_r(X_m)(d_X_m), where x  y concatenates vectors x and y.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,S} where S<:LazySet{N}}} where N<:Real","page":"Rectification","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, r::Rectification{N}) where {N<:Real}\n\nEvaluate the support function of a rectification of a convex set in a given direction.\n\nInput\n\nd – direction\nr – rectification of a convex set\n\nOutput\n\nThe support value of the rectification of a convex set in the given direction.\n\nAlgorithm\n\nWe use different procedures for different types of input sets. If the wrapped set has a suitable structure for which we can efficiently compute the support vector, we fall back to the evaluation of the support function by means of the support vector. Otherwise we compute the union of projections to obtain a precise result (see to_union_of_projections), and then compute the support function for this union. (The union is cached internally, so subsequent queries are more efficient.)\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#LazySets.an_element-Union{Tuple{Rectification{N,S} where S<:LazySet{N}}, Tuple{N}} where N<:Real","page":"Rectification","title":"LazySets.an_element","text":"an_element(r::Rectification{N}) where {N<:Real}\n\nReturn some element of a rectification.\n\nInput\n\nr – rectification\n\nOutput\n\nAn element in the rectification. The implementation relies on the an_element function of the wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Rectification{N,S} where S<:LazySet{N}}} where N<:Real","page":"Rectification","title":"Base.:∈","text":"∈(x::AbstractVector{N}, r::Rectification{N}) where {N<:Real}\n\nCheck whether a given point is contained in a rectification.\n\nInput\n\nx – point/vector\nr – rectification\n\nOutput\n\ntrue iff x  r.\n\nAlgorithm\n\nWe first scan for negative entries in the vector. If there are any, the vector is not contained in the rectification.\n\nNext we ask a membership query in the wrapped set. If the answer is positive, the vector is contained in the rectification.\n\nOtherwise, we scan for zero entries in the vector. If there are none, membership reduces to membership in the wrapped set, and so the answer is negative.\n\nFinally, if there are zero entries in the vector and the vector is not contained in the wrapped set, we give up and throw an error.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#Base.isempty-Tuple{Rectification}","page":"Rectification","title":"Base.isempty","text":"isempty(r::Rectification)\n\nCheck whether a rectification is empty or not.\n\nInput\n\nr – rectification\n\nOutput\n\ntrue iff the wrapped set is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#LazySets.isbounded-Union{Tuple{Rectification{N,S} where S<:LazySet{N}}, Tuple{N}} where N<:Real","page":"Rectification","title":"LazySets.isbounded","text":"isbounded(r::Rectification)\n\nDetermine whether a rectification is bounded.\n\nInput\n\nr – rectification\n\nOutput\n\ntrue iff the rectification is bounded.\n\nAlgorithm\n\nLet X be the set wrapped by rectification r. We first check whether X is bounded (because then r is bounded). Otherwise, we check unboundedness of X in direction (1 1  1), which is sufficient for unboundedness of r; this step is not necessary but rather a heuristics. Otherwise, we check boundedness of X in every positive unit direction, which is sufficient and necessary for boundedness of r.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#LazySets.to_union_of_projections-Union{Tuple{Rectification{N,S} where S<:LazySet{N}}, Tuple{N}, Tuple{Rectification{N,S} where S<:LazySet{N},Bool}} where N<:Real","page":"Rectification","title":"LazySets.to_union_of_projections","text":"to_union_of_projections(r::Rectification{N},\n                        concrete_intersection::Bool=false\n                       ) where {N<:Real}\n\nCompute an equivalent union of projections from a rectification of a convex set.\n\nInput\n\nr                     – rectification of a convex set\nconcrete_intersection – (optional, default: false) option to compute                            all intersections concretely or lazily\n\nAlgorithm\n\nLet X be the set wrapped by the rectification r. We compute a union of sets that represents the rectification of X precisely. The sets are lazy projections, potentially of intersections.\n\nWe first identify those dimensions where X is negative, using one support-function query per dimension, and collect the dimensions in the index set I_textneg. For each element in I_textneg we will later apply a projection to zero.\n\nNext we identify those dimensions from I_textneg where X is also positive, using another support-function query in each dimension, and collect the dimensions in the index set I_textmix. Let us call the remaining dimensions (I_textneg setminus I_textmix) I_textnonpos. For each dimension in j  I_textmix we will apply an intersection with axis-aligned polyhedra. In particular, we distinguish two cases using half-spaces x_j  0 and x_j  0, and then compute all possible combinations to intersect, using one half-space per dimension j  I_textmix.\n\nNext we project the intersections in all dimensions from i  I_textmix such that we used the half-space x_i  0 in their computation, and in all dimensions j  I_textnonpos irrespective of the half-space used.\n\nFinally, we take the union of the resulting sets.\n\nOutput\n\nThe result can be one of three cases depending on the wrapped set X, namely\n\nthe set X if X is contained in the positive quadrant,\na LinearMap (projection) of X if for each dimension, X is only either positive or negative, or\na UnionSetArray of LinearMaps (projections) otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/Rectification/#Rectification-cache","page":"Rectification","title":"Rectification cache","text":"","category":"section"},{"location":"lib/lazy_operations/Rectification/","page":"Rectification","title":"Rectification","text":"RectificationCache","category":"page"},{"location":"lib/lazy_operations/Rectification/#LazySets.RectificationCache","page":"Rectification","title":"LazySets.RectificationCache","text":"RectificationCache{N<:Real}\n\nStruct that is used as a cache for Rectifications.\n\nFields\n\nset                – set represented by the rectification (can be nothing                         if not computed yet)\nuse_support_vector – flag indicating whether to use support-vector                         computations for the cached set\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/LinearMap/","page":"LinearMap","title":"LinearMap","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/lazy_operations/LinearMap/#def_LinearMap","page":"LinearMap","title":"Linear map (LinearMap)","text":"","category":"section"},{"location":"lib/lazy_operations/LinearMap/","page":"LinearMap","title":"LinearMap","text":"LinearMap\n*(::Union{AbstractMatrix, UniformScaling, AbstractVector, Real}, ::LazySet)\ndim(::LinearMap)\nρ(::AbstractVector{N}, ::LinearMap{N}) where {N<:Real}\nσ(::AbstractVector{N}, ::LinearMap{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::LinearMap{N}) where {N<:Real}\nan_element(::LinearMap{N}) where {N<:Real}\nvertices_list(::LinearMap{N}) where {N<:Real}\nconstraints_list(::LinearMap{N}) where {N<:Real}\nlinear_map(::AbstractMatrix{N}, ::LinearMap{N}) where {N<:Real}","category":"page"},{"location":"lib/lazy_operations/LinearMap/#LazySets.LinearMap","page":"LinearMap","title":"LazySets.LinearMap","text":"LinearMap{N<:Real, S<:LazySet{N}, NM, MAT<:AbstractMatrix{NM}} <: AbstractAffineMap{N, S}\n\nType that represents a linear transformation MS of a convex set S.\n\nFields\n\nM – matrix/linear map\nX – convex set\n\nNotes\n\nThis type is parametric in the elements of the linear map, NM, which is independent of the numeric type of the wrapped set (N). Typically NM = N, but there may be exceptions, e.g., if NM is an interval that holds numbers of type N, where N is a floating point number type such as Float64.\n\nExamples\n\nFor the examples we create a 32 matrix and two unit squares, one of them being two-dimensional and the other one being one-dimensional.\n\njulia> A = [1 2; 1 3; 1 4]; X = BallInf([0, 0], 1); Y = BallInf([0], 1);\n\nThe function * can be used as an alias to construct a LinearMap object.\n\njulia> lm = LinearMap(A, X)\nLinearMap{Int64,BallInf{Int64,Array{Int64,1}},Int64,Array{Int64,2}}([1 2; 1 3; 1 4], BallInf{Int64,Array{Int64,1}}([0, 0], 1))\n\njulia> lm2 = A * X\nLinearMap{Int64,BallInf{Int64,Array{Int64,1}},Int64,Array{Int64,2}}([1 2; 1 3; 1 4], BallInf{Int64,Array{Int64,1}}([0, 0], 1))\n\njulia> lm == lm2\ntrue\n\nFor convenience, A does not need to be a matrix but we also allow to use vectors (interpreted as an n1 matrix) and UniformScalings resp. scalars (interpreted as a scaling, i.e., a scaled identity matrix). Scaling by 1 is ignored.\n\njulia> using LinearAlgebra: I\n\njulia> [2, 3] * Y\nLinearMap{Int64,BallInf{Int64,Array{Int64,1}},Int64,Array{Int64,2}}([2; 3], BallInf{Int64,Array{Int64,1}}([0], 1))\n\njulia> lm3 = 2 * X\nLinearMap{Int64,BallInf{Int64,Array{Int64,1}},Int64,SparseArrays.SparseMatrixCSC{Int64,Int64}}(\n  [1, 1]  =  2\n  [2, 2]  =  2, BallInf{Int64,Array{Int64,1}}([0, 0], 1))\n\njulia> 2I * X == lm3\ntrue\n\njulia> 1I * X == X\ntrue\n\nApplying a linear map to a LinearMap object combines the two maps into a single LinearMap instance. Again we can make use of the conversion for convenience.\n\njulia> B = transpose(A); B * lm\nLinearMap{Int64,BallInf{Int64,Array{Int64,1}},Int64,Array{Int64,2}}([3 9; 9 29], BallInf{Int64,Array{Int64,1}}([0, 0], 1))\n\njulia> B = [3, 4, 5]; B * lm\nLinearMap{Int64,BallInf{Int64,Array{Int64,1}},Int64,Array{Int64,2}}([12 38], BallInf{Int64,Array{Int64,1}}([0, 0], 1))\n\njulia> B = 2; B * lm\nLinearMap{Int64,BallInf{Int64,Array{Int64,1}},Int64,Array{Int64,2}}([2 4; 2 6; 2 8], BallInf{Int64,Array{Int64,1}}([0, 0], 1))\n\nThe application of a LinearMap to a ZeroSet or an EmptySet is simplified automatically.\n\njulia> A * ZeroSet{Int}(2)\nZeroSet{Int64}(3)\n\njulia> A * EmptySet{Int}(2)\nEmptySet{Int64}(2)\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/LinearMap/#Base.:*-Tuple{Union{Real, AbstractArray{T,2} where T, AbstractArray{T,1} where T, LinearAlgebra.UniformScaling},LazySet}","page":"LinearMap","title":"Base.:*","text":"    *(map::Union{AbstractMatrix, UniformScaling, AbstractVector, Real}, X::LazySet)\n\nAlias to create a LinearMap object.\n\nInput\n\nmap – linear map\nX   – convex set\n\nOutput\n\nA lazy linear map, i.e., a LinearMap instance.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/LinearMap/#LazySets.dim-Tuple{LinearMap}","page":"LinearMap","title":"LazySets.dim","text":"dim(lm::LinearMap)\n\nReturn the dimension of a linear map.\n\nInput\n\nlm – linear map\n\nOutput\n\nThe ambient dimension of the linear map.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/LinearMap/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LinearMap{N,S,NM,MAT} where MAT<:AbstractArray{NM,2} where NM where S<:LazySet{N}}} where N<:Real","page":"LinearMap","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, lm::LinearMap{N}; kwargs...) where {N<:Real}\n\nReturn the support function of the linear map.\n\nInput\n\nd      – direction\nlm     – linear map\nkwargs – additional arguments that are passed to the support function             algorithm\n\nOutput\n\nThe support function in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\nNotes\n\nIf L = MS, where M is a matrix and S is a convex set, it follows that ρ(d L) = ρ(M^T d S) for any direction d.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/LinearMap/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LinearMap{N,S,NM,MAT} where MAT<:AbstractArray{NM,2} where NM where S<:LazySet{N}}} where N<:Real","page":"LinearMap","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, lm::LinearMap{N}) where {N<:Real}\n\nReturn the support vector of the linear map.\n\nInput\n\nd  – direction\nlm – linear map\n\nOutput\n\nThe support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.\n\nNotes\n\nIf L = MS, where M is a matrix and S is a convex set, it follows that σ(d L) = Mσ(M^T d S) for any direction d.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/LinearMap/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},LinearMap{N,S,NM,MAT} where MAT<:AbstractArray{NM,2} where NM where S<:LazySet{N}}} where N<:Real","page":"LinearMap","title":"Base.:∈","text":"∈(x::AbstractVector{N}, lm::LinearMap{N}) where {N<:Real}\n\nCheck whether a given point is contained in a linear map of a convex set.\n\nInput\n\nx  – point/vector\nlm – linear map of a convex set\n\nOutput\n\ntrue iff x  lm.\n\nAlgorithm\n\nNote that x  MS iff M^-1x  S. This implementation does not explicitly invert the matrix, which is why it also works for non-square matrices.\n\nExamples\n\njulia> lm = LinearMap([2.0 0.0; 0.0 1.0], BallInf([1., 1.], 1.));\n\njulia> [5.0, 1.0] ∈ lm\nfalse\njulia> [3.0, 1.0] ∈ lm\ntrue\n\nAn example with non-square matrix:\n\njulia> B = BallInf(zeros(4), 1.);\n\njulia> M = [1. 0 0 0; 0 1 0 0]/2;\n\njulia> [0.5, 0.5] ∈ M*B\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/LinearMap/#LazySets.an_element-Union{Tuple{LinearMap{N,S,NM,MAT} where MAT<:AbstractArray{NM,2} where NM where S<:LazySet{N}}, Tuple{N}} where N<:Real","page":"LinearMap","title":"LazySets.an_element","text":"an_element(lm::LinearMap{N})::Vector{N} where {N<:Real}\n\nReturn some element of a linear map.\n\nInput\n\nlm – linear map\n\nOutput\n\nAn element in the linear map. It relies on the an_element function of the wrapped set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/LinearMap/#LazySets.vertices_list-Union{Tuple{LinearMap{N,S,NM,MAT} where MAT<:AbstractArray{NM,2} where NM where S<:LazySet{N}}, Tuple{N}} where N<:Real","page":"LinearMap","title":"LazySets.vertices_list","text":"vertices_list(lm::LinearMap{N}; prune::Bool=true)::Vector{Vector{N}} where {N<:Real}\n\nReturn the list of vertices of a (polyhedral) linear map.\n\nInput\n\nlm – linear map\nprune – (optional, default: true) if true removes redundant vertices\n\nOutput\n\nA list of vertices.\n\nAlgorithm\n\nWe assume that the underlying set X is polyhedral. Then the result is just the linear map applied to the vertices of X.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/LinearMap/#LazySets.constraints_list-Union{Tuple{LinearMap{N,S,NM,MAT} where MAT<:AbstractArray{NM,2} where NM where S<:LazySet{N}}, Tuple{N}} where N<:Real","page":"LinearMap","title":"LazySets.constraints_list","text":"constraints_list(lm::LinearMap{N}) where {N<:Real}\n\nReturn the list of constraints of a (polyhedral) linear map.\n\nInput\n\nlm – linear map\n\nOutput\n\nThe list of constraints of the linear map.\n\nNotes\n\nWe assume that the underlying set X is polyhedral, i.e., offers a method constraints_list(X).\n\nAlgorithm\n\nWe fall back to a concrete set representation and apply linear_map.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/LinearMap/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},LinearMap{N,S,NM,MAT} where MAT<:AbstractArray{NM,2} where NM where S<:LazySet{N}}} where N<:Real","page":"LinearMap","title":"LazySets.linear_map","text":"linear_map(M::AbstractMatrix{N}, lm::LinearMap{N}) where {N<:Real}\n\nReturn the linear map of a lazy linear map.\n\nInput\n\nM  – matrix\nlm – linear map\n\nOutput\n\nThe polytope representing the linear map of the lazy linear map of a set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/LinearMap/","page":"LinearMap","title":"LinearMap","text":"Inherited from AbstractAffineMap:","category":"page"},{"location":"lib/lazy_operations/LinearMap/","page":"LinearMap","title":"LinearMap","text":"isempty\nisbounded","category":"page"},{"location":"lib/lazy_operations/LinearMap/","page":"LinearMap","title":"LinearMap","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/LinearMap/","page":"LinearMap","title":"LinearMap","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/lazy_operations/LinearMap/","page":"LinearMap","title":"LinearMap","text":"The lazy projection of a set can be conveniently constructed using Projection.","category":"page"},{"location":"lib/lazy_operations/LinearMap/","page":"LinearMap","title":"LinearMap","text":"Projection","category":"page"},{"location":"lib/lazy_operations/LinearMap/#LazySets.Projection","page":"LinearMap","title":"LazySets.Projection","text":"Projection(X::LazySet{N}, variables::AbstractVector{Int}) where {N<:Real}\n\nReturn the lazy projection of a set.\n\nInput\n\nX         – set\nvariables – variables of interest\n\nOutput\n\nA lazy LinearMap that corresponds to projecting X along the given variables variables.\n\nExamples\n\nThe projection of a three-dimensional cube into the first two coordinates:\n\njulia> B = BallInf(zeros(3), 1.0)\nBallInf{Float64,Array{Float64,1}}([0.0, 0.0, 0.0], 1.0)\n\njulia> Bproj = Projection(B, [1, 2])\nLinearMap{Float64,BallInf{Float64,Array{Float64,1}},Float64,SparseArrays.SparseMatrixCSC{Float64,Int64}}(\n  [1, 1]  =  1.0\n  [2, 2]  =  1.0, BallInf{Float64,Array{Float64,1}}([0.0, 0.0, 0.0], 1.0))\n\njulia> isequivalent(Bproj, BallInf(zeros(2), 1.0))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/HPolygonOpt/","page":"HPolygonOpt","title":"HPolygonOpt","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/HPolygonOpt/#def_HPolygonOpt","page":"HPolygonOpt","title":"Polygon in optimized constraint representation (HPolygonOpt)","text":"","category":"section"},{"location":"lib/sets/HPolygonOpt/","page":"HPolygonOpt","title":"HPolygonOpt","text":"HPolygonOpt\nσ(::AbstractVector{N}, ::HPolygonOpt{N}) where {N<:Real}\ntranslate(::HPolygonOpt{N}, ::AbstractVector{N}) where {N<:Real}","category":"page"},{"location":"lib/sets/HPolygonOpt/#LazySets.HPolygonOpt","page":"HPolygonOpt","title":"LazySets.HPolygonOpt","text":"HPolygonOpt{N<:Real, VN<:AbstractVector{N}} <: AbstractHPolygon{N}\n\nType that represents a convex polygon in constraint representation whose edges are sorted in counter-clockwise fashion with respect to their normal directions. This is a refined version of HPolygon.\n\nFields\n\nconstraints       – list of linear constraints, sorted by the normal                        direction in counter-clockwise fashion\nind               – index in the list of constraints to begin the search                        to evaluate the support function\nsort_constraints  – (optional, default: true) flag for sorting the                        constraints (sortedness is a running assumption of this                        type)\ncheck_boundedness – (optional, default: false) flag for checking if the                        constraints make the polygon bounded; (boundedness is a                        running assumption of this type)\nprune             – (optional, default: true) flag for removing redundant                        constraints\n\nNotes\n\nThis structure is optimized to evaluate the support function/vector with a large sequence of directions that are close to each other. The strategy is to have an index that can be used to warm-start the search for optimal values in the support vector computation.\n\nThe option sort_constraints can be used to deactivate automatic sorting of constraints in counter-clockwise fashion, which is an invariant of this type. Alternatively, one can construct an HPolygonOpt with empty constraints list, which can then be filled iteratively using addconstraint!.\n\nSimilarly, the option prune can be used to deactivate automatic pruning of redundant constraints.\n\nAnother type assumption is that the polygon is bounded. The option check_boundedness can be used to assert this. This option is deactivated by default because we explicitly want to allow the iterative addition of the constraints, and hence one has to initially construct an empty list of constraints (which represents an unbounded set). The user has to make sure that the HPolygonOpt is not used before the constraints actually describe a bounded set. The function isbounded can be used to manually assert boundedness.\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/HPolygonOpt/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},HPolygonOpt{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"HPolygonOpt","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, P::HPolygonOpt{N};\n  [linear_search]::Bool=(length(P.constraints) < BINARY_SEARCH_THRESHOLD)\n ) where {N<:Real}\n\nReturn the support vector of an optimized polygon in a given direction.\n\nInput\n\nd             – direction\nP             – optimized polygon in constraint representation\nlinear_search – (optional, default: see below) flag for controlling whether                    to perform a linear search or a binary search\n\nOutput\n\nThe support vector in the given direction. The result is always one of the vertices; in particular, if the direction has norm zero, any vertex is returned.\n\nAlgorithm\n\nComparison of directions is performed using polar angles; see the overload of <= for two-dimensional vectors.\n\nFor polygons with BINARY_SEARCH_THRESHOLD = 10 or more constraints we use a binary search by default.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolygonOpt/#LazySets.translate-Union{Tuple{N}, Tuple{HPolygonOpt{N,VN} where VN<:AbstractArray{N,1},AbstractArray{N,1}}} where N<:Real","page":"HPolygonOpt","title":"LazySets.translate","text":"translate(P::HPolygonOpt{N}, v::AbstractVector{N}; share::Bool=false\n         ) where {N<:Real}\n\nTranslate (i.e., shift) an optimized polygon in constraint representation by a given vector.\n\nInput\n\nP     – optimized polygon in constraint representation\nv     – translation vector\nshare – (optional, default: false) flag for sharing unmodified parts of            the original set representation\n\nOutput\n\nA translated optimized polygon in constraint representation.\n\nNotes\n\nThe normal vectors of the constraints (vector a in a⋅x ≤ b) are shared with the original constraints if share == true.\n\nAlgorithm\n\nWe translate every constraint.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolygonOpt/","page":"HPolygonOpt","title":"HPolygonOpt","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/HPolygonOpt/","page":"HPolygonOpt","title":"HPolygonOpt","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/sets/HPolygonOpt/","page":"HPolygonOpt","title":"HPolygonOpt","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/HPolygonOpt/","page":"HPolygonOpt","title":"HPolygonOpt","text":"isempty\nisuniversal\nsingleton_list","category":"page"},{"location":"lib/sets/HPolygonOpt/","page":"HPolygonOpt","title":"HPolygonOpt","text":"Inherited from AbstractPolygon:","category":"page"},{"location":"lib/sets/HPolygonOpt/","page":"HPolygonOpt","title":"HPolygonOpt","text":"dim","category":"page"},{"location":"lib/sets/HPolygonOpt/","page":"HPolygonOpt","title":"HPolygonOpt","text":"Inherited from AbstractHPolygon:","category":"page"},{"location":"lib/sets/HPolygonOpt/","page":"HPolygonOpt","title":"HPolygonOpt","text":"an_element\n∈\nvertices_list\ntohrep\ntovrep\nnormalize\nisbounded\naddconstraint!\nisredundant\nremove_redundant_constraints!\nconstraints_list","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/HPolygon/#def_HPolygon","page":"HPolygon","title":"Polygon in constraint representation (HPolygon)","text":"","category":"section"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"HPolygon\nσ(::AbstractVector{N}, ::HPolygon{N}) where {N<:Real}\ntranslate(::HPolygon{N}, ::AbstractVector{N}) where {N<:Real}","category":"page"},{"location":"lib/sets/HPolygon/#LazySets.HPolygon","page":"HPolygon","title":"LazySets.HPolygon","text":"HPolygon{N<:Real, VN<:AbstractVector{N}} <: AbstractHPolygon{N}\n\nType that represents a convex polygon in constraint representation whose edges are sorted in counter-clockwise fashion with respect to their normal directions.\n\nFields\n\nconstraints       – list of linear constraints, sorted by the normal                        direction in counter-clockwise fashion\nsort_constraints  – (optional, default: true) flag for sorting the                        constraints (sortedness is a running assumption of this                        type)\ncheck_boundedness – (optional, default: false) flag for checking if the                        constraints make the polygon bounded; (boundedness is a                        running assumption of this type)\nprune             – (optional, default: true) flag for removing redundant                        constraints\n\nNotes\n\nThe option sort_constraints can be used to deactivate automatic sorting of constraints in counter-clockwise fashion, which is an invariant of this type. Alternatively, one can construct an HPolygon with empty constraints list, which can then be filled iteratively using addconstraint!.\n\nSimilarly, the option prune can be used to deactivate automatic pruning of redundant constraints.\n\nAnother type assumption is that the polygon is bounded. The option check_boundedness can be used to assert this. This option is deactivated by default because we explicitly want to allow the iterative addition of the constraints, and hence one has to initially construct an empty list of constraints (which represents an unbounded set). The user has to make sure that the HPolygon is not used before the constraints actually describe a bounded set. The function isbounded can be used to manually assert boundedness.\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/HPolygon/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},HPolygon{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"HPolygon","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, P::HPolygon{N};\n  [linear_search]::Bool=(length(P.constraints) < BINARY_SEARCH_THRESHOLD)\n ) where {N<:Real}\n\nReturn the support vector of a polygon in a given direction.\n\nInput\n\nd             – direction\nP             – polygon in constraint representation\nlinear_search – (optional, default: see below) flag for controlling whether                    to perform a linear search or a binary search\n\nOutput\n\nThe support vector in the given direction. The result is always one of the vertices; in particular, if the direction has norm zero, any vertex is returned.\n\nAlgorithm\n\nComparison of directions is performed using polar angles; see the overload of <= for two-dimensional vectors.\n\nFor polygons with BINARY_SEARCH_THRESHOLD = 10 or more constraints we use a binary search by default.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolygon/#LazySets.translate-Union{Tuple{N}, Tuple{HPolygon{N,VN} where VN<:AbstractArray{N,1},AbstractArray{N,1}}} where N<:Real","page":"HPolygon","title":"LazySets.translate","text":"translate(v::AbstractVector{N}, P::HPolygon{N}; share::Bool=false\n         ) where {N<:Real}\n\nTranslate (i.e., shift) a polygon in constraint representation by a given vector.\n\nInput\n\nP     – polygon in constraint representation\nv     – translation vector\nshare – (optional, default: false) flag for sharing unmodified parts of            the original set representation\n\nOutput\n\nA translated polygon in constraint representation.\n\nNotes\n\nThe normal vectors of the constraints (vector a in a⋅x ≤ b) are shared with the original constraints if share == true.\n\nAlgorithm\n\nWe translate every constraint.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"isempty\nisuniversal\nsingleton_list\nlinear_map","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"Inherited from AbstractPolygon:","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"dim","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"Inherited from AbstractHPolygon:","category":"page"},{"location":"lib/sets/HPolygon/","page":"HPolygon","title":"HPolygon","text":"an_element\n∈\nvertices_list\ntohrep\ntovrep\nnormalize\nisbounded\naddconstraint!\nisredundant\nremove_redundant_constraints!\nconstraints_list","category":"page"},{"location":"lib/sets/Line2D/","page":"Line2D","title":"Line2D","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/Line2D/#def_Line","page":"Line2D","title":"Line2D","text":"","category":"section"},{"location":"lib/sets/Line2D/","page":"Line2D","title":"Line2D","text":"Line2D\ndim(::Line2D)\nσ(::AbstractVector{N}, ::Line2D{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::Line2D{N}) where {N<:Real}\nan_element(::Line2D{N}) where {N<:Real}\nrand(::Type{Line2D})\nisbounded(::Line2D)\nisuniversal(::Line2D{N}, ::Bool=false) where {N<:Real}\nisempty(::Line2D)\nconstrained_dimensions(::Line2D{N}) where {N<:Real}\nconstraints_list(::Line2D{N}) where {N<:Real}\ntranslate(::Line2D{N}, ::AbstractVector{N}) where {N<:Real}","category":"page"},{"location":"lib/sets/Line2D/#LazySets.Line2D","page":"Line2D","title":"LazySets.Line2D","text":"Line2D{N<:Real, VN<:AbstractVector{N}} <: AbstractPolyhedron{N}\n\nType that represents a line in 2D of the form ax = b (i.e., a special case of a Hyperplane).\n\nFields\n\na – normal direction (non-zero)\nb – constraint\n\nExamples\n\nThe line y = -x + 1:\n\njulia> Line2D([1., 1.], 1.)\nLine2D{Float64,Array{Float64,1}}([1.0, 1.0], 1.0)\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Line2D/#LazySets.dim-Tuple{Line2D}","page":"Line2D","title":"LazySets.dim","text":"dim(L::Line2D)\n\nReturn the ambient dimension of a line.\n\nInput\n\nL – line\n\nOutput\n\nThe ambient dimension of the line, which is 2.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Line2D{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Line2D","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, L::Line2D{N}) where {N<:Real}\n\nReturn the support vector of a line in a given direction.\n\nInput\n\nd – direction\nL – line\n\nOutput\n\nThe support vector in the given direction, which is defined the same way as for the more general Hyperplane.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Line2D{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Line2D","title":"Base.:∈","text":"∈(x::AbstractVector{N}, L::Line2D{N}) where {N<:Real}\n\nCheck whether a given point is contained in a line.\n\nInput\n\nx – point/vector\nL – line\n\nOutput\n\ntrue iff x ∈ L.\n\nAlgorithm\n\nThe point x belongs to the line if and only if ax = b holds.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#LazySets.an_element-Union{Tuple{Line2D{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"Line2D","title":"LazySets.an_element","text":"an_element(L::Line2D{N}) where {N<:Real}\n\nReturn some element of a line.\n\nInput\n\nL – line\n\nOutput\n\nAn element on the line.\n\nAlgorithm\n\nIf the b value of the line is zero, the result is the origin. Otherwise the result is some x = x1 x2 such that ax1 x2 = b. We first find out in which dimension a is nonzero, say, dimension 1, and then choose x1 = 1 and accordingly x2 = fracb - a1a2.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#Base.rand-Tuple{Type{Line2D}}","page":"Line2D","title":"Base.rand","text":"rand(::Type{Line2D}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nCreate a random line.\n\nInput\n\nLine2D – type for dispatch\nN    – (optional, default: Float64) numeric type\ndim  – (optional, default: 2) dimension\nrng  – (optional, default: GLOBAL_RNG) random number generator\nseed – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random line.\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the constraint a is nonzero.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#LazySets.isbounded-Tuple{Line2D}","page":"Line2D","title":"LazySets.isbounded","text":"isbounded(L::Line2D)\n\nDetermine whether a line is bounded.\n\nInput\n\nL – line\n\nOutput\n\nfalse.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#LazySets.isuniversal-Union{Tuple{Line2D{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}, Tuple{Line2D{N,VN} where VN<:AbstractArray{N,1},Bool}} where N<:Real","page":"Line2D","title":"LazySets.isuniversal","text":"isuniversal(L::Line2D{N}, [witness]::Bool=false) where {N<:Real}\n\nCheck whether a line is universal.\n\nInput\n\nP       – line\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: false\nIf witness option is activated: (false, v) where v  P\n\nAlgorithm\n\nWitness production falls back to isuniversal(::Hyperplane).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#Base.isempty-Tuple{Line2D}","page":"Line2D","title":"Base.isempty","text":"isempty(L::Line2D)\n\nReturn if a line is empty or not.\n\nInput\n\nL – line\n\nOutput\n\nfalse.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#LazySets.constrained_dimensions-Union{Tuple{Line2D{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"Line2D","title":"LazySets.constrained_dimensions","text":"constrained_dimensions(L::Line2D{N}) where {N<:Real}\n\nReturn the indices in which a line is constrained.\n\nInput\n\nL – line\n\nOutput\n\nA vector of ascending indices i such that the line is constrained in dimension i.\n\nExamples\n\nA line with constraint x1 = 0 is constrained in dimension 1 only.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#LazySets.constraints_list-Union{Tuple{Line2D{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"Line2D","title":"LazySets.constraints_list","text":"constraints_list(L::Line2D{N}) where {N<:Real}\n\nReturn the list of constraints of a line.\n\nInput\n\nL – line\n\nOutput\n\nA list containing two half-spaces.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/#LazySets.translate-Union{Tuple{N}, Tuple{Line2D{N,VN} where VN<:AbstractArray{N,1},AbstractArray{N,1}}} where N<:Real","page":"Line2D","title":"LazySets.translate","text":"translate(L::Line2D{N}, v::AbstractVector{N}; share::Bool=false\n         ) where {N<:Real}\n\nTranslate (i.e., shift) a line by a given vector.\n\nInput\n\nL     – line\nv     – translation vector\nshare – (optional, default: false) flag for sharing unmodified parts of            the original set representation\n\nOutput\n\nA translated line.\n\nNotes\n\nThe normal vector of the line (vector a in a⋅x = b) is shared with the original line if share == true.\n\nAlgorithm\n\nA line ax = b is transformed to the line ax = b + av. In other words, we add the dot product av to b.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Line2D/","page":"Line2D","title":"Line2D","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Line2D/","page":"Line2D","title":"Line2D","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/sets/VPolytope/","page":"VPolytope","title":"VPolytope","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/VPolytope/#def_VPolytope","page":"VPolytope","title":"Polytope in vertex representation (VPolytope)","text":"","category":"section"},{"location":"lib/sets/VPolytope/","page":"VPolytope","title":"VPolytope","text":"VPolytope\ndim(::VPolytope)\nσ(::AbstractVector{N}, ::VPolytope{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::VPolytope{N}) where {N<:Real}\nrand(::Type{VPolytope})\ntranslate(::VPolytope{N}, ::AbstractVector{N}) where {N<:Real}\nvertices_list(::VPolytope{N}) where {N<:Real}\nremove_redundant_vertices(::VPolytope{N}) where {N<:Real}\nconstraints_list(::VPolytope{N}) where {N<:Real}\ntohrep(::VPolytope{N}) where {N<:Real}\ntovrep(::VPolytope)\npolyhedron(::VPolytope{N}) where {N<:Real}\nlinear_map(::AbstractMatrix{N}, ::VPolytope{N}) where {N<:Real}","category":"page"},{"location":"lib/sets/VPolytope/#LazySets.VPolytope","page":"VPolytope","title":"LazySets.VPolytope","text":"VPolytope{N<:Real, VN<:AbstractVector{N}} <: AbstractPolytope{N}\n\nType that represents a convex polytope in V-representation.\n\nFields\n\nvertices – list of vertices\n\nExamples\n\nA polytope in vertex representation can be constructed by passing the list of vertices. For example, we can build the tetrahedron:\n\njulia> P = VPolytope([0 0 0; 1 0 0; 0 1 0; 0 0 1]);\n\njulia> P.vertices\n3-element Array{Array{Int64,1},1}:\n [0, 1, 0, 0]\n [0, 0, 1, 0]\n [0, 0, 0, 1]\n\nAlternatively, a VPolytope can be constructed passing a matrix of vertices, where each column represents a vertex:\n\njulia> M = [0 0 0; 1 0 0; 0 1 0; 0 0 1]'\n3×4 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}:\n 0  1  0  0\n 0  0  1  0\n 0  0  0  1\n\njulia> P = VPolytope(M);\n\njulia> P.vertices\n4-element Array{Array{Int64,1},1}:\n [0, 0, 0]\n [1, 0, 0]\n [0, 1, 0]\n [0, 0, 1]\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/VPolytope/#LazySets.dim-Tuple{VPolytope}","page":"VPolytope","title":"LazySets.dim","text":"dim(P::VPolytope)\n\nReturn the dimension of a polytope in V-representation.\n\nInput\n\nP  – polytope in V-representation\n\nOutput\n\nThe ambient dimension of the polytope in V-representation. If it is empty, the result is -1.\n\nExamples\n\njulia> v = VPolytope();\n\njulia> v.vertices\n0-element Array{Array{Float64,1},1}\n\njulia> dim(v)\n-1\n\njulia> v = VPolytope([ones(3)]);\n\njulia> v.vertices\n1-element Array{Array{Float64,1},1}:\n [1.0, 1.0, 1.0]\n\njulia> dim(v) == 3\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},VPolytope{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"VPolytope","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, P::VPolytope{N}) where {N<:Real}\n\nReturn the support vector of a polytope in V-representation in a given direction.\n\nInput\n\nd – direction\nP – polytope in V-representation\n\nOutput\n\nThe support vector in the given direction.\n\nAlgorithm\n\nA support vector maximizes the support function. For a polytope, the support function is always maximized in some vertex. Hence it is sufficient to check all vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},VPolytope{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"VPolytope","title":"Base.:∈","text":"∈(x::AbstractVector{N}, P::VPolytope{N};\n  solver=default_lp_solver(N)) where {N<:Real}\n\nCheck whether a given point is contained in a polytope in vertex representation.\n\nInput\n\nx      – point/vector\nP      – polytope in vertex representation\nsolver – (optional, default: default_lp_solver(N)) the backend used to             solve the linear program\n\nOutput\n\ntrue iff x  P.\n\nAlgorithm\n\nWe check, using linear programming, the definition of a convex polytope that a point is in the set if and only if it is a convex combination of the vertices.\n\nLet v_j be the m vertices of P. Then we solve the following m-dimensional linear program.\n\nmax 0 text st \nbigwedge_i=1^n sum_j=1^m λ_j v_ji = xi\n sum_j=1^m λ_j = 1\n bigwedge_j=1^m λ_j  0\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#Base.rand-Tuple{Type{VPolytope}}","page":"VPolytope","title":"Base.rand","text":"rand(::Type{VPolytope}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing,\n     [num_vertices]::Int=-1)\n\nCreate a random polytope in vertex representation.\n\nInput\n\nVPolytope    – type for dispatch\nN            – (optional, default: Float64) numeric type\ndim          – (optional, default: 2) dimension\nrng          – (optional, default: GLOBAL_RNG) random number generator\nseed         – (optional, default: nothing) seed for reseeding\nnum_vertices – (optional, default: -1) upper bound on the number of                   vertices of the polytope (see comment below)\n\nOutput\n\nA random polytope in vertex representation.\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1.\n\nThe number of vertices can be controlled with the argument num_vertices. For a negative value we choose a random number in the range dim:5*dim (except if dim == 1, in which case we choose in the range 1:2). Note that we do not guarantee that the vertices are not redundant.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.translate-Union{Tuple{N}, Tuple{VPolytope{N,VN} where VN<:AbstractArray{N,1},AbstractArray{N,1}}} where N<:Real","page":"VPolytope","title":"LazySets.translate","text":"translate(P::VPolytope{N}, v::AbstractVector{N}) where {N<:Real}\n\nTranslate (i.e., shift) a polytope in vertex representation by a given vector.\n\nInput\n\nP – polytope in vertex representation\nv – translation vector\n\nOutput\n\nA translated polytope in vertex representation.\n\nAlgorithm\n\nWe add the vector to each vertex of the polytope.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.vertices_list-Union{Tuple{VPolytope{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"VPolytope","title":"LazySets.vertices_list","text":"vertices_list(P::VPolytope{N}) where {N<:Real}\n\nReturn the list of vertices of a polytope in V-representation.\n\nInput\n\nP – polytope in vertex representation\n\nOutput\n\nList of vertices.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.remove_redundant_vertices-Union{Tuple{VPolytope{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"VPolytope","title":"LazySets.remove_redundant_vertices","text":"remove_redundant_vertices(P::VPolytope{N};\n                          [backend]=nothing,\n                          [solver]=nothing) where {N<:Real}\n\nReturn the polytope obtained by removing the redundant vertices of the given polytope.\n\nInput\n\nP       – polytope in vertex representation\nbackend – (optional, default: nothing) the backend for polyhedral              computations; see default_polyhedra_backend(P, N) or              Polyhedra's documentation              for further information\nsolver  – (optional, default: nothing) the linear programming              solver used in the backend, if needed; see              default_lp_solver_polyhedra(N)\n\nOutput\n\nA new polytope such that its vertices are the convex hull of the given polytope.\n\nNotes\n\nThe optimization problem associated to removing redundant vertices is handled by Polyhedra. If the polyhedral computations backend requires an LP solver but it has not been set, we use default_lp_solver_polyhedra(N) to define such solver. Otherwise, the redundancy removal function of the polyhedral backend is used.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.constraints_list-Union{Tuple{VPolytope{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"VPolytope","title":"LazySets.constraints_list","text":"constraints_list(P::VPolytope{N}) where {N<:Real}\n\nReturn the list of constraints defining a polytope in V-representation.\n\nInput\n\nP – polytope in V-representation\n\nOutput\n\nThe list of constraints of the polytope.\n\nAlgorithm\n\nFirst the H-representation of P is computed, then its list of constraints is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.tohrep-Union{Tuple{VPolytope{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"VPolytope","title":"LazySets.tohrep","text":"tohrep(P::VPolytope{N};\n       [backend]=default_polyhedra_backend(P, N)) where {N<:Real}\n\nTransform a polytope in V-representation to a polytope in H-representation.\n\nInput\n\nP       – polytope in vertex representation\nbackend – (optional, default: default_polyhedra_backend(P, N)) the              backend for polyhedral computations; see Polyhedra's              documentation for further              information\n\nOutput\n\nThe HPolytope which is the constraint representation of the given polytope in vertex representation.\n\nNotes\n\nThe conversion may not preserve the numeric type (e.g., with N == Float32) depending on the backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.tovrep-Tuple{VPolytope}","page":"VPolytope","title":"LazySets.tovrep","text":"tovrep(P::VPolytope)\n\nReturn a vertex representation of the given polytope in vertex representation (no-op).\n\nInput\n\nP – polytope in vertex representation\n\nOutput\n\nThe same polytope instance.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#Polyhedra.polyhedron-Union{Tuple{VPolytope{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"VPolytope","title":"Polyhedra.polyhedron","text":"polyhedron(P::VPolytope{N};\n           [backend]=default_polyhedra_backend(P, N)) where {N<:Real}\n\nReturn an VRep polyhedron from Polyhedra.jl given a polytope in V-representation.\n\nInput\n\nP       – polytope\nbackend – (optional, default: default_polyhedra_backend(P, N)) the              backend for polyhedral computations; see Polyhedra's              documentation for further              information\nrelative_dimension – (default, optional: nothing) an integer representing                         the (relative) dimension of the polytope; this                         argument is mandatory if the polytope is empty\n\nOutput\n\nA VRep polyhedron.\n\nNotes\n\nThe relative dimension (or just dimension) refers to the dimension of the set relative to itself, independently of the ambient dimension. For example, a point has (relative) dimension zero, and a line segment has (relative) dimension one.\n\nIn this library, LazySets.dim always returns the ambient dimension of the set, such that a line segment in two dimensions has dimension two. However, Polyhedra.dim will assign a dimension equal to one to a line segment because it uses a different convention.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},VPolytope{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"VPolytope","title":"LazySets.linear_map","text":"linear_map(M::AbstractMatrix{N}, P::VPolytope{N}) where {N<:Real}\n\nConcrete linear map of a polytope in vertex representation.\n\nInput\n\nM – matrix\nP – polytope in vertex representation\n\nOutput\n\nA polytope in vertex representation.\n\nAlgorithm\n\nThe linear map M is applied to each vertex of the given set P, obtaining a polytope in V-representation. The output type is again a VPolytope.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/VPolytope/","page":"VPolytope","title":"VPolytope","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/VPolytope/","page":"VPolytope","title":"VPolytope","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/sets/VPolytope/","page":"VPolytope","title":"VPolytope","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/VPolytope/","page":"VPolytope","title":"VPolytope","text":"isbounded\nisempty\nisuniversal\nsingleton_list\nlinear_map","category":"page"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/HPolyhedron/#def_HPolyhedron","page":"HPolyhedron","title":"Polyhedron in constraint representation (HPolyhedron)","text":"","category":"section"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"HPolyhedron","category":"page"},{"location":"lib/sets/HPolyhedron/#LazySets.HPolyhedron","page":"HPolyhedron","title":"LazySets.HPolyhedron","text":"HPolyhedron{N<:Real, VN<:AbstractVector{N}} <: AbstractPolyhedron{N}\n\nType that represents a convex polyhedron in H-representation.\n\nFields\n\nconstraints – vector of linear constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"The following methods are shared between HPolytope and HPolyhedron.","category":"page"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"dim(::HPoly{N}) where {N<:Real}\nρ(::AbstractVector{N}, ::HPoly{N}) where {N<:Real}\nσ(::AbstractVector{N}, ::HPoly{N}) where {N<:Real}\naddconstraint!(::HPoly{N}, ::LinearConstraint{N}) where {N<:Real}\nconstraints_list(::HPoly{N}) where {N<:Real}\ntohrep(::HPoly{N}) where {N<:Real}\ntovrep(::HPoly{N}) where {N<:Real}\nnormalize(::HPoly{N}, p=N(2)) where {N<:Real}\nisempty(::HPoly{N}, ::Bool=false) where {N<:Real}\ntranslate(::HPoly{N}, ::AbstractVector{N}) where {N<:Real}\npolyhedron(::HPoly{N}) where {N<:Real}\nremove_redundant_constraints(::HPoly{N}) where {N<:Real}\nremove_redundant_constraints!(::HPoly{N}) where {N<:Real}","category":"page"},{"location":"lib/sets/HPolyhedron/#LazySets.dim-Union{Tuple{Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}}}, Tuple{N}} where N<:Real","page":"HPolyhedron","title":"LazySets.dim","text":"dim(P::HPoly{N}) where {N<:Real}\n\nReturn the dimension of a polyhedron in H-representation.\n\nInput\n\nP  – polyhedron in H-representation\n\nOutput\n\nThe ambient dimension of the polyhedron in H-representation. If it has no constraints, the result is -1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}}}} where N<:Real","page":"HPolyhedron","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, P::HPoly{N};\n  solver=default_lp_solver(N)) where {N<:Real}\n\nEvaluate the support function of a polyhedron (in H-representation) in a given direction.\n\nInput\n\nd      – direction\nP      – polyhedron in H-representation\nsolver – (optional, default: default_lp_solver(N)) the backend used to             solve the linear program\n\nOutput\n\nThe support function of the polyhedron. If a polytope is unbounded in the given direction, we throw an error. If a polyhedron is unbounded in the given direction, the result is Inf.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}}}} where N<:Real","page":"HPolyhedron","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, P::HPoly{N}; solver=default_lp_solver(N)\n ) where {N<:Real}\n\nReturn the support vector of a polyhedron (in H-representation) in a given direction.\n\nInput\n\nd      – direction\nP      – polyhedron in H-representation\nsolver – (optional, default: default_lp_solver(N)) the backend used to             solve the linear program\n\nOutput\n\nThe support vector in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.addconstraint!-Union{Tuple{N}, Tuple{Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}},HalfSpace{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"HPolyhedron","title":"LazySets.addconstraint!","text":"addconstraint!(P::HPoly{N}, constraint::LinearConstraint{N}) where {N<:Real}\n\nAdd a linear constraint to a polyhedron in H-representation.\n\nInput\n\nP          – polyhedron in H-representation\nconstraint – linear constraint to add\n\nNotes\n\nIt is left to the user to guarantee that the dimension of all linear constraints is the same.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.constraints_list-Union{Tuple{Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}}}, Tuple{N}} where N<:Real","page":"HPolyhedron","title":"LazySets.constraints_list","text":"constraints_list(P::HPoly{N}) where {N<:Real}\n\nReturn the list of constraints defining a polyhedron in H-representation.\n\nInput\n\nP – polyhedron in H-representation\n\nOutput\n\nThe list of constraints of the polyhedron.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.tohrep-Union{Tuple{Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}}}, Tuple{N}} where N<:Real","page":"HPolyhedron","title":"LazySets.tohrep","text":"tohrep(P::HPoly{N}) where {N<:Real}\n\nReturn a constraint representation of the given polyhedron in constraint representation (no-op).\n\nInput\n\nP – polyhedron in constraint representation\n\nOutput\n\nThe same polyhedron instance.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.tovrep-Union{Tuple{Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}}}, Tuple{N}} where N<:Real","page":"HPolyhedron","title":"LazySets.tovrep","text":"tovrep(P::HPoly{N};\n      [backend]=default_polyhedra_backend(P, N)) where {N<:Real}\n\nTransform a polyhedron in H-representation to a polytope in V-representation.\n\nInput\n\nP       – polyhedron in constraint representation\nbackend – (optional, default: default_polyhedra_backend(P, N)) the              backend for polyhedral computations\n\nOutput\n\nThe VPolytope which is the vertex representation of the given polyhedron in constraint representation.\n\nNotes\n\nThe conversion may not preserve the numeric type (e.g., with N == Float32) depending on the backend. For further information on the supported backends see Polyhedra's documentation.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LinearAlgebra.normalize-Union{Tuple{Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}}}, Tuple{N}, Tuple{Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}},Any}} where N<:Real","page":"HPolyhedron","title":"LinearAlgebra.normalize","text":"normalize(P::HPoly{N}, p=N(2)) where {N<:Real}\n\nNormalize a polyhedron in constraint representation.\n\nInput\n\nP – polyhedron in constraint representation\np – (optional, default: 2) norm\n\nOutput\n\nA new polyhedron in constraint representation whose normal directions a_i are normalized, i.e., such that a_i_p = 1 holds.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#Base.isempty-Union{Tuple{Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}}}, Tuple{N}, Tuple{Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}},Bool}} where N<:Real","page":"HPolyhedron","title":"Base.isempty","text":"isempty(P::HPoly{N}, witness::Bool=false;            [usepolyhedrainterface]::Bool=false, [solver]=defaultlpsolver(N),            [backend]=nothing) where {N<:Real}\n\nDetermine whether a polyhedron is empty.\n\nInput\n\nP       – polyhedron\nwitness – (optional, default: false) compute a witness if activated\nuse_polyhedra_interface – (optional, default: false) if true, we use              the Polyhedra interface for the emptiness test\nsolver  – (optional, default: default_lp_solver(N)) LP-solver backend\nbackend – (optional, default: nothing) backend for polyhedral              computations in Polyhedra; its value is set internally (see the              Notes below for details)\n\nOutput\n\nIf witness option is deactivated: true iff P = \nIf witness option is activated:\n(true, []) iff P = \n(false, v) iff P   and v  P\n\nNotes\n\nThe default value of the backend is set internally and depends on whether the use_polyhedra_interface option is set or not. If the option is set, we use default_polyhedra_backend(P, N).\n\nWitness production is not supported if use_polyhedra_interface is true.\n\nAlgorithm\n\nThe algorithm sets up a feasibility LP for the constraints of P. If use_polyhedra_interface is true, we call Polyhedra.isempty. Otherwise, we set up the LP internally.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.translate-Union{Tuple{N}, Tuple{Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}},AbstractArray{N,1}}} where N<:Real","page":"HPolyhedron","title":"LazySets.translate","text":"translate(P::HPoly{N}, v::AbstractVector{N}; share::Bool=false\n         ) where {N<:Real}\n\nTranslate (i.e., shift) a polyhedron in constraint representation by a given vector.\n\nInput\n\nP     – polyhedron in constraint representation\nv     – translation vector\nshare – (optional, default: false) flag for sharing unmodified parts of            the original set representation\n\nOutput\n\nA translated polyhedron in constraint representation.\n\nNotes\n\nThe normal vectors of the constraints (vector a in a⋅x ≤ b) are shared with the original constraints if share == true.\n\nAlgorithm\n\nWe translate every constraint.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#Polyhedra.polyhedron-Union{Tuple{Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}}}, Tuple{N}} where N<:Real","page":"HPolyhedron","title":"Polyhedra.polyhedron","text":"polyhedron(P::HPoly{N};\n           [backend]=default_polyhedra_backend(P, N)) where {N<:Real}\n\nReturn an HRep polyhedron from Polyhedra.jl given a polytope in H-representation.\n\nInput\n\nP       – polytope\nbackend – (optional, default: call default_polyhedra_backend(P, N))               the polyhedral computations backend\n\nOutput\n\nAn HRep polyhedron.\n\nNotes\n\nFor further information on the supported backends see Polyhedra's documentation.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.remove_redundant_constraints-Union{Tuple{Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}}}, Tuple{N}} where N<:Real","page":"HPolyhedron","title":"LazySets.remove_redundant_constraints","text":"remove_redundant_constraints(P::HPoly{N};\n                             backend=default_lp_solver(N)\n                            ) where {N<:Real}\n\nRemove the redundant constraints in a polyhedron in H-representation.\n\nInput\n\nP       – polyhedron\nbackend – (optional, default: default_lp_solver(N)) the backend used to              solve the linear program\n\nOutput\n\nA polyhedron equivalent to P but with no redundant constraints, or an empty set if P is detected to be empty, which may happen if the constraints are infeasible.\n\nAlgorithm\n\nSee remove_redundant_constraints!(::AbstractVector{<:LinearConstraint}) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.remove_redundant_constraints!-Union{Tuple{Union{HPolyhedron{N,VN} where VN<:AbstractArray{N,1}, HPolytope{N,VN} where VN<:AbstractArray{N,1}}}, Tuple{N}} where N<:Real","page":"HPolyhedron","title":"LazySets.remove_redundant_constraints!","text":"remove_redundant_constraints!(P::HPoly{N};\n                              backend=default_lp_solver(N)) where {N<:Real}\n\nRemove the redundant constraints in a polyhedron in H-representation; the polyhedron is updated in-place.\n\nInput\n\nP       – polyhedron\nbackend – (optional, default: default_lp_solver(N)) the backend used to              solve the linear program\n\nOutput\n\ntrue if the method was successful and the polyhedron P is modified by removing its redundant constraints, and false if P is detected to be empty, which may happen if the constraints are infeasible.\n\nAlgorithm\n\nSee remove_redundant_constraints!(::AbstractVector{<:LinearConstraint}) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"∈\n[constrained_dimensions](@ref constrained_dimensions(::AbstractPolyhedron)\nlinear_map","category":"page"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"The following methods are specific to HPolyhedron.","category":"page"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"rand(::Type{HPolyhedron})\nisbounded(::HPolyhedron)","category":"page"},{"location":"lib/sets/HPolyhedron/#Base.rand-Tuple{Type{HPolyhedron}}","page":"HPolyhedron","title":"Base.rand","text":"rand(::Type{HPolyhedron}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nCreate a polyhedron.\n\nInput\n\nHPolyhedron – type for dispatch\nN           – (optional, default: Float64) numeric type\ndim         – (optional, default: 2) dimension (is ignored)\nrng         – (optional, default: GLOBAL_RNG) random number generator\nseed        – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA polyhedron.\n\nAlgorithm\n\nWe first create a random polytope and then randomly remove some of the constraints.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/#LazySets.isbounded-Tuple{HPolyhedron}","page":"HPolyhedron","title":"LazySets.isbounded","text":"isbounded(P::HPolyhedron)\n\nDetermine whether a polyhedron in constraint representation is bounded.\n\nInput\n\nP – polyhedron in constraint representation\n\nOutput\n\ntrue iff the polyhedron is bounded.\n\nAlgorithm\n\nWe first check if the polyhedron has more than max(dim(P), 1) constraints, which is a necessary condition for boundedness. If so, we check boundedness via isbounded_unit_dimensions.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"Inherited from AbstractPolyhedron:","category":"page"},{"location":"lib/sets/HPolyhedron/","page":"HPolyhedron","title":"HPolyhedron","text":"isuniversal\nvertices_list\nsingleton_list","category":"page"},{"location":"man/interval_hulls/#Interval-Hulls","page":"Interval Hulls","title":"Interval Hulls","text":"","category":"section"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"In this section we illustrate the interval hull operators as well as several plotting functionalities.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"Pages = [\"interval_hulls.md\"]\nDepth = 3","category":"page"},{"location":"man/interval_hulls/#Balls-and-Singletons","page":"Interval Hulls","title":"Balls and Singletons","text":"","category":"section"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"Consider a ball in the 2-norm. By default, the coefficients of this set are 64-bit floating point numbers. Other numeric types (such as lower precision floating point, or rational) can be defined with the proper argument types in the Ball2 constructor.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"using Plots, LazySets\n\nX = Ball2(ones(2), 0.5)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"To plot a lazy set, we use the plot function. By design, lazy sets plots overapproximate with box directions only. To have a sharp definition of the borders, use the accuracy as a second argument.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"plot(X, 1e-3, aspectratio=1)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"To add plots to the same pair of axes we use plot!. Let's add some points of the set which are farthest in some given directions. Single points can be plotted using the Singleton type. In the third line of code we plot the center of the ball picking a custom cross marker.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"plot!(Singleton(σ([1., 0], X)))\nplot!(Singleton(σ([1., 1], X)))\nplot!(Singleton(X.center), markershape=:x)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"note: Note\nTo see the list of available plot keyword arguments, use the plotattr([attr]) function, where attr is the symbol :Plot, :Series, :Axis or :Subplot.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"For the remainder of this section we define another ball in the 2-norm and its convex hull with X.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"Y = Ball2([-3,-.5], 0.8)\nZ = CH(X, Y)\n\nplot(X, 1e-3, aspectratio=1)\nplot!(Y, 1e-3)\nplot!(Z, 1e-3, alpha=0.2)","category":"page"},{"location":"man/interval_hulls/#Ballinf-approximation","page":"Interval Hulls","title":"Ballinf approximation","text":"","category":"section"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"A simple overapproximation with a BallInf is obtained with the ballinf_approximation function, from the Approximations module. It overapproximates a convex set by a tight ball in the infinity norm by evaluating the support vector in the canonical directions.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"import LazySets.Approximations.ballinf_approximation\n\nplot(X, 1e-3, aspectratio=1)\nplot!(Y, 1e-3)\nplot!(Z, 1e-3, alpha=0.2)\n\nBapprox = ballinf_approximation(Z)\n\nplot!(Bapprox, alpha=0.1)\nplot!(Singleton(Bapprox.center), markershape=:x)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"Bapprox.center, Bapprox.radius","category":"page"},{"location":"man/interval_hulls/#Interval-hull-approximation","page":"Interval Hulls","title":"Interval hull approximation","text":"","category":"section"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"If we want to have different lengths for each dimension, instead of the ballinf_approximation, we can use the approximation with a hyperrectangle through the interval_hull function.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"import LazySets.Approximations.interval_hull\n\nplot(X, 1e-3, aspectratio=1)\nplot!(Y, 1e-3)\nplot!(Z, 1e-3, alpha=0.2)\n\nHapprox = interval_hull(Z)\n\nplot!(Happrox, alpha=0.1)\nplot!(Singleton(Happrox.center), markershape=:x)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"Happrox.center, Happrox.radius","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"note: Note\nThe interval_hull function is an alias for the box_approximation function. The nomenclature for approximation functions is *_approximation_*. To see a list of all approximation functions, either search in the docs or type names(LazySets.Approximations).","category":"page"},{"location":"man/interval_hulls/#Symmetric-interval-hull","page":"Interval Hulls","title":"Symmetric interval hull","text":"","category":"section"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"Contrary to the previous approximations, the symmetric interval hull is centered around the origin. It is defined in the Approximations module as well.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"import LazySets.Approximations.symmetric_interval_hull\nusing SparseArrays\n\nplot(X, 1e-3, aspectratio=1)\nplot!(Y, 1e-3)\nplot!(Z, 1e-3, alpha=0.2)\n\nS = symmetric_interval_hull(Z)\nplot!(S, alpha=0.2)\nplot!(Singleton(S.center), markershape=:x)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"S.center, S.radius","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"We can get the list of vertices using the vertices_list function:","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"vertices_list(S)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"For instance, compute the support vector in the south-east direction:","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"σ([1., -1.], S)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"It is also possible to pass a sparse vector as direction, and the result is a sparse vector:","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"σ(sparsevec([1., -1.]), S)","category":"page"},{"location":"man/interval_hulls/#Norm,-radius-and-diameter","page":"Interval Hulls","title":"Norm, radius and diameter","text":"","category":"section"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"In this part we illustrate some functions to obtain metric properties of sets, applied to the sets X, Y and Z defined previously, in the infinity norm. These functions apply generally to any LazySet. For some types, specialized methods are triggered automatically through multiple-dispatch.","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"The norm of a convex set is the norm of the enclosing ball (of the given norm) of minimal volume. For instance:","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"import LazySets.Approximations: norm, radius, diameter\n\nnorm(X), norm(Y), norm(Z)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"The radius of a convex set. It is the radius of the enclosing ball (of the given norm) of minimal volume with the same center. In the previous example,","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"radius(X), radius(Y), radius(Z)","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"Finally, it is sometimes convenient to ask directly the diameter of the set, defined as twice the radius:","category":"page"},{"location":"man/interval_hulls/","page":"Interval Hulls","title":"Interval Hulls","text":"diameter(X), diameter(Y), diameter(Z)","category":"page"},{"location":"lib/sets/HalfSpace/","page":"HalfSpace","title":"HalfSpace","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/HalfSpace/#def_HalfSpace","page":"HalfSpace","title":"Half-space (HalfSpace)","text":"","category":"section"},{"location":"lib/sets/HalfSpace/","page":"HalfSpace","title":"HalfSpace","text":"HalfSpace\nLinearConstraint\ndim(::HalfSpace)\nρ(::AbstractVector{N}, ::HalfSpace{N}) where {N<:Real}\nσ(::AbstractVector{N}, ::HalfSpace{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::HalfSpace{N}) where {N<:Real}\nan_element(::HalfSpace{N}) where {N<:Real}\nrand(::Type{HalfSpace})\nnormalize(::HalfSpace{N}, p=N(2)) where {N<:Real}\nisbounded(::HalfSpace)\nisuniversal(::HalfSpace{N}, ::Bool=false) where {N<:Real}\nisempty(::HalfSpace)\nconstraints_list(::HalfSpace{N}) where {N<:Real}\nconstraints_list(::AbstractMatrix{N}, ::AbstractVector{N}) where {N<:Real}\nconstrained_dimensions(::HalfSpace{N}) where {N<:Real}\ntranslate(::HalfSpace{N}, ::AbstractVector{N}) where {N<:Real}\nhalfspace_left(::AbstractVector{N}, ::AbstractVector{N}) where {N<:Real}\nhalfspace_right(::AbstractVector{N}, ::AbstractVector{N}) where {N<:Real}\ntosimplehrep(::AbstractVector{LC}) where {N<:Real, LC<:LinearConstraint{N}}\nremove_redundant_constraints\nremove_redundant_constraints!","category":"page"},{"location":"lib/sets/HalfSpace/#LazySets.HalfSpace","page":"HalfSpace","title":"LazySets.HalfSpace","text":"HalfSpace{N<:Real, VN<:AbstractVector{N}} <: AbstractPolyhedron{N}\n\nType that represents a (closed) half-space of the form ax  b.\n\nFields\n\na – normal direction (non-zero)\nb – constraint\n\nExamples\n\nThe half-space x + 2y - z  3:\n\njulia> HalfSpace([1, 2, -1.], 3.)\nHalfSpace{Float64,Array{Float64,1}}([1.0, 2.0, -1.0], 3.0)\n\nTo represent the set y  0 in the plane, we have to rearrange the expression as 0x - y  0:\n\njulia> HalfSpace([0, -1.], 0.)\nHalfSpace{Float64,Array{Float64,1}}([0.0, -1.0], 0.0)\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/HalfSpace/#LazySets.LinearConstraint","page":"HalfSpace","title":"LazySets.LinearConstraint","text":"LinearConstraint\n\nAlias for HalfSpace\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/HalfSpace/#LazySets.dim-Tuple{HalfSpace}","page":"HalfSpace","title":"LazySets.dim","text":"dim(hs::HalfSpace)\n\nReturn the dimension of a half-space.\n\nInput\n\nhs – half-space\n\nOutput\n\nThe ambient dimension of the half-space.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},HalfSpace{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"HalfSpace","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, hs::HalfSpace{N}) where {N<:Real}\n\nEvaluate the support function of a half-space in a given direction.\n\nInput\n\nd  – direction\nhs – half-space\n\nOutput\n\nThe support function of the half-space. If the set is unbounded in the given direction, the result is Inf.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},HalfSpace{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"HalfSpace","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, hs::HalfSpace{N}) where {N<:Real}\n\nReturn the support vector of a half-space.\n\nInput\n\nd  – direction\nhs – half-space\n\nOutput\n\nThe support vector in the given direction, which is only defined in the following two cases:\n\nThe direction has norm zero.\nThe direction is the half-space's normal direction.\n\nIn both cases the result is any point on the boundary (the defining hyperplane). Otherwise this function throws an error.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},HalfSpace{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"HalfSpace","title":"Base.:∈","text":"∈(x::AbstractVector{N}, hs::HalfSpace{N}) where {N<:Real}\n\nCheck whether a given point is contained in a half-space.\n\nInput\n\nx – point/vector\nhs – half-space\n\nOutput\n\ntrue iff x  hs.\n\nAlgorithm\n\nWe just check if x satisfies ax  b.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.an_element-Union{Tuple{HalfSpace{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"HalfSpace","title":"LazySets.an_element","text":"an_element(hs::HalfSpace{N}) where {N<:Real}\n\nReturn some element of a half-space.\n\nInput\n\nhs – half-space\n\nOutput\n\nAn element on the defining hyperplane.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#Base.rand-Tuple{Type{HalfSpace}}","page":"HalfSpace","title":"Base.rand","text":"rand(::Type{HalfSpace}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nCreate a random half-space.\n\nInput\n\nHalfSpace – type for dispatch\nN         – (optional, default: Float64) numeric type\ndim       – (optional, default: 2) dimension\nrng       – (optional, default: GLOBAL_RNG) random number generator\nseed      – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random half-space.\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the constraint a is nonzero.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LinearAlgebra.normalize-Union{Tuple{HalfSpace{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}, Tuple{HalfSpace{N,VN} where VN<:AbstractArray{N,1},Any}} where N<:Real","page":"HalfSpace","title":"LinearAlgebra.normalize","text":"normalize(hs::HalfSpace{N}, p=N(2)) where {N<:Real}\n\nNormalize a half-space.\n\nInput\n\nhs – half-space\np  – (optional, default: 2) norm\n\nOutput\n\nA new half-space whose normal direction a is normalized, i.e., such that a_p = 1 holds.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.isbounded-Tuple{HalfSpace}","page":"HalfSpace","title":"LazySets.isbounded","text":"isbounded(hs::HalfSpace)\n\nDetermine whether a half-space is bounded.\n\nInput\n\nhs – half-space\n\nOutput\n\nfalse.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.isuniversal-Union{Tuple{HalfSpace{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}, Tuple{HalfSpace{N,VN} where VN<:AbstractArray{N,1},Bool}} where N<:Real","page":"HalfSpace","title":"LazySets.isuniversal","text":"isuniversal(hs::HalfSpace{N}, [witness]::Bool=false) where {N<:Real}\n\nCheck whether a half-space is universal.\n\nInput\n\nP       – half-space\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: false\nIf witness option is activated: (false, v) where v  P\n\nAlgorithm\n\nWitness production falls back to isuniversal(::Hyperplane).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#Base.isempty-Tuple{HalfSpace}","page":"HalfSpace","title":"Base.isempty","text":"isempty(hs::HalfSpace)\n\nReturn if a half-space is empty or not.\n\nInput\n\nhs – half-space\n\nOutput\n\nfalse.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.constraints_list-Union{Tuple{HalfSpace{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"HalfSpace","title":"LazySets.constraints_list","text":"constraints_list(hs::HalfSpace{N}) where {N<:Real}\n\nReturn the list of constraints of a half-space.\n\nInput\n\nhs – half-space\n\nOutput\n\nA singleton list containing the half-space.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.constraints_list-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractArray{N,1}}} where N<:Real","page":"HalfSpace","title":"LazySets.constraints_list","text":"constraints_list(A::AbstractMatrix{N}, b::AbstractVector{N}) where {N<:Real}\n\nConvert a matrix-vector representation to a linear-constraint representation.\n\nInput\n\nA – matrix\nb – vector\n\nOutput\n\nA list of linear constraints.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.constrained_dimensions-Union{Tuple{HalfSpace{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"HalfSpace","title":"LazySets.constrained_dimensions","text":"constrained_dimensions(hs::HalfSpace{N}) where {N<:Real}\n\nReturn the indices in which a half-space is constrained.\n\nInput\n\nhs – half-space\n\nOutput\n\nA vector of ascending indices i such that the half-space is constrained in dimension i.\n\nExamples\n\nA 2D half-space with constraint x1  0 is constrained in dimension 1 only.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.translate-Union{Tuple{N}, Tuple{HalfSpace{N,VN} where VN<:AbstractArray{N,1},AbstractArray{N,1}}} where N<:Real","page":"HalfSpace","title":"LazySets.translate","text":"translate(hs::HalfSpace{N}, v::AbstractVector{N}; share::Bool=false\n         ) where {N<:Real}\n\nTranslate (i.e., shift) a half-space by a given vector.\n\nInput\n\nhs    – half-space\nv     – translation vector\nshare – (optional, default: false) flag for sharing unmodified parts of            the original set representation\n\nOutput\n\nA translated half-space.\n\nNotes\n\nThe normal vectors of the halfspace (vector a in a⋅x ≤ b) is shared with the original halfspace if share == true.\n\nAlgorithm\n\nA half-space ax  b is transformed to the half-space ax  b + av. In other words, we add the dot product av to b.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.halfspace_left-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,1}}} where N<:Real","page":"HalfSpace","title":"LazySets.halfspace_left","text":"halfspace_left(p::AbstractVector{N}, q::AbstractVector{N}) where {N<:Real}\n\nReturn a half-space describing the 'left' of a two-dimensional line segment through two points.\n\nInput\n\np – first point\nq – second point\n\nOutput\n\nThe half-space whose boundary goes through the two points p and q and which describes the left-hand side of the directed line segment pq.\n\nAlgorithm\n\nThe implementation is simple: the half-space ax  b is calculated as a = [dy, -dx], where d = (dx dy) denotes the line segment pq, that is, vecd = vecp - vecq, and b = dot(p, a).\n\nExamples\n\nThe left half-space of the \"east\" and \"west\" directions in two-dimensions are the upper and lower half-spaces:\n\njulia> using LazySets: halfspace_left\n\njulia> halfspace_left([0.0, 0.0], [1.0, 0.0])\nHalfSpace{Float64,Array{Float64,1}}([0.0, -1.0], 0.0)\n\njulia> halfspace_left([0.0, 0.0], [-1.0, 0.0])\nHalfSpace{Float64,Array{Float64,1}}([0.0, 1.0], 0.0)\n\nWe create a box from the sequence of line segments that describe its edges:\n\njulia> H1 = halfspace_left([-1.0, -1.0], [1.0, -1.0]);\n\njulia> H2 = halfspace_left([1.0, -1.0], [1.0, 1.0]);\n\njulia> H3 = halfspace_left([1.0, 1.0], [-1.0, 1.0]);\n\njulia> H4 = halfspace_left([-1.0, 1.0], [-1.0, -1.0]);\n\njulia> H = HPolygon([H1, H2, H3, H4]);\n\njulia> B = BallInf([0.0, 0.0], 1.0);\n\njulia> B ⊆ H && H ⊆ B\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.halfspace_right-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,1}}} where N<:Real","page":"HalfSpace","title":"LazySets.halfspace_right","text":"halfspace_right(p::AbstractVector{N}, q::AbstractVector{N}) where {N<:Real}\n\nReturn a half-space describing the 'right' of a two-dimensional line segment through two points.\n\nInput\n\np – first point\nq – second point\n\nOutput\n\nThe half-space whose boundary goes through the two points p and q and which describes the right-hand side of the directed line segment pq.\n\nAlgorithm\n\nSee the documentation of halfspace_left.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.tosimplehrep-Union{Tuple{AbstractArray{LC,1}}, Tuple{LC}, Tuple{N}} where LC<:(HalfSpace{N,VN} where VN<:AbstractArray{N,1}) where N<:Real","page":"HalfSpace","title":"LazySets.tosimplehrep","text":"tosimplehrep(constraints::AbstractVector{LC})\n    where {N<:Real, LC<:LinearConstraint{N}}\n\nReturn the simple H-representation Ax  b from a list of linear constraints.\n\nInput\n\nconstraints – a list of linear constraints\n\nOutput\n\nThe tuple (A, b) where A is the matrix of normal directions and b is the vector of offsets.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HalfSpace/#LazySets.remove_redundant_constraints","page":"HalfSpace","title":"LazySets.remove_redundant_constraints","text":"remove_redundant_constraints(\n    constraints::AbstractVector{<:LinearConstraint{N}};\n    backend=default_lp_solver(N)) where {N<:Real}\n\nRemove the redundant constraints of a given list of linear constraints.\n\nInput\n\nconstraints – list of constraints\nbackend     – (optional, default: default_lp_solver(N)) the backend used                  to solve the linear program\n\nOutput\n\nThe list of constraints with the redundant ones removed, or an empty set if the constraints are infeasible.\n\nAlgorithm\n\nSee remove_redundant_constraints!(::AbstractVector{<:LinearConstraint}) for details.\n\n\n\n\n\nremove_redundant_constraints(P::HPoly{N};\n                             backend=default_lp_solver(N)\n                            ) where {N<:Real}\n\nRemove the redundant constraints in a polyhedron in H-representation.\n\nInput\n\nP       – polyhedron\nbackend – (optional, default: default_lp_solver(N)) the backend used to              solve the linear program\n\nOutput\n\nA polyhedron equivalent to P but with no redundant constraints, or an empty set if P is detected to be empty, which may happen if the constraints are infeasible.\n\nAlgorithm\n\nSee remove_redundant_constraints!(::AbstractVector{<:LinearConstraint}) for details.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/HalfSpace/#LazySets.remove_redundant_constraints!","page":"HalfSpace","title":"LazySets.remove_redundant_constraints!","text":" remove_redundant_constraints!(\n     constraints::AbstractVector{<:LinearConstraint{N}};\n     [backend]=default_lp_solver(N)) where {N<:Real}\n\nRemove the redundant constraints of a given list of linear constraints; the list is updated in-place.\n\nInput\n\nconstraints – list of constraints\nbackend     – (optional, default: default_lp_solver(N)) the backend used                  to solve the linear program\n\nOutput\n\ntrue if the function was successful and the list of constraints constraints is modified by removing the redundant constraints, and false only if the constraints are infeasible.\n\nNotes\n\nNote that the result may be true even if the constraints are infeasible. For example, x  0  x  1 will return true without removing any constraint. To check if the constraints are infeasible, use isempty(HPolyhedron(constraints).\n\nAlgorithm\n\nIf there are m constraints in n dimensions, this function checks one by one if each of the m constraints is implied by the remaining ones.\n\nTo check if the k-th constraint is redundant, an LP is formulated using the constraints that have not yet being removed. If, at an intermediate step, it is detected that a subgroup of the constraints is infeasible, this function returns false. If the calculation finished successfully, this function returns true.\n\nFor details, see Fukuda's Polyhedra FAQ.\n\n\n\n\n\nremove_redundant_constraints!(P::AbstractHPolygon)\n\nRemove all redundant constraints of a polygon in constraint representation.\n\nInput\n\nP – polygon in constraint representation\n\nOutput\n\nThe same polygon with all redundant constraints removed.\n\nNotes\n\nSince we only consider bounded polygons and a polygon needs at least three constraints to be bounded, we stop removing redundant constraints if there are three or less constraints left. This means that for non-bounded polygons the result may be unexpected.\n\nAlgorithm\n\nWe go through all consecutive triples of constraints and check if the one in the middle is redundant. For this we assume that the constraints are sorted.\n\n\n\n\n\nremove_redundant_constraints!(P::HPoly{N};\n                              backend=default_lp_solver(N)) where {N<:Real}\n\nRemove the redundant constraints in a polyhedron in H-representation; the polyhedron is updated in-place.\n\nInput\n\nP       – polyhedron\nbackend – (optional, default: default_lp_solver(N)) the backend used to              solve the linear program\n\nOutput\n\ntrue if the method was successful and the polyhedron P is modified by removing its redundant constraints, and false if P is detected to be empty, which may happen if the constraints are infeasible.\n\nAlgorithm\n\nSee remove_redundant_constraints!(::AbstractVector{<:LinearConstraint}) for details.\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/HalfSpace/","page":"HalfSpace","title":"HalfSpace","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/HalfSpace/","page":"HalfSpace","title":"HalfSpace","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/#def_SymmetricIntervalHull","page":"SymmetricIntervalHull","title":"Symmetric interval hull (SymmetricIntervalHull)","text":"","category":"section"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"SymmetricIntervalHull\ndim(::SymmetricIntervalHull)\nσ(::AbstractVector{N}, ::SymmetricIntervalHull{N}) where {N<:Real}\ncenter(::SymmetricIntervalHull{N}, ::Int) where {N<:Real}\ncenter(::SymmetricIntervalHull{N}) where {N<:Real}\nradius_hyperrectangle(::SymmetricIntervalHull{N}) where {N<:Real}\nradius_hyperrectangle(::SymmetricIntervalHull{N}, ::Int) where {N<:Real}","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/#LazySets.SymmetricIntervalHull","page":"SymmetricIntervalHull","title":"LazySets.SymmetricIntervalHull","text":"SymmetricIntervalHull{N<:Real, S<:LazySet{N}} <: AbstractHyperrectangle{N}\n\nType that represents the symmetric interval hull of a compact convex set.\n\nFields\n\nX     – compact convex set\ncache – partial storage of already computed bounds, organized as mapping   from dimension to tuples (bound, valid), where valid is a flag   indicating if the bound entry has been computed\n\nNotes\n\nThe symmetric interval hull can be computed with 2n support vector queries of unit vectors, where n is the dimension of the wrapped set (i.e., two queries per dimension). When asking for the support vector for a direction d, one needs 2k such queries, where k is the number of non-zero entries in d.\n\nHowever, if one asks for many support vectors in a loop, the number of computations may exceed 2n. To be most efficient in such cases, this type stores the intermediately computed bounds in the cache field.\n\nThe set X must be compact.\n\n\n\n\n\n","category":"type"},{"location":"lib/lazy_operations/SymmetricIntervalHull/#LazySets.dim-Tuple{SymmetricIntervalHull}","page":"SymmetricIntervalHull","title":"LazySets.dim","text":"dim(sih::SymmetricIntervalHull)\n\nReturn the dimension of a symmetric interval hull of a convex set.\n\nInput\n\nsih – symmetric interval hull of a convex set\n\nOutput\n\nThe ambient dimension of the symmetric interval hull of a convex set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/SymmetricIntervalHull/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},SymmetricIntervalHull{N,S} where S<:LazySet{N}}} where N<:Real","page":"SymmetricIntervalHull","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, sih::SymmetricIntervalHull{N}) where {N<:Real}\n\nReturn the support vector of a symmetric interval hull of a convex set in a given direction.\n\nInput\n\nd   – direction\nsih – symmetric interval hull of a convex set\n\nOutput\n\nThe support vector of the symmetric interval hull of a convex set in the given direction. If the direction has norm zero, the origin is returned.\n\nAlgorithm\n\nFor each non-zero entry in d we need to either look up the bound (if it has been computed before) or compute it, in which case we store it for future queries. One such computation just asks for the support vector of the underlying set for both the positive and negative unit vector in the respective dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/SymmetricIntervalHull/#LazySets.center-Union{Tuple{N}, Tuple{SymmetricIntervalHull{N,S} where S<:LazySet{N},Int64}} where N<:Real","page":"SymmetricIntervalHull","title":"LazySets.center","text":"center(sih::SymmetricIntervalHull{N}, i::Int) where {N<:Real}\n\nReturn the center along a given dimension of a symmetric interval hull of a convex set.\n\nInput\n\nsih – symmetric interval hull of a convex set\ni – dimension of interest\n\nOutput\n\nThe center along a given dimension of the symmetric interval hull of a convex set.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/SymmetricIntervalHull/#LazySets.center-Union{Tuple{SymmetricIntervalHull{N,S} where S<:LazySet{N}}, Tuple{N}} where N<:Real","page":"SymmetricIntervalHull","title":"LazySets.center","text":"center(sih::SymmetricIntervalHull{N}) where {N<:Real}\n\nReturn the center of a symmetric interval hull of a convex set.\n\nInput\n\nsih – symmetric interval hull of a convex set\n\nOutput\n\nThe origin.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/SymmetricIntervalHull/#LazySets.radius_hyperrectangle-Union{Tuple{SymmetricIntervalHull{N,S} where S<:LazySet{N}}, Tuple{N}} where N<:Real","page":"SymmetricIntervalHull","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(sih::SymmetricIntervalHull{N}) where {N<:Real}\n\nReturn the box radius of a symmetric interval hull of a convex set in every dimension.\n\nInput\n\nsih – symmetric interval hull of a convex set\n\nOutput\n\nThe box radius of the symmetric interval hull of a convex set.\n\nNotes\n\nThis function computes the symmetric interval hull explicitly.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/SymmetricIntervalHull/#LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{SymmetricIntervalHull{N,S} where S<:LazySet{N},Int64}} where N<:Real","page":"SymmetricIntervalHull","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(sih::SymmetricIntervalHull{N},\n                      i::Int) where {N<:Real}\n\nReturn the box radius of a symmetric interval hull of a convex set in a given dimension.\n\nInput\n\nsih – symmetric interval hull of a convex set\ni   – dimension of interest\n\nOutput\n\nThe radius in the given dimension. If it was computed before, this is just a look-up, otherwise it requires two support vector computations.\n\n\n\n\n\n","category":"method"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"Inherited from LazySet:","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"diameter","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"isbounded\nsingleton_list","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"isempty\nan_element","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"ngens\nlinear_map\norder\ntogrep\ntranslate","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"Inherited from AbstractHyperrectangle:","category":"page"},{"location":"lib/lazy_operations/SymmetricIntervalHull/","page":"SymmetricIntervalHull","title":"SymmetricIntervalHull","text":"ρ\nσ\n∈\nnorm\nradius\nconstraints_list\nvertices_list\nhigh\nlow\ngenerators\ngenmat","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/Singleton/#def_Singleton","page":"Singleton","title":"Singleton","text":"","category":"section"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"Singleton\nrand(::Type{Singleton})\nelement(::Singleton{N}) where {N<:Real}\nelement(::Singleton{N}, ::Int) where {N<:Real}\ntranslate(::Singleton{N}, ::AbstractVector{N}) where {N<:Real}","category":"page"},{"location":"lib/sets/Singleton/#LazySets.Singleton","page":"Singleton","title":"LazySets.Singleton","text":"Singleton{N<:Real, VN<:AbstractVector{N}} <: AbstractSingleton{N}\n\nType that represents a singleton, that is, a set with a unique element.\n\nFields\n\nelement – the only element of the set\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Singleton/#Base.rand-Tuple{Type{Singleton}}","page":"Singleton","title":"Base.rand","text":"rand(::Type{Singleton}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nCreate a random singleton.\n\nInput\n\nSingleton – type for dispatch\nN         – (optional, default: Float64) numeric type\ndim       – (optional, default: 2) dimension\nrng       – (optional, default: GLOBAL_RNG) random number generator\nseed      – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random singleton.\n\nAlgorithm\n\nThe element is a normally distributed vector with entries of mean 0 and standard deviation 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Singleton/#LazySets.element-Union{Tuple{Singleton{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"Singleton","title":"LazySets.element","text":"element(S::Singleton{N}) where {N<:Real}\n\nReturn the element of a singleton.\n\nInput\n\nS – singleton\n\nOutput\n\nThe element of the singleton.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Singleton/#LazySets.element-Union{Tuple{N}, Tuple{Singleton{N,VN} where VN<:AbstractArray{N,1},Int64}} where N<:Real","page":"Singleton","title":"LazySets.element","text":"element(S::Singleton{N}, i::Int) where {N<:Real}\n\nReturn the i-th entry of the element of a singleton.\n\nInput\n\nS – singleton\ni – dimension\n\nOutput\n\nThe i-th entry of the element of the singleton.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Singleton/#LazySets.translate-Union{Tuple{N}, Tuple{Singleton{N,VN} where VN<:AbstractArray{N,1},AbstractArray{N,1}}} where N<:Real","page":"Singleton","title":"LazySets.translate","text":"translate(S::Singleton{N}, v::AbstractVector{N}) where {N<:Real}\n\nTranslate (i.e., shift) a singleton by a given vector.\n\nInput\n\nS – singleton\nv – translation vector\n\nOutput\n\nA translated singleton.\n\nAlgorithm\n\nWe add the vector to the point in the singleton.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"diameter","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"isbounded\nisuniversal\nsingleton_list","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"dim\nisempty","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"ngens\norder\ntogrep","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"Inherited from AbstractHyperrectangle:","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"norm\nradius\nhigh\nlow\nconstraints_list","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"Inherited from AbstractSingleton:","category":"page"},{"location":"lib/sets/Singleton/","page":"Singleton","title":"Singleton","text":"σ\n∈\nan_element\ncenter\nvertices_list\nradius_hyperrectangle\nradius_hyperrectangle\nlinear_map\ngenerators\ngenmat","category":"page"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/HPolytope/#def_HPolytope","page":"HPolytope","title":"Polytope in constraint representation (HPolytope)","text":"","category":"section"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"Convex polytopes are bounded polyhedra. The type HPolytope represents polytopes. While identical to HPolyhedron in implementation, HPolytope instances are assumed to be bounded.","category":"page"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"HPolytope","category":"page"},{"location":"lib/sets/HPolytope/#LazySets.HPolytope","page":"HPolytope","title":"LazySets.HPolytope","text":"HPolytope{N<:Real, VN<:AbstractVector{N}} <: AbstractPolytope{N}\n\nType that represents a convex polytope in H-representation.\n\nFields\n\nconstraints       – vector of linear constraints\ncheck_boundedness – (optional, default: false) flag for checking if the                        constraints make the polytope bounded; (boundedness is                        a running assumption of this type)\n\nNote\n\nRecall that a polytope is a bounded polyhedron. Boundedness is a running assumption in this type.\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"Some functionality is shared with HPolyhedron. Below follows the additional functionality specific to HPolytope.","category":"page"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"rand(::Type{HPolytope})\nvertices_list(::HPolytope{N}) where {N<:Real}\nisbounded(::HPolytope, ::Bool=true)","category":"page"},{"location":"lib/sets/HPolytope/#Base.rand-Tuple{Type{HPolytope}}","page":"HPolytope","title":"Base.rand","text":"rand(::Type{HPolytope}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nCreate a random polytope in constraint representation.\n\nInput\n\nHPolytope    – type for dispatch\nN            – (optional, default: Float64) numeric type\ndim          – (optional, default: 2) dimension\nrng          – (optional, default: GLOBAL_RNG) random number generator\nseed         – (optional, default: nothing) seed for reseeding\nnum_vertices – (optional, default: -1) upper bound on the number of                   vertices of the polytope (see comment below)\n\nOutput\n\nA random polytope in constraint representation.\n\nAlgorithm\n\nWe create a random polytope in vertex representation and convert it to constraint representation (hence the argument num_vertices). See rand(::Type{VPolytope}).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/#LazySets.vertices_list-Union{Tuple{HPolytope{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"HPolytope","title":"LazySets.vertices_list","text":"vertices_list(P::HPolytope{N};\n              [backend]=nothing, [prune]::Bool=true) where {N<:Real}\n\nReturn the list of vertices of a polytope in constraint representation.\n\nInput\n\nP       – polytope in constraint representation\nbackend – (optional, default: nothing) the polyhedral computations backend\nprune   – (optional, default: true) flag to remove redundant vertices\n\nOutput\n\nList of vertices.\n\nAlgorithm\n\nIf the polytope is two-dimensional, the polytope is converted to a polygon in H-representation and then its vertices_list function is used. This ensures that, by default, the optimized two-dimensional methods are used.\n\nIt is possible to use the Polyhedra backend in two-dimensions as well by passing, e.g. backend=CDDLib.Library().\n\nIf the polytope is not two-dimensional, the concrete polyhedra manipulation library Polyhedra is used. The actual computation is performed by a given backend; for the default backend used in LazySets see default_polyhedra_backend(N). For further information on the supported backends see Polyhedra's documentation.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/HPolytope/#LazySets.isbounded","page":"HPolytope","title":"LazySets.isbounded","text":"isbounded(P::HPolytope, [use_type_assumption]::Bool=true)\n\nDetermine whether a polytope in constraint representation is bounded.\n\nInput\n\nP                   – polytope in constraint representation\nuse_type_assumption – (optional, default: true) flag for ignoring the                          type assumption that polytopes are bounded\n\nOutput\n\ntrue if use_type_assumption is activated. Otherwise, true iff P is bounded.\n\nAlgorithm\n\nIf !use_type_assumption, we convert P to an HPolyhedron P2 and then use isbounded(P2).\n\n\n\n\n\n","category":"function"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/HPolytope/","page":"HPolytope","title":"HPolytope","text":"singleton_list\nisuniversal","category":"page"},{"location":"lib/sets/Hyperplane/","page":"Hyperplane","title":"Hyperplane","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/Hyperplane/#def_Hyperplane","page":"Hyperplane","title":"Hyperplane","text":"","category":"section"},{"location":"lib/sets/Hyperplane/","page":"Hyperplane","title":"Hyperplane","text":"Hyperplane\ndim(::Hyperplane)\nρ(::AbstractVector{N}, ::Hyperplane{N}) where {N<:Real}\nσ(::AbstractVector{N}, ::Hyperplane{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::Hyperplane{N}) where {N<:Real}\nan_element(::Hyperplane{N}) where {N<:Real}\nrand(::Type{Hyperplane})\nisbounded(::Hyperplane)\nisuniversal(::Hyperplane{N}, ::Bool=false) where {N<:Real}\nisempty(::Hyperplane)\nconstrained_dimensions(::Hyperplane{N}) where {N<:Real}\nconstraints_list(::Hyperplane{N}) where {N<:Real}\ntranslate(::Hyperplane{N}, ::AbstractVector{N}) where {N<:Real}","category":"page"},{"location":"lib/sets/Hyperplane/#LazySets.Hyperplane","page":"Hyperplane","title":"LazySets.Hyperplane","text":"Hyperplane{N<:Real, VN<:AbstractVector{N}} <: AbstractPolyhedron{N}\n\nType that represents a hyperplane of the form ax = b.\n\nFields\n\na – normal direction (non-zero)\nb – constraint\n\nExamples\n\nThe plane y = 0:\n\njulia> Hyperplane([0, 1.], 0.)\nHyperplane{Float64,Array{Float64,1}}([0.0, 1.0], 0.0)\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Hyperplane/#LazySets.dim-Tuple{Hyperplane}","page":"Hyperplane","title":"LazySets.dim","text":"dim(hp::Hyperplane)\n\nReturn the dimension of a hyperplane.\n\nInput\n\nhp – hyperplane\n\nOutput\n\nThe ambient dimension of the hyperplane.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Hyperplane{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Hyperplane","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, hp::Hyperplane{N}) where {N<:Real}\n\nEvaluate the support function of a hyperplane in a given direction.\n\nInput\n\nd  – direction\nhp – hyperplane\n\nOutput\n\nThe support function of the hyperplane. If the set is unbounded in the given direction, the result is Inf.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Hyperplane{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Hyperplane","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, hp::Hyperplane{N}) where {N<:Real}\n\nReturn the support vector of a hyperplane.\n\nInput\n\nd  – direction\nhp – hyperplane\n\nOutput\n\nThe support vector in the given direction, which is only defined in the following two cases:\n\nThe direction has norm zero.\nThe direction is the hyperplane's normal direction or its opposite direction.\n\nIn all cases, the result is any point on the hyperplane. Otherwise this function throws an error.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Hyperplane{N,VN} where VN<:AbstractArray{N,1}}} where N<:Real","page":"Hyperplane","title":"Base.:∈","text":"∈(x::AbstractVector{N}, hp::Hyperplane{N}) where {N<:Real}\n\nCheck whether a given point is contained in a hyperplane.\n\nInput\n\nx – point/vector\nhp – hyperplane\n\nOutput\n\ntrue iff x  hp.\n\nAlgorithm\n\nWe just check if x satisfies ax = b.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.an_element-Union{Tuple{Hyperplane{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"Hyperplane","title":"LazySets.an_element","text":"an_element(hp::Hyperplane{N}) where {N<:Real}\n\nReturn some element of a hyperplane.\n\nInput\n\nhp – hyperplane\n\nOutput\n\nAn element on the hyperplane.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#Base.rand-Tuple{Type{Hyperplane}}","page":"Hyperplane","title":"Base.rand","text":"rand(::Type{Hyperplane}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nCreate a random hyperplane.\n\nInput\n\nHyperplane – type for dispatch\nN          – (optional, default: Float64) numeric type\ndim        – (optional, default: 2) dimension\nrng        – (optional, default: GLOBAL_RNG) random number generator\nseed       – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random hyperplane.\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the constraint a is nonzero.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.isbounded-Tuple{Hyperplane}","page":"Hyperplane","title":"LazySets.isbounded","text":"isbounded(hp::Hyperplane)\n\nDetermine whether a hyperplane is bounded.\n\nInput\n\nhp – hyperplane\n\nOutput\n\nfalse.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.isuniversal-Union{Tuple{Hyperplane{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}, Tuple{Hyperplane{N,VN} where VN<:AbstractArray{N,1},Bool}} where N<:Real","page":"Hyperplane","title":"LazySets.isuniversal","text":"isuniversal(hp::Hyperplane{N}, [witness]::Bool=false) where {N<:Real}\n\nCheck whether a hyperplane is universal.\n\nInput\n\nP       – hyperplane\nwitness – (optional, default: false) compute a witness if activated\n\nOutput\n\nIf witness option is deactivated: false\nIf witness option is activated: (false, v) where v  P\n\nAlgorithm\n\nA witness is produced by adding the normal vector to an element on the hyperplane.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#Base.isempty-Tuple{Hyperplane}","page":"Hyperplane","title":"Base.isempty","text":"isempty(hp::Hyperplane)\n\nReturn if a hyperplane is empty or not.\n\nInput\n\nhp – hyperplane\n\nOutput\n\nfalse.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.constrained_dimensions-Union{Tuple{Hyperplane{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"Hyperplane","title":"LazySets.constrained_dimensions","text":"constrained_dimensions(hp::Hyperplane{N}) where {N<:Real}\n\nReturn the indices in which a hyperplane is constrained.\n\nInput\n\nhp – hyperplane\n\nOutput\n\nA vector of ascending indices i such that the hyperplane is constrained in dimension i.\n\nExamples\n\nA 2D hyperplane with constraint x1 = 0 is constrained in dimension 1 only.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.constraints_list-Union{Tuple{Hyperplane{N,VN} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"Hyperplane","title":"LazySets.constraints_list","text":"constraints_list(hp::Hyperplane{N}) where {N<:Real}\n\nReturn the list of constraints of a hyperplane.\n\nInput\n\nhp – hyperplane\n\nOutput\n\nA list containing two half-spaces.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/#LazySets.translate-Union{Tuple{N}, Tuple{Hyperplane{N,VN} where VN<:AbstractArray{N,1},AbstractArray{N,1}}} where N<:Real","page":"Hyperplane","title":"LazySets.translate","text":"translate(hp::Hyperplane{N}, v::AbstractVector{N}; share::Bool=false\n         ) where {N<:Real}\n\nTranslate (i.e., shift) a hyperplane by a given vector.\n\nInput\n\nhp    – hyperplane\nv     – translation vector\nshare – (optional, default: false) flag for sharing unmodified parts of            the original set representation\n\nOutput\n\nA translated hyperplane.\n\nNotes\n\nThe normal vectors of the hyperplane (vector a in a⋅x = b) is shared with the original hyperplane if share == true.\n\nAlgorithm\n\nA hyperplane ax = b is transformed to the hyperplane ax = b + av. In other words, we add the dot product av to b.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperplane/","page":"Hyperplane","title":"Hyperplane","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Hyperplane/","page":"Hyperplane","title":"Hyperplane","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/Hyperrectangle/#def_Hyperrectangle","page":"Hyperrectangle","title":"Hyperrectangle","text":"","category":"section"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"Hyperrectangle\nrand(::Type{Hyperrectangle})\ncenter(::Hyperrectangle{N}) where {N<:Real}\nradius_hyperrectangle(::Hyperrectangle{N}) where {N<:Real}\nradius_hyperrectangle(::Hyperrectangle{N}, ::Int) where {N<:Real}\ntranslate(::Hyperrectangle{N}, ::AbstractVector{N}) where {N<:Real}","category":"page"},{"location":"lib/sets/Hyperrectangle/#LazySets.Hyperrectangle","page":"Hyperrectangle","title":"LazySets.Hyperrectangle","text":"Hyperrectangle{N<:Real, VNC<:AbstractVector{N}, VNR<:AbstractVector{N}\n              } <: AbstractHyperrectangle{N}\n\nType that represents a hyperrectangle.\n\nA hyperrectangle is the Cartesian product of one-dimensional intervals.\n\nFields\n\ncenter – center of the hyperrectangle as a real vector\nradius – radius of the ball as a real vector, i.e., half of its width along             each coordinate direction\n\nExamples\n\nThe Hyperrectangle type stores a vector representing the center and another vector representing the radius. The default constructor Hyperrectangle(c, r) receives the center and radius, in that order. For instance,\n\njulia> c = [-1.0, 1.0];\n\njulia> r = [2.0, 1.0];\n\njulia> H = Hyperrectangle(c, r)\nHyperrectangle{Float64,Array{Float64,1},Array{Float64,1}}([-1.0, 1.0], [2.0, 1.0])\n\nWhich creates the hyperrectangle with vertices:\n\njulia> vertices_list(H)\n4-element Array{Array{Float64,1},1}:\n [1.0, 2.0]\n [-3.0, 2.0]\n [1.0, 0.0]\n [-3.0, 0.0]\n\nThe getter functions for the center and the radius are center and radius_hyperrectangle (since radius corresponds to the radius of the enclosing ball of minimal volume):\n\njulia> center(H)\n2-element Array{Float64,1}:\n -1.0\n  1.0\n\njulia> radius_hyperrectangle(H)\n2-element Array{Float64,1}:\n 2.0\n 1.0\n\nThere is also a constructor from lower and upper bounds with keyword arguments high and low. The following construction results in the same hyperrectangle as in the previous paragraph:\n\njulia> l = [-3.0, 0.0];\n\njulia> h = [1.0, 2.0];\n\njulia> Hyperrectangle(low=l, high=h)\nHyperrectangle{Float64,Array{Float64,1},Array{Float64,1}}([-1.0, 1.0], [2.0, 1.0])\n\nBy default, the constructor checks that that radius of the hyperrecatangle is nonnegative. To supress this check, use the check_bounds optional flag in the constructor. Note that if check_bounds is set to false, the behavior of a set with contradictory bounds is undefined.\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Hyperrectangle/#Base.rand-Tuple{Type{Hyperrectangle}}","page":"Hyperrectangle","title":"Base.rand","text":"rand(::Type{Hyperrectangle}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nCreate a random hyperrectangle.\n\nInput\n\nHyperrectangle – type for dispatch\nN              – (optional, default: Float64) numeric type\ndim            – (optional, default: 2) dimension\nrng            – (optional, default: GLOBAL_RNG) random number generator\nseed           – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random hyperrectangle.\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the radius is nonnegative.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperrectangle/#LazySets.center-Union{Tuple{Hyperrectangle{N,VNC,VNR} where VNR<:AbstractArray{N,1} where VNC<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"Hyperrectangle","title":"LazySets.center","text":"center(H::Hyperrectangle{N}) where {N<:Real}\n\nReturn the center of a hyperrectangle.\n\nInput\n\nH – hyperrectangle\n\nOutput\n\nThe center of the hyperrectangle.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperrectangle/#LazySets.radius_hyperrectangle-Union{Tuple{Hyperrectangle{N,VNC,VNR} where VNR<:AbstractArray{N,1} where VNC<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"Hyperrectangle","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(H::Hyperrectangle{N}) where {N<:Real}\n\nReturn the box radius of a hyperrectangle in every dimension.\n\nInput\n\nH – hyperrectangle\n\nOutput\n\nThe box radius of the hyperrectangle.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperrectangle/#LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{Hyperrectangle{N,VNC,VNR} where VNR<:AbstractArray{N,1} where VNC<:AbstractArray{N,1},Int64}} where N<:Real","page":"Hyperrectangle","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(H::Hyperrectangle{N}, i::Int) where {N<:Real}\n\nReturn the box radius of a hyperrectangle in a given dimension.\n\nInput\n\nH – hyperrectangle\ni – dimension of interest\n\nOutput\n\nThe radius in the given dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperrectangle/#LazySets.translate-Union{Tuple{N}, Tuple{Hyperrectangle{N,VNC,VNR} where VNR<:AbstractArray{N,1} where VNC<:AbstractArray{N,1},AbstractArray{N,1}}} where N<:Real","page":"Hyperrectangle","title":"LazySets.translate","text":"translate(H::Hyperrectangle{N}, v::AbstractVector{N}; share::Bool=false\n         ) where {N<:Real}\n\nTranslate (i.e., shift) a hyperrectangle by a given vector.\n\nInput\n\nH     – hyperrectangle\nv     – translation vector\nshare – (optional, default: false) flag for sharing unmodified parts of            the original set representation\n\nOutput\n\nA translated hyperrectangle.\n\nNotes\n\nThe radius vector is shared with the original hyperrectangle if share == true.\n\nAlgorithm\n\nWe add the vector to the center of the hyperrectangle.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"diameter","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"isbounded\nisuniversal\nsingleton_list","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"dim\nisempty\nan_element","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"ngens\nlinear_map\norder\ntogrep","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"Inherited from AbstractHyperrectangle:","category":"page"},{"location":"lib/sets/Hyperrectangle/","page":"Hyperrectangle","title":"Hyperrectangle","text":"σ\nρ\n∈\nnorm\nradius\nvertices_list\nhigh\nlow\nisflat\ngenerators\ngenmat\nconstraints_list","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/Zonotope/#def_Zonotope","page":"Zonotope","title":"Zonotope","text":"","category":"section"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"Zonotope\ncenter(::Zonotope{N}) where {N<:Real}\nrand(::Type{Zonotope})\ngenerators(Z::Zonotope)\ngenmat(Z::Zonotope)\nscale(::Real, ::Zonotope)\nngens(::Zonotope)\ntogrep(::Zonotope)\nreduce_order(::Zonotope, ::Union{Integer, Rational})\nsplit(::Zonotope, ::Int)\nremove_zero_generators(::Zonotope)","category":"page"},{"location":"lib/sets/Zonotope/#LazySets.Zonotope","page":"Zonotope","title":"LazySets.Zonotope","text":"Zonotope{N<:Real, VN<:AbstractVector{N}, MN<:AbstractMatrix{N}} <: AbstractZonotope{N}\n\nType that represents a zonotope.\n\nFields\n\ncenter     – center of the zonotope\ngenerators – matrix; each column is a generator of the zonotope\n\nNotes\n\nMathematically, a zonotope is defined as the set\n\nZ = left x  mathbbR^n  x = c + _i=1^p ξ_i g_i ξ_i in -1 1  i = 1 p right\n\nwhere c in mathbbR^n is its center and g_i_i=1^p, g_i in mathbbR^n, is the set of generators. This characterization defines a zonotope as the finite Minkowski sum of line segments. Zonotopes can be equivalently described as the image of a unit infinity-norm ball in mathbbR^n by an affine transformation.\n\nZonotopes can be constructed in two different ways: either passing the generators as a matrix, where each column represents a generator, or passing a list of vectors where each vector represents a generator. Below we illustrate both ways.\n\nExamples\n\nA two-dimensional zonotope with given center and set of generators:\n\njulia> Z = Zonotope([1.0, 0.0], [0.1 0.0; 0.0 0.1])\nZonotope{Float64,Array{Float64,1},Array{Float64,2}}([1.0, 0.0], [0.1 0.0; 0.0 0.1])\n\njulia> dim(Z)\n2\n\njulia> center(Z)\n2-element Array{Float64,1}:\n 1.0\n 0.0\n\njulia> genmat(Z)\n2×2 Array{Float64,2}:\n 0.1  0.0\n 0.0  0.1\n\nHere, the first vector in the Zonotope constructor corresponds to the zonotope's center, and each column of the second argument corresponds to a generator. The functions center and genmat return the center and the generator matrix of this zonotope respectively.\n\nWe can collect its vertices using vertices_list:\n\njulia> vertices_list(Z)\n4-element Array{Array{Float64,1},1}:\n [1.1, 0.1]\n [0.9, 0.1]\n [0.9, -0.1]\n [1.1, -0.1]\n\nThe support vector along a given direction can be computed using σ (resp. the support function can be computed using ρ):\n\njulia> σ([1., 1.], Z)\n2-element Array{Float64,1}:\n 1.1\n 0.1\n\nZonotopes admit an alternative constructor that receives a list of vectors, each vector representing a generator:\n\njulia> Z = Zonotope(ones(2), [[1., 0.], [0., 1.], [1., 1.]])\nZonotope{Float64,Array{Float64,1},Array{Float64,2}}([1.0, 1.0], [1.0 0.0 1.0; 0.0 1.0 1.0])\n\njulia> genmat(Z)\n2×3 Array{Float64,2}:\n 1.0  0.0  1.0\n 0.0  1.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Zonotope/#LazySets.center-Union{Tuple{Zonotope{N,VN,MN} where MN<:AbstractArray{N,2} where VN<:AbstractArray{N,1}}, Tuple{N}} where N<:Real","page":"Zonotope","title":"LazySets.center","text":"center(Z::Zonotope{N}) where {N<:Real}\n\nReturn the center of a zonotope.\n\nInput\n\nZ – zonotope\n\nOutput\n\nThe center of the zonotope.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/#Base.rand-Tuple{Type{Zonotope}}","page":"Zonotope","title":"Base.rand","text":"rand(::Type{Zonotope}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nCreate a random zonotope.\n\nInput\n\nZonotope       – type for dispatch\nN              – (optional, default: Float64) numeric type\ndim            – (optional, default: 2) dimension\nrng            – (optional, default: GLOBAL_RNG) random number generator\nseed           – (optional, default: nothing) seed for reseeding\nnum_generators – (optional, default: -1) number of generators of the                     zonotope (see comment below)\n\nOutput\n\nA random zonotope.\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1.\n\nThe number of generators can be controlled with the argument num_generators. For a negative value we choose a random number in the range dim:2*dim (except if dim == 1, in which case we only create a single generator).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/#LazySets.generators-Tuple{Zonotope}","page":"Zonotope","title":"LazySets.generators","text":"generators(Z::Zonotope)\n\nReturn an iterator over the generators of a zonotope.\n\nInput\n\nZ – zonotope\n\nOutput\n\nAn iterator over the generators of Z.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/#LazySets.genmat-Tuple{Zonotope}","page":"Zonotope","title":"LazySets.genmat","text":"genmat(Z::Zonotope)\n\nReturn the generator matrix of a zonotope.\n\nInput\n\nZ – zonotope\n\nOutput\n\nA matrix where each column represents one generator of the zonotope Z.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/#LazySets.scale-Tuple{Real,Zonotope}","page":"Zonotope","title":"LazySets.scale","text":"scale(α::Real, Z::Zonotope)\n\nConcrete scaling of a zonotope.\n\nInput\n\nα – scalar\nZ – zonotope\n\nOutput\n\nThe zonotope obtained by applying the numerical scale to the center and generators of Z.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/#LazySets.ngens-Tuple{Zonotope}","page":"Zonotope","title":"LazySets.ngens","text":"ngens(Z::Zonotope)\n\nReturn the number of generators of a zonotope.\n\nInput\n\nZ – zonotope\n\nOutput\n\nInteger representing the number of generators.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/#LazySets.togrep-Tuple{Zonotope}","page":"Zonotope","title":"LazySets.togrep","text":"togrep(Z::Zonotope)\n\nReturn a generator representation of a zonotope.\n\nInput\n\nZ – zonotopic set\n\nOutput\n\nThe same set Z.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/#LazySets.reduce_order-Tuple{Zonotope,Union{Integer, Rational}}","page":"Zonotope","title":"LazySets.reduce_order","text":"reduce_order(Z::Zonotope, r::Union{Integer, Rational})\n\nReduce the order of a zonotope by overapproximating with a zonotope with less generators.\n\nInput\n\nZ – zonotope\nr – desired order\n\nOutput\n\nA new zonotope with less generators, if possible.\n\nAlgorithm\n\nSee overapproximate(Z::Zonotope{N}, ::Type{<:Zonotope}, r::Union{Integer, Rational}) where {N<:Real} for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/#Base.split-Tuple{Zonotope,Int64}","page":"Zonotope","title":"Base.split","text":"split(Z::Zonotope, j::Int)\n\nReturn two zonotopes obtained by splitting the given zonotope.\n\nInput\n\nZ – zonotope\nj – index of the generator to be split\n\nOutput\n\nThe zonotope obtained by splitting Z into two zonotopes such that their union is Z and their intersection is possibly non-empty.\n\nAlgorithm\n\nThis function implements [Prop. 3, 1], that we state next. The zonotope Z = c g^(1  p) is split into:\n\nZ₁ = c - frac12g^(j) (g^(1 j-1) frac12g^(j) g^(j+1  p)) \nZ₂ = c + frac12g^(j) (g^(1 j-1) frac12g^(j) g^(j+1  p))\n\nsuch that Z₁  Z₂ = Z and Z₁  Z₂ = Z^*, where\n\nZ^* = c (g^(1j-1) g^(j+1 p))\n\n[1] Althoff, M., Stursberg, O., & Buss, M. (2008). Reachability analysis of nonlinear systems with uncertain parameters using conservative linearization. In Proc. of the 47th IEEE Conference on Decision and Control.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/#LazySets.remove_zero_generators-Tuple{Zonotope}","page":"Zonotope","title":"LazySets.remove_zero_generators","text":"remove_zero_generators(Z::Zonotope{N, VN, MN}) where {N<:Real,\n                                                      VN<:AbstractVector{N},\n                                                      MN<:AbstractMatrix{N}}\n\nReturn a new zonotope removing the generators which are zero of the given zonotope.\n\nInput\n\nZ – zonotope\n\nOutput\n\nIf there are no zero generators, the result is the original zonotope Z. Otherwise the result is a new zonotope that has the center and generators as Z except for those generators that are zero.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"norm\nradius\ndiameter","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"isbounded\nisuniversal\nsingleton_list","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"dim\nisempty\nan_element","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/sets/Zonotope/","page":"Zonotope","title":"Zonotope","text":"ρ\nσ\n∈\nlinear_map\ntranslate\nconstraints_list\nconstraints_list\nvertices_list\norder","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"CurrentModule = LazySets","category":"page"},{"location":"lib/sets/Interval/#def_Interval","page":"Interval","title":"Interval","text":"","category":"section"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"Interval\ndim(::Interval)\nσ(::AbstractVector{N}, ::Interval{N}) where {N<:Real}\nρ(::AbstractVector{N}, ::Interval{N}) where {N<:Real}\n∈(::AbstractVector{N}, ::Interval{N}) where {N<:Real}\n∈(::N, ::Interval{N}) where {N<:Real}\nan_element(::Interval{N}) where {N<:Real}\nvertices_list(::Interval{N}) where {N<:Real}\ntranslate(::Interval{N}, ::AbstractVector{N}) where {N<:Real}\ncenter(::Interval{N}) where {N<:Real}\nmin(::Interval{N}) where {N<:Real}\nmax(::Interval{N}) where {N<:Real}\nlow(::Interval{N}) where {N<:Real}\nhigh(::Interval{N}) where {N<:Real}\nradius_hyperrectangle(::Interval{N}) where {N<:Real}\nradius_hyperrectangle(::Interval{N}, ::Int) where {N<:Real}\n-(::Interval{N}, ::Interval{N}) where {N<:Real}\n*(::Interval{N}, ::Interval{N}) where {N<:Real}\nrand(::Type{Interval})\nisflat(::Interval)\nplot_recipe(::Interval{N}, ::N=zero(N)) where {N<:Real}\nlinear_map(::AbstractMatrix{N}, ::Interval{N}) where {N<:Real}\nscale(::N, ::Interval{N}) where {N<:Real}\nconstraints_list(::Interval{N}) where {N<:Real}\ncenter(::Interval{N}, ::Int) where {N<:Real}","category":"page"},{"location":"lib/sets/Interval/#LazySets.Interval","page":"Interval","title":"LazySets.Interval","text":"Interval{N<:Real, IN<:AbstractInterval{N}} <: AbstractHyperrectangle{N}\n\nType representing an interval on the real line. Mathematically, it is of the form\n\na b =  a  x  b   mathbbR\n\nFields\n\ndat – data container for the given interval\n\nNotes\n\nThis type relies on the IntervalArithmetic.jl library for representation of intervals and arithmetic operations.\n\nExamples\n\nUnidimensional intervals are symbolic representations of a real closed interval.\n\nWe can create intervals in different ways, the simpler way is to pass a pair of numbers:\n\njulia> x = Interval(0.0, 1.0)\nInterval{Float64,IntervalArithmetic.Interval{Float64}}([0, 1])\n\nor a 2-vector:\n\njulia> x = Interval([0.0, 1.0])\nInterval{Float64,IntervalArithmetic.Interval{Float64}}([0, 1])\n\nNote that if the package IntervalArithmetic is loaded in the current scope, you have to prepend LazySets. to the Interval type since there is a name conflict otherwise.\n\njulia> using IntervalArithmetic\nWARNING: using IntervalArithmetic.Interval in module Main conflicts with an existing identifier.\n\njulia> x = Interval(IntervalArithmetic.Interval(0.0, 1.0))\nInterval{Float64,IntervalArithmetic.Interval{Float64}}([0, 1])\n\njulia> dim(x)\n1\n\njulia> center(x)\n1-element Array{Float64,1}:\n 0.5\n\nThis type is such that the usual pairwise arithmetic operators +, -, * trigger the corresponding interval arithmetic backend method, and return a new Interval object. For the symbolic Minkowksi sum, use MinkowskiSum or ⊕.\n\nInterval of other numeric types can be created as well, eg. a rational interval:\n\njulia> Interval(0//1, 2//1)\nInterval{Rational{Int64},AbstractInterval{Rational{Int64}}}([0//1, 2//1])\n\n\n\n\n\n","category":"type"},{"location":"lib/sets/Interval/#LazySets.dim-Tuple{Interval}","page":"Interval","title":"LazySets.dim","text":"dim(x::Interval)\n\nReturn the ambient dimension of an interval.\n\nInput\n\nx – interval\n\nOutput\n\nThe integer 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}} where N<:Real","page":"Interval","title":"LazySets.σ","text":"σ(d::AbstractVector{N}, x::Interval{N}) where {N<:Real}\n\nReturn the support vector of an interval in a given direction.\n\nInput\n\nd – direction\nx – interval\n\nOutput\n\nSupport vector in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}} where N<:Real","page":"Interval","title":"LazySets.ρ","text":"ρ(d::AbstractVector{N}, x::Interval{N}) where {N<:Real}\n\nEvaluate the support function of an interval in a given direction.\n\nInput\n\nd – direction\nx – interval\n\nOutput\n\nEvaluation of the support function in the given direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}} where N<:Real","page":"Interval","title":"Base.:∈","text":"∈(v::AbstractVector{N}, x::Interval{N}) where {N<:Real})\n\nReturn whether a vector is contained in the interval.\n\nInput\n\nv – one-dimensional vector\nx – interval\n\nOutput\n\ntrue iff x contains v's first component.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#Base.:∈-Union{Tuple{N}, Tuple{N,Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}} where N<:Real","page":"Interval","title":"Base.:∈","text":"∈(v::N, x::Interval{N}) where {N<:Real}\n\nReturn whether a number is contained in the interval.\n\nInput\n\nv – scalar\nx – interval\n\nOutput\n\ntrue iff x contains v.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.an_element-Union{Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}, Tuple{N}} where N<:Real","page":"Interval","title":"LazySets.an_element","text":"an_element(x::Interval{N}) where {N<:Real}\n\nReturn some element of an interval.\n\nInput\n\nx – interval\n\nOutput\n\nThe left border (min(x)) of the interval.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.vertices_list-Union{Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}, Tuple{N}} where N<:Real","page":"Interval","title":"LazySets.vertices_list","text":"vertices_list(x::Interval{N}) where {N<:Real}\n\nReturn the list of vertices of this interval.\n\nInput\n\nx – interval\n\nOutput\n\nThe list of vertices of the interval represented as two one-dimensional vectors.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.translate-Union{Tuple{N}, Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N},AbstractArray{N,1}}} where N<:Real","page":"Interval","title":"LazySets.translate","text":"translate(x::Interval{N}, v::AbstractVector{N}) where {N<:Real}\n\nTranslate (i.e., shift) an interval by a given vector.\n\nInput\n\nx – interval\nv – translation vector\n\nOutput\n\nA translated interval.\n\nAlgorithm\n\nWe add the vector to the left and right of the interval.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.center-Union{Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}, Tuple{N}} where N<:Real","page":"Interval","title":"LazySets.center","text":"center(x::Interval{N}) where {N<:Real}\n\nReturn the interval's center.\n\nInput\n\nx – interval\n\nOutput\n\nThe center, or midpoint, of x.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#Base.min-Union{Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}, Tuple{N}} where N<:Real","page":"Interval","title":"Base.min","text":"min(x::Interval{N}) where {N<:Real}\n\nReturn the lower component of an interval.\n\nInput\n\nx – interval\n\nOutput\n\nThe lower (lo) component of the interval.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#Base.max-Union{Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}, Tuple{N}} where N<:Real","page":"Interval","title":"Base.max","text":"max(x::Interval{N}) where {N<:Real}\n\nReturn the higher or upper component of an interval.\n\nInput\n\nx – interval\n\nOutput\n\nThe higher (hi) component of the interval.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.low-Union{Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}, Tuple{N}} where N<:Real","page":"Interval","title":"LazySets.low","text":"low(x::Interval{N}) where {N<:Real}\n\nReturn the lower coordinate of an interval set.\n\nInput\n\nx – interval\n\nOutput\n\nA vector with the lower coordinate of the interval.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.high-Union{Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}, Tuple{N}} where N<:Real","page":"Interval","title":"LazySets.high","text":"high(x::Interval{N}) where {N<:Real}\n\nReturn the higher coordinate of an interval set.\n\nInput\n\nx – interval\n\nOutput\n\nA vector with the higher coordinate of the interval.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.radius_hyperrectangle-Union{Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}, Tuple{N}} where N<:Real","page":"Interval","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(x::Interval{N}) where {N<:Real}\n\nReturn the box radius of an interval in every dimension.\n\nInput\n\nx – interval\n\nOutput\n\nThe box radius of the interval (a one-dimensional vector).\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N},Int64}} where N<:Real","page":"Interval","title":"LazySets.radius_hyperrectangle","text":"radius_hyperrectangle(x::Interval{N}, i::Int) where {N<:Real}\n\nReturn the box radius of an interval in a given dimension.\n\nInput\n\nx – interval\ni – dimension index (must be 1)\n\nOutput\n\nThe box radius in the given dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#Base.:--Union{Tuple{N}, Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N},Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}} where N<:Real","page":"Interval","title":"Base.:-","text":"-(x::Interval{N}, y::Interval{N}) where {N<:Real}\n\nReturn the difference of the intervals.\n\nInput\n\nx – interval\ny – interval\n\nOutput\n\nThe difference of the intervals as a new Interval set.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#Base.:*-Union{Tuple{N}, Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N},Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}} where N<:Real","page":"Interval","title":"Base.:*","text":"    *(x::Interval{N}, y::Interval{N}) where {N<:Real}\n\nReturn the product of the intervals.\n\nInput\n\nx – interval\ny – interval\n\nOutput\n\nThe product of the intervals as a new Interval set.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#Base.rand-Tuple{Type{Interval}}","page":"Interval","title":"Base.rand","text":"rand(::Type{Interval}; [N]::Type{<:Real}=Float64, [dim]::Int=2,\n     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing)\n\nCreate a random interval.\n\nInput\n\nInterval – type for dispatch\nN        – (optional, default: Float64) numeric type\ndim      – (optional, default: 1) dimension\nrng      – (optional, default: GLOBAL_RNG) random number generator\nseed     – (optional, default: nothing) seed for reseeding\n\nOutput\n\nA random interval.\n\nAlgorithm\n\nAll numbers are normally distributed with mean 0 and standard deviation 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.isflat-Tuple{Interval}","page":"Interval","title":"LazySets.isflat","text":"isflat(I::Interval)\n\nDetermine whether an interval is flat, i.e. whether its extreme values coincide.\n\nInput\n\nI – interval\n\nOutput\n\nA boolean which is true if the interval is flat and false otherwise.\n\nNotes\n\nFor robustness with respect to floating-point inputs, this function relies on the result of isapproxzero when applied to the diameter of the interval. Hence, this function depends on the absolute zero tolerance ABSZTOL.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.plot_recipe-Union{Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}, Tuple{N}, Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N},N}} where N<:Real","page":"Interval","title":"LazySets.plot_recipe","text":"plot_recipe(I::Interval{N}, [ε]::N=zero(N)) where {N<:Real}\n\nConvert an interval to a pair (x, y) of points for plotting.\n\nInput\n\nI – interval\nε – (optional, default: 0) ignored, used for dispatch\n\nOutput\n\nA pair (x, y) of two points that can be plotted.\n\nNotes\n\nWe consider the interval as a line segment with y coordinate equal to zero.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}} where N<:Real","page":"Interval","title":"LazySets.linear_map","text":"linear_map(M::AbstractMatrix{N}, x::Interval{N}) where {N<:Real}\n\nConcrete linear map of an interval.\n\nInput\n\nM – matrix\nx – interval\n\nOutput\n\nEither an interval or a zonotope, depending on the leading dimension (i.e. the number of rows) of M:\n\nIf size(M, 1) == 1, the output is an interval obtained by scaling x by the matrix M.\nIf size(M, 1) > 1, the output is a zonotope whose center is M * center(x) and it has the single generator, M * g, where g = (high(x)-low(x))/2.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.scale-Union{Tuple{N}, Tuple{N,Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}} where N<:Real","page":"Interval","title":"LazySets.scale","text":"scale(α::N, x::Interval{N}) where {N<:Real}\n\nConcrete scaling of an interval.\n\nInput\n\nα – scalar\nx – interval\n\nOutput\n\nThe interval obtained by applying the numerical scale to the given interval.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.constraints_list-Union{Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N}}, Tuple{N}} where N<:Real","page":"Interval","title":"LazySets.constraints_list","text":"constraints_list(x::Interval{N}) where {N<:Real}\n\nReturn the list of constraints of the given interval.\n\nInput\n\nx – interval\n\nOutput\n\nThe list of constraints of the interval represented as two one-dimensional half-spaces.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/#LazySets.center-Union{Tuple{N}, Tuple{Interval{N,IN} where IN<:IntervalArithmetic.AbstractInterval{N},Int64}} where N<:Real","page":"Interval","title":"LazySets.center","text":"center(H::Interval{N}, i::Int) where {N<:Real}\n\nReturn the center along a given dimension of a interval.\n\nInput\n\nx – interval\ni – dimension of interest\n\nOutput\n\nThe center along a given dimension of the interval.\n\n\n\n\n\n","category":"method"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"Inherited from LazySet:","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"diameter","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"Inherited from AbstractPolytope:","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"isbounded\nisuniversal\nsingleton_list","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"Inherited from AbstractCentrallySymmetricPolytope:","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"isempty","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"Inherited from AbstractZonotope:","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"ngens\norder\ntogrep","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"Inherited from AbstractHyperrectangle:","category":"page"},{"location":"lib/sets/Interval/","page":"Interval","title":"Interval","text":"norm\nradius\ngenerators\ngenmat","category":"page"}]
}
