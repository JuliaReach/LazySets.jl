<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conversions between set representations · LazySets.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">LazySets.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../man/set_operations/">Operations on Sets</a></li><li><a class="tocitem" href="../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../sets/Line/">Line</a></li><li><a class="tocitem" href="../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../sets/PolynomialZonotope/">PolynomialZonotope</a></li><li><a class="tocitem" href="../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../sets/Zonotope/">Zonotope</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lazy_operations/AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../lazy_operations/Bloating/">Bloating</a></li><li><a class="tocitem" href="../lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../lazy_operations/Complement/">Complement</a></li><li><a class="tocitem" href="../lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../lazy_operations/Intersection/">Intersection</a></li><li><a class="tocitem" href="../lazy_operations/LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../lazy_operations/Rectification/">Rectification</a></li><li><a class="tocitem" href="../lazy_operations/ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../lazy_operations/Translation/">Translation</a></li><li><a class="tocitem" href="../lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><a class="tocitem" href="../binary_functions/">Concrete Operations</a></li><li class="is-active"><a class="tocitem" href>Conversions between set representations</a></li><li><a class="tocitem" href="../comparisons/">Comparisons</a></li><li><a class="tocitem" href="../approximations/">Approximations</a></li><li><a class="tocitem" href="../utils/">Utility Functions</a></li><li><a class="tocitem" href="../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Conversions between set representations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Conversions between set representations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/conversion.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Conversion-between-set-representations"><a class="docs-heading-anchor" href="#Conversion-between-set-representations">Conversion between set representations</a><a id="Conversion-between-set-representations-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-between-set-representations" title="Permalink"></a></h1><p>This section of the manual lists the conversion functions between set representations.</p><ul><li><a href="#Conversion-between-set-representations">Conversion between set representations</a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON2}, Tuple{HPOLYGON1}, Tuple{Type{HPOLYGON1},HPOLYGON2}} where HPOLYGON2&lt;:AbstractHPolygon where HPOLYGON1&lt;:AbstractHPolygon" href="#Base.convert-Union{Tuple{HPOLYGON2}, Tuple{HPOLYGON1}, Tuple{Type{HPOLYGON1},HPOLYGON2}} where HPOLYGON2&lt;:AbstractHPolygon where HPOLYGON1&lt;:AbstractHPolygon"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{HPOLYGON1},
        P::HPOLYGON2) where {HPOLYGON1&lt;:AbstractHPolygon,
                             HPOLYGON2&lt;:AbstractHPolygon}</code></pre><p>Convert between polygon types in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polygon</li></ul><p><strong>Output</strong></p><p>The polygon represented as the target type.</p><p><strong>Notes</strong></p><p>We need the <code>Union</code> type for <code>HPOLYGON1</code> because the target type must be concrete.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L12-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON},VPolygon}} where HPOLYGON&lt;:AbstractHPolygon" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON},VPolygon}} where HPOLYGON&lt;:AbstractHPolygon"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(T::Type{HPOLYGON}, P::VPolygon) where {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Converts a polygon in vertex representation to a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPOLYGON</code> – type used for dispatch</li><li><code>P</code>        – polygon in vertex representation</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L42-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{Hyperrectangle},AbstractHyperrectangle}" href="#Base.convert-Tuple{Type{Hyperrectangle},AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Hyperrectangle}, H::AbstractHyperrectangle)</code></pre><p>Convert a hyperrectangular set to a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – hyperrectangle type, used for dispatch</li><li><code>H</code>              – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; convert(Hyperrectangle, Interval(0.0, 1.0))
Hyperrectangle{Float64,Array{Float64,1},Array{Float64,1}}([0.5], [0.5])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L571-L591">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{Interval},AbstractHyperrectangle}" href="#Base.convert-Tuple{Type{Interval},AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Interval}, H::AbstractHyperrectangle)</code></pre><p>Converts a hyperrectangular set to an interval.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – interval type, used for dispatch</li><li><code>H</code>        – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>An interval.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; convert(Interval, Hyperrectangle([0.5], [0.5]))
Interval{Float64,IntervalArithmetic.Interval{Float64}}([0, 1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L596-L616">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{Interval},LazySet{N}}} where N&lt;:Real" href="#Base.convert-Union{Tuple{N}, Tuple{Type{Interval},LazySet{N}}} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Interval}, S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Converts a convex set to an interval.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – interval type, used for dispatch</li><li><code>S</code>        – convex set</li></ul><p><strong>Output</strong></p><p>An interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L622-L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProductArray{N,HN}}} where HN&lt;:AbstractHyperrectangle{N} where N&lt;:Real" href="#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProductArray{N,HN}}} where HN&lt;:AbstractHyperrectangle{N} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Hyperrectangle},
        cpa::CartesianProductArray{N, HN}) where {N&lt;:Real, HN&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the cartesian product of a finite number of hyperrectangular sets to a single hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>S</code>              – cartesian product array of hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>This implementation uses the <code>center</code> and <code>radius_hyperrectangle</code> methods of <code>AbstractHyperrectangle</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L641-L661">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProductArray{N,Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}}}} where N&lt;:Real" href="#Base.convert-Union{Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProductArray{N,Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}}}} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Hyperrectangle},
        cpa::CartesianProductArray{N, Interval{N}}) where {N&lt;:Real}</code></pre><p>Converts the cartesian product of a finite number of intervals to a single hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>S</code>              – cartesian product array of intervals</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>This implementation uses the <code>min</code> and <code>max</code> methods of <code>Interval</code> to reduce the allocatons and improve performance (see LazySets#1143).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L706-L726">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON},AbstractHyperrectangle}} where HPOLYGON&lt;:AbstractHPolygon" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{Type{HPOLYGON},AbstractHyperrectangle}} where HPOLYGON&lt;:AbstractHPolygon"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{HPOLYGON}, H::AbstractHyperrectangle) where
    {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Converts a hyperrectangular set to a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPOLYGON</code>  – type used for dispatch</li><li><code>H</code>         – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L838-L852">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{VN}, Tuple{N}, Tuple{Type{HPOLYGON},HPolytope{N,VN}}} where HPOLYGON&lt;:AbstractHPolygon where VN&lt;:AbstractArray{N,1} where N&lt;:Real" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{VN}, Tuple{N}, Tuple{Type{HPOLYGON},HPolytope{N,VN}}} where HPOLYGON&lt;:AbstractHPolygon where VN&lt;:AbstractArray{N,1} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{HPOLYGON}, P::HPolytope{N, VN};
        prune::Bool=true) where {N&lt;:Real, VN&lt;:AbstractVector{N}, HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Convert from 2D polytope in H-representation to polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code>  – target type</li><li><code>P</code>     – source polytope (must be 2D)</li><li><code>prune</code> – (optional, default: <code>true</code>) flag for removing redundant            constraints in the end</li></ul><p><strong>Output</strong></p><p>The 2D polytope represented as polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L243-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON},AbstractSingleton{N}}} where HPOLYGON&lt;:AbstractHPolygon where N&lt;:Real" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON},AbstractSingleton{N}}} where HPOLYGON&lt;:AbstractHPolygon where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{HPOLYGON}, S::AbstractSingleton{N}
       ) where {N&lt;:Real, HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Convert from singleton to polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>S</code>    – singleton</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation with the minimal number of constraints (three).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L513-L528">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON},LineSegment{N,VN} where VN&lt;:AbstractArray{N,1}}} where HPOLYGON&lt;:AbstractHPolygon where N&lt;:Real" href="#Base.convert-Union{Tuple{HPOLYGON}, Tuple{N}, Tuple{Type{HPOLYGON},LineSegment{N,VN} where VN&lt;:AbstractArray{N,1}}} where HPOLYGON&lt;:AbstractHPolygon where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{HPOLYGON}, L::LineSegment{N}
      ) where {N&lt;:Real, HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Convert from line segment to polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code>  – target type</li><li><code>L</code>     – line segment</li><li><code>prune</code> – (optional, default: <code>false</code>) flag for removing redundant            constraints in the end</li></ul><p><strong>Output</strong></p><p>A flat polygon in constraint representation with the minimal number of constraints (four).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L541-L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolyhedron},AbstractPolytope}" href="#Base.convert-Tuple{Type{HPolyhedron},AbstractPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{HPolyhedron}, P::AbstractPolytope)</code></pre><p>Convert a polytopic set to a polyhedron in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The given polytope represented as a polyhedron in constraint representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L181-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolytope},AbstractHPolygon}" href="#Base.convert-Tuple{Type{HPolytope},AbstractHPolygon}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{HPolytope}, P::AbstractHPolygon)</code></pre><p>Convert from polygon in H-representation to polytope in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polygon</li></ul><p><strong>Output</strong></p><p>The polygon represented as 2D polytope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L78-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolytope},AbstractHyperrectangle}" href="#Base.convert-Tuple{Type{HPolytope},AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{HPolytope}, H::AbstractHyperrectangle)</code></pre><p>Converts a hyperrectangular set to a polytope in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPolytope</code> – type used for dispatch</li><li><code>H</code>         – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A polytope in constraint representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L819-L832">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolytope},AbstractPolytope}" href="#Base.convert-Tuple{Type{HPolytope},AbstractPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{HPolytope}, P::AbstractPolytope)</code></pre><p>Convert a polytopic set to a polytope in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The given polytope represented as a polytope in constraint representation.</p><p><strong>Algorithm</strong></p><p>First the list of constraints of <code>P</code> is computed, then the corresponding <code>HPolytope</code> is created.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L158-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{HPolytope},VPolytope}" href="#Base.convert-Tuple{Type{HPolytope},VPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{HPolytope}, P::VPolytope)</code></pre><p>Convert from polytope in V-representation to polytope in H-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The polytope in the dual representation.</p><p><strong>Algorithm</strong></p><p>The <code>tohrep</code> function is invoked. It requires the <code>Polyhedra</code> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L199-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolygon},AbstractHPolygon}" href="#Base.convert-Tuple{Type{VPolygon},AbstractHPolygon}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{VPolygon}, P::AbstractHPolygon)</code></pre><p>Converts a polygon in constraint representation to a polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>VPolygon</code> – type used for dispatch</li><li><code>P</code>        – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>A polygon in vertex representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L60-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolygon},AbstractPolytope}" href="#Base.convert-Tuple{Type{VPolygon},AbstractPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{VPolygon}, P::AbstractPolytope)</code></pre><p>Convert polytopic set to polygon in V-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The 2D polytope represented as a polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L114-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolytope},AbstractPolytope}" href="#Base.convert-Tuple{Type{VPolytope},AbstractPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{VPolytope}, P::AbstractPolytope)</code></pre><p>Convert polytopic type to polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The set <code>P</code> represented as a <code>VPolytope</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L96-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolytope},HPolytope}" href="#Base.convert-Tuple{Type{VPolytope},HPolytope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{VPolytope}, P::HPolytope)</code></pre><p>Convert from polytope in H-representation to polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>P</code>    – source polytope</li></ul><p><strong>Output</strong></p><p>The polytope in the dual representation.</p><p><strong>Algorithm</strong></p><p>The <code>tovrep</code> function is invoked. It requires the <code>Polyhedra</code> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L221-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{Zonotope},AbstractHyperrectangle{N}}} where N" href="#Base.convert-Union{Tuple{N}, Tuple{Type{Zonotope},AbstractHyperrectangle{N}}} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Zonotope}, H::AbstractHyperrectangle)</code></pre><p>Converts a hyperrectangular set to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>H</code>        – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L269-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{Zonotope},AbstractZonotope}" href="#Base.convert-Tuple{Type{Zonotope},AbstractZonotope}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Zonotope}, Z::AbstractZonotope)</code></pre><p>Converts a zonotopic set to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>H</code>        – zonotopic set</li></ul><p><strong>Output</strong></p><p>A zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L368-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{IntervalArithmetic.IntervalBox},AbstractHyperrectangle}" href="#Base.convert-Tuple{Type{IntervalArithmetic.IntervalBox},AbstractHyperrectangle}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{IntervalArithmetic.IntervalBox}, H::AbstractHyperrectangle)</code></pre><p>Converts a hyperrectangular set to an <code>IntervalBox</code> from <code>IntervalArithmetic</code>.</p><p><strong>Input</strong></p><ul><li><code>IntervalBox</code> – type used for dispatch</li><li><code>H</code>           – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>An <code>IntervalBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L896-L909">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{Hyperrectangle},IntervalArithmetic.IntervalBox}" href="#Base.convert-Tuple{Type{Hyperrectangle},IntervalArithmetic.IntervalBox}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Hyperrectangle}, IB::IntervalArithmetic.IntervalBox)</code></pre><p>Converts an <code>IntervalBox</code> from <code>IntervalArithmetic</code> to a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>IB</code>             – interval box</li></ul><p><strong>Output</strong></p><p>A <code>Hyperrectangle</code>.</p><p><strong>Notes</strong></p><p><code>IntervalArithmetic.IntervalBox</code> uses <em>static</em> vectors to store each component interval, hence the resulting <code>Hyperrectangle</code> has its center and radius represented as a static vector (<code>SArray</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L914-L933">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{ZN2}, Tuple{ZN1}, Tuple{N}, Tuple{Type{Zonotope},CartesianProduct{N,ZN1,ZN2}}} where ZN2&lt;:AbstractZonotope{N} where ZN1&lt;:AbstractZonotope{N} where N&lt;:Real" href="#Base.convert-Union{Tuple{ZN2}, Tuple{ZN1}, Tuple{N}, Tuple{Type{Zonotope},CartesianProduct{N,ZN1,ZN2}}} where ZN2&lt;:AbstractZonotope{N} where ZN1&lt;:AbstractZonotope{N} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Zonotope}, cp::CartesianProduct{N, ZN1, ZN2}
       ) where {N&lt;:Real, ZN1&lt;:AbstractZonotope{N}, ZN2&lt;:AbstractZonotope{N}}</code></pre><p>Converts the cartesian product of two zonotopes to a new zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type used for dispatch</li><li><code>S</code>        – cartesian product of two zonotopes</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>The cartesian product is obtained by:</p><ul><li>Concatenating the centers of each input zonotope.</li><li>Arranging the generators in block-diagional fashion, and filled with zeros in the off-diagonal; for this reason, the generator matrix of the returned zonotope is built as a sparse matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L787-L810">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProduct{N,HN1,HN2}}} where HN2&lt;:AbstractHyperrectangle{N} where HN1&lt;:AbstractHyperrectangle{N} where N&lt;:Real" href="#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Hyperrectangle},CartesianProduct{N,HN1,HN2}}} where HN2&lt;:AbstractHyperrectangle{N} where HN1&lt;:AbstractHyperrectangle{N} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Hyperrectangle},
        cp::CartesianProduct{N, HN1, HN2}) where {N&lt;:Real, HN1&lt;:AbstractHyperrectangle{N}, HN2&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the cartesian product of two hyperrectangular sets to a single hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>S</code>              – cartesian product of two hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>The result is obtained by concatenating the center and radius of each hyperrectangle. This implementation uses the <code>center</code> and <code>radius_hyperrectangle</code> methods of <code>AbstractHyperrectangle</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L677-L697">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope},CartesianProduct{N,HN1,HN2}}} where HN2&lt;:AbstractHyperrectangle{N} where HN1&lt;:AbstractHyperrectangle{N} where N&lt;:Real" href="#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope},CartesianProduct{N,HN1,HN2}}} where HN2&lt;:AbstractHyperrectangle{N} where HN1&lt;:AbstractHyperrectangle{N} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Zonotope}, cp::CartesianProduct{N, HN1, HN2}) where {N&lt;:Real,
    HN1&lt;:AbstractHyperrectangle{N}, HN2&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the cartesian product of two hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>cp</code>       – cartesian product of two hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>This method falls back to the conversion of the cartesian product to a single hyperrectangle, and then from a hyperrectangle to a zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L386-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope},CartesianProductArray{N,HN}}} where HN&lt;:AbstractHyperrectangle{N} where N&lt;:Real" href="#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope},CartesianProductArray{N,HN}}} where HN&lt;:AbstractHyperrectangle{N} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Zonotope}, cpa::CartesianProductArray{N, HN})
    where {N&lt;:Real, HN&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the cartesian product array of hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>cpa</code>      – cartesian product array of hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method falls back to the conversion of the cartesian product to a single hyperrectangle, and then from a hyperrectangle to a zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L408-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{ZN}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,ZN,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM}} where ZN&lt;:AbstractZonotope{N} where N" href="#Base.convert-Union{Tuple{ZN}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,ZN,NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM}} where ZN&lt;:AbstractZonotope{N} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Zonotope}, S::LinearMap{N, ZN}
       ) where {N, ZN&lt;:AbstractZonotope{N}}</code></pre><p>Converts the lazy linear map of a zonotopic set to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>S</code>        – linear map of a zonotopic set</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method first applies the (concrete) linear map to the zonotopic set and then converts the result to a <code>Zonotope</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L433-L452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,CartesianProduct{N,HN1,HN2},NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM}} where HN2&lt;:AbstractHyperrectangle{N} where HN1&lt;:AbstractHyperrectangle{N} where N" href="#Base.convert-Union{Tuple{HN2}, Tuple{HN1}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,CartesianProduct{N,HN1,HN2},NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM}} where HN2&lt;:AbstractHyperrectangle{N} where HN1&lt;:AbstractHyperrectangle{N} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Zonotope}, S::LinearMap{N, CartesianProduct{N, HN1, HN2}}
       ) where {N, HN1&lt;:AbstractHyperrectangle{N},
                HN2&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the lazy linear map of the cartesian product of two hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>S</code>        – linear map of the cartesian product of hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method first converts the cartesian product to a zonotope, and then applies the (concrete) linear map to the zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L458-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,CartesianProductArray{N,HN},NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM}} where HN&lt;:AbstractHyperrectangle{N} where N" href="#Base.convert-Union{Tuple{HN}, Tuple{N}, Tuple{Type{Zonotope},LinearMap{N,CartesianProductArray{N,HN},NM,MAT} where MAT&lt;:AbstractArray{NM,2} where NM}} where HN&lt;:AbstractHyperrectangle{N} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Zonotope},S::LinearMap{N, CartesianProductArray{N, HN}}
       ) where {N, HN&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts the lazy linear map of the cartesian product of a finite number of hyperrectangular sets to a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type, used for dispatch</li><li><code>S</code>        – linear map of a <code>CartesianProductArray</code> of hyperrectangular sets</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Algorithm</strong></p><p>This method first converts the cartesian product array to a zonotope, and then applies the (concrete) linear map to the zonotope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L487-L507">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProduct{N,Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N},Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}}},AbstractHyperrectangle{N}}} where N&lt;:Real" href="#Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProduct{N,Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N},Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}}},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{CartesianProduct{N, Interval{N}, Interval{N}}},
        H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Converts a two-dimensional hyperrectangle to the cartesian product of two intervals.</p><p><strong>Input</strong></p><ul><li><code>CartesianProduct</code> – type used for dispatch</li><li><code>H</code>                – hyperrectangle</li></ul><p><strong>Output</strong></p><p>The cartesian product of two intervals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L740-L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProductArray{N,Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}}},AbstractHyperrectangle{N}}} where N&lt;:Real" href="#Base.convert-Union{Tuple{N}, Tuple{Type{CartesianProductArray{N,Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}}},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{CartesianProductArray{N, Interval{N}}},
        H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Converts a hyperrectangle to the cartesian product array of intervals.</p><p><strong>Input</strong></p><ul><li><code>CartesianProductArray</code> – type used for dispatch</li><li><code>H</code>                     – hyperrectangle</li></ul><p><strong>Output</strong></p><p>The cartesian product of a finite number of intervals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L766-L780">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{AH}, Tuple{N}, Tuple{Type{Hyperrectangle},Rectification{N,AH}}} where AH&lt;:AbstractHyperrectangle{N} where N&lt;:Real" href="#Base.convert-Union{Tuple{AH}, Tuple{N}, Tuple{Type{Hyperrectangle},Rectification{N,AH}}} where AH&lt;:AbstractHyperrectangle{N} where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Hyperrectangle}, r::Rectification{N, AH})
    where {N&lt;:Real, AH&lt;:AbstractHyperrectangle{N}}</code></pre><p>Converts a rectification of a hyperrectangle to a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type used for dispatch</li><li><code>r</code>              – rectification of a hyperrectangle</li></ul><p><strong>Output</strong></p><p>A <code>Hyperrectangle</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L940-L954">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{IN}, Tuple{N}, Tuple{Type{Interval},Rectification{N,IN}}} where IN&lt;:(Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}) where N&lt;:Real" href="#Base.convert-Union{Tuple{IN}, Tuple{N}, Tuple{Type{Interval},Rectification{N,IN}}} where IN&lt;:(Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}) where N&lt;:Real"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Interval},
        r::Rectification{N, IN}) where {N&lt;:Real, IN&lt;:Interval{N}}</code></pre><p>Converts a rectification of an interval to an interval.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – type used for dispatch</li><li><code>r</code>        – rectification of an interval</li></ul><p><strong>Output</strong></p><p>An <code>Interval</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L961-L975">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{IntervalArithmetic.Interval},Interval}" href="#Base.convert-Tuple{Type{IntervalArithmetic.Interval},Interval}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{IntervalArithmetic.Interval}, x::Interval)</code></pre><p>Converts a <code>LazySets</code> interval to an <code>Interval</code> from <code>IntervalArithmetic</code>.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – type used for dispatch, from <code>IntervalArithmetic</code></li><li><code>x</code>        – interval (<code>LazySets.Interval</code>)</li></ul><p><strong>Output</strong></p><p>An <code>IntervalArithmetic.Interval</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L860-L873">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{Interval},IntervalArithmetic.Interval}" href="#Base.convert-Tuple{Type{Interval},IntervalArithmetic.Interval}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Interval}, x::IntervalArithmetic.Interval)</code></pre><p>Converts an <code>Interval</code> from <code>IntervalArithmetic</code> to an interval in <code>LazySets</code>.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – type used for dispatch</li><li><code>x</code>        – interval (<code>IntervalArithmetic.Interval</code>)</li></ul><p><strong>Output</strong></p><p>A <code>LazySets.Interval</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L878-L891">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{VT}, Tuple{N}, Tuple{Type{VPolytope},ConvexHullArray{N,Singleton{N,VT}}}} where VT where N" href="#Base.convert-Union{Tuple{VT}, Tuple{N}, Tuple{Type{VPolytope},ConvexHullArray{N,Singleton{N,VT}}}} where VT where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{VPolytope},
        X::ConvexHullArray{N, Singleton{N, VT}}) where {N, VT}</code></pre><p>Converts the convex hull array of singletons to a polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><code>VPolytope</code> – type used for dispatch</li><li><code>X</code>         – convex hull array of singletons</li></ul><p><strong>Output</strong></p><p>A polytope in vertex representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L981-L995">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{VT}, Tuple{N}, Tuple{Type{VPolygon},ConvexHullArray{N,Singleton{N,VT}}}} where VT where N" href="#Base.convert-Union{Tuple{VT}, Tuple{N}, Tuple{Type{VPolygon},ConvexHullArray{N,Singleton{N,VT}}}} where VT where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{VPolygon},
        X::ConvexHullArray{N, Singleton{N, VT}}) where {N, VT}</code></pre><p>Converts the convex hull array of singletons to a polygon in V-representation.</p><p><strong>Input</strong></p><ul><li><code>VPolygon</code>  – type used for dispatch</li><li><code>X</code>         – convex hull array of singletons</li></ul><p><strong>Output</strong></p><p>A polygon in vertex representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L1001-L1015">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{VPolygon},LazySet}" href="#Base.convert-Tuple{Type{VPolygon},LazySet}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{VPolygon}, X::LazySet)</code></pre><p>Generic conversion to polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>type</code> – target type</li><li><code>X</code>    – set</li></ul><p><strong>Output</strong></p><p>The 2D set represented as a polygon.</p><p><strong>Algorithm</strong></p><p>We compute the list of vertices of <code>X</code> and wrap the result in a polygon in vertex representation, which guarantees that the vertices are sorted in counter-clockwise fashion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L133-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{ST}, Tuple{N}, Tuple{Type{MinkowskiSumArray},MinkowskiSum{N,ST,MinkowskiSumArray{N,ST}}}} where ST where N" href="#Base.convert-Union{Tuple{ST}, Tuple{N}, Tuple{Type{MinkowskiSumArray},MinkowskiSum{N,ST,MinkowskiSumArray{N,ST}}}} where ST where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{MinkowskiSumArray},
        X::MinkowskiSum{N, ST, MinkowskiSumArray{N, ST}}) where {N, ST}</code></pre><p>Converts the Minkowski sum of a Minkowski sum array to a Minkowski sum array.</p><p><strong>Input</strong></p><ul><li><code>MinkowskiSumArray</code>  – type used for dispatch</li><li><code>X</code>                  – Minkowski sum of a Minkowski sum array</li></ul><p><strong>Output</strong></p><p>A Minkowski sum array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L1022-L1036">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{IT}, Tuple{N}, Tuple{Type{Interval},MinkowskiSum{N,IT,IT}}} where IT&lt;:(Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}) where N" href="#Base.convert-Union{Tuple{IT}, Tuple{N}, Tuple{Type{Interval},MinkowskiSum{N,IT,IT}}} where IT&lt;:(Interval{N,IN} where IN&lt;:IntervalArithmetic.AbstractInterval{N}) where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Interval}, x::MinkowskiSum{N, IT, IT}) where {N, IT&lt;:Interval{N}}</code></pre><p>Converts the Minkowski sum of two intervals into an interval.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – type used for dispatch</li><li><code>x</code>        – Minkowski sum of a pair of intervals</li></ul><p><strong>Output</strong></p><p>An interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L1042-L1055">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{HParallelotope},AbstractZonotope{N}}} where N" href="#Base.convert-Union{Tuple{N}, Tuple{Type{HParallelotope},AbstractZonotope{N}}} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{HParallelotope}, Z::AbstractZonotope{N}) where {N}</code></pre><p>Converts a zonotopic set of order one into a parallelotope in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HParallelotope</code> – type used for dispatch</li><li><code>Z</code>              – zonotopic set</li></ul><p><strong>Output</strong></p><p>A parallelotope in constraint representation.</p><p><strong>Notes</strong></p><p>This function requires that the list of constraints of <code>Z</code> are obtained in the particular order returned from the constraints list function of a <code>Zonotope</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L1071-L1090">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{AZ2}, Tuple{AZ1}, Tuple{N}, Tuple{Type{Zonotope},CartesianProduct{N,AZ1,AZ2}}} where AZ2&lt;:AbstractZonotope{N} where AZ1&lt;:AbstractZonotope{N} where N" href="#Base.convert-Union{Tuple{AZ2}, Tuple{AZ1}, Tuple{N}, Tuple{Type{Zonotope},CartesianProduct{N,AZ1,AZ2}}} where AZ2&lt;:AbstractZonotope{N} where AZ1&lt;:AbstractZonotope{N} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Zonotope}, cp::CartesianProduct{N, AZ1, AZ2}) where
     {N, AZ1&lt;:AbstractZonotope{N}, AZ2&lt;:AbstractZonotope{N}}</code></pre><p>Converts a cartesian product of two zonotopes into a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type used for dispatch</li><li><code>cp</code>       – cartesian product of two zonotopes</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Notes</strong></p><p>This implementation creates a <code>Zonotope</code> with sparse vector and matrix representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L1111-L1129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{AZ}, Tuple{N}, Tuple{Type{Zonotope},CartesianProductArray{N,AZ}}} where AZ&lt;:AbstractZonotope{N} where N" href="#Base.convert-Union{Tuple{AZ}, Tuple{N}, Tuple{Type{Zonotope},CartesianProductArray{N,AZ}}} where AZ&lt;:AbstractZonotope{N} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Zonotope}, cpa::CartesianProductArray{N, AZ})
    where {N, AZ&lt;:AbstractZonotope{N}}</code></pre><p>Converts a cartesian product array of zonotopes into a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code> – type used for dispatch</li><li><code>cpa</code>       – cartesian product array of zonotopes</li></ul><p><strong>Output</strong></p><p>A zonotope.</p><p><strong>Notes</strong></p><p>This function requires the use of <code>SparseArrays</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/6300bddf560e1337bb163f7362dbfcc13653403d/src/convert.jl#L1138-L1156">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../binary_functions/">« Concrete Operations</a><a class="docs-footer-nextpage" href="../comparisons/">Comparisons »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 21 October 2020 22:30">Wednesday 21 October 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
