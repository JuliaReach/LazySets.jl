<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CartesianProduct · LazySets.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">LazySets.jl</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../../man/set_operations/">Operations on Sets</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../interfaces/">Interfaces</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../../sets/Line/">Line</a></li><li><a class="tocitem" href="../../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../../sets/PolynomialZonotope/">PolynomialZonotope</a></li><li><a class="tocitem" href="../../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../../sets/Zonotope/">Zonotope</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../Bloating/">Bloating</a></li><li class="is-active"><a class="tocitem" href>CartesianProduct</a><ul class="internal"><li><a class="tocitem" href="#def_CartesianProduct"><span>Binary Cartesian product (CartesianProduct)</span></a></li><li><a class="tocitem" href="#def_CartesianProductArray"><span><span>$n$</span>-ary Cartesian product (CartesianProductArray)</span></a></li></ul></li><li><a class="tocitem" href="../Complement/">Complement</a></li><li><a class="tocitem" href="../ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../Intersection/">Intersection</a></li><li><a class="tocitem" href="../LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../Rectification/">Rectification</a></li><li><a class="tocitem" href="../ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../Translation/">Translation</a></li><li><a class="tocitem" href="../UnionSet/">UnionSet</a></li></ul></li><li><a class="tocitem" href="../../binary_functions/">Concrete Operations</a></li><li><a class="tocitem" href="../../conversion/">Conversions between set representations</a></li><li><a class="tocitem" href="../../comparisons/">Comparisons</a></li><li><a class="tocitem" href="../../approximations/">Approximations</a></li><li><a class="tocitem" href="../../utils/">Utility Functions</a></li><li><a class="tocitem" href="../../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li><a class="is-disabled">Lazy Operations</a></li><li class="is-active"><a href>CartesianProduct</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CartesianProduct</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/lazy_operations/CartesianProduct.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Cartesian-product"><a class="docs-heading-anchor" href="#Cartesian-product">Cartesian product</a><a id="Cartesian-product-1"></a><a class="docs-heading-anchor-permalink" href="#Cartesian-product" title="Permalink"></a></h1><h2 id="def_CartesianProduct"><a class="docs-heading-anchor" href="#def_CartesianProduct">Binary Cartesian product (CartesianProduct)</a><a id="def_CartesianProduct-1"></a><a class="docs-heading-anchor-permalink" href="#def_CartesianProduct" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.CartesianProduct" href="#LazySets.CartesianProduct"><code>LazySets.CartesianProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CartesianProduct{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents a Cartesian product of two convex sets.</p><p><strong>Fields</strong></p><ul><li><code>X</code> – first convex set</li><li><code>Y</code> – second convex set</li></ul><p><strong>Notes</strong></p><p>The Cartesian product of three elements is obtained recursively. See also <code>CartesianProductArray</code> for an implementation of a Cartesian product of many sets without recursion, instead using an array.</p><p>The <code>EmptySet</code> is the absorbing element for <code>CartesianProduct</code>.</p><p><strong>Examples</strong></p><p>The Cartesian product between two sets <code>X</code> and <code>Y</code> can be constructed either using <code>CartesianProduct(X, Y)</code> or the short-cut notation <code>X × Y</code>:</p><pre><code class="language-julia-repl">julia&gt; I1 = Interval(0, 1);

julia&gt; I2 = Interval(2, 4);

julia&gt; I12 = I1 × I2;

julia&gt; typeof(I12)
CartesianProduct{Float64,Interval{Float64,IntervalArithmetic.Interval{Float64}},Interval{Float64,IntervalArithmetic.Interval{Float64}}}</code></pre><p>A hyperrectangle is the cartesian product of intervals, so we can convert <code>I12</code> exactly to a <code>Hyperrectangle</code> type:</p><pre><code class="language-julia-repl">julia&gt; convert(Hyperrectangle, I12)
Hyperrectangle{Float64,Array{Float64,1},Array{Float64,1}}([0.5, 3.0], [0.5, 1.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProduct.jl#L7-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.:×-Tuple{LazySet,LazySet}" href="#LinearAlgebra.:×-Tuple{LazySet,LazySet}"><code>LinearAlgebra.:×</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">×</code></pre><p>Alias for the binary Cartesian product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProduct.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{LazySet,LazySet}" href="#Base.:*-Tuple{LazySet,LazySet}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    *(X::LazySet, Y::LazySet)</code></pre><p>Alias for the binary Cartesian product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProduct.jl#L59-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.swap-Tuple{CartesianProduct}" href="#LazySets.swap-Tuple{CartesianProduct}"><code>LazySets.swap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swap(cp::CartesianProduct)</code></pre><p>Return a new <code>CartesianProduct</code> object with the arguments swapped.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product of two convex sets</li></ul><p><strong>Output</strong></p><p>A new <code>CartesianProduct</code> object with the arguments swapped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProduct.jl#L75-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.dim-Tuple{CartesianProduct}" href="#LazySets.dim-Tuple{CartesianProduct}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dim(cp::CartesianProduct)</code></pre><p>Return the dimension of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Cartesian product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProduct.jl#L92-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, cp::CartesianProduct{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>The support function in the given direction. If the direction has norm zero, the result depends on the wrapped sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProduct.jl#L129-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">σ(d::AbstractVector{N}, cp::CartesianProduct{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProduct.jl#L109-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isbounded-Tuple{CartesianProduct}" href="#LazySets.isbounded-Tuple{CartesianProduct}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isbounded(cp::CartesianProduct)</code></pre><p>Determine whether a Cartesian product is bounded.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff both wrapped sets are bounded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProduct.jl#L149-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∈(x::AbstractVector{N}, cp::CartesianProduct{N}) where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>x</code>  – point/vector</li><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ cp$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProduct.jl#L166-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{CartesianProduct}" href="#Base.isempty-Tuple{CartesianProduct}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isempty(cp::CartesianProduct)</code></pre><p>Return if a Cartesian product is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the sub-blocks is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProduct.jl#L188-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraints_list(cp::CartesianProduct{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of a (polyhedral) Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>A list of constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProduct.jl#L205-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertices_list(cp::CartesianProduct{N}) where {N&lt;:Real}</code></pre><p>Return the list of vertices of a (polytopic) Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProduct.jl#L222-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, cp::CartesianProduct{N}) where {N&lt;:Real}</code></pre><p>Concrete linear map of a (polyhedral) Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>M</code>  – matrix</li><li><code>cp</code> – Cartesian product of two convex sets</li></ul><p><strong>Output</strong></p><p>A polytope if <code>cp</code> is bounded and a polyhedron otherwise.</p><p><strong>Algorithm</strong></p><p>We convert the Cartesian product to constraint representation and then call <code>linear_map</code> on the corresponding polyhedron.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProduct.jl#L258-L276">source</a></section></article><p>Inherited from <a href="../../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li><li><a href="../../interfaces/#LazySets.singleton_list-Tuple{LazySet}"><code>singleton_list</code></a></li></ul><h2 id="def_CartesianProductArray"><a class="docs-heading-anchor" href="#def_CartesianProductArray"><span>$n$</span>-ary Cartesian product (CartesianProductArray)</a><a id="def_CartesianProductArray-1"></a><a class="docs-heading-anchor-permalink" href="#def_CartesianProductArray" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.CartesianProductArray" href="#LazySets.CartesianProductArray"><code>LazySets.CartesianProductArray</code></a> — <span class="docstring-category">Type</span></header><section><div><p>CartesianProductArray{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</p><p>Type that represents the Cartesian product of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><code>array</code> – array of sets</li></ul><p><strong>Notes</strong></p><p>The <code>EmptySet</code> is the absorbing element for <code>CartesianProductArray</code>.</p><p>Constructors:</p><ul><li><p><code>CartesianProductArray(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>CartesianProductArray([n]::Int=0, [N]::Type=Float64)</code></p></li></ul><p>– constructor for an empty product with optional size hint and numeric type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProductArray.jl#L7-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.dim-Tuple{CartesianProductArray}" href="#LazySets.dim-Tuple{CartesianProductArray}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span></header><section><div><p>dim(cpa::CartesianProductArray)</p><p>Return the dimension of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Cartesian product of a finite number of convex sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProductArray.jl#L65-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ρ(d::AbstractVector{N}, cp::CartesianProductArray{N}) where {N&lt;:Real}</p><p>Return the support function of a Cartesian product array.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The support function in the given direction. If the direction has norm zero, the result depends on the wrapped sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProductArray.jl#L149-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>σ(d::AbstractVector{N}, cpa::CartesianProductArray{N}) where {N&lt;:Real}</p><p>Support vector of a Cartesian product array.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the product sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProductArray.jl#L83-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.isbounded-Tuple{CartesianProductArray}" href="#LazySets.isbounded-Tuple{CartesianProductArray}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span></header><section><div><p>isbounded(cpa::CartesianProductArray)</p><p>Determine whether a Cartesian product of a finite number of convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff all wrapped sets are bounded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProductArray.jl#L211-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span></header><section><div><p>∈(x::AbstractVector{N}, cpa::CartesianProductArray{N}) where {N&lt;:Real}</p><p>Check whether a given point is contained in a Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>x</code>   – point/vector</li><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ \text{cpa}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProductArray.jl#L229-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{CartesianProductArray}" href="#Base.isempty-Tuple{CartesianProductArray}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><p>isempty(cpa::CartesianProductArray)</p><p>Return if a Cartesian product is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the sub-blocks is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProductArray.jl#L259-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span></header><section><div><p>constraints_list(cpa::CartesianProductArray{N}) where {N&lt;:Real}</p><p>Return the list of constraints of a (polyhedral) Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A list of constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProductArray.jl#L276-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span></header><section><div><p>vertices_list(cpa::CartesianProductArray{N}) where {N&lt;:Real}</p><p>Return the list of vertices of a (polytopic) Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProductArray.jl#L311-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span></header><section><div><p>linear_map(M::AbstractMatrix{N}, cpa::CartesianProductArray{N}              ) where {N&lt;:Real}</p><p>Concrete linear map of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>M</code>   – matrix</li><li><code>cpa</code> – Cartesian product of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>A polytope.</p><p><strong>Algorithm</strong></p><p>We check if the matrix is invertible. If so, we convert the Cartesian product to constraint representation. Otherwise, we convert the Cartesian product to vertex representation. In both cases, we then call <code>linear_map</code> on the resulting polytope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProductArray.jl#L559-L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.array-Union{Tuple{CartesianProductArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real" href="#LazySets.array-Union{Tuple{CartesianProductArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span></header><section><div><p>array(cpa::CartesianProductArray{N, S}) where {N&lt;:Real, S&lt;:LazySet{N}}</p><p>Return the array of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The array of a Cartesian product of a finite number of convex sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProductArray.jl#L47-L59">source</a></section><section><div><pre><code class="language-none">array(cha::ConvexHullArray{N, S}) where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p>The array of a convex hull of a finite number of convex sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/ConvexHullArray.jl#L70-L82">source</a></section><section><div><pre><code class="language-none">array(ia::IntersectionArray{N, S}) where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of an intersection of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array of an intersection of a finite number of convex sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/IntersectionArray.jl#L53-L65">source</a></section><section><div><p>array(msa::MinkowskiSumArray{N, S}) where {N&lt;:Real, S&lt;:LazySet{N}}</p><p>Return the array of a Minkowski sum of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The array of a Minkowski sum of a finite number of convex sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/MinkowskiSumArray.jl#L55-L67">source</a></section><section><div><pre><code class="language-none">array(cms::CachedMinkowskiSumArray{N, S}) where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The array of a caching Minkowski sum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CachedMinkowskiSumArray.jl#L90-L102">source</a></section><section><div><p>array(cup::UnionSetArray{N, S}) where {N&lt;:Real, S&lt;:LazySet{N}}</p><p>Return the array of a union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array that holds the union of a finite number of convex sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/UnionSetArray.jl#L50-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.block_structure-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N" href="#LazySets.block_structure-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N"><code>LazySets.block_structure</code></a> — <span class="docstring-category">Method</span></header><section><div><p>block_structure(cpa::CartesianProductArray{N}) where {N}</p><p>Returns an array containing the dimension ranges of each block in a <code>CartesianProductArray</code>.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A vector of ranges</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using LazySets: block_structure

julia&gt; cpa = CartesianProductArray([BallInf(zeros(n), 1.0) for n in [3, 1, 2]]);

julia&gt; block_structure(cpa)
3-element Array{UnitRange{Int64},1}:
 1:3
 4:4
 5:6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProductArray.jl#L408-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.block_to_dimension_indices-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N},Array{Int64,1}}} where N" href="#LazySets.block_to_dimension_indices-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N},Array{Int64,1}}} where N"><code>LazySets.block_to_dimension_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><p>block<em>to</em>dimension_indices(cpa::CartesianProductArray{N}, vars::Vector{Int}) where {N}</p><p>Returns a vector mapping block index <code>i</code> to tuple <code>(f, l)</code> such that either <code>f = l = -1</code> or <code>f</code> is the first dimension index and <code>l</code> is the last dimension index of the <code>i</code>-th block, depending on whether one of the block&#39;s dimension indices is specified in <code>vars</code>.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li><li><code>vars</code> – list containing the variables of interest, sorted in ascending order</li></ul><p><strong>Output</strong></p><p>(i) A vector of tuples, where values in tuple relate to range of dimensions in the i-th block. (ii) Number of constrained blocks</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using LazySets: block_to_dimension_indices

julia&gt; cpa = CartesianProductArray([BallInf(zeros(n), 1.0) for n in [1, 3, 2, 3]]);

julia&gt; m, k = block_to_dimension_indices(cpa, [2, 4, 8]);

julia&gt; m
4-element Array{Tuple{Int64,Int64},1}:
 (-1, -1)
 (2, 4)
 (-1, -1)
 (7, 9)

julia&gt; k
2</code></pre><p>This vector represents the mapping &quot;second block from dimension 2 to dimension 4, fourth block from dimension 7 to dimension 9.&quot; These blocks contain the dimensions specified in <code>[2, 4, 8]</code>. Number of constrained variables here is 2 (2nd and 4th blocks)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProductArray.jl#L447-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.substitute_blocks-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N},CartesianProductArray{N,S} where S&lt;:LazySet{N},Array{Tuple{Int64,Int64},1}}} where N" href="#LazySets.substitute_blocks-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N},CartesianProductArray{N,S} where S&lt;:LazySet{N},Array{Tuple{Int64,Int64},1}}} where N"><code>LazySets.substitute_blocks</code></a> — <span class="docstring-category">Method</span></header><section><div><p>substitute<em>blocks(low</em>dim<em>cpa::CartesianProductArray{N},                         orig</em>cpa::CartesianProductArray{N},                           blocks::Vector{Tuple{Int,Int}}) where {N}</p><p>Return merged Cartesian Product Array between original CPA and some low-dimensional CPA, which represents updated subset of variables in specified blocks.</p><p><strong>Input</strong></p><ul><li><code>low_dim_cpa</code> – low-dimensional cartesian product array</li><li><code>orig_cpa</code> – original high-dimensional Cartesian product array</li><li><code>blocks</code> – index of the first variable in each block of <code>orig_cpa</code></li></ul><p><strong>Output</strong></p><p>Merged cartesian product array</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/72ae5a61e1f5ae98c7d711ec4228975945a24d6b/src/LazyOperations/CartesianProductArray.jl#L523-L540">source</a></section></article><p>Inherited from <a href="../../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li><li><a href="../../interfaces/#LazySets.singleton_list-Tuple{LazySet}"><code>singleton_list</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Bloating/">« Bloating</a><a class="docs-footer-nextpage" href="../Complement/">Complement »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 5 August 2020 14:06">Wednesday 5 August 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
