<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Set Interfaces · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/getting_started.html">Getting Started</a></li><li><a class="toctext" href="../man/polyhedral_approximations.html">Polyhedral Approximations</a></li><li><a class="toctext" href="../man/decompose_example.html">Decomposing an Affine Map</a></li><li><a class="toctext" href="../man/fast_2d_LPs.html">Fast 2D LPs</a></li><li><a class="toctext" href="../man/iterative_refinement.html">Iterative Refinement</a></li><li><a class="toctext" href="../man/interval_hulls.html">Interval Hulls</a></li><li><a class="toctext" href="../man/convex_hulls.html">Convex Hulls</a></li><li><a class="toctext" href="../man/set_operations.html">Operations on Sets</a></li><li><a class="toctext" href="../man/reach_zonotopes.html">A Reachability Algorithm</a></li><li><a class="toctext" href="../man/reach_zonotopes_hybrid.html">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../man/concrete_polyhedra.html">Concrete Polyhedra</a></li></ul></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href="interfaces.html">Set Interfaces</a><ul class="internal"><li><a class="toctext" href="#LazySet-1">LazySet</a></li><li><a class="toctext" href="#Centrally-symmetric-set-1">Centrally symmetric set</a></li><li><a class="toctext" href="#Polytope-1">Polytope</a></li></ul></li><li><a class="toctext" href="representations.html">Common Set Representations</a></li><li><a class="toctext" href="operations.html">Common Set Operations</a></li><li><a class="toctext" href="conversion.html">Conversion between set representations</a></li><li><a class="toctext" href="binary_functions.html">Binary Functions on Sets</a></li><li><a class="toctext" href="approximations.html">Approximations</a></li><li><a class="toctext" href="utils.html">Utility Functions</a></li></ul></li><li><a class="toctext" href="../about.html">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="interfaces.html">Set Interfaces</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/interfaces.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Set Interfaces</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Set-Interfaces-1" href="#Set-Interfaces-1">Set Interfaces</a></h1><p>This section of the manual describes the interfaces for different set types. Every set that fits the description of an interface should also implement it. This helps in several ways:</p><ul><li>avoid code duplicates,</li><li>provide functions for many sets at once,</li><li>allow changes in the source code without changing the API.</li></ul><p>The interface functions are outlined in the interface documentation. See <a href="representations.html#Common-Set-Representations-1">Common Set Representations</a> for implementations of the interfaces.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The naming convention is such that all interface names (with the exception of the main abstract type <code>LazySet</code>) should be preceded by <code>Abstract</code>.</p></div></div><p>The following diagram shows the interface hierarchy.</p><p><img src="../assets/interfaces.png" alt="../assets/interfaces.png"/></p><ul><li><a href="interfaces.html#Set-Interfaces-1">Set Interfaces</a></li><ul><li><a href="interfaces.html#LazySet-1">LazySet</a></li><ul><li><a href="interfaces.html#Support-function-and-support-vector-1">Support function and support vector</a></li><li><a href="interfaces.html#Other-globally-defined-set-functions-1">Other globally defined set functions</a></li><li><a href="interfaces.html#Aliases-for-set-types-1">Aliases for set types</a></li></ul><li><a href="interfaces.html#Centrally-symmetric-set-1">Centrally symmetric set</a></li><li><a href="interfaces.html#Polytope-1">Polytope</a></li><ul><li><a href="interfaces.html#Polygon-1">Polygon</a></li><ul><li><a href="interfaces.html#HPolygon-1">HPolygon</a></li></ul><li><a href="interfaces.html#Centrally-symmetric-polytope-1">Centrally symmetric polytope</a></li><ul><li><a href="interfaces.html#Hyperrectangle-1">Hyperrectangle</a></li><li><a href="interfaces.html#Singleton-1">Singleton</a></li></ul></ul></ul></ul><h2><a class="nav-anchor" id="LazySet-1" href="#LazySet-1">LazySet</a></h2><p>Every convex set in this library implements this interface.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.LazySet" href="#LazySets.LazySet"><code>LazySets.LazySet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LazySet{N}</code></pre><p>Abstract type for convex sets, i.e., sets characterized by a (possibly infinite) intersection of halfspaces, or equivalently, sets <span>$S$</span> such that for any two elements <span>$x, y ∈ S$</span> and <span>$0 ≤ λ ≤ 1$</span> it holds that <span>$λ·x + (1-λ)·y ∈ S$</span>.</p><p><strong>Notes</strong></p><p><code>LazySet</code> types should be parameterized with a type <code>N</code>, typically <code>N&lt;:Real</code>, for using different numeric types.</p><p>Every concrete <code>LazySet</code> must define the following functions:</p><ul><li><code>σ(d::AbstractVector{N}, S::LazySet{N}) where {N&lt;:Real}</code> – the support vector   of <code>S</code> in a given direction <code>d</code>; note that the numeric type <code>N</code> of <code>d</code> and   <code>S</code> must be identical; for some set types <code>N</code> may be more restrictive than   <code>Real</code></li><li><code>dim(S::LazySet)::Int</code> – the ambient dimension of <code>S</code></li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(LazySet)
19-element Array{Any,1}:
 AbstractCentrallySymmetric
 AbstractPolytope
 CacheMinkowskiSum
 CartesianProduct
 CartesianProductArray
 ConvexHull
 ConvexHullArray
 EmptySet
 ExponentialMap
 ExponentialProjectionMap
 HPolyhedron
 Hyperplane
 Intersection
 IntersectionArray
 HalfSpace
 Line
 LinearMap
 MinkowskiSum
 MinkowskiSumArray</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/LazySet.jl#L14-L56">source</a></section><h3><a class="nav-anchor" id="Support-function-and-support-vector-1" href="#Support-function-and-support-vector-1">Support function and support vector</a></h3><p>Every <code>LazySet</code> type must define a function <code>σ</code> to compute the support vector.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.support_vector" href="#LazySets.support_vector"><code>LazySets.support_vector</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">support_vector</code></pre><p>Alias for the support vector σ.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/LazySet.jl#L99-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ρ(d::AbstractVector{N}, S::LazySet{N})::N where {N&lt;:Real}</code></pre><p>Evaluate the support function of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>The support function of the set <code>S</code> for the direction <code>d</code>.</p><p><strong>Notes</strong></p><p>The numeric type of the direction and the set must be identical.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/LazySet.jl#L63-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.support_function" href="#LazySets.support_function"><code>LazySets.support_function</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">support_function</code></pre><p>Alias for the support function ρ.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/LazySet.jl#L85-L89">source</a></section><h3><a class="nav-anchor" id="Other-globally-defined-set-functions-1" href="#Other-globally-defined-set-functions-1">Other globally defined set functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{LazySet,Real}" href="#LinearAlgebra.norm-Tuple{LazySet,Real}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">norm(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the norm of a convex set. It is the norm of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/LazySet.jl#L107-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius-Tuple{LazySet,Real}" href="#LazySets.radius-Tuple{LazySet,Real}"><code>LazySets.radius</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">radius(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the radius of a convex set. It is the radius of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/LazySet.jl#L131-L146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.diameter-Tuple{LazySet,Real}" href="#LazySets.diameter-Tuple{LazySet,Real}"><code>LazySets.diameter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">diameter(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the diameter of a convex set. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/LazySet.jl#L155-L171">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{LazySet{Real}}" href="#LazySets.an_element-Tuple{LazySet{Real}}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">an_element(S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>An element of a convex set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/LazySet.jl#L177-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Tuple{LazySet,LazySet}" href="#Base.:==-Tuple{LazySet,LazySet}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">==(X::LazySet, Y::LazySet)</code></pre><p>Return whether two LazySets of the same type are exactly equal by recursively comparing their fields until a mismatch is found.</p><p><strong>Input</strong></p><ul><li><code>X</code> – any <code>LazySet</code></li><li><code>Y</code> – another <code>LazySet</code> of the same type as <code>X</code></li></ul><p><strong>Output</strong></p><ul><li><code>true</code> iff <code>X</code> is equal to <code>Y</code>.</li></ul><p><strong>Notes</strong></p><p>The check is purely syntactic and the sets need to have the same base type. I.e. <code>X::VPolytope == Y::HPolytope</code> returns <code>false</code> even if <code>X</code> and <code>Y</code> represent the same polytope. However <code>X::HPolytope{Int64} == Y::HPolytope{Float64}</code> is a valid comparison.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; HalfSpace([1], 1) == HalfSpace([1], 1)
true

julia&gt; HalfSpace([1], 1) == HalfSpace([1.0], 1.0)
true

julia&gt; Ball1([0.], 1.) == Ball2([0.], 1.)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/LazySet.jl#L195-L227">source</a></section><h3><a class="nav-anchor" id="Aliases-for-set-types-1" href="#Aliases-for-set-types-1">Aliases for set types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CompactSet" href="#LazySets.CompactSet"><code>LazySets.CompactSet</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">CompactSet</code></pre><p>An alias for compact set types.</p><p><strong>Notes</strong></p><p>Most lazy operations are not captured by this alias because whether their result is compact or not depends on the argument(s).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/aliases.jl#L4-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.NonCompactSet" href="#LazySets.NonCompactSet"><code>LazySets.NonCompactSet</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">NonCompactSet</code></pre><p>An alias for non-compact set types.</p><p><strong>Notes</strong></p><p>Most lazy operations are not captured by this alias because whether their result is non-compact or not depends on the argument(s).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/aliases.jl#L20-L29">source</a></section><h2><a class="nav-anchor" id="Centrally-symmetric-set-1" href="#Centrally-symmetric-set-1">Centrally symmetric set</a></h2><p>Centrally symmetric sets such as balls of different norms are characterized by a center. Note that there is a special interface combination <a href="interfaces.html#Centrally-symmetric-polytope-1">Centrally symmetric polytope</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractCentrallySymmetric" href="#LazySets.AbstractCentrallySymmetric"><code>LazySets.AbstractCentrallySymmetric</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractCentrallySymmetric{N&lt;:Real} &lt;: LazySet{N}</code></pre><p>Abstract type for centrally symmetric sets.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractCentrallySymmetric</code> must define the following functions:</p><ul><li><code>center(::AbstractCentrallySymmetric{N})::Vector{N}</code> – return the center   point</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractCentrallySymmetric)
3-element Array{Any,1}:
 Ball2
 Ballp
 Ellipsoid</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractCentrallySymmetric.jl#L7-L26">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractCentrallySymmetric}" href="#LazySets.dim-Tuple{AbstractCentrallySymmetric}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dim(S::AbstractCentrallySymmetric)::Int</code></pre><p>Return the ambient dimension of a centrally symmetric set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractCentrallySymmetric.jl#L30-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">an_element(S::AbstractCentrallySymmetric{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a centrally symmetric set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p>The center of the centrally symmetric set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractCentrallySymmetric.jl#L47-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{AbstractCentrallySymmetric}" href="#Base.isempty-Tuple{AbstractCentrallySymmetric}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isempty(S::AbstractCentrallySymmetric)::Bool</code></pre><p>Return if a centrally symmetric set is empty or not.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractCentrallySymmetric.jl#L64-L76">source</a></section><h2><a class="nav-anchor" id="Polytope-1" href="#Polytope-1">Polytope</a></h2><p>A polytope has finitely many vertices (<em>V-representation</em>) resp. facets (<em>H-representation</em>). Note that there is a special interface combination <a href="interfaces.html#Centrally-symmetric-polytope-1">Centrally symmetric polytope</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractPolytope" href="#LazySets.AbstractPolytope"><code>LazySets.AbstractPolytope</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractPolytope{N&lt;:Real} &lt;: LazySet{N}</code></pre><p>Abstract type for polytopic sets, i.e., sets with finitely many flat facets, or equivalently, sets defined as an intersection of a finite number of halfspaces, or equivalently, sets with finitely many vertices.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolytope</code> must define the following functions:</p><ul><li><code>constraints_list(::AbstractPolytope{N})::Vector{LinearConstraint{N}}</code> –   return a list of all facet constraints</li><li><code>vertices_list(::AbstractPolytope{N})::Vector{Vector{N}}</code> – return a list of   all vertices</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolytope)
4-element Array{Any,1}:
 AbstractCentrallySymmetricPolytope
 AbstractPolygon
 HPolytope
 VPolytope</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractPolytope.jl#L9-L32">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">singleton_list(P::AbstractPolytope{N})::Vector{Singleton{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a polytopic set as a list of singletons.</p><p><strong>Input</strong></p><ul><li><code>P</code> – a polytopic set</li></ul><p><strong>Output</strong></p><p>List containing a singleton for each vertex.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractPolytope.jl#L39-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Tuple{AbstractArray{T,2} where T,AbstractPolytope}" href="#LazySets.linear_map-Tuple{AbstractArray{T,2} where T,AbstractPolytope}"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">linear_map(M::AbstractMatrix, P::AbstractPolytope{N};
           output_type::Type{&lt;:LazySet}=VPolytope{N}) where {N&lt;:Real}</code></pre><p>Concrete linear map of an abstract polytype.</p><p><strong>Input</strong></p><ul><li><code>M</code>           – matrix</li><li><code>P</code>           – abstract polytype</li><li><code>output_type</code> – (optional, default: <code>VPolytope</code>) type of the result</li></ul><p><strong>Output</strong></p><p>A set of type <code>output_type</code>.</p><p><strong>Algorithm</strong></p><p>The linear map <span>$M$</span> is applied to each vertex of the given set <span>$P$</span>, obtaining a polytope in V-representation. Since some set representations (e.g. axis-aligned hyperrectangles) are not closed under linear maps, the default output is a <code>VPolytope</code>. If an <code>output_type</code> is given, the corresponding <code>convert</code> method is invoked.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractPolytope.jl#L57-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real" href="#Base.isempty-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isempty(P::AbstractPolytope{N})::Bool where {N&lt;:Real}</code></pre><p>Determine whether a polytope is empty.</p><p><strong>Input</strong></p><ul><li><code>P</code> – abstract polytope</li></ul><p><strong>Output</strong></p><p><code>true</code> if the given polytope contains no vertices, and <code>false</code> otherwise.</p><p><strong>Algorithm</strong></p><p>This algorithm checks whether the <code>vertices_list</code> of the given polytope is empty or not.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractPolytope.jl#L88-L105">source</a></section><h3><a class="nav-anchor" id="Polygon-1" href="#Polygon-1">Polygon</a></h3><p>A polygon is a two-dimensional polytope.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractPolygon" href="#LazySets.AbstractPolygon"><code>LazySets.AbstractPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractPolygon{N&lt;:Real} &lt;: AbstractPolytope{N}</code></pre><p>Abstract type for polygons (i.e., 2D polytopes).</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolygon</code> must define the following functions:</p><ul><li><code>tovrep(::AbstractPolygon{N})::VPolygon{N}</code>         – transform into   V-representation</li><li><code>tohrep(::AbstractPolygon{N})::AbstractHPolygon{N}</code> – transform into   H-representation</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolygon)
2-element Array{Any,1}:
 AbstractHPolygon
 VPolygon</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractPolygon.jl#L7-L26">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractPolygon}" href="#LazySets.dim-Tuple{AbstractPolygon}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dim(P::AbstractPolygon)::Int</code></pre><p>Return the ambient dimension of a polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polygon, which is 2.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractPolygon.jl#L33-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{T,2} where T,AbstractPolygon{N}}} where N" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{T,2} where T,AbstractPolygon{N}}} where N"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">linear_map(M::AbstractMatrix, P::AbstractPolygon{N};
           output_type::Type{&lt;:LazySet}=typeof(P)) where {N}</code></pre><p>Concrete linear map of an abstract polygon.</p><p><strong>Input</strong></p><ul><li><code>M</code>           – matrix</li><li><code>P</code>           – abstract polygon</li><li><code>output_type</code> – (optional, default: type of <code>P</code>) type of the result</li></ul><p><strong>Output</strong></p><p>A set of type <code>output_type</code>.</p><p><strong>Algorithm</strong></p><p>The linear map <span>$M$</span> is applied to each vertex of the given set <span>$P$</span>, obtaining a polygon in V-representation. Since polygons are closed under linear map, by default <span>$MP$</span> is converted to the concrete type of <span>$P$</span>. If an <code>output_type</code> is given, the corresponding <code>convert</code> method is invoked.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractPolygon.jl#L182-L204">source</a></section><h4><a class="nav-anchor" id="HPolygon-1" href="#HPolygon-1">HPolygon</a></h4><p>An HPolygon is a polygon in H-representation (or constraint representation).</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractHPolygon" href="#LazySets.AbstractHPolygon"><code>LazySets.AbstractHPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractHPolygon{N&lt;:Real} &lt;: AbstractPolygon{N}</code></pre><p>Abstract type for polygons in H-representation (i.e., constraints).</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractHPolygon</code> must have the following fields:</p><ul><li><code>constraints::Vector{LinearConstraint{N}}</code> – the constraints</li></ul><p>New subtypes should be added to the <code>convert</code> method in order to be convertible.</p><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractHPolygon)
2-element Array{Any,1}:
 HPolygon
 HPolygonOpt</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractHPolygon.jl#L16-L34">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">an_element(P::AbstractHPolygon{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>A vertex of the polygon in constraint representation (the first one in the order of the constraints).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractHPolygon.jl#L134-L147">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Real,1},AbstractHPolygon{Real}}" href="#Base.:∈-Tuple{AbstractArray{Real,1},AbstractHPolygon{Real}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">∈(x::AbstractVector{N}, P::AbstractHPolygon{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given 2D point is contained in a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>x</code> – two-dimensional point/vector</li><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation checks if the point lies on the outside of each edge.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractHPolygon.jl#L154-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{AbstractHPolygon{Real}}" href="#LazySets.vertices_list-Tuple{AbstractHPolygon{Real}}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">vertices_list(P::AbstractHPolygon{N},
              apply_convex_hull::Bool=false
             )::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>                 – polygon in constraint representation</li><li><code>apply_convex_hull</code> – (optional, default: <code>false</code>) to post process or not the                        intersection of constraints with a convex hull</li></ul><p><strong>Output</strong></p><p>List of vertices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractHPolygon.jl#L80-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tohrep-Tuple{AbstractHPolygon{Real}}" href="#LazySets.tohrep-Tuple{AbstractHPolygon{Real}}"><code>LazySets.tohrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tohrep(P::AbstractHPolygon{N})::AbstractHPolygon{N} where {N&lt;:Real}</code></pre><p>Build a contraint representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>The identity, i.e., the same polygon instance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractHPolygon.jl#L59-L71">source</a><div><div><pre><code class="language-none">tohrep(P::HPoly{N}) where {N}</code></pre><p>Return a constraint representation of the given polyhedron in constraint representation (no-op).</p><p><strong>Input</strong></p><ul><li><code>P</code> – polyhedron in constraint representation</li></ul><p><strong>Output</strong></p><p>The same polyhedron instance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/HPolyhedron.jl#L282-L295">source</a><div><div><pre><code class="language-none">tohrep(P::VPolygon{N}, ::Type{HPOLYGON}=HPolygon
      )::AbstractHPolygon{N} where {N&lt;:Real, HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Build a constraint representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code>        – polygon in vertex representation</li><li><code>HPOLYGON</code> – (optional, default: <code>HPolygon</code>) type of target polygon</li></ul><p><strong>Output</strong></p><p>The same polygon but in constraint representation, an <code>AbstractHPolygon</code>.</p><p><strong>Algorithm</strong></p><p>The algorithms consists of adding an edge for each consecutive pair of vertices. Since the vertices are already ordered in counter-clockwise fashion (CWW), the constraints will be sorted automatically (CCW) if we start with the first edge between the first and second vertex.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/VPolygon.jl#L75-L96">source</a><div><div><pre><code class="language-none">tohrep(P::VPolytope{N}; [backend]=default_polyhedra_backend(P, N)) where {N}</code></pre><p>Transform a polytope in V-representation to a polytope in H-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>          – polytope in vertex representation</li><li><code>backend</code>    – (optional, default: <code>default_polyhedra_backend(P, N)</code>) the polyhedral                 computations backend,                 see <a href="https://juliapolyhedra.github.io/Polyhedra.jl/latest/installation.html#Getting-Libraries-1">Polyhedra&#39;s documentation</a>                 for further information</li></ul><p><strong>Output</strong></p><p>The <code>HPolytope</code> which is the constraint representation of the given polytope in vertex representation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/VPolytope.jl#L243-L260">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tovrep-Tuple{AbstractHPolygon{Real}}" href="#LazySets.tovrep-Tuple{AbstractHPolygon{Real}}"><code>LazySets.tovrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tovrep(P::AbstractHPolygon{N})::VPolygon{N} where {N&lt;:Real}</code></pre><p>Build a vertex representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>The same polygon but in vertex representation, a <code>VPolygon</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractHPolygon.jl#L41-L53">source</a><div><div><pre><code class="language-none">tovrep(P::HPoly{N};
      [backend]=default_polyhedra_backend(P, N)) where {N}</code></pre><p>Transform a polyhedron in H-representation to a polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>          – polyhedron in constraint representation</li><li><code>backend</code>    – (optional, default: <code>default_polyhedra_backend(P, N)</code>)                 the polyhedral computations backend</li></ul><p><strong>Output</strong></p><p>The <code>VPolytope</code> which is the vertex representation of the given polyhedron in constraint representation.</p><p><strong>Notes</strong></p><p>For further information on the supported backends see <a href="https://juliapolyhedra.github.io/Polyhedra.jl/">Polyhedra&#39;s documentation</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/HPolyhedron.jl#L368-L389">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.addconstraint!-Tuple{AbstractHPolygon{Real},LazySets.HalfSpace{Real}}" href="#LazySets.addconstraint!-Tuple{AbstractHPolygon{Real},LazySets.HalfSpace{Real}}"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addconstraint!(P::AbstractHPolygon{N},
               constraint::LinearConstraint{N};
               [linear_search]::Bool=(
                length(P.constraints) &lt; BINARY_SEARCH_THRESHOLD)
              )::Nothing where {N&lt;:Real}</code></pre><p>Add a linear constraint to a polygon in constraint representation, keeping the constraints sorted by their normal directions.</p><p><strong>Input</strong></p><ul><li><code>P</code>          – polygon in constraint representation</li><li><code>constraint</code> – linear constraint to add</li></ul><p><strong>Output</strong></p><p>Nothing.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractHPolygon.jl#L188-L206">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Tuple{AbstractHPolygon{Real}}" href="#LazySets.constraints_list-Tuple{AbstractHPolygon{Real}}"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">constraints_list(P::AbstractHPolygon{N})::Vector{LinearConstraint{N}} where {N&lt;:Real}</code></pre><p>Return the list of constraints defining a polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in H-representation</li></ul><p><strong>Output</strong></p><p>The list of constraints of the polygon.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractHPolygon.jl#L114-L126">source</a></section><h3><a class="nav-anchor" id="Centrally-symmetric-polytope-1" href="#Centrally-symmetric-polytope-1">Centrally symmetric polytope</a></h3><p>A centrally symmetric polytope is a combination of two other interfaces: <a href="interfaces.html#Centrally-symmetric-set-1">Centrally symmetric set</a> and <a href="interfaces.html#Polytope-1">Polytope</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractCentrallySymmetricPolytope" href="#LazySets.AbstractCentrallySymmetricPolytope"><code>LazySets.AbstractCentrallySymmetricPolytope</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractCentrallySymmetricPolytope{N&lt;:Real} &lt;: AbstractPolytope{N}</code></pre><p>Abstract type for centrally symmetric, polytopic sets. It combines the <code>AbstractCentrallySymmetric</code> and <code>AbstractPolytope</code> interfaces. Such a type combination is necessary as long as Julia does not support <a href="https://github.com/JuliaLang/julia/issues/5">multiple inheritance</a>.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractCentrallySymmetricPolytope</code> must define the following functions:</p><ul><li>from <code>AbstractCentrallySymmetric</code>:<ul><li><code>center(::AbstractCentrallySymmetricPolytope{N})::Vector{N}</code> – return the  center point</li></ul></li><li>from <code>AbstractPolytope</code>:<ul><li><code>vertices_list(::AbstractCentrallySymmetricPolytope{N})::Vector{Vector{N}}</code>  – return a list of all vertices</li></ul></li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractCentrallySymmetricPolytope)
4-element Array{Any,1}:
 AbstractHyperrectangle
 Ball1
 LineSegment
 Zonotope</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractCentrallySymmetricPolytope.jl#L9-L36">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}" href="#LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dim(P::AbstractCentrallySymmetricPolytope)::Int</code></pre><p>Return the ambient dimension of a centrally symmetric, polytopic set.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric, polytopic set</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polytopic set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractCentrallySymmetricPolytope.jl#L44-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">an_element(P::AbstractCentrallySymmetricPolytope{N})::Vector{N}
    where {N&lt;:Real}</code></pre><p>Return some element of a centrally symmetric polytope.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric polytope</li></ul><p><strong>Output</strong></p><p>The center of the centrally symmetric polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractCentrallySymmetricPolytope.jl#L62-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}" href="#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isempty(P::AbstractCentrallySymmetricPolytope)::Bool</code></pre><p>Return if a centrally symmetric, polytopic set is empty or not.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric, polytopic set</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractCentrallySymmetricPolytope.jl#L81-L93">source</a></section><h4><a class="nav-anchor" id="Hyperrectangle-1" href="#Hyperrectangle-1">Hyperrectangle</a></h4><p>A hyperrectangle is a special centrally symmetric polytope with axis-aligned facets.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractHyperrectangle" href="#LazySets.AbstractHyperrectangle"><code>LazySets.AbstractHyperrectangle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractHyperrectangle{N&lt;:Real} &lt;: AbstractCentrallySymmetricPolytope{N}</code></pre><p>Abstract type for hyperrectangular sets.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractHyperrectangle</code> must define the following functions:</p><ul><li><code>radius_hyperrectangle(::AbstractHyperrectangle{N})::Vector{N}</code> – return the   hyperrectangle&#39;s radius, which is a full-dimensional vector</li><li><code>radius_hyperrectangle(::AbstractHyperrectangle{N}, i::Int)::N</code> – return the   hyperrectangle&#39;s radius in the <code>i</code>-th dimension</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractHyperrectangle)
5-element Array{Any,1}:
 AbstractSingleton
 BallInf
 Hyperrectangle
 Interval
 SymmetricIntervalHull</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractHyperrectangle.jl#L7-L29">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{AbstractHyperrectangle,Real}" href="#LinearAlgebra.norm-Tuple{AbstractHyperrectangle,Real}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">norm(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the norm of a convex set. It is the norm of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/LazySet.jl#L107-L122">source</a><div><div><pre><code class="language-none">norm(H::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the norm of a hyperrectangular set.</p><p>The norm of a hyperrectangular set is defined as the norm of the enclosing ball, of the given <span>$p$</span>-norm, of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p><p><strong>Algorithm</strong></p><p>Recall that the norm is defined as</p><div>\[‖ X ‖ = \max_{x ∈ X} ‖ x ‖_p = max_{x ∈ \text{vertices}(X)} ‖ x ‖_p.\]</div><p>The last equality holds because the optimum of a convex function over a polytope is attained at one of its vertices.</p><p>This implementation uses the fact that the maximum is achieved in the vertex <span>$c + \text{diag}(\text{sign}(c)) r$</span>, for any <span>$p$</span>-norm, hence it suffices to take the <span>$p$</span>-norm of this particular vertex. This statement is proved below. Note that, in particular, there is no need to compute the <span>$p$</span>-norm for <em>each</em> vertex, which can be very expensive. </p><p>If <span>$X$</span> is an axis-aligned hyperrectangle and the <span>$n$</span>-dimensional vectors center and radius of the hyperrectangle are denoted <span>$c$</span> and <span>$r$</span> respectively, then reasoning on the <span>$2^n$</span> vertices we have that:</p><div>\[\max_{x ∈ \text{vertices}(X)} ‖ x ‖_p = \max_{α_1, …, α_n ∈ \{-1, 1\}} (|c_1 + α_1 r_1|^p + ... + |c_n + α_n r_n|^p)^{1/p}.\]</div><p>The function <span>$x ↦ x^p$</span>, <span>$p &gt; 0$</span>, is monotonically increasing and thus the maximum of each term <span>$|c_i + α_i r_i|^p$</span> is given by <span>$|c_i + \text{sign}(c_i) r_i|^p$</span> for each <span>$i$</span>. Hence, <span>$x^* := \text{argmax}_{x ∈ X} ‖ x ‖_p$</span> is the vertex <span>$c + \text{diag}(\text{sign}(c)) r$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractHyperrectangle.jl#L113-L158">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius-Tuple{AbstractHyperrectangle,Real}" href="#LazySets.radius-Tuple{AbstractHyperrectangle,Real}"><code>LazySets.radius</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">radius(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the radius of a convex set. It is the radius of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/LazySet.jl#L131-L146">source</a><div><div><pre><code class="language-none">radius(H::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the radius of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p><p><strong>Notes</strong></p><p>The radius is defined as the radius of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center. It is the same for all corners of a hyperrectangular set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractHyperrectangle.jl#L164-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Real,1},AbstractHyperrectangle{Real}}" href="#LazySets.σ-Tuple{AbstractArray{Real,1},AbstractHyperrectangle{Real}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">σ(d::AbstractVector{N}, H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a hyperrectangular set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the vertex with biggest values is returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractHyperrectangle.jl#L94-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Real,1},AbstractHyperrectangle{Real}}" href="#Base.:∈-Tuple{AbstractArray{Real,1},AbstractHyperrectangle{Real}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">∈(x::AbstractVector{N}, H::AbstractHyperrectangle{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ H$</span>.</p><p><strong>Algorithm</strong></p><p>Let <span>$H$</span> be an <span>$n$</span>-dimensional hyperrectangular set, <span>$c_i$</span> and <span>$r_i$</span> be the box&#39;s center and radius and <span>$x_i$</span> be the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ H$</span> iff <span>$|c_i - x_i| ≤ r_i$</span> for all <span>$i=1,…,n$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractHyperrectangle.jl#L188-L208">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{AbstractHyperrectangle{Real}}" href="#LazySets.vertices_list-Tuple{AbstractHyperrectangle{Real}}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">vertices_list(H::AbstractHyperrectangle{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Notes</strong></p><p>For high dimensions, it is preferable to develop a <code>vertex_iterator</code> approach.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractHyperrectangle.jl#L37-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Tuple{AbstractHyperrectangle{Real}}" href="#LazySets.constraints_list-Tuple{AbstractHyperrectangle{Real}}"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">constraints_list(H::AbstractHyperrectangle{N})::Vector{LinearConstraint{N}}
    where {N&lt;:Real}</code></pre><p>Return the list of constraints of an axis-aligned hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A list of linear constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractHyperrectangle.jl#L64-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Tuple{AbstractHyperrectangle{Real}}" href="#LazySets.high-Tuple{AbstractHyperrectangle{Real}}"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">high(H::AbstractHyperrectangle{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the higher coordinates of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A vector with the higher coordinates of the hyperrectangular set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractHyperrectangle.jl#L224-L236">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Tuple{AbstractHyperrectangle{Real}}" href="#LazySets.low-Tuple{AbstractHyperrectangle{Real}}"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">low(H::AbstractHyperrectangle{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the lower coordinates of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A vector with the lower coordinates of the hyperrectangular set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractHyperrectangle.jl#L241-L253">source</a></section><h4><a class="nav-anchor" id="Singleton-1" href="#Singleton-1">Singleton</a></h4><p>A singleton is a special hyperrectangle consisting of only one point.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractSingleton" href="#LazySets.AbstractSingleton"><code>LazySets.AbstractSingleton</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractSingleton{N&lt;:Real} &lt;: AbstractHyperrectangle{N}</code></pre><p>Abstract type for sets with a single value.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractSingleton</code> must define the following functions:</p><ul><li><code>element(::AbstractSingleton{N})::Vector{N}</code> – return the single element</li><li><code>element(::AbstractSingleton{N}, i::Int)::N</code> – return the single element&#39;s   entry in the <code>i</code>-th dimension</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractSingleton)
2-element Array{Any,1}:
 Singleton
 ZeroSet</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractSingleton.jl#L8-L26">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">σ(d::AbstractVector{N}, S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The support vector, which is the set&#39;s vector itself, irrespective of the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractSingleton.jl#L175-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">∈(x::AbstractVector{N}, S::AbstractSingleton{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ S$</span>.</p><p><strong>Notes</strong></p><p>This implementation performs an exact comparison, which may be insufficient with floating point computations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractSingleton.jl#L195-L213">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">an_element(S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>An element of a convex set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/LazySet.jl#L177-L189">source</a><div><div><pre><code class="language-none">an_element(P::AbstractCentrallySymmetricPolytope{N})::Vector{N}
    where {N&lt;:Real}</code></pre><p>Return some element of a centrally symmetric polytope.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric polytope</li></ul><p><strong>Output</strong></p><p>The center of the centrally symmetric polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractCentrallySymmetricPolytope.jl#L62-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Tuple{AbstractSingleton{Real}}" href="#LazySets.center-Tuple{AbstractSingleton{Real}}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">center(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The only element of the set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractSingleton.jl#L110-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">vertices_list(S::AbstractSingleton{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A list containing only a single vertex.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractSingleton.jl#L131-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Tuple{AbstractSingleton{Real}}" href="#LazySets.radius_hyperrectangle-Tuple{AbstractSingleton{Real}}"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">radius_hyperrectangle(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the box radius of a set with a single value in every dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The zero vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractSingleton.jl#L52-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Tuple{AbstractSingleton{Real},Int64}" href="#LazySets.radius_hyperrectangle-Tuple{AbstractSingleton{Real},Int64}"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">radius_hyperrectangle(S::AbstractSingleton{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the box radius of a set with a single value in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>Zero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractSingleton.jl#L33-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{T,2} where T,AbstractSingleton{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{T,2} where T,AbstractSingleton{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">linear_map(M::AbstractMatrix, S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Concrete linear map of an abstract singleton.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>S</code> – abstract singleton</li></ul><p><strong>Output</strong></p><p>The abstract singleton of the same type of <span>$S$</span> obtained by applying the linear map to the element in <span>$S$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/bda62ac50aa77d9c61fa3323ed66c0dd1311a73b/src/AbstractSingleton.jl#L149-L163">source</a></section><footer><hr/><a class="previous" href="../man/concrete_polyhedra.html"><span class="direction">Previous</span><span class="title">Concrete Polyhedra</span></a><a class="next" href="representations.html"><span class="direction">Next</span><span class="title">Common Set Representations</span></a></footer></article></body></html>
