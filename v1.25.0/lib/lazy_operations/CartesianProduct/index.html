<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CartesianProduct · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link href="../../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../../"><img class="logo" src="../../../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../../man/getting_started/">Getting Started</a></li><li><a class="toctext" href="../../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="toctext" href="../../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="toctext" href="../../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="toctext" href="../../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="toctext" href="../../../man/interval_hulls/">Interval Hulls</a></li><li><a class="toctext" href="../../../man/convex_hulls/">Convex Hulls</a></li><li><a class="toctext" href="../../../man/set_operations/">Operations on Sets</a></li><li><a class="toctext" href="../../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="toctext" href="../../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="toctext" href="../../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="toctext" href="../../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../../interfaces/">Interfaces</a></li><li><span class="toctext">Sets</span><ul><li><a class="toctext" href="../../sets/Ball1/">Ball1</a></li><li><a class="toctext" href="../../sets/Ball2/">Ball2</a></li><li><a class="toctext" href="../../sets/BallInf/">BallInf</a></li><li><a class="toctext" href="../../sets/Ballp/">Ballp</a></li><li><a class="toctext" href="../../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="toctext" href="../../sets/EmptySet/">EmptySet</a></li><li><a class="toctext" href="../../sets/HalfSpace/">HalfSpace</a></li><li><a class="toctext" href="../../sets/HPolygon/">HPolygon</a></li><li><a class="toctext" href="../../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="toctext" href="../../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="toctext" href="../../sets/HPolytope/">HPolytope</a></li><li><a class="toctext" href="../../sets/Hyperplane/">Hyperplane</a></li><li><a class="toctext" href="../../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="toctext" href="../../sets/Interval/">Interval</a></li><li><a class="toctext" href="../../sets/Line/">Line</a></li><li><a class="toctext" href="../../sets/LineSegment/">LineSegment</a></li><li><a class="toctext" href="../../sets/PolynomialZonotope/">PolynomialZonotope</a></li><li><a class="toctext" href="../../sets/Singleton/">Singleton</a></li><li><a class="toctext" href="../../sets/Universe/">Universe</a></li><li><a class="toctext" href="../../sets/VPolygon/">VPolygon</a></li><li><a class="toctext" href="../../sets/VPolytope/">VPolytope</a></li><li><a class="toctext" href="../../sets/ZeroSet/">ZeroSet</a></li><li><a class="toctext" href="../../sets/Zonotope/">Zonotope</a></li></ul></li><li><span class="toctext">Lazy Operations</span><ul><li><a class="toctext" href="../AffineMap/">AffineMap</a></li><li><a class="toctext" href="../Bloating/">Bloating</a></li><li class="current"><a class="toctext" href>CartesianProduct</a><ul class="internal"><li><a class="toctext" href="#def_CartesianProduct-1">Binary Cartesian product (CartesianProduct)</a></li><li><a class="toctext" href="#def_CartesianProductArray-1"><span>$n$</span>-ary Cartesian product (CartesianProductArray)</a></li></ul></li><li><a class="toctext" href="../Complement/">Complement</a></li><li><a class="toctext" href="../ConvexHull/">ConvexHull</a></li><li><a class="toctext" href="../ExponentialMap/">ExponentialMap</a></li><li><a class="toctext" href="../Intersection/">Intersection</a></li><li><a class="toctext" href="../LinearMap/">LinearMap</a></li><li><a class="toctext" href="../MinkowskiSum/">MinkowskiSum</a></li><li><a class="toctext" href="../Rectification/">Rectification</a></li><li><a class="toctext" href="../ResetMap/">ResetMap</a></li><li><a class="toctext" href="../SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="toctext" href="../Translation/">Translation</a></li><li><a class="toctext" href="../UnionSet/">UnionSet</a></li></ul></li><li><a class="toctext" href="../../binary_functions/">Concrete Operations</a></li><li><a class="toctext" href="../../conversion/">Conversions between set representations</a></li><li><a class="toctext" href="../../comparisons/">Comparisons</a></li><li><a class="toctext" href="../../approximations/">Approximations</a></li><li><a class="toctext" href="../../utils/">Utility Functions</a></li><li><a class="toctext" href="../../parallel/">Parallel</a></li></ul></li><li><a class="toctext" href="../../../about/">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li>Lazy Operations</li><li><a href>CartesianProduct</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/lazy_operations/CartesianProduct.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>CartesianProduct</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Cartesian-product-1" href="#Cartesian-product-1">Cartesian product</a></h1><h2><a class="nav-anchor" id="def_CartesianProduct-1" href="#def_CartesianProduct-1">Binary Cartesian product (CartesianProduct)</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CartesianProduct" href="#LazySets.CartesianProduct"><code>LazySets.CartesianProduct</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CartesianProduct{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents a Cartesian product of two convex sets.</p><p><strong>Fields</strong></p><ul><li><code>X</code> – first convex set</li><li><code>Y</code> – second convex set</li></ul><p><strong>Notes</strong></p><p>The Cartesian product of three elements is obtained recursively. See also <code>CartesianProductArray</code> for an implementation of a Cartesian product of many sets without recursion, instead using an array.</p><p>The <code>EmptySet</code> is the absorbing element for <code>CartesianProduct</code>.</p><p><strong>Examples</strong></p><p>The Cartesian product between two sets <code>X</code> and <code>Y</code> can be constructed either using <code>CartesianProduct(X, Y)</code> or the short-cut notation <code>X × Y</code>:</p><pre><code class="language-julia-repl">julia&gt; I1 = Interval(0, 1);

julia&gt; I2 = Interval(2, 4);

julia&gt; I12 = I1 × I2;

julia&gt; typeof(I12)
CartesianProduct{Float64,Interval{Float64,IntervalArithmetic.Interval{Float64}},Interval{Float64,IntervalArithmetic.Interval{Float64}}}</code></pre><p>A hyperrectangle is the cartesian product of intervals, so we can convert <code>I12</code> exactly to a <code>Hyperrectangle</code> type:</p><pre><code class="language-julia-repl">julia&gt; convert(Hyperrectangle, I12)
Hyperrectangle{Float64,Array{Float64,1},Array{Float64,1}}([0.5, 3.0], [0.5, 1.0])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProduct.jl#L7-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.:×-Tuple{LazySet,LazySet}" href="#LinearAlgebra.:×-Tuple{LazySet,LazySet}"><code>LinearAlgebra.:×</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">×</code></pre><p>Alias for the binary Cartesian product.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProduct.jl#L68-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{LazySet,LazySet}" href="#Base.:*-Tuple{LazySet,LazySet}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">    *(X::LazySet, Y::LazySet)</code></pre><p>Alias for the binary Cartesian product.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProduct.jl#L59-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.swap-Tuple{CartesianProduct}" href="#LazySets.swap-Tuple{CartesianProduct}"><code>LazySets.swap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">swap(cp::CartesianProduct)</code></pre><p>Return a new <code>CartesianProduct</code> object with the arguments swapped.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product of two convex sets</li></ul><p><strong>Output</strong></p><p>A new <code>CartesianProduct</code> object with the arguments swapped.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProduct.jl#L75-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{CartesianProduct}" href="#LazySets.dim-Tuple{CartesianProduct}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(cp::CartesianProduct)::Int</code></pre><p>Return the dimension of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Cartesian product.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProduct.jl#L92-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, cp::CartesianProduct{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>The support function in the given direction. If the direction has norm zero, the result depends on the wrapped sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProduct.jl#L129-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, cp::CartesianProduct{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProduct.jl#L109-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{CartesianProduct}" href="#LazySets.isbounded-Tuple{CartesianProduct}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(cp::CartesianProduct)::Bool</code></pre><p>Determine whether a Cartesian product is bounded.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff both wrapped sets are bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProduct.jl#L149-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, cp::CartesianProduct{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>x</code>  – point/vector</li><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ cp$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProduct.jl#L166-L179">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{CartesianProduct}" href="#Base.isempty-Tuple{CartesianProduct}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(cp::CartesianProduct)::Bool</code></pre><p>Return if a Cartesian product is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the sub-blocks is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProduct.jl#L188-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(cp::CartesianProduct{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of a (polyhedral) Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>A list of constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProduct.jl#L205-L217">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(cp::CartesianProduct{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a (polytopic) Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProduct.jl#L222-L240">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},CartesianProduct{N,S1,S2} where S2&lt;:LazySet{N} where S1&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, cp::CartesianProduct{N}) where {N&lt;:Real}</code></pre><p>Concrete linear map of a (polyhedral) Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>M</code>  – matrix</li><li><code>cp</code> – Cartesian product of two convex sets</li></ul><p><strong>Output</strong></p><p>A polytope.</p><p><strong>Algorithm</strong></p><p>We check if the matrix is invertible. If so, we convert the Cartesian product to constraint representation. Otherwise, we convert the Cartesian product to vertex representation. In both cases, we then call <code>linear_map</code> on the resulting polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProduct.jl#L259-L279">source</a></section><p>Inherited from <a href="../../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h2><a class="nav-anchor" id="def_CartesianProductArray-1" href="#def_CartesianProductArray-1"><span>$n$</span>-ary Cartesian product (CartesianProductArray)</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CartesianProductArray" href="#LazySets.CartesianProductArray"><code>LazySets.CartesianProductArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>CartesianProductArray{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</p><p>Type that represents the Cartesian product of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><code>array</code> – array of sets</li></ul><p><strong>Notes</strong></p><p>The <code>EmptySet</code> is the absorbing element for <code>CartesianProductArray</code>.</p><p>Constructors:</p><ul><li><p><code>CartesianProductArray(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>CartesianProductArray([n]::Int=0, [N]::Type=Float64)</code></p></li></ul><p>– constructor for an empty product with optional size hint and numeric type</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProductArray.jl#L11-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{CartesianProductArray}" href="#LazySets.dim-Tuple{CartesianProductArray}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>dim(cpa::CartesianProductArray)::Int</p><p>Return the dimension of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Cartesian product of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProductArray.jl#L70-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>ρ(d::AbstractVector{N}, cp::CartesianProductArray{N}) where {N&lt;:Real}</p><p>Return the support function of a Cartesian product array.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The support function in the given direction. If the direction has norm zero, the result depends on the wrapped sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProductArray.jl#L154-L168">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>σ(d::AbstractVector{N}, cpa::CartesianProductArray{N}) where {N&lt;:Real}</p><p>Support vector of a Cartesian product array.</p><p><strong>Input</strong></p><ul><li><code>d</code>   – direction</li><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the product sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProductArray.jl#L88-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{CartesianProductArray}" href="#LazySets.isbounded-Tuple{CartesianProductArray}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>isbounded(cpa::CartesianProductArray)::Bool</p><p>Determine whether a Cartesian product of a finite number of convex sets is bounded.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p><code>true</code> iff all wrapped sets are bounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProductArray.jl#L216-L229">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>∈(x::AbstractVector{N}, cpa::CartesianProductArray{N}     )::Bool where {N&lt;:Real}</p><p>Check whether a given point is contained in a Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>x</code>   – point/vector</li><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ \text{cpa}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProductArray.jl#L234-L249">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{CartesianProductArray}" href="#Base.isempty-Tuple{CartesianProductArray}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>isempty(cpa::CartesianProductArray)::Bool</p><p>Return if a Cartesian product is empty or not.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p><code>true</code> iff any of the sub-blocks is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProductArray.jl#L265-L277">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>constraints_list(cpa::CartesianProductArray{N}) where {N&lt;:Real}</p><p>Return the list of constraints of a (polyhedral) Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A list of constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProductArray.jl#L282-L295">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>vertices_list(cpa::CartesianProductArray{N}                 )::Vector{Vector{N}} where {N&lt;:Real}</p><p>Return the list of vertices of a (polytopic) Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProductArray.jl#L317-L337">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},CartesianProductArray{N,S} where S&lt;:LazySet{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>linear_map(M::AbstractMatrix{N}, cpa::CartesianProductArray{N}              ) where {N&lt;:Real}</p><p>Concrete linear map of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>M</code>   – matrix</li><li><code>cpa</code> – Cartesian product of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>A polytope.</p><p><strong>Algorithm</strong></p><p>We check if the matrix is invertible. If so, we convert the Cartesian product to constraint representation. Otherwise, we convert the Cartesian product to vertex representation. In both cases, we then call <code>linear_map</code> on the resulting polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProductArray.jl#L558-L579">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.array-Union{Tuple{CartesianProductArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real" href="#LazySets.array-Union{Tuple{CartesianProductArray{N,S}}, Tuple{S}, Tuple{N}} where S&lt;:LazySet{N} where N&lt;:Real"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>array(cpa::CartesianProductArray{N, S}         )::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</p><p>Return the array of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>The array of a Cartesian product of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProductArray.jl#L51-L64">source</a><div><div><pre><code class="language-none">array(cha::ConvexHullArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cha</code> – convex hull array</li></ul><p><strong>Output</strong></p><p>The array of a convex hull of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/ConvexHullArray.jl#L70-L82">source</a><div><div><p>array(ia::IntersectionArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</p><p>Return the array of an intersection of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array of an intersection of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/IntersectionArray.jl#L53-L65">source</a><div><div><p>array(msa::MinkowskiSumArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</p><p>Return the array of a Minkowski sum of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>msa</code> – Minkowski sum array</li></ul><p><strong>Output</strong></p><p>The array of a Minkowski sum of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/MinkowskiSumArray.jl#L55-L67">source</a><div><div><pre><code class="language-none">array(cms::CacheMinkowskiSum{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><code>cms</code> – caching Minkowski sum</li></ul><p><strong>Output</strong></p><p>The array of a caching Minkowski sum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CacheMinkowskiSum.jl#L94-L106">source</a><div><div><p>array(cup::UnionSetArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</p><p>Return the array of a union of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><code>cup</code> – union of a finite number of convex sets</li></ul><p><strong>Output</strong></p><p>The array that holds the union of a finite number of convex sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/UnionSetArray.jl#L50-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.block_structure-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N" href="#LazySets.block_structure-Union{Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N}}, Tuple{N}} where N"><code>LazySets.block_structure</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>block_structure(cpa::CartesianProductArray{N}) where {N}</p><p>Returns an array containing the dimension ranges of each block in a <code>CartesianProductArray</code>.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A vector of ranges</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using LazySets: block_structure

julia&gt; cpa = CartesianProductArray([BallInf(zeros(n), 1.0) for n in [3, 1, 2]]);

julia&gt; block_structure(cpa)
3-element Array{UnitRange{Int64},1}:
 1:3
 4:4
 5:6</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProductArray.jl#L416-L442">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.block_to_dimension_indices-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N},Array{Int64,1}}} where N" href="#LazySets.block_to_dimension_indices-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N},Array{Int64,1}}} where N"><code>LazySets.block_to_dimension_indices</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>block<em>to</em>dimension_indices(cpa::CartesianProductArray{N}, vars::Vector{Int}) where {N}</p><p>Returns a vector mapping block index <code>i</code> to tuple <code>(f, l)</code> such that either <code>f = l = -1</code> or <code>f</code> is the first dimension index and <code>l</code> is the last dimension index of the <code>i</code>-th block, depending on whether one of the block&#39;s dimension indices is specified in <code>vars</code>.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li><li><code>vars</code> – list containing the variables of interest, sorted in ascending order</li></ul><p><strong>Output</strong></p><p>(i) A vector of tuples, where values in tuple relate to range of dimensions in the i-th block. (ii) Number of constrained blocks</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using LazySets: block_to_dimension_indices

julia&gt; cpa = CartesianProductArray([BallInf(zeros(n), 1.0) for n in [1, 3, 2, 3]]);

julia&gt; block_to_dimension_indices(cpa, [2, 4, 8])
(Tuple{Int64,Int64}[(-1, -1), (2, 4), (-1, -1), (7, 9)], 2)</code></pre><p>This vector represents the mapping &quot;second block from dimension 2 to dimension 4, fourth block from dimension 7 to dimension 9.&quot; These blocks contain the dimensions specified in <code>[2, 4, 8]</code>. Number of constrained variables here is 2 (2nd and 4th blocks)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProductArray.jl#L455-L486">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.substitute_blocks-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N},CartesianProductArray{N,S} where S&lt;:LazySet{N},Array{Tuple{Int64,Int64},1}}} where N" href="#LazySets.substitute_blocks-Union{Tuple{N}, Tuple{CartesianProductArray{N,S} where S&lt;:LazySet{N},CartesianProductArray{N,S} where S&lt;:LazySet{N},Array{Tuple{Int64,Int64},1}}} where N"><code>LazySets.substitute_blocks</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>substitute<em>blocks(low</em>dim<em>cpa::CartesianProductArray{N},                         orig</em>cpa::CartesianProductArray{N},                           blocks::Vector{Tuple{Int,Int}}) where {N}</p><p>Return merged Cartesian Product Array between original CPA and some low-dimensional CPA, which represents updated subset of variables in specified blocks.</p><p><strong>Input</strong></p><ul><li><code>low_dim_cpa</code> – low-dimensional cartesian product array</li><li><code>orig_cpa</code> – original high-dimensional Cartesian product array</li><li><code>blocks</code> – index of the first variable in each block of <code>orig_cpa</code></li></ul><p><strong>Output</strong></p><p>Merged cartesian product array</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/e9061d3cc1e21bce03bc9b9959ebe3236285e488/src/LazyOperations/CartesianProductArray.jl#L522-L539">source</a></section><p>Inherited from <a href="../../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../../interfaces/#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><footer><hr/><a class="previous" href="../Bloating/"><span class="direction">Previous</span><span class="title">Bloating</span></a><a class="next" href="../Complement/"><span class="direction">Next</span><span class="title">Complement</span></a></footer></article></body></html>
