<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Set Interfaces · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/getting_started.html">Getting Started</a></li><li><a class="toctext" href="../man/polyhedral_approximations.html">Polyhedral Approximations</a></li><li><a class="toctext" href="../man/decompose_example.html">Decomposing an Affine Map</a></li><li><a class="toctext" href="../man/fast_2d_LPs.html">Fast 2D LPs</a></li><li><a class="toctext" href="../man/iterative_refinement.html">Iterative Refinement</a></li><li><a class="toctext" href="../man/interval_hulls.html">Interval Hulls</a></li><li><a class="toctext" href="../man/convex_hulls.html">Convex Hulls</a></li><li><a class="toctext" href="../man/set_operations.html">Operations on Sets</a></li><li><a class="toctext" href="../man/reach_zonotopes.html">A Reachability Algorithm</a></li><li><a class="toctext" href="../man/reach_zonotopes_hybrid.html">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../man/concrete_polyhedra.html">Concrete Polyhedra</a></li><li><a class="toctext" href="../man/parallel_approximations.html">Parallel Approximations</a></li></ul></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href="interfaces.html">Set Interfaces</a><ul class="internal"><li><a class="toctext" href="#LazySet-1">LazySet</a></li><li><a class="toctext" href="#Centrally-symmetric-set-1">Centrally symmetric set</a></li><li><a class="toctext" href="#Polyhedron-1">Polyhedron</a></li></ul></li><li><a class="toctext" href="representations.html">Common Set Representations</a></li><li><a class="toctext" href="operations.html">Common Set Operations</a></li><li><a class="toctext" href="comparisons.html">Comparisons</a></li><li><a class="toctext" href="conversion.html">Conversions between set representations</a></li><li><a class="toctext" href="binary_functions.html">Binary Functions on Sets</a></li><li><a class="toctext" href="approximations.html">Approximations</a></li><li><a class="toctext" href="utils.html">Utility Functions</a></li><li><a class="toctext" href="parallel.html">Parallel</a></li></ul></li><li><a class="toctext" href="../about.html">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="interfaces.html">Set Interfaces</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/interfaces.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Set Interfaces</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Set-Interfaces-1" href="#Set-Interfaces-1">Set Interfaces</a></h1><p>This section of the manual describes the interfaces for different set types. Every set that fits the description of an interface should also implement it. This helps in several ways:</p><ul><li>avoid code duplicates,</li><li>provide functions for many sets at once,</li><li>allow changes in the source code without changing the API.</li></ul><p>The interface functions are outlined in the interface documentation. See <a href="representations.html#Common-Set-Representations-1">Common Set Representations</a> for implementations of the interfaces.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The naming convention is such that all interface names (with the exception of the main abstract type <code>LazySet</code>) should be preceded by <code>Abstract</code>.</p></div></div><p>The following diagram shows the interface hierarchy.</p><p><img src="../assets/interfaces.png" alt="../assets/interfaces.png"/></p><ul><li><a href="interfaces.html#Set-Interfaces-1">Set Interfaces</a></li><ul><li><a href="interfaces.html#LazySet-1">LazySet</a></li><ul><li><a href="interfaces.html#Support-function-and-support-vector-1">Support function and support vector</a></li><li><a href="interfaces.html#Other-globally-defined-set-functions-1">Other globally defined set functions</a></li><li><a href="interfaces.html#Set-functions-that-override-Base-functions-1">Set functions that override Base functions</a></li><li><a href="interfaces.html#Aliases-for-set-types-1">Aliases for set types</a></li></ul><li><a href="interfaces.html#Centrally-symmetric-set-1">Centrally symmetric set</a></li><li><a href="interfaces.html#Polyhedron-1">Polyhedron</a></li><ul><li><a href="interfaces.html#Polytope-1">Polytope</a></li><ul><li><a href="interfaces.html#Polygon-1">Polygon</a></li><li><a href="interfaces.html#Centrally-symmetric-polytope-1">Centrally symmetric polytope</a></li></ul></ul></ul></ul><h2><a class="nav-anchor" id="LazySet-1" href="#LazySet-1">LazySet</a></h2><p>Every convex set in this library implements this interface.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.LazySet" href="#LazySets.LazySet"><code>LazySets.LazySet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LazySet{N}</code></pre><p>Abstract type for convex sets, i.e., sets characterized by a (possibly infinite) intersection of halfspaces, or equivalently, sets <span>$S$</span> such that for any two elements <span>$x, y ∈ S$</span> and <span>$0 ≤ λ ≤ 1$</span> it holds that <span>$λ·x + (1-λ)·y ∈ S$</span>.</p><p><strong>Notes</strong></p><p><code>LazySet</code> types should be parameterized with a type <code>N</code>, typically <code>N&lt;:Real</code>, for using different numeric types.</p><p>Every concrete <code>LazySet</code> must define the following functions:</p><ul><li><code>σ(d::AbstractVector{N}, S::LazySet{N}) where {N&lt;:Real}</code> – the support vector   of <code>S</code> in a given direction <code>d</code>; note that the numeric type <code>N</code> of <code>d</code> and   <code>S</code> must be identical; for some set types <code>N</code> may be more restrictive than   <code>Real</code></li><li><code>dim(S::LazySet)::Int</code> – the ambient dimension of <code>S</code></li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(LazySet)
15-element Array{Any,1}:
 AbstractCentrallySymmetric
 AbstractPolyhedron
 CacheMinkowskiSum
 CartesianProduct
 CartesianProductArray
 ConvexHull
 ConvexHullArray
 EmptySet
 ExponentialMap
 ExponentialProjectionMap
 Intersection
 IntersectionArray
 LinearMap
 MinkowskiSum
 MinkowskiSumArray</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/LazySet.jl#L16-L54">source</a></section><h3><a class="nav-anchor" id="Support-function-and-support-vector-1" href="#Support-function-and-support-vector-1">Support function and support vector</a></h3><p>Every <code>LazySet</code> type must define a function <code>σ</code> to compute the support vector.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.support_vector" href="#LazySets.support_vector"><code>LazySets.support_vector</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">support_vector</code></pre><p>Alias for the support vector σ.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/LazySet.jl#L97-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LazySet{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LazySet{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ρ(d::AbstractVector{N}, S::LazySet{N})::N where {N&lt;:Real}</code></pre><p>Evaluate the support function of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>The support function of the set <code>S</code> for the direction <code>d</code>.</p><p><strong>Notes</strong></p><p>The numeric type of the direction and the set must be identical.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/LazySet.jl#L61-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.support_function" href="#LazySets.support_function"><code>LazySets.support_function</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">support_function</code></pre><p>Alias for the support function ρ.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/LazySet.jl#L83-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ" href="#LazySets.σ"><code>LazySets.σ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">σ</code></pre><p>Function to compute the support vector σ.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/LazySet.jl#L90-L94">source</a></section><h3><a class="nav-anchor" id="Other-globally-defined-set-functions-1" href="#Other-globally-defined-set-functions-1">Other globally defined set functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">norm(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the norm of a convex set. It is the norm of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/LazySet.jl#L156-L171">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius" href="#LazySets.radius"><code>LazySets.radius</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">radius(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the radius of a convex set. It is the radius of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/LazySet.jl#L180-L195">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.diameter" href="#LazySets.diameter"><code>LazySets.diameter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">diameter(S::LazySet, [p]::Real=Inf)</code></pre><p>Return the diameter of a convex set. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/LazySet.jl#L204-L220">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{LazySet}" href="#LazySets.isbounded-Tuple{LazySet}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isbounded(S::LazySet)::Bool</code></pre><p>Determine whether a set is bounded.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set is bounded.</p><p><strong>Algorithm</strong></p><p>We check boundedness via <a href="interfaces.html#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>isbounded_unit_dimensions</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/LazySet.jl#L104-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.isbounded_unit_dimensions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isbounded_unit_dimensions(S::LazySet{N})::Bool where {N&lt;:Real}</code></pre><p>Determine whether a set is bounded in each unit dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the set is bounded in each unit dimension.</p><p><strong>Algorithm</strong></p><p>This function performs <span>$2n$</span> support function checks, where <span>$n$</span> is the ambient dimension of <code>S</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/LazySet.jl#L125-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">an_element(S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>An element of a convex set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/LazySet.jl#L226-L238">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{Dict{Symbol,Any},LazySet}" href="#RecipesBase.apply_recipe-Tuple{Dict{Symbol,Any},LazySet}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">plot_lazyset(S::LazySet; ...)</code></pre><p>Plot a convex set in two dimensions using an axis-aligned approximation.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Plots, LazySets

julia&gt; B = BallInf(ones(2), 0.1);

julia&gt; plot(2.0 * B);
</code></pre><p><strong>Algorithm</strong></p><p>For any 2D lazy set we compute its box overapproximation, followed by the list of vertices. A post-processing <code>convex_hull</code> is applied to the vertices list; this ensures that the shaded area inside the convex hull of the vertices is covered correctly.</p><p><strong>Notes</strong></p><p>This recipe detects if the axis-aligned approximation is such that the first two vertices returned by <code>vertices_list</code> are the same. In that case, a scatter plot is used (instead of a shape plot). This use case arises, for example, when plotting singletons.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/plot_recipes.jl#L7-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{S}, Tuple{Dict{Symbol,Any},Array{S,1}}} where S&lt;:LazySet" href="#RecipesBase.apply_recipe-Union{Tuple{S}, Tuple{Dict{Symbol,Any},Array{S,1}}} where S&lt;:LazySet"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">plot_lazyset(Xk::Vector{S}) where {S&lt;:LazySet}</code></pre><p>Plot an array of convex sets in two dimensions using an axis-aligned approximation.</p><p><strong>Input</strong></p><ul><li><code>Xk</code> – array of convex sets</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Plots, LazySets;

julia&gt; B1 = BallInf(zeros(2), 0.4);

julia&gt; B2 = BallInf(ones(2), 0.4);

julia&gt; plot([B1, B2]);
</code></pre><p><strong>Algorithm</strong></p><p>For each 2D lazy set in the array we compute its box overapproximation, followed by the list of vertices. A post-processing <code>convex_hull</code> is applied to the vertices list; this ensures that the shaded area inside the convex hull of the vertices is covered correctly.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/plot_recipes.jl#L59-L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{Dict{Symbol,Any},LazySet,Float64}" href="#RecipesBase.apply_recipe-Tuple{Dict{Symbol,Any},LazySet,Float64}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">plot_lazyset(S::LazySet, ε::Float64; ...)</code></pre><p>Plot a lazy set in two dimensions using iterative refinement.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li><li><code>ε</code> – approximation error bound</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Plots, LazySets;

julia&gt; B = BallInf(ones(2), 0.1);

julia&gt; plot(randn(2, 2) * B, 1e-3);
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/plot_recipes.jl#L109-L129">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{S}, Tuple{Dict{Symbol,Any},Array{S,1},Float64}} where S&lt;:LazySet" href="#RecipesBase.apply_recipe-Union{Tuple{S}, Tuple{Dict{Symbol,Any},Array{S,1},Float64}} where S&lt;:LazySet"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">plot_lazyset(Xk::Vector{S}, ε::Float64; ...) where {S&lt;:LazySet}</code></pre><p>Plot an array of lazy sets in two dimensions using iterative refinement.</p><p><strong>Input</strong></p><ul><li><code>Xk</code> – array of convex sets</li><li><code>ε</code>  – approximation error bound</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Plots, LazySets;

julia&gt; B1 = BallInf(zeros(2), 0.4);

julia&gt; B2 = Ball2(ones(2), 0.4);

julia&gt; plot([B1, B2], 1e-4);
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/plot_recipes.jl#L147-L169">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tosimplehrep-Tuple{LazySet}" href="#LazySets.tosimplehrep-Tuple{LazySet}"><code>LazySets.tosimplehrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tosimplehrep(S::LazySet)</code></pre><p>Return the simple H-representation <span>$Ax ≤ b$</span> of a set from its list of linear constraints.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p>The tuple <code>(A, b)</code> where <code>A</code> is the matrix of normal directions and <code>b</code> is the vector of offsets.</p><p><strong>Notes</strong></p><p>This function only works for sets that can be represented exactly by a finite list of linear constraints. This fallback implementation relies on <code>constraints_list(S)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/LazySet.jl#L321-L341">source</a></section><h3><a class="nav-anchor" id="Set-functions-that-override-Base-functions-1" href="#Set-functions-that-override-Base-functions-1">Set functions that override Base functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Tuple{LazySet,LazySet}" href="#Base.:==-Tuple{LazySet,LazySet}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">==(X::LazySet, Y::LazySet)</code></pre><p>Return whether two LazySets of the same type are exactly equal by recursively comparing their fields until a mismatch is found.</p><p><strong>Input</strong></p><ul><li><code>X</code> – any <code>LazySet</code></li><li><code>Y</code> – another <code>LazySet</code> of the same type as <code>X</code></li></ul><p><strong>Output</strong></p><ul><li><code>true</code> iff <code>X</code> is equal to <code>Y</code>.</li></ul><p><strong>Notes</strong></p><p>The check is purely syntactic and the sets need to have the same base type. I.e. <code>X::VPolytope == Y::HPolytope</code> returns <code>false</code> even if <code>X</code> and <code>Y</code> represent the same polytope. However <code>X::HPolytope{Int64} == Y::HPolytope{Float64}</code> is a valid comparison.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; HalfSpace([1], 1) == HalfSpace([1], 1)
true

julia&gt; HalfSpace([1], 1) == HalfSpace([1.0], 1.0)
true

julia&gt; Ball1([0.], 1.) == Ball2([0.], 1.)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/LazySet.jl#L244-L276">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy-Tuple{LazySet}" href="#Base.copy-Tuple{LazySet}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">copy(S::LazySet)</code></pre><p>Return a deep copy of the given set by copying its values recursively.</p><p><strong>Input</strong></p><ul><li><code>S</code> – any <code>LazySet</code></li></ul><p><strong>Output</strong></p><p>A copy of <code>S</code>.</p><p><strong>Notes</strong></p><p>This function performs a <code>deepcopy</code> of each field in <code>S</code>, resulting in a completely independent object. See the documentation of <code>?deepcopy</code> for further details.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/LazySet.jl#L300-L318">source</a></section><h3><a class="nav-anchor" id="Aliases-for-set-types-1" href="#Aliases-for-set-types-1">Aliases for set types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CompactSet" href="#LazySets.CompactSet"><code>LazySets.CompactSet</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">CompactSet</code></pre><p>An alias for compact set types.</p><p><strong>Notes</strong></p><p>Most lazy operations are not captured by this alias because whether their result is compact or not depends on the argument(s).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/aliases.jl#L4-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.NonCompactSet" href="#LazySets.NonCompactSet"><code>LazySets.NonCompactSet</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">NonCompactSet</code></pre><p>An alias for non-compact set types.</p><p><strong>Notes</strong></p><p>Most lazy operations are not captured by this alias because whether their result is non-compact or not depends on the argument(s).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/aliases.jl#L20-L29">source</a></section><h2><a class="nav-anchor" id="Centrally-symmetric-set-1" href="#Centrally-symmetric-set-1">Centrally symmetric set</a></h2><p>Centrally symmetric sets such as balls of different norms are characterized by a center. Note that there is a special interface combination <a href="interfaces.html#Centrally-symmetric-polytope-1">Centrally symmetric polytope</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractCentrallySymmetric" href="#LazySets.AbstractCentrallySymmetric"><code>LazySets.AbstractCentrallySymmetric</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractCentrallySymmetric{N&lt;:Real} &lt;: LazySet{N}</code></pre><p>Abstract type for centrally symmetric sets.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractCentrallySymmetric</code> must define the following functions:</p><ul><li><code>center(::AbstractCentrallySymmetric{N})::Vector{N}</code> – return the center   point</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractCentrallySymmetric)
3-element Array{Any,1}:
 Ball2
 Ballp
 Ellipsoid</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractCentrallySymmetric.jl#L7-L26">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractCentrallySymmetric}" href="#LazySets.dim-Tuple{AbstractCentrallySymmetric}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dim(S::AbstractCentrallySymmetric)::Int</code></pre><p>Return the ambient dimension of a centrally symmetric set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractCentrallySymmetric.jl#L30-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{AbstractCentrallySymmetric}" href="#LazySets.isbounded-Tuple{AbstractCentrallySymmetric}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isbounded(S::AbstractCentrallySymmetric)::Bool</code></pre><p>Determine whether a centrally symmetric set is bounded.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p><code>true</code> (since a set with a unique center must be bounded).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractCentrallySymmetric.jl#L47-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">an_element(S::AbstractCentrallySymmetric{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a centrally symmetric set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p>The center of the centrally symmetric set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractCentrallySymmetric.jl#L64-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{AbstractCentrallySymmetric}" href="#Base.isempty-Tuple{AbstractCentrallySymmetric}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isempty(S::AbstractCentrallySymmetric)::Bool</code></pre><p>Return if a centrally symmetric set is empty or not.</p><p><strong>Input</strong></p><ul><li><code>S</code> – centrally symmetric set</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractCentrallySymmetric.jl#L81-L93">source</a></section><h2><a class="nav-anchor" id="Polyhedron-1" href="#Polyhedron-1">Polyhedron</a></h2><p>A polyhedron has finitely many facets (<em>H-representation</em>) and is not necessarily bounded.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractPolyhedron" href="#LazySets.AbstractPolyhedron"><code>LazySets.AbstractPolyhedron</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractPolyhedron{N&lt;:Real} &lt;: LazySet{N}</code></pre><p>Abstract type for polyhedral sets, i.e., sets with finitely many flat facets, or equivalently, sets defined as an intersection of a finite number of half-spaces.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolyhedron</code> must define the following functions:</p><ul><li><code>constraints_list(::AbstractPolyhedron{N})::Vector{LinearConstraint{N}}</code> –   return a list of all facet constraints</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolyhedron)
5-element Array{Any,1}:
 AbstractPolytope
 HPolyhedron
 HalfSpace
 Hyperplane
 Line</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractPolyhedron.jl#L3-L24">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractPolyhedron{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractPolyhedron{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">∈(x::AbstractVector{N}, P::AbstractPolyhedron{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a polyhedron.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>P</code> – polyhedron</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation checks if the point lies inside each defining half-space.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractPolyhedron_functions.jl#L8-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constrained_dimensions-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constrained_dimensions-Union{Tuple{AbstractPolyhedron{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constrained_dimensions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">constrained_dimensions(P::AbstractPolyhedron{N})::Vector{Int}
    where {N&lt;:Real}</code></pre><p>Return the indices in which a polyhedron is constrained.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polyhedron</li></ul><p><strong>Output</strong></p><p>A vector of ascending indices <code>i</code> such that the polyhedron is constrained in dimension <code>i</code>.</p><p><strong>Examples</strong></p><p>A 2D polyhedron with constraint <span>$x1 ≥ 0$</span> is constrained in dimension 1 only.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractPolyhedron_functions.jl#L38-L56">source</a></section><h3><a class="nav-anchor" id="Polytope-1" href="#Polytope-1">Polytope</a></h3><p>A polytope is a bounded set with finitely many vertices (<em>V-representation</em>) resp. facets (<em>H-representation</em>). Note that there is a special interface combination <a href="interfaces.html#Centrally-symmetric-polytope-1">Centrally symmetric polytope</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractPolytope" href="#LazySets.AbstractPolytope"><code>LazySets.AbstractPolytope</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractPolytope{N&lt;:Real} &lt;: AbstractPolyhedron{N}</code></pre><p>Abstract type for polytopic sets, i.e., bounded sets with finitely many flat facets, or equivalently, bounded sets defined as an intersection of a finite number of half-spaces, or equivalently, bounded sets with finitely many vertices.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolytope</code> must define the following functions:</p><ul><li><code>constraints_list(::AbstractPolytope{N})::Vector{LinearConstraint{N}}</code> –   return a list of all facet constraints</li><li><code>vertices_list(::AbstractPolytope{N})::Vector{Vector{N}}</code> – return a list of   all vertices</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolytope)
4-element Array{Any,1}:
 AbstractCentrallySymmetricPolytope
 AbstractPolygon
 HPolytope
 VPolytope</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractPolytope.jl#L9-L33">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{AbstractPolytope}" href="#LazySets.isbounded-Tuple{AbstractPolytope}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isbounded(P::AbstractPolytope)::Bool</code></pre><p>Determine whether a polytopic set is bounded.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polytopic set</li></ul><p><strong>Output</strong></p><p><code>true</code> (since a polytope must be bounded).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractPolytope.jl#L40-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">singleton_list(P::AbstractPolytope{N})::Vector{Singleton{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a polytopic set as a list of singletons.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polytopic set</li></ul><p><strong>Output</strong></p><p>List containing a singleton for each vertex.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractPolytope.jl#L57-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolytope{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolytope{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">linear_map(M::AbstractMatrix{N}, P::AbstractPolytope{N};
           output_type::Type{&lt;:LazySet}=VPolytope{N}) where {N&lt;:Real}</code></pre><p>Concrete linear map of an abstract polytype.</p><p><strong>Input</strong></p><ul><li><code>M</code>           – matrix</li><li><code>P</code>           – abstract polytype</li><li><code>output_type</code> – (optional, default: <code>VPolytope</code>) type of the result</li></ul><p><strong>Output</strong></p><p>A set of type <code>output_type</code>.</p><p><strong>Algorithm</strong></p><p>The linear map <span>$M$</span> is applied to each vertex of the given set <span>$P$</span>, obtaining a polytope in V-representation. Since some set representations (e.g. axis-aligned hyperrectangles) are not closed under linear maps, the default output is a <code>VPolytope</code>. If an <code>output_type</code> is given, the corresponding <code>convert</code> method is invoked.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractPolytope.jl#L75-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{AbstractPolytope}" href="#Base.isempty-Tuple{AbstractPolytope}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isempty(P::AbstractPolytope)::Bool</code></pre><p>Determine whether a polytope is empty.</p><p><strong>Input</strong></p><ul><li><code>P</code> – abstract polytope</li></ul><p><strong>Output</strong></p><p><code>true</code> if the given polytope contains no vertices, and <code>false</code> otherwise.</p><p><strong>Algorithm</strong></p><p>This algorithm checks whether the <code>vertices_list</code> of the given polytope is empty or not.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractPolytope.jl#L106-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{Dict{Symbol,Any},AbstractPolytope}" href="#RecipesBase.apply_recipe-Tuple{Dict{Symbol,Any},AbstractPolytope}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">plot_polygon(P::AbstractPolytope; ...)</code></pre><p>Plot a 2D polytope as the convex hull of its vertices.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon or polytope</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Plots, LazySets;

julia&gt; P = HPolygon([LinearConstraint([1.0, 0.0], 0.6),
                     LinearConstraint([0.0, 1.0], 0.6),
                     LinearConstraint([-1.0, 0.0], -0.4),
                     LinearConstraint([0.0, -1.0], -0.4)]);

julia&gt; plot(P);
</code></pre><p>This recipe also applies if the polygon is given in vertex representation:</p><pre><code class="language-julia-repl">julia&gt; P = VPolygon([[0.6, 0.6], [0.4, 0.6], [0.4, 0.4], [0.6, 0.4]]);

julia&gt; plot(P);
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/plot_recipes.jl#L194-L225">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{S}, Tuple{Dict{Symbol,Any},Array{S,1}}} where S&lt;:AbstractPolytope" href="#RecipesBase.apply_recipe-Union{Tuple{S}, Tuple{Dict{Symbol,Any},Array{S,1}}} where S&lt;:AbstractPolytope"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">plot_polytopes(Xk::Vector{S}; ...)</code></pre><p>Plot an array of 2D polytopes.</p><p><strong>Input</strong></p><ul><li><code>Xk</code> – array of polytopes</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Plots, LazySets;

julia&gt; P1 = HPolygon([LinearConstraint([1.0, 0.0], 0.6),
                      LinearConstraint([0.0, 1.0], 0.6),
                      LinearConstraint([-1.0, 0.0], -0.4),
                      LinearConstraint([0.0, -1.0], -0.4)]);

julia&gt; P2 = HPolygon([LinearConstraint([2.0, 0.0], 0.6),
                      LinearConstraint([0.0, 2.0], 0.6),
                      LinearConstraint([-2.0, 0.0], -0.4),
                      LinearConstraint([0.0, -2.0], -0.4)]);

julia&gt; plot([P1, P2]);
</code></pre><pre><code class="language-julia-repl">julia&gt; P1 = VPolygon([[0.6, 0.6], [0.4, 0.6], [0.4, 0.4], [0.6, 0.4]]);

julia&gt; P2 = VPolygon([[0.3, 0.3], [0.2, 0.3], [0.2, 0.2], [0.3, 0.2]]);

julia&gt; plot([P1, P2]);
</code></pre><p><strong>Notes</strong></p><p>It is assumed that the given vector of polytopes is two-dimensional.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/plot_recipes.jl#L244-L284">source</a></section><h4><a class="nav-anchor" id="Polygon-1" href="#Polygon-1">Polygon</a></h4><p>A polygon is a two-dimensional polytope.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractPolygon" href="#LazySets.AbstractPolygon"><code>LazySets.AbstractPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractPolygon{N&lt;:Real} &lt;: AbstractPolytope{N}</code></pre><p>Abstract type for polygons (i.e., 2D polytopes).</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractPolygon</code> must define the following functions:</p><ul><li><code>tovrep(::AbstractPolygon{N})::VPolygon{N}</code>         – transform into   V-representation</li><li><code>tohrep(::AbstractPolygon{N})::S where {S&lt;:AbstractHPolygon{N}}</code> – transform   into H-representation</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractPolygon)
2-element Array{Any,1}:
 AbstractHPolygon
 VPolygon</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractPolygon.jl#L7-L26">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractPolygon}" href="#LazySets.dim-Tuple{AbstractPolygon}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dim(P::AbstractPolygon)::Int</code></pre><p>Return the ambient dimension of a polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polygon, which is 2.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractPolygon.jl#L33-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolygon{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolygon{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">linear_map(M::AbstractMatrix{N}, P::AbstractPolygon{N};
           output_type::Type{&lt;:LazySet}=typeof(P)) where {N&lt;:Real}</code></pre><p>Concrete linear map of an abstract polygon.</p><p><strong>Input</strong></p><ul><li><code>M</code>           – matrix</li><li><code>P</code>           – abstract polygon</li><li><code>output_type</code> – (optional, default: type of <code>P</code>) type of the result</li></ul><p><strong>Output</strong></p><p>A set of type <code>output_type</code>.</p><p><strong>Algorithm</strong></p><p>The linear map <span>$M$</span> is applied to each vertex of the given set <span>$P$</span>, obtaining a polygon in V-representation. Since polygons are closed under linear map, by default <span>$MP$</span> is converted to the concrete type of <span>$P$</span>. If an <code>output_type</code> is given, the corresponding <code>convert</code> method is invoked.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractPolygon.jl#L182-L204">source</a></section><h5><a class="nav-anchor" id="HPolygon-1" href="#HPolygon-1">HPolygon</a></h5><p>An HPolygon is a polygon in H-representation (or constraint representation).</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractHPolygon" href="#LazySets.AbstractHPolygon"><code>LazySets.AbstractHPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractHPolygon{N&lt;:Real} &lt;: AbstractPolygon{N}</code></pre><p>Abstract type for polygons in H-representation (i.e., constraints).</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractHPolygon</code> must have the following fields:</p><ul><li><code>constraints::Vector{LinearConstraint{N}}</code> – the constraints</li></ul><p>New subtypes should be added to the <code>convert</code> method in order to be convertible.</p><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractHPolygon)
2-element Array{Any,1}:
 HPolygon
 HPolygonOpt</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHPolygon.jl#L18-L36">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">an_element(P::AbstractHPolygon{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>A vertex of the polygon in constraint representation (the first one in the order of the constraints).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHPolygon.jl#L160-L173">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHPolygon{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHPolygon{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">∈(x::AbstractVector{N}, P::AbstractHPolygon{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given 2D point is contained in a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>x</code> – two-dimensional point/vector</li><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation checks if the point lies on the outside of each edge.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHPolygon.jl#L180-L198">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Union{Tuple{Type{HPOLYGON}}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon" href="#Base.rand-Union{Tuple{Type{HPOLYGON}}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rand(::Type{HPOLYGON}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing,
     [num_constraints]::Int=-1
    )::HPOLYGON{N} where {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Create a random polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPOLYGON</code>        – type for dispatch</li><li><code>N</code>               – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>             – (optional, default: 2) dimension</li><li><code>rng</code>             – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>            – (optional, default: <code>nothing</code>) seed for reseeding</li><li><code>num_constraints</code> – (optional, default: <code>-1</code>) number of constraints of the                      polygon (must be 3 or bigger; see comment below)</li></ul><p><strong>Output</strong></p><p>A random polygon in constraint representation.</p><p><strong>Algorithm</strong></p><p>We create a random polygon in vertex representation and convert it to constraint representation. See <a href="representations.html#Base.rand-Tuple{Type{VPolygon}}"><code>rand(::Type{VPolygon})</code></a>. For non-flat polygons the number of vertices and the number of constraints are identical.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHPolygon.jl#L210-L239">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tohrep-Union{Tuple{HPOLYGON}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon" href="#LazySets.tohrep-Union{Tuple{HPOLYGON}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon"><code>LazySets.tohrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tohrep(P::HPOLYGON)::HPOLYGON where {HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Build a contraint representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>The identity, i.e., the same polygon instance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHPolygon.jl#L61-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tovrep-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.tovrep-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.tovrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tovrep(P::AbstractHPolygon{N})::VPolygon{N} where {N&lt;:Real}</code></pre><p>Build a vertex representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li></ul><p><strong>Output</strong></p><p>The same polygon but in vertex representation, a <code>VPolygon</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHPolygon.jl#L43-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.addconstraint!-Union{Tuple{N}, Tuple{AbstractHPolygon{N},HalfSpace{N}}} where N&lt;:Real" href="#LazySets.addconstraint!-Union{Tuple{N}, Tuple{AbstractHPolygon{N},HalfSpace{N}}} where N&lt;:Real"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addconstraint!(P::AbstractHPolygon{N},
               constraint::LinearConstraint{N};
               linear_search::Bool=(length(P.constraints) &lt; BINARY_SEARCH_THRESHOLD)
              )::Nothing where {N&lt;:Real}</code></pre><p>Add a linear constraint to a polygon in constraint representation, keeping the constraints sorted by their normal directions.</p><p><strong>Input</strong></p><ul><li><code>P</code>          – polygon in constraint representation</li><li><code>constraint</code> – linear constraint to add</li></ul><p><strong>Output</strong></p><p>Nothing.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHPolygon.jl#L259-L276">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.addconstraint!-Union{Tuple{N}, Tuple{Array{HalfSpace{N},1},HalfSpace{N}}} where N&lt;:Real" href="#LazySets.addconstraint!-Union{Tuple{N}, Tuple{Array{HalfSpace{N},1},HalfSpace{N}}} where N&lt;:Real"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addconstraint!(constraints::Vector{LinearConstraint{N}},
               new_constraint::LinearConstraint{N};
               [linear_search]::Bool=(length(P.constraints) &lt; BINARY_SEARCH_THRESHOLD)
              )::Nothing where {N&lt;:Real}</code></pre><p>Add a linear constraint to a sorted vector of constrains, keeping the constraints sorted by their normal directions.</p><p><strong>Input</strong></p><ul><li><code>constraints</code>    – vector of linear constraintspolygon in constraint representation</li><li><code>new_constraint</code> – linear constraint to add</li></ul><p><strong>Output</strong></p><p>Nothing.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHPolygon.jl#L284-L301">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">constraints_list(P::AbstractHPolygon{N})::Vector{LinearConstraint{N}} where {N&lt;:Real}</code></pre><p>Return the list of constraints defining a polygon in H-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in H-representation</li></ul><p><strong>Output</strong></p><p>The list of constraints of the polygon.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHPolygon.jl#L139-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}, Tuple{AbstractHPolygon{N},Bool}, Tuple{AbstractHPolygon{N},Bool,Bool}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}, Tuple{AbstractHPolygon{N},Bool}, Tuple{AbstractHPolygon{N},Bool,Bool}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">vertices_list(P::AbstractHPolygon{N},
              apply_convex_hull::Bool=false,
              check_feasibility::Bool=true
             )::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>                 – polygon in constraint representation</li><li><code>apply_convex_hull</code> – (optional, default: <code>false</code>) flag to post-process the                        intersection of constraints with a convex hull</li><li><code>check_feasibility</code> – (optional, default: <code>true</code>) flag to check whether the                        polygon was empty (required for correctness in case of                        empty polygons)</li></ul><p><strong>Output</strong></p><p>List of vertices.</p><p><strong>Algorithm</strong></p><p>We compute each vertex as the intersection of consecutive lines defined by the half-spaces. If <code>check_feasibility</code> is active, we then check if the constraints of the polygon were actually feasible (i.e., they pointed in the <em>right</em> direction). For this we compute the <em>average</em> of all vertices and check membership in each constraint.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHPolygon.jl#L82-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded" href="#LazySets.isbounded"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isbounded(P::AbstractHPolygon, [use_type_assumption]::Bool=true)::Bool</code></pre><p>Determine whether a polygon in constraint representation is bounded.</p><p><strong>Input</strong></p><ul><li><code>P</code>                   – polygon in constraint representation</li><li><code>use_type_assumption</code> – (optional, default: <code>true</code>) flag for ignoring the                          type assumption that polygons are bounded</li></ul><p><strong>Output</strong></p><p><code>true</code> if <code>use_type_assumption</code> is activated. Otherwise, <code>true</code> iff <code>P</code> is bounded.</p><p><strong>Algorithm</strong></p><p>If <code>!use_type_assumption</code>, we convert <code>P</code> to an <code>HPolyhedron</code> <code>P2</code> and then use <code>isbounded(P2)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHPolygon.jl#L383-L403">source</a></section><h4><a class="nav-anchor" id="Centrally-symmetric-polytope-1" href="#Centrally-symmetric-polytope-1">Centrally symmetric polytope</a></h4><p>A centrally symmetric polytope is a combination of two other interfaces: <a href="interfaces.html#Centrally-symmetric-set-1">Centrally symmetric set</a> and <a href="interfaces.html#Polytope-1">Polytope</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractCentrallySymmetricPolytope" href="#LazySets.AbstractCentrallySymmetricPolytope"><code>LazySets.AbstractCentrallySymmetricPolytope</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractCentrallySymmetricPolytope{N&lt;:Real} &lt;: AbstractPolytope{N}</code></pre><p>Abstract type for centrally symmetric, polytopic sets. It combines the <code>AbstractCentrallySymmetric</code> and <code>AbstractPolytope</code> interfaces. Such a type combination is necessary as long as Julia does not support <a href="https://github.com/JuliaLang/julia/issues/5">multiple inheritance</a>.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractCentrallySymmetricPolytope</code> must define the following functions:</p><ul><li>from <code>AbstractCentrallySymmetric</code>:<ul><li><code>center(::AbstractCentrallySymmetricPolytope{N})::Vector{N}</code> – return the  center point</li></ul></li><li>from <code>AbstractPolytope</code>:<ul><li><code>vertices_list(::AbstractCentrallySymmetricPolytope{N})::Vector{Vector{N}}</code>  – return a list of all vertices</li></ul></li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractCentrallySymmetricPolytope)
4-element Array{Any,1}:
 AbstractHyperrectangle
 Ball1
 LineSegment
 Zonotope</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractCentrallySymmetricPolytope.jl#L9-L36">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}" href="#LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dim(P::AbstractCentrallySymmetricPolytope)::Int</code></pre><p>Return the ambient dimension of a centrally symmetric, polytopic set.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric, polytopic set</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polytopic set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractCentrallySymmetricPolytope.jl#L44-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">an_element(P::AbstractCentrallySymmetricPolytope{N})::Vector{N}
    where {N&lt;:Real}</code></pre><p>Return some element of a centrally symmetric polytope.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric polytope</li></ul><p><strong>Output</strong></p><p>The center of the centrally symmetric polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractCentrallySymmetricPolytope.jl#L62-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}" href="#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isempty(P::AbstractCentrallySymmetricPolytope)::Bool</code></pre><p>Return if a centrally symmetric, polytopic set is empty or not.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric, polytopic set</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractCentrallySymmetricPolytope.jl#L81-L93">source</a></section><h5><a class="nav-anchor" id="Hyperrectangle-1" href="#Hyperrectangle-1">Hyperrectangle</a></h5><p>A hyperrectangle is a special centrally symmetric polytope with axis-aligned facets.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractHyperrectangle" href="#LazySets.AbstractHyperrectangle"><code>LazySets.AbstractHyperrectangle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractHyperrectangle{N&lt;:Real} &lt;: AbstractCentrallySymmetricPolytope{N}</code></pre><p>Abstract type for hyperrectangular sets.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractHyperrectangle</code> must define the following functions:</p><ul><li><code>radius_hyperrectangle(::AbstractHyperrectangle{N})::Vector{N}</code> – return the   hyperrectangle&#39;s radius, which is a full-dimensional vector</li><li><code>radius_hyperrectangle(::AbstractHyperrectangle{N}, i::Int)::N</code> – return the   hyperrectangle&#39;s radius in the <code>i</code>-th dimension</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractHyperrectangle)
5-element Array{Any,1}:
 AbstractSingleton
 BallInf
 Hyperrectangle
 Interval
 SymmetricIntervalHull</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHyperrectangle.jl#L8-L30">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">norm(H::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the norm of a hyperrectangular set.</p><p>The norm of a hyperrectangular set is defined as the norm of the enclosing ball, of the given <span>$p$</span>-norm, of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p><p><strong>Algorithm</strong></p><p>Recall that the norm is defined as</p><div>\[‖ X ‖ = \max_{x ∈ X} ‖ x ‖_p = max_{x ∈ \text{vertices}(X)} ‖ x ‖_p.\]</div><p>The last equality holds because the optimum of a convex function over a polytope is attained at one of its vertices.</p><p>This implementation uses the fact that the maximum is achieved in the vertex <span>$c + \text{diag}(\text{sign}(c)) r$</span>, for any <span>$p$</span>-norm, hence it suffices to take the <span>$p$</span>-norm of this particular vertex. This statement is proved below. Note that, in particular, there is no need to compute the <span>$p$</span>-norm for <em>each</em> vertex, which can be very expensive. </p><p>If <span>$X$</span> is an axis-aligned hyperrectangle and the <span>$n$</span>-dimensional vectors center and radius of the hyperrectangle are denoted <span>$c$</span> and <span>$r$</span> respectively, then reasoning on the <span>$2^n$</span> vertices we have that:</p><div>\[\max_{x ∈ \text{vertices}(X)} ‖ x ‖_p = \max_{α_1, …, α_n ∈ \{-1, 1\}} (|c_1 + α_1 r_1|^p + ... + |c_n + α_n r_n|^p)^{1/p}.\]</div><p>The function <span>$x ↦ x^p$</span>, <span>$p &gt; 0$</span>, is monotonically increasing and thus the maximum of each term <span>$|c_i + α_i r_i|^p$</span> is given by <span>$|c_i + \text{sign}(c_i) r_i|^p$</span> for each <span>$i$</span>. Hence, <span>$x^* := \text{argmax}_{x ∈ X} ‖ x ‖_p$</span> is the vertex <span>$c + \text{diag}(\text{sign}(c)) r$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHyperrectangle.jl#L114-L159">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius" href="#LazySets.radius"><code>LazySets.radius</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">radius(H::AbstractHyperrectangle, [p]::Real=Inf)::Real</code></pre><p>Return the radius of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p><p><strong>Notes</strong></p><p>The radius is defined as the radius of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center. It is the same for all corners of a hyperrectangular set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHyperrectangle.jl#L165-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">σ(d::AbstractVector{N}, H::AbstractHyperrectangle{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a hyperrectangular set in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the vertex with biggest values is returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHyperrectangle.jl#L95-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">∈(x::AbstractVector{N}, H::AbstractHyperrectangle{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ H$</span>.</p><p><strong>Algorithm</strong></p><p>Let <span>$H$</span> be an <span>$n$</span>-dimensional hyperrectangular set, <span>$c_i$</span> and <span>$r_i$</span> be the box&#39;s center and radius and <span>$x_i$</span> be the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ H$</span> iff <span>$|c_i - x_i| ≤ r_i$</span> for all <span>$i=1,…,n$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHyperrectangle.jl#L189-L209">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">vertices_list(H::AbstractHyperrectangle{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Notes</strong></p><p>For high dimensions, it is preferable to develop a <code>vertex_iterator</code> approach.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHyperrectangle.jl#L38-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">constraints_list(H::AbstractHyperrectangle{N})::Vector{LinearConstraint{N}}
    where {N&lt;:Real}</code></pre><p>Return the list of constraints of an axis-aligned hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A list of linear constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHyperrectangle.jl#L65-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.high-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">high(H::AbstractHyperrectangle{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the higher coordinates of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A vector with the higher coordinates of the hyperrectangular set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHyperrectangle.jl#L225-L237">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.low-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">low(H::AbstractHyperrectangle{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the lower coordinates of a hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A vector with the lower coordinates of the hyperrectangular set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractHyperrectangle.jl#L242-L254">source</a></section><h5><a class="nav-anchor" id="Singleton-1" href="#Singleton-1">Singleton</a></h5><p>A singleton is a special hyperrectangle consisting of only one point.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.AbstractSingleton" href="#LazySets.AbstractSingleton"><code>LazySets.AbstractSingleton</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractSingleton{N&lt;:Real} &lt;: AbstractHyperrectangle{N}</code></pre><p>Abstract type for sets with a single value.</p><p><strong>Notes</strong></p><p>Every concrete <code>AbstractSingleton</code> must define the following functions:</p><ul><li><code>element(::AbstractSingleton{N})::Vector{N}</code> – return the single element</li><li><code>element(::AbstractSingleton{N}, i::Int)::N</code> – return the single element&#39;s   entry in the <code>i</code>-th dimension</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractSingleton)
2-element Array{Any,1}:
 Singleton
 ZeroSet</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractSingleton.jl#L8-L26">source</a></section><p>This interface defines the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">σ(d::AbstractVector{N}, S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The support vector, which is the set&#39;s vector itself, irrespective of the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractSingleton.jl#L176-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">∈(x::AbstractVector{N}, S::AbstractSingleton{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ S$</span>.</p><p><strong>Notes</strong></p><p>This implementation performs an exact comparison, which may be insufficient with floating point computations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractSingleton.jl#L196-L214">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">an_element(S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – convex set</li></ul><p><strong>Output</strong></p><p>An element of a convex set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/LazySet.jl#L226-L238">source</a><div><div><pre><code class="language-none">an_element(P::AbstractCentrallySymmetricPolytope{N})::Vector{N}
    where {N&lt;:Real}</code></pre><p>Return some element of a centrally symmetric polytope.</p><p><strong>Input</strong></p><ul><li><code>P</code> – centrally symmetric polytope</li></ul><p><strong>Output</strong></p><p>The center of the centrally symmetric polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractCentrallySymmetricPolytope.jl#L62-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.center-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">center(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The only element of the set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractSingleton.jl#L110-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">vertices_list(S::AbstractSingleton{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A list containing only a single vertex.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractSingleton.jl#L131-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">radius_hyperrectangle(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the box radius of a set with a single value in every dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>The zero vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractSingleton.jl#L52-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">radius_hyperrectangle(S::AbstractSingleton{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the box radius of a set with a single value in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>Zero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractSingleton.jl#L33-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.high-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">high(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the higher coordinates of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A vector with the higher coordinates of the set with a single value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractSingleton.jl#L71-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.low-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">low(S::AbstractSingleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the lower coordinates of a set with a single value.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set with a single value</li></ul><p><strong>Output</strong></p><p>A vector with the lower coordinates of the set with a single value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractSingleton.jl#L88-L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractSingleton{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractSingleton{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">linear_map(M::AbstractMatrix{N}, S::AbstractSingleton{N}) where {N&lt;:Real}</code></pre><p>Concrete linear map of an abstract singleton.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>S</code> – abstract singleton</li></ul><p><strong>Output</strong></p><p>The abstract singleton of the same type of <span>$S$</span> obtained by applying the linear map to the element in <span>$S$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/AbstractSingleton.jl#L149-L163">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{Dict{Symbol,Any},AbstractSingleton}" href="#RecipesBase.apply_recipe-Tuple{Dict{Symbol,Any},AbstractSingleton}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">plot_singleton(X::AbstractSingleton; ...)</code></pre><p>Plot a singleton.</p><p><strong>Input</strong></p><ul><li><code>X</code> – singleton, i.e., a one-element set</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Plots, LazySets;

julia&gt; plot(Singleton([0.5, 1.0]));
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/plot_recipes.jl#L310-L327">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{S}, Tuple{Dict{Symbol,Any},Array{S,1}}} where S&lt;:AbstractSingleton" href="#RecipesBase.apply_recipe-Union{Tuple{S}, Tuple{Dict{Symbol,Any},Array{S,1}}} where S&lt;:AbstractSingleton"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">plot_singleton(Xk::Vector{S}; ...) where {S&lt;:AbstractSingleton}</code></pre><p>Plot a list of singletons.</p><p><strong>Input</strong></p><ul><li><code>Xk</code> – list of singletons, i.e., a vector of one-element sets</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Plots, LazySets;

julia&gt; plot([Singleton([0.0, 0.0]), Singleton([1., 0]), Singleton([0.5, .5])]);
</code></pre><p>Three-dimensional singletons can be plotted as well:</p><pre><code class="language-julia-repl">julia&gt; using Plots, LazySets;

julia&gt; a, b, c = zeros(3), [1.0, 0, 0], [0.0, 1., 0];

julia&gt; plot([Singleton(a), Singleton(b), Singleton(c)]);
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/79a9678f6421aa1d50a86ce8ae2c487f3f8bd23c/src/plot_recipes.jl#L338-L366">source</a></section><footer><hr/><a class="previous" href="../man/parallel_approximations.html"><span class="direction">Previous</span><span class="title">Parallel Approximations</span></a><a class="next" href="representations.html"><span class="direction">Next</span><span class="title">Common Set Representations</span></a></footer></article></body></html>
