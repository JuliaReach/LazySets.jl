<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Common Set Operations · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/getting_started.html">Getting Started</a></li><li><a class="toctext" href="../man/polyhedral_approximations.html">Polyhedral Approximations</a></li><li><a class="toctext" href="../man/decompose_example.html">Decomposing an Affine Map</a></li><li><a class="toctext" href="../man/fast_2d_LPs.html">Fast 2D LPs</a></li><li><a class="toctext" href="../man/iterative_refinement.html">Iterative Refinement</a></li><li><a class="toctext" href="../man/interval_hulls.html">Interval Hulls</a></li><li><a class="toctext" href="../man/convex_hulls.html">Convex Hulls</a></li><li><a class="toctext" href="../man/set_operations.html">Operations on Sets</a></li><li><a class="toctext" href="../man/reach_zonotopes.html">A Reachability Algorithm</a></li><li><a class="toctext" href="../man/reach_zonotopes_hybrid.html">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../man/concrete_polyhedra.html">Concrete Polyhedra</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="interfaces.html">Set Interfaces</a></li><li><a class="toctext" href="representations.html">Common Set Representations</a></li><li class="current"><a class="toctext" href="operations.html">Common Set Operations</a><ul class="internal"><li><a class="toctext" href="#Cartesian-Product-1">Cartesian Product</a></li><li><a class="toctext" href="#Convex-Hull-1">Convex Hull</a></li><li><a class="toctext" href="#Intersection-1">Intersection</a></li><li><a class="toctext" href="#Minkowski-Sum-1">Minkowski Sum</a></li><li><a class="toctext" href="#Maps-1">Maps</a></li><li><a class="toctext" href="#Symmetric-Interval-Hull-1">Symmetric Interval Hull</a></li></ul></li><li><a class="toctext" href="conversion.html">Conversion between set representations</a></li><li><a class="toctext" href="binary_functions.html">Binary Functions on Sets</a></li><li><a class="toctext" href="approximations.html">Approximations</a></li><li><a class="toctext" href="utils.html">Utility Functions</a></li></ul></li><li><a class="toctext" href="../about.html">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="operations.html">Common Set Operations</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/operations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Common Set Operations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Common-Set-Operations-1" href="#Common-Set-Operations-1">Common Set Operations</a></h1><p>This section of the manual describes the basic symbolic types describing operations between sets.</p><ul><li><a href="operations.html#Common-Set-Operations-1">Common Set Operations</a></li><ul><li><a href="operations.html#Cartesian-Product-1">Cartesian Product</a></li><ul><li><a href="operations.html#Binary-Cartesian-Product-1">Binary Cartesian Product</a></li><li><a href="operations.html#n-ary-Cartesian-Product-1"><span>$n$</span>-ary Cartesian Product</a></li></ul><li><a href="operations.html#Convex-Hull-1">Convex Hull</a></li><ul><li><a href="operations.html#Binary-Convex-Hull-1">Binary Convex Hull</a></li><li><a href="operations.html#n-ary-Convex-Hull-1"><span>$n$</span>-ary Convex Hull</a></li><li><a href="operations.html#Convex-Hull-Algorithms-1">Convex Hull Algorithms</a></li></ul><li><a href="operations.html#Intersection-1">Intersection</a></li><li><a href="operations.html#Minkowski-Sum-1">Minkowski Sum</a></li><ul><li><a href="operations.html#Binary-Minkowski-Sum-1">Binary Minkowski Sum</a></li><li><a href="operations.html#n-ary-Minkowski-Sum-1"><span>$n$</span>-ary Minkowski Sum</a></li><li><a href="operations.html#n-ary-Minkowski-Sum-with-cache-1"><span>$n$</span>-ary Minkowski Sum with cache</a></li></ul><li><a href="operations.html#Maps-1">Maps</a></li><ul><li><a href="operations.html#Linear-Map-1">Linear Map</a></li><li><a href="operations.html#Exponential-Map-1">Exponential Map</a></li></ul><li><a href="operations.html#Symmetric-Interval-Hull-1">Symmetric Interval Hull</a></li></ul></ul><h2><a class="nav-anchor" id="Cartesian-Product-1" href="#Cartesian-Product-1">Cartesian Product</a></h2><h3><a class="nav-anchor" id="Binary-Cartesian-Product-1" href="#Binary-Cartesian-Product-1">Binary Cartesian Product</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CartesianProduct" href="#LazySets.CartesianProduct"><code>LazySets.CartesianProduct</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CartesianProduct{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents a Cartesian product of two convex sets.</p><p><strong>Fields</strong></p><ul><li><p><code>X</code> – first convex set</p></li><li><p><code>Y</code> – second convex set</p></li></ul><p><strong>Notes</strong></p><p>The Cartesian product of three elements is obtained recursively. See also <code>CartesianProductArray</code> for an implementation of a Cartesian product of many sets without recursion, instead using an array.</p><p>The <code>EmptySet</code> is the absorbing element for <code>CartesianProduct</code>.</p><p>Constructors:</p><ul><li><p><code>CartesianProduct{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}}(X1::S1, X2::S2)</code> – default constructor</p></li><li><p><code>CartesianProduct(Xarr::Vector{S}) where {S&lt;:LazySet}</code> – constructor from an array of convex sets</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/CartesianProduct.jl#L8-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{LazySets.LazySet{Float64},LazySets.LazySet{Float64}}" href="#Base.:*-Tuple{LazySets.LazySet{Float64},LazySets.LazySet{Float64}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">    *(X::LazySet, Y::LazySet)</code></pre><p>Alias for the binary Cartesian product.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/CartesianProduct.jl#L56-L62">source</a><div><pre><code class="language-none">    *(a::N, X::LazySet) where {N}</code></pre><p>Return a linear map of a convex set by a scalar value.</p><p><strong>Input</strong></p><ul><li><p><code>a</code> – scalar</p></li><li><p><code>X</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>The linear map of the convex set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/LinearMap.jl#L60-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.CartesianProduct{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.CartesianProduct{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(cp::CartesianProduct)::Int</code></pre><p>Return the dimension of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><p><code>cp</code> – Cartesian product</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Cartesian product.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/CartesianProduct.jl#L72-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.CartesianProduct{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.CartesianProduct{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::V, cp::CartesianProduct) where {N&lt;:Real, V&lt;:AbstractVector{N}}</code></pre><p>Return the support vector of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>  – direction</p></li><li><p><code>cp</code> – Cartesian product</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the product sets.</p><p><strong>Algorithm</strong></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/CartesianProduct.jl#L89-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.CartesianProduct{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.CartesianProduct{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{&lt;:Real}, cp::CartesianProduct)::Bool</code></pre><p>Check whether a given point is contained in a Cartesian product set.</p><p><strong>Input</strong></p><ul><li><p><code>x</code>  – point/vector</p></li><li><p><code>cp</code> – Cartesian product</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ cp$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/CartesianProduct.jl#L112-L125">source</a></section><h3><a class="nav-anchor" id="n-ary-Cartesian-Product-1" href="#n-ary-Cartesian-Product-1"><span>$n$</span>-ary Cartesian Product</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CartesianProductArray" href="#LazySets.CartesianProductArray"><code>LazySets.CartesianProductArray</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CartesianProductArray{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the Cartesian product of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><p><code>array</code> – array of sets</p></li></ul><p><strong>Notes</strong></p><p>The <code>EmptySet</code> is the absorbing element for <code>CartesianProductArray</code>.</p><p>Constructors:</p><ul><li><p><code>CartesianProductArray(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>CartesianProductArray([n]::Int=0, [N]::Type=Float64)</code> – constructor for an empty product with optional size hint and numeric type</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/CartesianProduct.jl#L136-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.array-Tuple{LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.array-Tuple{LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">array(cpa::CartesianProductArray{N, S}
     )::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>cpa</code> – Cartesian product array</p></li></ul><p><strong>Output</strong></p><p>The array of a Cartesian product of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/CartesianProduct.jl#L177-L190">source</a><div><pre><code class="language-none">array(cha::ConvexHullArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>cha</code> – convex hull array</p></li></ul><p><strong>Output</strong></p><p>The array of a convex hull of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ConvexHull.jl#L157-L169">source</a><div><pre><code class="language-none">array(msa::MinkowskiSumArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Minkowski sum of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>msa</code> – Minkowski sum array</p></li></ul><p><strong>Output</strong></p><p>The array of a Minkowski sum of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L154-L166">source</a><div><pre><code class="language-none">array(cms::CacheMinkowskiSum{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><p><code>cms</code> – caching Minkowski sum</p></li></ul><p><strong>Output</strong></p><p>The array of a caching Minkowski sum.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L294-L306">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(cpa::CartesianProductArray)::Int</code></pre><p>Return the dimension of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>cpa</code> – Cartesian product array</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Cartesian product of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/CartesianProduct.jl#L196-L209">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::V, cpa::CartesianProductArray{N, &lt;:LazySet{N}}) where {N&lt;:Real, V&lt;:AbstractVector{N}}</code></pre><p>Support vector of a Cartesian product.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>   – direction</p></li><li><p><code>cpa</code> – Cartesian product array</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the product sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/CartesianProduct.jl#L214-L228">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.CartesianProductArray{Float64,LazySets.LazySet{Float64}}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, cpa::CartesianProductArray{N, &lt;:LazySet{N}}
 )::Bool  where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><p><code>x</code>   – point/vector</p></li><li><p><code>cpa</code> – Cartesian product array</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ \text{cpa}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/CartesianProduct.jl#L240-L255">source</a></section><h2><a class="nav-anchor" id="Convex-Hull-1" href="#Convex-Hull-1">Convex Hull</a></h2><h3><a class="nav-anchor" id="Binary-Convex-Hull-1" href="#Binary-Convex-Hull-1">Binary Convex Hull</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ConvexHull" href="#LazySets.ConvexHull"><code>LazySets.ConvexHull</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConvexHull{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the convex hull of the union of two convex sets.</p><p><strong>Fields</strong></p><ul><li><p><code>X</code> – convex set</p></li><li><p><code>Y</code> – convex set</p></li></ul><p><strong>Notes</strong></p><p>The <code>EmptySet</code> is the neutral element for <code>ConvexHull</code>.</p><p><strong>Examples</strong></p><p>Convex hull of two 100-dimensional Euclidean balls:</p><pre><code class="language-julia-repl">julia&gt; b1, b2 = Ball2(zeros(100), 0.1), Ball2(4*ones(100), 0.2);

julia&gt; c = ConvexHull(b1, b2);

julia&gt; typeof(c)
LazySets.ConvexHull{Float64,LazySets.Ball2{Float64},LazySets.Ball2{Float64}}</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ConvexHull.jl#L10-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CH" href="#LazySets.CH"><code>LazySets.CH</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CH</code></pre><p>Alias for <code>ConvexHull</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ConvexHull.jl#L53-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.ConvexHull{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.ConvexHull{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(ch::ConvexHull)::Int</code></pre><p>Return the dimension of a convex hull of two convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>ch</code> – convex hull of two convex sets</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the convex hull of two convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ConvexHull.jl#L60-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.ConvexHull{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.ConvexHull{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::V, ch::ConvexHull) where {N&lt;:Real, V&lt;:AbstractVector{N}}</code></pre><p>Return the support vector of a convex hull of two convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>  – direction</p></li><li><p><code>ch</code> – convex hull of two convex sets</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ConvexHull.jl#L77-L87">source</a></section><h3><a class="nav-anchor" id="n-ary-Convex-Hull-1" href="#n-ary-Convex-Hull-1"><span>$n$</span>-ary Convex Hull</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ConvexHullArray" href="#LazySets.ConvexHullArray"><code>LazySets.ConvexHullArray</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConvexHullArray{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the symbolic convex hull of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><p><code>array</code> – array of sets</p></li></ul><p><strong>Notes</strong></p><p>The <code>EmptySet</code> is the neutral element for <code>ConvexHullArray</code>.</p><p>Constructors:</p><ul><li><p><code>ConvexHullArray(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>ConvexHullArray([n]::Int=0, [N]::Type=Float64)</code> – constructor for an empty hull with optional size hint and numeric type</p></li></ul><p><strong>Examples</strong></p><p>Convex hull of 100 two-dimensional balls whose centers follows a sinusoidal:</p><pre><code class="language-julia-repl">julia&gt; b = [Ball2([2*pi*i/100, sin(2*pi*i/100)], 0.05) for i in 1:100];

julia&gt; c = ConvexHullArray(b);</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ConvexHull.jl#L99-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CHArray" href="#LazySets.CHArray"><code>LazySets.CHArray</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CHArray</code></pre><p>Alias for <code>ConvexHullArray</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ConvexHull.jl#L150-L154">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.array-Tuple{LazySets.ConvexHullArray{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.array-Tuple{LazySets.ConvexHullArray{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">array(cpa::CartesianProductArray{N, S}
     )::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>cpa</code> – Cartesian product array</p></li></ul><p><strong>Output</strong></p><p>The array of a Cartesian product of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/CartesianProduct.jl#L177-L190">source</a><div><pre><code class="language-none">array(cha::ConvexHullArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>cha</code> – convex hull array</p></li></ul><p><strong>Output</strong></p><p>The array of a convex hull of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ConvexHull.jl#L157-L169">source</a><div><pre><code class="language-none">array(msa::MinkowskiSumArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Minkowski sum of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>msa</code> – Minkowski sum array</p></li></ul><p><strong>Output</strong></p><p>The array of a Minkowski sum of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L154-L166">source</a><div><pre><code class="language-none">array(cms::CacheMinkowskiSum{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><p><code>cms</code> – caching Minkowski sum</p></li></ul><p><strong>Output</strong></p><p>The array of a caching Minkowski sum.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L294-L306">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.ConvexHullArray}" href="#LazySets.dim-Tuple{LazySets.ConvexHullArray}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(cha::ConvexHullArray)::Int</code></pre><p>Return the dimension of the convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>cha</code> – convex hull array</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the convex hull of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ConvexHull.jl#L174-L186">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.ConvexHullArray}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.ConvexHullArray}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::V, cha::ConvexHullArray) where {N&lt;:Real, V&lt;:AbstractVector{N}}</code></pre><p>Return the support vector of a convex hull array in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>   – direction</p></li><li><p><code>cha</code> – convex hull array</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ConvexHull.jl#L192-L201">source</a></section><h3><a class="nav-anchor" id="Convex-Hull-Algorithms-1" href="#Convex-Hull-Algorithms-1">Convex Hull Algorithms</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.convex_hull" href="#LazySets.convex_hull"><code>LazySets.convex_hull</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">convex_hull(points::Vector{S}; [algorithm]::String=&quot;monotone_chain&quot;
           )::Vector{S} where {S&lt;:AbstractVector{N}} where {N&lt;:Real}</code></pre><p>Compute the convex hull of points in the plane.</p><p><strong>Input</strong></p><ul><li><p><code>points</code>    – list of 2D vectors</p></li><li><p><code>algorithm</code> – (optional, default: <code>&quot;monotone_chain&quot;</code>) the convex hull                algorithm, valid options are:</p><ul><li><p><code>&quot;monotone_chain&quot;</code></p></li><li><p><code>&quot;monotone_chain_sorted&quot;</code></p></li></ul></li></ul><p><strong>Output</strong></p><p>The convex hull as a list of 2D vectors with the coordinates of the points.</p><p><strong>Examples</strong></p><p>Compute the convex hull of a random set of points:</p><pre><code class="language-julia-repl">julia&gt; points = [randn(2) for i in 1:30]; # 30 random points in 2D

julia&gt; hull = convex_hull(points);

julia&gt; typeof(hull)
Array{Array{Float64,1},1}</code></pre><p>Plot both the random points and the computed convex hull polygon:</p><pre><code class="language-julia-repl">julia&gt; using Plots;

julia&gt; plot([Tuple(pi) for pi in points], seriestype=:scatter);

julia&gt; plot!(VPolygon(hull), alpha=0.2);</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/convex_hull_algorithms.jl#L1-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.convex_hull!" href="#LazySets.convex_hull!"><code>LazySets.convex_hull!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">convex_hull!(points::Vector{S}; [algorithm]::String=&quot;monotone_chain&quot;
            )::Vector{S} where {S&lt;:AbstractVector{N}} where {N&lt;:Real}</code></pre><p>Compute the convex hull of points in the plane, in-place.</p><p><strong>Input</strong></p><ul><li><p><code>points</code>    – list of 2D vectors (is modified)</p></li><li><p><code>algorithm</code> – (optional, default: <code>&quot;monotone_chain&quot;</code>) the convex hull                algorithm; valid options are:</p><ul><li><p><code>&quot;monotone_chain&quot;</code></p></li><li><p><code>&quot;monotone_chain_sorted&quot;</code></p></li></ul></li></ul><p><strong>Output</strong></p><p>The convex hull as a list of 2D vectors with the coordinates of the points.</p><p><strong>Notes</strong></p><p>See the non-modifying version <code>convex_hull</code> for more details.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/convex_hull_algorithms.jl#L48-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.right_turn" href="#LazySets.right_turn"><code>LazySets.right_turn</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">right_turn(O::AbstractVector{N}, A::AbstractVector{N}, B::AbstractVector{N}
          )::N where {N&lt;:Real}</code></pre><p>Determine if the acute angle defined by the three points <code>O</code>, <code>A</code>, <code>B</code> in the plane is a right turn (counter-clockwise) with respect to the center <code>O</code>.</p><p><strong>Input</strong></p><ul><li><p><code>O</code> – 2D center point</p></li><li><p><code>A</code> – 2D one point</p></li><li><p><code>B</code> – 2D another point</p></li></ul><p><strong>Output</strong></p><p>Scalar representing the rotation.</p><p><strong>Algorithm</strong></p><p>The <a href="https://en.wikipedia.org/wiki/Cross_product">cross product</a> is used to determine the sense of rotation. If the result is 0, the points are collinear; if it is positive, the three points constitute a positive angle of rotation around <code>O</code> from <code>A</code> to <code>B</code>; otherwise they constitute a negative angle.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/convex_hull_algorithms.jl#L85-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.monotone_chain!" href="#LazySets.monotone_chain!"><code>LazySets.monotone_chain!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">monotone_chain!(points::Vector{S}; sort::Bool=true
               )::Vector{S} where {S&lt;:AbstractVector{N}} where {N&lt;:Real}</code></pre><p>Compute the convex hull of points in the plane using Andrew&#39;s monotone chain method.</p><p><strong>Input</strong></p><ul><li><p><code>points</code> – list of 2D vectors; is sorted in-place inside this function</p></li><li><p><code>sort</code>   – (optional, default: <code>true</code>) flag for sorting the vertices             lexicographically; sortedness is required for correctness</p></li></ul><p><strong>Output</strong></p><p>List of vectors containing the 2D coordinates of the corner points of the convex hull.</p><p><strong>Notes</strong></p><p>For large sets of points, it is convenient to use static vectors to get maximum performance. For information on how to convert usual vectors into static vectors, see the type <code>SVector</code> provided by the <a href="http://juliaarrays.github.io/StaticArrays.jl/stable/">StaticArrays</a> package.</p><p><strong>Algorithm</strong></p><p>This function implements Andrew&#39;s monotone chain convex hull algorithm to construct the convex hull of a set of <span>$n$</span> points in the plane in <span>$O(n \log n)$</span> time. For further details see <a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain">Monotone chain</a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/convex_hull_algorithms.jl#L115-L148">source</a></section><h2><a class="nav-anchor" id="Intersection-1" href="#Intersection-1">Intersection</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Intersection" href="#LazySets.Intersection"><code>LazySets.Intersection</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Intersection{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the intersection of two convex sets.</p><p><strong>Fields</strong></p><ul><li><p><code>X</code> – convex set</p></li><li><p><code>Y</code> – convex set</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/Intersection.jl#L5-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.Intersection{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.Intersection{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(cap::Intersection)::Int</code></pre><p>Return the dimension of an intersection of two convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>cap</code> – intersection of two convex sets</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the intersection of two convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/Intersection.jl#L42-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Intersection{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Intersection{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::V, cap::Intersection) where {N&lt;:Real, V&lt;:AbstractVector{N}}</code></pre><p>Return the support vector of an intersection of two convex sets in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>   – direction</p></li><li><p><code>cap</code> – intersection of two convex sets</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/Intersection.jl#L59-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.Intersection{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.Intersection{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, cap::Intersection{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a intersection of two convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – point/vector</p></li><li><p><code>cap</code> – intersection of two convex sets</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ cap$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/Intersection.jl#L81-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{LazySets.Intersection{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#Base.isempty-Tuple{LazySets.Intersection{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isempty(cap::Intersection)::Bool</code></pre><p>Return if the intersection is empty or not.</p><p><strong>Input</strong></p><ul><li><p><code>cap</code> – intersection of two convex sets</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff the intersection is empty.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/Intersection.jl#L103-L115">source</a></section><h2><a class="nav-anchor" id="Minkowski-Sum-1" href="#Minkowski-Sum-1">Minkowski Sum</a></h2><h3><a class="nav-anchor" id="Binary-Minkowski-Sum-1" href="#Binary-Minkowski-Sum-1">Binary Minkowski Sum</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.MinkowskiSum" href="#LazySets.MinkowskiSum"><code>LazySets.MinkowskiSum</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">MinkowskiSum{N&lt;:Real, S1&lt;:LazySet{N}, S2&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the Minkowski sum of two convex sets.</p><p><strong>Fields</strong></p><ul><li><p><code>X</code> – first convex set</p></li><li><p><code>Y</code> – second convex set</p></li></ul><p><strong>Notes</strong></p><p>The <code>ZeroSet</code> is the neutral element and the <code>EmptySet</code> is the absorbing element for <code>MinkowskiSum</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L10-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{LazySets.LazySet{Float64},LazySets.LazySet{Float64}}" href="#Base.:+-Tuple{LazySets.LazySet{Float64},LazySets.LazySet{Float64}}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">X + Y</code></pre><p>Convenience constructor for Minkowski sum.</p><p><strong>Input</strong></p><ul><li><p><code>X</code> – a convex set</p></li><li><p><code>Y</code> – another convex set</p></li></ul><p><strong>Output</strong></p><p>The symbolic Minkowski sum of <span>$X$</span> and <span>$Y$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L44-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.:⊕" href="#LazySets.:⊕"><code>LazySets.:⊕</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">⊕(X::LazySet, Y::LazySet)</code></pre><p>Unicode alias constructor ⊕ (<code>oplus</code>) for the lazy Minkowski sum operator.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L60-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.MinkowskiSum{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.MinkowskiSum{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(ms::MinkowskiSum)::Int</code></pre><p>Return the dimension of a Minkowski sum.</p><p><strong>Input</strong></p><ul><li><p><code>ms</code> – Minkowski sum</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Minkowski sum.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L67-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.MinkowskiSum{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.MinkowskiSum{Float64,LazySets.LazySet{Float64},LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::V, ms::MinkowskiSum) where {N&lt;:Real, V&lt;:AbstractVector{N}}</code></pre><p>Return the support vector of a Minkowski sum.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>  – direction</p></li><li><p><code>ms</code> – Minkowski sum</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L84-L98">source</a></section><h3><a class="nav-anchor" id="n-ary-Minkowski-Sum-1" href="#n-ary-Minkowski-Sum-1"><span>$n$</span>-ary Minkowski Sum</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.MinkowskiSumArray" href="#LazySets.MinkowskiSumArray"><code>LazySets.MinkowskiSumArray</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">MinkowskiSumArray{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the Minkowski sum of a finite number of convex sets.</p><p><strong>Fields</strong></p><ul><li><p><code>array</code> – array of convex sets</p></li></ul><p><strong>Notes</strong></p><p>This type assumes that the dimensions of all elements match.</p><p>The <code>ZeroSet</code> is the neutral element and the <code>EmptySet</code> is the absorbing element for <code>MinkowskiSumArray</code>.</p><p>Constructors:</p><ul><li><p><code>MinkowskiSumArray(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>MinkowskiSumArray([n]::Int=0, [N]::Type=Float64)</code> – constructor for an empty sum with optional size hint and numeric type</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L107-L129">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.array-Tuple{LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.array-Tuple{LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">array(cpa::CartesianProductArray{N, S}
     )::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>cpa</code> – Cartesian product array</p></li></ul><p><strong>Output</strong></p><p>The array of a Cartesian product of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/CartesianProduct.jl#L177-L190">source</a><div><pre><code class="language-none">array(cha::ConvexHullArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>cha</code> – convex hull array</p></li></ul><p><strong>Output</strong></p><p>The array of a convex hull of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ConvexHull.jl#L157-L169">source</a><div><pre><code class="language-none">array(msa::MinkowskiSumArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Minkowski sum of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>msa</code> – Minkowski sum array</p></li></ul><p><strong>Output</strong></p><p>The array of a Minkowski sum of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L154-L166">source</a><div><pre><code class="language-none">array(cms::CacheMinkowskiSum{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><p><code>cms</code> – caching Minkowski sum</p></li></ul><p><strong>Output</strong></p><p>The array of a caching Minkowski sum.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L294-L306">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(msa::MinkowskiSumArray)::Int</code></pre><p>Return the dimension of a Minkowski sum of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><p><code>msa</code> – Minkowski sum array</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the Minkowski sum of a finite number of sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L171-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.MinkowskiSumArray{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, msa::MinkowskiSumArray)::Vector{&lt;:Real}</code></pre><p>Return the support vector of a Minkowski sum of a finite number of sets in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>   – direction</p></li><li><p><code>msa</code> – Minkowski sum array</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L188-L203">source</a></section><h3><a class="nav-anchor" id="n-ary-Minkowski-Sum-with-cache-1" href="#n-ary-Minkowski-Sum-with-cache-1"><span>$n$</span>-ary Minkowski Sum with cache</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.CacheMinkowskiSum" href="#LazySets.CacheMinkowskiSum"><code>LazySets.CacheMinkowskiSum</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CacheMinkowskiSum{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the Minkowski sum of a finite number of convex sets. Support vector queries are cached.</p><p><strong>Fields</strong></p><ul><li><p><code>array</code> – array of convex sets</p></li><li><p><code>cache</code> – cache of support vector query results</p></li></ul><p><strong>Notes</strong></p><p>This type assumes that the dimensions of all elements match.</p><p>The <code>ZeroSet</code> is the neutral element and the <code>EmptySet</code> is the absorbing element for <code>CacheMinkowskiSum</code>.</p><p>The cache (field <code>cache</code>) is implemented as dictionary whose keys are directions and whose values are pairs <code>(k, s)</code> where <code>k</code> is the number of elements in the array <code>array</code> when the support vector was evaluated last time, and <code>s</code> is the support vector that was obtained. Thus this type assumes that <code>array</code> is not modified except by adding new sets at the end.</p><p>Constructors:</p><ul><li><p><code>CacheMinkowskiSum(array::Vector{&lt;:LazySet})</code> – default constructor</p></li><li><p><code>CacheMinkowskiSum([n]::Int=0, [N]::Type=Float64)</code> – constructor for an empty sum with optional size hint and numeric type</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L236-L267">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.array-Tuple{LazySets.CacheMinkowskiSum{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.array-Tuple{LazySets.CacheMinkowskiSum{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.array</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">array(cpa::CartesianProductArray{N, S}
     )::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Cartesian product of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>cpa</code> – Cartesian product array</p></li></ul><p><strong>Output</strong></p><p>The array of a Cartesian product of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/CartesianProduct.jl#L177-L190">source</a><div><pre><code class="language-none">array(cha::ConvexHullArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a convex hull of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>cha</code> – convex hull array</p></li></ul><p><strong>Output</strong></p><p>The array of a convex hull of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ConvexHull.jl#L157-L169">source</a><div><pre><code class="language-none">array(msa::MinkowskiSumArray{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a Minkowski sum of a finite number of convex sets.</p><p><strong>Input</strong></p><ul><li><p><code>msa</code> – Minkowski sum array</p></li></ul><p><strong>Output</strong></p><p>The array of a Minkowski sum of a finite number of convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L154-L166">source</a><div><pre><code class="language-none">array(cms::CacheMinkowskiSum{N, S})::Vector{S} where {N&lt;:Real, S&lt;:LazySet{N}}</code></pre><p>Return the array of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><p><code>cms</code> – caching Minkowski sum</p></li></ul><p><strong>Output</strong></p><p>The array of a caching Minkowski sum.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L294-L306">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.CacheMinkowskiSum{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.CacheMinkowskiSum{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(cms::CacheMinkowskiSum)::Int</code></pre><p>Return the dimension of a caching Minkowski sum.</p><p><strong>Input</strong></p><ul><li><p><code>cms</code> – caching Minkowski sum</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the caching Minkowski sum.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L312-L324">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.CacheMinkowskiSum{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.CacheMinkowskiSum{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, cms::CacheMinkowskiSum)::Vector{&lt;:Real}</code></pre><p>Return the support vector of a caching Minkowski sum in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>   – direction</p></li><li><p><code>cms</code> – caching Minkowski sum</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the summand sets.</p><p><strong>Notes</strong></p><p>The result is cached, i.e., any further query with the same direction runs in constant time. When sets are added to the caching Minkowski sum, the query is only performed for the new sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L329-L350">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.forget_sets!-Tuple{LazySets.CacheMinkowskiSum}" href="#LazySets.forget_sets!-Tuple{LazySets.CacheMinkowskiSum}"><code>LazySets.forget_sets!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">forget_sets!(cms::CacheMinkowskiSum)::Int</code></pre><p>Tell a caching Minkowski sum to forget the stored sets (but not the support vectors). Only those sets are forgotten such that for each cached direction the support vector has been computed before.</p><p><strong>Input</strong></p><ul><li><p><code>cms</code> – caching Minkowski sum</p></li></ul><p><strong>Output</strong></p><p>The number of sets that have been forgotten.</p><p><strong>Notes</strong></p><p>This function should only be used under the assertion that no new directions are queried in the future; otherwise such support vector results will be incorrect.</p><p>This implementation is optimistic and first tries to remove all sets. However, it also checks that for all cached directions the support vector has been computed before. If it finds that this is not the case, the implementation identifies the biggest index <span>$k$</span> such that the above holds for the <span>$k$</span> oldest sets, and then it only removes these. See the example below.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x1 = BallInf(ones(3), 3.); x2 = Ball1(ones(3), 5.);

julia&gt; cms1 = CacheMinkowskiSum(2); cms2 = CacheMinkowskiSum(2);

julia&gt; d = ones(3);

julia&gt; a1 = array(cms1); a2 = array(cms2);

julia&gt; push!(a1, x1); push!(a2, x1);

julia&gt; σ(d, cms1); σ(d, cms2);

julia&gt; push!(a1, x2); push!(a2, x2);

julia&gt; σ(d, cms1);

# the support vector was computed for both sets
julia&gt; idx1 = forget_sets!(cms1)
2

# the support vector was only computed for the first set
julia&gt; idx1 = forget_sets!(cms2)
1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/MinkowskiSum.jl#L375-L431">source</a></section><h2><a class="nav-anchor" id="Maps-1" href="#Maps-1">Maps</a></h2><h3><a class="nav-anchor" id="Linear-Map-1" href="#Linear-Map-1">Linear Map</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.LinearMap" href="#LazySets.LinearMap"><code>LazySets.LinearMap</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LinearMap{NM, N} &lt;: LazySet{N}</code></pre><p>Type that represents a linear transformation <span>$M⋅S$</span> of a convex set <span>$S$</span>.</p><p><strong>Fields</strong></p><ul><li><p><code>M</code> – matrix/linear map</p></li><li><p><code>X</code> – convex set</p></li></ul><p><strong>Notes</strong></p><p>This type is parametric in the elements of the linear map, <code>NM</code>, and independently on the type of elements of the target set (<code>N</code>). Typically <code>NM = N</code> but it is not necessarily always the case e.g. if <code>NM</code> is an interval that holds numbers of type <code>N</code>, where <code>N</code> is a floating point number type such as <code>Float64</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/LinearMap.jl#L5-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.LinearMap{Float64,Float64}}" href="#LazySets.dim-Tuple{LazySets.LinearMap{Float64,Float64}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(lm::LinearMap)::Int</code></pre><p>Return the dimension of a linear map.</p><p><strong>Input</strong></p><ul><li><p><code>lm</code> – linear map</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the linear map.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/LinearMap.jl#L120-L132">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.LinearMap{Float64,Float64}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.LinearMap{Float64,Float64}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, lm::LinearMap)::AbstractVector{&lt;:Real}</code></pre><p>Return the support vector of the linear map.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>  – direction</p></li><li><p><code>lm</code> – linear map</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$L = M⋅S$</span>, where <span>$M$</span> is a matrix and <span>$S$</span> is a convex set, it follows that <span>$σ(d, L) = M⋅σ(M^T d, S)$</span> for any direction <span>$d$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/LinearMap.jl#L137-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{AbstractArray{T,2} where T,LazySets.LazySet}" href="#Base.:*-Tuple{AbstractArray{T,2} where T,LazySets.LazySet}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">    *(M::AbstractMatrix, X::LazySet)</code></pre><p>Return the linear map of a convex set.</p><p><strong>Input</strong></p><ul><li><p><code>M</code> – matrix/linear map</p></li><li><p><code>X</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>A lazy linear map, i.e. a <code>LinearMap</code> instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/LinearMap.jl#L40-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{Float64,LazySets.LazySet}" href="#Base.:*-Tuple{Float64,LazySets.LazySet}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">    *(a::N, X::LazySet) where {N}</code></pre><p>Return a linear map of a convex set by a scalar value.</p><p><strong>Input</strong></p><ul><li><p><code>a</code> – scalar</p></li><li><p><code>X</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>The linear map of the convex set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/LinearMap.jl#L60-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.LinearMap{Float64,Float64}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.LinearMap{Float64,Float64}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, lm::LinearMap{NM, N})::Bool where {NM, N&lt;:Real}</code></pre><p>Check whether a given point is contained in a linear map of a convex set.</p><p><strong>Input</strong></p><ul><li><p><code>x</code>  – point/vector</p></li><li><p><code>lm</code> – linear map of a convex set</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ lm$</span>.</p><p><strong>Algorithm</strong></p><p>Note that <span>$x ∈ M⋅S$</span> iff <span>$M^{-1}⋅x ∈ S$</span>. This implementation does not explicitly invert the matrix, which is why it also works for non-square matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; lm = LinearMap([2.0 0.0; 0.0 1.0], BallInf([1., 1.], 1.));

julia&gt; ∈([5.0, 1.0], lm)
false
julia&gt; ∈([3.0, 1.0], lm)
true</code></pre><p>An example with non-square matrix:</p><pre><code class="language-julia-repl">julia&gt; B = BallInf(zeros(4), 1.);

julia&gt; M = [1. 0 0 0; 0 1 0 0]/2;

julia&gt; ∈([0.5, 0.5], M*B)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/LinearMap.jl#L161-L201">source</a></section><h3><a class="nav-anchor" id="Exponential-Map-1" href="#Exponential-Map-1">Exponential Map</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ExponentialMap" href="#LazySets.ExponentialMap"><code>LazySets.ExponentialMap</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ExponentialMap{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the action of an exponential map on a convex set.</p><p><strong>Fields</strong></p><ul><li><p><code>spmexp</code> – sparse matrix exponential</p></li><li><p><code>X</code>      – convex set</p></li></ul><p><strong>Examples</strong></p><p>The <code>ExponentialMap</code> type is overloaded to the usual times <code>*</code> operator when the linear map is a lazy matrix exponential. For instance,</p><pre><code class="language-julia-repl">julia&gt; A = sprandn(100, 100, 0.1);

julia&gt; E = SparseMatrixExp(A);

julia&gt; B = BallInf(zeros(100), 1.);

julia&gt; M = E * B; # represents the image set: exp(A) * B

julia&gt; M isa ExponentialMap
true

julia&gt; dim(M)
100</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ExponentialMap.jl#L127-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.ExponentialMap{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.ExponentialMap{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(em::ExponentialMap)::Int</code></pre><p>Return the dimension of an exponential map.</p><p><strong>Input</strong></p><ul><li><p><code>em</code> – an ExponentialMap</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the exponential map.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ExponentialMap.jl#L186-L198">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.ExponentialMap{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.ExponentialMap{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::V, em::ExponentialMap) where {N&lt;:Real, V&lt;:AbstractVector{N}}</code></pre><p>Return the support vector of the exponential map.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>  – direction</p></li><li><p><code>em</code> – exponential map</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$E = \exp(M)⋅S$</span>, where <span>$M$</span> is a matrix and <span>$S$</span> is a convex set, it follows that <span>$σ(d, E) = \exp(M)⋅σ(\exp(M)^T d, S)$</span> for any direction <span>$d$</span>.</p><p>We allow sparse direction vectors, but will convert them to dense vectors to be able to use <code>expmv</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ExponentialMap.jl#L203-L225">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.ExponentialMap{Float64,LazySets.LazySet{Float64}}}" href="#Base.:∈-Tuple{AbstractArray{Float64,1},LazySets.ExponentialMap{Float64,LazySets.LazySet{Float64}}}"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">∈(x::AbstractVector{N}, em::ExponentialMap{&lt;:LazySet{N}})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in an exponential map of a convex set.</p><p><strong>Input</strong></p><ul><li><p><code>x</code>  – point/vector</p></li><li><p><code>em</code> – exponential map of a convex set</p></li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ em$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation exploits that <span>$x ∈ \exp(M)⋅S$</span> iff <span>$\exp(-M)⋅x ∈ S$</span>. This follows from <span>$\exp(-M)⋅\exp(M) = I$</span> for any <span>$M$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; em = ExponentialMap(SparseMatrixExp(SparseMatrixCSC([2.0 0.0; 0.0 1.0])),
                           BallInf([1., 1.], 1.));

julia&gt; ∈([5.0, 1.0], em)
false
julia&gt; ∈([1.0, 1.0], em)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ExponentialMap.jl#L233-L263">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ExponentialProjectionMap" href="#LazySets.ExponentialProjectionMap"><code>LazySets.ExponentialProjectionMap</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ExponentialProjectionMap{N&lt;:Real, S&lt;:LazySet{N}} &lt;: LazySet{N}</code></pre><p>Type that represents the application of a projection of a sparse matrix exponential to a convex set.</p><p><strong>Fields</strong></p><ul><li><p><code>spmexp</code> – projection of a sparse matrix exponential</p></li><li><p><code>X</code>      – convex set</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ExponentialMap.jl#L287-L297">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.ExponentialProjectionMap{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.ExponentialProjectionMap{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(eprojmap::ExponentialProjectionMap)::Int</code></pre><p>Return the dimension of a projection of an exponential map.</p><p><strong>Input</strong></p><ul><li><p><code>eprojmap</code> – projection of an exponential map</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the projection of an exponential map.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ExponentialMap.jl#L331-L343">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.ExponentialProjectionMap{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.ExponentialProjectionMap{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::V, eprojmap::ExponentialProjectionMap) where {N&lt;:Real, V&lt;:AbstractVector{N}}</code></pre><p>Return the support vector of a projection of an exponential map.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>        – direction</p></li><li><p><code>eprojmap</code> – projection of an exponential map</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the result depends on the wrapped set.</p><p><strong>Notes</strong></p><p>If <span>$S = (L⋅M⋅R)⋅X$</span>, where <span>$L$</span> and <span>$R$</span> are matrices, <span>$M$</span> is a matrix exponential, and <span>$X$</span> is a set, it follows that <span>$σ(d, S) = L⋅M⋅R⋅σ(R^T⋅M^T⋅L^T⋅d, X)$</span> for any direction <span>$d$</span>.</p><p>We allow sparse direction vectors, but will convert them to dense vectors to be able to use <code>expmv</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ExponentialMap.jl#L348-L371">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.SparseMatrixExp" href="#LazySets.SparseMatrixExp"><code>LazySets.SparseMatrixExp</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SparseMatrixExp{N}</code></pre><p>Type that represents the matrix exponential, <span>$\exp(M)$</span>, of a sparse matrix.</p><p><strong>Fields</strong></p><ul><li><p><code>M</code> – sparse matrix</p></li></ul><p><strong>Examples</strong></p><p>Take for exammple a random sparse matrix:</p><pre><code class="language-julia-repl">julia&gt; A = sprandn(100, 100, 0.1);

julia&gt; E = SparseMatrixExp(A);

julia&gt; size(E)
(100, 100)</code></pre><p>Now, <code>E</code> is a lazy representation of <span>$\exp(A)$</span>. To compute with <code>E</code>, use <code>get_row</code> and <code>get_column</code> (or <code>get_rows</code> and <code>get_columns</code>; they return row and column vectors (or matrices). For example:</p><pre><code class="language-julia-repl">julia&gt; get_row(E, 10); # compute E[10, :]

julia&gt; get_column(E, 10); # compute E[:, 10]

julia&gt; get_rows(E, [10]); # same as get_row(E, 10) but a 1x100 matrix is returned

julia&gt; get_columns(E, [10]); # same as get_column(E, 10) but a 100x1 matrix is returned</code></pre><p><strong>Notes</strong></p><p>This type is provided for use with very large and very sparse matrices. The evaluation of the exponential matrix action over vectors relies on the <a href="https://github.com/acroy/Expokit.jl">Expokit</a> package.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ExponentialMap.jl#L15-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{LazySets.SparseMatrixExp{Float64},LazySets.LazySet{Float64}}" href="#Base.:*-Tuple{LazySets.SparseMatrixExp{Float64},LazySets.LazySet{Float64}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">    *(spmexp::SparseMatrixExp, X::LazySet)::ExponentialMap</code></pre><p>Return the exponential map of a convex set from a sparse matrix exponential.</p><p><strong>Input</strong></p><ul><li><p><code>spmexp</code> – sparse matrix exponential</p></li><li><p><code>X</code>      – convex set</p></li></ul><p><strong>Output</strong></p><p>The exponential map of the convex set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ExponentialMap.jl#L166-L181">source</a><div><pre><code class="language-none">    *(M::AbstractMatrix, X::LazySet)</code></pre><p>Return the linear map of a convex set.</p><p><strong>Input</strong></p><ul><li><p><code>M</code> – matrix/linear map</p></li><li><p><code>X</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>A lazy linear map, i.e. a <code>LinearMap</code> instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/LinearMap.jl#L40-L55">source</a><div><pre><code class="language-none">    *(a::N, X::LazySet) where {N}</code></pre><p>Return a linear map of a convex set by a scalar value.</p><p><strong>Input</strong></p><ul><li><p><code>a</code> – scalar</p></li><li><p><code>X</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>The linear map of the convex set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/LinearMap.jl#L60-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ProjectionSparseMatrixExp" href="#LazySets.ProjectionSparseMatrixExp"><code>LazySets.ProjectionSparseMatrixExp</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ProjectionSparseMatrixExp{N&lt;:Real}</code></pre><p>Type that represents the projection of a sparse matrix exponential, i.e., <span>$L⋅\exp(M)⋅R$</span> for a given sparse matrix <span>$M$</span>.</p><p><strong>Fields</strong></p><ul><li><p><code>L</code> – left multiplication matrix</p></li><li><p><code>E</code> – sparse matrix exponential</p></li><li><p><code>R</code> – right multiplication matrix</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ExponentialMap.jl#L269-L280">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{LazySets.ProjectionSparseMatrixExp{Float64},LazySets.LazySet{Float64}}" href="#Base.:*-Tuple{LazySets.ProjectionSparseMatrixExp{Float64},LazySets.LazySet{Float64}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">    *(projspmexp::ProjectionSparseMatrixExp,
      X::LazySet)::ExponentialProjectionMap</code></pre><p>Return the application of a projection of a sparse matrix exponential to a convex set.</p><p><strong>Input</strong></p><ul><li><p><code>projspmexp</code> – projection of a sparse matrix exponential</p></li><li><p><code>X</code>          – convex set</p></li></ul><p><strong>Output</strong></p><p>The application of the projection of a sparse matrix exponential to the convex set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/ExponentialMap.jl#L307-L325">source</a><div><pre><code class="language-none">    *(a::N, X::LazySet) where {N}</code></pre><p>Return a linear map of a convex set by a scalar value.</p><p><strong>Input</strong></p><ul><li><p><code>a</code> – scalar</p></li><li><p><code>X</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>The linear map of the convex set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/LinearMap.jl#L60-L75">source</a></section><h2><a class="nav-anchor" id="Symmetric-Interval-Hull-1" href="#Symmetric-Interval-Hull-1">Symmetric Interval Hull</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.SymmetricIntervalHull" href="#LazySets.SymmetricIntervalHull"><code>LazySets.SymmetricIntervalHull</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SymmetricIntervalHull{N&lt;:Real, S&lt;:LazySet{N}} &lt;: AbstractHyperrectangle{N}</code></pre><p>Type that represents the symmetric interval hull of a convex set.</p><p><strong>Fields</strong></p><ul><li><p><code>X</code>     – convex set</p></li><li><p><code>cache</code> – partial storage of already computed bounds, organized as mapping   from dimension to tuples <code>(bound, valid)</code>, where <code>valid</code> is a flag   indicating if the <code>bound</code> entry has been computed</p></li></ul><p><strong>Notes</strong></p><p>The symmetric interval hull can be computed with <span>$2n$</span> support vector queries of unit vectors, where <span>$n$</span> is the dimension of the wrapped set (i.e., two queries per dimension). When asking for the support vector for a direction <span>$d$</span>, one needs <span>$2k$</span> such queries, where <span>$k$</span> is the number of non-zero entries in <span>$d$</span>.</p><p>However, if one asks for many support vectors in a loop, the number of computations may exceed <span>$2n$</span>. To be most efficient in such cases, this type stores the intermediately computed bounds in the <code>cache</code> field.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/SymmetricIntervalHull.jl#L4-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.SymmetricIntervalHull{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.dim-Tuple{LazySets.SymmetricIntervalHull{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(P::AbstractPointSymmetricPolytope)::Int</code></pre><p>Return the ambient dimension of a point symmetric set.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – set</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/AbstractPointSymmetricPolytope.jl#L41-L53">source</a><div><pre><code class="language-none">dim(sih::SymmetricIntervalHull)::Int</code></pre><p>Return the dimension of a symmetric interval hull of a convex set.</p><p><strong>Input</strong></p><ul><li><p><code>sih</code> – symmetric interval hull of a convex set</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the symmetric interval hull of a convex set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/SymmetricIntervalHull.jl#L144-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.SymmetricIntervalHull{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.SymmetricIntervalHull{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::V, H::AbstractHyperrectangle{N}) where {N&lt;:Real, V&lt;:AbstractVector{N}}</code></pre><p>Return the support vector of a hyperrectangular set in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>H</code> – hyperrectangular set</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the vertex with biggest values is returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/AbstractHyperrectangle.jl#L63-L77">source</a><div><pre><code class="language-none">σ(d::V, sih::SymmetricIntervalHull) where {N&lt;:Real, V&lt;:AbstractVector{N}}</code></pre><p>Return the support vector of a symmetric interval hull of a convex set in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code>   – direction</p></li><li><p><code>sih</code> – symmetric interval hull of a convex set</p></li></ul><p><strong>Output</strong></p><p>The support vector of the symmetric interval hull of a convex set in the given direction. If the direction has norm zero, the origin is returned.</p><p><strong>Algorithm</strong></p><p>For each non-zero entry in <code>d</code> we need to either look up the bound (if it has been computed before) or compute it, in which case we store it for future queries. One such computation just asks for the support vector of the underlying set for both the positive and negative unit vector in the respective dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/SymmetricIntervalHull.jl#L161-L185">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{LazySets.SymmetricIntervalHull{Float64,LazySets.LazySet{Float64}}}" href="#LazySets.an_element-Tuple{LazySets.SymmetricIntervalHull{Float64,LazySets.LazySet{Float64}}}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">an_element(S::LazySet{N}) where {N&lt;:Real}</code></pre><p>Return some element of a convex set.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>An element of a convex set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/LazySet.jl#L174-L186">source</a><div><pre><code class="language-none">an_element(P::AbstractPointSymmetricPolytope{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a point symmetric polytope.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – point symmetric polytope</p></li></ul><p><strong>Output</strong></p><p>The center of the point symmetric polytope.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/92e7920684957322941af991f1055f304782df43/src/AbstractPointSymmetricPolytope.jl#L59-L71">source</a></section><footer><hr/><a class="previous" href="representations.html"><span class="direction">Previous</span><span class="title">Common Set Representations</span></a><a class="next" href="conversion.html"><span class="direction">Next</span><span class="title">Conversion between set representations</span></a></footer></article></body></html>
