<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Common Set Representations · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/getting_started/">Getting Started</a></li><li><a class="toctext" href="../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="toctext" href="../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="toctext" href="../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="toctext" href="../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="toctext" href="../../man/interval_hulls/">Interval Hulls</a></li><li><a class="toctext" href="../../man/convex_hulls/">Convex Hulls</a></li><li><a class="toctext" href="../../man/set_operations/">Operations on Sets</a></li><li><a class="toctext" href="../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="toctext" href="../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="toctext" href="../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="toctext" href="../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../interfaces/">Set Interfaces</a></li><li class="current"><a class="toctext" href>Common Set Representations</a><ul class="internal"><li><a class="toctext" href="#Balls-1">Balls</a></li><li><a class="toctext" href="#Ellipsoid-1">Ellipsoid</a></li><li><a class="toctext" href="#Empty-set-1">Empty set</a></li><li><a class="toctext" href="#Half-Space-1">Half-Space</a></li><li><a class="toctext" href="#Hyperplane-1">Hyperplane</a></li><li><a class="toctext" href="#Hyperrectangle-1">Hyperrectangle</a></li><li><a class="toctext" href="#Interval-1">Interval</a></li><li><a class="toctext" href="#Line-1">Line</a></li><li><a class="toctext" href="#Line-segment-1">Line segment</a></li><li><a class="toctext" href="#Polygons-1">Polygons</a></li><li><a class="toctext" href="#Polyhedra-and-Polytopes-1">Polyhedra and Polytopes</a></li><li><a class="toctext" href="#Polynomial-Zonotopes-1">Polynomial Zonotopes</a></li><li><a class="toctext" href="#Singleton-1">Singleton</a></li><li><a class="toctext" href="#Universe-1">Universe</a></li><li><a class="toctext" href="#Zero-set-1">Zero set</a></li><li><a class="toctext" href="#Zonotope-1">Zonotope</a></li></ul></li><li><a class="toctext" href="../operations/">Common Set Operations</a></li><li><a class="toctext" href="../comparisons/">Comparisons</a></li><li><a class="toctext" href="../conversion/">Conversions between set representations</a></li><li><a class="toctext" href="../binary_functions/">Binary Functions on Sets</a></li><li><a class="toctext" href="../approximations/">Approximations</a></li><li><a class="toctext" href="../utils/">Utility Functions</a></li><li><a class="toctext" href="../parallel/">Parallel</a></li></ul></li><li><a class="toctext" href="../../about/">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Common Set Representations</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/representations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Common Set Representations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Common-Set-Representations-1" href="#Common-Set-Representations-1">Common Set Representations</a></h1><p>This section of the manual describes the basic set representation types.</p><ul><li><a href="#Common-Set-Representations-1">Common Set Representations</a></li><ul><li><a href="#Balls-1">Balls</a></li><ul><li><a href="#Euclidean-norm-ball-1">Euclidean norm ball</a></li><li><a href="#Infinity-norm-ball-1">Infinity norm ball</a></li><li><a href="#Manhattan-norm-ball-1">Manhattan norm ball</a></li><li><a href="#p-norm-ball-1">p-norm ball</a></li></ul><li><a href="#Ellipsoid-1">Ellipsoid</a></li><li><a href="#Empty-set-1">Empty set</a></li><li><a href="#Half-Space-1">Half-Space</a></li><li><a href="#Hyperplane-1">Hyperplane</a></li><li><a href="#Hyperrectangle-1">Hyperrectangle</a></li><li><a href="#Interval-1">Interval</a></li><li><a href="#Line-1">Line</a></li><li><a href="#Line-segment-1">Line segment</a></li><li><a href="#Polygons-1">Polygons</a></li><ul><li><a href="#Constraint-representation-1">Constraint representation</a></li><li><a href="#Optimized-constraint-representation-1">Optimized constraint representation</a></li><li><a href="#Vertex-representation-1">Vertex representation</a></li><li><a href="#Sorting-directions-1">Sorting directions</a></li></ul><li><a href="#Polyhedra-and-Polytopes-1">Polyhedra and Polytopes</a></li><ul><li><a href="#Constraint-representation-2">Constraint representation</a></li><li><a href="#Vertex-representation-2">Vertex representation</a></li></ul><li><a href="#Polynomial-Zonotopes-1">Polynomial Zonotopes</a></li><li><a href="#Singleton-1">Singleton</a></li><li><a href="#Universe-1">Universe</a></li><li><a href="#Zero-set-1">Zero set</a></li><li><a href="#Zonotope-1">Zonotope</a></li></ul></ul><h2><a class="nav-anchor" id="Balls-1" href="#Balls-1">Balls</a></h2><h3><a class="nav-anchor" id="Euclidean-norm-ball-1" href="#Euclidean-norm-ball-1">Euclidean norm ball</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Ball2" href="#LazySets.Ball2"><code>LazySets.Ball2</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Ball2{N&lt;:AbstractFloat} &lt;: AbstractCentrallySymmetric{N}</code></pre><p>Type that represents a ball in the 2-norm.</p><p><strong>Fields</strong></p><ul><li><code>center</code> – center of the ball as a real vector</li><li><code>radius</code> – radius of the ball as a real scalar (<span>$≥ 0$</span>)</li></ul><p><strong>Notes</strong></p><p>Mathematically, a ball in the 2-norm is defined as the set</p><div>\[\mathcal{B}_2^n(c, r) = \{ x ∈ \mathbb{R}^n : ‖ x - c ‖_2 ≤ r \},\]</div><p>where <span>$c ∈ \mathbb{R}^n$</span> is its center and <span>$r ∈ \mathbb{R}_+$</span> its radius. Here <span>$‖ ⋅ ‖_2$</span> denotes the Euclidean norm (also known as 2-norm), defined as <span>$‖ x ‖_2 = \left( \sum\limits_{i=1}^n |x_i|^2 \right)^{1/2}$</span> for any <span>$x ∈ \mathbb{R}^n$</span>.</p><p><strong>Examples</strong></p><p>Create a five-dimensional ball <code>B</code> in the 2-norm centered at the origin with radius 0.5:</p><pre><code class="language-julia-repl">julia&gt; B = Ball2(zeros(5), 0.5)
Ball2{Float64}([0.0, 0.0, 0.0, 0.0, 0.0], 0.5)
julia&gt; dim(B)
5</code></pre><p>Evaluate <code>B</code>&#39;s support vector in the direction <span>$[1,2,3,4,5]$</span>:</p><pre><code class="language-julia-repl">julia&gt; σ([1.,2.,3.,4.,5.], B)
5-element Array{Float64,1}:
 0.06741998624632421
 0.13483997249264842
 0.20225995873897262
 0.26967994498529685
 0.3370999312316211</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ball2.jl#L6-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ball2{N}}} where N&lt;:AbstractFloat" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ball2{N}}} where N&lt;:AbstractFloat"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, B::Ball2{N}) where {N&lt;:AbstractFloat}</code></pre><p>Return the support vector of a 2-norm ball in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>B</code> – ball in the 2-norm</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the origin is returned.</p><p><strong>Notes</strong></p><p>Let <span>$c$</span> and <span>$r$</span> be the center and radius of a ball <span>$B$</span> in the 2-norm, respectively. For nonzero direction <span>$d$</span> we have</p><div>\[σ_B(d) = c + r \frac{d}{‖d‖_2}.\]</div><p>This function requires computing the 2-norm of the input direction, which is performed in the given precision of the numeric datatype of both the direction and the set. Exact inputs are not supported.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ball2.jl#L91-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ball2{N}}} where N&lt;:AbstractFloat" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ball2{N}}} where N&lt;:AbstractFloat"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, B::Ball2{N})::Bool where {N&lt;:AbstractFloat}</code></pre><p>Check whether a given point is contained in a ball in the 2-norm.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>B</code> – ball in the 2-norm</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ B$</span>.</p><p><strong>Notes</strong></p><p>This implementation is worst-case optimized, i.e., it is optimistic and first computes (see below) the whole sum before comparing to the radius. In applications where the point is typically far away from the ball, a fail-fast implementation with interleaved comparisons could be more efficient.</p><p><strong>Algorithm</strong></p><p>Let <span>$B$</span> be an <span>$n$</span>-dimensional ball in the 2-norm with radius <span>$r$</span> and let <span>$c_i$</span> and <span>$x_i$</span> be the ball&#39;s center and the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ B$</span> iff <span>$\left( ∑_{i=1}^n |c_i - x_i|^2 \right)^{1/2} ≤ r$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = Ball2([1., 1.], sqrt(0.5))
Ball2{Float64}([1.0, 1.0], 0.7071067811865476)
julia&gt; ∈([.5, 1.6], B)
false
julia&gt; ∈([.5, 1.5], B)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ball2.jl#L130-L168">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Union{Tuple{Ball2{N}}, Tuple{N}} where N&lt;:AbstractFloat" href="#LazySets.center-Union{Tuple{Ball2{N}}, Tuple{N}} where N&lt;:AbstractFloat"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">center(B::Ball2{N})::Vector{N} where {N&lt;:AbstractFloat}</code></pre><p>Return the center of a ball in the 2-norm.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the 2-norm</li></ul><p><strong>Output</strong></p><p>The center of the ball in the 2-norm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ball2.jl#L70-L82">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{Ball2}}" href="#Base.rand-Tuple{Type{Ball2}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{Ball2}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::Ball2{N}</code></pre><p>Create a random ball in the 2-norm.</p><p><strong>Input</strong></p><ul><li><code>Ball2</code> – type for dispatch</li><li><code>N</code>     – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>   – (optional, default: 2) dimension</li><li><code>rng</code>   – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>  – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A random ball in the 2-norm.</p><p><strong>Algorithm</strong></p><p>All numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the radius is nonnegative.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ball2.jl#L178-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{Ball2{N},AbstractArray{N,1}}} where N&lt;:AbstractFloat" href="#LazySets.translate-Union{Tuple{N}, Tuple{Ball2{N},AbstractArray{N,1}}} where N&lt;:AbstractFloat"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(B::Ball2{N}, v::AbstractVector{N}) where {N&lt;:AbstractFloat}</code></pre><p>Translate (i.e., shift) a ball in the 2-norm by a given vector.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the 2-norm</li><li><code>v</code> – translation vector</li></ul><p><strong>Output</strong></p><p>A translated ball in the 2-norm.</p><p><strong>Algorithm</strong></p><p>We add the vector to the center of the ball.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ball2.jl#L214-L231">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractCentrallySymmetric"><code>AbstractCentrallySymmetric</code></a>:</p><ul><li><a href="../interfaces/#LazySets.dim-Tuple{AbstractCentrallySymmetric}"><code>dim</code></a></li><li><a href="../interfaces/#LazySets.isbounded-Tuple{AbstractCentrallySymmetric}"><code>isbounded</code></a></li><li><a href="../interfaces/#Base.isempty-Tuple{AbstractCentrallySymmetric}"><code>isempty</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h3><a class="nav-anchor" id="Infinity-norm-ball-1" href="#Infinity-norm-ball-1">Infinity norm ball</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.BallInf" href="#LazySets.BallInf"><code>LazySets.BallInf</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BallInf{N&lt;:Real} &lt;: AbstractHyperrectangle{N}</code></pre><p>Type that represents a ball in the infinity norm.</p><p><strong>Fields</strong></p><ul><li><code>center</code> – center of the ball as a real vector</li><li><code>radius</code> – radius of the ball as a real scalar (<span>$≥ 0$</span>)</li></ul><p><strong>Notes</strong></p><p>Mathematically, a ball in the infinity norm is defined as the set</p><div>\[\mathcal{B}_∞^n(c, r) = \{ x ∈ \mathbb{R}^n : ‖ x - c ‖_∞ ≤ r \},\]</div><p>where <span>$c ∈ \mathbb{R}^n$</span> is its center and <span>$r ∈ \mathbb{R}_+$</span> its radius. Here <span>$‖ ⋅ ‖_∞$</span> denotes the infinity norm, defined as <span>$‖ x ‖_∞ = \max\limits_{i=1,…,n} \vert x_i \vert$</span> for any <span>$x ∈ \mathbb{R}^n$</span>.</p><p><strong>Examples</strong></p><p>Create the two-dimensional unit ball and compute its support function along the positive <span>$x=y$</span> direction:</p><pre><code class="language-julia-repl">julia&gt; B = BallInf(zeros(2), 1.0)
BallInf{Float64}([0.0, 0.0], 1.0)
julia&gt; dim(B)
2
julia&gt; ρ([1., 1.], B)
2.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/BallInf.jl#L5-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Union{Tuple{BallInf{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.center-Union{Tuple{BallInf{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">center(B::BallInf{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a ball in the infinity norm.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the infinity norm</li></ul><p><strong>Output</strong></p><p>The center of the ball in the infinity norm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/BallInf.jl#L100-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius" href="#LazySets.radius"><code>LazySets.radius</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">radius(B::BallInf, [p]::Real=Inf)::Real</code></pre><p>Return the radius of a ball in the infinity norm.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the infinity norm</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p><p><strong>Notes</strong></p><p>The radius is defined as the radius of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/BallInf.jl#L121-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{BallInf{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{BallInf{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">radius_hyperrectangle(B::BallInf{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the box radius of a infinity norm ball, which is the same in every dimension.</p><p><strong>Input</strong></p><ul><li><code>B</code> – infinity norm ball</li></ul><p><strong>Output</strong></p><p>The box radius of the ball in the infinity norm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/BallInf.jl#L78-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{BallInf{N},Int64}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{BallInf{N},Int64}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">radius_hyperrectangle(B::BallInf{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the box radius of a infinity norm ball in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>B</code> – infinity norm ball</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The box radius of the ball in the infinity norm in the given dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/BallInf.jl#L60-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{BallInf}}" href="#Base.rand-Tuple{Type{BallInf}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{BallInf}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::BallInf{N}</code></pre><p>Create a random ball in the infinity norm.</p><p><strong>Input</strong></p><ul><li><code>BallInf</code> – type for dispatch</li><li><code>N</code>       – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>     – (optional, default: 2) dimension</li><li><code>rng</code>     – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>    – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A random ball in the infinity norm.</p><p><strong>Algorithm</strong></p><p>All numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the radius is nonnegative.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/BallInf.jl#L144-L167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{BallInf{N},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{N}, Tuple{BallInf{N},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(B::BallInf{N}, v::AbstractVector{N}) where {N&lt;:Real}</code></pre><p>Translate (i.e., shift) a ball in the infinity norm by a given vector.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the infinity norm</li><li><code>v</code> – translation vector</li></ul><p><strong>Output</strong></p><p>A translated ball in the infinity norm.</p><p><strong>Algorithm</strong></p><p>We add the vector to the center of the ball.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/BallInf.jl#L180-L197">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.isbounded-Tuple{AbstractPolytope}"><code>isbounded</code></a></li><li><a href="../interfaces/#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>singleton_list</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractCentrallySymmetricPolytope"><code>AbstractCentrallySymmetricPolytope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}"><code>dim</code></a></li><li><a href="../interfaces/#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}"><code>isempty</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractHyperrectangle"><code>AbstractHyperrectangle</code></a>:</p><ul><li><a href="../interfaces/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>σ</code></a></li><li><a href="../interfaces/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>∈</code></a></li><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../interfaces/#LazySets.vertices_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>vertices_list</code></a></li><li><a href="../interfaces/#LazySets.high-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>high</code></a></li><li><a href="../interfaces/#LazySets.low-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>low</code></a></li></ul><h3><a class="nav-anchor" id="Manhattan-norm-ball-1" href="#Manhattan-norm-ball-1">Manhattan norm ball</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Ball1" href="#LazySets.Ball1"><code>LazySets.Ball1</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Ball1{N&lt;:Real} &lt;: AbstractCentrallySymmetricPolytope{N}</code></pre><p>Type that represents a ball in the 1-norm (also known as the Manhattan norm). The ball is also known as a <a href="https://en.wikipedia.org/wiki/Cross-polytope">cross-polytope</a>.</p><p>It is defined as the set</p><div>\[\mathcal{B}_1^n(c, r) = \{ x ∈ \mathbb{R}^n : ∑_{i=1}^n |c_i - x_i| ≤ r \},\]</div><p>where <span>$c ∈ \mathbb{R}^n$</span> is its center and <span>$r ∈ \mathbb{R}_+$</span> its radius.</p><p><strong>Fields</strong></p><ul><li><code>center</code> – center of the ball as a real vector</li><li><code>radius</code> – radius of the ball as a scalar (<span>$≥ 0$</span>)</li></ul><p><strong>Examples</strong></p><p>Unit ball in the 1-norm in the plane:</p><pre><code class="language-julia-repl">julia&gt; B = Ball1(zeros(2), 1.)
Ball1{Float64}([0.0, 0.0], 1.0)
julia&gt; dim(B)
2</code></pre><p>We evaluate the support vector in the East direction:</p><pre><code class="language-julia-repl">julia&gt; σ([0.,1], B)
2-element Array{Float64,1}:
 0.0
 1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ball1.jl#L6-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ball1{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ball1{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, B::Ball1{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a ball in the 1-norm in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>B</code> – ball in the 1-norm</li></ul><p><strong>Output</strong></p><p>Support vector in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ball1.jl#L119-L132">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ball1{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ball1{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, B::Ball1{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>B</code> – ball in the 1-norm</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ B$</span>.</p><p><strong>Notes</strong></p><p>This implementation is worst-case optimized, i.e., it is optimistic and first computes (see below) the whole sum before comparing to the radius. In applications where the point is typically far away from the ball, a fail-fast implementation with interleaved comparisons could be more efficient.</p><p><strong>Algorithm</strong></p><p>Let <span>$B$</span> be an <span>$n$</span>-dimensional ball in the 1-norm with radius <span>$r$</span> and let <span>$c_i$</span> and <span>$x_i$</span> be the ball&#39;s center and the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ B$</span> iff <span>$∑_{i=1}^n |c_i - x_i| ≤ r$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = Ball1([1., 1.], 1.);

julia&gt; ∈([.5, -.5], B)
false
julia&gt; ∈([.5, 1.5], B)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ball1.jl#L140-L178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{Ball1{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{Ball1{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(B::Ball1{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the 1-norm</li></ul><p><strong>Output</strong></p><p>A list containing the vertices of the ball in the 1-norm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ball1.jl#L84-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Union{Tuple{Ball1{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.center-Union{Tuple{Ball1{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">center(B::Ball1{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the 1-norm</li></ul><p><strong>Output</strong></p><p>The center of the ball in the 1-norm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ball1.jl#L63-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{Ball1}}" href="#Base.rand-Tuple{Type{Ball1}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{Ball1}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::Ball1{N}</code></pre><p>Create a random ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><code>Ball1</code> – type for dispatch</li><li><code>N</code>     – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>   – (optional, default: 2) dimension</li><li><code>rng</code>   – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>  – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A random ball in the 1-norm.</p><p><strong>Algorithm</strong></p><p>All numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the radius is nonnegative.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ball1.jl#L188-L211">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{Ball1{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{Ball1{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(P::Ball1{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints defining a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the 1-norm</li></ul><p><strong>Output</strong></p><p>The list of constraints of the ball.</p><p><strong>Algorithm</strong></p><p>The constraints can be defined as <span>$d_i^T (x-c) ≤ r$</span> for all <span>$d_i$</span>, where <span>$d_i$</span> is a vector with elements <span>$1$</span> or <span>$-1$</span> in <span>$n$</span> dimensions. To span all possible <span>$d_i$</span>, the function <code>Iterators.product</code> is used.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ball1.jl#L224-L242">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{Ball1{N},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{N}, Tuple{Ball1{N},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(B::Ball1{N}, v::AbstractVector{N}) where {N&lt;:Real}</code></pre><p>Translate (i.e., shift) a ball in the 1-norm by a given vector.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the 1-norm</li><li><code>v</code> – translation vector</li></ul><p><strong>Output</strong></p><p>A translated ball in the 1-norm.</p><p><strong>Algorithm</strong></p><p>We add the vector to the center of the ball.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ball1.jl#L254-L271">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.isbounded-Tuple{AbstractPolytope}"><code>isbounded</code></a></li><li><a href="../interfaces/#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>singleton_list</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractCentrallySymmetricPolytope"><code>AbstractCentrallySymmetricPolytope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}"><code>dim</code></a></li><li><a href="../interfaces/#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}"><code>isempty</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h3><a class="nav-anchor" id="p-norm-ball-1" href="#p-norm-ball-1">p-norm ball</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Ballp" href="#LazySets.Ballp"><code>LazySets.Ballp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Ballp{N&lt;:AbstractFloat} &lt;: AbstractCentrallySymmetric{N}</code></pre><p>Type that represents a ball in the p-norm, for <span>$1 ≤ p ≤ ∞$</span>.</p><p>It is defined as the set</p><div>\[\mathcal{B}_p^n(c, r) = \{ x ∈ \mathbb{R}^n : ‖ x - c ‖_p ≤ r \},\]</div><p>where <span>$c ∈ \mathbb{R}^n$</span> is its center and <span>$r ∈ \mathbb{R}_+$</span> its radius. Here <span>$‖ ⋅ ‖_p$</span> for <span>$1 ≤ p ≤ ∞$</span> denotes the vector <span>$p$</span>-norm, defined as <span>$‖ x ‖_p = \left( \sum\limits_{i=1}^n |x_i|^p \right)^{1/p}$</span> for any <span>$x ∈ \mathbb{R}^n$</span>.</p><p><strong>Fields</strong></p><ul><li><code>p</code>      – norm as a real scalar</li><li><code>center</code> – center of the ball as a real vector</li><li><code>radius</code> – radius of the ball as a scalar (<span>$≥ 0$</span>)</li></ul><p><strong>Notes</strong></p><p>The special cases <span>$p=1$</span>, <span>$p=2$</span> and <span>$p=∞$</span> fall back to the specialized types <code>Ball1</code>, <code>Ball2</code> and <code>BallInf</code>, respectively.</p><p><strong>Examples</strong></p><p>A five-dimensional ball in the <span>$p=3/2$</span> norm centered at the origin of radius 0.5:</p><pre><code class="language-julia-repl">julia&gt; B = Ballp(3/2, zeros(5), 0.5)
Ballp{Float64}(1.5, [0.0, 0.0, 0.0, 0.0, 0.0], 0.5)
julia&gt; dim(B)
5</code></pre><p>We evaluate the support vector in direction <span>$[1,2,…,5]$</span>:</p><pre><code class="language-julia-repl">julia&gt; σ([1., 2, 3, 4, 5], B)
5-element Array{Float64,1}:
 0.013516004434607558
 0.05406401773843023
 0.12164403991146802
 0.21625607095372093
 0.33790011086518895</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ballp.jl#L6-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ballp{N}}} where N&lt;:AbstractFloat" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ballp{N}}} where N&lt;:AbstractFloat"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, B::Ballp{N}) where {N&lt;:AbstractFloat}</code></pre><p>Return the support vector of a <code>Ballp</code> in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>B</code> – ball in the p-norm</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the center of the ball is returned.</p><p><strong>Algorithm</strong></p><p>The support vector of the unit ball in the <span>$p$</span>-norm along direction <span>$d$</span> is:</p><div>\[σ_{\mathcal{B}_p^n(0, 1)}(d) = \dfrac{\tilde{v}}{‖\tilde{v}‖_q},\]</div><p>where <span>$\tilde{v}_i = \frac{|d_i|^q}{d_i}$</span> if <span>$d_i ≠ 0$</span> and <span>$tilde{v}_i = 0$</span> otherwise, for all <span>$i=1,…,n$</span>, and <span>$q$</span> is the conjugate number of <span>$p$</span>. By the affine transformation <span>$x = r\tilde{x} + c$</span>, one obtains that the support vector of <span>$\mathcal{B}_p^n(c, r)$</span> is</p><div>\[σ_{\mathcal{B}_p^n(c, r)}(d) = \dfrac{v}{‖v‖_q},\]</div><p>where <span>$v_i = c_i + r\frac{|d_i|^q}{d_i}$</span> if <span>$d_i ≠ 0$</span> and <span>$v_i = 0$</span> otherwise, for all <span>$i = 1, …, n$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ballp.jl#L106-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ballp{N}}} where N&lt;:AbstractFloat" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ballp{N}}} where N&lt;:AbstractFloat"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, B::Ballp{N})::Bool where {N&lt;:AbstractFloat}</code></pre><p>Check whether a given point is contained in a ball in the p-norm.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>B</code> – ball in the p-norm</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ B$</span>.</p><p><strong>Notes</strong></p><p>This implementation is worst-case optimized, i.e., it is optimistic and first computes (see below) the whole sum before comparing to the radius. In applications where the point is typically far away from the ball, a fail-fast implementation with interleaved comparisons could be more efficient.</p><p><strong>Algorithm</strong></p><p>Let <span>$B$</span> be an <span>$n$</span>-dimensional ball in the p-norm with radius <span>$r$</span> and let <span>$c_i$</span> and <span>$x_i$</span> be the ball&#39;s center and the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ B$</span> iff <span>$\left( ∑_{i=1}^n |c_i - x_i|^p \right)^{1/p} ≤ r$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = Ballp(1.5, [1., 1.], 1.)
Ballp{Float64}(1.5, [1.0, 1.0], 1.0)
julia&gt; ∈([.5, -.5], B)
false
julia&gt; ∈([.5, 1.5], B)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ballp.jl#L152-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Union{Tuple{Ballp{N}}, Tuple{N}} where N&lt;:AbstractFloat" href="#LazySets.center-Union{Tuple{Ballp{N}}, Tuple{N}} where N&lt;:AbstractFloat"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">center(B::Ballp{N})::Vector{N} where {N&lt;:AbstractFloat}</code></pre><p>Return the center of a ball in the p-norm.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the p-norm</li></ul><p><strong>Output</strong></p><p>The center of the ball in the p-norm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ballp.jl#L85-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{Ballp}}" href="#Base.rand-Tuple{Type{Ballp}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{Ballp}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::Ballp{N}</code></pre><p>Create a random ball in the p-norm.</p><p><strong>Input</strong></p><ul><li><code>Ballp</code> – type for dispatch</li><li><code>N</code>     – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>   – (optional, default: 2) dimension</li><li><code>rng</code>   – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>  – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A random ball in the p-norm.</p><p><strong>Algorithm</strong></p><p>The center and radius are normally distributed with mean 0 and standard deviation 1. Additionally, the radius is nonnegative. The p-norm is a normally distributed number ≥ 1 with mean 1 and standard deviation 1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ballp.jl#L200-L226">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{Ballp{N},AbstractArray{N,1}}} where N&lt;:AbstractFloat" href="#LazySets.translate-Union{Tuple{N}, Tuple{Ballp{N},AbstractArray{N,1}}} where N&lt;:AbstractFloat"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(B::Ballp{N}, v::AbstractVector{N}) where {N&lt;:AbstractFloat}</code></pre><p>Translate (i.e., shift) a ball in the p-norm by a given vector.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the p-norm</li><li><code>v</code> – translation vector</li></ul><p><strong>Output</strong></p><p>A translated ball in the p- norm.</p><p><strong>Algorithm</strong></p><p>We add the vector to the center of the ball.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ballp.jl#L240-L257">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractCentrallySymmetric"><code>AbstractCentrallySymmetric</code></a>:</p><ul><li><a href="../interfaces/#LazySets.dim-Tuple{AbstractCentrallySymmetric}"><code>dim</code></a></li><li><a href="../interfaces/#LazySets.isbounded-Tuple{AbstractCentrallySymmetric}"><code>isbounded</code></a></li><li><a href="../interfaces/#Base.isempty-Tuple{AbstractCentrallySymmetric}"><code>isempty</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h2><a class="nav-anchor" id="Ellipsoid-1" href="#Ellipsoid-1">Ellipsoid</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Ellipsoid" href="#LazySets.Ellipsoid"><code>LazySets.Ellipsoid</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Ellipsoid{N&lt;:AbstractFloat} &lt;:  AbstractCentrallySymmetric{N}</code></pre><p>Type that represents an ellipsoid.</p><p>It is defined as the set</p><div>\[E = \left\{ x ∈ \mathbb{R}^n : (x-c)Q^{-1}(x-c) ≤ 1 \right\},\]</div><p>where <span>$c \in \mathbb{R}^n$</span> is its <em>center</em> and <span>$Q \in \mathbb{R}^{n×n}$</span> its <em>shape matrix</em>, which should be a positive definite matrix. An ellipsoid can also be characterized as the image of a Euclidean ball by an invertible linear transformation. It is the higher-dimensional generalization of an ellipse.</p><p><strong>Fields</strong></p><ul><li><code>center</code>       – center of the ellipsoid</li><li><code>shape matrix</code> – real positive definite matrix, i.e. it is equal to its transpose                   and <span>$x^\mathrm{T}Qx &gt; 0$</span> for all nonzero <span>$x$</span></li></ul><p><strong>Examples</strong></p><p>If the center is not specified, it is assumed that the center is the origin. For instance, a 3D ellipsoid with center at the origin and the shape matrix being the identity can be created with:</p><pre><code class="language-julia-repl">julia&gt; E = Ellipsoid(Matrix{Float64}(I, 3, 3))
Ellipsoid{Float64}([0.0, 0.0, 0.0], [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])

julia&gt; dim(E)
3

julia&gt; an_element(E)
3-element Array{Float64,1}:
 0.0
 0.0
 0.0</code></pre><p>This ellipsoid corresponds to the unit Euclidean ball. Let&#39;s evaluate its support vector in a given direction:</p><pre><code class="language-julia-repl">julia&gt; σ(ones(3), E)
3-element Array{Float64,1}:
 0.5773502691896258
 0.5773502691896258
 0.5773502691896258</code></pre><p>A two-dimensional ellipsoid with given center and shape matrix:</p><pre><code class="language-julia">julia&gt; E = Ellipsoid(ones(2), Diagonal([2.0, 0.5]))
Ellipsoid{Float64}([1.0, 1.0], [2.0 0.0; 0.0 0.5])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ellipsoid.jl#L5-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ellipsoid{N}}} where N&lt;:AbstractFloat" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ellipsoid{N}}} where N&lt;:AbstractFloat"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, E::Ellipsoid{N}) where {N&lt;:AbstractFloat}</code></pre><p>Return the support function of an ellipsoid in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>E</code> – ellipsoid</li></ul><p><strong>Output</strong></p><p>The support function of the ellipsoid in the given direction.</p><p><strong>Algorithm</strong></p><p>The support value is <span>$cᵀ d + ‖Bᵀ d‖₂$</span> where <span>$c$</span> is the center and <span>$Q = B Bᵀ$</span> is the shape matrix of <code>E</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ellipsoid.jl#L146-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ellipsoid{N}}} where N&lt;:AbstractFloat" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ellipsoid{N}}} where N&lt;:AbstractFloat"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, E::Ellipsoid{N}) where {N&lt;:AbstractFloat}</code></pre><p>Return the support vector of an ellipsoid in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>E</code> – ellipsoid</li></ul><p><strong>Output</strong></p><p>Support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>Let <span>$E$</span> be an ellipsoid of center <span>$c$</span> and shape matrix <span>$Q = BB^\mathrm{T}$</span>. Its support vector along direction <span>$d$</span> can be deduced from that of the unit Euclidean ball <span>$\mathcal{B}_2$</span> using the algebraic relations for the support vector,</p><div>\[σ_{B\mathcal{B}_2 ⊕ c}(d) = c + Bσ_{\mathcal{B}_2} (B^\mathrm{T} d)
= c + \dfrac{Qd}{\sqrt{d^\mathrm{T}Q d}}.\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ellipsoid.jl#L112-L137">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ellipsoid{N}}} where N&lt;:AbstractFloat" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Ellipsoid{N}}} where N&lt;:AbstractFloat"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, E::Ellipsoid{N})::Bool where {N&lt;:AbstractFloat}</code></pre><p>Check whether a given point is contained in an ellipsoid.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>E</code> – ellipsoid</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>x ∈ E</code>.</p><p><strong>Algorithm</strong></p><p>The point <span>$x$</span> belongs to the ellipsoid of center <span>$c$</span> and shape matrix <span>$Q$</span> if and only if</p><div>\[(x-c)^\mathrm{T} Q^{-1} (x-c) ≤ 1.\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ellipsoid.jl#L169-L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{Ellipsoid}}" href="#Base.rand-Tuple{Type{Ellipsoid}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{Ellipsoid}; [N]::Type{&lt;:AbstractFloat}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::Ellipsoid{N}</code></pre><p>Create a random ellipsoid.</p><p><strong>Input</strong></p><ul><li><code>Ellipsoid</code> – type for dispatch</li><li><code>N</code>         – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>       – (optional, default: 2) dimension</li><li><code>rng</code>       – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>      – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A random ellipsoid.</p><p><strong>Algorithm</strong></p><p>The center is a normally distributed vector with entries of mean 0 and standard deviation 1.</p><p>The idea for the shape matrix comes from <a href="https://math.stackexchange.com/a/358092">here</a>. The matrix is symmetric positive definite, but also diagonally dominant.</p><div>\[Q =  rac{1}{2}(S + S^T) + nI,\]</div><p>where <span>$n$</span> = <code>dim</code> (defaults to 2), and <span>$S$</span> is a <span>$n \times n$</span> random matrix whose coefficients are uniformly distributed in the interval <span>$[-1, 1]$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ellipsoid.jl#L198-L231">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Union{Tuple{Ellipsoid{N}}, Tuple{N}} where N&lt;:AbstractFloat" href="#LazySets.center-Union{Tuple{Ellipsoid{N}}, Tuple{N}} where N&lt;:AbstractFloat"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">center(E::Ellipsoid{N})::Vector{N} where {N&lt;:AbstractFloat}</code></pre><p>Return the center of the ellipsoid.</p><p><strong>Input</strong></p><ul><li><code>E</code> – ellipsoid</li></ul><p><strong>Output</strong></p><p>The center of the ellipsoid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ellipsoid.jl#L91-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{Ellipsoid{N},AbstractArray{N,1}}} where N&lt;:AbstractFloat" href="#LazySets.translate-Union{Tuple{N}, Tuple{Ellipsoid{N},AbstractArray{N,1}}} where N&lt;:AbstractFloat"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(E::Ellipsoid{N}, v::AbstractVector{N}; share::Bool=false
         ) where {N&lt;:AbstractFloat}</code></pre><p>Translate (i.e., shift) an ellipsoid by a given vector.</p><p><strong>Input</strong></p><ul><li><code>E</code>     – ellipsoid</li><li><code>v</code>     – translation vector</li><li><code>share</code> – (optional, default: <code>false</code>) flag for sharing unmodified parts of            the original set representation</li></ul><p><strong>Output</strong></p><p>A translated ellipsoid.</p><p><strong>Notes</strong></p><p>The shape matrix is shared with the original ellipsoid if <code>share == true</code>.</p><p><strong>Algorithm</strong></p><p>We add the vector to the center of the ellipsoid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Ellipsoid.jl#L258-L282">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractCentrallySymmetric"><code>AbstractCentrallySymmetric</code></a>:</p><ul><li><a href="../interfaces/#LazySets.dim-Tuple{AbstractCentrallySymmetric}"><code>dim</code></a></li><li><a href="../interfaces/#LazySets.isbounded-Tuple{AbstractCentrallySymmetric}"><code>isbounded</code></a></li><li><a href="../interfaces/#Base.isempty-Tuple{AbstractCentrallySymmetric}"><code>isempty</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetric{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h2><a class="nav-anchor" id="Empty-set-1" href="#Empty-set-1">Empty set</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.EmptySet" href="#LazySets.EmptySet"><code>LazySets.EmptySet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">EmptySet{N&lt;:Real} &lt;: LazySet{N}</code></pre><p>Type that represents the empty set, i.e., the set with no elements.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/EmptySet.jl#L9-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.∅" href="#LazySets.∅"><code>LazySets.∅</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">∅</code></pre><p>An <code>EmptySet</code> instance of type <code>Float64</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/EmptySet.jl#L19-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{EmptySet}" href="#LazySets.dim-Tuple{EmptySet}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(∅::EmptySet)</code></pre><p>Return the dimension of the empty set, which is -1 by convention.</p><p><strong>Input</strong></p><ul><li><code>∅</code> – an empty set</li></ul><p><strong>Output</strong></p><p><code>-1</code> by convention.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/EmptySet.jl#L30-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},EmptySet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},EmptySet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, ∅::EmptySet{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of an empty set.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>∅</code> – an empty set</li></ul><p><strong>Output</strong></p><p>An error.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/EmptySet.jl#L47-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},EmptySet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},EmptySet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, ∅::EmptySet{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in an empty set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>∅</code> – empty set</li></ul><p><strong>Output</strong></p><p>The output is always <code>false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ∈([1.0, 0.0], ∅)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/EmptySet.jl#L82-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Tuple{EmptySet}" href="#LazySets.an_element-Tuple{EmptySet}"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(∅::EmptySet)</code></pre><p>Return some element of an empty set.</p><p><strong>Input</strong></p><ul><li><code>∅</code> – empty set</li></ul><p><strong>Output</strong></p><p>An error.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/EmptySet.jl#L107-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{EmptySet}}" href="#Base.rand-Tuple{Type{EmptySet}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{EmptySet}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=0,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::EmptySet{N}</code></pre><p>Create an empty set (note that there is nothing to randomize).</p><p><strong>Input</strong></p><ul><li><code>EmptySet</code> – type for dispatch</li><li><code>N</code>        – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>      – (optional, default: 0) dimension (is ignored)</li><li><code>rng</code>      – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>     – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>The (only) empty set of the given numeric type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/EmptySet.jl#L124-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{EmptySet}" href="#LazySets.isbounded-Tuple{EmptySet}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(∅::EmptySet)::Bool</code></pre><p>Determine whether an empty set is bounded.</p><p><strong>Input</strong></p><ul><li><code>∅</code> – empty set</li></ul><p><strong>Output</strong></p><p><code>true</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/EmptySet.jl#L65-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{EmptySet}" href="#Base.isempty-Tuple{EmptySet}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(∅::EmptySet)::Bool</code></pre><p>Return if the empty set is empty or not.</p><p><strong>Input</strong></p><ul><li><code>∅</code> – empty set</li></ul><p><strong>Output</strong></p><p><code>true</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/EmptySet.jl#L153-L165">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">norm(S::EmptySet, [p]::Real=Inf)</code></pre><p>Return the norm of an empty set. It is the norm of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><code>S</code> – empty set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>An error.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/EmptySet.jl#L170-L185">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius" href="#LazySets.radius"><code>LazySets.radius</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">radius(S::EmptySet, [p]::Real=Inf)</code></pre><p>Return the radius of an empty set. It is the radius of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><code>S</code> – empty set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>An error.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/EmptySet.jl#L190-L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.diameter" href="#LazySets.diameter"><code>LazySets.diameter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">diameter(S::EmptySet, [p]::Real=Inf)</code></pre><p>Return the diameter of an empty set. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><code>S</code> – empty set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>An error.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/EmptySet.jl#L210-L226">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},EmptySet{N}}} where N" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},EmptySet{N}}} where N"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, ∅::EmptySet{N}) where {N}</code></pre><p>Return the linear map of an empty set.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>∅</code> – empty set</li></ul><p><strong>Output</strong></p><p>The empty set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/EmptySet.jl#L231-L244">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{EmptySet{N},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{N}, Tuple{EmptySet{N},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(∅::EmptySet{N}, v::AbstractVector{N}) where {N&lt;:Real}</code></pre><p>Translate (i.e., shift) an empty set by a given vector.</p><p><strong>Input</strong></p><ul><li><code>∅</code> – empty set</li><li><code>v</code> – translation vector</li></ul><p><strong>Output</strong></p><p>The empty set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/EmptySet.jl#L247-L260">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.plot_recipe-Union{Tuple{EmptySet{N}}, Tuple{N}, Tuple{EmptySet{N},N}} where N&lt;:Real" href="#LazySets.plot_recipe-Union{Tuple{EmptySet{N}}, Tuple{N}, Tuple{EmptySet{N},N}} where N&lt;:Real"><code>LazySets.plot_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_recipe(∅::EmptySet{N}, [ε]::N=zero(N)) where {N&lt;:Real}</code></pre><p>Convert an empty set to a sequence of points for plotting. In the special case of an empty set, we define the sequence as <code>nothing</code>.</p><p><strong>Input</strong></p><ul><li><code>∅</code> – empty set</li><li><code>ε</code> – (optional, default: <code>0</code>) ignored, used for dispatch</li></ul><p><strong>Output</strong></p><p><code>nothing</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/EmptySet.jl#L265-L279">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{Dict{Symbol,Any},EmptySet{N}}, Tuple{Dict{Symbol,Any},EmptySet{N},N}} where N&lt;:Real" href="#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{Dict{Symbol,Any},EmptySet{N}}, Tuple{Dict{Symbol,Any},EmptySet{N},N}} where N&lt;:Real"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_emptyset(∅::EmptySet, [ε]::N=zero(N); ...)</code></pre><p>Plot an empty set.</p><p><strong>Input</strong></p><ul><li><code>∅</code> – empty set</li><li><code>ε</code> – (optional, default: <code>0</code>) ignored, used for dispatch</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/plot_recipes.jl#L267-L276">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><h2><a class="nav-anchor" id="Half-Space-1" href="#Half-Space-1">Half-Space</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.HalfSpace" href="#LazySets.HalfSpace"><code>LazySets.HalfSpace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">HalfSpace{N&lt;:Real, VN&lt;:AbstractVector{N}} &lt;: AbstractPolyhedron{N}</code></pre><p>Type that represents a (closed) half-space of the form <span>$a⋅x ≤ b$</span>.</p><p><strong>Fields</strong></p><ul><li><code>a</code> – normal direction</li><li><code>b</code> – constraint</li></ul><p><strong>Examples</strong></p><p>The set <span>$y ≥ 0$</span> in the plane:</p><pre><code class="language-julia-repl">julia&gt; HalfSpace([0, -1.], 0.)
HalfSpace{Float64,Array{Float64,1}}([0.0, -1.0], 0.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HalfSpace.jl#L11-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.LinearConstraint" href="#LazySets.LinearConstraint"><code>LazySets.LinearConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">LinearConstraint</code></pre><p>Alias for <code>HalfSpace</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HalfSpace.jl#L35-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{HalfSpace}" href="#LazySets.dim-Tuple{HalfSpace}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(hs::HalfSpace)::Int</code></pre><p>Return the dimension of a half-space.</p><p><strong>Input</strong></p><ul><li><code>hs</code> – half-space</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the half-space.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HalfSpace.jl#L45-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, hs::HalfSpace{N})::N where {N&lt;:Real}</code></pre><p>Evaluate the support function of a half-space in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>hs</code> – half-space</li></ul><p><strong>Output</strong></p><p>The support function of the half-space. If the set is unbounded in the given direction, the result is <code>Inf</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HalfSpace.jl#L62-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, hs::HalfSpace{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a half-space.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>hs</code> – half-space</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction, which is only defined in the following two cases:</p><ol><li>The direction has norm zero.</li><li>The direction is the half-space&#39;s normal direction.</li></ol><p>In both cases the result is any point on the boundary (the defining hyperplane). Otherwise this function throws an error.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HalfSpace.jl#L86-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, hs::HalfSpace{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a half-space.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>hs</code> – half-space</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ hs$</span>.</p><p><strong>Algorithm</strong></p><p>We just check if <span>$x$</span> satisfies <span>$a⋅x ≤ b$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HalfSpace.jl#L145-L162">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(hs::HalfSpace{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a half-space.</p><p><strong>Input</strong></p><ul><li><code>hs</code> – half-space</li></ul><p><strong>Output</strong></p><p>An element on the defining hyperplane.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HalfSpace.jl#L128-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{HalfSpace}}" href="#Base.rand-Tuple{Type{HalfSpace}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{HalfSpace}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::HalfSpace{N}</code></pre><p>Create a random half-space.</p><p><strong>Input</strong></p><ul><li><code>HalfSpace</code> – type for dispatch</li><li><code>N</code>         – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>       – (optional, default: 2) dimension</li><li><code>rng</code>       – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>      – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A random half-space.</p><p><strong>Algorithm</strong></p><p>All numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the constraint <code>a</code> is nonzero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HalfSpace.jl#L167-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{HalfSpace}" href="#LazySets.isbounded-Tuple{HalfSpace}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(hs::HalfSpace)::Bool</code></pre><p>Determine whether a half-space is bounded.</p><p><strong>Input</strong></p><ul><li><code>hs</code> – half-space</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HalfSpace.jl#L111-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{HalfSpace}" href="#Base.isempty-Tuple{HalfSpace}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(hs::HalfSpace)::Bool</code></pre><p>Return if a half-space is empty or not.</p><p><strong>Input</strong></p><ul><li><code>hs</code> – half-space</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HalfSpace.jl#L206-L218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(hs::HalfSpace{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of a half-space.</p><p><strong>Input</strong></p><ul><li><code>hs</code> – half-space</li></ul><p><strong>Output</strong></p><p>A singleton list containing the half-space.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HalfSpace.jl#L223-L235">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(A::AbstractMatrix{N}, b::AbstractVector{N}) where {N&lt;:Real}</code></pre><p>Convert a matrix-vector representation to a linear-constraint representation.</p><p><strong>Input</strong></p><ul><li><code>A</code> – matrix</li><li><code>b</code> – vector</li></ul><p><strong>Output</strong></p><p>A list of linear constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HalfSpace.jl#L240-L253">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constrained_dimensions-Union{Tuple{HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constrained_dimensions-Union{Tuple{HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constrained_dimensions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constrained_dimensions(hs::HalfSpace{N})::Vector{Int} where {N&lt;:Real}</code></pre><p>Return the indices in which a half-space is constrained.</p><p><strong>Input</strong></p><ul><li><code>hs</code> – half-space</li></ul><p><strong>Output</strong></p><p>A vector of ascending indices <code>i</code> such that the half-space is constrained in dimension <code>i</code>.</p><p><strong>Examples</strong></p><p>A 2D half-space with constraint <span>$x1 ≥ 0$</span> is constrained in dimension 1 only.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HalfSpace.jl#L263-L280">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{N}, Tuple{HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(hs::HalfSpace{N}, v::AbstractVector{N}; share::Bool=false
         ) where {N&lt;:Real}</code></pre><p>Translate (i.e., shift) a half-space by a given vector.</p><p><strong>Input</strong></p><ul><li><code>hs</code>    – half-space</li><li><code>v</code>     – translation vector</li><li><code>share</code> – (optional, default: <code>false</code>) flag for sharing unmodified parts of            the original set representation</li></ul><p><strong>Output</strong></p><p>A translated half-space.</p><p><strong>Notes</strong></p><p>The normal vectors of the halfspace (vector <code>a</code> in <code>a⋅x ≤ b</code>) is shared with the original halfspace if <code>share == true</code>.</p><p><strong>Algorithm</strong></p><p>A half-space <span>$a⋅x ≤ b$</span> is transformed to the half-space <span>$a⋅x ≤ b + a⋅v$</span>. In other words, we add the dot product <span>$a⋅v$</span> to <span>$b$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HalfSpace.jl#L414-L440">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.halfspace_left-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.halfspace_left-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.halfspace_left</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">halfspace_left(p::AbstractVector{N},
               q::AbstractVector{N})::HalfSpace{N} where {N&lt;:Real}</code></pre><p>Return a half-space describing the &#39;left&#39; of a two-dimensional line segment through two points.</p><p><strong>Input</strong></p><ul><li><code>p</code> – first point</li><li><code>q</code> – second point</li></ul><p><strong>Output</strong></p><p>The half-space whose boundary goes through the two points <code>p</code> and <code>q</code> and which describes the left-hand side of the directed line segment <code>pq</code>.</p><p><strong>Algorithm</strong></p><p>The implementation is simple: the half-space <span>$a⋅x ≤ b$</span> is calculated as <code>a = [dy, -dx]</code>, where <span>$d = (dx, dy)$</span> denotes the line segment <code>pq</code>, that is, <span>$\vec{d} = \vec{p} - \vec{q}$</span>, and <code>b = dot(p, a)</code>.</p><p><strong>Examples</strong></p><p>The left half-space of the &quot;east&quot; and &quot;west&quot; directions in two-dimensions are the upper and lower half-spaces:</p><pre><code class="language-julia-repl">julia&gt; using LazySets: halfspace_left

julia&gt; halfspace_left([0.0, 0.0], [1.0, 0.0])
HalfSpace{Float64,Array{Float64,1}}([0.0, -1.0], 0.0)

julia&gt; halfspace_left([0.0, 0.0], [-1.0, 0.0])
HalfSpace{Float64,Array{Float64,1}}([0.0, 1.0], 0.0)</code></pre><p>We create a box from the sequence of line segments that describe its edges:</p><pre><code class="language-julia-repl">julia&gt; H1 = halfspace_left([-1.0, -1.0], [1.0, -1.0]);

julia&gt; H2 = halfspace_left([1.0, -1.0], [1.0, 1.0]);

julia&gt; H3 = halfspace_left([1.0, 1.0], [-1.0, 1.0]);

julia&gt; H4 = halfspace_left([-1.0, 1.0], [-1.0, -1.0]);

julia&gt; H = HPolygon([H1, H2, H3, H4]);

julia&gt; B = BallInf([0.0, 0.0], 1.0);

julia&gt; B ⊆ H &amp;&amp; H ⊆ B
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HalfSpace.jl#L285-L341">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.halfspace_right-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.halfspace_right-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.halfspace_right</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">halfspace_right(p::AbstractVector{N},
                q::AbstractVector{N})::HalfSpace{N} where {N&lt;:Real}</code></pre><p>Return a half-space describing the &#39;right&#39; of a two-dimensional line segment through two points.</p><p><strong>Input</strong></p><ul><li><code>p</code> – first point</li><li><code>q</code> – second point</li></ul><p><strong>Output</strong></p><p>The half-space whose boundary goes through the two points <code>p</code> and <code>q</code> and which describes the right-hand side of the directed line segment <code>pq</code>.</p><p><strong>Algorithm</strong></p><p>See the documentation of <code>halfspace_left</code>. </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HalfSpace.jl#L350-L370">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tosimplehrep-Union{Tuple{AbstractArray{LC,1}}, Tuple{LC}, Tuple{N}} where LC&lt;:(HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}) where N&lt;:Real" href="#LazySets.tosimplehrep-Union{Tuple{AbstractArray{LC,1}}, Tuple{LC}, Tuple{N}} where LC&lt;:(HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}) where N&lt;:Real"><code>LazySets.tosimplehrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tosimplehrep(constraints::AbstractVector{LC})
    where {N&lt;:Real, LC&lt;:LinearConstraint{N}}</code></pre><p>Return the simple H-representation <span>$Ax ≤ b$</span> from a list of linear constraints.</p><p><strong>Input</strong></p><ul><li><code>constraints</code> – a list of linear constraints</li></ul><p><strong>Output</strong></p><p>The tuple <code>(A, b)</code> where <code>A</code> is the matrix of normal directions and <code>b</code> is the vector of offsets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/AbstractPolyhedron_functions.jl#L67-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.remove_redundant_constraints-Union{Tuple{AbstractArray{LC,1}}, Tuple{LC}, Tuple{N}} where LC&lt;:(HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}) where N&lt;:Real" href="#LazySets.remove_redundant_constraints-Union{Tuple{AbstractArray{LC,1}}, Tuple{LC}, Tuple{N}} where LC&lt;:(HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}) where N&lt;:Real"><code>LazySets.remove_redundant_constraints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">remove_redundant_constraints(constraints::AbstractVector{LC};
    backend=GLPKSolverLP()) where {N&lt;:Real, LC&lt;:LinearConstraint{N}}</code></pre><p>Remove the redundant constraints of a given list of linear constraints.</p><p><strong>Input</strong></p><ul><li><code>constraints</code> – list of constraints</li><li><code>backend</code>     – (optional, default: <code>GLPKSolverLP</code>) numeric LP solver backend</li></ul><p><strong>Output</strong></p><p>The list of constraints with the redundant ones removed, or an empty set if the constraints are infeasible.</p><p><strong>Algorithm</strong></p><p>See <a href="#LazySets.remove_redundant_constraints!-Union{Tuple{AbstractArray{LC,1}}, Tuple{LC}, Tuple{N}} where LC&lt;:(HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}) where N&lt;:Real"><code>remove_redundant_constraints!(::AbstractVector{&lt;:LinearConstraint{&lt;:Real}})</code></a> for details.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/AbstractPolyhedron_functions.jl#L180-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.remove_redundant_constraints!-Union{Tuple{AbstractArray{LC,1}}, Tuple{LC}, Tuple{N}} where LC&lt;:(HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}) where N&lt;:Real" href="#LazySets.remove_redundant_constraints!-Union{Tuple{AbstractArray{LC,1}}, Tuple{LC}, Tuple{N}} where LC&lt;:(HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}) where N&lt;:Real"><code>LazySets.remove_redundant_constraints!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia"> remove_redundant_constraints!(constraints::AbstractVector{LC};
     [backend]=GLPKSolverLP())::Bool where {N&lt;:Real,
                                            LC&lt;:LinearConstraint{N}}</code></pre><p>Remove the redundant constraints of a given list of linear constraints; the list is updated in-place.</p><p><strong>Input</strong></p><ul><li><code>constraints</code> – list of constraints</li><li><code>backend</code>     – (optional, default: <code>GLPKSolverLP</code>) numeric LP solver backend</li></ul><p><strong>Output</strong></p><p><code>true</code> if the function was successful and the list of constraints <code>constraints</code> is modified by removing the redundant constraints, and <code>false</code> only if the constraints are infeasible.</p><p><strong>Notes</strong></p><p>Note that the result may be <code>true</code> even if the constraints are infeasible. For example, <span>$x ≤ 0 &amp;&amp; x ≥ 1$</span> will return <code>true</code> without removing any constraint. To check if the constraints are infeasible, use <code>isempty(HPolyhedron(constraints)</code>.</p><p><strong>Algorithm</strong></p><p>If there are <code>m</code> constraints in <code>n</code> dimensions, this function checks one by one if each of the <code>m</code> constraints is implied by the remaining ones.</p><p>To check if the <code>k</code>-th constraint is redundant, an LP is formulated using the constraints that have not yet being removed. If, at an intermediate step, it is detected that a subgroup of the constraints is infeasible, this function returns <code>false</code>. If the calculation finished successfully, this function returns <code>true</code>.</p><p>For details, see <a href="https://www.cs.mcgill.ca/~fukuda/soft/polyfaq/node24.html">Fukuda&#39;s Polyhedra FAQ</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/AbstractPolyhedron_functions.jl#L101-L141">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><h2><a class="nav-anchor" id="Hyperplane-1" href="#Hyperplane-1">Hyperplane</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Hyperplane" href="#LazySets.Hyperplane"><code>LazySets.Hyperplane</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Hyperplane{N&lt;:Real} &lt;: AbstractPolyhedron{N}</code></pre><p>Type that represents a hyperplane of the form <span>$a⋅x = b$</span>.</p><p><strong>Fields</strong></p><ul><li><code>a</code> – normal direction</li><li><code>b</code> – constraint</li></ul><p><strong>Examples</strong></p><p>The plane <span>$y = 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; Hyperplane([0, 1.], 0.)
Hyperplane{Float64}([0.0, 1.0], 0.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Hyperplane.jl#L8-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{Hyperplane}" href="#LazySets.dim-Tuple{Hyperplane}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(hp::Hyperplane)::Int</code></pre><p>Return the dimension of a hyperplane.</p><p><strong>Input</strong></p><ul><li><code>hp</code> – hyperplane</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the hyperplane.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Hyperplane.jl#L57-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Hyperplane{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Hyperplane{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, hp::Hyperplane{N})::N where {N&lt;:Real}</code></pre><p>Evaluate the support function of a hyperplane in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>hp</code> – hyperplane</li></ul><p><strong>Output</strong></p><p>The support function of the hyperplane. If the set is unbounded in the given direction, the result is <code>Inf</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Hyperplane.jl#L74-L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Hyperplane{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Hyperplane{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, hp::Hyperplane{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a hyperplane.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>hp</code> – hyperplane</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction, which is only defined in the following two cases:</p><ol><li>The direction has norm zero.</li><li>The direction is the hyperplane&#39;s normal direction or its opposite direction.</li></ol><p>In all cases, the result is any point on the hyperplane. Otherwise this function throws an error.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Hyperplane.jl#L97-L115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Hyperplane{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Hyperplane{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, hp::Hyperplane{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a hyperplane.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>hp</code> – hyperplane</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ hp$</span>.</p><p><strong>Algorithm</strong></p><p>We just check if <span>$x$</span> satisfies <span>$a⋅x = b$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Hyperplane.jl#L155-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{Hyperplane{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{Hyperplane{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(hp::Hyperplane{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a hyperplane.</p><p><strong>Input</strong></p><ul><li><code>hp</code> – hyperplane</li></ul><p><strong>Output</strong></p><p>An element on the hyperplane.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Hyperplane.jl#L138-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{Hyperplane}}" href="#Base.rand-Tuple{Type{Hyperplane}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{Hyperplane}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::Hyperplane{N}</code></pre><p>Create a random hyperplane.</p><p><strong>Input</strong></p><ul><li><code>Hyperplane</code> – type for dispatch</li><li><code>N</code>          – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>        – (optional, default: 2) dimension</li><li><code>rng</code>        – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>       – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A random hyperplane.</p><p><strong>Algorithm</strong></p><p>All numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the constraint <code>a</code> is nonzero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Hyperplane.jl#L177-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{Hyperplane}" href="#LazySets.isbounded-Tuple{Hyperplane}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(hp::Hyperplane)::Bool</code></pre><p>Determine whether a hyperplane is bounded.</p><p><strong>Input</strong></p><ul><li><code>hp</code> – hyperplane</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Hyperplane.jl#L121-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{Hyperplane}" href="#Base.isempty-Tuple{Hyperplane}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(hp::Hyperplane)::Bool</code></pre><p>Return if a hyperplane is empty or not.</p><p><strong>Input</strong></p><ul><li><code>hp</code> – hyperplane</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Hyperplane.jl#L216-L228">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constrained_dimensions-Union{Tuple{Hyperplane{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constrained_dimensions-Union{Tuple{Hyperplane{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constrained_dimensions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constrained_dimensions(hp::Hyperplane{N})::Vector{Int} where {N&lt;:Real}</code></pre><p>Return the indices in which a hyperplane is constrained.</p><p><strong>Input</strong></p><ul><li><code>hp</code> – hyperplane</li></ul><p><strong>Output</strong></p><p>A vector of ascending indices <code>i</code> such that the hyperplane is constrained in dimension <code>i</code>.</p><p><strong>Examples</strong></p><p>A 2D hyperplane with constraint <span>$x1 = 0$</span> is constrained in dimension 1 only.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Hyperplane.jl#L233-L250">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{Hyperplane{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{Hyperplane{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(hp::Hyperplane{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of a hyperplane.</p><p><strong>Input</strong></p><ul><li><code>hp</code> – hyperplane</li></ul><p><strong>Output</strong></p><p>A list containing two half-spaces.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Hyperplane.jl#L36-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{Hyperplane{N},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{N}, Tuple{Hyperplane{N},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(hp::Hyperplane{N}, v::AbstractVector{N}; share::Bool=false
         ) where {N&lt;:Real}</code></pre><p>Translate (i.e., shift) a hyperplane by a given vector.</p><p><strong>Input</strong></p><ul><li><code>hp</code>    – hyperplane</li><li><code>v</code>     – translation vector</li><li><code>share</code> – (optional, default: <code>false</code>) flag for sharing unmodified parts of            the original set representation</li></ul><p><strong>Output</strong></p><p>A translated hyperplane.</p><p><strong>Notes</strong></p><p>The normal vectors of the hyperplane (vector <code>a</code> in <code>a⋅x = b</code>) is shared with the original hyperplane if <code>share == true</code>.</p><p><strong>Algorithm</strong></p><p>A hyperplane <span>$a⋅x = b$</span> is transformed to the hyperplane <span>$a⋅x = b + a⋅v$</span>. In other words, we add the dot product <span>$a⋅v$</span> to <span>$b$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Hyperplane.jl#L403-L429">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><h2><a class="nav-anchor" id="Hyperrectangle-1" href="#Hyperrectangle-1">Hyperrectangle</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Hyperrectangle" href="#LazySets.Hyperrectangle"><code>LazySets.Hyperrectangle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Hyperrectangle{N&lt;:Real} &lt;: AbstractHyperrectangle{N}</code></pre><p>Type that represents a hyperrectangle.</p><p>A <a href="https://en.wikipedia.org/wiki/Hyperrectangle">hyperrectangle</a> is the Cartesian product of one-dimensional intervals.</p><p><strong>Fields</strong></p><ul><li><code>center</code> – center of the hyperrectangle as a real vector</li><li><code>radius</code> – radius of the ball as a real vector, i.e., half of its width along             each coordinate direction</li></ul><p><strong>Examples</strong></p><p>There is also a constructor from lower and upper bounds with keyword arguments <code>high</code> and <code>low</code>. The following two constructions are equivalent:</p><pre><code class="language-julia-repl">julia&gt; c = ones(2);

julia&gt; r = [0.1, 0.2];

julia&gt; l = [0.9, 0.8];

julia&gt; h = [1.1, 1.2];

julia&gt; Hyperrectangle(c, r)
Hyperrectangle{Float64}([1.0, 1.0], [0.1, 0.2])
julia&gt; Hyperrectangle(low=l, high=h)
Hyperrectangle{Float64}([1.0, 1.0], [0.1, 0.2])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Hyperrectangle.jl#L5-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{Hyperrectangle}}" href="#Base.rand-Tuple{Type{Hyperrectangle}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{Hyperrectangle}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::Hyperrectangle{N}</code></pre><p>Create a random hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>Hyperrectangle</code> – type for dispatch</li><li><code>N</code>              – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>            – (optional, default: 2) dimension</li><li><code>rng</code>            – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>           – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A random hyperrectangle.</p><p><strong>Algorithm</strong></p><p>All numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the radius is nonnegative.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Hyperrectangle.jl#L132-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Union{Tuple{Hyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.center-Union{Tuple{Hyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">center(H::Hyperrectangle{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangle</li></ul><p><strong>Output</strong></p><p>The center of the hyperrectangle.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Hyperrectangle.jl#L111-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{Hyperrectangle{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{Hyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">radius_hyperrectangle(H::Hyperrectangle{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the box radius of a hyperrectangle in every dimension.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangle</li></ul><p><strong>Output</strong></p><p>The box radius of the hyperrectangle.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Hyperrectangle.jl#L90-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{Hyperrectangle{N},Int64}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{Hyperrectangle{N},Int64}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">radius_hyperrectangle(H::Hyperrectangle{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the box radius of a hyperrectangle in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangle</li><li><code>i</code> – dimension of interest</li></ul><p><strong>Output</strong></p><p>The radius in the given dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Hyperrectangle.jl#L72-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{Hyperrectangle{N},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{N}, Tuple{Hyperrectangle{N},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(H::Hyperrectangle{N}, v::AbstractVector{N}; share::Bool=false
         ) where {N&lt;:Real}</code></pre><p>Translate (i.e., shift) a hyperrectangle by a given vector.</p><p><strong>Input</strong></p><ul><li><code>H</code>     – hyperrectangle</li><li><code>v</code>     – translation vector</li><li><code>share</code> – (optional, default: <code>false</code>) flag for sharing unmodified parts of            the original set representation</li></ul><p><strong>Output</strong></p><p>A translated hyperrectangle.</p><p><strong>Notes</strong></p><p>The radius vector is shared with the original hyperrectangle if <code>share == true</code>.</p><p><strong>Algorithm</strong></p><p>We add the vector to the center of the hyperrectangle.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Hyperrectangle.jl#L168-L192">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.isbounded-Tuple{AbstractPolytope}"><code>isbounded</code></a></li><li><a href="../interfaces/#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>singleton_list</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractCentrallySymmetricPolytope"><code>AbstractCentrallySymmetricPolytope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}"><code>dim</code></a></li><li><a href="../interfaces/#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}"><code>isempty</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractHyperrectangle"><code>AbstractHyperrectangle</code></a>:</p><ul><li><a href="../interfaces/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>σ</code></a></li><li><a href="../interfaces/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHyperrectangle{N}}} where N&lt;:Real"><code>∈</code></a></li><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li><li><a href="../interfaces/#LazySets.vertices_list-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>vertices_list</code></a></li><li><a href="../interfaces/#LazySets.high-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>high</code></a></li><li><a href="../interfaces/#LazySets.low-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>low</code></a></li></ul><h2><a class="nav-anchor" id="Interval-1" href="#Interval-1">Interval</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Interval" href="#LazySets.Interval"><code>LazySets.Interval</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Interval{N&lt;:Real, IN&lt;:AbstractInterval{N}} &lt;: AbstractHyperrectangle{N}</code></pre><p>Type representing an interval on the real line. Mathematically, it is of the form</p><div>\[[a, b] := \{ a ≤ x ≤ b \} ⊆ \mathbb{R}.\]</div><p><strong>Fields</strong></p><ul><li><code>dat</code> – data container for the given interval</li></ul><p><strong>Notes</strong></p><p>This type relies on the <a href="https://juliaintervals.github.io/IntervalArithmetic.jl/stable/">IntervalArithmetic.jl</a> library for representation of intervals and arithmetic operations.</p><p><strong>Examples</strong></p><p>Unidimensional intervals are symbolic representations of a real closed interval.</p><p>We can create intervals in different ways, the simpler way is to pass a pair of numbers:</p><pre><code class="language-julia-repl">julia&gt; x = Interval(0.0, 1.0)
Interval{Float64,IntervalArithmetic.Interval{Float64}}([0, 1])</code></pre><p>or a 2-vector:</p><pre><code class="language-julia-repl">julia&gt; x = Interval([0.0, 1.0])
Interval{Float64,IntervalArithmetic.Interval{Float64}}([0, 1])</code></pre><p>Note that if the package <code>IntervalArithmetic</code> is loaded in the current scope, you have to prepend <code>LazySets.</code> to the <code>Interval</code> type since there is a name conflict otherwise.</p><pre><code class="language-julia-repl">julia&gt; using IntervalArithmetic
WARNING: using IntervalArithmetic.Interval in module Main conflicts with an existing identifier.

julia&gt; x = Interval(IntervalArithmetic.Interval(0.0, 1.0))
Interval{Float64,IntervalArithmetic.Interval{Float64}}([0, 1])

julia&gt; dim(x)
1

julia&gt; center(x)
1-element Array{Float64,1}:
 0.5</code></pre><p>This type is such that the usual pairwise arithmetic operators <code>+</code>, <code>-</code>, <code>*</code> trigger the corresponding interval arithmetic backend method, and return a new <code>Interval</code> object. For the symbolic Minkowksi sum, use <code>MinkowskiSum</code> or <code>⊕</code>.</p><p>Interval of other numeric types can be created as well, eg. a rational interval:</p><pre><code class="language-julia-repl">julia&gt; Interval(0//1, 2//1)
Interval{Rational{Int64},AbstractInterval{Rational{Int64}}}([0//1, 2//1])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L10-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{Interval}" href="#LazySets.dim-Tuple{Interval}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(x::Interval)::Int</code></pre><p>Return the ambient dimension of an interval.</p><p><strong>Input</strong></p><ul><li><code>x</code> – interval</li></ul><p><strong>Output</strong></p><p>The integer 1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L108-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Interval{N,IN} where IN&lt;:AbstractInterval{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Interval{N,IN} where IN&lt;:AbstractInterval{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, x::Interval{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of an ellipsoid in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>x</code> – interval</li></ul><p><strong>Output</strong></p><p>Support vector in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L123-L136">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Interval{N,IN} where IN&lt;:AbstractInterval{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Interval{N,IN} where IN&lt;:AbstractInterval{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(v::AbstractVector{N}, x::Interval{N}) where {N&lt;:Real})</code></pre><p>Return whether a vector is contained in the interval.</p><p><strong>Input</strong></p><ul><li><code>v</code> – one-dimensional vector</li><li><code>x</code> – interval</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>x</code> contains <code>v</code>&#39;s first component.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L215-L228">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{N,Interval{N,IN} where IN&lt;:AbstractInterval{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{N,Interval{N,IN} where IN&lt;:AbstractInterval{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(v::N, x::Interval{N}) where {N&lt;:Real}</code></pre><p>Return whether a number is contained in the interval.</p><p><strong>Input</strong></p><ul><li><code>v</code> – scalar</li><li><code>x</code> – interval</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>x</code> contains <code>v</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L233-L246">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(x::Interval{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of an interval.</p><p><strong>Input</strong></p><ul><li><code>x</code> – interval</li></ul><p><strong>Output</strong></p><p>The left border (<code>min(x)</code>) of the interval.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L319-L331">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(x::Interval{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of this interval.</p><p><strong>Input</strong></p><ul><li><code>x</code> – interval</li></ul><p><strong>Output</strong></p><p>The list of vertices of the interval represented as two one-dimensional vectors.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L372-L384">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{N}, Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(x::Interval{N}, v::AbstractVector{N}) where {N&lt;:Real}</code></pre><p>Translate (i.e., shift) an interval by a given vector.</p><p><strong>Input</strong></p><ul><li><code>x</code> – interval</li><li><code>v</code> – translation vector</li></ul><p><strong>Output</strong></p><p>A translated interval.</p><p><strong>Algorithm</strong></p><p>We add the vector to the left and right of the interval.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L389-L406">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Union{Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.center-Union{Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">center(x::Interval{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the interval&#39;s center.</p><p><strong>Input</strong></p><ul><li><code>x</code> – interval</li></ul><p><strong>Output</strong></p><p>The center, or midpoint, of <span>$x$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L142-L154">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.min-Union{Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N}}, Tuple{N}} where N&lt;:Real" href="#Base.min-Union{Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N}}, Tuple{N}} where N&lt;:Real"><code>Base.min</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">min(x::Interval{N})::N where {N&lt;:Real}</code></pre><p>Return the lower component of an interval.</p><p><strong>Input</strong></p><ul><li><code>x</code> – interval</li></ul><p><strong>Output</strong></p><p>The lower (<code>lo</code>) component of the interval.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L251-L263">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.max-Union{Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N}}, Tuple{N}} where N&lt;:Real" href="#Base.max-Union{Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N}}, Tuple{N}} where N&lt;:Real"><code>Base.max</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">max(x::Interval{N})::N where {N&lt;:Real}</code></pre><p>Return the higher or upper component of an interval.</p><p><strong>Input</strong></p><ul><li><code>x</code> – interval</li></ul><p><strong>Output</strong></p><p>The higher (<code>hi</code>) component of the interval.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L268-L280">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Union{Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.low-Union{Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">low(x::Interval{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the lower coordinate of an interval set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – interval</li></ul><p><strong>Output</strong></p><p>A vector with the lower coordinate of the interval.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L285-L297">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Union{Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.high-Union{Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">high(x::Interval{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the higher coordinate of an interval set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – interval</li></ul><p><strong>Output</strong></p><p>A vector with the higher coordinate of the interval.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L302-L314">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">radius_hyperrectangle(x::Interval{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the box radius of an interval in every dimension.</p><p><strong>Input</strong></p><ul><li><code>x</code> – interval</li></ul><p><strong>Output</strong></p><p>The box radius of the interval (a one-dimensional vector).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L436-L448">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N},Int64}} where N&lt;:Real" href="#LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N},Int64}} where N&lt;:Real"><code>LazySets.radius_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">radius_hyperrectangle(x::Interval{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the box radius of an interval in a given dimension.</p><p><strong>Input</strong></p><ul><li><code>x</code> – interval</li><li><code>i</code> – dimension index (must be <code>1</code>)</li></ul><p><strong>Output</strong></p><p>The box radius in the given dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L417-L430">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Union{Tuple{N}, Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N},Interval{N,IN} where IN&lt;:AbstractInterval{N}}} where N&lt;:Real" href="#Base.:+-Union{Tuple{N}, Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N},Interval{N,IN} where IN&lt;:AbstractInterval{N}}} where N&lt;:Real"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">+(x::Interval{N}, y::Interval{N}) where {N&lt;:Real}</code></pre><p>Return the sum of the intervals.</p><p><strong>Input</strong></p><ul><li><code>x</code> – interval</li><li><code>y</code> – interval</li></ul><p><strong>Output</strong></p><p>The sum of the intervals as a new <code>Interval</code> set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L159-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Union{Tuple{N}, Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N},Interval{N,IN} where IN&lt;:AbstractInterval{N}}} where N&lt;:Real" href="#Base.:--Union{Tuple{N}, Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N},Interval{N,IN} where IN&lt;:AbstractInterval{N}}} where N&lt;:Real"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">-(x::Interval{N}, y::Interval{N}) where {N&lt;:Real}</code></pre><p>Return the difference of the intervals.</p><p><strong>Input</strong></p><ul><li><code>x</code> – interval</li><li><code>y</code> – interval</li></ul><p><strong>Output</strong></p><p>The difference of the intervals as a new <code>Interval</code> set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L177-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Union{Tuple{N}, Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N},Interval{N,IN} where IN&lt;:AbstractInterval{N}}} where N&lt;:Real" href="#Base.:*-Union{Tuple{N}, Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N},Interval{N,IN} where IN&lt;:AbstractInterval{N}}} where N&lt;:Real"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">    *(x::Interval{N}, y::Interval{N}) where {N&lt;:Real}</code></pre><p>Return the product of the intervals.</p><p><strong>Input</strong></p><ul><li><code>x</code> – interval</li><li><code>y</code> – interval</li></ul><p><strong>Output</strong></p><p>The product of the intervals as a new <code>Interval</code> set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L195-L210">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{Interval}}" href="#Base.rand-Tuple{Type{Interval}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{Interval}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::Interval{N}</code></pre><p>Create a random interval.</p><p><strong>Input</strong></p><ul><li><code>Interval</code> – type for dispatch</li><li><code>N</code>        – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>      – (optional, default: 1) dimension</li><li><code>rng</code>      – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>     – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A random interval.</p><p><strong>Algorithm</strong></p><p>All numbers are normally distributed with mean 0 and standard deviation 1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L336-L358">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isflat-Tuple{Interval}" href="#LazySets.isflat-Tuple{Interval}"><code>LazySets.isflat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isflat(I::Interval)::Bool</code></pre><p>Return whether the interval is flat, i.e. if its extreme values coincide.</p><p><strong>Input</strong></p><ul><li><code>I</code> – interval</li></ul><p><strong>Output</strong></p><p>A boolean which is <code>true</code> if the interval is flat and <code>false</code> otherwise.</p><p><strong>Notes</strong></p><p>For robustness with respect to floating-point inputs, this function relies on the result of <code>isapproxzero</code> when applied to the diameter of the interval. Hence, this function depends on the absolute zero tolerance <code>ABSZTOL</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L453-L471">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.plot_recipe-Union{Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N}}, Tuple{N}, Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N},N}} where N&lt;:Real" href="#LazySets.plot_recipe-Union{Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N}}, Tuple{N}, Tuple{Interval{N,IN} where IN&lt;:AbstractInterval{N},N}} where N&lt;:Real"><code>LazySets.plot_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_recipe(I::Interval{N}, [ε]::N=zero(N)) where {N&lt;:Real}</code></pre><p>Convert an interval to a pair <code>(x, y)</code> of points for plotting.</p><p><strong>Input</strong></p><ul><li><code>I</code> – interval</li><li><code>ε</code> – (optional, default: <code>0</code>) ignored, used for dispatch</li></ul><p><strong>Output</strong></p><p>A pair <code>(x, y)</code> of two points that can be plotted.</p><p><strong>Notes</strong></p><p>We consider the interval as a line segment with y coordinate equal to zero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Interval.jl#L476-L493">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.isbounded-Tuple{AbstractPolytope}"><code>isbounded</code></a></li><li><a href="../interfaces/#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>singleton_list</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractCentrallySymmetricPolytope"><code>AbstractCentrallySymmetricPolytope</code></a>:</p><ul><li><a href="../interfaces/#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}"><code>isempty</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractHyperrectangle"><code>AbstractHyperrectangle</code></a>:</p><ul><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li></ul><h2><a class="nav-anchor" id="Line-1" href="#Line-1">Line</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Line" href="#LazySets.Line"><code>LazySets.Line</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Line{N&lt;:Real, VN&lt;:AbstractVector{N}} &lt;: AbstractPolyhedron{N}</code></pre><p>Type that represents a line in 2D of the form <span>$a⋅x = b$</span> (i.e., a special case of a <code>Hyperplane</code>).</p><p><strong>Fields</strong></p><ul><li><code>a</code> – normal direction</li><li><code>b</code> – constraint</li></ul><p><strong>Examples</strong></p><p>The line <span>$y = -x + 1$</span>:</p><pre><code class="language-julia-repl">julia&gt; Line([1., 1.], 1.)
Line{Float64,Array{Float64,1}}([1.0, 1.0], 1.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Line.jl#L8-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{Line}" href="#LazySets.dim-Tuple{Line}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(L::Line)::Int</code></pre><p>Return the ambient dimension of a line.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the line, which is 2.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Line.jl#L112-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Line{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Line{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, L::Line{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a line in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>L</code> – line</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction, which is defined the same way as for the more general <code>Hyperplane</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Line.jl#L129-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Line{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Line{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, L::Line{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a line.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>L</code> – line</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>x ∈ L</code>.</p><p><strong>Algorithm</strong></p><p>The point <span>$x$</span> belongs to the line if and only if <span>$a⋅x = b$</span> holds.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Line.jl#L196-L213">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{Line{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{Line{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(L::Line{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a line.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line</li></ul><p><strong>Output</strong></p><p>An element on the line.</p><p><strong>Algorithm</strong></p><p>If the <span>$b$</span> value of the line is zero, the result is the origin. Otherwise the result is some <span>$x = [x1, x2]$</span> such that <span>$a·[x1, x2] = b$</span>. We first find out in which dimension <span>$a$</span> is nonzero, say, dimension 1, and then choose <span>$x1 = 1$</span> and accordingly <span>$x2 = \frac{b - a1}{a2}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Line.jl#L165-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{Line}}" href="#Base.rand-Tuple{Type{Line}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{Line}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::Line{N}</code></pre><p>Create a random line.</p><p><strong>Input</strong></p><ul><li><code>Line</code> – type for dispatch</li><li><code>N</code>    – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>  – (optional, default: 2) dimension</li><li><code>rng</code>  – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code> – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A random line.</p><p><strong>Algorithm</strong></p><p>All numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the constraint <code>a</code> is nonzero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Line.jl#L219-L242">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{Line}" href="#LazySets.isbounded-Tuple{Line}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(L::Line)::Bool</code></pre><p>Determine whether a line is bounded.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Line.jl#L148-L160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{Line}" href="#Base.isempty-Tuple{Line}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(L::Line)::Bool</code></pre><p>Return if a line is empty or not.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Line.jl#L259-L271">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constrained_dimensions-Union{Tuple{Line{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constrained_dimensions-Union{Tuple{Line{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constrained_dimensions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constrained_dimensions(L::Line{N})::Vector{Int} where {N&lt;:Real}</code></pre><p>Return the indices in which a line is constrained.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line</li></ul><p><strong>Output</strong></p><p>A vector of ascending indices <code>i</code> such that the line is constrained in dimension <code>i</code>.</p><p><strong>Examples</strong></p><p>A line with constraint <span>$x1 = 0$</span> is constrained in dimension 1 only.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Line.jl#L276-L293">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{Line{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{Line{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(L::Line{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints of a line.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line</li></ul><p><strong>Output</strong></p><p>A list containing two half-spaces.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Line.jl#L91-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{Line{N,VN} where VN&lt;:AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{N}, Tuple{Line{N,VN} where VN&lt;:AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(L::Line{N}, v::AbstractVector{N}; share::Bool=false
         ) where {N&lt;:Real}</code></pre><p>Translate (i.e., shift) a line by a given vector.</p><p><strong>Input</strong></p><ul><li><code>L</code>     – line</li><li><code>v</code>     – translation vector</li><li><code>share</code> – (optional, default: <code>false</code>) flag for sharing unmodified parts of            the original set representation</li></ul><p><strong>Output</strong></p><p>A translated line.</p><p><strong>Notes</strong></p><p>The normal vector of the line (vector <code>a</code> in <code>a⋅x = b</code>) is shared with the original line if <code>share == true</code>.</p><p><strong>Algorithm</strong></p><p>A line <span>$a⋅x = b$</span> is transformed to the line <span>$a⋅x = b + a⋅v$</span>. In other words, we add the dot product <span>$a⋅v$</span> to <span>$b$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Line.jl#L303-L329">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><h2><a class="nav-anchor" id="Line-segment-1" href="#Line-segment-1">Line segment</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.LineSegment" href="#LazySets.LineSegment"><code>LazySets.LineSegment</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">LineSegment{N&lt;:Real} &lt;: AbstractCentrallySymmetricPolytope{N}</code></pre><p>Type that represents a line segment in 2D between two points <span>$p$</span> and <span>$q$</span>.</p><p><strong>Fields</strong></p><ul><li><code>p</code> – first point</li><li><code>q</code> – second point</li></ul><p><strong>Examples</strong></p><p>A line segment along the <span>$x = y$</span> diagonal:</p><pre><code class="language-julia-repl">julia&gt; s = LineSegment([0., 0], [1., 1.])
LineSegment{Float64}([0.0, 0.0], [1.0, 1.0])
julia&gt; dim(s)
2</code></pre><p>Use <code>plot(s)</code> to plot the extreme points of <code>s</code> and the line segment joining them. Membership test is computed with ∈ (<code>in</code>):</p><pre><code class="language-julia-repl">julia&gt; [0., 0] ∈ s &amp;&amp; [.25, .25] ∈ s &amp;&amp; [1., 1] ∈ s &amp;&amp; !([.5, .25] ∈ s)
true</code></pre><p>We can check the intersection with another line segment, and optionally compute a witness (which is just the common point in this case):</p><pre><code class="language-julia-repl">julia&gt; sn = LineSegment([1., 0], [0., 1.])
LineSegment{Float64}([1.0, 0.0], [0.0, 1.0])
julia&gt; isempty(s ∩ sn)
false
julia&gt; is_intersection_empty(s, sn, true)
(false, [0.5, 0.5])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/LineSegment.jl#L8-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LineSegment}" href="#LazySets.dim-Tuple{LineSegment}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(L::LineSegment)::Int</code></pre><p>Return the ambient dimension of a line segment.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line segment</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the line segment, which is 2.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/LineSegment.jl#L70-L82">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LineSegment{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},LineSegment{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, L::LineSegment{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a line segment in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>L</code> – line segment</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>If the angle between the vector <span>$q - p$</span> and <span>$d$</span> is bigger than 90° and less than 270° (measured in counter-clockwise order), the result is <span>$p$</span>, otherwise it is <span>$q$</span>. If the angle is exactly 90° or 270°, or if the direction has norm zero, this implementation returns <span>$q$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/LineSegment.jl#L87-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},LineSegment{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},LineSegment{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, L::LineSegment{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a line segment.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>L</code> – line segment</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ L$</span>.</p><p><strong>Algorithm</strong></p><p>Let <span>$L = (p, q)$</span> be the line segment with extremes <span>$p$</span> and <span>$q$</span>, and let <span>$x$</span> be the given point.</p><ol><li>A necessary condition for <span>$x ∈ (p, q)$</span> is that the three points are aligned, thus their cross product should be zero.</li><li>It remains to check that <span>$x$</span> belongs to the box approximation of <span>$L$</span>. This amounts to comparing each coordinate with those of the extremes <span>$p$</span> and <span>$q$</span>.</li></ol><p><strong>Notes</strong></p><p>The algorithm is inspired from <a href="https://stackoverflow.com/a/328110">here</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/LineSegment.jl#L130-L158">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Union{Tuple{LineSegment{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.center-Union{Tuple{LineSegment{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">center(L::LineSegment{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a line segment.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line segment</li></ul><p><strong>Output</strong></p><p>The center of the line segment.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/LineSegment.jl#L175-L187">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{LineSegment{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{LineSegment{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(L::LineSegment{N}) where {N&lt;:Real}</code></pre><p>Return some element of a line segment.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line segment</li></ul><p><strong>Output</strong></p><p>The first vertex of the line segment.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/LineSegment.jl#L113-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{LineSegment}}" href="#Base.rand-Tuple{Type{LineSegment}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{LineSegment}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::LineSegment{N}</code></pre><p>Create a random line segment.</p><p><strong>Input</strong></p><ul><li><code>LineSegment</code> – type for dispatch</li><li><code>N</code>           – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>         – (optional, default: 2) dimension</li><li><code>rng</code>         – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>        – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A random line segment.</p><p><strong>Algorithm</strong></p><p>All numbers are normally distributed with mean 0 and standard deviation 1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/LineSegment.jl#L219-L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.halfspace_left-Tuple{LineSegment}" href="#LazySets.halfspace_left-Tuple{LineSegment}"><code>LazySets.halfspace_left</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">halfspace_left(L::LineSegment)</code></pre><p>Return a half-space describing the &#39;left&#39; of a two-dimensional line segment through two points.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line segment</li></ul><p><strong>Output</strong></p><p>The half-space whose boundary goes through the two points <code>p</code> and <code>q</code> and which describes the left-hand side of the directed line segment <code>pq</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/LineSegment.jl#L259-L273">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.halfspace_right-Tuple{LineSegment}" href="#LazySets.halfspace_right-Tuple{LineSegment}"><code>LazySets.halfspace_right</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">halfspace_right(L::LineSegment)</code></pre><p>Return a half-space describing the &#39;right&#39; of a two-dimensional line segment through two points.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line segment</li></ul><p><strong>Output</strong></p><p>The half-space whose boundary goes through the two points <code>p</code> and <code>q</code> and which describes the right-hand side of the directed line segment <code>pq</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/LineSegment.jl#L276-L290">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{LineSegment{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{LineSegment{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(L::LineSegment{N}
             )::Vector{&lt;:AbstractVector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a line segment.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line segment</li></ul><p><strong>Output</strong></p><p>The list of end points of the line segment.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/LineSegment.jl#L196-L209">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{LineSegment{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{LineSegment{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(L::LineSegment{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints defining a line segment in 2D.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line segment</li></ul><p><strong>Output</strong></p><p>A vector of constraints that define the line segment.</p><p><strong>Algorithm</strong></p><p><span>$L$</span> is defined by 4 constraints. In this algorithm, the first two constraints are returned by <span>$halfspace_right$</span> and <span>$halfspace_left$</span>, and the other two are obtained by considering the vector normal to the line segment that passes through each opposite vertex.</p><p><strong>Notes</strong></p><p>This function returns a vector of halfspaces. It does not return equality constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/LineSegment.jl#L293-L317">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{LineSegment{N},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{N}, Tuple{LineSegment{N},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(L::LineSegment{N}, v::AbstractVector{N}) where {N&lt;:Real}</code></pre><p>Translate (i.e., shift) a line segment by a given vector.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line segment</li><li><code>v</code> – translation vector</li></ul><p><strong>Output</strong></p><p>A translated line segment.</p><p><strong>Algorithm</strong></p><p>We add the vector to both defining points of the line segment.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/LineSegment.jl#L325-L342">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.plot_recipe-Union{Tuple{LineSegment{N}}, Tuple{N}, Tuple{LineSegment{N},N}} where N&lt;:Real" href="#LazySets.plot_recipe-Union{Tuple{LineSegment{N}}, Tuple{N}, Tuple{LineSegment{N},N}} where N&lt;:Real"><code>LazySets.plot_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_recipe(L::LineSegment{N}, [ε]::N=zero(N)) where {N&lt;:Real}</code></pre><p>Convert a line segment to a pair <code>(x, y)</code> of points for plotting.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line segment</li><li><code>ε</code> – (optional, default: <code>0</code>) ignored, used for dispatch</li></ul><p><strong>Output</strong></p><p>A pair <code>(x, y)</code> of two points that can be plotted.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/LineSegment.jl#L349-L362">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{Dict{Symbol,Any},Union{LineSegment{N}, Interval{N,IN} where IN&lt;:AbstractInterval{N}}}, Tuple{Dict{Symbol,Any},Union{LineSegment{N}, Interval{N,IN} where IN&lt;:AbstractInterval{N}},N}} where N&lt;:Real" href="#RecipesBase.apply_recipe-Union{Tuple{N}, Tuple{Dict{Symbol,Any},Union{LineSegment{N}, Interval{N,IN} where IN&lt;:AbstractInterval{N}}}, Tuple{Dict{Symbol,Any},Union{LineSegment{N}, Interval{N,IN} where IN&lt;:AbstractInterval{N}},N}} where N&lt;:Real"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plot_linesegment(X::Union{Interval{N}, LineSegment{N}}, [ε]::N=zero(N); ...)
    where {N&lt;:Real}</code></pre><p>Plot a line segment or an interval.</p><p><strong>Input</strong></p><ul><li><code>X</code> – line segment or interval</li><li><code>ε</code> – (optional, default: <code>0</code>) ignored, used for dispatch</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; L = LineSegment([0., 0.], [1., 1.]);

julia&gt; plot(L)</code></pre><p>To control the color of the line, use the <code>linecolor</code> keyword argument, and to control the color of the end points, use the <code>markercolor</code> keyword argument. To control the width, use <code>linewidth</code>.</p><pre><code class="language-julia">julia&gt; plot(L, markercolor=&quot;green&quot;, linecolor=&quot;red&quot;, linewidth=2.)</code></pre><p>To omit the markers, use <code>markershape=:none</code>. You also need to pass a value for <code>seriestype=:path</code> explicitly (this seems to be an external bug).</p><pre><code class="language-julia">julia&gt; plot(L, seriestype=:path, markershape=:none)</code></pre><p>A shorter alternative is to pass <code>marker=0</code>, but this may result in small dots as markers based on the plotting backend.</p><pre><code class="language-julia">julia&gt; plot(L, marker=0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/plot_recipes.jl#L209-L250">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.isbounded-Tuple{AbstractPolytope}"><code>isbounded</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractCentrallySymmetricPolytope"><code>AbstractCentrallySymmetricPolytope</code></a>:</p><ul><li><a href="../interfaces/#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}"><code>isempty</code></a></li></ul><h2><a class="nav-anchor" id="Polygons-1" href="#Polygons-1">Polygons</a></h2><h3><a class="nav-anchor" id="Constraint-representation-1" href="#Constraint-representation-1">Constraint representation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.HPolygon" href="#LazySets.HPolygon"><code>LazySets.HPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">HPolygon{N&lt;:Real} &lt;: AbstractHPolygon{N}</code></pre><p>Type that represents a convex polygon in constraint representation whose edges are sorted in counter-clockwise fashion with respect to their normal directions.</p><p><strong>Fields</strong></p><ul><li><code>constraints</code>       – list of linear constraints, sorted by the normal                        direction in counter-clockwise fashion</li><li><code>sort_constraints</code>  – (optional, default: <code>true</code>) flag for sorting the                        constraints (sortedness is a running assumption of this                        type)</li><li><code>check_boundedness</code> – (optional, default: <code>false</code>) flag for checking if the                        constraints make the polygon bounded; (boundedness is a                        running assumption of this type)</li><li><code>prune</code>             – (optional, default: <code>true</code>) flag for removing redundant                        constraints</li></ul><p><strong>Notes</strong></p><p>The option <code>sort_constraints</code> can be used to deactivate automatic sorting of constraints in counter-clockwise fashion, which is an invariant of this type. Alternatively, one can construct an <code>HPolygon</code> with empty constraints list, which can then be filled iteratively using <code>addconstraint!</code>.</p><p>Similarly, the option <code>prune</code> can be used to deactivate automatic pruning of redundant constraints.</p><p>Another type assumption is that the polygon is bounded. The option <code>check_boundedness</code> can be used to assert this. This option is deactivated by default because we explicitly want to allow the iterative addition of the constraints, and hence one has to initially construct an empty list of constraints (which represents an unbounded set). The user has to make sure that the <code>HPolygon</code> is not used before the constraints actually describe a bounded set. The function <code>isbounded</code> can be used to manually assert boundedness.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolygon.jl#L5-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},HPolygon{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},HPolygon{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, P::HPolygon{N};
  [linear_search]::Bool=(length(P.constraints) &lt; BINARY_SEARCH_THRESHOLD)
 ) where {N&lt;:Real}</code></pre><p>Return the support vector of a polygon in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>             – direction</li><li><code>P</code>             – polygon in constraint representation</li><li><code>linear_search</code> – (optional, default: see below) flag for controlling whether                    to perform a linear search or a binary search</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. The result is always one of the vertices; in particular, if the direction has norm zero, any vertex is returned.</p><p><strong>Algorithm</strong></p><p>Comparison of directions is performed using polar angles; see the overload of <code>&lt;=</code> for two-dimensional vectors.</p><p>For polygons with <code>BINARY_SEARCH_THRESHOLD = 10</code> or more constraints we use a binary search by default.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolygon.jl#L107-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{HPolygon{N},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{N}, Tuple{HPolygon{N},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(v::AbstractVector{N}, P::HPolygon{N}; share::Bool=false
         ) where {N&lt;:Real}</code></pre><p>Translate (i.e., shift) a polygon in constraint representation by a given vector.</p><p><strong>Input</strong></p><ul><li><code>P</code>     – polygon in constraint representation</li><li><code>v</code>     – translation vector</li><li><code>share</code> – (optional, default: <code>false</code>) flag for sharing unmodified parts of            the original set representation</li></ul><p><strong>Output</strong></p><p>A translated polygon in constraint representation.</p><p><strong>Notes</strong></p><p>The normal vectors of the constraints (vector <code>a</code> in <code>a⋅x ≤ b</code>) are shared with the original constraints if <code>share == true</code>.</p><p><strong>Algorithm</strong></p><p>We translate every constraint.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolygon.jl#L162-L188">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><a href="../interfaces/#Base.isempty-Tuple{AbstractPolytope}"><code>isempty</code></a></li><li><a href="../interfaces/#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>singleton_list</code></a></li><li><a href="../interfaces/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolyhedron{N}}} where N&lt;:Real"><code>linear_map</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolygon"><code>AbstractPolygon</code></a>:</p><ul><li><a href="../interfaces/#LazySets.dim-Tuple{AbstractPolygon}"><code>dim</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractHPolygon"><code>AbstractHPolygon</code></a>:</p><ul><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li><li><a href="../interfaces/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHPolygon{N}}} where N&lt;:Real"><code>∈</code></a></li><li><a href="../interfaces/#LazySets.vertices_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}, Tuple{AbstractHPolygon{N},Bool}, Tuple{AbstractHPolygon{N},Bool,Bool}} where N&lt;:Real"><code>vertices_list</code></a></li><li><a href="../interfaces/#LazySets.tohrep-Union{Tuple{HPOLYGON}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon"><code>tohrep</code></a></li><li><a href="../interfaces/#LazySets.tovrep-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>tovrep</code></a></li><li><a href="../interfaces/#LazySets.isbounded"><code>isbounded</code></a></li><li><a href="../interfaces/#LazySets.addconstraint!-Union{Tuple{N}, Tuple{AbstractHPolygon{N},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>addconstraint!</code></a></li><li><a href="../interfaces/#LazySets.isredundant-Union{Tuple{N}, Tuple{HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>isredundant</code></a></li><li><a href="../interfaces/#LazySets.remove_redundant_constraints!-Tuple{AbstractHPolygon}"><code>remove_redundant_constraints!</code></a></li><li><a href="../interfaces/#LazySets.constraints_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>constraints_list</code></a></li></ul><h3><a class="nav-anchor" id="Optimized-constraint-representation-1" href="#Optimized-constraint-representation-1">Optimized constraint representation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.HPolygonOpt" href="#LazySets.HPolygonOpt"><code>LazySets.HPolygonOpt</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">HPolygonOpt{N&lt;:Real} &lt;: AbstractHPolygon{N}</code></pre><p>Type that represents a convex polygon in constraint representation whose edges are sorted in counter-clockwise fashion with respect to their normal directions. This is a refined version of <a href="#LazySets.HPolygon"><code>HPolygon</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>constraints</code>       – list of linear constraints, sorted by the normal                        direction in counter-clockwise fashion</li><li><code>ind</code>               – index in the list of constraints to begin the search                        to evaluate the support function</li><li><code>sort_constraints</code>  – (optional, default: <code>true</code>) flag for sorting the                        constraints (sortedness is a running assumption of this                        type)</li><li><code>check_boundedness</code> – (optional, default: <code>false</code>) flag for checking if the                        constraints make the polygon bounded; (boundedness is a                        running assumption of this type)</li><li><code>prune</code>             – (optional, default: <code>true</code>) flag for removing redundant                        constraints</li></ul><p><strong>Notes</strong></p><p>This structure is optimized to evaluate the support function/vector with a large sequence of directions that are close to each other. The strategy is to have an index that can be used to warm-start the search for optimal values in the support vector computation.</p><p>The option <code>sort_constraints</code> can be used to deactivate automatic sorting of constraints in counter-clockwise fashion, which is an invariant of this type. Alternatively, one can construct an <code>HPolygonOpt</code> with empty constraints list, which can then be filled iteratively using <code>addconstraint!</code>.</p><p>Similarly, the option <code>prune</code> can be used to deactivate automatic pruning of redundant constraints.</p><p>Another type assumption is that the polygon is bounded. The option <code>check_boundedness</code> can be used to assert this. This option is deactivated by default because we explicitly want to allow the iterative addition of the constraints, and hence one has to initially construct an empty list of constraints (which represents an unbounded set). The user has to make sure that the <code>HPolygonOpt</code> is not used before the constraints actually describe a bounded set. The function <code>isbounded</code> can be used to manually assert boundedness.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolygonOpt.jl#L5-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},HPolygonOpt{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},HPolygonOpt{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, P::HPolygonOpt{N};
  [linear_search]::Bool=(length(P.constraints) &lt; BINARY_SEARCH_THRESHOLD)
 ) where {N&lt;:Real}</code></pre><p>Return the support vector of an optimized polygon in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>             – direction</li><li><code>P</code>             – optimized polygon in constraint representation</li><li><code>linear_search</code> – (optional, default: see below) flag for controlling whether                    to perform a linear search or a binary search</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. The result is always one of the vertices; in particular, if the direction has norm zero, any vertex is returned.</p><p><strong>Algorithm</strong></p><p>Comparison of directions is performed using polar angles; see the overload of <code>&lt;=</code> for two-dimensional vectors.</p><p>For polygons with <code>BINARY_SEARCH_THRESHOLD = 10</code> or more constraints we use a binary search by default.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolygonOpt.jl#L118-L145">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{HPolygonOpt{N},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{N}, Tuple{HPolygonOpt{N},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(P::HPolygonOpt{N}, v::AbstractVector{N}; share::Bool=false
         ) where {N&lt;:Real}</code></pre><p>Translate (i.e., shift) an optimized polygon in constraint representation by a given vector.</p><p><strong>Input</strong></p><ul><li><code>P</code>     – optimized polygon in constraint representation</li><li><code>v</code>     – translation vector</li><li><code>share</code> – (optional, default: <code>false</code>) flag for sharing unmodified parts of            the original set representation</li></ul><p><strong>Output</strong></p><p>A translated optimized polygon in constraint representation.</p><p><strong>Notes</strong></p><p>The normal vectors of the constraints (vector <code>a</code> in <code>a⋅x ≤ b</code>) are shared with the original constraints if <code>share == true</code>.</p><p><strong>Algorithm</strong></p><p>We translate every constraint.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolygonOpt.jl#L200-L226">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><a href="../interfaces/#Base.isempty-Tuple{AbstractPolytope}"><code>isempty</code></a></li><li><a href="../interfaces/#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>singleton_list</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolygon"><code>AbstractPolygon</code></a>:</p><ul><li><a href="../interfaces/#LazySets.dim-Tuple{AbstractPolygon}"><code>dim</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractHPolygon"><code>AbstractHPolygon</code></a>:</p><ul><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li><li><a href="../interfaces/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractHPolygon{N}}} where N&lt;:Real"><code>∈</code></a></li><li><a href="../interfaces/#LazySets.vertices_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}, Tuple{AbstractHPolygon{N},Bool}, Tuple{AbstractHPolygon{N},Bool,Bool}} where N&lt;:Real"><code>vertices_list</code></a></li><li><a href="../interfaces/#LazySets.tohrep-Union{Tuple{HPOLYGON}, Tuple{HPOLYGON}} where HPOLYGON&lt;:AbstractHPolygon"><code>tohrep</code></a></li><li><a href="../interfaces/#LazySets.tovrep-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>tovrep</code></a></li><li><a href="../interfaces/#LazySets.isbounded"><code>isbounded</code></a></li><li><a href="../interfaces/#LazySets.addconstraint!-Union{Tuple{N}, Tuple{AbstractHPolygon{N},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>addconstraint!</code></a></li><li><a href="../interfaces/#LazySets.isredundant-Union{Tuple{N}, Tuple{HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>isredundant</code></a></li><li><a href="../interfaces/#LazySets.remove_redundant_constraints!-Tuple{AbstractHPolygon}"><code>remove_redundant_constraints!</code></a></li><li><a href="../interfaces/#LazySets.constraints_list-Union{Tuple{AbstractHPolygon{N}}, Tuple{N}} where N&lt;:Real"><code>constraints_list</code></a></li></ul><h3><a class="nav-anchor" id="Vertex-representation-1" href="#Vertex-representation-1">Vertex representation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.VPolygon" href="#LazySets.VPolygon"><code>LazySets.VPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">VPolygon{N&lt;:Real, VN&lt;:AbstractVector{N}} &lt;: AbstractPolygon{N}</code></pre><p>Type that represents a polygon by its vertices.</p><p><strong>Fields</strong></p><ul><li><code>vertices</code> – the list of vertices</li></ul><p><strong>Notes</strong></p><p>The constructor of <code>VPolygon</code> runs a convex hull algorithm on its vertices by default, to remove the possibly redundant vertices. The vertices are sorted in counter-clockwise fashion. Use the flag <code>apply_convex_hull=false</code> to skip the computation of the convex hull.</p><ul><li><code>VPolygon(vertices::Vector{Vector{N}};           apply_convex_hull::Bool=true,           algorithm::String=&quot;monotone_chain&quot;)</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolygon.jl#L11-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, P::VPolygon{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a polygon in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>P</code> – polygon in vertex representation</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the first vertex is returned.</p><p><strong>Algorithm</strong></p><p>This implementation performs a brute-force search, comparing the projection of each vector along the given direction. It runs in <span>$O(n)$</span> where <span>$n$</span> is the number of vertices.</p><p><strong>Notes</strong></p><p>For arbitrary points without structure this is the best one can do. However, a more efficient approach can be used if the vertices of the polygon have been sorted in counter-clockwise fashion. In that case a binary search algorithm can be used that runs in <span>$O(\log n)$</span>. See issue <a href="https://github.com/JuliaReach/LazySets.jl/issues/40">#40</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolygon.jl#L227-L255">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, P::VPolygon{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>P</code> – polygon in vertex representation</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>This implementation exploits that the polygon&#39;s vertices are sorted in counter-clockwise fashion. Under this assumption we can just check if the vertex lies on the left of each edge, using the dot product.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; P = VPolygon([[2.0, 3.0], [3.0, 1.0], [5.0, 1.0], [4.0, 5.0]];
                    apply_convex_hull=false);

julia&gt; ∈([4.5, 3.1], P)
false
julia&gt; ∈([4.5, 3.0], P)
true
julia&gt; ∈([4.4, 3.4], P)  #  point lies on the edge -&gt; floating point error
false
julia&gt; P = VPolygon([[2//1, 3//1], [3//1, 1//1], [5//1, 1//1], [4//1, 5//1]];
                     apply_convex_hull=false);

julia&gt; ∈([44//10, 34//10], P)  #  with rational numbers the answer is correct
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolygon.jl#L285-L324">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(P::VPolygon{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return some element of a polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in vertex representation</li></ul><p><strong>Output</strong></p><p>The first vertex of the polygon in vertex representation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolygon.jl#L267-L279">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{VPolygon}}" href="#Base.rand-Tuple{Type{VPolygon}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{VPolygon}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::VPolygon{N}</code></pre><p>Create a random polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>VPolygon</code>     – type for dispatch</li><li><code>N</code>            – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>          – (optional, default: 2) dimension</li><li><code>rng</code>          – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>         – (optional, default: <code>nothing</code>) seed for reseeding</li><li><code>num_vertices</code> – (optional, default: <code>-1</code>) number of vertices of the                   polygon (see comment below)</li></ul><p><strong>Output</strong></p><p>A random polygon in vertex representation.</p><p><strong>Algorithm</strong></p><p>We follow the idea <a href="https://stackoverflow.com/a/47358689">here</a> based on <a href="https://link.springer.com/article/10.1007%2FBF01271274">P. Valtr. Probability that n random points are in convex position</a>. There is also a nice video available <a href="http://cglab.ca/~sander/misc/ConvexGeneration/convex.html">here</a>.</p><p>The number of vertices can be controlled with the argument <code>num_vertices</code>. For a negative value we choose a random number in the range <code>3:10</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolygon.jl#L401-L432">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(P::VPolygon{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a convex polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – a polygon vertex representation</li></ul><p><strong>Output</strong></p><p>List of vertices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolygon.jl#L206-L218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tohrep-Union{Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{HPOLYGON}, Tuple{N}, Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1},Type{HPOLYGON}}} where HPOLYGON&lt;:AbstractHPolygon where N&lt;:Real" href="#LazySets.tohrep-Union{Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{HPOLYGON}, Tuple{N}, Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1},Type{HPOLYGON}}} where HPOLYGON&lt;:AbstractHPolygon where N&lt;:Real"><code>LazySets.tohrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tohrep(P::VPolygon{N}, ::Type{HPOLYGON}=HPolygon
      ) where {N&lt;:Real, HPOLYGON&lt;:AbstractHPolygon}</code></pre><p>Build a constraint representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code>        – polygon in vertex representation</li><li><code>HPOLYGON</code> – (optional, default: <code>HPolygon</code>) type of target polygon</li></ul><p><strong>Output</strong></p><p>The same polygon but in constraint representation, an <code>AbstractHPolygon</code>.</p><p><strong>Algorithm</strong></p><p>The algorithms consists of adding an edge for each consecutive pair of vertices. Since the vertices are already ordered in counter-clockwise fashion (CWW), the constraints will be sorted automatically (CCW) if we start with the first edge between the first and second vertex.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolygon.jl#L143-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tovrep-Union{Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real" href="#LazySets.tovrep-Union{Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real"><code>LazySets.tovrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tovrep(P::VPolygon{N})::VPolygon{N} where {N&lt;:Real}</code></pre><p>Build a vertex representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in vertex representation</li></ul><p><strong>Output</strong></p><p>The identity, i.e., the same polygon instance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolygon.jl#L126-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(P::VPolygon{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints defining a polygon in V-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in V-representation</li></ul><p><strong>Output</strong></p><p>The list of constraints of the polygon.</p><p><strong>Algorithm</strong></p><p>First the H-representation of <span>$P$</span> is computed, then its list of constraints is returned. </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolygon.jl#L481-L498">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{N}, Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(P::VPolygon{N}, v::AbstractVector{N}) where {N&lt;:Real}</code></pre><p>Translate (i.e., shift) a polygon in vertex representation by a given vector.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in vertex representation</li><li><code>v</code> – translation vector</li></ul><p><strong>Output</strong></p><p>A translated polygon in vertex representation.</p><p><strong>Algorithm</strong></p><p>We add the vector to each vertex of the polygon.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolygon.jl#L534-L551">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.remove_redundant_vertices-Union{Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real" href="#LazySets.remove_redundant_vertices-Union{Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real"><code>LazySets.remove_redundant_vertices</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">remove_redundant_vertices(P::VPolygon{N};
                          [algorithm]::String=&quot;monotone_chain&quot;)::VPolygon{N} where {N&lt;:Real}</code></pre><p>Return the polygon obtained by removing the redundant vertices of the given polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code>         – polygon in vertex representation</li><li><code>algorithm</code> – (optional, default: &quot;monotone_chain&quot;) the algorithm used to                compute the convex hull</li></ul><p><strong>Output</strong></p><p>A new polygon such that its vertices are the convex hull of the given polygon.</p><p><strong>Algorithm</strong></p><p>A convex hull algorithm is used to compute the convex hull of the vertices of the given input polygon <code>P</code>; see <code>?convex_hull</code> for details on the available algorithms. The vertices of the output polygon are sorted in counter-clockwise fashion.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolygon.jl#L87-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.remove_redundant_vertices!-Union{Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real" href="#LazySets.remove_redundant_vertices!-Union{Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real"><code>LazySets.remove_redundant_vertices!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">remove_redundant_vertices!(P::VPolygon{N};
                           [algorithm]::String=&quot;monotone_chain&quot;)::VPolygon{N} where {N&lt;:Real}</code></pre><p>Remove the redundant vertices of the given polygon.</p><p><strong>Input</strong></p><ul><li><code>P</code>         – polygon in vertex representation</li><li><code>algorithm</code> – (optional, default: &quot;monotone_chain&quot;) the algorithm used to                compute the convex hull</li></ul><p><strong>Output</strong></p><p>A new polygon such that its vertices are the convex hull of the given polygon.</p><p><strong>Algorithm</strong></p><p>A convex hull algorithm is used to compute the convex hull of the vertices of the given input polygon <code>P</code>; see <code>?convex_hull</code> for details on the available algorithms. The vertices of the output polygon are sorted in counter-clockwise fashion.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolygon.jl#L60-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.minkowski_sum-Union{Tuple{N}, Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1},VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.minkowski_sum-Union{Tuple{N}, Tuple{VPolygon{N,VN} where VN&lt;:AbstractArray{N,1},VPolygon{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.minkowski_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">minkowski_sum(P::VPolygon{N}, Q::VPolygon{N}) where {N&lt;:Real}</code></pre><p>The Minkowski Sum of two polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in vertex representation</li><li><code>Q</code> – another polygon in vertex representation</li></ul><p><strong>Output</strong></p><p>A polygon in vertex representation.</p><p><strong>Algorithm</strong></p><p>We treat each edge of the polygons as a vector, attaching them in polar order (attaching the tail of the next vector to the head of the previous vector). The resulting polygonal chain will be a polygon, which is the Minkowski sum of the  given polygons. This algorithm assumes that the vertices of P and Q are sorted  in counter-clockwise fashion and has linear complexity O(m+n) where m and n are  the number of vertices of P and Q respectively.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolygon.jl#L558-L581">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.isbounded-Tuple{AbstractPolytope}"><code>isbounded</code></a></li><li><a href="../interfaces/#Base.isempty-Tuple{AbstractPolytope}"><code>isempty</code></a></li><li><a href="../interfaces/#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>singleton_list</code></a></li><li><a href="../interfaces/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolyhedron{N}}} where N&lt;:Real"><code>linear_map</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolygon"><code>AbstractPolygon</code></a>:</p><ul><li><a href="../interfaces/#LazySets.dim-Tuple{AbstractPolygon}"><code>dim</code></a></li></ul><h3><a class="nav-anchor" id="Sorting-directions-1" href="#Sorting-directions-1">Sorting directions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.jump2pi" href="#LazySets.jump2pi"><code>LazySets.jump2pi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">jump2pi(x::N)::N where {N&lt;:AbstractFloat}</code></pre><p>Return <span>$x + 2π$</span> if <span>$x$</span> is negative, otherwise return <span>$x$</span>.</p><p><strong>Input</strong></p><ul><li><code>x</code> – real scalar</li></ul><p><strong>Output</strong></p><p><span>$x + 2π$</span> if <span>$x$</span> is negative, <span>$x$</span> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LazySets: jump2pi

julia&gt; jump2pi(0.0)
0.0

julia&gt; jump2pi(-0.5)
5.783185307179586

julia&gt; jump2pi(0.5)
0.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/AbstractPolygon.jl#L50-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&lt;=-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:AbstractFloat" href="#Base.:&lt;=-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:AbstractFloat"><code>Base.:&lt;=</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">&lt;=(u::AbstractVector{N}, v::AbstractVector{N})::Bool where {N&lt;:AbstractFloat}</code></pre><p>Compares two 2D vectors by their direction.</p><p><strong>Input</strong></p><ul><li><code>u</code> –  first 2D direction</li><li><code>v</code> –  second 2D direction</li></ul><p><strong>Output</strong></p><p>True iff <span>$\arg(u) [2π] ≤ \arg(v) [2π]$</span></p><p><strong>Notes</strong></p><p>The argument is measured in counter-clockwise fashion, with the 0 being the direction (1, 0).</p><p><strong>Algorithm</strong></p><p>The implementation uses the arctangent function with sign, <code>atan</code>, which for two arguments implements the <a href="https://en.wikipedia.org/wiki/Atan2"><code>atan2</code> function</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/AbstractPolygon.jl#L172-L196">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&lt;=-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:Real" href="#Base.:&lt;=-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:Real"><code>Base.:&lt;=</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">&lt;=(u::AbstractVector{N}, v::AbstractVector{N})::Bool where {N&lt;:Real}</code></pre><p>Compare two 2D vectors by their direction.</p><p><strong>Input</strong></p><ul><li><code>u</code> – first 2D direction</li><li><code>v</code> – second 2D direction</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$\arg(u) [2π] ≤ \arg(v) [2π]$</span>.</p><p><strong>Notes</strong></p><p>The argument is measured in counter-clockwise fashion, with the 0 being the direction (1, 0).</p><p><strong>Algorithm</strong></p><p>The implementation checks the quadrant of each direction, and compares directions using the right-hand rule (see <a href="../utils/#LazySets.is_right_turn"><code>is_right_turn</code></a>). In particular, this method does not use the arctangent.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/AbstractPolygon.jl#L137-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.quadrant-Tuple{AbstractArray{Real,1}}" href="#LazySets.quadrant-Tuple{AbstractArray{Real,1}}"><code>LazySets.quadrant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">quadrant(w::AbstractVector{N})::Int where {N&lt;:Real}</code></pre><p>Compute the quadrant where the direction <code>w</code> belongs.</p><p><strong>Input</strong></p><ul><li><code>w</code> –  direction</li></ul><p><strong>Output</strong></p><p>An integer from 0 to 3, with the following convention:</p><pre><code class="language-none">     ^
   1 | 0
  ---+--&gt;
   2 | 3</code></pre><p><strong>Algorithm</strong></p><p>The idea is to encode the following logic function: <span>$11 ↦ 0, 01 ↦ 1, 00 ↦ 2, 10 ↦ 3$</span>, according to the convention of above.</p><p>This function is inspired from AGPX&#39;s answer in: <a href="https://stackoverflow.com/a/46635372">Sort points in clockwise order?</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/AbstractPolygon.jl#L82-L109">source</a></section><h2><a class="nav-anchor" id="Polyhedra-and-Polytopes-1" href="#Polyhedra-and-Polytopes-1">Polyhedra and Polytopes</a></h2><h3><a class="nav-anchor" id="Constraint-representation-2" href="#Constraint-representation-2">Constraint representation</a></h3><p><a href="https://en.wikipedia.org/wiki/Polytope">Convex polytopes</a> are bounded polyhedra. The types <code>HPolytope</code> and <code>HPolyhedron</code> are used to represent polytopes and general polyhedra respectively, the difference being that for <code>HPolytope</code> there is a running assumption about the boundedness of the set.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.HPolytope" href="#LazySets.HPolytope"><code>LazySets.HPolytope</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">HPolytope{N&lt;:Real} &lt;: AbstractPolytope{N}</code></pre><p>Type that represents a convex polytope in H-representation.</p><p><strong>Fields</strong></p><ul><li><code>constraints</code>       – vector of linear constraints</li><li><code>check_boundedness</code> – (optional, default: <code>false</code>) flag for checking if the                        constraints make the polytope bounded; (boundedness is                        a running assumption of this type)</li></ul><p><strong>Note</strong></p><p>Recall that a polytope is a bounded polyhedron. Boundedness is a running assumption in this type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolytope.jl#L7-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.HPolyhedron" href="#LazySets.HPolyhedron"><code>LazySets.HPolyhedron</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">HPolyhedron{N&lt;:Real} &lt;: AbstractPolyhedron{N}</code></pre><p>Type that represents a convex polyhedron in H-representation.</p><p><strong>Fields</strong></p><ul><li><code>constraints</code> – vector of linear constraints</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolyhedron.jl#L22-L30">source</a></section><p>The following methods are shared between <code>HPolytope</code> and <code>HPolyhedron</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Union{Tuple{Union{HPolyhedron{N}, HPolytope{N}}}, Tuple{N}} where N&lt;:Real" href="#LazySets.dim-Union{Tuple{Union{HPolyhedron{N}, HPolytope{N}}}, Tuple{N}} where N&lt;:Real"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(P::HPoly{N})::Int where {N&lt;:Real}</code></pre><p>Return the dimension of a polyhedron in H-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>  – polyhedron in H-representation</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polyhedron in H-representation. If it has no constraints, the result is <span>$-1$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolyhedron.jl#L66-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Union{HPolyhedron{N}, HPolytope{N}}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Union{HPolyhedron{N}, HPolytope{N}}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, P::HPoly{N})::N where {N&lt;:Real}</code></pre><p>Evaluate the support function of a polyhedron (in H-representation) in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>P</code> – polyhedron in H-representation</li></ul><p><strong>Output</strong></p><p>The support function of the polyhedron. If a polytope is unbounded in the given direction, we throw an error. If a polyhedron is unbounded in the given direction, the result is <code>Inf</code>.</p><p><strong>Algorithm</strong></p><p>This implementation uses <code>GLPKSolverLP</code> as linear programming backend.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolyhedron.jl#L84-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Union{HPolyhedron{N}, HPolytope{N}}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Union{HPolyhedron{N}, HPolytope{N}}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, P::HPoly{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a polyhedron (in H-representation) in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>P</code> – polyhedron in H-representation</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p><p><strong>Algorithm</strong></p><p>This implementation uses <code>GLPKSolverLP</code> as linear programming backend.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolyhedron.jl#L117-L135">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.addconstraint!-Union{Tuple{N}, Tuple{Union{HPolyhedron{N}, HPolytope{N}},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.addconstraint!-Union{Tuple{N}, Tuple{Union{HPolyhedron{N}, HPolytope{N}},HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">addconstraint!(P::HPoly{N},
               constraint::LinearConstraint{N})::Nothing where {N&lt;:Real}</code></pre><p>Add a linear constraint to a polyhedron in H-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>          – polyhedron in H-representation</li><li><code>constraint</code> – linear constraint to add</li></ul><p><strong>Output</strong></p><p>Nothing.</p><p><strong>Notes</strong></p><p>It is left to the user to guarantee that the dimension of all linear constraints is the same.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolyhedron.jl#L275-L294">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{Union{HPolyhedron{N}, HPolytope{N}}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{Union{HPolyhedron{N}, HPolytope{N}}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(P::HPoly{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints defining a polyhedron in H-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polyhedron in H-representation</li></ul><p><strong>Output</strong></p><p>The list of constraints of the polyhedron.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolyhedron.jl#L302-L314">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tohrep-Union{Tuple{Union{HPolyhedron{N}, HPolytope{N}}}, Tuple{N}} where N&lt;:Real" href="#LazySets.tohrep-Union{Tuple{Union{HPolyhedron{N}, HPolytope{N}}}, Tuple{N}} where N&lt;:Real"><code>LazySets.tohrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tohrep(P::HPoly{N}) where {N&lt;:Real}</code></pre><p>Return a constraint representation of the given polyhedron in constraint representation (no-op).</p><p><strong>Input</strong></p><ul><li><code>P</code> – polyhedron in constraint representation</li></ul><p><strong>Output</strong></p><p>The same polyhedron instance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolyhedron.jl#L319-L332">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tovrep-Union{Tuple{Union{HPolyhedron{N}, HPolytope{N}}}, Tuple{N}} where N&lt;:Real" href="#LazySets.tovrep-Union{Tuple{Union{HPolyhedron{N}, HPolytope{N}}}, Tuple{N}} where N&lt;:Real"><code>LazySets.tovrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tovrep(P::HPoly{N};
      [backend]=default_polyhedra_backend(P, N)) where {N&lt;:Real}</code></pre><p>Transform a polyhedron in H-representation to a polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polyhedron in constraint representation</li><li><code>backend</code> – (optional, default: <code>default_polyhedra_backend(P, N)</code>) the              backend for polyhedral computations</li></ul><p><strong>Output</strong></p><p>The <code>VPolytope</code> which is the vertex representation of the given polyhedron in constraint representation.</p><p><strong>Notes</strong></p><p>The conversion may not preserve the numeric type (e.g., with <code>N == Float32</code>) depending on the backend. For further information on the supported backends see <a href="https://juliapolyhedra.github.io/Polyhedra.jl/latest/installation.html#Getting-Libraries-1">Polyhedra&#39;s documentation</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolyhedron.jl#L514-L537">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Union{Tuple{Union{HPolyhedron{N}, HPolytope{N}}}, Tuple{N}, Tuple{Union{HPolyhedron{N}, HPolytope{N}},Bool}} where N&lt;:Real" href="#Base.isempty-Union{Tuple{Union{HPolyhedron{N}, HPolytope{N}}}, Tuple{N}, Tuple{Union{HPolyhedron{N}, HPolytope{N}},Bool}} where N&lt;:Real"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>isempty(P::HPoly{N}, witness::Bool=false;            [use<em>polyhedra</em>interface]::Bool=false, [solver]=GLPKSolverLP(),            [backend]=nothing           )::Union{Bool, Tuple{Bool, Vector{N}}} where {N&lt;:Real}</p><p>Determine whether a polyhedron is empty.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polyhedron</li><li><code>witness</code> – (optional, default: <code>false</code>) compute a witness if activated</li><li><code>use_polyhedra_interface</code> – (optional, default: <code>false</code>) if <code>true</code>, we use              the <code>Polyhedra</code> interface for the emptiness test</li><li><code>solver</code>  – (optional, default: <code>GLPKSolverLP()</code>) LP-solver backend</li><li><code>backend</code> – (optional, default: <code>nothing</code>) backend for polyhedral              computations in <code>Polyhedra</code>; its value is set internally (see the              Notes below for details)</li></ul><p><strong>Output</strong></p><ul><li>If <code>witness</code> option is deactivated: <code>true</code> iff <span>$P = ∅$</span></li><li>If <code>witness</code> option is activated:<ul><li><code>(true, [])</code> iff <span>$P = ∅$</span></li><li><code>(false, v)</code> iff <span>$P ≠ ∅$</span> and <span>$v ∈ P$</span></li></ul></li></ul><p><strong>Notes</strong></p><p>The default value of the <code>backend</code> is set internally and depends on whether the <code>use_polyhedra_interface</code> option is set or not. If the option is set, we use <code>default_polyhedra_backend(P, N)</code>.</p><p>Witness production is not supported if <code>use_polyhedra_interface</code> is <code>true</code>.</p><p><strong>Algorithm</strong></p><p>The algorithm sets up a feasibility LP for the constraints of <code>P</code>. If <code>use_polyhedra_interface</code> is <code>true</code>, we call <code>Polyhedra.isempty</code>. Otherwise, we set up the LP internally.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolyhedron.jl#L595-L634">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{PT}, Tuple{N}, Tuple{PT,AbstractArray{N,1}}} where PT&lt;:Union{HPolyhedron{N}, HPolytope{N}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{PT}, Tuple{N}, Tuple{PT,AbstractArray{N,1}}} where PT&lt;:Union{HPolyhedron{N}, HPolytope{N}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(P::PT, v::AbstractVector{N}; share::Bool=false
         ) where {N&lt;:Real, PT&lt;:HPoly{N}}</code></pre><p>Translate (i.e., shift) a polyhedron in constraint representation by a given vector.</p><p><strong>Input</strong></p><ul><li><code>P</code>     – polyhedron in constraint representation</li><li><code>v</code>     – translation vector</li><li><code>share</code> – (optional, default: <code>false</code>) flag for sharing unmodified parts of            the original set representation</li></ul><p><strong>Output</strong></p><p>A translated polyhedron in constraint representation.</p><p><strong>Notes</strong></p><p>The normal vectors of the constraints (vector <code>a</code> in <code>a⋅x ≤ b</code>) are shared with the original constraints if <code>share == true</code>.</p><p><strong>Algorithm</strong></p><p>We translate every constraint.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolyhedron.jl#L404-L430">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.cartesian_product-Union{Tuple{N}, Tuple{Union{HPolyhedron{N}, HPolytope{N}},Union{HPolyhedron{N}, HPolytope{N}}}} where N&lt;:Real" href="#LazySets.cartesian_product-Union{Tuple{N}, Tuple{Union{HPolyhedron{N}, HPolytope{N}},Union{HPolyhedron{N}, HPolytope{N}}}} where N&lt;:Real"><code>LazySets.cartesian_product</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">cartesian_product(P1::HPoly{N}, P2::HPoly{N};
                  [backend]=default_polyhedra_backend(P1, N)
                 ) where {N&lt;:Real}</code></pre><p>Compute the Cartesian product of two polyhedra in H-representaion.</p><p><strong>Input</strong></p><ul><li><code>P1</code>         – polyhedron</li><li><code>P2</code>         – another polyhedron</li><li><code>backend</code>    – (optional, default: <code>default_polyhedra_backend(P1, N)</code>)                 the polyhedral computations backend</li></ul><p><strong>Output</strong></p><p>The polyhedron obtained by the concrete cartesian product of <code>P1</code> and <code>P2</code>.</p><p><strong>Notes</strong></p><p>For further information on the supported backends see <a href="https://juliapolyhedra.github.io/Polyhedra.jl/">Polyhedra&#39;s documentation</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolyhedron.jl#L480-L502">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.polyhedron-Union{Tuple{Union{HPolyhedron{N}, HPolytope{N}}}, Tuple{N}} where N&lt;:Real" href="#Polyhedra.polyhedron-Union{Tuple{Union{HPolyhedron{N}, HPolytope{N}}}, Tuple{N}} where N&lt;:Real"><code>Polyhedra.polyhedron</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">polyhedron(P::HPoly{N};
           [backend]=default_polyhedra_backend(P, N)) where {N&lt;:Real}</code></pre><p>Return an <code>HRep</code> polyhedron from <code>Polyhedra.jl</code> given a polytope in H-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polytope</li><li><code>backend</code> – (optional, default: call <code>default_polyhedra_backend(P, N)</code>)               the polyhedral computations backend</li></ul><p><strong>Output</strong></p><p>An <code>HRep</code> polyhedron.</p><p><strong>Notes</strong></p><p>For further information on the supported backends see <a href="https://juliapolyhedra.github.io/Polyhedra.jl/">Polyhedra&#39;s documentation</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolyhedron.jl#L713-L734">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.remove_redundant_constraints-Union{Tuple{PT}, Tuple{PT}, Tuple{N}} where PT&lt;:Union{HPolyhedron{N}, HPolytope{N}} where N&lt;:Real" href="#LazySets.remove_redundant_constraints-Union{Tuple{PT}, Tuple{PT}, Tuple{N}} where PT&lt;:Union{HPolyhedron{N}, HPolytope{N}} where N&lt;:Real"><code>LazySets.remove_redundant_constraints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">remove_redundant_constraints(P::PT;
                             backend=GLPKSolverLP()
                            )::Union{PT, EmptySet{N}} where {N&lt;:Real,
                                                             PT&lt;:HPoly{N}}</code></pre><p>Remove the redundant constraints in a polyhedron in H-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polyhedron</li><li><code>backend</code> – (optional, default: <code>GLPKSolverLP</code>) the numeric LP solver backend</li></ul><p><strong>Output</strong></p><p>A polyhedron equivalent to <code>P</code> but with no redundant constraints, or an empty set if <code>P</code> is detected to be empty, which may happen if the constraints are infeasible.</p><p><strong>Algorithm</strong></p><p>See <a href="#LazySets.remove_redundant_constraints!-Union{Tuple{AbstractArray{LC,1}}, Tuple{LC}, Tuple{N}} where LC&lt;:(HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}) where N&lt;:Real"><code>remove_redundant_constraints!(::Vector{LinearConstraint{&lt;:Real}})</code></a> for details.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolyhedron.jl#L337-L361">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.remove_redundant_constraints!-Union{Tuple{Union{HPolyhedron{N}, HPolytope{N}}}, Tuple{N}} where N&lt;:Real" href="#LazySets.remove_redundant_constraints!-Union{Tuple{Union{HPolyhedron{N}, HPolytope{N}}}, Tuple{N}} where N&lt;:Real"><code>LazySets.remove_redundant_constraints!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">remove_redundant_constraints!(P::HPoly{N};
                              backend=GLPKSolverLP())::Bool where {N&lt;:Real}</code></pre><p>Remove the redundant constraints in a polyhedron in H-representation; the polyhedron is updated in-place.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polyhedron</li><li><code>backend</code> – (optional, default: <code>GLPKSolverLP</code>) the numeric LP solver backend</li></ul><p><strong>Output</strong></p><p><code>true</code> if the method was successful and the polyhedron <code>P</code> is modified by removing its redundant constraints, and <code>false</code> if <code>P</code> is detected to be empty, which may happen if the constraints are infeasible.</p><p><strong>Algorithm</strong></p><p>See <a href="#LazySets.remove_redundant_constraints!-Union{Tuple{AbstractArray{LC,1}}, Tuple{LC}, Tuple{N}} where LC&lt;:(HalfSpace{N,VN} where VN&lt;:AbstractArray{N,1}) where N&lt;:Real"><code>remove_redundant_constraints!(::Vector{LinearConstraint{&lt;:Real}})</code></a> for details.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolyhedron.jl#L374-L397">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolyhedron"><code>AbstractPolyhedron</code></a>:</p><ul><li><a href="../interfaces/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractPolyhedron{N}}} where N&lt;:Real"><code>∈</code></a></li><li>[<code>constrained_dimensions</code>](@ref constrained_dimensions(::AbstractPolyhedron)</li><li><a href="../interfaces/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolyhedron{N}}} where N&lt;:Real"><code>linear_map</code></a></li></ul><h4><a class="nav-anchor" id="Polytopes-1" href="#Polytopes-1">Polytopes</a></h4><p>The following methods are specific for <code>HPolytope</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{HPolytope}}" href="#Base.rand-Tuple{Type{HPolytope}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{HPolytope}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::HPolytope{N}</code></pre><p>Create a random polytope in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>HPolytope</code>    – type for dispatch</li><li><code>N</code>            – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>          – (optional, default: 2) dimension</li><li><code>rng</code>          – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>         – (optional, default: <code>nothing</code>) seed for reseeding</li><li><code>num_vertices</code> – (optional, default: <code>-1</code>) upper bound on the number of                   vertices of the polytope (see comment below)</li></ul><p><strong>Output</strong></p><p>A random polytope in constraint representation.</p><p><strong>Algorithm</strong></p><p>We create a random polytope in vertex representation and convert it to constraint representation (hence the argument <code>num_vertices</code>). See <a href="#Base.rand-Tuple{Type{VPolytope}}"><code>rand(::Type{VPolytope})</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolytope.jl#L62-L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{HPolytope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{HPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(P::HPolytope{N};
              [backend]=nothing,
              [prune]::Bool=true)::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a polytope in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polytope in constraint representation</li><li><code>backend</code> – (optional, default: <code>nothing</code>) the polyhedral computations backend</li><li><code>prune</code>   – (optional, default: <code>true</code>) flag to remove redundant vertices</li></ul><p><strong>Output</strong></p><p>List of vertices.</p><p><strong>Algorithm</strong></p><p>If the polytope is two-dimensional, the polytope is converted to a polygon in H-representation and then its <code>vertices_list</code> function is used. This ensures that, by default, the optimized two-dimensional methods are used.</p><p>It is possible to use the <code>Polyhedra</code> backend in two-dimensions as well by passing, e.g. <code>backend=CDDLib.Library()</code>.</p><p>If the polytope is not two-dimensional, the concrete polyhedra manipulation library <code>Polyhedra</code> is used. The actual computation is performed by a given backend; for the default backend used in <code>LazySets</code> see <code>default_polyhedra_backend(N)</code>. For further information on the supported backends see <a href="https://juliapolyhedra.github.io/Polyhedra.jl/">Polyhedra&#39;s documentation</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolytope.jl#L179-L210">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded" href="#LazySets.isbounded"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isbounded(P::HPolytope, [use_type_assumption]::Bool=true)::Bool</code></pre><p>Determine whether a polytope in constraint representation is bounded.</p><p><strong>Input</strong></p><ul><li><code>P</code>                   – polytope in constraint representation</li><li><code>use_type_assumption</code> – (optional, default: <code>true</code>) flag for ignoring the                          type assumption that polytopes are bounded</li></ul><p><strong>Output</strong></p><p><code>true</code> if <code>use_type_assumption</code> is activated. Otherwise, <code>true</code> iff <code>P</code> is bounded.</p><p><strong>Algorithm</strong></p><p>If <code>!use_type_assumption</code>, we convert <code>P</code> to an <code>HPolyhedron</code> <code>P2</code> and then use <code>isbounded(P2)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolytope.jl#L104-L124">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>singleton_list</code></a></li></ul><h4><a class="nav-anchor" id="Polyhedra-1" href="#Polyhedra-1">Polyhedra</a></h4><p>The following methods are specific for <code>HPolyhedron</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{HPolyhedron}}" href="#Base.rand-Tuple{Type{HPolyhedron}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{HPolyhedron}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::HPolyhedron{N}</code></pre><p>Create a polyhedron.</p><p><strong>Input</strong></p><ul><li><code>HPolyhedron</code> – type for dispatch</li><li><code>N</code>           – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>         – (optional, default: 2) dimension (is ignored)</li><li><code>rng</code>         – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>        – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A polyhedron.</p><p><strong>Algorithm</strong></p><p>We first create a random polytope and then randomly remove some of the constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolyhedron.jl#L227-L250">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{HPolyhedron}" href="#LazySets.isbounded-Tuple{HPolyhedron}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(P::HPolyhedron)::Bool</code></pre><p>Determine whether a polyhedron in constraint representation is bounded.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polyhedron in constraint representation</li></ul><p><strong>Output</strong></p><p><code>true</code> iff the polyhedron is bounded.</p><p><strong>Algorithm</strong></p><p>We first check if the polyhedron has more than <code>max(dim(P), 1)</code> constraints, which is a necessary condition for boundedness. If so, we check boundedness via <a href="../interfaces/#LazySets.isbounded_unit_dimensions-Union{Tuple{LazySet{N}}, Tuple{N}} where N&lt;:Real"><code>isbounded_unit_dimensions</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolyhedron.jl#L201-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{HPolyhedron{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{HPolyhedron{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(P::HPolyhedron{N}) where {N&lt;:Real}</code></pre><p>Return the list of vertices of a polyhedron in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polyhedron in constraint representation</li></ul><p><strong>Output</strong></p><p>This function returns an error because the polyhedron is possibly unbounded. If <code>P</code> is known to be bounded, try converting to <code>HPolytope</code> first:</p><pre><code class="language-julia-repl">julia&gt; P = HPolyhedron([HalfSpace([1.0, 0.0], 1.0),
                        HalfSpace([0.0, 1.0], 1.0),
                        HalfSpace([-1.0, 0.0], 1.0),
                        HalfSpace([0.0, -1.0], 1.0)]);

julia&gt; P_as_polytope = convert(HPolytope, P);</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolyhedron.jl#L546-L568">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.singleton_list-Union{Tuple{HPolyhedron{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.singleton_list-Union{Tuple{HPolyhedron{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">singleton_list(P::HPolyhedron{N})::Vector{Singleton{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a polyhedron in H-representation as a list of singletons.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polytope in constraint representation</li></ul><p><strong>Output</strong></p><p>This function returns an error because the polyhedron is possibly unbounded. If <code>P</code> is known to be bounded, try converting to <code>HPolytope</code> first.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/HPolyhedron.jl#L575-L588">source</a></section><h3><a class="nav-anchor" id="Vertex-representation-2" href="#Vertex-representation-2">Vertex representation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.VPolytope" href="#LazySets.VPolytope"><code>LazySets.VPolytope</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">VPolytope{N&lt;:Real} &lt;: AbstractPolytope{N}</code></pre><p>Type that represents a convex polytope in V-representation.</p><p><strong>Fields</strong></p><ul><li><code>vertices</code> – the list of vertices</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolytope.jl#L13-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{VPolytope}" href="#LazySets.dim-Tuple{VPolytope}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(P::VPolytope)::Int</code></pre><p>Return the dimension of a polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>  – polytope in V-representation</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polytope in V-representation. If it is empty, the result is <span>$-1$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = VPolytope();

julia&gt; dim(v) &gt; 0
false

julia&gt; v = VPolytope([ones(3)])
VPolytope{Float64}(Array{Float64,1}[[1.0, 1.0, 1.0]])

julia&gt; dim(v) == 3
true
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolytope.jl#L43-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},VPolytope{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},VPolytope{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, P::VPolytope{N}; algorithm=&quot;hrep&quot;) where {N&lt;:Real}</code></pre><p>Return the support vector of a polyhedron (in V-representation) in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code>         – direction</li><li><code>P</code>         – polyhedron in V-representation</li><li><code>algorithm</code> – (optional, default: <code>&#39;hrep&#39;</code>) method to compute the support vector</li></ul><p><strong>Output</strong></p><p>The support vector in the given direction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolytope.jl#L77-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},VPolytope{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},VPolytope{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, P::VPolytope{N};
  solver=GLPKSolverLP(method=:Simplex))::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a polytope in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>P</code> – polytope in vertex representation</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ P$</span>.</p><p><strong>Algorithm</strong></p><p>We check, using linear programming, the definition of a convex polytope that a point is in the set if and only if it is a convex combination of the vertices.</p><p>Let <span>$\{v_j\}$</span> be the <span>$m$</span> vertices of <code>P</code>. Then we solve the following <span>$m$</span>-dimensional linear program.</p><div>\[\max 0 \text{s.t.}
igwedge_{i=1}^n \sum_{j=1}^m λ_j v_j[i] = x[i]
\sum_{j=1}^m λ_j = 1
igwedge_{j=1}^m λ_j ≥ 0\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolytope.jl#L105-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{VPolytope}}" href="#Base.rand-Tuple{Type{VPolytope}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{VPolytope}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::VPolytope{N}</code></pre><p>Create a random polytope in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>VPolytope</code>    – type for dispatch</li><li><code>N</code>            – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>          – (optional, default: 2) dimension</li><li><code>rng</code>          – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>         – (optional, default: <code>nothing</code>) seed for reseeding</li><li><code>num_vertices</code> – (optional, default: <code>-1</code>) upper bound on the number of                   vertices of the polytope (see comment below)</li></ul><p><strong>Output</strong></p><p>A random polytope in vertex representation.</p><p><strong>Algorithm</strong></p><p>All numbers are normally distributed with mean 0 and standard deviation 1.</p><p>The number of vertices can be controlled with the argument <code>num_vertices</code>. For a negative value we choose a random number in the range <code>dim:5*dim</code> (except if <code>dim == 1</code>, in which case we choose in the range <code>1:2</code>). Note that we do not guarantee that the vertices are not redundant.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolytope.jl#L177-L206">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{VPolytope{N},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{N}, Tuple{VPolytope{N},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(P::VPolytope{N}, v::AbstractVector{N}) where {N&lt;:Real}</code></pre><p>Translate (i.e., shift) a polytope in vertex representation by a given vector.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polytope in vertex representation</li><li><code>v</code> – translation vector</li></ul><p><strong>Output</strong></p><p>A translated polytope in vertex representation.</p><p><strong>Algorithm</strong></p><p>We add the vector to each vertex of the polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolytope.jl#L250-L267">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{VPolytope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{VPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(P::VPolytope{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polytope in vertex representation</li></ul><p><strong>Output</strong></p><p>List of vertices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolytope.jl#L276-L288">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.remove_redundant_vertices-Union{Tuple{VPolytope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.remove_redundant_vertices-Union{Tuple{VPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.remove_redundant_vertices</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">remove_redundant_vertices(P::VPolytope{N};
                          [backend]=default_polyhedra_backend(P, N))::VPolytope{N} where {N&lt;:Real}</code></pre><p>Return the polytope obtained by removing the redundant vertices of the given polytope.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polytope in vertex representation</li><li><code>backend</code> – (optional, default: <code>default_polyhedra_backend(P1, N)</code>) the polyhedral              computations backend, see              <a href="https://juliapolyhedra.github.io/Polyhedra.jl/latest/installation.html#Getting-Libraries-1">Polyhedra&#39;s documentation</a>              for further information</li></ul><p><strong>Output</strong></p><p>A new polytope such that its vertices are the convex hull of the given polytope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolytope.jl#L377-L394">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{VPolytope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{VPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(P::VPolytope{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints defining a polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polytope in V-representation</li></ul><p><strong>Output</strong></p><p>The list of constraints of the polytope.</p><p><strong>Algorithm</strong></p><p>First the H-representation of <span>$P$</span> is computed, then its list of constraints is returned. </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolytope.jl#L293-L310">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tohrep-Union{Tuple{VPolytope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.tohrep-Union{Tuple{VPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.tohrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tohrep(P::VPolytope{N};
       [backend]=default_polyhedra_backend(P, N)) where {N&lt;:Real}</code></pre><p>Transform a polytope in V-representation to a polytope in H-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polytope in vertex representation</li><li><code>backend</code> – (optional, default: <code>default_polyhedra_backend(P, N)</code>) the              backend for polyhedral computations</li></ul><p><strong>Output</strong></p><p>The <code>HPolytope</code> which is the constraint representation of the given polytope in vertex representation.</p><p><strong>Notes</strong></p><p>The conversion may not preserve the numeric type (e.g., with <code>N == Float32</code>) depending on the backend. For further information on the supported backends see <a href="https://juliapolyhedra.github.io/Polyhedra.jl/latest/installation.html#Getting-Libraries-1">Polyhedra&#39;s documentation</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolytope.jl#L404-L427">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tovrep-Tuple{VPolytope}" href="#LazySets.tovrep-Tuple{VPolytope}"><code>LazySets.tovrep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tovrep(P::VPolytope)</code></pre><p>Return a vertex representation of the given polytope in vertex representation (no-op).</p><p><strong>Input</strong></p><ul><li><code>P</code> – polytope in vertex representation</li></ul><p><strong>Output</strong></p><p>The same polytope instance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolytope.jl#L439-L452">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.cartesian_product-Union{Tuple{N}, Tuple{VPolytope{N},VPolytope{N}}} where N" href="#LazySets.cartesian_product-Union{Tuple{N}, Tuple{VPolytope{N},VPolytope{N}}} where N"><code>LazySets.cartesian_product</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">cartesian_product(P1::VPolytope{N}, P2::VPolytope{N};
                  [backend]=default_polyhedra_backend(P1, N)) where {N}</code></pre><p>Compute the Cartesian product of two polytopes in V-representation.</p><p><strong>Input</strong></p><ul><li><code>P1</code>         – polytope</li><li><code>P2</code>         – another polytope</li><li><code>backend</code>    – (optional, default: <code>default_polyhedra_backend(P1, N)</code>) the polyhedral                 computations backend, see                 <a href="https://juliapolyhedra.github.io/Polyhedra.jl/latest/installation.html#Getting-Libraries-1">Polyhedra&#39;s documentation</a>                 for further information</li></ul><p><strong>Output</strong></p><p>The <code>VPolytope</code> obtained by the concrete Cartesian product of <code>P1</code> and <code>P2</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolytope.jl#L349-L367">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.polyhedron-Union{Tuple{VPolytope{N}}, Tuple{N}} where N&lt;:Real" href="#Polyhedra.polyhedron-Union{Tuple{VPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>Polyhedra.polyhedron</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">polyhedron(P::VPolytope{N};
           [backend]=default_polyhedra_backend(P, N)) where {N&lt;:Real}</code></pre><p>Return an <code>VRep</code> polyhedron from <code>Polyhedra.jl</code> given a polytope in V-representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polytope</li><li><code>backend</code> – (optional, default: <code>default_polyhedra_backend(P, N)</code>) the polyhedral              computations backend, see <a href="https://juliapolyhedra.github.io/Polyhedra.jl/latest/installation.html#Getting-Libraries-1">Polyhedra&#39;s documentation</a>              for further information</li><li><code>relative_dimension</code> – (default, optional: <code>nothing</code>) an integer representing                         the (relative) dimension of the polytope; this argument                         is mandatory if the polytope is empty</li></ul><p><strong>Output</strong></p><p>A <code>VRep</code> polyhedron.</p><p><strong>Notes</strong></p><p>The <em>relative dimension</em> (or just <em>dimension</em>) refers to the dimension of the set relative to itself, independently of the ambient dimension. For example, a point has (relative) dimension zero, and a line segment has (relative) dimension one.</p><p>In this library, <code>LazySets.dim</code> always returns the ambient dimension of the set, such that a line segment in two dimensions has dimension two. However, <code>Polyhedra.dim</code> will assign a dimension equal to one to a line segment because it uses a different convention.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolytope.jl#L478-L508">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},VPolytope{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},VPolytope{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, P::VPolytope{N}) where {N&lt;:Real}</code></pre><p>Concrete linear map of a polytope in vertex representation.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>P</code> – polytope in vertex representation</li></ul><p><strong>Output</strong></p><p>A polytope in vertex representation.</p><p><strong>Algorithm</strong></p><p>The linear map <span>$M$</span> is applied to each vertex of the given set <span>$P$</span>, obtaining a polytope in V-representation. The output type is again a <code>VPolytope</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/VPolytope.jl#L222-L240">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.isbounded-Tuple{AbstractPolytope}"><code>isbounded</code></a></li><li><a href="../interfaces/#Base.isempty-Tuple{AbstractPolytope}"><code>isempty</code></a></li><li><a href="../interfaces/#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>singleton_list</code></a></li><li><a href="../interfaces/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractPolyhedron{N}}} where N&lt;:Real"><code>linear_map</code></a></li></ul><h2><a class="nav-anchor" id="Polynomial-Zonotopes-1" href="#Polynomial-Zonotopes-1">Polynomial Zonotopes</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.PolynomialZonotope" href="#LazySets.PolynomialZonotope"><code>LazySets.PolynomialZonotope</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PolynomialZonotope{N}</code></pre><p>Type that represents a polynomial zonotope.</p><p><strong>Fields</strong></p><ul><li><code>c</code>  – starting point</li><li><code>E</code>  – matrix of multi-indexed generators such that <em>all</em> indices have the same value</li><li><code>F</code>  – matrix of multi-indexed generators such that <em>not all</em> indices have the same value</li><li><code>G</code>  – matrix of single-indexed generators</li></ul><p><strong>Notes</strong></p><p>Polynomial zonotopes were introduced by M. Althoff in [1] and have been applied as a non-convex set representation in the reachability problem of nonlinear ODEs. </p><p>Mathematically, a polynomial zonotope is defined as the tuple <span>$(c, E, F, G)$</span>, where:</p><ul><li><p><span>$c ∈ \mathbb{R}^n$</span> is the starting point (in some particular cases it corresponds to the center of a usual zonotope),</p></li><li><p><span>$E = [E^{[1]} ⋯ E^{[η]}]$</span> is an <span>$n × p × η(η+1)/2$</span> matrix with column-blocks</p></li></ul><div>\[E^{[i]} = [f^{([i], 1, 1, …, 1)} ⋯ f^{([i], p, p, …, p)}], \qquad i = 1,…, η\]</div><p>called the matrix of <em>multi-indexed generators with equal indices</em>, where each <span>$f^{([i], k_1, k_2, …, k_i)}$</span> is an <span>$n$</span>-vector,</p><ul><li><span>$F = [F^{[2]} ⋯ F^{[η]}]$</span> is a matrix with column-blocks</li></ul><div>\[F^{[i]} = [f^{([i], 1, 1, …, 1, 2)} f^{([i], 1, 1, …, 1, 3)} ⋯ f^{([i], 1, 1, …, 1, p)} \\
f^{([i], 1, 1, …, 2, 2)} f^{([i], 1, 1, …, 2, 3)} ⋯ f^{([i], 1, 1, …, 2, p)} \\
f^{([i], 1, 1, …, 3, 3)} ⋯], \qquad i = 1,…, η\]</div><p>called the matrix of <em>multi-indexed generators with unequal indices</em> (or, more accurately, not-all-equal indices), where each <span>$f^{([i], k_1, k_2, …, k_i)}$</span> is an <span>$n$</span>-vector,</p><ul><li><span>$G = [G^{[1]} ⋯ G^{[q]}]$</span> is an <span>$n × q$</span> matrix with columns</li></ul><div>\[G^{[i]} = g^{(i)}, \qquad i = 1,…, q\]</div><p>called the matrix of <em>single-indexed generators</em>, where each <span>$g^{(i)}$</span> is an <span>$n$</span>-vector.</p><p>The polynomial zonotope <span>$(c, E, F, G)$</span> defines the set:</p><div>\[\mathcal{PZ} = \left\{ c + ∑_{j=1}^p β_j f^{([1], j)} + ∑_{j=1}^p ∑_{k=j}^p β_j β_k f^{([2], j, k)} + \\
+ … + ∑_{j=1}^p ∑_{k=j}^p ⋯ ∑_{m=ℓ}^p β_j β_k ⋯ β_m f^{([η], j, k, …, m)} + \\
+ ∑_{i=1}^q γ_i g^{(i)}, \qquad β_i, γ_i ∈ [-1, 1] \right\},\]</div><p>where the number of factors in the final product, <span>$β_j β_k ⋯ β_m$</span>, corresponds to the polynomial order <span>$η$</span>.</p><p>[1] M. Althoff in <em>Reachability analysis of nonlinear systems using conservative     polynomialization and non-convex sets</em>, Hybrid Systems: Computation and     Control, 2013, pp. 173–182.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/PolynomialZonotope.jl#L8-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{PolynomialZonotope}" href="#LazySets.dim-Tuple{PolynomialZonotope}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(pz::PolynomialZonotope)::Int</code></pre><p>Return the ambient dimension of a polynomial zonotope.</p><p><strong>Input</strong></p><ul><li><code>pz</code> – polynomial zonotope</li></ul><p><strong>Output</strong></p><p>An integer representing the ambient dimension of the polynomial zonotope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/PolynomialZonotope.jl#L96-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},PolynomialZonotope{N}}} where N" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},PolynomialZonotope{N}}} where N"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, pz::PolynomialZonotope{N})::AbstractVector{N} where {N}</code></pre><p>Return the support vector of a polynomial zonotope along direction <code>d</code>.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>pz</code> – polynomial zonotope</li></ul><p><strong>Output</strong></p><p>Vector representing the support vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/PolynomialZonotope.jl#L111-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},PolynomialZonotope{N}}} where N" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},PolynomialZonotope{N}}} where N"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, pz::PolynomialZonotope{N})::AbstractVector{N} where {N}</code></pre><p>Return the support function of a polynomial zonotope along direction <code>d</code>.</p><p><strong>Input</strong></p><ul><li><code>d</code>  – direction</li><li><code>pz</code> – polynomial zonotope</li></ul><p><strong>Output</strong></p><p>Value of the support function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/PolynomialZonotope.jl#L129-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.polynomial_order-Tuple{PolynomialZonotope}" href="#LazySets.polynomial_order-Tuple{PolynomialZonotope}"><code>LazySets.polynomial_order</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">polynomial_order(pz::PolynomialZonotope)::Int</code></pre><p>Polynomial order of a polynomial zonotope.</p><p><strong>Input</strong></p><ul><li><code>pz</code> – polynomial zonotope</li></ul><p><strong>Output</strong></p><p>The polynomial order, defined as the maximal power of the scale factors <span>$β_i$</span>. Usually denoted <span>$η$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/PolynomialZonotope.jl#L147-L160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.order-Tuple{PolynomialZonotope}" href="#LazySets.order-Tuple{PolynomialZonotope}"><code>LazySets.order</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">order(pz::PolynomialZonotope)::Rational{Int}</code></pre><p>Order of a polynomial zonotope.</p><p><strong>Input</strong></p><ul><li><code>pz</code> – polynomial zonotope</li></ul><p><strong>Output</strong></p><p>The order, a rational number defined as the total number of generators divided by the ambient dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/PolynomialZonotope.jl#L163-L176">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Tuple{Array{T,2} where T,PolynomialZonotope}" href="#LazySets.linear_map-Tuple{Array{T,2} where T,PolynomialZonotope}"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::Matrix, pz::PolynomialZonotope)</code></pre><p>Return the linear map of a polynomial zonotope.</p><p><strong>Input</strong></p><ul><li><code>M</code>  – matrix</li><li><code>pz</code> – polynomial zonotope</li></ul><p><strong>Output</strong></p><p>Polynomial zonotope such that its starting point and generators are those of <code>pz</code> multiplied by the matrix <code>M</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/PolynomialZonotope.jl#L186-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.scale-Tuple{Number,PolynomialZonotope}" href="#LazySets.scale-Tuple{Number,PolynomialZonotope}"><code>LazySets.scale</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">scale(α::Number, pz::PolynomialZonotope)</code></pre><p>Return a polynomial zonotope modified by a scale factor.</p><p><strong>Input</strong></p><ul><li><code>α</code>  – polynomial zonotope</li><li><code>pz</code> – polynomial zonotope</li></ul><p><strong>Output</strong></p><p>Polynomial zonotope such that its center and generators are multiples of those of <code>pz</code> by a factor <span>$α$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/PolynomialZonotope.jl#L209-L223">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.minkowski_sum-Tuple{PolynomialZonotope,Zonotope}" href="#LazySets.minkowski_sum-Tuple{PolynomialZonotope,Zonotope}"><code>LazySets.minkowski_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">minkowski_sum(pz::PolynomialZonotope, z::Zonotope)</code></pre><p>Return the Minkowski sum of a polynomial zonotope and a usual zonotope.</p><p><strong>Input</strong></p><ul><li><code>pz</code> – polynomial zonotope</li><li><code>z</code>  – usual zonotope</li></ul><p><strong>Output</strong></p><p>Polynomial zonotope such that its center is the sum of the centers of <code>pz</code> and <code>z</code> and its generators is the matrix that results by concatenating them.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/PolynomialZonotope.jl#L232-L246">source</a></section><h2><a class="nav-anchor" id="Singleton-1" href="#Singleton-1">Singleton</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Singleton" href="#LazySets.Singleton"><code>LazySets.Singleton</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Singleton{N&lt;:Real, VN&lt;:AbstractVector{N}} &lt;: AbstractSingleton{N}</code></pre><p>Type that represents a singleton, that is, a set with a unique element.</p><p><strong>Fields</strong></p><ul><li><code>element</code> – the only element of the set</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Singleton.jl#L5-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{Singleton}}" href="#Base.rand-Tuple{Type{Singleton}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{Singleton}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::Singleton{N}</code></pre><p>Create a random singleton.</p><p><strong>Input</strong></p><ul><li><code>Singleton</code> – type for dispatch</li><li><code>N</code>         – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>       – (optional, default: 2) dimension</li><li><code>rng</code>       – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>      – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A random singleton.</p><p><strong>Algorithm</strong></p><p>The element is a normally distributed vector with entries of mean 0 and standard deviation 1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Singleton.jl#L61-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.element-Union{Tuple{Singleton{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real" href="#LazySets.element-Union{Tuple{Singleton{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N&lt;:Real"><code>LazySets.element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">element(S::Singleton{N}) where {N&lt;:Real}</code></pre><p>Return the element of a singleton.</p><p><strong>Input</strong></p><ul><li><code>S</code> – singleton</li></ul><p><strong>Output</strong></p><p>The element of the singleton.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Singleton.jl#L22-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.element-Union{Tuple{N}, Tuple{Singleton{N,VN} where VN&lt;:AbstractArray{N,1},Int64}} where N&lt;:Real" href="#LazySets.element-Union{Tuple{N}, Tuple{Singleton{N,VN} where VN&lt;:AbstractArray{N,1},Int64}} where N&lt;:Real"><code>LazySets.element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">element(S::Singleton{N}, i::Int)::N where {N&lt;:Real}</code></pre><p>Return the i-th entry of the element of a singleton.</p><p><strong>Input</strong></p><ul><li><code>S</code> – singleton</li><li><code>i</code> – dimension</li></ul><p><strong>Output</strong></p><p>The i-th entry of the element of the singleton.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Singleton.jl#L39-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{Singleton{N,VN} where VN&lt;:AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{N}, Tuple{Singleton{N,VN} where VN&lt;:AbstractArray{N,1},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(S::Singleton{N}, v::AbstractVector{N}) where {N&lt;:Real}</code></pre><p>Translate (i.e., shift) a singleton by a given vector.</p><p><strong>Input</strong></p><ul><li><code>S</code> – singleton</li><li><code>v</code> – translation vector</li></ul><p><strong>Output</strong></p><p>A translated singleton.</p><p><strong>Algorithm</strong></p><p>We add the vector to the point in the singleton.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Singleton.jl#L96-L113">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.isbounded-Tuple{AbstractPolytope}"><code>isbounded</code></a></li><li><a href="../interfaces/#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>singleton_list</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractCentrallySymmetricPolytope"><code>AbstractCentrallySymmetricPolytope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}"><code>dim</code></a></li><li><a href="../interfaces/#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}"><code>isempty</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractHyperrectangle"><code>AbstractHyperrectangle</code></a>:</p><ul><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li><li><a href="../interfaces/#LazySets.high-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>high</code></a></li><li><a href="../interfaces/#LazySets.low-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>low</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractSingleton"><code>AbstractSingleton</code></a>:</p><ul><li><a href="../interfaces/#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real"><code>σ</code></a></li><li><a href="../interfaces/#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractSingleton{N}}} where N&lt;:Real"><code>∈</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li><li><a href="../interfaces/#LazySets.center-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>center</code></a></li><li><a href="../interfaces/#LazySets.vertices_list-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>vertices_list</code></a></li><li><a href="../interfaces/#LazySets.radius_hyperrectangle-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>radius_hyperrectangle</code></a></li><li><a href="../interfaces/#LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real"><code>radius_hyperrectangle</code></a></li><li><a href="../interfaces/#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},AbstractSingleton{N}}} where N&lt;:Real"><code>linear_map</code></a></li></ul><h2><a class="nav-anchor" id="Universe-1" href="#Universe-1">Universe</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Universe" href="#LazySets.Universe"><code>LazySets.Universe</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Universe{N&lt;:Real} &lt;: AbstractPolyhedron{N}</code></pre><p>Type that represents the universal set, i.e., the set of all elements.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Universe.jl#L7-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{Universe}" href="#LazySets.dim-Tuple{Universe}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(U::Universe)</code></pre><p>Return the dimension of a universe.</p><p><strong>Input</strong></p><ul><li><code>U</code> – universe</li></ul><p><strong>Output</strong></p><p>The dimension of a universe.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Universe.jl#L61-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Universe{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Universe{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, U::Universe{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a universe.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>U</code> – universe</li></ul><p><strong>Output</strong></p><p>The support function in the given direction.</p><p><strong>Algorithm</strong></p><p>If the direction is all zero, the result is zero. Otherwise, the result is <code>Inf</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Universe.jl#L78-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Universe{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Universe{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, U::Universe{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a universe.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>U</code> – universe</li></ul><p><strong>Output</strong></p><p>A vector with infinity values, except in dimensions where the direction is zero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Universe.jl#L101-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Universe{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Universe{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, U::Universe{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a universe.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>U</code> – universe</li></ul><p><strong>Output</strong></p><p>The output is always <code>true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ∈([1.0, 0.0], Universe(2))
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Universe.jl#L119-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{Universe}}" href="#Base.rand-Tuple{Type{Universe}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{Universe}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::Universe{N}</code></pre><p>Create a universe (note that there is nothing to randomize).</p><p><strong>Input</strong></p><ul><li><code>Universe</code> – type for dispatch</li><li><code>N</code>        – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>      – (optional, default: 2) dimension</li><li><code>rng</code>      – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>     – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>The (only) universe of the given numeric type and dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Universe.jl#L162-L180">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.an_element-Union{Tuple{Universe{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.an_element-Union{Tuple{Universe{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.an_element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">an_element(U::Universe{N}) where {N&lt;:Real}</code></pre><p>Return some element of a universe.</p><p><strong>Input</strong></p><ul><li><code>U</code> – universe</li></ul><p><strong>Output</strong></p><p>The origin.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Universe.jl#L145-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{Universe}" href="#Base.isempty-Tuple{Universe}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isempty(U::Universe)::Bool</code></pre><p>Return if a universe is empty or not.</p><p><strong>Input</strong></p><ul><li><code>U</code> – universe</li></ul><p><strong>Output</strong></p><p><code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Universe.jl#L191-L203">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.isbounded-Tuple{Universe}" href="#LazySets.isbounded-Tuple{Universe}"><code>LazySets.isbounded</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isbounded(U::Universe)::Bool</code></pre><p>Determine whether a universe is bounded.</p><p><strong>Input</strong></p><ul><li><code>S</code> – universe</li></ul><p><strong>Output</strong></p><p><code>false</code> as the universe is unbounded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Universe.jl#L208-L220">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">norm(U::Universe, [p]::Real=Inf)</code></pre><p>Return the norm of a universe. It is the norm of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume that is centered in the origin.</p><p><strong>Input</strong></p><ul><li><code>U</code> – universe</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>An error.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Universe.jl#L225-L240">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius" href="#LazySets.radius"><code>LazySets.radius</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">radius(U::Universe, [p]::Real=Inf)</code></pre><p>Return the radius of a universe. It is the radius of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><code>U</code> – universe</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>An error.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Universe.jl#L245-L260">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.diameter" href="#LazySets.diameter"><code>LazySets.diameter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">diameter(U::Universe, [p]::Real=Inf)</code></pre><p>Return the diameter of a universe. It is the maximum distance between any two elements of the set, or, equivalently, the diameter of the enclosing ball (of the given <span>$p$</span>-norm) of minimal volume with the same center.</p><p><strong>Input</strong></p><ul><li><code>U</code> – universe</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm</li></ul><p><strong>Output</strong></p><p>An error.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Universe.jl#L265-L281">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{Universe{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{Universe{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(U::Universe{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints defining a universe.</p><p><strong>Input</strong></p><ul><li><code>U</code> – universe</li></ul><p><strong>Output</strong></p><p>The empty list of constraints, as the universe is unconstrained.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Universe.jl#L23-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constrained_dimensions-Tuple{Universe}" href="#LazySets.constrained_dimensions-Tuple{Universe}"><code>LazySets.constrained_dimensions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constrained_dimensions(U::Universe)::Vector{Int}</code></pre><p>Return the indices in which a universe is constrained.</p><p><strong>Input</strong></p><ul><li><code>U</code> – universe</li></ul><p><strong>Output</strong></p><p>The empty vector, as the universe is unconstrained in every dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Universe.jl#L40-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{Universe{N},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{N}, Tuple{Universe{N},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(U::Universe{N}, v::AbstractVector{N}) where {N&lt;:Real}</code></pre><p>Translate (i.e., shift) a universe by a given vector.</p><p><strong>Input</strong></p><ul><li><code>U</code> – universe</li><li><code>v</code> – translation vector</li></ul><p><strong>Output</strong></p><p>The universe.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Universe.jl#L286-L299">source</a></section><h2><a class="nav-anchor" id="Zero-set-1" href="#Zero-set-1">Zero set</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ZeroSet" href="#LazySets.ZeroSet"><code>LazySets.ZeroSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ZeroSet{N&lt;:Real} &lt;: AbstractSingleton{N}</code></pre><p>Type that represents the zero set, i.e., the set that only contains the origin.</p><p><strong>Fields</strong></p><ul><li><code>dim</code> – the ambient dimension of this zero set</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/ZeroSet.jl#L7-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{ZeroSet}" href="#LazySets.dim-Tuple{ZeroSet}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dim(Z::ZeroSet)::Int</code></pre><p>Return the ambient dimension of this zero set.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – a zero set, i.e., a set that only contains the origin</li></ul><p><strong>Output</strong></p><p>The ambient dimension of the zero set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/ZeroSet.jl#L66-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ZeroSet{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},ZeroSet{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, Z::ZeroSet{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a zero set.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – a zero set, i.e., a set that only contains the origin</li></ul><p><strong>Output</strong></p><p>The returned value is the origin since it is the only point that belongs to this set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/ZeroSet.jl#L83-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},ZeroSet{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},ZeroSet{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, Z::ZeroSet{N})::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a zero set.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>Z</code> – zero set</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ Z$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Z = ZeroSet(2);

julia&gt; ∈([1.0, 0.0], Z)
false
julia&gt; ∈([0.0, 0.0], Z)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/ZeroSet.jl#L102-L126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{ZeroSet}}" href="#Base.rand-Tuple{Type{ZeroSet}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{ZeroSet}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::ZeroSet{N}</code></pre><p>Create a zero set (note that there is nothing to randomize).</p><p><strong>Input</strong></p><ul><li><code>ZeroSet</code> – type for dispatch</li><li><code>N</code>       – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>     – (optional, default: 2) dimension</li><li><code>rng</code>     – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>    – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>The (only) zero set of the given numeric type and dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/ZeroSet.jl#L134-L152">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.element-Union{Tuple{ZeroSet{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.element-Union{Tuple{ZeroSet{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">element(S::ZeroSet{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the element of a zero set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – zero set</li></ul><p><strong>Output</strong></p><p>The element of the zero set, i.e., a zero vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/ZeroSet.jl#L27-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.element-Union{Tuple{N}, Tuple{ZeroSet{N},Int64}} where N&lt;:Real" href="#LazySets.element-Union{Tuple{N}, Tuple{ZeroSet{N},Int64}} where N&lt;:Real"><code>LazySets.element</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">element(S::ZeroSet{N}, ::Int)::N where {N&lt;:Real}</code></pre><p>Return the i-th entry of the element of a zero set.</p><p><strong>Input</strong></p><ul><li><code>S</code> – zero set</li><li><code>i</code> – dimension</li></ul><p><strong>Output</strong></p><p>The i-th entry of the element of the zero set, i.e., 0.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/ZeroSet.jl#L44-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},ZeroSet{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},ZeroSet{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, Z::ZeroSet{N}) where {N&lt;:Real}</code></pre><p>Concrete linear map of a zero set.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>Z</code> – zero set</li></ul><p><strong>Output</strong></p><p>The zero set whose dimension matches the output dimension of the given matrix.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/ZeroSet.jl#L163-L176">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{ZeroSet{N},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{N}, Tuple{ZeroSet{N},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(Z::ZeroSet{N}, v::AbstractVector{N}) where {N&lt;:Real}</code></pre><p>Translate (i.e., shift) a zero set by a given vector.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zero set</li><li><code>v</code> – translation vector</li></ul><p><strong>Output</strong></p><p>A singleton containing the vector <code>v</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/ZeroSet.jl#L184-L197">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.isbounded-Tuple{AbstractPolytope}"><code>isbounded</code></a></li><li><a href="../interfaces/#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>singleton_list</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractCentrallySymmetricPolytope"><code>AbstractCentrallySymmetricPolytope</code></a>:</p><ul><li><a href="../interfaces/#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}"><code>isempty</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractHyperrectangle"><code>AbstractHyperrectangle</code></a>:</p><ul><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li><li><a href="../interfaces/#LazySets.high-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>high</code></a></li><li><a href="../interfaces/#LazySets.low-Union{Tuple{AbstractHyperrectangle{N}}, Tuple{N}} where N&lt;:Real"><code>low</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractSingleton"><code>AbstractSingleton</code></a>:</p><ul><li><a href="../interfaces/#LazySets.radius_hyperrectangle-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>radius_hyperrectangle</code></a></li><li><a href="../interfaces/#LazySets.radius_hyperrectangle-Union{Tuple{N}, Tuple{AbstractSingleton{N},Int64}} where N&lt;:Real"><code>radius_hyperrectangle</code></a></li><li><a href="../interfaces/#LazySets.vertices_list-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>vertices_list</code></a></li><li><a href="../interfaces/#LazySets.center-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>center</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{AbstractSingleton{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><h2><a class="nav-anchor" id="Zonotope-1" href="#Zonotope-1">Zonotope</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Zonotope" href="#LazySets.Zonotope"><code>LazySets.Zonotope</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Zonotope{N&lt;:Real} &lt;: AbstractCentrallySymmetricPolytope{N}</code></pre><p>Type that represents a zonotope.</p><p><strong>Fields</strong></p><ul><li><code>center</code>     – center of the zonotope</li><li><code>generators</code> – matrix; each column is a generator of the zonotope</li></ul><p><strong>Notes</strong></p><p>Mathematically, a zonotope is defined as the set</p><div>\[Z = \left\{ c + ∑_{i=1}^p ξ_i g_i,~~ ξ_i \in [-1, 1]~~ ∀ i = 1,…, p \right\},\]</div><p>where <span>$c \in \mathbb{R}^n$</span> is its <em>center</em> and <span>$\{g_i\}_{i=1}^p$</span>, <span>$g_i \in \mathbb{R}^n$</span>, is the set of <em>generators</em>. This characterization defines a zonotope as the finite Minkowski sum of line segments. Zonotopes can be equivalently described as the image of a unit infinity-norm ball in <span>$\mathbb{R}^n$</span> by an affine transformation.</p><ul><li><p><code>Zonotope(center::AbstractVector{N},           generators::AbstractMatrix{N}) where {N&lt;:Real}</code></p></li><li><p><code>Zonotope(center::AbstractVector{N},           generators_list::AbstractVector{VN}          ) where {N&lt;:Real, VN&lt;:AbstractVector{N}}</code></p></li></ul><p>The optional argument <code>remove_zero_generators</code> controls whether we remove zero columns from the <code>generators</code> matrix. This option is active by default.</p><p><strong>Examples</strong></p><p>A two-dimensional zonotope with given center and set of generators:</p><pre><code class="language-julia-repl">julia&gt; Z = Zonotope([1.0, 0.0], [0.1 0.0; 0.0 0.1])
Zonotope{Float64}([1.0, 0.0], [0.1 0.0; 0.0 0.1])
julia&gt; dim(Z)
2</code></pre><p>Compute its vertices:</p><pre><code class="language-julia-repl">julia&gt; vertices_list(Z)
4-element Array{Array{Float64,1},1}:
 [1.1, 0.1]
 [0.9, 0.1]
 [1.1, -0.1]
 [0.9, -0.1]</code></pre><p>Evaluate the support vector in a given direction:</p><pre><code class="language-julia-repl">julia&gt; σ([1., 1.], Z)
2-element Array{Float64,1}:
 1.1
 0.1</code></pre><p>Alternative constructor: A zonotope in two dimensions with three generators:</p><pre><code class="language-julia-repl">julia&gt; Z = Zonotope(ones(2), [[1., 0.], [0., 1.], [1., 1.]])
Zonotope{Float64}([1.0, 1.0], [1.0 0.0 1.0; 0.0 1.0 1.0])
julia&gt; Z.generators
2×3 Array{Float64,2}:
 1.0  0.0  1.0
 0.0  1.0  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Zonotope.jl#L15-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Zonotope{N}}} where N&lt;:Real" href="#LazySets.ρ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Zonotope{N}}} where N&lt;:Real"><code>LazySets.ρ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ρ(d::AbstractVector{N}, Z::Zonotope{N}) where {N&lt;:Real}</code></pre><p>Return the support function of a zonotope in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>Z</code> – zonotope</li></ul><p><strong>Output</strong></p><p>The support function of the zonotope in the given direction.</p><p><strong>Algorithm</strong></p><p>The support value is <span>$cᵀ d + ‖Gᵀ d‖₁$</span> where <span>$c$</span> is the center and <span>$G$</span> is the generator matrix of <code>Z</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Zonotope.jl#L193-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Zonotope{N}}} where N&lt;:Real" href="#LazySets.σ-Union{Tuple{N}, Tuple{AbstractArray{N,1},Zonotope{N}}} where N&lt;:Real"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">σ(d::AbstractVector{N}, Z::Zonotope{N}) where {N&lt;:Real}</code></pre><p>Return the support vector of a zonotope in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>Z</code> – zonotope</li></ul><p><strong>Output</strong></p><p>Support vector in the given direction. If the direction has norm zero, the vertex with <span>$ξ_i = 1 \ \ ∀ i = 1,…, p$</span> is returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Zonotope.jl#L217-L232">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Zonotope{N}}} where N&lt;:Real" href="#Base.:∈-Union{Tuple{N}, Tuple{AbstractArray{N,1},Zonotope{N}}} where N&lt;:Real"><code>Base.:∈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">∈(x::AbstractVector{N}, Z::Zonotope{N};
  solver=GLPKSolverLP(method=:Simplex))::Bool where {N&lt;:Real}</code></pre><p>Check whether a given point is contained in a zonotope.</p><p><strong>Input</strong></p><ul><li><code>x</code>      – point/vector</li><li><code>Z</code>      – zonotope</li><li><code>solver</code> – (optional, default: <code>GLPKSolverLP(method=:Simplex)</code>) the backend             used to solve the linear program</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ Z$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Z = Zonotope([1.0, 0.0], [0.1 0.0; 0.0 0.1]);

julia&gt; ∈([1.0, 0.2], Z)
false
julia&gt; ∈([1.0, 0.1], Z)
true</code></pre><p><strong>Algorithm</strong></p><p>The membership problem is computed by stating and solving the following linear program with the simplex method. Let <span>$p$</span> and <span>$n$</span> be the number of generators and ambient dimension, respectively. We consider the minimization of <span>$x_0$</span> in the <span>$p+1$</span>-dimensional space of elements <span>$(x_0, ξ_1, …, ξ_p)$</span> constrained to <span>$0 ≤ x_0 ≤ ∞$</span>, <span>$ξ_i ∈ [-1, 1]$</span> for all <span>$i = 1, …, p$</span>, and such that <span>$x-c = Gξ$</span> holds. If a feasible solution exists, the optimal value <span>$x_0 = 0$</span> is achieved.</p><p><strong>Notes</strong></p><p>This function is parametric in the number type <code>N</code>. For exact arithmetic use an appropriate backend, e.g. <code>solver=GLPKSolverLP(method=:Exact)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Zonotope.jl#L237-L280">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Type{Zonotope}}" href="#Base.rand-Tuple{Type{Zonotope}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(::Type{Zonotope}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )::Zonotope{N}</code></pre><p>Create a random zonotope.</p><p><strong>Input</strong></p><ul><li><code>Zonotope</code>       – type for dispatch</li><li><code>N</code>              – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>            – (optional, default: 2) dimension</li><li><code>rng</code>            – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>           – (optional, default: <code>nothing</code>) seed for reseeding</li><li><code>num_generators</code> – (optional, default: <code>-1</code>) number of generators of the                     zonotope (see comment below)</li></ul><p><strong>Output</strong></p><p>A random zonotope.</p><p><strong>Algorithm</strong></p><p>All numbers are normally distributed with mean 0 and standard deviation 1.</p><p>The number of generators can be controlled with the argument <code>num_generators</code>. For a negative value we choose a random number in the range <code>dim:2*dim</code> (except if <code>dim == 1</code>, in which case we only create a single generator).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Zonotope.jl#L298-L326">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{Zonotope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.vertices_list-Union{Tuple{Zonotope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vertices_list(Z::Zonotope{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotope</li></ul><p><strong>Output</strong></p><p>List of vertices as a vector of vectors.</p><p><strong>Algorithm</strong></p><p>If the zonotope has <span>$p$</span> generators, each of the <span>$2^p$</span> vertices is computed by taking the sum of the center and a linear combination of generators, where the combination factors are <span>$ξ_i ∈ \{-1, 1\}$</span>.</p><p><strong>Notes</strong></p><p>For high dimensions, it would be preferable to develop a <code>vertex_iterator</code> approach.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Zonotope.jl#L153-L176">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{Zonotope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.constraints_list-Union{Tuple{Zonotope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(P::Zonotope{N}) where {N&lt;:Real}</code></pre><p>Return the list of constraints defining a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotope</li></ul><p><strong>Output</strong></p><p>The list of constraints of the zonotope.</p><p><strong>Algorithm</strong></p><p>This is the (inefficient) fallback implementation for rational numbers. It first computes the vertices and then converts the corresponding polytope to constraint representation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Zonotope.jl#L551-L569">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{Zonotope{N}}, Tuple{N}} where N&lt;:AbstractFloat" href="#LazySets.constraints_list-Union{Tuple{Zonotope{N}}, Tuple{N}} where N&lt;:AbstractFloat"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">constraints_list(Z::Zonotope{N}) where {N&lt;:AbstractFloat}</code></pre><p>Return the list of constraints defining a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotope</li></ul><p><strong>Output</strong></p><p>The list of constraints of the zonotope.</p><p><strong>Notes</strong></p><p>The algorithm assumes that no generator is redundant. The result has <span>$2 \binom{p}{n-1}$</span> (with <span>$p$</span> being the number of generators and <span>$n$</span> being the ambient dimension) constraints, which is optimal under this assumption.</p><p>If <span>$p &lt; n$</span>, we fall back to the (slower) computation based on the vertex representation.</p><p><strong>Algorithm</strong></p><p>We follow the algorithm presented in <em>Althoff, Stursberg, Buss: Computing Reachable Sets of Hybrid Systems Using a Combination of Zonotopes and Polytopes. 2009.</em></p><p>The one-dimensional case is not covered by that algorithm; we manually handle this case, assuming that there is only one generator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Zonotope.jl#L574-L605">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.center-Union{Tuple{Zonotope{N}}, Tuple{N}} where N&lt;:Real" href="#LazySets.center-Union{Tuple{Zonotope{N}}, Tuple{N}} where N&lt;:Real"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">center(Z::Zonotope{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the center of a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotope</li></ul><p><strong>Output</strong></p><p>The center of the zonotope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Zonotope.jl#L116-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.order-Tuple{Zonotope}" href="#LazySets.order-Tuple{Zonotope}"><code>LazySets.order</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">order(Z::Zonotope)::Rational</code></pre><p>Return the order of a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotope</li></ul><p><strong>Output</strong></p><p>A rational number representing the order of the zonotope.</p><p><strong>Notes</strong></p><p>The order of a zonotope is defined as the quotient of its number of generators and its dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Zonotope.jl#L347-L364">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.generators-Tuple{Zonotope}" href="#LazySets.generators-Tuple{Zonotope}"><code>LazySets.generators</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>generators(Z::Zonotope)</p><p>Return the generators of a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotope</li></ul><p><strong>Output</strong></p><p>The generators of the zonotope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Zonotope.jl#L133-L145">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.minkowski_sum-Union{Tuple{N}, Tuple{Zonotope{N},Zonotope{N}}} where N&lt;:Real" href="#LazySets.minkowski_sum-Union{Tuple{N}, Tuple{Zonotope{N},Zonotope{N}}} where N&lt;:Real"><code>LazySets.minkowski_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">minkowski_sum(Z1::Zonotope{N}, Z2::Zonotope{N}) where {N&lt;:Real}</code></pre><p>Concrete Minkowski sum of a pair of zonotopes.</p><p><strong>Input</strong></p><ul><li><code>Z1</code> – one zonotope</li><li><code>Z2</code> – another zonotope</li></ul><p><strong>Output</strong></p><p>The zonotope obtained by summing the centers and concatenating the generators of <span>$Z_1$</span> and <span>$Z_2$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Zonotope.jl#L369-L383">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},Zonotope{N}}} where N&lt;:Real" href="#LazySets.linear_map-Union{Tuple{N}, Tuple{AbstractArray{N,2},Zonotope{N}}} where N&lt;:Real"><code>LazySets.linear_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linear_map(M::AbstractMatrix{N}, Z::Zonotope{N}) where {N&lt;:Real}</code></pre><p>Concrete linear map of a zonotope.</p><p><strong>Input</strong></p><ul><li><code>M</code> – matrix</li><li><code>Z</code> – zonotope</li></ul><p><strong>Output</strong></p><p>The zonotope obtained by applying the linear map to the center and generators of <span>$Z$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Zonotope.jl#L388-L402">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.translate-Union{Tuple{N}, Tuple{Zonotope{N},AbstractArray{N,1}}} where N&lt;:Real" href="#LazySets.translate-Union{Tuple{N}, Tuple{Zonotope{N},AbstractArray{N,1}}} where N&lt;:Real"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate(Z::Zonotope{N}, v::AbstractVector{N}; share::Bool=false
         ) where {N&lt;:Real}</code></pre><p>Translate (i.e., shift) a zonotope by a given vector.</p><p><strong>Input</strong></p><ul><li><code>Z</code>     – zonotope</li><li><code>v</code>     – translation vector</li><li><code>share</code> – (optional, default: <code>false</code>) flag for sharing unmodified parts of            the original set representation</li></ul><p><strong>Output</strong></p><p>A translated zonotope.</p><p><strong>Notes</strong></p><p>The generator matrix is shared with the original zonotope if <code>share == true</code>.</p><p><strong>Algorithm</strong></p><p>We add the vector to the center of the zonotope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Zonotope.jl#L651-L675">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.scale-Tuple{Real,Zonotope}" href="#LazySets.scale-Tuple{Real,Zonotope}"><code>LazySets.scale</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">scale(α::Real, Z::Zonotope)</code></pre><p>Concrete scaling of a zonotope.</p><p><strong>Input</strong></p><ul><li><code>α</code> – scalar</li><li><code>Z</code> – zonotope</li></ul><p><strong>Output</strong></p><p>The zonotope obtained by applying the numerical scale to the center and generators of <span>$Z$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Zonotope.jl#L412-L426">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ngens-Tuple{Zonotope}" href="#LazySets.ngens-Tuple{Zonotope}"><code>LazySets.ngens</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ngens(Z::Zonotope)::Int</code></pre><p>Return the number of generators of a zonotope.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotope</li></ul><p><strong>Output</strong></p><p>Integer representing the number of generators.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Zonotope.jl#L433-L445">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.reduce_order-Tuple{Zonotope,Any}" href="#LazySets.reduce_order-Tuple{Zonotope,Any}"><code>LazySets.reduce_order</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">reduce_order(Z::Zonotope, r)::Zonotope</code></pre><p>Reduce the order of a zonotope by overapproximating with a zonotope with less generators.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotope</li><li><code>r</code> – desired order</li></ul><p><strong>Output</strong></p><p>A new zonotope with less generators, if possible.</p><p><strong>Algorithm</strong></p><p>This function implements the algorithm described in A. Girard&#39;s <em>Reachability of Uncertain Linear Systems Using Zonotopes</em>, HSCC. Vol. 5. 2005.</p><p>If the desired order is smaller than one, the zonotope is <em>not</em> reduced.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Zonotope.jl#L448-L469">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.split-Tuple{Zonotope,Int64}" href="#Base.split-Tuple{Zonotope,Int64}"><code>Base.split</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">split(Z::Zonotope, j::Int)</code></pre><p>Return two zonotopes obtained by splitting the given zonotope.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotope</li><li><code>j</code> – index of the generator to be split</li></ul><p><strong>Output</strong></p><p>The zonotope obtained by splitting <code>Z</code> into two zonotopes such that their union is <code>Z</code> and their intersection is possibly non-empty.</p><p><strong>Algorithm</strong></p><p>This function implements [Prop. 3, 1], that we state next. The zonotope <span>$Z = ⟨c, g^{(1, …, p)}⟩$</span> is split into:</p><div>\[Z₁ = ⟨c - \frac{1}{2}g^{(j)}, (g^{(1, …,j-1)}, \frac{1}{2}g^{(j)}, g^{(j+1, …, p)})⟩ \\
Z₂ = ⟨c + \frac{1}{2}g^{(j)}, (g^{(1, …,j-1)}, \frac{1}{2}g^{(j)}, g^{(j+1, …, p)})⟩,\]</div><p>such that <span>$Z₁ ∪ Z₂ = Z$</span> and <span>$Z₁ ∩ Z₂ = Z^*$</span>, where</p><div>\[Z^* = ⟨c, (g^{(1,…,j-1)}, g^{(j+1,…, p)})⟩.\]</div><p>[1] <em>Althoff, M., Stursberg, O., &amp; Buss, M. (2008). Reachability analysis of nonlinear systems with uncertain parameters using conservative linearization. In Proc. of the 47th IEEE Conference on Decision and Control.</em></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/a5545aeed10c2ee91b7f022c2e2a7cf5c8ae05fb/src/Zonotope.jl#L499-L532">source</a></section><p>Inherited from <a href="../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="#LazySets.radius"><code>radius</code></a></li><li><a href="#LazySets.diameter"><code>diameter</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.isbounded-Tuple{AbstractPolytope}"><code>isbounded</code></a></li><li><a href="../interfaces/#LazySets.singleton_list-Union{Tuple{AbstractPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>singleton_list</code></a></li></ul><p>Inherited from <a href="../interfaces/#LazySets.AbstractCentrallySymmetricPolytope"><code>AbstractCentrallySymmetricPolytope</code></a>:</p><ul><li><a href="../interfaces/#LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}"><code>dim</code></a></li><li><a href="../interfaces/#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}"><code>isempty</code></a></li><li><a href="../interfaces/#LazySets.an_element-Union{Tuple{AbstractCentrallySymmetricPolytope{N}}, Tuple{N}} where N&lt;:Real"><code>an_element</code></a></li></ul><footer><hr/><a class="previous" href="../interfaces/"><span class="direction">Previous</span><span class="title">Set Interfaces</span></a><a class="next" href="../operations/"><span class="direction">Next</span><span class="title">Common Set Operations</span></a></footer></article></body></html>
