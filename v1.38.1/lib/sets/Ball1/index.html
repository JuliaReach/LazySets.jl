<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ball1 · LazySets.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">LazySets.jl</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../../man/set_operations/">Operations on Sets</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../interfaces/">Interfaces</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox" checked/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Ball1</a></li><li><a class="tocitem" href="../Ball2/">Ball2</a></li><li><a class="tocitem" href="../BallInf/">BallInf</a></li><li><a class="tocitem" href="../Ballp/">Ballp</a></li><li><a class="tocitem" href="../Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../Interval/">Interval</a></li><li><a class="tocitem" href="../Line2D/">Line2D</a></li><li><a class="tocitem" href="../Line/">Line</a></li><li><a class="tocitem" href="../LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../PolynomialZonotope/">PolynomialZonotope</a></li><li><a class="tocitem" href="../Singleton/">Singleton</a></li><li><a class="tocitem" href="../Universe/">Universe</a></li><li><a class="tocitem" href="../VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../Zonotope/">Zonotope</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lazy_operations/AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../../lazy_operations/Bloating/">Bloating</a></li><li><a class="tocitem" href="../../lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../../lazy_operations/Complement/">Complement</a></li><li><a class="tocitem" href="../../lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../../lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../../lazy_operations/Intersection/">Intersection</a></li><li><a class="tocitem" href="../../lazy_operations/LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../../lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../../lazy_operations/Rectification/">Rectification</a></li><li><a class="tocitem" href="../../lazy_operations/ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../../lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../../lazy_operations/Translation/">Translation</a></li><li><a class="tocitem" href="../../lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><a class="tocitem" href="../../binary_functions/">Concrete Operations</a></li><li><a class="tocitem" href="../../conversion/">Conversions between set representations</a></li><li><a class="tocitem" href="../../comparisons/">Comparisons</a></li><li><a class="tocitem" href="../../approximations/">Approximations</a></li><li><a class="tocitem" href="../../utils/">Utility Functions</a></li><li><a class="tocitem" href="../../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li><a class="is-disabled">Sets</a></li><li class="is-active"><a href>Ball1</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ball1</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/sets/Ball1.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="def_Ball1"><a class="docs-heading-anchor" href="#def_Ball1">Manhattan-norm ball (Ball1)</a><a id="def_Ball1-1"></a><a class="docs-heading-anchor-permalink" href="#def_Ball1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="LazySets.Ball1" href="#LazySets.Ball1"><code>LazySets.Ball1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Ball1{N, VN&lt;:AbstractVector{N}} &lt;: AbstractCentrallySymmetricPolytope{N}</code></pre><p>Type that represents a ball in the 1-norm (also known as the Manhattan norm). The ball is also known as a <a href="https://en.wikipedia.org/wiki/Cross-polytope">cross-polytope</a>.</p><p>It is defined as the set</p><p class="math-container">\[\mathcal{B}_1^n(c, r) = \{ x ∈ \mathbb{R}^n : ∑_{i=1}^n |c_i - x_i| ≤ r \},\]</p><p>where <span>$c ∈ \mathbb{R}^n$</span> is its center and <span>$r ∈ \mathbb{R}_+$</span> its radius.</p><p><strong>Fields</strong></p><ul><li><code>center</code> – center of the ball as a real vector</li><li><code>radius</code> – radius of the ball as a scalar (<span>$≥ 0$</span>)</li></ul><p><strong>Examples</strong></p><p>Unit ball in the 1-norm in the plane:</p><pre><code class="language-julia-repl">julia&gt; B = Ball1(zeros(2), 1.)
Ball1{Float64,Array{Float64,1}}([0.0, 0.0], 1.0)
julia&gt; dim(B)
2</code></pre><p>We evaluate the support vector in the East direction:</p><pre><code class="language-julia-repl">julia&gt; σ([0.,1], B)
2-element Array{Float64,1}:
 0.0
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/Sets/Ball1.jl#L6-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{T,1} where T,Ball1}" href="#LazySets.σ-Tuple{AbstractArray{T,1} where T,Ball1}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">σ(d::AbstractVector, B::Ball1)</code></pre><p>Return the support vector of a ball in the 1-norm in a given direction.</p><p><strong>Input</strong></p><ul><li><code>d</code> – direction</li><li><code>B</code> – ball in the 1-norm</li></ul><p><strong>Output</strong></p><p>Support vector in the given direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/Sets/Ball1.jl#L122-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∈" href="#Base.:∈"><code>Base.:∈</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">∈(x::AbstractVector, B::Ball1, [failfast]::Bool=false)</code></pre><p>Check whether a given point is contained in a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><code>x</code> – point/vector</li><li><code>B</code> – ball in the 1-norm</li><li><code>failfast</code> – (optional, default: <code>false</code>) optimization for negative answer</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <span>$x ∈ B$</span>.</p><p><strong>Notes</strong></p><p>The default behavior (<code>failfast == false</code>) is worst-case optimized, i.e., the implementation is optimistic and first computes (see below) the whole sum before comparing to the radius. In applications where the point is typically far away from the ball, the option <code>failfast == true</code> terminates faster.</p><p><strong>Algorithm</strong></p><p>Let <span>$B$</span> be an <span>$n$</span>-dimensional ball in the 1-norm with radius <span>$r$</span> and let <span>$c_i$</span> and <span>$x_i$</span> be the ball&#39;s center and the vector <span>$x$</span> in dimension <span>$i$</span>, respectively. Then <span>$x ∈ B$</span> iff <span>$∑_{i=1}^n |c_i - x_i| ≤ r$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = Ball1([1., 1.], 1.);

julia&gt; [.5, -.5] ∈ B
false
julia&gt; [.5, 1.5] ∈ B
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/Sets/Ball1.jl#L143-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.vertices_list-Union{Tuple{Ball1{N,VN}}, Tuple{VN}, Tuple{N}} where VN&lt;:(AbstractArray{T,1} where T) where N" href="#LazySets.vertices_list-Union{Tuple{Ball1{N,VN}}, Tuple{VN}, Tuple{N}} where VN&lt;:(AbstractArray{T,1} where T) where N"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertices_list(P::AbstractHPolygon{N};
              apply_convex_hull::Bool=true,
              check_feasibility::Bool=true) where {N}</code></pre><p>Return the list of vertices of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>                 – polygon in constraint representation</li><li><code>apply_convex_hull</code> – (optional, default: <code>true</code>) flag to post-process the                        intersection of constraints with a convex hull</li><li><code>check_feasibility</code> – (optional, default: <code>true</code>) flag to check whether the                        polygon was empty (required for correctness in case of                        empty polygons)</li></ul><p><strong>Output</strong></p><p>List of vertices.</p><p><strong>Algorithm</strong></p><p>We compute each vertex as the intersection of consecutive lines defined by the half-spaces. If <code>check_feasibility</code> is active, we then check if the constraints of the polygon were actually feasible (i.e., they pointed in the <em>right</em> direction). For this we compute the <em>average</em> of all vertices and check membership in each constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/Interfaces/AbstractHPolygon.jl#L108-L136">source</a></section><section><div><pre><code class="language-none">vertices_list(B::Ball1{N, VN}) where {N, VN&lt;:AbstractVector}</code></pre><p>Return the list of vertices of a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the 1-norm</li></ul><p><strong>Output</strong></p><p>A list containing the vertices of the ball in the 1-norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/Sets/Ball1.jl#L84-L96">source</a></section><section><div><pre><code class="language-none">vertices_list(∅::EmptySet{N}) where {N}</code></pre><p>Return the list of vertices of an empty set.</p><p><strong>Input</strong></p><ul><li><code>∅</code> – empty set</li></ul><p><strong>Output</strong></p><p>The empty list of vertices, as the empty set does not contain any vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/Sets/EmptySet.jl#L293-L305">source</a></section><section><div><pre><code class="language-none">vertices_list(P::HPolytope{N};
              [backend]=nothing, [prune]::Bool=true) where {N}</code></pre><p>Return the list of vertices of a polytope in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code>       – polytope in constraint representation</li><li><code>backend</code> – (optional, default: <code>nothing</code>) the polyhedral computations backend</li><li><code>prune</code>   – (optional, default: <code>true</code>) flag to remove redundant vertices</li></ul><p><strong>Output</strong></p><p>List of vertices.</p><p><strong>Algorithm</strong></p><p>If the polytope is two-dimensional, the polytope is converted to a polygon in H-representation and then its <code>vertices_list</code> function is used. This ensures that, by default, the optimized two-dimensional methods are used.</p><p>It is possible to use the <code>Polyhedra</code> backend in two-dimensions as well by passing, e.g. <code>backend=CDDLib.Library()</code>.</p><p>If the polytope is not two-dimensional, the concrete polyhedra manipulation library <code>Polyhedra</code> is used. The actual computation is performed by a given backend; for the default backend used in <code>LazySets</code> see <code>default_polyhedra_backend(P)</code>. For further information on the supported backends see <a href="https://juliapolyhedra.github.io/Polyhedra.jl/">Polyhedra&#39;s documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/Sets/HPolytope.jl#L180-L210">source</a></section><section><div><pre><code class="language-none">vertices_list(cp::CartesianProduct{N}) where {N}</code></pre><p>Return the list of vertices of a (polytopic) Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>cp</code> – Cartesian product</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/LazyOperations/CartesianProduct.jl#L225-L243">source</a></section><section><div><p>vertices_list(cpa::CartesianProductArray{N}) where {N}</p><p>Return the list of vertices of a (polytopic) Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying sets are polytopic. Then the high-dimensional set of vertices is just the Cartesian product of the low-dimensional sets of vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/LazyOperations/CartesianProductArray.jl#L309-L328">source</a></section><section><div><pre><code class="language-none">vertices_list(em::ExponentialMap{N}) where {N}</code></pre><p>Return the list of vertices of a (polytopic) exponential map.</p><p><strong>Input</strong></p><ul><li><code>em</code> – exponential map</li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Algorithm</strong></p><p>We assume that the underlying set <code>X</code> is polytopic. Then the result is just the exponential map applied to the vertices of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/LazyOperations/ExponentialMap.jl#L398-L415">source</a></section><section><div><pre><code class="language-none">vertices_list(ms::MinkowskiSum{N, Z1, Z2}) where {N, Z1&lt;:AbstractZonotope{N}, Z2&lt;:AbstractZonotope{N}}</code></pre><p>Return the list of vertices for the Minkowski sum of two zonotopic sets.</p><p><strong>Input</strong></p><ul><li><code>ms</code> – Minkowski sum of two zonotopic sets</li></ul><p><strong>Output</strong></p><p>The list of vertices of the Minkowski sum of two zonotopic sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/LazyOperations/MinkowskiSum.jl#L258-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.center-Tuple{Ball1}" href="#LazySets.center-Tuple{Ball1}"><code>LazySets.center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">center(B::Ball1)</code></pre><p>Return the center of a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the 1-norm</li></ul><p><strong>Output</strong></p><p>The center of the ball in the 1-norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/Sets/Ball1.jl#L63-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{Type{Ball1}}" href="#Base.rand-Tuple{Type{Ball1}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rand(::Type{Ball1}; [N]::Type{&lt;:Real}=Float64, [dim]::Int=2,
     [rng]::AbstractRNG=GLOBAL_RNG, [seed]::Union{Int, Nothing}=nothing
    )</code></pre><p>Create a random ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><code>Ball1</code> – type for dispatch</li><li><code>N</code>     – (optional, default: <code>Float64</code>) numeric type</li><li><code>dim</code>   – (optional, default: 2) dimension</li><li><code>rng</code>   – (optional, default: <code>GLOBAL_RNG</code>) random number generator</li><li><code>seed</code>  – (optional, default: <code>nothing</code>) seed for reseeding</li></ul><p><strong>Output</strong></p><p>A random ball in the 1-norm.</p><p><strong>Algorithm</strong></p><p>All numbers are normally distributed with mean 0 and standard deviation 1. Additionally, the radius is nonnegative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/Sets/Ball1.jl#L198-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.constraints_list-Union{Tuple{Ball1{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N" href="#LazySets.constraints_list-Union{Tuple{Ball1{N,VN} where VN&lt;:AbstractArray{N,1}}, Tuple{N}} where N"><code>LazySets.constraints_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraints_list(H::AbstractHyperrectangle{N}) where {N}</code></pre><p>Return the list of constraints of an axis-aligned hyperrectangular set.</p><p><strong>Input</strong></p><ul><li><code>H</code> – hyperrectangular set</li></ul><p><strong>Output</strong></p><p>A list of linear constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/Interfaces/AbstractHyperrectangle.jl#L231-L243">source</a></section><section><div><pre><code class="language-none">constraints_list(P::Ball1{N}) where {N}</code></pre><p>Return the list of constraints defining a ball in the 1-norm.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the 1-norm</li></ul><p><strong>Output</strong></p><p>The list of constraints of the ball.</p><p><strong>Algorithm</strong></p><p>The constraints can be defined as <span>$d_i^T (x-c) ≤ r$</span> for all <span>$d_i$</span>, where <span>$d_i$</span> is a vector with elements <span>$1$</span> or <span>$-1$</span> in <span>$n$</span> dimensions. To span all possible <span>$d_i$</span>, the function <code>Iterators.product</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/Sets/Ball1.jl#L234-L252">source</a></section><section><div><pre><code class="language-none">constraints_list(x::Interval{N}) where {N}</code></pre><p>Return the list of constraints of the given interval.</p><p><strong>Input</strong></p><ul><li><code>x</code> – interval</li></ul><p><strong>Output</strong></p><p>The list of constraints of the interval represented as two one-dimensional half-spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/Sets/Interval.jl#L396-L409">source</a></section><section><div><pre><code class="language-none">constraints_list(L::Line{N, VN}) where {N, VN}</code></pre><p>Return the list of constraints of a line.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line</li></ul><p><strong>Output</strong></p><p>A list containing <code>2n-2</code> half-spaces whose intersection is <code>L</code>, where <code>n</code> is the ambient dimension of <code>L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/Sets/Line.jl#L191-L204">source</a></section><section><div><pre><code class="language-none">constraints_list(U::Universe{N}) where {N}</code></pre><p>Return the list of constraints defining a universe.</p><p><strong>Input</strong></p><ul><li><code>U</code> – universe</li></ul><p><strong>Output</strong></p><p>The empty list of constraints, as the universe is unconstrained.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/Sets/Universe.jl#L42-L54">source</a></section><section><div><pre><code class="language-none">constraints_list(P::HParallelotope{N, VN}) where {N, VN}</code></pre><p>Return the list of constraints of the given parallelotope.</p><p><strong>Input</strong></p><ul><li><code>P</code> – parallelotope in constraint representation</li></ul><p><strong>Output</strong></p><p>The list of constraints of <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/Sets/HParallelotope.jl#L289-L301">source</a></section><section><div><p>constraints_list(cpa::CartesianProductArray{N}) where {N}</p><p>Return the list of constraints of a (polyhedral) Cartesian product of a finite number of sets.</p><p><strong>Input</strong></p><ul><li><code>cpa</code> – Cartesian product array</li></ul><p><strong>Output</strong></p><p>A list of constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/LazyOperations/CartesianProductArray.jl#L274-L287">source</a></section><section><div><pre><code class="language-none">constraints_list(ia::IntersectionArray{N}) where {N}</code></pre><p>Return the list of constraints of an intersection of a finite number of (polyhedral) sets.</p><p><strong>Input</strong></p><ul><li><code>ia</code> – intersection of a finite number of (polyhedral) sets</li></ul><p><strong>Output</strong></p><p>The list of constraints of the intersection.</p><p><strong>Notes</strong></p><p>We assume that the underlying sets are polyhedral, i.e., offer a method <code>constraints_list</code>.</p><p><strong>Algorithm</strong></p><p>We create the polyhedron from the <code>constraints_list</code>s of the sets and remove redundant constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/LazyOperations/IntersectionArray.jl#L161-L184">source</a></section><section><div><pre><code class="language-none">constraints_list(rm::ResetMap{N}) where {N}</code></pre><p>Return the list of constraints of a polytopic reset map.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map of a polytope</li></ul><p><strong>Output</strong></p><p>The list of constraints of the reset map.</p><p><strong>Notes</strong></p><p>We assume that the underlying set <code>X</code> is a polytope, i.e., is bounded and offers a method <code>constraints_list(X)</code>.</p><p><strong>Algorithm</strong></p><p>We fall back to <code>constraints_list</code> of a <code>LinearMap</code> of the <code>A</code>-matrix in the affine-map view of a reset map. Each reset dimension <span>$i$</span> is projected to zero, expressed by two constraints for each reset dimension. Then it remains to shift these constraints to the new value.</p><p>For instance, if the dimension <span>$5$</span> was reset to <span>$4$</span>, then there will be constraints <span>$x₅ ≤ 0$</span> and <span>$-x₅ ≤ 0$</span>. We then modify the right-hand side of these constraints to <span>$x₅ ≤ 4$</span> and <span>$-x₅ ≤ -4$</span>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/LazyOperations/ResetMap.jl#L257-L287">source</a></section><section><div><pre><code class="language-none">constraints_list(rm::ResetMap{N, S}) where {N, S&lt;:AbstractHyperrectangle}</code></pre><p>Return the list of constraints of a hyperrectangular reset map.</p><p><strong>Input</strong></p><ul><li><code>rm</code> – reset map of a hyperrectangular set</li></ul><p><strong>Output</strong></p><p>The list of constraints of the reset map.</p><p><strong>Algorithm</strong></p><p>We iterate through all dimensions. If there is a reset, we construct the corresponding (flat) constraints. Otherwise, we construct the corresponding constraints of the underlying set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/LazyOperations/ResetMap.jl#L329-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.translate-Tuple{Ball1,AbstractArray{T,1} where T}" href="#LazySets.translate-Tuple{Ball1,AbstractArray{T,1} where T}"><code>LazySets.translate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">translate(B::Ball1, v::AbstractVector)</code></pre><p>Translate (i.e., shift) a ball in the 1-norm by a given vector.</p><p><strong>Input</strong></p><ul><li><code>B</code> – ball in the 1-norm</li><li><code>v</code> – translation vector</li></ul><p><strong>Output</strong></p><p>A translated ball in the 1-norm.</p><p><strong>Algorithm</strong></p><p>We add the vector to the center of the ball.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/0360f186ca663ae97782dc3463fd3d59a5911372/src/Sets/Ball1.jl#L264-L281">source</a></section></article><p>Inherited from <a href="../../interfaces/#LazySets.LazySet"><code>LazySet</code></a>:</p><ul><li><a href="../../interfaces/#LinearAlgebra.norm"><code>norm</code></a></li><li><a href="../../interfaces/#LazySets.radius"><code>radius</code></a></li><li><a href="../../interfaces/#LazySets.diameter"><code>diameter</code></a></li><li><a href="../../interfaces/#LazySets.singleton_list-Tuple{LazySet}"><code>singleton_list</code></a></li></ul><p>Inherited from <a href="../../interfaces/#LazySets.AbstractPolytope"><code>AbstractPolytope</code></a>:</p><ul><li><a href="../../interfaces/#LazySets.isbounded-Tuple{AbstractPolytope}"><code>isbounded</code></a></li><li><a href="../../interfaces/#LazySets.isuniversal-Union{Tuple{AbstractPolytope{N}}, Tuple{N}, Tuple{AbstractPolytope{N},Bool}} where N"><code>isuniversal</code></a></li></ul><p>Inherited from <a href="../../interfaces/#LazySets.AbstractCentrallySymmetricPolytope"><code>AbstractCentrallySymmetricPolytope</code></a>:</p><ul><li><a href="../../interfaces/#LazySets.dim-Tuple{AbstractCentrallySymmetricPolytope}"><code>dim</code></a></li><li><a href="../../interfaces/#Base.isempty-Tuple{AbstractCentrallySymmetricPolytope}"><code>isempty</code></a></li><li><a href="../../interfaces/#LazySets.an_element-Tuple{AbstractCentrallySymmetricPolytope}"><code>an_element</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../interfaces/">« Interfaces</a><a class="docs-footer-nextpage" href="../Ball2/">Ball2 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 13 January 2021 13:19">Wednesday 13 January 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
