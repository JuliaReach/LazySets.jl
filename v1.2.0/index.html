<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Introduction-1">Introduction</a></li><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#Features-1">Features</a></li><li><a class="toctext" href="#Manual-Outline-1">Manual Outline</a></li><li><a class="toctext" href="#Library-Outline-1">Library Outline</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="man/getting_started.html">Getting Started</a></li><li><a class="toctext" href="man/polyhedral_approximations.html">Polyhedral Approximations</a></li><li><a class="toctext" href="man/decompose_example.html">Decomposing an Affine Map</a></li><li><a class="toctext" href="man/fast_2d_LPs.html">Fast 2D LPs</a></li><li><a class="toctext" href="man/iterative_refinement.html">Iterative Refinement</a></li><li><a class="toctext" href="man/interval_hulls.html">Interval Hulls</a></li><li><a class="toctext" href="man/convex_hulls.html">Convex Hulls</a></li><li><a class="toctext" href="man/set_operations.html">Operations on Sets</a></li><li><a class="toctext" href="man/reach_zonotopes.html">A Reachability Algorithm</a></li><li><a class="toctext" href="man/reach_zonotopes_hybrid.html">A Hybrid Reachability Algorithm</a></li><li><a class="toctext" href="man/concrete_polyhedra.html">Concrete Polyhedra</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="lib/interfaces.html">Set Interfaces</a></li><li><a class="toctext" href="lib/representations.html">Common Set Representations</a></li><li><a class="toctext" href="lib/operations.html">Common Set Operations</a></li><li><a class="toctext" href="lib/conversion.html">Conversion between set representations</a></li><li><a class="toctext" href="lib/binary_functions.html">Binary Functions on Sets</a></li><li><a class="toctext" href="lib/approximations.html">Approximations</a></li><li><a class="toctext" href="lib/utils.html">Utility Functions</a></li></ul></li><li><a class="toctext" href="about.html">About</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="LazySets.jl-1" href="#LazySets.jl-1">LazySets.jl</a></h1><p><code>LazySets</code> is a <a href="http://julialang.org">Julia</a> package for calculus with convex sets.</p><p>The aim is to provide a scalable library for solving complex set-based problems, such as those encountered in <a href="https://en.wikipedia.org/wiki/Differential_inclusion">differential inclusions</a> or reachability analysis techniques in the domain of <a href="https://en.wikipedia.org/wiki/Formal_verification">formal verification</a>. Typically, one is confronted with a set-based recurrence with a given initial set and/or input sets, and for visualization purposes the final result has to be obtained through an adequate projection onto low-dimensions. This library implements types to construct set formulas and methods to efficiently and accurately approximate the projection in low-dimensions.</p><ul><li><a href="index.html#LazySets.jl-1">LazySets.jl</a></li><ul><li><a href="index.html#Introduction-1">Introduction</a></li><li><a href="index.html#Example-1">Example</a></li><li><a href="index.html#Features-1">Features</a></li><li><a href="index.html#Manual-Outline-1">Manual Outline</a></li><li><a href="index.html#Library-Outline-1">Library Outline</a></li></ul></ul><h2><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h2><p>In this package we describe convex sets lazily (i.e., symbolically). This way we provide an exact but abstract representation, in principle for any common convex set class or operation between sets. Concrete information is obtained through evaluating the set in specific directions. More precisely, each concrete subtype <span>$\mathcal{X}$</span> of the abstract type <code>LazySet</code> exports a method to calculate its support vector <span>$\sigma(d, \mathcal{X})$</span> in a given (arbitrary) direction <span>$d \in \mathbb{R}^n$</span>. Representing sets exactly but lazily has the advantage of being able to perform only the required operations on-demand.</p><p>For very long sequences of computations (e.g., set-based recurrences with tens of thousands of elements), it is useful to combine both lazy and concrete representations such as polyhedral approximations. All this is easy to do with <code>LazySets</code>. Moreover, we provide a specialized module for handling Cartesian decomposition of two-dimensional projections. The projection can be taken to the desired precision using an iterative refinement method.</p><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><p>Let <span>$\mathcal{X}_0 \subset \mathbb{R}^{1000}$</span> be the Euclidean ball of center <span>$(1, \ldots, 1)$</span> and radius <span>$0.1$</span> in dimension <span>$n=1000$</span>. Given a real matrix <span>$A \in \mathbb{R}^{1000 \times 1000}$</span>, suppose that we are interested in the equation</p><div>\[\mathcal{Y} = CH(e^{A δ} \mathcal{X}_0 ⊕ δ B\mathcal{U}, \mathcal{X}_0),\]</div><p>where <span>$CH$</span> is the convex hull operator, <span>$⊕$</span> denotes Minkowski sum, <span>$\mathcal{U}$</span> is a ball in the infinity norm centered at zero and radius <span>$1.2$</span>, and <span>$B$</span> is a linear map of the appropriate dimensions. This equation typically arises in the study of discrete approximation models for reachability of continuous systems, see for example <a href="https://github.com/JuliaReach/Reachability.jl/wiki/References#frehse2011spaceex">SpaceEx: Scalable verification of hybrid systems</a>.</p><p>For concreteness, we take <span>$A$</span> to be a random matrix with probability <span>$1\%$</span> of any entry being nonzero. Suppose that the input set <span>$\mathcal{U}$</span> is two-dimensional, and that the linear map <span>$B$</span> is random. Finally, let δ = 0.1. Using <code>LazySets</code>, we can define this problem as follows:</p><pre><code class="language-julia-repl">julia&gt; using LazySets;

julia&gt; A = sprandn(1000, 1000, 0.01);

julia&gt; δ = 0.1;

julia&gt; X0 = Ball2(ones(1000), 0.1);

julia&gt; B = randn(1000, 2);

julia&gt; U = BallInf(zeros(2), 1.2);
</code></pre><p>The <code>@time</code> macro reveals that building <span>$\mathcal{Y}$</span> with <code>LazySets</code> is instantaneous:</p><pre><code class="language-julia-repl">julia&gt; @time Y = CH(SparseMatrixExp(A * δ) * X0 + δ * B * U, X0);
0.000022 seconds (13 allocations: 16.094 KiB)</code></pre><p>By asking for the concrete type of <code>Y</code>, we see that it has a convex hull type, parameterized by the types of its arguments, corresponding to the mathematical formulation:</p><pre><code class="language-julia-repl">julia&gt; typeof(Y)
LazySets.ConvexHull{Float64,LazySets.MinkowskiSum{Float64,LazySets.ExponentialMap{Float64,LazySets.Ball2{Float64}},LazySets.LinearMap{Float64,Float64}},LazySets.Ball2{Float64}}</code></pre><p>Now suppose that we are interested in observing the projection of <span>$\mathcal{Y}$</span> onto the variables number 1 and 500. First we define the <span>$2×1000$</span> projection matrix and apply it to <span>$\mathcal{Y}$</span> as a linear map (i.e., from the left). Second, we use the <code>overapproximate</code> method:</p><pre><code class="language-julia-repl">julia&gt; proj_mat = [[1. zeros(1, 999)]; [zeros(1, 499) 1. zeros(1, 500)]];

julia&gt; @time res = Approximations.overapproximate(proj_mat * Y);
0.064034 seconds (1.12 k allocations: 7.691 MiB)</code></pre><p>We have calculated a box overapproximation of the exact projection onto the <span>$(x_1, x_{500})$</span> plane. Notice that it takes about 0.064 seconds for the whole operation, allocating less than 10MB of RAM. Let us note that if the set operations were done explicitly, this would be much (!) slower. For instance, already the explicit computation of the matrix exponential would have cost 10x more, and allocated around 300MB. For even higher <span>$n$</span>, an evaluation will probably run out of RAM. But this is doable with <code>LazySets</code> because the <em>action</em> of the matrix exponential on the set is only evaluated along the directions of interest. Similar comments apply to the Minkowski sum above.</p><p>We can visualize the result using <code>plot</code>, as shown below (left-most plot).</p><p><img src="assets/example_ch.png" alt="assets/example_ch.png"/></p><p>In the second and third plots, we have used a refined method that allows to specify a prescribed accuracy for the projection (in terms of the <a href="https://en.wikipedia.org/wiki/Hausdorff_distance">Hausdorff distance</a>). For the theoretical background, see <a href="https://github.com/JuliaReach/Reachability.jl/wiki/References#polyhedral-approximations">this reference</a>. It can be passed as a second argument to <code>overapproximate</code>.</p><table><tr><th>Error tol.</th><th>time (s)</th><th>memory (MB)</th></tr><tr><td>∞ (no refinement)</td><td>0.022</td><td>5.27</td></tr><tr><td>1e-1</td><td>0.051</td><td>7.91</td></tr><tr><td>1e-3</td><td>0.17</td><td>30.3</td></tr></table><p>This table shows the runtime and memory consumption for different error tolerances, and the results are shown in three plots of above, from left to right. When passing to a smaller tolerance, the corners connecting edges are more &quot;rounded&quot;, at the expense of computational resources, since more support vectors have to be evaluated.</p><h2><a class="nav-anchor" id="Features-1" href="#Features-1">Features</a></h2><p>The core functionality of <code>LazySets</code> is:</p><ul><li><p>Lazy (i.e., symbolic) types for several classes of convex sets such as balls in different norms, polygons in constraint or vertex representation, zonotopes, special types such as lines and linear constraints, hyperrectangles, and high-dimensional polyhedra.</p></li><li><p>Lazy implementations for most commonly used set operations, e.g., Minkowski sum, Cartesian product, convex hull and interval hull approximations, and linear and exponential maps.</p></li></ul><p>On top of the previous basic type representations and operations, <code>LazySets</code> can be used to:</p><ul><li><p>Efficiently evaluate the support vector of nested lazy sets.</p></li><li><p>Cartesian decomposition of lazy sets using two-dimensional projections.</p></li><li><p>Fast overapproximation of an exact set using a polyhedral approximation, to the desired accuracy.</p></li><li><p>Extensive visualization capabilities through the <a href="http://docs.juliaplots.org/latest/">Plots.jl</a> framework.</p></li></ul><h2><a class="nav-anchor" id="Manual-Outline-1" href="#Manual-Outline-1">Manual Outline</a></h2><ul><li><a href="man/getting_started.html#Getting-Started-1">Getting Started</a></li><ul><li><a href="man/getting_started.html#Setup-1">Setup</a></li><li><a href="man/getting_started.html#Workflow-tips-1">Workflow tips</a></li><li><a href="man/getting_started.html#Updating-1">Updating</a></li></ul><li><a href="man/polyhedral_approximations.html#Polyhedral-Approximations-1">Polyhedral Approximations</a></li><ul><li><a href="man/polyhedral_approximations.html#Preliminaries-1">Preliminaries</a></li><li><a href="man/polyhedral_approximations.html#Support-Function-1">Support Function</a></li><li><a href="man/polyhedral_approximations.html#Support-Vector-1">Support Vector</a></li><li><a href="man/polyhedral_approximations.html#Polyhedral-approximation-of-a-convex-set-1">Polyhedral approximation of a convex set</a></li></ul><li><a href="man/decompose_example.html#Decomposing-an-Affine-Map-1">Decomposing an Affine Map</a></li><ul><li><a href="man/decompose_example.html#Preliminaries:-Polygon,-Linear-Map,-and-Plotting-1">Preliminaries: Polygon, Linear Map, and Plotting</a></li><li><a href="man/decompose_example.html#Cartesian-Decomposition-1">Cartesian Decomposition</a></li><li><a href="man/decompose_example.html#Decomposed-Image-of-a-Linear-Map-1">Decomposed Image of a Linear Map</a></li></ul><li><a href="man/fast_2d_LPs.html#Fast-2D-LPs-1">Fast 2D LPs</a></li><ul><li><a href="man/fast_2d_LPs.html#Introduction-1">Introduction</a></li><li><a href="man/fast_2d_LPs.html#Algorithm-1">Algorithm</a></li></ul><li><a href="man/iterative_refinement.html#Iterative-Refinement-1">Iterative Refinement</a></li><ul><li><a href="man/iterative_refinement.html#Local-approximations-1">Local approximations</a></li><li><a href="man/iterative_refinement.html#Refinement-1">Refinement</a></li><li><a href="man/iterative_refinement.html#Algorithm-1">Algorithm</a></li><li><a href="man/iterative_refinement.html#Example-1">Example</a></li></ul><li><a href="man/interval_hulls.html#Interval-Hulls-1">Interval Hulls</a></li><ul><li><a href="man/interval_hulls.html#Balls-and-Singletons-1">Balls and Singletons</a></li><li><a href="man/interval_hulls.html#Ballinf-approximation-1">Ballinf approximation</a></li><li><a href="man/interval_hulls.html#Interval-hull-approximation-1">Interval hull approximation</a></li><li><a href="man/interval_hulls.html#Symmetric-interval-hull-1">Symmetric interval hull</a></li><li><a href="man/interval_hulls.html#Norm,-radius-and-diameter-1">Norm, radius and diameter</a></li></ul><li><a href="man/convex_hulls.html#Convex-Hulls-1">Convex Hulls</a></li><ul><li><a href="man/convex_hulls.html#Symbolic-convex-hull-1">Symbolic convex hull</a></li><li><a href="man/convex_hulls.html#D-convex-hull-1">2D convex hull</a></li><li><a href="man/convex_hulls.html#Using-static-vectors-1">Using static vectors</a></li></ul><li><a href="man/reach_zonotopes.html#A-Reachability-Algorithm-Using-Zonotopes-1">A Reachability Algorithm Using Zonotopes</a></li><ul><li><a href="man/reach_zonotopes.html#Introduction-1">Introduction</a></li><li><a href="man/reach_zonotopes.html#Algorithm-1">Algorithm</a></li><li><a href="man/reach_zonotopes.html#Projection-1">Projection</a></li><li><a href="man/reach_zonotopes.html#Example-1-1">Example 1</a></li><li><a href="man/reach_zonotopes.html#Example-2-1">Example 2</a></li></ul><li><a href="man/reach_zonotopes_hybrid.html#A-Hybrid-Reachability-Algorithm-Using-Zonotopes-1">A Hybrid Reachability Algorithm Using Zonotopes</a></li><ul><li><a href="man/reach_zonotopes_hybrid.html#Introduction-1">Introduction</a></li><li><a href="man/reach_zonotopes_hybrid.html#Hybrid-algorithm-1">Hybrid algorithm</a></li><li><a href="man/reach_zonotopes_hybrid.html#Example-1">Example</a></li></ul><li><a href="man/concrete_polyhedra.html#Concrete-Polyhedra-1">Concrete Polyhedra</a></li><ul><li><a href="man/concrete_polyhedra.html#Creating-polyhedra-1">Creating polyhedra</a></li><li><a href="man/concrete_polyhedra.html#Methods-1">Methods</a></li><li><a href="man/concrete_polyhedra.html#Projections-1">Projections</a></li></ul></ul><h2><a class="nav-anchor" id="Library-Outline-1" href="#Library-Outline-1">Library Outline</a></h2><ul><li><a href="lib/interfaces.html#Set-Interfaces-1">Set Interfaces</a></li><ul><li><a href="lib/interfaces.html#LazySet-1">LazySet</a></li><li><a href="lib/interfaces.html#Point-symmetric-set-1">Point symmetric set</a></li><li><a href="lib/interfaces.html#Polytope-1">Polytope</a></li></ul><li><a href="lib/representations.html#Common-Set-Representations-1">Common Set Representations</a></li><ul><li><a href="lib/representations.html#Balls-1">Balls</a></li><li><a href="lib/representations.html#Ellipsoid-1">Ellipsoid</a></li><li><a href="lib/representations.html#EmptySet-1">EmptySet</a></li><li><a href="lib/representations.html#Half-Space-1">Half-Space</a></li><li><a href="lib/representations.html#Hyperplane-1">Hyperplane</a></li><li><a href="lib/representations.html#Hyperrectangles-1">Hyperrectangles</a></li><li><a href="lib/representations.html#Intervals-1">Intervals</a></li><li><a href="lib/representations.html#Line-1">Line</a></li><li><a href="lib/representations.html#Line-segment-1">Line segment</a></li><li><a href="lib/representations.html#Polygons-1">Polygons</a></li><li><a href="lib/representations.html#Polytopes-1">Polytopes</a></li><li><a href="lib/representations.html#Singletons-1">Singletons</a></li><li><a href="lib/representations.html#ZeroSet-1">ZeroSet</a></li><li><a href="lib/representations.html#Zonotopes-1">Zonotopes</a></li></ul><li><a href="lib/operations.html#Common-Set-Operations-1">Common Set Operations</a></li><ul><li><a href="lib/operations.html#Cartesian-Product-1">Cartesian Product</a></li><li><a href="lib/operations.html#Convex-Hull-1">Convex Hull</a></li><li><a href="lib/operations.html#Intersection-1">Intersection</a></li><li><a href="lib/operations.html#Minkowski-Sum-1">Minkowski Sum</a></li><li><a href="lib/operations.html#Maps-1">Maps</a></li><li><a href="lib/operations.html#Symmetric-Interval-Hull-1">Symmetric Interval Hull</a></li></ul><li><a href="lib/conversion.html#Conversion-between-set-representations-1">Conversion between set representations</a></li><li><a href="lib/approximations.html#Approximations-1">Approximations</a></li><ul><li><a href="lib/approximations.html#Cartesian-Decomposition-1">Cartesian Decomposition</a></li><li><a href="lib/approximations.html#Overapproximations-1">Overapproximations</a></li><li><a href="lib/approximations.html#Box-Approximations-1">Box Approximations</a></li><li><a href="lib/approximations.html#Iterative-refinement-1">Iterative refinement</a></li></ul><li><a href="lib/utils.html#Utility-functions-1">Utility functions</a></li><ul><li><a href="lib/utils.html#Helper-functions-for-internal-use-only-1">Helper functions for internal use only</a></li></ul></ul><footer><hr/><a class="next" href="man/getting_started.html"><span class="direction">Next</span><span class="title">Getting Started</span></a></footer></article></body></html>
