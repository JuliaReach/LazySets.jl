<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Approximations · LazySets.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="LazySets.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">LazySets.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../man/convex_sets/">Introduction to Convex Sets</a></li><li><a class="tocitem" href="../../man/polyhedral_approximations/">Polyhedral Approximations</a></li><li><a class="tocitem" href="../../man/decompose_example/">Decomposing an Affine Map</a></li><li><a class="tocitem" href="../../man/fast_2d_LPs/">Fast 2D LPs</a></li><li><a class="tocitem" href="../../man/iterative_refinement/">Iterative Refinement</a></li><li><a class="tocitem" href="../../man/interval_hulls/">Interval Hulls</a></li><li><a class="tocitem" href="../../man/convex_hulls/">Convex Hulls</a></li><li><a class="tocitem" href="../../man/set_operations/">Operations on Sets</a></li><li><a class="tocitem" href="../../man/reach_zonotopes/">A Reachability Algorithm</a></li><li><a class="tocitem" href="../../man/reach_zonotopes_hybrid/">A Hybrid Reachability Algorithm</a></li><li><a class="tocitem" href="../../man/concrete_polyhedra/">Concrete Polyhedra</a></li><li><a class="tocitem" href="../../man/parallel_approximations/">Parallel Approximations</a></li><li><a class="tocitem" href="../../man/lazy_intersections/">Lazy Intersections</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sets/Ball1/">Ball1</a></li><li><a class="tocitem" href="../sets/Ball2/">Ball2</a></li><li><a class="tocitem" href="../sets/BallInf/">BallInf</a></li><li><a class="tocitem" href="../sets/Ballp/">Ballp</a></li><li><a class="tocitem" href="../sets/Ellipsoid/">Ellipsoid</a></li><li><a class="tocitem" href="../sets/EmptySet/">EmptySet</a></li><li><a class="tocitem" href="../sets/HalfSpace/">HalfSpace</a></li><li><a class="tocitem" href="../sets/HPolygon/">HPolygon</a></li><li><a class="tocitem" href="../sets/HPolygonOpt/">HPolygonOpt</a></li><li><a class="tocitem" href="../sets/HPolyhedron/">HPolyhedron</a></li><li><a class="tocitem" href="../sets/HPolytope/">HPolytope</a></li><li><a class="tocitem" href="../sets/Hyperplane/">Hyperplane</a></li><li><a class="tocitem" href="../sets/Hyperrectangle/">Hyperrectangle</a></li><li><a class="tocitem" href="../sets/Interval/">Interval</a></li><li><a class="tocitem" href="../sets/Line2D/">Line2D</a></li><li><a class="tocitem" href="../sets/Line/">Line</a></li><li><a class="tocitem" href="../sets/LineSegment/">LineSegment</a></li><li><a class="tocitem" href="../sets/PolynomialZonotope/">PolynomialZonotope</a></li><li><a class="tocitem" href="../sets/Singleton/">Singleton</a></li><li><a class="tocitem" href="../sets/Universe/">Universe</a></li><li><a class="tocitem" href="../sets/VPolygon/">VPolygon</a></li><li><a class="tocitem" href="../sets/VPolytope/">VPolytope</a></li><li><a class="tocitem" href="../sets/ZeroSet/">ZeroSet</a></li><li><a class="tocitem" href="../sets/Zonotope/">Zonotope</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Lazy Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lazy_operations/AffineMap/">AffineMap</a></li><li><a class="tocitem" href="../lazy_operations/Bloating/">Bloating</a></li><li><a class="tocitem" href="../lazy_operations/CartesianProduct/">CartesianProduct</a></li><li><a class="tocitem" href="../lazy_operations/Complement/">Complement</a></li><li><a class="tocitem" href="../lazy_operations/ConvexHull/">ConvexHull</a></li><li><a class="tocitem" href="../lazy_operations/ExponentialMap/">ExponentialMap</a></li><li><a class="tocitem" href="../lazy_operations/Intersection/">Intersection</a></li><li><a class="tocitem" href="../lazy_operations/LinearMap/">LinearMap</a></li><li><a class="tocitem" href="../lazy_operations/MinkowskiSum/">MinkowskiSum</a></li><li><a class="tocitem" href="../lazy_operations/Rectification/">Rectification</a></li><li><a class="tocitem" href="../lazy_operations/ResetMap/">ResetMap</a></li><li><a class="tocitem" href="../lazy_operations/SymmetricIntervalHull/">SymmetricIntervalHull</a></li><li><a class="tocitem" href="../lazy_operations/Translation/">Translation</a></li><li><a class="tocitem" href="../lazy_operations/UnionSet/">UnionSet</a></li></ul></li><li><a class="tocitem" href="../binary_functions/">Concrete Operations</a></li><li><a class="tocitem" href="../conversion/">Conversions between set representations</a></li><li><a class="tocitem" href="../comparisons/">Comparisons</a></li><li class="is-active"><a class="tocitem" href>Approximations</a><ul class="internal"><li><a class="tocitem" href="#Cartesian-Decomposition"><span>Cartesian Decomposition</span></a></li><li><a class="tocitem" href="#Overapproximations"><span>Overapproximations</span></a></li><li><a class="tocitem" href="#Underapproximations"><span>Underapproximations</span></a></li><li><a class="tocitem" href="#Approximations-2"><span>Approximations</span></a></li><li><a class="tocitem" href="#Box-Approximations"><span>Box Approximations</span></a></li><li><a class="tocitem" href="#Iterative-refinement"><span>Iterative refinement</span></a></li><li><a class="tocitem" href="#Template-directions"><span>Template directions</span></a></li><li><a class="tocitem" href="#Distances"><span>Distances</span></a></li></ul></li><li><a class="tocitem" href="../utils/">Utility Functions</a></li><li><a class="tocitem" href="../parallel/">Parallel</a></li></ul></li><li><a class="tocitem" href="../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Approximations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Approximations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/approximations.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Approximations"><a class="docs-heading-anchor" href="#Approximations">Approximations</a><a id="Approximations-1"></a><a class="docs-heading-anchor-permalink" href="#Approximations" title="Permalink"></a></h1><p>This section of the manual describes the Cartesian decomposition algorithms and the approximation of high-dimensional convex sets using projections.</p><ul><li><a href="#Approximations">Approximations</a></li><ul><li><a href="#Cartesian-Decomposition">Cartesian Decomposition</a></li><ul><li><a href="#Convenience-functions">Convenience functions</a></li></ul><li><a href="#Overapproximations">Overapproximations</a></li><li><a href="#Underapproximations">Underapproximations</a></li><li><a href="#Approximations-2">Approximations</a></li><li><a href="#Box-Approximations">Box Approximations</a></li><li><a href="#Iterative-refinement">Iterative refinement</a></li><li><a href="#Template-directions">Template directions</a></li><li><a href="#Distances">Distances</a></li><ul><li><a href="#Infimum-distance">Infimum distance</a></li><li><a href="#Hausdorff-distance">Hausdorff distance</a></li></ul></ul></ul><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations" href="#LazySets.Approximations"><code>LazySets.Approximations</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Module <code>Approximations.jl</code> – polygonal approximation of convex sets through support vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/Approximations.jl#L3-L6">source</a></section></article><h2 id="Cartesian-Decomposition"><a class="docs-heading-anchor" href="#Cartesian-Decomposition">Cartesian Decomposition</a><a id="Cartesian-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Cartesian-Decomposition" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.decompose" href="#LazySets.Approximations.decompose"><code>LazySets.Approximations.decompose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">decompose(S::LazySet{N},
          partition::AbstractVector{&lt;:AbstractVector{Int}},
          block_options
         ) where {N}</code></pre><p>Decompose a high-dimensional set into a Cartesian product of overapproximations of the projections over the specified subspaces.</p><p><strong>Input</strong></p><ul><li><code>S</code>             – set</li><li><code>partition</code>     – vector of blocks (i.e., of vectors of integers) (see the                    Notes below)</li><li><code>block_options</code> – mapping from block indices in <code>partition</code> to a                    corresponding overapproximation option; we only require                    access via <code>[⋅]</code> (but see also the Notes below)</li></ul><p><strong>Output</strong></p><p>A <code>CartesianProductArray</code> containing the low-dimensional approximated projections.</p><p><strong>Algorithm</strong></p><p>For each block a specific <code>project</code> method is called, dispatching on the corresponding overapproximation option.</p><p><strong>Notes</strong></p><p>The argument <code>partition</code> requires some discussion. Typically, the list of blocks should form a partition of the set <span>$\{1, \dots, n\}$</span> represented as a list of consecutive blocks, where <span>$n$</span> is the ambient dimension of set <code>S</code>.</p><p>However, technically there is no problem if the blocks are not consecutive, blocks are missing, blocks occur more than once, or blocks are overlapping. This function will, however, stick to the order of blocks, so the resulting set must be interpreted with care in such cases. One use case is the need of a projection consisting of several blocks.</p><p>For convenience, the argument <code>block_options</code> can also be given as a single option instead of a mapping, which is then interpreted as the option for all blocks.</p><p><strong>Examples</strong></p><p>This function supports different options: one can specify the target set, the degree of accuracy, and template directions. These options are exemplified below, where we use the following example.</p><pre><code class="language-julia-repl">julia&gt; using LazySets.Approximations: decompose

julia&gt; S = Ball2(zeros(4), 1.);  # set to be decomposed (4D 2-norm unit ball)

julia&gt; P2d = [1:2, 3:4];  # a partition with two blocks of size two

julia&gt; P1d = [[1], [2], [3], [4]];  # a partition with four blocks of size one</code></pre><p><strong>Different set types</strong></p><p>We can decompose using polygons in constraint representation:</p><pre><code class="language-julia-repl">julia&gt; all([ai isa HPolygon for ai in array(decompose(S, P2d, HPolygon))])
true</code></pre><p>For decomposition into 1D subspaces, we can use <code>Interval</code>:</p><pre><code class="language-julia-repl">julia&gt; all([ai isa Interval for ai in array(decompose(S, P1d, Interval))])
true</code></pre><p>However, if you need to specify different set types for different blocks, the interface presented so far does not apply. See the paragraph <em>Advanced input for different block approximations</em> below for how to do that.</p><p><strong>Refining the decomposition I: <span>$ε$</span>-close approximation</strong></p><p>The <span>$ε$</span> option can be used to refine a decomposition, i.e., obtain a more accurate result. We use the <a href="#Iterative-refinement">Iterative refinement</a> algorithm from the <code>Approximations</code> module.</p><p>To illustrate this, consider again the set <code>S</code> from above. We decompose into two 2D polygons. Using smaller <span>$ε$</span> implies a better precision, thus more constraints in each 2D decomposition. In the following example, we look at the number of constraints in the first block.</p><pre><code class="language-julia-repl">julia&gt; d(ε, bi) = array(decompose(S, P2d, (HPolygon =&gt; ε)))[bi]
d (generic function with 1 method)

julia&gt; [length(constraints_list(d(ε, 1))) for ε in [Inf, 0.1, 0.01]]
3-element Array{Int64,1}:
  4
  8
 32</code></pre><p><strong>Refining the decomposition II: template polyhedra</strong></p><p>Another way to refine a decomposition is by using template polyhedra. The idea is to specify a set of template directions and then to compute on each block the polytopic overapproximation obtained by evaluating the support function of the given input set over the template directions.</p><p>For example, octagonal 2D approximations of the set <code>S</code> are obtained with:</p><pre><code class="language-julia-repl">julia&gt; using LazySets.Approximations: OctDirections

julia&gt; B = decompose(S, P2d, OctDirections);

julia&gt; length(B.array) == 2 &amp;&amp; all(dim(bi) == 2 for bi in B.array)
true</code></pre><p>See <a href="#Template-directions">Template directions</a> for the available template directions. Note that, in contrast to the polygonal <span>$ε$</span>-close approximation from above, this method can be applied to blocks of any size.</p><pre><code class="language-julia-repl">julia&gt; B = decompose(S, [1:4], OctDirections);

julia&gt; length(B.array) == 1 &amp;&amp; dim(B.array[1]) == 4
true</code></pre><p><strong>Advanced input for different block approximations</strong></p><p>Instead of defining the approximation option uniformly for each block, we can define different approximations for different blocks. The third argument has to be a mapping from block index (in the partition) to the corresponding approximation option.</p><p>For example:</p><pre><code class="language-julia-repl">julia&gt; res = array(decompose(S, P2d, Dict(1 =&gt; Hyperrectangle, 2 =&gt; 0.1)));

julia&gt; typeof(res[1]), typeof(res[2])
(Hyperrectangle{Float64,Array{Float64,1},Array{Float64,1}}, HPolygon{Float64,Array{Float64,1}})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/decompositions.jl#L69-L220">source</a></section></article><h3 id="Convenience-functions"><a class="docs-heading-anchor" href="#Convenience-functions">Convenience functions</a><a id="Convenience-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.uniform_partition" href="#LazySets.Approximations.uniform_partition"><code>LazySets.Approximations.uniform_partition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> uniform_partition(n::Int, block_size::Int)</code></pre><p>Compute a uniform block partition of the given size.</p><p><strong>Input</strong></p><ul><li><code>n</code>          – number of dimensions of the partition</li><li><code>block_size</code> – size of each block</li></ul><p><strong>Output</strong></p><p>A vector of ranges, <code>Vector{UnitRange{Int}}</code>, such that the size of each block is the same, if possible.</p><p><strong>Examples</strong></p><p>If the number of dimensions <code>n</code> is 2, we have two options: either two blocks of size <code>1</code> or one block of size <code>2</code>:</p><pre><code class="language-julia-repl">julia&gt; LazySets.Approximations.uniform_partition(2, 1)
2-element Array{UnitRange{Int64},1}:
 1:1
 2:2

julia&gt; LazySets.Approximations.uniform_partition(2, 2)
1-element Array{UnitRange{Int64},1}:
 1:2</code></pre><p>If the block size argument is not compatible with (i.e. does not divide) <code>n</code>, the output is filled with one block of the size needed to reach <code>n</code>:</p><pre><code class="language-julia-repl">julia&gt; LazySets.Approximations.uniform_partition(3, 1)
3-element Array{UnitRange{Int64},1}:
 1:1
 2:2
 3:3

julia&gt; LazySets.Approximations.uniform_partition(3, 2)
2-element Array{UnitRange{Int64},1}:
 1:2
 3:3

julia&gt; LazySets.Approximations.uniform_partition(10, 6)
2-element Array{UnitRange{Int64},1}:
 1:6
 7:10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/decompositions.jl#L1-L52">source</a></section></article><h2 id="Overapproximations"><a class="docs-heading-anchor" href="#Overapproximations">Overapproximations</a><a id="Overapproximations-1"></a><a class="docs-heading-anchor-permalink" href="#Overapproximations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.overapproximate" href="#LazySets.Approximations.overapproximate"><code>LazySets.Approximations.overapproximate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">overapproximate(X::S, ::Type{S}, args...) where {S&lt;:LazySet}</code></pre><p>Overapproximating a set of type <code>S</code> with type <code>S</code> is a no-op.</p><p><strong>Input</strong></p><ul><li><code>X</code>       – set</li><li><code>Type{S}</code> – target set type</li><li><code>args</code>    – further arguments (ignored)</li></ul><p><strong>Output</strong></p><p>The input set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L7-L21">source</a></section><section><div><pre><code class="language-none">overapproximate(S::LazySet)</code></pre><p>Alias for <code>overapproximate(S, Hyperrectangle)</code> resp. <code>box_approximation(S)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L26-L30">source</a></section><section><div><pre><code class="language-none">overapproximate(S::LazySet, ::Type{&lt;:Hyperrectangle})</code></pre><p>Alias for <code>box_approximation(S)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L33-L37">source</a></section><section><div><pre><code class="language-none">overapproximate(S::LazySet, ::Type{&lt;:BallInf})</code></pre><p>Alias for <code>ballinf_approximation(S)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L47-L51">source</a></section><section><div><pre><code class="language-none">overapproximate(S::LazySet{N},
                ::Type{&lt;:HPolygon},
                [ε]::Real=Inf) where {N}</code></pre><p>Return an approximation of a given 2D set using iterative refinement.</p><p><strong>Input</strong></p><ul><li><code>S</code>        – convex set, assumed to be two-dimensional</li><li><code>HPolygon</code> – type for dispatch</li><li><code>ε</code>        – (optional, default: <code>Inf</code>) error tolerance</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p><p><strong>Notes</strong></p><p>The result is always a convex overapproximation of the input set.</p><p>If no error tolerance ε is given, or is <code>Inf</code>, the result is a box-shaped polygon. For convex input sets, the result is an ε-close approximation as a polygon, with respect to the Hausdorff distance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L56-L80">source</a></section><section><div><pre><code class="language-none">overapproximate(S::LazySet, ε::Real)</code></pre><p>Alias for <code>overapproximate(S, HPolygon, ε)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L111-L115">source</a></section><section><div><pre><code class="language-none">overapproximate(X::ConvexHull{N, &lt;:AbstractZonotope, &lt;:AbstractZonotope},
                ::Type{&lt;:Zonotope}) where {N}</code></pre><p>Overapproximate the convex hull of two zonotopes.</p><p><strong>Input</strong></p><ul><li><code>X</code>         – convex hull of two zonotopes</li><li><code>Zonotope</code>  – type for dispatch</li><li><code>algorithm</code> – (optional; default: <code>&quot;mean&quot;</code>) choice of algorithm; possible                values are <code>&quot;mean&quot;</code> and <code>&quot;join&quot;</code></li></ul><p><strong>Output</strong></p><p>A zonotope <span>$Z$</span> such that <span>$X ⊆ Z$</span>.</p><p><strong>Algorithm</strong></p><p>The algorithm can be controlled by the parameter <code>algorithm</code>. Note that the results of the two implemented algorithms are generally incomparable.</p><p><strong>&#39;mean&#39; method</strong></p><p>If <code>algorithm == &quot;mean&quot;</code>, we choose the method proposed in [1]. The convex hull of two zonotopes <span>$Z₁$</span> and <span>$Z₂$</span> of the same order, which we write</p><p class="math-container">\[Z_j = ⟨c^{(j)}, g^{(j)}_1, …, g^{(j)}_p⟩\]</p><p>for <span>$j = 1, 2$</span>, can be overapproximated as follows:</p><p class="math-container">\[CH(Z_1, Z_2) ⊆ \frac{1}{2}⟨c^{(1)}+c^{(2)}, g^{(1)}_1+g^{(2)}_1, …,
g^{(1)}_p+g^{(2)}_p, c^{(1)}-c^{(2)}, g^{(1)}_1-g^{(2)}_1, …, g^{(1)}_p-g^{(2)}_p⟩.\]</p><p>If the zonotope order is not the same, this algorithm calls <code>reduce_order</code> to reduce the order to the minimum of the arguments.</p><p>It should be noted that the output zonotope is not necessarily the minimal enclosing zonotope, which is in general expensive in high dimensions. This is further investigated in [2].</p><p><strong>&#39;join&#39; method</strong></p><p>If <code>algorithm == &quot;join&quot;</code>, we choose the method proposed in [3, Definition 1]. The convex hull <span>$X$</span> of two zonotopes <span>$Z₁$</span> and <span>$Z₂$</span> is overapproximated by a zonotope <span>$Z₃$</span> such that the box approximation of <span>$X$</span> is identical with the box approximation of <span>$Z₃$</span>. Let <span>$□(X)$</span> denote the box approximation of <span>$X$</span>. The center of <span>$Z₃$</span> is the center of <span>$□(X)$</span>.</p><p>The generator construction consists of two phases. In the first phase, we construct generators <span>$g$</span> as a combination of one generator from <span>$Z₁$</span>, say, <span>$g₁$</span>, with another generator from <span>$Z₂$</span>, say, <span>$g₂$</span>. The entry of <span>$g$</span> in the <span>$i$</span>-th dimension is given as</p><p class="math-container">\[    g[i] = \arg\min_{\min(g₁[i], g₂[i]) ≤ x ≤ \max(g₁[i], g₂[i])} |x|.\]</p><p>If <span>$g$</span> is the zero vector, it can be omitted.</p><p>In the second phase, we construct another generator for each dimension. These generators are scaled unit vectors. The following formula defines the sum of all those generators.</p><p class="math-container">\[    \sup(□(X)) - c - ∑_g |g|\]</p><p>where <span>$c$</span> is the center of the new zonotope and the <span>$g$</span>s are the generators constructed in the first phase.</p><p><strong>References</strong></p><p>[1] Reachability of Uncertain Linear Systems Using Zonotopes, A. Girard.     HSCC 2005.</p><p>[2] Zonotopes as bounding volumes, L. J. Guibas et al, Proc. of Symposium on     Discrete Algorithms, pp. 803-812.</p><p>[3] The zonotope abstract domain Taylor1+. K. Ghorbal, E. Goubault, S. Putot.     CAV 2009.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L130-L218">source</a></section><section><div><pre><code class="language-none">overapproximate(lm::LinearMap{N, &lt;:AbstractZonotope},
                ::Type{&lt;:Zonotope}) where {N}</code></pre><p>Overapproximate a lazy linear map of a zonotopic set with a zonotope.</p><p><strong>Input</strong></p><ul><li><code>lm</code>       – lazy linear map of a zonotopic set</li><li><code>Zonotope</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>The tight zonotope corresponding to <code>lm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L315-L329">source</a></section><section><div><pre><code class="language-none">overapproximate(X::LazySet{N}, dir::AbstractDirections; [prune]::Bool=true) where {N}</code></pre><p>Overapproximate a (possibly unbounded) set with template directions.</p><p><strong>Input</strong></p><ul><li><code>X</code>     – set</li><li><code>dir</code>   – (concrete) direction representation</li><li><code>prune</code> – (optional, default: <code>true</code>) flag for removing redundant            constraints in the end</li></ul><p><strong>Output</strong></p><p>A polyhedron overapproximating the set <code>X</code> with the directions from <code>dir</code>. The overapproximation is computed using support functions. If the obtained set is bounded, the result is an <code>HPolytope</code>. Otherwise the result is an <code>HPolyhedron</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L335-L352">source</a></section><section><div><pre><code class="language-none">overapproximate(X::LazySet{N}, dir::Type{&lt;:AbstractDirections}) where {N}</code></pre><p>Overapproximating a set with template directions.</p><p><strong>Input</strong></p><ul><li><code>X</code>   – set</li><li><code>dir</code> – type of direction representation</li></ul><p><strong>Output</strong></p><p>A polyhedron overapproximating the set <code>X</code> with the directions from <code>dir</code>. If the directions are known to be bounded, the result is an <code>HPolytope</code>, otherwise the result is an <code>HPolyhedron</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L405-L420">source</a></section><section><div><pre><code class="language-none">overapproximate(S::LazySet{N}, ::Type{&lt;:Interval}) where {N}</code></pre><p>Return the overapproximation of a unidimensional set with an interval.</p><p><strong>Input</strong></p><ul><li><code>S</code>        – one-dimensional set</li><li><code>Interval</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>An interval.</p><p><strong>Algorithm</strong></p><p>We use two support-function evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L426-L443">source</a></section><section><div><pre><code class="language-none">overapproximate(cap::Intersection, ::Type{&lt;:Interval})</code></pre><p>Return the overapproximation of a unidimensional intersection with an interval.</p><p><strong>Input</strong></p><ul><li><code>cap</code>      – one-dimensional lazy intersection</li><li><code>Interval</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>An interval.</p><p><strong>Algorithm</strong></p><p>The algorithm recursively overapproximates the two intersected sets with intervals and then intersects these.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L450-L468">source</a></section><section><div><pre><code class="language-none">overapproximate(cap::IntersectionArray, ::Type{&lt;:Interval})</code></pre><p>Return the overapproximation of a unidimensional intersection with an interval.</p><p><strong>Input</strong></p><ul><li><code>cap</code>      – one-dimensional lazy intersection</li><li><code>Interval</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>An interval.</p><p><strong>Algorithm</strong></p><p>The algorithm recursively overapproximates the two intersected sets with intervals and then intersects these.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L477-L495">source</a></section><section><div><pre><code class="language-none">overapproximate(cap::Intersection{N, &lt;:LazySet, &lt;:AbstractPolyhedron},
                dir::AbstractDirections;
                kwargs...
               ) where {N}</code></pre><p>Return the overapproximation of the intersection between a compact set and a polytope given a set of template directions.</p><p><strong>Input</strong></p><ul><li><code>cap</code>         – intersection of a compact set and a polytope</li><li><code>dir</code>         – template directions</li><li><code>kwargs</code>      – additional arguments that are passed to the support function                  algorithm</li></ul><p><strong>Output</strong></p><p>A polytope in H-representation such that the normal direction of each half-space is given by an element of <code>dir</code>.</p><p><strong>Algorithm</strong></p><p>Let <code>di</code> be a direction drawn from the set of template directions <code>dir</code>. Let <code>X</code> be the compact set and let <code>P</code> be the polytope. We overapproximate the set <code>X ∩ H</code> with a polytope in constraint representation using a given set of template directions <code>dir</code>.</p><p>The idea is to solve the univariate optimization problem <code>ρ(di, X ∩ Hi)</code> for each half-space in the set <code>P</code> and then take the minimum. This gives an overapproximation of the exact support function.</p><p>This algorithm is inspired from <a href="https://www.sciencedirect.com/science/article/pii/S1474667015371809">G. Frehse, R. Ray. Flowpipe-Guard Intersection for Reachability Computations with Support Functions</a>.</p><p><strong>Notes</strong></p><p>This method relies on having available the <code>constraints_list</code> of the polytope <code>P</code>.</p><p>This method of overapproximations can return a non-empty set even if the original intersection is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L541-L584">source</a></section><section><div><pre><code class="language-none">overapproximate(cap::Intersection{N, &lt;:HalfSpace, &lt;:AbstractPolytope},
                dir::AbstractDirections;
                [kwargs]...
               ) where {N}</code></pre><p>Return the overapproximation of the intersection between a half-space and a polytope given a set of template directions.</p><p><strong>Input</strong></p><ul><li><code>cap</code>         – intersection of a half-space and a polytope</li><li><code>dir</code>         – template directions</li><li><code>kwargs</code>      – additional arguments that are passed to the support function                  algorithm</li></ul><p><strong>Output</strong></p><p>A polytope in H-representation such that the normal direction of each half-space is given by an element of <code>dir</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L645-L665">source</a></section><section><div><pre><code class="language-none">overapproximate(lm::LinearMap{N, &lt;:CartesianProductArray},
                ::Type{CartesianProductArray{N, S}}
               ) where {N, S&lt;:LazySet}</code></pre><p>Decompose a lazy linear map of a Cartesian product array while keeping the original block structure.</p><p><strong>Input</strong></p><ul><li><code>lm</code>                    – lazy linear map of Cartesian product array</li><li><code>CartesianProductArray</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>A <code>CartesianProductArray</code> representing the decomposed linear map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L1068-L1084">source</a></section><section><div><pre><code class="language-none">overapproximate(lm::LinearMap{N, &lt;:CartesianProductArray},
                ::Type{&lt;:CartesianProductArray},
                dir::Type{&lt;:AbstractDirections}) where {N}</code></pre><p>Decompose a lazy linear map of a Cartesian product array with template directions while keeping the original block structure.</p><p><strong>Input</strong></p><ul><li><code>lm</code>                    – lazy linear map of a Cartesian product array</li><li><code>CartesianProductArray</code> – type for dispatch</li><li><code>dir</code>                   – template directions for overapproximation</li></ul><p><strong>Output</strong></p><p>A <code>CartesianProductArray</code> representing the decomposed linear map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L1093-L1110">source</a></section><section><div><pre><code class="language-none">overapproximate(lm::LinearMap{N, &lt;:CartesianProductArray},
                ::Type{&lt;:CartesianProductArray},
                set_type::Type{&lt;:LazySet}) where {N}</code></pre><p>Decompose a lazy linear map of a Cartesian product array with a given set type while keeping the original block structure.</p><p><strong>Input</strong></p><ul><li><code>lm</code>                    – lazy linear map of a Cartesian product array</li><li><code>CartesianProductArray</code> – type for dispatch</li><li><code>set_type</code>              – set type for overapproximation</li></ul><p><strong>Output</strong></p><p>A <code>CartesianProductArray</code> representing the decomposed linear map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L1119-L1136">source</a></section><section><div><pre><code class="language-none">overapproximate(rm::ResetMap{N, &lt;:CartesianProductArray},
                ::Type{&lt;:CartesianProductArray}, oa) where {N}</code></pre><p>Overapproximate a reset map (that only resets to zero) of a Cartesian product by a new Cartesian product.</p><p><strong>Input</strong></p><ul><li><code>rm</code>                    – reset map</li><li><code>CartesianProductArray</code> – type for dispatch</li><li><code>oa</code>                    – overapproximation option</li></ul><p><strong>Output</strong></p><p>A Cartesian product with the same block structure.</p><p><strong>Notes</strong></p><p>This implementation currently only supports resets to zero.</p><p><strong>Algorithm</strong></p><p>We convert the <code>ResetMap</code> into a <code>LinearMap</code> and then call the corresponding overapproximation method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L1171-L1196">source</a></section><section><div><pre><code class="language-none">overapproximate(cap::Intersection{N,
                                  &lt;:CartesianProductArray,
                                  &lt;:AbstractPolyhedron},
                ::Type{CartesianProductArray}, oa) where {N}</code></pre><p>Return the intersection of the Cartesian product of a finite number of convex sets and a polyhedron.</p><p><strong>Input</strong></p><ul><li><code>cap</code>                   – lazy intersection of a Cartesian product array and a polyhedron</li><li><code>CartesianProductArray</code> – type for dispatch</li><li><code>oa</code>                    – overapproximation option</li></ul><p><strong>Output</strong></p><p>A <code>CartesianProductArray</code> that overapproximates the intersection of <code>cpa</code> and <code>P</code>.</p><p><strong>Algorithm</strong></p><p>The intersection only needs to be computed in the blocks of <code>cpa</code> that are constrained in <code>P</code>. Hence we first collect those constrained blocks in a lower-dimensional Cartesian product array and then convert to an <code>HPolytope</code> <code>X</code>. Then we take the intersection of <code>X</code> and the projection of <code>Y</code> onto the corresponding dimensions. (This projection is purely syntactic and exact.) Finally we decompose the result again and plug together the unaffected old blocks and the newly computed blocks. The result is a <code>CartesianProductArray</code> with the same block structure as in <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L1207-L1239">source</a></section><section><div><pre><code class="language-none">overapproximate(Z::Zonotope{N}, ::Type{&lt;:Zonotope}, r::Union{Integer, Rational}) where {N}</code></pre><p>Reduce the order of a zonotope by overapproximating with a zonotope with less generators.</p><p><strong>Input</strong></p><ul><li><code>Z</code> – zonotope</li><li><code>Zonotope</code> – desired type for dispatch</li><li><code>r</code> – desired order</li></ul><p><strong>Output</strong></p><p>A new zonotope with less generators, if possible.</p><p><strong>Algorithm</strong></p><p>This function implements the algorithm described in A. Girard&#39;s <em>Reachability of Uncertain Linear Systems Using Zonotopes</em>, HSCC. Vol. 5. 2005.</p><p>If the desired order is smaller than one, the zonotope is <em>not</em> reduced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L1270-L1292">source</a></section><section><div><pre><code class="language-none">overapproximate(X::LazySet, ZT::Type{&lt;:Zonotope},
                dir::AbstractDirections;
                algorithm=&quot;vrep&quot;, kwargs...)</code></pre><p>Overapproximate a polytopic set with a zonotope.</p><p><strong>Input</strong></p><ul><li><code>X</code>         – polytopic set</li><li><code>Zonotope</code>  – type for dispatch</li><li><code>dir</code>       – directions used for the generators</li><li><code>algorithm</code> – (optional, default: <code>&quot;vrep&quot;</code>) method used to compute the overapproximation</li><li><code>kwargs</code>    – further algorithm choices</li></ul><p><strong>Output</strong></p><p>A zonotope that overapproximates <code>X</code> and uses at most the directions provided in <code>dir</code> (redundant directions will be ignored).</p><p><strong>Notes</strong></p><p>Two algorithms are available:</p><ul><li><p><code>&quot;vrep&quot;</code> – Overapproximate a polytopic set with a zonotope of minimal total generator sum             using only generators in the given directions. Under this constraint,             the zonotope has the minimal sum of generator vectors. See the docstring             of <a href="#LazySets.Approximations._overapproximate_zonotope_vrep"><code>_overapproximate_zonotope_vrep</code></a> for further details.</p></li><li><p><code>&quot;cpa&quot;</code> – Overapproximate a polytopic set with a zonotope using a cartesian            decomposition into two-dimensional blocks. See the docstring            of <a href="#LazySets.Approximations._overapproximate_zonotope_cpa"><code>_overapproximate_zonotope_cpa</code></a> for further details.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L1322-L1354">source</a></section><section><div><pre><code class="language-none">overapproximate(r::Rectification{N, &lt;:AbstractZonotope}, ::Type{&lt;:Zonotope}) where {N}</code></pre><p>Overapproximation of the rectification of a zonotopic set.</p><p><strong>Input</strong></p><ul><li><code>r</code> – lazy rectification of a zonotopic set</li><li><code>Zonotope</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>A zonotope overapproximation of the set obtained by rectifying <code>Z</code>.</p><p><strong>Algorithm</strong></p><p>This function implements [Theorem 3.1, 1].</p><p>[1] <em>Singh, G., Gehr, T., Mirman, M., Püschel, M., &amp; Vechev, M. (2018). Fast and effective robustness certification. In Advances in Neural Information Processing Systems (pp. 10802-10813).</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L1560-L1581">source</a></section><section><div><pre><code class="language-none">overapproximate(CHA::ConvexHullArray{N, &lt;:AbstractZonotope}, ::Type{&lt;:Zonotope}) where {N}</code></pre><p>Overapproximation of the convex hull array of zonotopic sets.</p><p><strong>Input</strong></p><ul><li><code>CHA</code> – convex hull array of zonotopic sets</li><li><code>Zonotope</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>A zonotope overapproximation of the convex hull array of zonotopic sets.</p><p><strong>Algorithm</strong></p><p>This function iteratively applies the overapproximation algorithm for the convex hull of two zonotopes to the given array of zonotopes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L1628-L1646">source</a></section><section><div><pre><code class="language-none">overapproximate(Z::AbstractZonotope, ::Type{&lt;:HParallelotope}, indices=1:dim(Z))</code></pre><p>Overapproximation of a zonotopic set with a parallelotopic set in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>Z</code>              – zonotopic set</li><li><code>HParallelotope</code> – type for dispatch</li><li><code>indices</code>        – (optional; default: <code>1:dim(Z)</code>) generator indices selected                      when constructing the parallelotope</li></ul><p><strong>Output</strong></p><p>An overapproximation of the given zonotope using a parallelotope.</p><p><strong>Algorithm</strong></p><p>The algorithm is based on Proposition 8 discussed in Section 5 of [1].</p><p>[1] Althoff, M., Stursberg, O., &amp; Buss, M. (2010). <em>Computing reachable sets of hybrid systems using a combination of zonotopes and polytopes</em>. Nonlinear analysis: hybrid systems, 4(2), 233-249.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L1661-L1685">source</a></section><section><div><pre><code class="language-none">overapproximate(X::Intersection{N, &lt;:AbstractZonotope, &lt;:Hyperplane},
                dirs::AbstractDirections) where {N}</code></pre><p>Overapproximation of the intersection between a zonotopic set and a hyperplane</p><p><strong>Input</strong></p><ul><li><code>X</code>    – intersection between a zonotopic set and a hyperplane</li><li><code>dirs</code> – type of direction representation</li></ul><p><strong>Output</strong></p><p>An overapproximation of the intersection between a zonotopic set and a hyperplane.</p><p><strong>Algorithm</strong></p><p>This function implements [Algorithm 8.1, 1].</p><p>[1] <em>Colas Le Guernic. Reachability Analysis of Hybrid Systems with Linear Continuous Dynamics. Computer Science [cs]. Université Joseph-Fourier - Grenoble I, 2009. English. fftel-00422569v2f</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L1708-L1730">source</a></section><section><div><pre><code class="language-none">overapproximate(vTM::Vector{TaylorModel1{T, S}},
                ::Type{&lt;:Zonotope}) where {T, S}</code></pre><p>Overapproximate a taylor model in one variable with a zonotope.</p><p><strong>Input</strong></p><ul><li><code>vTM</code>      – <code>TaylorModel1</code></li><li><code>Zonotope</code> –  type for dispatch</li></ul><p><strong>Output</strong></p><p>A zonotope that overapproximates the range of the given taylor model.</p><p><strong>Examples</strong></p><p>If the polynomials are linear, this functions exactly transforms to a zonotope. However, the nonlinear case necessarily introduces overapproximation error. Consider the linear case first:</p><pre><code class="language-julia">julia&gt; using LazySets, TaylorModels

julia&gt; const IA = IntervalArithmetic;

julia&gt; I = IA.Interval(-0.5, 0.5) # interval remainder
[-0.5, 0.5]

julia&gt; x₀ = IA.Interval(0.0) # expansion point
[0, 0]

julia&gt; D = IA.Interval(-3.0, 1.0)
[-3, 1]

julia&gt; p1 = Taylor1([2.0, 1.0], 2) # define a linear polynomial
 2.0 + 1.0 t + 𝒪(t³)

julia&gt; p2 = Taylor1([0.9, 3.0], 2) # define another linear polynomial
 0.9 + 3.0 t + 𝒪(t³)

julia&gt; vTM = [TaylorModel1(pi, I, x₀, D) for pi in [p1, p2]]
2-element Array{TaylorModel1{Float64,Float64},1}:
 2.0 + 1.0 t + [-0.5, 0.5]
 0.9 + 3.0 t + [-0.5, 0.5]</code></pre><p>Here, <code>vTM</code> is a taylor model vector, since each component is a taylor model in one variable (<code>TaylorModel1</code>). Using <code>overapproximate(vTM, Zonotope)</code> we can compute its associated zonotope in generator representation:</p><pre><code class="language-julia">julia&gt; using LazySets.Approximations

julia&gt; Z = overapproximate(vTM, Zonotope);

julia&gt; center(Z)
2-element Array{Float64,1}:
  1.0
 -2.1

julia&gt; Matrix(genmat(Z))
2×3 Array{Float64,2}:
 2.0  0.5  0.0
 6.0  0.0  0.5</code></pre><p>Note how the generators of this zonotope mainly consist of two pieces: one comes from the linear part of the polynomials, and another one that corresponds to the interval remainder. This conversion gives the same upper and lower bounds as the range evaluation using interval arithmetic:</p><pre><code class="language-julia">julia&gt; X = box_approximation(Z)
Hyperrectangle{Float64}([1.0, -2.1], [2.5, 6.5])

julia&gt; Y = evaluate(vTM[1], vTM[1].dom) × evaluate(vTM[2], vTM[2].dom)
[-1.5, 3.5] × [-8.60001, 4.40001]

julia&gt; H = convert(Hyperrectangle, Y) # this IntevalBox is the same as X
Hyperrectangle{Float64}([1.0, -2.1], [2.5, 6.5])</code></pre><p>However, the zonotope returns better results if we want to approximate the <code>TM</code>, since it is not axis-aligned:</p><pre><code class="language-julia">julia&gt; d = [-0.35, 0.93];

julia&gt; ρ(d, Z) &lt; ρ(d, X)
true</code></pre><p>This function also works if the polynomials are non-linear; for example suppose that we add a third polynomial with a quadratic term:</p><pre><code class="language-julia">julia&gt; p3 = Taylor1([0.9, 3.0, 1.0], 3);

julia&gt; vTM = [TaylorModel1(pi, I, x₀, D) for pi in [p1, p2, p3]]
3-element Array{TaylorModel1{Float64,Float64},1}:
           2.0 + 1.0 t + [-0.5, 0.5]
           0.9 + 3.0 t + [-0.5, 0.5]
  0.9 + 3.0 t + 1.0 t² + [-0.5, 0.5]

julia&gt; Z = overapproximate(vTM, Zonotope);

julia&gt; center(Z)
3-element Array{Float64,1}:
  1.0
 -2.1
  0.8999999999999999

julia&gt; Matrix(genmat(Z))
3×4 Array{Float64,2}:
 2.0  0.5  0.0  0.0
 6.0  0.0  0.5  0.0
 6.0  0.0  0.0  6.5</code></pre><p>The fourth and last generator corresponds to the addition between the interval remainder and the box overapproximation of the nonlinear part of <code>p3</code> over the domain.</p><p><strong>Algorithm</strong></p><p>Let <span>$\text{vTM} = (p, I)$</span> be a vector of <span>$m$</span> taylor models, where <span>$I$</span> is the interval remainder in <span>$\mathbb{R}^m$</span>. Let <span>$p_{lin}$</span> (resp. <span>$p_{nonlin}$</span>) correspond to the linear (resp. nonlinear) part of each scalar polynomial.</p><p>The range of <span>$\text{vTM}$</span> can be enclosed by a zonotope with center <span>$c$</span> and matrix of generators <span>$G$</span>, <span>$Z = ⟨c, G⟩$</span>, by performing a conservative linearization of <span>$\text{vTM}$</span>:</p><p class="math-container">\[    vTM&#39; = (p&#39;, I&#39;) := (p_{lin} − p_{nonlin} , I + \text{Int}(p_{nonlin})).\]</p><p>This algorithm proceeds in two steps:</p><p>1- Conservatively linearize <span>$\text{vTM}$</span> as above and compute a box    overapproximation of the nonlinear part. 2- Transform the linear taylor model to a zonotope exactly through variable    normalization onto the symmetric intervals <span>$[-1, 1]$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L718-L861">source</a></section><section><div><pre><code class="language-none">overapproximate(vTM::Vector{TaylorModelN{N, T, S}},
                ::Type{&lt;:Zonotope}) where {N,T, S}</code></pre><p>Overapproximate a multivariate taylor model with a zonotope.</p><p><strong>Input</strong></p><ul><li><code>vTM</code>      – <code>TaylorModelN</code></li><li><code>Zonotope</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>A zonotope that overapproximates the range of the given taylor model.</p><p><strong>Examples</strong></p><p>Consider a vector of two 2-dimensional taylor models of order 2 and 4 respectively.</p><pre><code class="language-julia">julia&gt; using LazySets, LazySets.Approximations, TaylorModels

julia&gt; const IA = IntervalArithmetic;

julia&gt; x₁, x₂ = set_variables(Float64, [&quot;x₁&quot;, &quot;x₂&quot;], order=8)
2-element Array{TaylorN{Float64},1}:
  1.0 x₁ + 𝒪(‖x‖⁹)
  1.0 x₂ + 𝒪(‖x‖⁹)

julia&gt; x₀ = IntervalBox(0..0, 2) # expansion point
[0, 0] × [0, 0]

julia&gt; Dx₁ = IA.Interval(0.0, 3.0) # domain for x₁
[0, 3]

julia&gt; Dx₂ = IA.Interval(-1.0, 1.0) # domain for x₂
[-1, 1]

julia&gt; D = Dx₁ × Dx₂ # take the Cartesian product of the domain on each variable
[0, 3] × [-1, 1]

julia&gt; r = IA.Interval(-0.5, 0.5) # interval remainder
[-0.5, 0.5]

julia&gt; p1 = 1 + x₁^2 - x₂
 1.0 - 1.0 x₂ + 1.0 x₁² + 𝒪(‖x‖⁹)

julia&gt; p2 = x₂^3 + 3x₁^4 + x₁ + 1
 1.0 + 1.0 x₁ + 1.0 x₂³ + 3.0 x₁⁴ + 𝒪(‖x‖⁹)

julia&gt; vTM = [TaylorModelN(pi, r, x₀, D) for pi in [p1, p2]]
2-element Array{TaylorModelN{2,Float64,Float64},1}:
             1.0 - 1.0 x₂ + 1.0 x₁² + [-0.5, 0.5]
   1.0 + 1.0 x₁ + 1.0 x₂³ + 3.0 x₁⁴ + [-0.5, 0.5]

julia&gt; Z = overapproximate(vTM, Zonotope);

julia&gt; center(Z)
2-element Array{Float64,1}:
   5.5
 124.0

julia&gt; Matrix(genmat(Z))
2×4 Array{Float64,2}:
 0.0  -1.0  5.0    0.0
 1.5   0.0  0.0  123.0</code></pre><p><strong>Algorithm</strong></p><p>We refer to the algorithm description for the univariate case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L875-L948">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations._overapproximate_zonotope_vrep" href="#LazySets.Approximations._overapproximate_zonotope_vrep"><code>LazySets.Approximations._overapproximate_zonotope_vrep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_overapproximate_zonotope_vrep(X::LazySet{N},
                               dir::AbstractDirections;
                               solver=default_lp_solver(N)) where {N}</code></pre><p>Overapproximate a polytopic set with a zonotope of minimal total generator sum using only generators in the given directions.</p><p><strong>Input</strong></p><ul><li><code>X</code>        – polytopic set</li><li><code>dir</code>      – directions used for the generators</li><li><code>solver</code>   – (optional, default: <code>default_lp_solver(N)</code>) the backend used to               solve the linear program</li></ul><p><strong>Output</strong></p><p>A zonotope that overapproximates <code>X</code> and uses at most the directions provided in <code>dir</code> (redundant directions will be ignored). Under this constraint, the zonotope has the minimal sum of generator vectors.</p><p><strong>Notes</strong></p><p>The algorithm only requires one representative of each generator direction and their additive inverse (e.g. only one of <code>[1, 0]</code> and <code>[-1, 0]</code>) and assumes that the directions are normalized. We preprocess the directions in that respect.</p><p><strong>Algorithm</strong></p><p>We solve a linear program parametric in the vertices <span>$v_j$</span> of <code>X</code> and the directions <span>$d_k$</span> in <code>dir</code> presented in Section 4.2 in [1], adapting the notation to the one used in this library.</p><p class="math-container">\[    \min \sum_{k=1}^l α_k \
    s.t. \
    c + \sum_{k=1}^l b_{kj} * d_k = v_j \quad \forall j \
    -α_k ≤ b_{kj} ≤ α_k \quad \forall k, j \
    α_k ≥ 0 \quad \forall k\]</p><p>The resulting zonotope has center <code>c</code> and generators <code>α_k · d_k</code>.</p><p>Note that the first type of side constraints is vector-based and that the nonnegativity constraints (last type) are not stated explicitly in [1].</p><p>[1] Zonotopes as bounding volumes, L. J. Guibas et al, Proc. of Symposium on     Discrete Algorithms, pp. 803-812.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L1374-L1423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations._overapproximate_zonotope_cpa" href="#LazySets.Approximations._overapproximate_zonotope_cpa"><code>LazySets.Approximations._overapproximate_zonotope_cpa</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_overapproximate_zonotope_cpa(X::LazySet, dir::Type{&lt;:AbstractDirections})</code></pre><p>Overapproximate a polytopic set with a zonotope using cartesian decomposition.</p><p><strong>Input</strong></p><ul><li><code>X</code>        – polytopic set</li><li><code>dir</code>      – directions used for the generators</li></ul><p><strong>Output</strong></p><p>A zonotope that overapproximates <code>X</code>.</p><p><strong>Notes</strong></p><p>The algorithm decomposes <code>X</code> in 2D sets and overapproximates those sets with zonotopes, and finally takes the cartesian product of the sets and converts to a zonotope.</p><p><strong>Algorithm</strong></p><p>The algorithm used is based on the section 8.2.4 of [1].</p><p>[1] Le Guernic, C. (2009). Reachability analysis of hybrid systems with linear continuous dynamics (Doctoral dissertation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/overapproximate.jl#L1503-L1528">source</a></section></article><h2 id="Underapproximations"><a class="docs-heading-anchor" href="#Underapproximations">Underapproximations</a><a id="Underapproximations-1"></a><a class="docs-heading-anchor-permalink" href="#Underapproximations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.underapproximate" href="#LazySets.Approximations.underapproximate"><code>LazySets.Approximations.underapproximate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">underapproximate(X::LazySet{N}, dirs::AbstractDirections;
                [apply_convex_hull]::Bool=false) where {N}</code></pre><p>Compute the underapproximation of a convex set by sampling support vectors.</p><p><strong>Input</strong></p><ul><li><code>X</code>                 – set</li><li><code>dirs</code>              – directions</li><li><code>apply_convex_hull</code> – (optional, default: <code>false</code>) if <code>true</code>, post-process                        the support vectors with a convex hull operation</li></ul><p><strong>Output</strong></p><p>The <code>VPolytope</code> obtained by taking the convex hull of the support vectors of <code>X</code> along the directions determined by <code>dirs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/underapproximate.jl#L1-L17">source</a></section></article><h2 id="Approximations-2"><a class="docs-heading-anchor" href="#Approximations-2">Approximations</a><a class="docs-heading-anchor-permalink" href="#Approximations-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.approximate" href="#LazySets.Approximations.approximate"><code>LazySets.Approximations.approximate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">approximate(R::Rectification; apply_convex_hull::Bool=false)</code></pre><p>Approximate a rectification of a polytopic set with a convex polytope.</p><p><strong>Input</strong></p><ul><li><code>R</code>                 – rectification</li><li><code>apply_convex_hull</code> – (optional; default: <code>false</code>) option to remove redundant                        vertices</li></ul><p><strong>Output</strong></p><p>A polytope in vertex representation. There is no guarantee that the result over- or underapproximates <code>R</code>.</p><p><strong>Algorithm</strong></p><p>Let <span>$X$</span> be the set that is rectified. We compute the vertices of <span>$X$</span>, rectify them, and return the convex hull of the result.</p><p><strong>Notes</strong></p><p>Let <span>$X$</span> be the set that is rectified and let <span>$p$</span> and <span>$q$</span> be two vertices on a facet of <span>$X$</span>. Intuitively, an approximation may occur if the line segment connecting these vertices crosses a coordinate hyperplane and if the line segment connecting the rectified vertices has a different angle.</p><p>As a corollary, the approximation is exact for the special cases that the original set is contained in either the positive or negative orthant or is axis-aligned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/approximate.jl#L1-L34">source</a></section></article><h2 id="Box-Approximations"><a class="docs-heading-anchor" href="#Box-Approximations">Box Approximations</a><a id="Box-Approximations-1"></a><a class="docs-heading-anchor-permalink" href="#Box-Approximations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.ballinf_approximation" href="#LazySets.Approximations.ballinf_approximation"><code>LazySets.Approximations.ballinf_approximation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ballinf_approximation(S::LazySet)</code></pre><p>Overapproximate a set by a tight ball in the infinity norm.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p>A tight ball in the infinity norm.</p><p><strong>Algorithm</strong></p><p>The center and radius of the box are obtained by evaluating the support function of the given convex set along the canonical directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/ballinf_approximation.jl#L5-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.box_approximation" href="#LazySets.Approximations.box_approximation"><code>LazySets.Approximations.box_approximation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">box_approximation(S::LazySet{N}) where {N}</code></pre><p>Overapproximate a set by a tight hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p>A tight hyperrectangle.</p><p><strong>Algorithm</strong></p><p>The center of the hyperrectangle is obtained by averaging the support function of the given set in the canonical directions, and the lengths of the sides can be recovered from the distance among support functions in the same directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/box_approximation.jl#L5-L23">source</a></section><section><div><pre><code class="language-none">box_approximation(S::CartesianProductArray{N, &lt;:AbstractHyperrectangle}) where {N}</code></pre><p>Return a tight overapproximation of the Cartesian product array of a finite number of convex sets with and hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>S</code>              – Cartesian product array of a finite number of convex set</li><li><code>Hyperrectangle</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>This method falls back to the corresponding <code>convert</code> method. Since the sets wrapped by the Cartesian product array are hyperrectangles, it can be done efficiently without overapproximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/box_approximation.jl#L94-L114">source</a></section><section><div><pre><code class="language-none">box_approximation(S::CartesianProduct{N, &lt;:AbstractHyperrectangle, &lt;:AbstractHyperrectangle}) where {N}</code></pre><p>Return a tight overapproximation of the Cartesian product of two hyperrectangles by a new hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>S</code>              – Cartesian product of two hyperrectangular sets</li><li><code>Hyperrectangle</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>This method falls back to the corresponding <code>convert</code> method. Since the sets wrapped by the Cartesian product are hyperrectangles, it can be done efficiently without overapproximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/box_approximation.jl#L119-L139">source</a></section><section><div><pre><code class="language-none">box_approximation(lm::LinearMap{N, &lt;:AbstractHyperrectangle}) where {N}</code></pre><p>Return a tight overapproximation of the linear map of a hyperrectangular set using a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>S</code>              – linear map of a hyperrectangular set</li><li><code>Hyperrectangle</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>If <code>c</code> and <code>r</code> denote the center and vector radius of a hyperrectangle <code>H</code>, a tight hyperrectangular overapproximation of <code>M * H</code> is obtained by transforming <code>c ↦ M*c</code> and <code>r ↦ abs.(M) * r</code>, where <code>abs.(⋅)</code> denotes the element-wise absolute value operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/box_approximation.jl#L144-L165">source</a></section><section><div><pre><code class="language-none">box_approximation(r::Rectification{N}) where {N}</code></pre><p>Overapproximate the rectification of a convex set by a tight hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>r</code>              – rectification of a convex set</li><li><code>Hyperrectangle</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>Box approximation and rectification distribute. Hence we first check whether the wrapped set is empty. If so, we return the empty set. Otherwise, we compute the box approximation of the wrapped set, rectify the resulting box (which is simple), and finally convert the resulting set to a box.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/box_approximation.jl#L173-L194">source</a></section><section><div><pre><code class="language-none">box_approximation(Z::AbstractZonotope)</code></pre><p>Return a tight overapproximation of a zonotope with an axis-aligned box.</p><p><strong>Input</strong></p><ul><li><code>Z</code>              – zonotope</li><li><code>Hyperrectangle</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>This function implements the method in [Section 5.1.2, 1]. A zonotope <span>$Z = ⟨c, G⟩$</span> can be overapproximated tightly by an axis-aligned box (i.e. a <code>Hyperrectangle</code>) such that its center is <span>$c$</span> and the radius along dimension <span>$i$</span> is the column-sum of the absolute values of the <span>$i$</span>-th row of <span>$G$</span> for <span>$i = 1,…, p$</span>, where <span>$p$</span> is the number of generators of <span>$Z$</span>.</p><p>[1] <em>Althoff, M., Stursberg, O., &amp; Buss, M. (2010). Computing reachable sets of hybrid systems using a combination of zonotopes and polytopes. Nonlinear analysis: hybrid systems, 4(2), 233-249.</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/box_approximation.jl#L202-L227">source</a></section><section><div><pre><code class="language-none">box_approximation(am::AbstractAffineMap{N, &lt;:AbstractHyperrectangle}) where {N}</code></pre><p>Overapproximate the affine map of a hyperrectangular set using a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><code>am</code>             – affine map of a hyperrectangular set</li><li><code>Hyperrectangle</code> – type for dispatch</li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Algorithm</strong></p><p>If <code>c</code> and <code>r</code> denote the center and vector radius of a hyperrectangle <code>H</code> and <code>v</code> the translation vector, a tight hyperrectangular overapproximation of <code>M * H + v</code> is obtained by transforming <code>c ↦ M*c+v</code> and <code>r ↦ abs.(M) * r</code>, where <code>abs.(⋅)</code> denotes the element-wise absolute value operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/box_approximation.jl#L233-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.interval_hull" href="#LazySets.Approximations.interval_hull"><code>LazySets.Approximations.interval_hull</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interval_hull</code></pre><p>Alias for <code>box_approximation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/box_approximation.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.box_approximation_symmetric" href="#LazySets.Approximations.box_approximation_symmetric"><code>LazySets.Approximations.box_approximation_symmetric</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">box_approximation_symmetric</code></pre><p>Alias for <code>symmetric_interval_hull</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/symmetric_interval_hull.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.symmetric_interval_hull" href="#LazySets.Approximations.symmetric_interval_hull"><code>LazySets.Approximations.symmetric_interval_hull</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">symmetric_interval_hull(S::LazySet{N}) where {N}</code></pre><p>Overapproximate a set by a tight hyperrectangle centered in the origin.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p>A tight hyperrectangle that is centrally symmetric wrt. the origin.</p><p><strong>Algorithm</strong></p><p>The center of the box is the origin, and the radius is obtained by computing the maximum value of the support function evaluated in the canonical directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/symmetric_interval_hull.jl#L5-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.box_approximation_helper" href="#LazySets.Approximations.box_approximation_helper"><code>LazySets.Approximations.box_approximation_helper</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">box_approximation_helper(S::LazySet{N}) where {N}</code></pre><p>Common code of <code>box_approximation</code> and <code>box_approximation_symmetric</code>.</p><p><strong>Input</strong></p><ul><li><code>S</code> – set</li></ul><p><strong>Output</strong></p><p>A tuple containing the data that is needed to construct a tightly overapproximating hyperrectangle.</p><ul><li><code>c</code> – center</li><li><code>r</code> – radius</li></ul><p><strong>Algorithm</strong></p><p>The center of the hyperrectangle is obtained by averaging the support function of the given set in the canonical directions. The lengths of the sides can be recovered from the distance among support functions in the same directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/box_approximation.jl#L39-L62">source</a></section></article><h2 id="Iterative-refinement"><a class="docs-heading-anchor" href="#Iterative-refinement">Iterative refinement</a><a id="Iterative-refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Iterative-refinement" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.LocalApproximation" href="#LazySets.Approximations.LocalApproximation"><code>LazySets.Approximations.LocalApproximation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LocalApproximation{N, VN&lt;:AbstractVector{N}}</code></pre><p>Type that represents a local approximation in 2D.</p><p><strong>Fields</strong></p><ul><li><code>p1</code>        – first inner point</li><li><code>d1</code>        – first direction</li><li><code>p2</code>        – second inner point</li><li><code>d2</code>        – second direction</li><li><code>q</code>         – intersection of the lines l1 ⟂ d1 at p1 and l2 ⟂ d2 at p2</li><li><code>refinable</code> – states if this approximation is refinable</li><li><code>err</code>       – error upper bound</li></ul><p><strong>Notes</strong></p><p>The criteria for being refinable are determined in the method <code>new_approx</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/iterative_refinement.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.PolygonalOverapproximation" href="#LazySets.Approximations.PolygonalOverapproximation"><code>LazySets.Approximations.PolygonalOverapproximation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PolygonalOverapproximation{N, SN&lt;:LazySet{N}, VN&lt;:AbstractVector{N}}</code></pre><p>Type that represents the polygonal approximation of a convex set.</p><p><strong>Fields</strong></p><ul><li><code>S</code>            – convex set</li><li><code>approx_stack</code> – stack of local approximations that still need to be examined</li><li><code>constraints</code>  – vector of linear constraints that are already finalized                   (i.e., they satisfy the given error bound)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/iterative_refinement.jl#L47-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.new_approx-Union{Tuple{VN}, Tuple{N}, Tuple{LazySet,VN,VN,VN,VN}} where VN&lt;:AbstractArray{N,1} where N&lt;:AbstractFloat" href="#LazySets.Approximations.new_approx-Union{Tuple{VN}, Tuple{N}, Tuple{LazySet,VN,VN,VN,VN}} where VN&lt;:AbstractArray{N,1} where N&lt;:AbstractFloat"><code>LazySets.Approximations.new_approx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">new_approx(S::LazySet, p1::VN, d1::VN,
           p2::VN, d2::VN) where {N&lt;:AbstractFloat, VN&lt;:AbstractVector{N}}</code></pre><p>Create a <code>LocalApproximation</code> instance for the given excerpt of a polygonal approximation.</p><p><strong>Input</strong></p><ul><li><code>S</code>  – convex set</li><li><code>p1</code> – first inner point</li><li><code>d1</code> – first direction</li><li><code>p2</code> – second inner point</li><li><code>d2</code> – second direction</li></ul><p><strong>Output</strong></p><p>A local approximation of <code>S</code> in the given directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/iterative_refinement.jl#L71-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.addapproximation!-Union{Tuple{VN}, Tuple{N}, Tuple{LazySets.Approximations.PolygonalOverapproximation,VN,VN,VN,VN}} where VN&lt;:AbstractArray{N,1} where N&lt;:Real" href="#LazySets.Approximations.addapproximation!-Union{Tuple{VN}, Tuple{N}, Tuple{LazySets.Approximations.PolygonalOverapproximation,VN,VN,VN,VN}} where VN&lt;:AbstractArray{N,1} where N&lt;:Real"><code>LazySets.Approximations.addapproximation!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addapproximation!(Ω::PolygonalOverapproximation, p1::VN, d1::VN,
                  p2::VN, d2::VN) where {N, VN&lt;:AbstractVector{N}}</code></pre><p><strong>Input</strong></p><ul><li><code>Ω</code>  – polygonal overapproximation of a convex set</li><li><code>p1</code> – first inner point</li><li><code>d1</code> – first direction</li><li><code>p2</code> – second inner point</li><li><code>d2</code> – second direction</li></ul><p><strong>Output</strong></p><p>The list of local approximations in <code>Ω</code> of the set <code>Ω.S</code> is updated in-place and the new approximation is returned by this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/iterative_refinement.jl#L107-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.refine-Tuple{LazySets.Approximations.LocalApproximation,LazySet}" href="#LazySets.Approximations.refine-Tuple{LazySets.Approximations.LocalApproximation,LazySet}"><code>LazySets.Approximations.refine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">refine(approx::LocalApproximation, S::LazySet)</code></pre><p>Refine a given local approximation of the polygonal approximation of a convex set by splitting along the normal direction of the approximation.</p><p><strong>Input</strong></p><ul><li><code>approx</code> – local approximation to be refined</li><li><code>S</code>      – 2D convex set</li></ul><p><strong>Output</strong></p><p>The tuple consisting of the refined right and left local approximations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/iterative_refinement.jl#L131-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.tohrep-Tuple{LazySets.Approximations.PolygonalOverapproximation}" href="#LazySets.Approximations.tohrep-Tuple{LazySets.Approximations.PolygonalOverapproximation}"><code>LazySets.Approximations.tohrep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tohrep(Ω::PolygonalOverapproximation)</code></pre><p>Convert a polygonal overapproximation into a concrete polygon.</p><p><strong>Input</strong></p><ul><li><code>Ω</code> – polygonal overapproximation of a convex set</li></ul><p><strong>Output</strong></p><p>A polygon in constraint representation.</p><p><strong>Algorithm</strong></p><p>Internally we keep the constraints sorted. Hence we do not need to use <code>addconstraint!</code> when creating the <code>HPolygon</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/iterative_refinement.jl#L155-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations._approximate-Union{Tuple{N}, Tuple{LazySet{N},N}} where N&lt;:AbstractFloat" href="#LazySets.Approximations._approximate-Union{Tuple{N}, Tuple{LazySet{N},N}} where N&lt;:AbstractFloat"><code>LazySets.Approximations._approximate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_approximate(S::LazySet{N}, ε::N) where {N&lt;:AbstractFloat}</code></pre><p>Return an ε-close approximation of the given 2D convex set (in terms of Hausdorff distance) as an inner and an outer approximation composed by sorted local <code>Approximation2D</code>.</p><p><strong>Input</strong></p><ul><li><code>S</code> – 2D convex set</li><li><code>ε</code> – error bound</li></ul><p><strong>Output</strong></p><p>An ε-close approximation of the given 2D convex set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/iterative_refinement.jl#L186-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.constraint-Tuple{LazySets.Approximations.LocalApproximation}" href="#LazySets.Approximations.constraint-Tuple{LazySets.Approximations.LocalApproximation}"><code>LazySets.Approximations.constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint(approx::LocalApproximation)</code></pre><p>Convert a local approximation to a linear constraint.</p><p><strong>Input</strong></p><ul><li><code>approx</code> – local approximation</li></ul><p><strong>Output</strong></p><p>A linear constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/iterative_refinement.jl#L30-L42">source</a></section></article><h2 id="Template-directions"><a class="docs-heading-anchor" href="#Template-directions">Template directions</a><a id="Template-directions-1"></a><a class="docs-heading-anchor-permalink" href="#Template-directions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.AbstractDirections" href="#LazySets.Approximations.AbstractDirections"><code>LazySets.Approximations.AbstractDirections</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractDirections{N, VN}</code></pre><p>Abstract type for template direction representations.</p><p><strong>Notes</strong></p><p>This type is parameterzed by <code>N</code> and <code>VN</code>, where:</p><ul><li><code>N</code> stands for the numeric type</li><li><code>VN</code> stands for the vector type with coefficients of type <code>N</code></li></ul><p>Each subtype is an iterator over a set of prescribed directions.</p><p>All subtypes should implement the standard iterator methods from <code>Base</code>, namely <code>Base.length</code> (returns the number of directions in the template), and <code>Base.iterate</code>. Moreover, the following methods should be implemented:</p><ul><li><code>dim</code>    – return the ambient dimension of the template</li><li><code>eltype</code> – return the type of each vector in the template</li></ul><p>Optionally, subtypes may implement:</p><ul><li><code>isbounding</code>   – (defaults to <code>false</code>) return <code>true</code> if an overapproximation with                   a list of template directions results in a bounded set, given a                   bounded input set, and <code>false</code> otherwise</li><li><code>isnormalized</code> – (defaults to <code>false</code>) returns <code>true</code> if each direction in the                   given template has norm one w.r.t. the usual vector 2-norm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/template_directions.jl#L4-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.isbounding" href="#LazySets.Approximations.isbounding"><code>LazySets.Approximations.isbounding</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isbounding(ad::Type{&lt;:AbstractDirections})</code></pre><p>Checks if an overapproximation with a list of template directions results in a bounded set, given a bounded input set.</p><p><strong>Input</strong></p><ul><li><code>ad</code> – template directions</li></ul><p><strong>Output</strong></p><p>Given a bounded set <span>$X$</span>, we can construct an outer approximation of <span>$X$</span> by using the template directions <code>ad</code> as normal vectors of the facets. If this function returns <code>true</code>, then the result is again a bounded set (i.e., a polytope). Note that the result does not depend on the specific shape of <span>$X$</span>, as long as <span>$X$</span> is bounded.</p><p><strong>Notes</strong></p><p>By default, this function returns <code>false</code> in order to be conservative. Custom subtypes of <code>AbstractDirections</code> should hence add a method for this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/template_directions.jl#L50-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.isnormalized" href="#LazySets.Approximations.isnormalized"><code>LazySets.Approximations.isnormalized</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isnormalized(ad::Type{&lt;:AbstractDirections})</code></pre><p>Returns whether the given template directions is normalized with respect to the 2-norm.</p><p><strong>Input</strong></p><ul><li><code>ad</code> – template directions</li></ul><p><strong>Output</strong></p><p><code>true</code> if the 2-norm of each element in <code>ad</code> is one and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/template_directions.jl#L81-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.project-Tuple{LazySet,AbstractArray{Int64,1},Type{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:LazySets.Approximations.AbstractDirections}" href="#LazySets.project-Tuple{LazySet,AbstractArray{Int64,1},Type{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:LazySets.Approximations.AbstractDirections}"><code>LazySets.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project(S::LazySet,
        block::AbstractVector{Int},
        directions::Type{&lt;:AbstractDirections},
        [n]::Int
       )</code></pre><p>Project a high-dimensional set to a given block using template directions.</p><p><strong>Input</strong></p><ul><li><code>S</code>          – set</li><li><code>block</code>      – block structure - a vector with the dimensions of interest</li><li><code>directions</code> – template directions</li><li><code>n</code>          – (optional, default: <code>dim(S)</code>) ambient dimension of the set <code>S</code></li></ul><p><strong>Output</strong></p><p>The template direction approximation of the projection of <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/template_directions.jl#L101-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.BoxDirections" href="#LazySets.Approximations.BoxDirections"><code>LazySets.Approximations.BoxDirections</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BoxDirections{N, VN} &lt;: AbstractDirections{N, VN}</code></pre><p>Box directions representation.</p><p><strong>Fields</strong></p><ul><li><code>n</code> – dimension</li></ul><p><strong>Notes</strong></p><p>Box directions can be seen as the vectors where only one entry is ±1, and all other entries are 0. In dimension <span>$n$</span>, there are <span>$2n$</span> such directions.</p><p>The default vector representation used in this template is a <code>LazySets.Arrays.SingleEntryVector</code>, although other implementations can be used such as a regular <code>Vector</code> and a sparse vector, <code>SparseVector</code>.</p><p><strong>Examples</strong></p><p>The template can be constructed by passing the dimension. For example, in dimension two,</p><pre><code class="language-julia-repl">julia&gt; dirs = BoxDirections(2)
BoxDirections{Float64,LazySets.Arrays.SingleEntryVector{Float64}}(2)

julia&gt; length(dirs)
4</code></pre><p>By default, each direction is represented in this iterator as a <code>SingleEntryVector</code>, i.e. a vector with only one non-zero element,</p><pre><code class="language-julia-repl">julia&gt; eltype(dirs)
LazySets.Arrays.SingleEntryVector{Float64}</code></pre><p>In two dimensions, the directions defined by <code>BoxDirections</code> are normal to the facets of a box.</p><pre><code class="language-julia-repl">julia&gt; collect(dirs)
4-element Array{LazySets.Arrays.SingleEntryVector{Float64},1}:
 [1.0, 0.0]
 [0.0, 1.0]
 [0.0, -1.0]
 [-1.0, 0.0]</code></pre><p>The numeric type can be specified as well:</p><pre><code class="language-julia-repl">julia&gt; BoxDirections{Rational{Int}}(10)
BoxDirections{Rational{Int64},LazySets.Arrays.SingleEntryVector{Rational{Int64}}}(10)

julia&gt; length(ans)
20</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/template_directions.jl#L134-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.OctDirections" href="#LazySets.Approximations.OctDirections"><code>LazySets.Approximations.OctDirections</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OctDirections{N, VN} &lt;: AbstractDirections{N, VN}</code></pre><p>Octagon directions representation.</p><p><strong>Fields</strong></p><ul><li><code>n</code> – dimension</li></ul><p><strong>Notes</strong></p><p>Octagon directions consist of all vectors that are zero almost everywhere except in two dimensions <span>$i$</span>, <span>$j$</span> (possibly <span>$i = j$</span>) where it is <span>$±1$</span>. In dimension <span>$n$</span>, there are <span>$2n^2$</span> such directions.</p><p><strong>Examples</strong></p><p>The template can be constructed by passing the dimension. For example, in dimension two,</p><pre><code class="language-julia-repl">julia&gt; dirs = OctDirections(2)
OctDirections{Float64,SparseArrays.SparseVector{Float64,Int64}}(2)

julia&gt; length(dirs) # number of directions
8</code></pre><p>By default, each direction is represented in this iterator as a sparse vector:</p><pre><code class="language-julia-repl">julia&gt; eltype(dirs)
SparseArrays.SparseVector{Float64,Int64}</code></pre><p>In two dimensions, the directions defined by <code>OctDirections</code> are normal to the facets of an octagon.</p><pre><code class="language-julia-repl">julia&gt; first(dirs)
2-element SparseArrays.SparseVector{Float64,Int64} with 2 stored entries:
  [1]  =  1.0
  [2]  =  1.0

julia&gt; Vector.(collect(dirs))
8-element Array{Array{Float64,1},1}:
 [1.0, 1.0]
 [1.0, -1.0]
 [-1.0, 1.0]
 [-1.0, -1.0]
 [1.0, 0.0]
 [0.0, 1.0]
 [0.0, -1.0]
 [-1.0, 0.0]</code></pre><p>The numeric type can be specified as well:</p><pre><code class="language-julia-repl">julia&gt; OctDirections{Rational{Int}}(10)
OctDirections{Rational{Int64},SparseArrays.SparseVector{Rational{Int64},Int64}}(10)

julia&gt; length(ans)
200</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/template_directions.jl#L250-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.BoxDiagDirections" href="#LazySets.Approximations.BoxDiagDirections"><code>LazySets.Approximations.BoxDiagDirections</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BoxDiagDirections{N, VN} &lt;: AbstractDirections{N, VN}</code></pre><p>Box-diagonal directions representation.</p><p><strong>Fields</strong></p><ul><li><code>n</code> – dimension</li></ul><p><strong>Notes</strong></p><p>Box-diagonal directions can be seen as the union of diagonal directions (all entries are ±1) and box directions (one entry is ±1, all other entries are 0). The iterator first enumerates all diagonal directions, and then all box directions. In dimension <span>$n$</span>, there are in total <span>$2^n + 2n$</span> such directions.</p><p><strong>Examples</strong></p><p>The template can be constructed by passing the dimension. For example, in dimension two,</p><pre><code class="language-julia-repl">julia&gt; dirs = BoxDiagDirections(2)
BoxDiagDirections{Float64,Array{Float64,1}}(2)

julia&gt; length(dirs) # number of directions
8</code></pre><p>By default, each direction is represented in this iterator as a regular vector:</p><pre><code class="language-julia-repl">julia&gt; eltype(dirs)
Array{Float64,1}</code></pre><p>In two dimensions, the directions defined by <code>BoxDiagDirections</code> are normal to the facets of an octagon.</p><pre><code class="language-julia-repl">julia&gt; collect(dirs)
8-element Array{Array{Float64,1},1}:
 [1.0, 1.0]
 [-1.0, 1.0]
 [1.0, -1.0]
 [-1.0, -1.0]
 [1.0, 0.0]
 [0.0, 1.0]
 [0.0, -1.0]
 [-1.0, 0.0]</code></pre><p>The numeric type can be specified as well:</p><pre><code class="language-julia-repl">julia&gt; BoxDiagDirections{Rational{Int}}(10)
BoxDiagDirections{Rational{Int64},Array{Rational{Int64},1}}(10)

julia&gt; length(ans)
1044</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/template_directions.jl#L418-L477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.PolarDirections" href="#LazySets.Approximations.PolarDirections"><code>LazySets.Approximations.PolarDirections</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PolarDirections{N&lt;:AbstractFloat, VN&lt;:AbstractVector{N}} &lt;: AbstractDirections{N, VN}</code></pre><p>Polar directions representation.</p><p><strong>Fields</strong></p><ul><li><code>Nφ</code> – length of the partition of the polar angle</li></ul><p><strong>Notes</strong></p><p>The <code>PolarDirections</code> constructor provides a sample of the unit sphere in <span>$\mathbb{R}^2$</span>, which is parameterized by the polar angle <span>$φ ∈ Dφ := [0, 2π]$</span>; see the wikipedia entry <a href="https://en.wikipedia.org/wiki/Polar_coordinate_system">Polar coordinate system</a> for details.</p><p>The integer argument <span>$Nφ$</span> defines how many samples of <span>$Dφ$</span> are taken. The Cartesian components of each direction are obtained with</p><p class="math-container">\[[cos(φᵢ), sin(φᵢ)].\]</p><p><strong>Examples</strong></p><p>The integer passed as an argument is used to discretize <span>$φ$</span>:</p><pre><code class="language-julia-repl">julia&gt; pd = PolarDirections(2);

julia&gt; pd.stack
2-element Array{Array{Float64,1},1}:
 [1.0, 0.0]
 [-1.0, 1.2246467991473532e-16]

julia&gt; length(pd)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/template_directions.jl#L530-L569">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.SphericalDirections" href="#LazySets.Approximations.SphericalDirections"><code>LazySets.Approximations.SphericalDirections</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SphericalDirections{N&lt;:AbstractFloat, VN&lt;:AbstractVector{N}} &lt;: AbstractDirections{N, VN}</code></pre><p>Spherical directions representation.</p><p><strong>Fields</strong></p><ul><li><code>Nθ</code>    – length of the partition of the azimuthal angle</li><li><code>Nφ</code>    – length of the partition of the polar angle</li><li><code>stack</code> – list of computed directions</li></ul><p><strong>Notes</strong></p><p>The <code>SphericalDirections</code> constructor provides a sample of the unit sphere in <span>$\mathbb{R}^3$</span>, which is parameterized by the azimuthal and polar angles <span>$θ ∈ Dθ := [0, π]$</span> and <span>$φ ∈ Dφ := [0, 2π]$</span> respectively, see the wikipedia entry <a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system">Spherical coordinate system</a> for details.</p><p>The integer arguments <span>$Nθ$</span> and <span>$Nφ$</span> define how many samples along the domains <span>$Dθ$</span> and <span>$Dφ$</span> respectively are taken. The Cartesian components of each direction are obtained with</p><p class="math-container">\[[sin(θᵢ)*cos(φᵢ), sin(θᵢ)*sin(φᵢ), cos(θᵢ)].\]</p><p>The north and south poles are treated separately so that those points are not considered more than once.</p><p><strong>Examples</strong></p><p>A <code>SphericalDirections</code> template can be built in different ways. If you pass only one integer, the same value is used to discretize both <span>$θ$</span> and <span>$φ$</span>:</p><pre><code class="language-julia-repl">julia&gt; sd = SphericalDirections(3);

julia&gt; sd.Nθ, sd.Nφ
(3, 3)

julia&gt; length(sd)
4</code></pre><p>Pass two integers to control the discretization in <span>$θ$</span> and in <span>$φ$</span> separately:</p><pre><code class="language-julia-repl">julia&gt; sd = SphericalDirections(4, 5);

julia&gt; length(sd)
10

julia&gt; sd = SphericalDirections(4, 8);

julia&gt; length(sd)
16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/template_directions.jl#L609-L667">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.CustomDirections" href="#LazySets.Approximations.CustomDirections"><code>LazySets.Approximations.CustomDirections</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CustomDirections{N, VN&lt;:AbstractVector{N}} &lt;: AbstractDirections{N, VN}</code></pre><p>User-defined template directions.</p><p><strong>Fields</strong></p><ul><li><code>directions</code> – list of template directions</li><li><code>n</code>          – dimension</li><li><code>isbounding</code> – boundedness status</li></ul><p><strong>Notes</strong></p><p>This struct is a wrapper type for a set of user-defined directions which are iterated over. It has fields for the list of directions, the set dimension, and (boolean) cache fields for the boundedness and normalization properties. The latter are checked by default upon construction.</p><p>To check boundedness, we overapproximate the unit ball in the infinity norm using the given directions and check if the resulting set is bounded.</p><p>The dimension will also be determined automatically, unless the empty vector is passed (in which case the optional argument <code>n</code> needs to be specified).</p><p><strong>Examples</strong></p><p>Creating a template with box directions in dimension two:</p><pre><code class="language-julia-repl">julia&gt; dirs = CustomDirections([[1.0, 0.0], [-1.0, 0.0], [0.0, 1.0], [0.0, -1.0]]);

julia&gt; dirs.directions
4-element Array{Array{Float64,1},1}:
 [1.0, 0.0]
 [-1.0, 0.0]
 [0.0, 1.0]
 [0.0, -1.0]

julia&gt; LazySets.Approximations.isbounding(dirs)
true

julia&gt; LazySets.Approximations.isnormalized(dirs)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/template_directions.jl#L719-L763">source</a></section></article><p>See also <code>overapproximate(X::LazySet, dir::AbstractDirections)::HPolytope</code>.</p><h2 id="Distances"><a class="docs-heading-anchor" href="#Distances">Distances</a><a id="Distances-1"></a><a class="docs-heading-anchor-permalink" href="#Distances" title="Permalink"></a></h2><h3 id="Infimum-distance"><a class="docs-heading-anchor" href="#Infimum-distance">Infimum distance</a><a id="Infimum-distance-1"></a><a class="docs-heading-anchor-permalink" href="#Infimum-distance" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="LazySets.Arrays.distance" href="#LazySets.Arrays.distance"><code>LazySets.Arrays.distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distance(x::AbstractVector, y::AbstractVector, p::Real=2.0)</code></pre><p>Compute the distance between two vectors with respect to the given <code>p</code>-norm, computed as</p><p class="math-container">\[    \|x - y\|_p = \left( \sum_{i=1}^n | x_i - y_i |^p \right)^{1/p}\]</p><p><strong>Input</strong></p><ul><li><code>x</code> – vector</li><li><code>y</code> – vector</li><li><code>p</code> – (optional, default: <code>2.0</code>) the <code>p</code>-norm used; <code>p = 2.0</code> corresponds to        the usual Euclidean norm</li></ul><p><strong>Output</strong></p><p>A scalar representing <span>$‖ x - y ‖_p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Arrays/vector_operations.jl#L357-L377">source</a></section><section><div><pre><code class="language-none">distance(H1::AbstractHyperrectangle, H2::AbstractHyperrectangle;
         [p]::Real=2)</code></pre><p>Compute the standard distance between two hyperrectangular sets, defined as</p><p class="math-container">\[    \inf_{x \in H_1, y \in H_2} \{ d(x, y) \}.\]</p><p><strong>Input</strong></p><ul><li><code>H1</code> – hyperrectangular set</li><li><code>H2</code> – hyperrectangular set</li><li><code>p</code>  – (optional; default: <code>2</code>) value of the <span>$p$</span>-norm</li></ul><p><strong>Output</strong></p><p>The distance, which is zero if the sets intersect and otherwise the <span>$p$</span>-norm of the shortest line segment between any pair of points.</p><p><strong>Notes</strong></p><p>See also <a href="#LazySets.Approximations.hausdorff_distance"><code>hausdorff_distance</code></a> for an alternative distance notion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/distance.jl#L3-L27">source</a></section><section><div><pre><code class="language-julia">distance(x::AbstractVector, L::Line, p::Real=2.0)</code></pre><p>Compute the distance between point <code>x</code> and the line with respect to the given <code>p</code>-norm.</p><p><strong>Input</strong></p><ul><li><code>x</code> – vector</li><li><code>L</code> – line</li><li><code>p</code> – (optional, default: <code>2.0</code>) the <code>p</code>-norm used; <code>p = 2.0</code> corresponds to        the usual Euclidean norm</li></ul><p><strong>Output</strong></p><p>A scalar representing the distance between <code>x</code> and the line <code>L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Sets/Line.jl#L465-L481">source</a></section><section><div><pre><code class="language-julia">distance(x::AbstractSingleton, L::Line, p::Real=2.0)</code></pre><p>Compute the distance between the singleton <code>x</code> and the line with respect to the given <code>p</code>-norm.</p><p><strong>Input</strong></p><ul><li><code>x</code> – singleton, i.e. a set with one element</li><li><code>L</code> – line</li><li><code>p</code> – (optional, default: <code>2.0</code>) the <code>p</code>-norm used; <code>p = 2.0</code> corresponds to        the usual Euclidean norm</li></ul><p><strong>Output</strong></p><p>A scalar representing the distance between the element wrapped by <code>x</code> and the line <code>L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Sets/Line.jl#L489-L505">source</a></section></article><h3 id="Hausdorff-distance"><a class="docs-heading-anchor" href="#Hausdorff-distance">Hausdorff distance</a><a id="Hausdorff-distance-1"></a><a class="docs-heading-anchor-permalink" href="#Hausdorff-distance" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="LazySets.Approximations.hausdorff_distance" href="#LazySets.Approximations.hausdorff_distance"><code>LazySets.Approximations.hausdorff_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hausdorff_distance(X::LazySet{N}, Y::LazySet{N}; [p]::N=N(Inf),
                   [ε]=N(1e-3)) where {N}</code></pre><p>Compute the Hausdorff distance between two convex sets up to a given threshold.</p><p><strong>Input</strong></p><ul><li><code>X</code> – convex set</li><li><code>Y</code> – convex set</li><li><code>p</code> – (optional, default: <code>Inf</code>) norm parameter of the Hausdorff distance</li><li><code>ε</code> – (optional, default: <code>1e-3</code>) precision threshold; the true Hausdorff        distance may diverge from the result by at most this value</li></ul><p><strong>Output</strong></p><p>A value from the <span>$ε$</span>-neighborhood of the Hausdorff distance between <span>$X$</span> and <span>$Y$</span>.</p><p><strong>Notes</strong></p><p>Given a <span>$p$</span>-norm, the Hausdorff distance <span>$d_H^p(X, Y)$</span> between sets <span>$X$</span> and <span>$Y$</span> is defined as follows:</p><p class="math-container">\[    d_H^p(X, Y) = \inf\{δ ≥ 0 \mid Y ⊆ X ⊕ δ 𝐵_p^n \text{ and } X ⊆ Y ⊕ δ 𝐵_p^n\}\]</p><p>Here <span>$𝐵_p^n$</span> is the <span>$n$</span>-dimensional unit ball in the <span>$p$</span>-norm.</p><p>The implementation may internally rely on the support function of <span>$X$</span> and <span>$Y$</span>; hence any imprecision in the implementation of the support function may affect the result. At the time of writing, the only set type with imprecise support function is the lazy <a href="../lazy_operations/Intersection/#LazySets.Intersection"><code>Intersection</code></a>.</p><p><strong>Algorithm</strong></p><p>We perform binary search for bounding the Hausdorff distance in an interval <span>$[l, u]$</span>, where initially <span>$l$</span> is <span>$0$</span> and <span>$u$</span> is described below. The binary search terminates when <span>$u - l ≤ ε$</span>, i.e., the interval becomes sufficiently small.</p><p>To find an upper bound <span>$u$</span>, we start with the heuristics of taking the biggest distance in the axis-parallel directions. As long as this bound does not work, we increase the bound by <span>$2$</span>.</p><p>Given a value <span>$δ$</span>, to check whether the sets are within Hausdorff distance <span>$δ$</span>, we simply check the inclusions given above, where on the right-hand side we use a lazy <code>Bloating</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/144578a06eca7f0c80cc6b10e1176b7ccc008519/src/Approximations/hausdorff_distance.jl#L3-L53">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../comparisons/">« Comparisons</a><a class="docs-footer-nextpage" href="../utils/">Utility Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 25 January 2021 22:50">Monday 25 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
